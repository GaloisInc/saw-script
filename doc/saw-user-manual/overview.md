# Overview

SAW, the Software Analysis Workbench, is a tool for working with
formal models of the computational behavior of software.
It supports numerous input languages and formats and can establish
proofs about many kinds of properties and relationships.
It also has some ability to transform these inputs into other forms
and output them.

There are three primary forms of input to SAW: code, prewritten formal
models, and scripting logic to glue things together.
SAW can load LLVM bitcode (typically output by the Clang compiler from
C or C++ sources), Java bytecode (as output by various Java virtual
machine tools), and, experimentally, the MIR intermediate
representation as used by the Rust compiler.
SAW can also, experimentally, load Verilog or VHDL hardware designs
processed by Yosys, as well as and-inverter graphs (AIGs) in AIGER
format.

Prewritten formal models are written in Cryptol.
(Code can be written in Cryptol as well.)
The scripting logic can be written in SAWScript (SAW's custom DSL
for the purpose), in Python, or (in principle) in any other language
supporting the remote procedure call API used by the Python bindings.


The formal models handled by SAW, whether prewritten or generated by
loading and symbolically executing code, are processed using a unified
internal representation called SAWCore.
It is also possible (though usually not recommended) to write models
directly in SAWCore.

Proofs are set up by scripting, and then resolved by various possible
methods.
Most proofs can be handled by automated proof tools: SAW supports a
range of SMT and SAT solvers.
Proofs that are too large, too complex, or too deep for solvers can be
exported to external proof tools, including the Rocq theorem prover.
SAW also has its own experimental interactive proof mode.

There are, of course, some restrictions and provisos.
The biggest limitation is that the symbolic execution SAW uses to
construct models from code needs to be bounded.
This means that the input programs must have fixed-size inputs and
outputs, and all loops (including recursion) must terminate after a
fixed number of iterations.
There are also some unsupported constructs in the LLVM, JVM, and
particularly MIR backends.

<!-- (there's no good place to stuff this in now, and it's not that important)
The
models take the form of typed functional programs, so in a sense SAW can
be considered a translator from imperative programs to their functional
equivalents.
-->

Perhaps the most common use case is to prove equivalence between an
algorithm specification written in Cryptol and an implementation
written in C, Java, or Rust.
It is also possible to prove refinements (for example, that one model
is a more complex or more elaborated version of another) and
bisimulations (correspondences between execution of two pieces of
code).
One can also prove properties about individual models.
For example, it is common for Cryptol specifications to contain
statements of properties that the specification should respect; SAW
can be used to prove these.

## Notation

:::{warning}
This section is under construction!
:::

## Outline

This manual is divided into three sections: first a user guide, which
introduces SAW, the role of Cryptol in SAW, the various modes and
fittings that SAW supports, and the SAWScript language.
The user guide is followed by a reference manual, which gives a
complete breakdown of SAW builtins and SAW functionality, as well as
the full specification for SAWScript and the remote procedure call API
used by the Python scripting interface.
Following these, a series of appendices provides additional
supplementary information.

## SAW Use Cases

:::{warning}
This section is under construction!
:::

## SAW Terminology

:::{warning}
This section is under construction!
:::

## Running Example

:::{warning}
This section is under construction!
:::
