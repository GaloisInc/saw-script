
----------------------------------
#decFieldPrime.spec#


method com.galois.ecc.P384ECC64.decFieldPrime
{
  var x                :: int[12];
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let r = ref_decFieldPrime(join(valueOf(x)));
  ensure valueOf(x) := split(r.rslt) : [12][32];
  return r.carry;
  verify { rewrite; yices; };
};

----------------------------------
add.saw

method com.galois.ecc.P384ECC64.add
{
  var z, x, y :: int[12];
  mayAlias { z, x, y };
  let x' = join(valueOf(x)) : [384];
  let y' = join(valueOf(y)) : [384];
  let z' = x' + y';
  ensure valueOf(z) := split(z') : [12][32];
  return if z' <u x' && z' <u y' then 1:[32] else 0:[32];
  verify yices;
};

----------------------------------
array_shift.saw

method com.galois.ecc.P384ECC64.array_shift
{
  var r :: int[12];
  let jr = join(valueOf(r));
  ensure valueOf(r) := split(jr << (32 : [9])) : [12][32];
  return aget(valueOf(r), 11 : [32]) # 0 : [32];
  verify abc;
};




----------------------------------
assign.saw

method com.galois.ecc.P384ECC64.assign
{
  var x, y :: int[12];
  ensure valueOf(x) := valueOf(y);
  verify abc;
};


----------------------------------
common.saw

// This SAWScript file contains definitions common to many proofs.  It
// also imports the SBV representations of functions from the
// Cryptol reference implementation.

let even(x:[384]) : Bit = (x & 1:[384]) == 0:[384];

// Define constants for P384 curve (taken from NIST and NSA documents).
let field_prime = <| 2^384 - 2^128 - 2^96 + 2^32 - 1 |> : [384];
let group_order = 0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973 : [384];

let basePointX = join(
  [ 0x72760ab7:[32], 0x3a545e38:[32], 0xbf55296c:[32], 0x5502f25d:[32],
    0x82542a38:[32], 0x59f741e0:[32], 0x8ba79b98:[32], 0x6e1d3b62:[32],
    0xf320ad74:[32], 0x8eb1c71e:[32], 0xbe8b0537:[32], 0xaa87ca22:[32]
  ]);
let basePointY = join(
  [ 0x90ea0e5f:[32], 0x7a431d7c:[32], 0x1d7e819d:[32], 0x0a60b1ce:[32],
    0xb5f0b8c0:[32], 0xe9da3113:[32], 0x289a147c:[32], 0xf8f41dbd:[32],
    0x9292dc29:[32], 0x5d9e98bf:[32], 0x96262c6f:[32], 0x3617de4a:[32]
  ]);
let basePoint = { x = basePointX ; y = basePointY };

let ref_aset_384(a:[384], i:[32], x:[32]) : [384] =
  join(aset(split(a):[12][32], i ,x)) : [384];

let ref_aset_768(a:[768], i:[32], x:[32]) : [768] =
  join(aset(split(a):[24][32], i ,x)) : [768];

pragma ref_aset_384 : SBV "aset_384";
pragma ref_aset_768 : SBV "aset_768";

extern SBV ref_mul_java_inner("../spec/sbv/generated/mul_java_inner.sbv") :
  ([32], [768], [32], [32], [32], [64]) -> { mji_a : [768]; mji_d : [64]};

extern SBV ref_mul_java("../spec/sbv/generated/mul_java.sbv") :
  ([768], [384], [384]) -> [768];

extern SBV ref_sq_java_loop("../spec/sbv/generated/sq_java_loop.sbv") :
  ([768], [384]) -> [768];

extern SBV ref_sq_java_inner1("../spec/sbv/generated/sq_java_inner1.sbv") :
  ([768], [32], [64]) -> { mji_a : [768]; mji_d : [64]};

extern SBV ref_sq_java_inner2("../spec/sbv/generated/sq_java_inner2.sbv") :
  ([768], [32], [32], [64]) -> { mji_a : [768]; mji_d : [64]};

extern SBV ref_sq_java("../spec/sbv/generated/sq_java.sbv") :
  ([768], [384]) -> [768];

let ref_safe_product(x:[384], y:[384]) : [768] = ref_mul_java(0 : [768], x, y);

pragma ref_safe_product : SBV "p384_safe_product";

extern SBV ref_incFieldPrime("../spec/sbv/generated/p384_incFieldPrime.sbv") 
  : [384] -> { carry : [32]; rslt : [384] };
extern SBV ref_decFieldPrime("../spec/sbv/generated/p384_decFieldPrime.sbv") 
  : [384] -> { carry : [32]; rslt : [384] };
extern SBV ref_field_mod("../spec/sbv/generated/p384_field_mod.sbv") : [768] -> [384];

extern SBV ref_group_red_aux("../spec/sbv/generated/group_red_aux_java.sbv")
  : ([384], [32], [32], [64], [64]) -> { gra_r : [384] ; gra_b : [64] };

extern SBV ref_group_red("../spec/sbv/generated/p384_group_red.sbv")
  : ([384], [384], [64]) -> [384];

extern SBV ref_group_mul_aux("../spec/sbv/generated/group_mul_aux_java.sbv")
  : ([384], [32], [32], [32], [64]) -> { gra_r : [384] ; gra_b : [64] };

extern SBV ref_group_mul("../spec/sbv/generated/p384_group_mul.sbv")
  : ([384], [384], [384]) -> [384];

extern SBV ref_group_add("../spec/sbv/generated/p384_group_add.sbv")    : ([384],[384]) -> [384];
extern SBV ref_mod_half("../spec/sbv/generated/p384_mod_half.sbv") : ([384], [384]) -> [384];
extern SBV ref_mod_add ("../spec/sbv/generated/p384_mod_add.sbv")
   : ([384], [384], [384]) -> [384];
extern SBV ref_mod_sub ("../spec/sbv/generated/p384_mod_sub.sbv")
   : ([384], [384], [384]) -> [384];

let ref_egcd(p:[384], a:[384], ra:[384], b:[384], rb:[384]) : [384] =
  if b == 0:[384] then
    ra
  else if even(b) then
    ref_egcd(p, a, ra, b       >>u 1:[384], ref_mod_half(p, rb))
  else if a <=u b then
    ref_egcd(p, a, ra, (b - a) >>u 1:[384], ref_mod_half(p, ref_mod_sub(p, rb, ra)))
  else 
    ref_egcd(p, b, rb, (a - b) >>u 1:[384], ref_mod_half(p, ref_mod_sub(p, ra, rb)));

let ref_mod_div(p:[384], x:[384], y:[384]) : [384] = ref_egcd(p, p, 0:[384], y, x);
pragma ref_mod_div : SBV "p384_mod_div"; // Declares that "ref_div" is "mod_div" in Cryptol.

extern SBV ref_is_field ("../spec/sbv/generated/p384_is_field_val.sbv") : [384] -> Bit;
extern SBV ref_field_add("../spec/sbv/generated/p384_field_add.sbv")    : ([384],[384]) -> [384];
extern SBV ref_field_sub("../spec/sbv/generated/p384_field_sub.sbv")    : ([384],[384]) -> [384];
extern SBV ref_field_neg("../spec/sbv/generated/p384_field_neg.sbv")    : [384] -> [384];
extern SBV ref_field_mul("../spec/sbv/generated/p384_field_mul.sbv")    : ([384],[384]) -> [384];
extern SBV ref_field_sq("../spec/sbv/generated/p384_field_sq.sbv")      : [384] -> [384];

extern SBV ref_ec_jacobify("../spec/sbv/generated/p384_ec_jacobify.sbv") :
  { x : [384]; y : [384] } -> { x : [384]; y : [384]; z : [384] };
extern SBV ref_ec_affinify("../spec/sbv/generated/p384_ec_affinify.sbv") :
  { x : [384]; y : [384]; z : [384] } -> { x : [384]; y : [384] };

extern SBV ref_ec_double("../spec/sbv/generated/p384_ec_double.sbv") :
  { x : [384]; y : [384]; z : [384] } -> { x : [384]; y : [384]; z : [384] };
extern SBV ref_ec_full_add("../spec/sbv/generated/p384_ec_full_add.sbv") 
  : ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) -> { x:[384]; y:[384]; z:[384] };
extern SBV ref_ec_full_sub("../spec/sbv/generated/p384_ec_full_sub.sbv") 
  : ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) -> { x:[384]; y:[384]; z:[384] };

extern SBV ref_ec_mul_init("../spec/sbv/generated/p384_ec_mul_init.sbv") :
  ([384], { x: [384]; y: [384] }) ->
  { h: [384]; r: { x: [384]; y: [384]; z: [384] } };

extern SBV ref_ec_mul_aux("../spec/sbv/generated/p384_ec_mul_aux.sbv") :
  ( { x: [384]; y: [384]; z: [384] }
  , { x: [384]; y:[384] }
  , [32]
  , [32]
  , [32]
  , [32]
  , [32]
  ) -> { x:[384]; y:[384]; z:[384] };

extern SBV ref_ec_mul("../spec/sbv/generated/p384_ec_mul.sbv") :
  ([384], { x: [384]; y: [384] }) -> { x: [384]; y: [384]; z: [384] };

extern SBV ref_ec_mul_window_aux("../spec/sbv/generated/p384_ec_mul_window_aux.sbv") :
  ( { h : [384] ; j : [32] ; r : { x : [384] ; y : [384] ;  z : [384] } }
  , [32], [32], [32], [32], [32], [32]
  , { x : [384] ; y : [384] }
  , { x : [384] ; y : [384] }
  , { x : [384] ; y : [384] }
  ) -> { h : [384] ; j : [32] ; r : { x : [384] ; y : [384] ;  z : [384] } };

extern SBV ref_ec_mul_window_finish("../spec/sbv/generated/p384_ec_mul_window_finish.sbv") :
  ( [32]
  , { x: [384]; y: [384]; z: [384] }
  , [32]
  , [32]
  , { x: [384]; y:[384] }
  ) -> { x:[384]; y:[384]; z:[384] };

/*
extern SBV ref_ec_mul_window ("../spec/sbv/generated/p384_ec_mul_window.sbv") :
  ([384],
   {x : [384]; y : [384]},
   {x : [384]; y : [384]},
   {x : [384]; y : [384]}) -> {x : [384];  y : [384];  z : [384]};
*/

extern SBV ref_ecdsa_sign("../spec/sbv/generated/p384_ecdsa_sign.sbv") :
  ([384], [384], [384]) -> { r:[384]; s:[384] };

extern SBV ref_ec_twin_mul_init("../spec/sbv/generated/p384_ec_twin_mul_init.sbv") :
  ([384], {x : [384];  y : [384]}, [384], {x : [384];  y : [384]}) ->
  { r : {x : [384]; y : [384]; z : [384]};
    sMt : {x : [384];  y : [384]};
    sPt : {x : [384];  y : [384]} };

extern SBV ref_ec_twin_mul_aux1("../spec/sbv/generated/p384_ec_twin_mul_aux1.sbv") :
  ( { x: [384]; y: [384]; z: [384] }
  , [32]
  , [32]
  , { x: [384]; y:[384] }
  , { x: [384]; y:[384] }
  , { x: [384]; y:[384] }
  , { x: [384]; y:[384] }
  )
  -> { x: [384]; y: [384]; z: [384] };

extern SBV ref_ec_twin_mul_aux2("../spec/sbv/generated/p384_ec_twin_mul_aux2.sbv") : 
  ([32],[32],[32],[32],[32],[32],[32],[32],[32]) -> 
    { tma2_u0:[32]; tma2_u1:[32]; tma2_c0':[32]; tma2_c1':[32]; tma2_e0':[32]; tma2_e1':[32]; tma2_sh':[32] };

extern SBV ref_ec_twin_mul_aux_f("../spec/sbv/generated/p384_ec_twin_mul_aux_F.sbv") : [32] -> [32];

----------------------------------
decFieldPrime.saw

import "common.saw";
import "rules.saw";
enable ref_decFieldPrime;
import "decFieldPrime.spec";

----------------------------------
decFieldPrime.spec


method com.galois.ecc.P384ECC64.decFieldPrime
{
  var x                :: int[12];
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let r = ref_decFieldPrime(join(valueOf(x)));
  ensure valueOf(x) := split(r.rslt) : [12][32];
  return r.carry;
  verify { rewrite; yices; };
};

----------------------------------
ec_double.saw

import "common.saw";
import "rules.saw";

set verification off;
import "is_zero.saw";
import "set_zero.saw";
import "set_unit.saw";
import "field_add.spec";
import "field_sub.spec";
import "field_dbl.spec";
import "field_mul.spec";
import "field_sq.spec";
set verification on;

enable ref_ec_double;
import "ec_double.spec";


----------------------------------
ec_double.spec

method com.galois.ecc.P384ECC64.ec_double 
{
  var r                 :: com.galois.ecc.JacobianPoint;
  var r.x, r.y, r.z     :: int[12];
  var this.t1, this.t2  :: int[12]; // ec_double changes t1 and t2
  var this.a            :: int[24]; // field_mul changes a
  var this.field_prime  :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_double({ x = join(valueOf(r.x))
                          ; y = join(valueOf(r.y))
                          ; z = join(valueOf(r.z))
                          });

  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];

  modify valueOf(this.t1), valueOf(this.t2), valueOf(this.a);

  verify rewrite;
};
disable ref_ec_double;

----------------------------------
ec_full_add.saw

import "common.saw";
import "rules.saw";

set verification off;
import "assign.saw";
import "is_zero.saw";
import "set_unit.saw";
import "set_zero.saw";
import "field_add.spec";
import "field_dbl.spec";
import "field_dbl_dec.spec";
import "field_sub.spec";
import "field_mul.spec";
import "field_sq.spec";
import "mod_half.spec";
import "ec_double.spec";
set verification on;

enable ref_ec_full_add;
import "ec_full_add.spec";

----------------------------------
ec_full_add.spec

method com.galois.ecc.P384ECC64.ec_full_add
{
  var r                         :: com.galois.ecc.JacobianPoint; 
  var t                         :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24]; // field_mul modifies field 'a'
  var this.t1, this.t2, this.t3 :: int[12]; // ec_full_add modifies these fields
  var r.x, r.y, r.z             :: int[12]; // Jacobian point members
  var t.x, t.y                  :: int[12]; // Affine point members
  var this.field_prime          :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_full_add( { x = join(valueOf(r.x))
                             ; y = join(valueOf(r.y))
                             ; z = join(valueOf(r.z))
                             }, 
                             { x = join(valueOf(t.x))
                             ; y = join(valueOf(t.y))
                             }
                           );

  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];

  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verify { rewrite; yices; };
};

----------------------------------
ec_full_sub.saw

import "common.saw";
import "rules.saw";

set verification off;
import "assign.saw";
import "is_zero.saw";
import "set_unit.saw";
import "set_zero.saw";
import "sub.saw";
import "ec_full_add.spec";
set verification on;

enable ref_ec_full_sub;
import "ec_full_sub.spec";



----------------------------------
ec_full_sub.spec

method com.galois.ecc.P384ECC64.ec_full_sub
{
  var r                         :: com.galois.ecc.JacobianPoint; 
  var t                         :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24]; // field_mul (via ec_full_add) modify field 'a'
  var this.t1, this.t2, this.t3 :: int[12]; // ec_full_add modify these fields
  var r.x, r.y, r.z             :: int[12]; // Jacobian point members
  var t.x, t.y                  :: int[12]; // Affine point members
  var this.field_prime          :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_full_sub( { x = join(valueOf(r.x))
                             ; y = join(valueOf(r.y))
                             ; z = join(valueOf(r.z))
                             }, 
                             { x = join(valueOf(t.x))
                             ; y = join(valueOf(t.y))
                             }
                           );

  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];

  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verify { rewrite; yices; };
};

----------------------------------
ec_mul.saw

import "common.saw";
import "rules.saw";

set verification off;
import "add.saw";
import "shr.saw";
import "set_zero.saw";
import "set_unit.saw";
import "assign.saw";
import "ec_mul_aux.spec";
import "ec_mul_init.spec";
set verification on;

enable ref_ec_mul;
import "ec_mul.spec";

----------------------------------
ec_mul.spec

method com.galois.ecc.P384ECC64.ec_mul
{
  var r                         :: com.galois.ecc.JacobianPoint;
  var d                         :: int[12];
  var s                         :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var r.x, r.y, r.z             :: int[12];
  var s.x, s.y                  :: int[12];
  var this.field_prime          :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_mul( join(valueOf(d)), 
                        { x = join(valueOf(s.x))
                        ; y = join(valueOf(s.y))
                        }
                      );

  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.h), valueOf(this.t1), 
    valueOf(this.t2), valueOf(this.t3);
  verify { rewrite; };
};

----------------------------------
ec_mul_aux.saw

import "common.saw";
import "rules.saw";

set verification off;
import "field_add.spec";
import "field_sub.spec";
import "field_dbl.spec";
import "field_mul.spec";
import "field_sq.spec";
import "ec_double.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
set verification on;

enable ref_ec_mul_aux;
import "ec_mul_aux.spec";

----------------------------------
ec_mul_aux.spec

method com.galois.ecc.P384ECC64.ec_mul_aux
{
  var r                         :: com.galois.ecc.JacobianPoint;
  var s                         :: com.galois.ecc.AffinePoint;
  var j, hi                     :: int;
  var i_lt_11                   :: boolean;
  var d_at_i, d_at_ip1          :: int;
  var this.a                    :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var r.x, r.y, r.z             :: int[12];
  var s.x, s.y                  :: int[12];
  var this.field_prime          :: int[12];

  assert j >=u 0:[32] && j <u 384:[32];                      // 0 <= j < 384
  assert i_lt_11 >=u 0:[32] && i_lt_11 <=u 1:[32];           // i_lt_11 is a boolean
  assert ((j >>u 5:[32]) <u 11:[32]) == (i_lt_11 >u 0:[32]); // i < 11 <=> i_lt_11
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_mul_aux( { x = join(valueOf(r.x))
                            ; y = join(valueOf(r.y))
                            ; z = join(valueOf(r.z))
                            }
                          , { x = join(valueOf(s.x))
                            ; y = join(valueOf(s.y))
                            }
                          , j, hi, i_lt_11, d_at_i, d_at_ip1 );
  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  verify { rewrite; yices; };
};

----------------------------------
ec_mul_init.saw

import "common.saw";
import "rules.saw";

enable ref_ec_mul_init;
import "ec_mul_init.spec";

----------------------------------
ec_mul_init.spec

method com.galois.ecc.P384ECC64.ec_mul_init
{
  var r                         :: com.galois.ecc.JacobianPoint;
  var d                         :: int[12];
  var s                         :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var r.x, r.y, r.z             :: int[12];
  var s.x, s.y                  :: int[12];
  var this.field_prime          :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_mul_init( join(valueOf(d)), 
                            { x = join(valueOf(s.x))
                            ; y = join(valueOf(s.y))
                            }
                           );

  ensure valueOf(r.x) := split(res.r.x) : [12][32];
  ensure valueOf(r.y) := split(res.r.y) : [12][32];
  ensure valueOf(r.z) := split(res.r.z) : [12][32];
  ensure valueOf(this.h) := split(res.h) : [12][32];

  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verify abc;
};

----------------------------------
ec_mul_window.saw

import "common.saw";
import "rules.saw";

set verification off;
import "add.saw";
import "shr.saw";
import "set_zero.saw";
import "set_unit.saw";
import "assign.saw";
import "field_add.spec";
import "field_sub.spec";
import "field_dbl.spec";
import "field_mul.spec";
import "field_sq.spec";
import "ec_double.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
import "ec_mul_init.spec";
import "ec_mul_window_aux.spec";
import "ec_mul_window_finish.spec";
set verification on;

enable ref_ec_mul_window;
import "ec_mul_window.qcspec";

----------------------------------
ec_mul_window_aux.saw

import "common.saw";
import "rules.saw";

set verification off;
import "ec_double.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
set verification on;

enable ref_ec_mul_window_aux;
import "ec_mul_window_aux.spec";

----------------------------------
ec_mul_window_aux.spec

method com.galois.ecc.P384ECC64.ec_mul_window_aux
{
  var j                         :: int;
  var r                         :: com.galois.ecc.JacobianPoint;
  var hi, kai, kip1             :: int;
  var hi2, kai2, ki2p1          :: int;
  var s, s3, s5                 :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var r.x, r.y, r.z             :: int[12];
  var s.x, s.y                  :: int[12];
  var s3.x, s3.y                :: int[12];
  var s5.x, s5.y                :: int[12];
  var this.field_prime          :: int[12];

  //assert j >=u 0:[32] && j <u 384:[32];                      // 0 <= j < 384

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_mul_window_aux( { h = 0:[384]
                                   ; j = j
                                   ; r = { x = join(valueOf(r.x))
                                         ; y = join(valueOf(r.y))
                                         ; z = join(valueOf(r.z))
                                         }
                                   }
                                 , hi, kai, kip1
                                 , hi2, kai2, ki2p1
                                 , { x = join(valueOf(s.x))
                                   ; y = join(valueOf(s.y))
                                   }
                                 , { x = join(valueOf(s3.x))
                                   ; y = join(valueOf(s3.y))
                                   }
                                 , { x = join(valueOf(s5.x))
                                   ; y = join(valueOf(s5.y))
                                   } );
  ensure valueOf(r.x) := split(res.r.x) : [12][32];
  //ensure valueOf(r.y) := split(res.r.y) : [12][32];
  //ensure valueOf(r.z) := split(res.r.z) : [12][32];

  return res.j;
  modify valueOf(r.x);
  modify valueOf(r.y);
  modify valueOf(r.z);
  modify valueOf(s.x);
  modify valueOf(s.y);
  modify valueOf(s3.x);
  modify valueOf(s3.y);
  modify valueOf(s5.x);
  modify valueOf(s5.y);
  modify valueOf(this.a), valueOf(this.h);
  modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  modify valueOf(this.field_prime);

  verify { rewrite; /*yices;*/ };
};

----------------------------------
ec_mul_window_finish.saw

import "common.saw";
import "rules.saw";

set verification off;
import "ec_double.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
set verification on;

enable ref_ec_mul_window_finish;
import "ec_mul_window_finish.spec";

----------------------------------
ec_mul_window_finish.spec

method com.galois.ecc.P384ECC64.ec_mul_window_finish
{
  var j, hi, ki                 :: int;
  var r                         :: com.galois.ecc.JacobianPoint;
  var s                         :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var r.x, r.y, r.z             :: int[12];
  var s.x, s.y                  :: int[12];
  var this.field_prime          :: int[12];

  assert j >=u 0:[32] && j <u 384:[32];                      // 0 <= j < 384

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ref_ec_mul_window_finish(j,
                                     { x = join(valueOf(r.x))
                                     ; y = join(valueOf(r.y))
                                     ; z = join(valueOf(r.z))
                                     },
                                     hi,
                                     ki,
                                     { x = join(valueOf(s.x))
                                     ; y = join(valueOf(s.y))
                                     });
  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];

  modify valueOf(s.x);
  modify valueOf(s.y);
  modify valueOf(this.a), valueOf(this.h);
  modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  modify valueOf(this.field_prime);

  verify { rewrite; yices; };
};

----------------------------------
ec_twin_mul.saw

import "common.saw";
import "rules.saw";

set verification off;
import "assign.saw";
import "is_equal.saw";
import "set_unit.saw";
import "set_zero.saw";
import "group_add.spec";
import "field_mul.spec";
import "field_sq.spec";
import "mod_sub.spec";
import "mod_div.spec";
import "ec_mul.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
import "ec_twin_mul_aux1.spec";
import "ec_twin_mul_aux2.spec";
import "ec_twin_mul_aux_f.spec";
import "ec_twin_mul_init.spec";
set verification on;

extern SBV ref_ec_twin_mul("../spec/sbv/generated/p384_ec_twin_mul.sbv") :
  ([384], { x: [384]; y: [384] }, [384], { x: [384]; y: [384] }) ->
  { x: [384]; y: [384]; z: [384] };

enable ref_ec_twin_mul;
import "ec_twin_mul.spec";

----------------------------------
ec_twin_mul.spec

method com.galois.ecc.P384ECC64.ec_twin_mul
{
  var r                         :: com.galois.ecc.JacobianPoint;
  var d0                        :: int[12];
  var s                         :: com.galois.ecc.AffinePoint;
  var d1                        :: int[12];
  var t                         :: com.galois.ecc.AffinePoint;
  var sPtP                      :: com.galois.ecc.JacobianPoint;
  var sMtP                      :: com.galois.ecc.JacobianPoint;
  var sPt                       :: com.galois.ecc.AffinePoint;
  var sMt                       :: com.galois.ecc.AffinePoint;
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var this.aux2Rslt             :: com.galois.ecc.TwinMulAux2Rslt;
  var this.aux2Rslt.u0          :: int;
  var this.aux2Rslt.u1          :: int;
  var this.aux2Rslt.c0p         :: int;
  var this.aux2Rslt.c1p         :: int;
  var this.aux2Rslt.e0p         :: int;
  var this.aux2Rslt.e1p         :: int;
  var this.aux2Rslt.shp         :: int;
  var r.x, r.y, r.z             :: int[12];
  var s.x, s.y                  :: int[12];
  var t.x, t.y                  :: int[12];
  var sPtP.x, sPtP.y, sPtP.z    :: int[12];
  var sMtP.x, sMtP.y, sMtP.z    :: int[12];
  var sPt.x, sPt.y              :: int[12];
  var sMt.x, sMt.y              :: int[12];
  var this.field_prime          :: int[12];
  var this.group_order          :: int[12];
  var this.field_unit           :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  assert valueOf(this.group_order) := split(group_order) : [12][32];
  assert valueOf(this.field_unit)  := split(1 : [384]) : [12][32];

  let d0' = join(valueOf(d0));
  let sx  = join(valueOf(s.x));
  let sy  = join(valueOf(s.y));
  let d1' = join(valueOf(d1));
  let tx  = join(valueOf(t.x));
  let ty  = join(valueOf(t.y));

  let res = ref_ec_twin_mul(d0', { x = sx; y = sy },
                            d1', { x = tx; y = ty });

  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];
  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];
  modify valueOf(this.a);
  modify valueOf(this.h), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  modify this.aux2Rslt.u0, this.aux2Rslt.u1,
         this.aux2Rslt.c0p, this.aux2Rslt.c1p,
         this.aux2Rslt.e0p, this.aux2Rslt.e1p, this.aux2Rslt.shp;

  modify valueOf(sPtP.x);
  modify valueOf(sPtP.y);
  modify valueOf(sPtP.z);
  modify valueOf(sMtP.x);
  modify valueOf(sMtP.y);
  modify valueOf(sMtP.z);
  modify valueOf(sPt.x);
  modify valueOf(sPt.y);
  modify valueOf(sMt.x);
  modify valueOf(sMt.y);

  verify { rewrite; };
};

----------------------------------
ec_twin_mul_aux1.saw

import "common.saw";
import "rules.saw";

set verification off;
import "field_add.spec";
import "field_sub.spec";
import "field_dbl.spec";
import "field_mul.spec";
import "field_sq.spec";
import "ec_double.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
set verification on;

enable ref_ec_twin_mul_aux1;
import "ec_twin_mul_aux1.spec";

----------------------------------
ec_twin_mul_aux1.spec

method com.galois.ecc.P384ECC64.ec_twin_mul_aux1
{
  var r                          :: com.galois.ecc.JacobianPoint;
  var u0, u1                     :: int;
  var sPt, s, sMt, t             :: com.galois.ecc.AffinePoint;
  var r.x, r.y, r.z              :: int[12];
  var sPt.x, sPt.y               :: int[12];
  var s.x, s.y                   :: int[12];
  var sMt.x, sMt.y               :: int[12];
  var t.x, t.y                   :: int[12];
  var this.a                     :: int[24];
  var this.t1, this.t2, this.t3  :: int[12];
  var this.field_prime           :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = 
    ref_ec_twin_mul_aux1( { x = join(valueOf(r.x)); y = join(valueOf(r.y)); z = join(valueOf(r.z)) }
                        , u0
                        , u1
                        , { x = join(valueOf(sPt.x)) ; y = join(valueOf(sPt.y)) }
                        , { x = join(valueOf(s.x))   ; y = join(valueOf(s.y))   }
                        , { x = join(valueOf(sMt.x)) ; y = join(valueOf(sMt.y)) }
                        , { x = join(valueOf(t.x))   ; y = join(valueOf(t.y))   }
                        );

  ensure valueOf(r.x) := split(res.x) : [12][32];
  ensure valueOf(r.y) := split(res.y) : [12][32];
  ensure valueOf(r.z) := split(res.z) : [12][32];

  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  verify { rewrite; yices; };
};

----------------------------------
ec_twin_mul_aux2.saw

import "common.saw";
import "rules.saw";
enable ref_ec_twin_mul_aux2;
import "ec_twin_mul_aux2.spec";

----------------------------------
ec_twin_mul_aux2.spec

method com.galois.ecc.P384ECC64.ec_twin_mul_aux2
{
  var c0, c1, e0, e1, shift, d0i, d1i           :: int;
  var dv1, dv2                                  :: boolean;
  var this.aux2Rslt                             :: com.galois.ecc.TwinMulAux2Rslt;
  var this.aux2Rslt.u0                          :: int;
  var this.aux2Rslt.u1                          :: int;
  var this.aux2Rslt.c0p                         :: int;
  var this.aux2Rslt.c1p                         :: int;
  var this.aux2Rslt.e0p                         :: int;
  var this.aux2Rslt.e1p                         :: int;
  var this.aux2Rslt.shp                         :: int;

  assert (shift >=s 0:[32]) && (shift <=s 31:[32]);

  let res = ref_ec_twin_mul_aux2(c0, c1, e0, e1, shift, d0i, d1i, dv1, dv2);

  ensure this.aux2Rslt.u0  := res.tma2_u0;
  ensure this.aux2Rslt.u1  := res.tma2_u1;
  ensure this.aux2Rslt.c0p := res.tma2_c0';
  ensure this.aux2Rslt.c1p := res.tma2_c1';
  ensure this.aux2Rslt.e0p := res.tma2_e0';  
  ensure this.aux2Rslt.e1p := res.tma2_e1';  
  ensure this.aux2Rslt.shp := res.tma2_sh';  

  verify { abc; };
};

----------------------------------
ec_twin_mul_aux_f.saw

import "common.saw";
import "rules.saw";
enable ref_ec_twin_mul_aux_f;
import "ec_twin_mul_aux_f.spec";

----------------------------------
ec_twin_mul_aux_f.spec

method com.galois.ecc.P384ECC64.ec_twin_mul_aux_f
{
  var t :: int;
  let res = ref_ec_twin_mul_aux_f(t);
  return res;
  verify { rewrite; yices; }; // Also discharges using only abc
};

----------------------------------
ec_twin_mul_init.saw

import "common.saw";
import "rules.saw";

set verification off;
import "assign.saw";
import "is_equal.saw";
import "set_unit.saw";
import "set_zero.saw";
import "group_add.spec";
import "field_mul.spec";
import "field_sq.spec";
import "mod_sub.spec";
import "mod_div.spec";
import "ec_mul.spec";
import "ec_double.spec";
import "ec_full_add.spec";
import "ec_full_sub.spec";
set verification on;

enable ref_ec_twin_mul_init;
import "ec_twin_mul_init.spec";

----------------------------------
ec_twin_mul_init.spec

method com.galois.ecc.P384ECC64.ec_twin_mul_init
{
  var r                          :: com.galois.ecc.JacobianPoint;
  var d0, d1                     :: int[12];
  var sPt, s, sMt, t             :: com.galois.ecc.AffinePoint;
  var r.x, r.y, r.z              :: int[12];
  var sPt.x, sPt.y               :: int[12];
  var s.x, s.y                   :: int[12];
  var sMt.x, sMt.y               :: int[12];
  var t.x, t.y                   :: int[12];
  var sPtP, sMtP                 :: com.galois.ecc.JacobianPoint;
  var sPtP.x, sPtP.y, sPtP.z     :: int[12];
  var sMtP.x, sMtP.y, sMtP.z     :: int[12];
  var this.a                     :: int[24];
  var this.h                     :: int[12];
  var this.t1, this.t2, this.t3  :: int[12];
  var this.field_prime           :: int[12];
  var this.field_unit            :: int[12];
  var this.group_order           :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  assert valueOf(this.field_unit)  := split(1 : [384])   : [12][32];
  assert valueOf(this.group_order) := split(group_order) : [12][32];

  let res =
    ref_ec_twin_mul_init( join(valueOf(d0))
                        , { x = join(valueOf(s.x)) ; y = join(valueOf(s.y)) }
                        , join(valueOf(d1))
                        , { x = join(valueOf(t.x)) ; y = join(valueOf(t.y)) }
                        );

  ensure valueOf(r.x) := split(res.r.x) : [12][32];
  ensure valueOf(r.y) := split(res.r.y) : [12][32];
  ensure valueOf(r.z) := split(res.r.z) : [12][32];
  let special = join(valueOf(s.x)) == join(valueOf(t.x));

  ensure valueOf(sPt.x) := split(res.sPt.x) : [12][32];
  ensure valueOf(sPt.y) := split(res.sPt.y) : [12][32];
  ensure valueOf(sMt.x) := split(res.sMt.x) : [12][32];
  ensure valueOf(sMt.y) := split(res.sMt.y) : [12][32];

  return special;

  modify valueOf(sPtP.x);
  modify valueOf(sPtP.y);
  modify valueOf(sPtP.z);
  modify valueOf(sMtP.x);
  modify valueOf(sMtP.y);
  modify valueOf(sMtP.z);

  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  modify valueOf(this.h);

  verify { rewrite; yices; };
};

----------------------------------
ecdsa_public_verify.saw

import "common.saw";
import "rules.saw";

set verification off;
import "leq.saw";
import "sub.saw";
import "mod_div.spec";
import "group_mul.spec";
import "assign.saw";
extern SBV ref_ec_twin_mul("../spec/sbv/generated/p384_ec_twin_mul.sbv") :
  ([384], { x: [384]; y: [384] }, [384], { x: [384]; y: [384] }) ->
  { x: [384]; y: [384]; z: [384] };
import "ec_twin_mul.spec";
import "is_zero.saw";
import "set_zero.saw";
import "field_sq.spec";
import "field_mul.spec";
import "is_equal.saw";
import "add.saw";
set verification on;

extern SBV ref_ecdsa_public_verify(
    "../spec/sbv/generated/p384_ecdsa_public_verify.sbv"
  ) : ([384], [384], [384], { x:[384]; y:[384] }) -> Bit;

enable ref_ecdsa_public_verify;
import "ecdsa_public_verify.spec";

----------------------------------
ecdsa_public_verify.spec

method com.galois.ecc.P384ECC64.verifySignature
{
  var hashValue                 :: int[12];
  var signature                 :: com.galois.ecc.Signature;
  var publicKey                 :: com.galois.ecc.PublicKey;
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var this.u1, this.u2          :: int[12];
  var signature.r, signature.s  :: int[12];
  var publicKey.x, publicKey.y  :: int[12];
  var this.qPoint               :: com.galois.ecc.AffinePoint;
  var this.qPoint.x             :: int[12];
  var this.qPoint.y             :: int[12];
  var this.rP                   :: com.galois.ecc.JacobianPoint;
  var this.rP.x                 :: int[12];
  var this.rP.y                 :: int[12];
  var this.rP.z                 :: int[12];
  var this.sPtP                 :: com.galois.ecc.JacobianPoint;
  var this.sPtP.x               :: int[12];
  var this.sPtP.y               :: int[12];
  var this.sPtP.z               :: int[12];
  var this.sMtP                 :: com.galois.ecc.JacobianPoint;
  var this.sMtP.x               :: int[12];
  var this.sMtP.y               :: int[12];
  var this.sMtP.z               :: int[12];
  var this.sPt                  :: com.galois.ecc.AffinePoint;
  var this.sPt.x                :: int[12];
  var this.sPt.y                :: int[12];
  var this.sMt                  :: com.galois.ecc.AffinePoint;
  var this.sMt.x                :: int[12];
  var this.sMt.y                :: int[12];
  var this.aux2Rslt             :: com.galois.ecc.TwinMulAux2Rslt;
  var this.aux2Rslt.u0          :: int;
  var this.aux2Rslt.u1          :: int;
  var this.aux2Rslt.c0p         :: int;
  var this.aux2Rslt.c1p         :: int;
  var this.aux2Rslt.e0p         :: int;
  var this.aux2Rslt.e1p         :: int;
  var this.aux2Rslt.shp         :: int;
  var this.basePoint            :: com.galois.ecc.AffinePoint;
  var this.basePoint.x          :: int[12];
  var this.basePoint.y          :: int[12];
  var this.field_prime          :: int[12];
  var this.group_order          :: int[12];
  var this.field_unit           :: int[12];

  let zero = split(0 : [384]) : [12][32];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  assert valueOf(this.group_order) := split(group_order) : [12][32];
  assert valueOf(this.field_unit)  := split(1 : [384])   : [12][32];
  assert this.width := 12 : [32];
  assert valueOf(this.basePoint.x)  := split(basePoint.x) : [12][32];
  assert valueOf(this.basePoint.y)  := split(basePoint.y) : [12][32];

  let e  = join(valueOf(hashValue));
  let r  = join(valueOf(signature.r));
  let s  = join(valueOf(signature.s));
  let qx = join(valueOf(publicKey.x));
  let qy = join(valueOf(publicKey.y));

  return ref_ecdsa_public_verify(e, r, s, {x = qx; y = qy});

  modify valueOf(this.a);

  ensure valueOf(this.h)      := zero;
  ensure valueOf(this.t1)     := zero;
  ensure valueOf(this.t2)     := zero;
  ensure valueOf(this.t3)     := zero;
  ensure valueOf(this.u1)     := zero;
  ensure valueOf(this.u2)     := zero;
  ensure valueOf(this.rP.x)   := zero;
  ensure valueOf(this.rP.y)   := zero;
  ensure valueOf(this.rP.z)   := zero;
  ensure valueOf(this.sPtP.x) := zero;
  ensure valueOf(this.sPtP.y) := zero;
  ensure valueOf(this.sPtP.z) := zero;
  ensure valueOf(this.sMtP.x) := zero;
  ensure valueOf(this.sMtP.y) := zero;
  ensure valueOf(this.sMtP.z) := zero;
  ensure valueOf(this.sPt.x)  := zero;
  ensure valueOf(this.sPt.y)  := zero;
  ensure valueOf(this.sMt.x)  := zero;
  ensure valueOf(this.sMt.y)  := zero;

  ensure this.aux2Rslt.u0  := 0:[32];
  ensure this.aux2Rslt.u1  := 0:[32];
  ensure this.aux2Rslt.c0p := 0:[32];
  ensure this.aux2Rslt.c1p := 0:[32];
  ensure this.aux2Rslt.e0p := 0:[32];
  ensure this.aux2Rslt.e1p := 0:[32];
  ensure this.aux2Rslt.shp := 0:[32];

  ensure valueOf(this.qPoint.x) := zero;
  ensure valueOf(this.qPoint.y) := zero;

  verify { rewrite; yices; };
};

----------------------------------
ecdsa_sign.saw

import "common.saw";
import "rules.saw";

set verification off;
import "assign.saw";
import "ec_mul.spec";
import "mod_div.spec";
import "field_sq.spec";
import "field_mul.spec";
import "leq.saw";
import "sub.saw";
import "group_mul.spec";
import "group_add.spec";
import "is_zero.saw";
import "set_zero.saw";
set verification on;

enable ref_ecdsa_sign;
import "ecdsa_sign.spec";

----------------------------------
ecdsa_sign.spec

method com.galois.ecc.P384ECC64.signHash
{
  var signature                 :: com.galois.ecc.Signature;
  var privateKey                :: int[12];
  var hashValue                 :: int[12];
  var ephemeralKey              :: int[12];
  var this.a                    :: int[24];
  var this.h                    :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];
  var this.u1, this.u2          :: int[12];
  var signature.r, signature.s  :: int[12];
  var this.width                :: int;
  var this.field_prime          :: int[12];
  var this.field_unit           :: int[12];
  var this.group_order          :: int[12];
  var this.rP                   :: com.galois.ecc.JacobianPoint;
  var this.rP.x                 :: int[12];
  var this.rP.y                 :: int[12];
  var this.rP.z                 :: int[12];
  var this.sPtP                 :: com.galois.ecc.JacobianPoint;
  var this.sPtP.x               :: int[12];
  var this.sPtP.y               :: int[12];
  var this.sPtP.z               :: int[12];
  var this.sMtP                 :: com.galois.ecc.JacobianPoint;
  var this.sMtP.x               :: int[12];
  var this.sMtP.y               :: int[12];
  var this.sMtP.z               :: int[12];
  var this.sPt                  :: com.galois.ecc.AffinePoint;
  var this.sPt.x                :: int[12];
  var this.sPt.y                :: int[12];
  var this.sMt                  :: com.galois.ecc.AffinePoint;
  var this.sMt.x                :: int[12];
  var this.sMt.y                :: int[12];
  var this.basePoint            :: com.galois.ecc.AffinePoint;
  var this.basePoint.x          :: int[12];
  var this.basePoint.y          :: int[12];
  var this.basePoint3           :: com.galois.ecc.AffinePoint;
  var this.basePoint3.x         :: int[12];
  var this.basePoint3.y         :: int[12];
  var this.basePoint5           :: com.galois.ecc.AffinePoint;
  var this.basePoint5.x         :: int[12];
  var this.basePoint5.y         :: int[12];
  var this.aux2Rslt             :: com.galois.ecc.TwinMulAux2Rslt;
  var this.aux2Rslt.u0          :: int;
  var this.aux2Rslt.u1          :: int;
  var this.aux2Rslt.c0p         :: int;
  var this.aux2Rslt.c1p         :: int;
  var this.aux2Rslt.e0p         :: int;
  var this.aux2Rslt.e1p         :: int;
  var this.aux2Rslt.shp         :: int;
  var this.qPoint               :: com.galois.ecc.AffinePoint;
  var this.qPoint.x             :: int[12];
  var this.qPoint.y             :: int[12];

  let b3 = {
    x = 0x077a41d4606ffa1464793c7e5fdc7d98cb9d3910202dcd06bea4f240d3566da6b408bbae5026580d02d7e5c70500c831 : [384];
    y = 0xc995f7ca0b0c42837d0bbe9602a9fc998520b41c85115aa5f7684c0edc111eacc24abd6be4b5d298b65f28600a2f1df1 : [384]
  };

  let b5 = {
    x = 0x11de24a2c251c777573cac5ea025e467f208e51dbff98fc54f6661cbe56583b037882f4a1ca297e60abcdbc3836d84bc : [384];
    y = 0x8fa696c77440f92d0f5837e90a00e7c5284b447754d5dee88c986533b6901aeb3177686d0ae8fb33184414abe6c1713a : [384]
  };

  assert valueOf(this.basePoint.x)  := split(basePoint.x) : [12][32];
  assert valueOf(this.basePoint.y)  := split(basePoint.y) : [12][32];
  assert valueOf(this.basePoint3.x) := split(b3.x)        : [12][32];
  assert valueOf(this.basePoint3.y) := split(b3.y)        : [12][32];
  assert valueOf(this.basePoint5.x) := split(b5.x)        : [12][32];
  assert valueOf(this.basePoint5.y) := split(b5.y)        : [12][32];
  assert valueOf(this.group_order)  := split(group_order) : [12][32];
  assert valueOf(this.field_prime)  := split(field_prime) : [12][32];
  assert valueOf(this.field_unit)   := split(1:[384])     : [12][32];
  assert this.width                 := 12                 : [32];

  let d = join(valueOf(privateKey));
  let e = join(valueOf(hashValue));
  let k = join(valueOf(ephemeralKey));
  assert not(d == 0:[384]);
  assert not(k == 0:[384]);
  assert not(group_order <=u d);
  assert not(group_order <=u k);

  let res = ref_ecdsa_sign(d, e, k);

  ensure valueOf(signature.r) := split(res.r) : [12][32];
  ensure valueOf(signature.s) := split(res.s) : [12][32];
  return res.r != 0:[384] && res.s != 0:[384];

  //ensure valueOf(this.a)      := split(0 : [768]) : [24][32];
  modify valueOf(this.a);

  ensure valueOf(this.h)      := split(0 : [384]) : [12][32];
  ensure valueOf(this.t1)     := split(0 : [384]) : [12][32];
  ensure valueOf(this.t2)     := split(0 : [384]) : [12][32];
  ensure valueOf(this.t3)     := split(0 : [384]) : [12][32];
  ensure valueOf(this.u1)     := split(0 : [384]) : [12][32];
  ensure valueOf(this.u2)     := split(0 : [384]) : [12][32];
  ensure valueOf(this.rP.x)   := split(0 : [384]) : [12][32];
  ensure valueOf(this.rP.y)   := split(0 : [384]) : [12][32];
  ensure valueOf(this.rP.z)   := split(0 : [384]) : [12][32];
  ensure valueOf(this.sPtP.x) := split(0 : [384]) : [12][32];
  ensure valueOf(this.sPtP.y) := split(0 : [384]) : [12][32];
  ensure valueOf(this.sPtP.z) := split(0 : [384]) : [12][32];
  ensure valueOf(this.sMtP.x) := split(0 : [384]) : [12][32];
  ensure valueOf(this.sMtP.y) := split(0 : [384]) : [12][32];
  ensure valueOf(this.sMtP.z) := split(0 : [384]) : [12][32];
  ensure valueOf(this.sPt.x)  := split(0 : [384]) : [12][32];
  ensure valueOf(this.sPt.y)  := split(0 : [384]) : [12][32];
  ensure valueOf(this.sMt.x)  := split(0 : [384]) : [12][32];
  ensure valueOf(this.sMt.y)  := split(0 : [384]) : [12][32];
  ensure this.aux2Rslt.u0  := 0:[32];
  ensure this.aux2Rslt.u1  := 0:[32];
  ensure this.aux2Rslt.c0p := 0:[32];
  ensure this.aux2Rslt.c1p := 0:[32];
  ensure this.aux2Rslt.e0p := 0:[32];
  ensure this.aux2Rslt.e1p := 0:[32];
  ensure this.aux2Rslt.shp := 0:[32];
  ensure valueOf(this.qPoint.x) := split(0 : [384]) : [12][32];
  ensure valueOf(this.qPoint.y) := split(0 : [384]) : [12][32];

  verify { rewrite; yices; };
};

----------------------------------
example1.saw

// Test a propertye on 100 randomly generated tests.

method Example.m1 {
  var args[0] : int;
  returns: (fromJava (args[0]) + fromJava (args[0]));
  verifyUsing: quickcheck 100;
};











----------------------------------
example2.saw

// Test a propertye on 100 randomly generated tests.
//
// If the property contains assumptions, then it is quite possible
// that some of the randomly generated inputs will fail the assumptions.
// Such tests are not interesting so, by default, we keep generating
// test inputs until we have passed 100 tests successfully.

method Example.m1 {
  var args[0] : int;
  assume fromJava(args[0]) == 0 : [32];
  returns: 0 : [32];
  verifyUsing: quickcheck 100;
};











----------------------------------
example3.saw

// Test a propertye on 100 randomly generated tests.
//
// If the property contains assumptions, then it is quite possible
// that some of the randomly generated inputs will fail the assumptions.
// Such tests are not interesting so, by default, we keep generating
// test inputs until we have passed 100 tests successfully.
//
// It is possible to specify an upper bound on the number of generated
// tests.  For example, here is how we would say that we'd like 100 tests
// to be passed but we are going to try at most 120 randomly generated inputs.

method Example.m1 {
  var args[0] : int;
  assume fromJava(args[0]) == 0 : [32];
  returns: 0 : [32];
  verifyUsing: quickcheck 100 120;
};


// This is what happens when we exhaust the number of examples:
//
// "example3.saw":12:1
//   QuickCheck: Failed to generate enough good inputs.
//     Attempts: 120
//     Passed: 4
//     Goal: 100








----------------------------------
example4.saw

// Test a propertye on 100 randomly generated tests.
//
// This shows what happens when we find a counter example.

method Example.m1 {
  var args[0] : int;
  returns: 0 : [32];
  verifyUsing: quickcheck 100;
};


// This is what happens when we find a counter example:
//
// "example4.saw":5:1
//   Random testing found a counter example:
//     Method: Example.m1
//     Unexpected value for: return value
//       Expected: 0:[32]
//       Found: 1745204022:[32]
//     Random arguments:
//       args[0] = 872602011:[32]





----------------------------------
field_add.saw

import "common.saw"; 
import "rules.saw";

enable ref_field_add;
import "field_add.spec";

----------------------------------
field_add.spec

method com.galois.ecc.P384ECC64.field_add 
{
  var z, x, y :: int[12];
  mayAlias { z, x, y };

  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  ensure valueOf(z) := split(ref_field_add(jx, jy)) : [12][32];

  verify { rewrite; yices; };
};

----------------------------------
field_dbl.saw

import "common.saw";
import "rules.saw";

enable ref_field_add;
import "field_dbl.spec";

----------------------------------
field_dbl.spec

method com.galois.ecc.P384ECC64.field_dbl
{
  var z, x             :: int[12];
  var this.field_prime :: int[12];
  mayAlias { z, x };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jx = join(valueOf(x));
  ensure
    valueOf(z) := split (ref_field_add(jx, jx)) : [12][32];
  verify { rewrite; yices; };
};


----------------------------------
field_dbl_dec.saw

import "common.saw";
import "rules.saw";

set verification off;
import "field_sub.spec";
set verification on;

enable ref_field_sub;
import "field_dbl_dec.spec";

----------------------------------
field_dbl_dec.spec

method com.galois.ecc.P384ECC64.field_dbl_dec
{
  var z, x             :: int[12];
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jz = join(valueOf(z));
  let jx = join(valueOf(x));
  ensure 
    valueOf(z) :=
      split (ref_field_sub(ref_field_sub(jz, jx), jx)) : [12][32];
  verify rewrite;
};


----------------------------------
field_mul.saw

import "common.saw";
import "rules.saw";

set verification off;
import "mul.spec";
import "field_red.spec";
set verification on;

rule mul_java_elim: forAll {a:[768], x:[384], y:[384]}.
  ref_mul_java(a, x, y) -> ref_safe_product(x, y);

enable ref_field_mul;
import "field_mul.spec";

----------------------------------
field_mul.spec

method com.galois.ecc.P384ECC64.field_mul 
{
  var z, x, y          :: int[12];
  var this.a           :: int[24];
  var this.field_prime :: int[12];
  mayAlias { z, x, y };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  ensure valueOf(z) := split(ref_field_mul(jx, jy)) : [12][32];
  modify valueOf(this.a);
  verify rewrite;
};

----------------------------------
field_mul3.saw

import "common.saw";
import "rules.saw";

set verification off;
import "field_dbl.spec";
import "field_add.spec";
set verification on;

import "field_mul3.spec";


----------------------------------
field_mul3.spec

method com.galois.ecc.P384ECC64.field_mul3
{
  var z, x             :: int[12];
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jx = join(valueOf(x));
  ensure 
    valueOf(z) := 
      split (ref_field_add(jx, ref_field_add(jx, jx))) : [12][32];
  verify rewrite;
};

----------------------------------
field_mul4.saw

import "common.saw";
import "rules.saw";

set verification off;
import "field_dbl.spec";
set verification on;

import "field_mul4.spec";

----------------------------------
field_mul4.spec

method com.galois.ecc.P384ECC64.field_mul4
{
  var z, x             :: int[12];
  var this.field_prime :: int[12];
  mayAlias { z, x };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jx  = join(valueOf(x));
  let dbl = ref_field_add(jx, jx);
  ensure 
    valueOf(z) := split (ref_field_add(dbl, dbl)) : [12][32];
  verify rewrite;
};

----------------------------------
field_mul8.saw

import "common.saw";
import "rules.saw";

set verification off;
import "field_dbl.spec";
set verification on;

import "field_mul8.spec";


----------------------------------
field_mul8.spec

method com.galois.ecc.P384ECC64.field_mul8
{
  var z, x             :: int[12];
  var this.field_prime :: int[12];
  mayAlias { z, x };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jx = join(valueOf(x));
  let x2 = ref_field_add(jx, jx);
  let x4 = ref_field_add(x2, x2);
  ensure 
    valueOf(z) := split (ref_field_add(x4, x4)) : [12][32];
  verify rewrite;
};

----------------------------------
field_red.saw

import "common.saw";

set verification off;
import "decFieldPrime.spec";
import "incFieldPrime.spec";
import "leq.saw";
set verification on;

enable ref_field_mod;
import "field_red.spec";

----------------------------------
field_red.spec

method com.galois.ecc.P384ECC64.field_red
{
  var z, this.field_prime :: int[12];
  var a                   :: int[24];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let a' = join(valueOf(a));
  ensure 
    valueOf(z) := split(ref_field_mod(a')) : [12][32];

  verify { abc; };
};

----------------------------------
field_sq.saw

import "common.saw";
import "rules.saw";

set verification off;
import "sq.spec";
import "field_red.spec";
set verification on;

rule sq_java_elim: forAll {a:[768], x:[384]}.
  ref_sq_java(a, x) -> ref_safe_product(x, x);

enable ref_field_sq;
import "field_sq.spec";

----------------------------------
field_sq.spec

method com.galois.ecc.P384ECC64.field_sq {
  var z, x             :: int[12];
  var this.a           :: int[24];
  var this.field_prime :: int[12];
  mayAlias { z, x };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(z) := split(ref_field_sq(join(valueOf(x)))) : [12][32];
  modify valueOf(this.a);
  verify rewrite;
};

----------------------------------
field_sub.saw

import "common.saw"; 
import "rules.saw";

enable ref_field_sub;
import "field_sub.spec";

----------------------------------
field_sub.spec

method com.galois.ecc.P384ECC64.field_sub 
{
  var z, x, y          :: int[12];
  var this.field_prime :: int[12];
  mayAlias { z, x, y };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  ensure valueOf(z) := split(ref_field_sub(jx, jy)) : [12][32];
  verify { rewrite; yices; };
};

----------------------------------
group_add.saw

import "common.saw"; 
import "rules.saw";

enable ref_mod_add;
import "group_add.spec";

----------------------------------
group_add.spec

method com.galois.ecc.P384ECC64.group_add
{
  var z, x, y          :: int[12];
  var this.group_order :: int[12];
  mayAlias { z, x, y };
  assert valueOf(this.group_order) := split(group_order) : [12][32];
  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  ensure valueOf(z) := split(ref_mod_add(group_order, jx, jy)) : [12][32];
  verify{ rewrite; yices; };
};

----------------------------------
group_mul.saw

import "common.saw"; 
import "rules.saw";

set verification off;
import "set_zero.saw";
import "group_red.spec";
import "array_shift.saw";
import "group_mul_aux.spec";
import "leq.saw";
import "sub.saw";
set verification on;

enable ref_group_mul;
import "group_mul.spec";

----------------------------------
group_mul.spec

method com.galois.ecc.P384ECC64.group_mul
{
  var r, x, y          :: int[12];
  var this.group_order :: int[12];
  assert valueOf(this.group_order) := split(group_order) : [12][32];
  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  ensure valueOf(r) := split(ref_group_mul(group_order, jx, jy)) : [12][32];
  verify { rewrite; };
};

----------------------------------
group_mul_aux.saw

import "common.saw"; 
import "rules.saw";

enable ref_aset_384;
enable ref_group_mul_aux;
import "group_mul_aux.spec";

----------------------------------
group_mul_aux.spec

method com.galois.ecc.P384ECC64.group_mul_aux
{
  var r              :: int[12];
  var yj, j, xi      :: int;
  var c              :: long;
  assert (j >=s 0 :[32]) && (j <=s 11:[32]);
  let jr = join(valueOf(r));
  let res = ref_group_mul_aux(jr, yj, j, xi, c);
  ensure valueOf(r) := split(res.gra_r) : [12][32];
  return res.gra_b;
  verify yices;
};

----------------------------------
group_red.saw

import "common.saw"; 
import "rules.saw";

set verification off;
import "sub.saw";
import "group_red_aux.spec";
set verification on;

enable ref_group_red;
import "group_red.spec";

----------------------------------
group_red.spec

method com.galois.ecc.P384ECC64.group_red
{
  var r                :: int[12];
  var c                :: long;
  var this.group_order :: int[12];
  assert valueOf(this.group_order) := split(group_order) : [12][32];
  let jr = join(valueOf(r));
  ensure valueOf(r) := split(ref_group_red(group_order, jr, c)) : [12][32];
  verify { rewrite; yices; };
  //quickcheck 10;
};

----------------------------------
group_red_aux.saw

import "common.saw"; 
import "rules.saw";

enable ref_aset_384;
enable ref_group_red_aux;
import "group_red_aux.spec";

----------------------------------
group_red_aux.spec

method com.galois.ecc.P384ECC64.group_red_aux
{
  var r              :: int[12];
  var aj, j          :: int;
  var c, b           :: long;
  assert (j >=s 0 :[32]) && (j <=s 11:[32]);
  let jr = join(valueOf(r));
  let res = ref_group_red_aux(jr, aj, j, c, b);
  ensure valueOf(r) := split(res.gra_r) : [12][32];
  return res.gra_b;
  verify yices;
};

----------------------------------
incFieldPrime.saw

import "common.saw";
import "rules.saw";
enable ref_incFieldPrime;
import "incFieldPrime.spec";

----------------------------------
incFieldPrime.spec

method com.galois.ecc.P384ECC64.incFieldPrime 
{
  var x :: int[12];
  let r = ref_incFieldPrime(join(valueOf(x)));
  ensure valueOf(x) := split(r.rslt) : [12][32];
  return r.carry;
  verify { rewrite; yices; };
};

----------------------------------
is_equal.saw

method com.galois.ecc.P384ECC64.is_equal
{
  var x, y :: int[12];
  return join(valueOf(x)) == join(valueOf(y));
  verify abc;
};

----------------------------------
is_zero.saw

method com.galois.ecc.P384ECC64.is_zero 
{
  var x :: int[12];
  return join(valueOf(x)) == 0:[384];
  verify abc;
};

----------------------------------
leq.saw

method com.galois.ecc.P384ECC64.leq
{
  var x, y :: int[12];
  mayAlias { x, y };
  return join(valueOf(x)) <=u join(valueOf(y));
  verify abc;
};

----------------------------------
localspec.saw

/* Check that we generate multiple verification conditions. */
method LocalSpec.test1 {
    var args[0] :: int[12];
    localSpec 4 {
        modifies: valueOf(args[0]);
    };
    modifies: valueOf(args[0]);
    verifyUsing: abc;
};

/* Test that we can check intermediate values. */
method LocalSpec.test2 {
    var args[0] :: int[1];
    localSpec 4 {
        ensures valueOf(args[0]) := [1 : [32]];
    };
    modifies: valueOf(args[0]);
    /* Disabled until we implement evaluation of ensures clauses at the
       beginning of execution fragments. */
    //ensures valueOf(args[0]) := [2 : [32]];
    verifyUsing: abc;
};

/* Test that we can handle arbitrary iteration counts. */
method LocalSpec.test3 {
    var args[0] :: int[1];
    var args[1] :: int[1];
    /* The one back edge in this method is from "goto 4". */
    localSpec 20 {
        modifies: valueOf(args[0]);
    };
    modifies: valueOf(args[0]);
    verifyUsing: abc;
};

/* Test that we can check the body of a loop for an arbitrary
   iteration. */
method LocalSpec.test4 {
    var args[0] :: int[1];
    localSpec 14 {
        ensures valueOf(args[0]) := [join(valueOf(args[0])) - (1 : [32])];
    };
    modifies: valueOf(args[0]);
    verifyUsing: abc;
};

/* Test that we can analyze a method with a similar shape to the
   mod_div method. */
method LocalSpec.div_like {
    var args[0] :: int[8];
    localSpec 20 {
        ensures valueOf(args[0]) := split(0:[256]) : [8][32];
    };
    localSpec 31 {
        ensures valueOf(args[0]) := split(0:[256]) : [8][32];
    };
    ensures valueOf(args[0]) := split(0:[256]) : [8][32];
    verifyUsing: abc;
};

----------------------------------
mod_div.saw

import "common.saw";
import "rules.saw";

// Definition of ref_div and egcd (should be moved to common.saw).

set verification off;

import "assign.saw";
import "is_zero.saw";
import "leq.saw";
import "mod_half.spec";
import "mod_sub.spec";
import "set_zero.saw";
import "shr.saw";
import "sub.saw";

set verification on;

enable even;
enable ref_mod_div;

import "mod_div.spec";

----------------------------------
mod_div.spec

method com.galois.ecc.P384ECC64.mod_div {
  var ra, x, y, p :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];

  ensure valueOf(ra) 
    := split(ref_mod_div(
         join(valueOf(p)), join(valueOf(x)), join(valueOf(y)))) : [12][32];
  modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  from line +7 {
    var swapped :: boolean;
    var a, ra, b, rb, p :: int[12];
    var this.t1, this.t2, this.t3 :: int[12];

    let res
      = split(ref_egcd(join(valueOf(p)),
                       join(valueOf(a)), join(valueOf(ra)),
                       join(valueOf(b)), join(valueOf(rb)))) : [12][32];

    if (swapped == 0:[32]) {
      assert swapped := false;
      assert this.t1 := a;
      assert this.t2 := b;
      assert this.t3 := rb;

      ensure valueOf(ra) := res;
    } else {
      assert swapped := true;
      assert this.t1 := b;
      assert this.t2 := a;
      assert this.t3 := ra;

      ensure valueOf(rb) := res;
    }

    modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  }

  verify {
    from line +7 {
       expand ref_egcd(join(valueOf(p)),
                       join(valueOf(a)),
                       join(valueOf(ra)),
                       join(valueOf(b)),
                       join(valueOf(rb)));
    }
    rewrite;
    yices;
  }
};

----------------------------------
mod_half.saw

import "common.saw";
import "rules.saw";

set verification off;
import "add.saw";
import "shr.saw";
set verification on;

enable ref_mod_half;
import "mod_half.spec";

----------------------------------
mod_half.spec

method com.galois.ecc.P384ECC64.mod_half {
  var x, p :: int[12]; 
  mayAlias { x, p };
  let jx = join(valueOf(x));
  let jp = join(valueOf(p));
  // NB: ref_mod_half takes it parameters in the opposite order of mod_half.
  ensure valueOf(x) := split(ref_mod_half(jp, jx)) : [12][32];
  verify { rewrite; yices; }
};


----------------------------------
mod_sub.saw

import "common.saw"; 
import "rules.saw";

set verification off;
import "add.saw";
import "sub.saw";
set verification on;

enable ref_mod_sub;
import "mod_sub.spec";

----------------------------------
mod_sub.spec

method com.galois.ecc.P384ECC64.mod_sub 
{
  var z, x, y, p :: int[12];
  mayAlias { z, x, y };

  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  let jp = join(valueOf(p));
  ensure valueOf(z) := split(ref_mod_sub(jp, jx, jy)) : [12][32];

  verify { rewrite; yices; };
};

----------------------------------
mul.saw

import "common.saw";
import "rules.saw";

set verification off;
import "mul_inner.spec";
set verification on;

enable ref_mul_java;
enable ref_aset_768;
import "mul.spec";

----------------------------------
mul.spec

method com.galois.ecc.P384ECC64.mul
{
  var a   :: int[24];
  var x,y :: int[12];
  mayAlias { x, y };
  let a' = join(valueOf(a)) : [768];
  let x' = join(valueOf(x)) : [384];
  let y' = join(valueOf(y)) : [384];
  ensure valueOf(a) := split(ref_mul_java(a', x', y')) : [24][32];
  verify { rewrite; };
};

----------------------------------
mul_inner.saw

import "common.saw";
import "rules.saw";
enable ref_mul_java_inner;
import "mul_inner.spec";

----------------------------------
mul_inner.spec

method com.galois.ecc.P384ECC64.mul_inner
{
  var azero   :: boolean;
  var a       :: int[24];
  var ij      :: int;
  var xi, yj  :: int;
  var d       :: long;

  assert (ij >=s 0 :[32]) && (ij <=s 23:[32]);

  let ja  = join(valueOf(a)) : [768];
  let res = ref_mul_java_inner(azero, ja, ij, xi, yj, d);

  ensure valueOf(a) := split(res.mji_a) : [24][32];
  return res.mji_d;

//  verify { rewrite; yices; };
  verify {abc;} ;
};

----------------------------------
proofs-old.saw

// Define operators from SBV files.
extern SBV is_field("sbv-old/ref_p384_is_val.sbv")  : [384] -> Bit;
extern SBV field_add("sbv-old/ref_p384_add.sbv") : ([384],[384]) -> [384];
extern SBV field_sub("sbv-old/ref_p384_sub.sbv") : ([384],[384]) -> [384];
extern SBV field_mul("sbv-old/ref_p384_mul.sbv") : ([384],[384]) -> [384];
extern SBV field_mod("sbv-old/ref_p384_mod.sbv") : [768] -> [384];
extern SBV field_sq("sbv-old/ref_p384_sq.sbv") : [384] -> [384];
extern SBV ec_double("sbv-old/p384_ref_double.sbv") :
  { x: [384]; y: [384]; z: [384] } -> { x:[384]; y:[384]; z:[384] };
/*
extern SBV field_div_step("sbv/ref_p384_div_step.sbv") :
  ([12][32], [12][32], [12][32], [12][32], [12][32], [32]) ->
  { a:[12][32]; ra:[12][32]; b:[12][32]; rb:[12][32]; sw:[32] };
*/
extern SBV field_half("sbv-old/ref_p384_half.sbv") : [384] -> [384];
extern SBV field_neg("sbv-old/ref_p384_neg.sbv") : [384] -> [384];
extern SBV ec_full_add("sbv-old/p384_ref_full_add.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_full_sub("sbv-old/p384_ref_full_sub.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_mul_aux("sbv-old/p384_ref_mul_aux.sbv") :
  ({ x: [384]; y: [384]; z: [384] }, { x:[384]; y:[384] }, [32], [32], [32]) ->
  { x:[384]; y:[384]; z:[384] };
extern SBV ec_mul("sbv-old/p384_ref_mul.sbv") :
  ([384], { x:[384]; y:[384] }) -> { x:[384]; y:[384]; z:[384] };

// Define field prime for P384 curve (taken from NIST and NSA documents).
let field_prime = <| 2^384 - 2^128 - 2^96 + 2^32 - 1 |> : [384];

// Array operation verification {{{1

method com.galois.ecc.P384ECC64.is_zero {
  var x :: int[12];
  return join(valueOf(x)) == 0:[384];
  verify abc;
};

method com.galois.ecc.P384ECC64.set_zero {
  var args[0] :: int[12];
  ensure valueOf(args[0]) := split(0:[384]) : [12][32];
  verify abc;
};

method com.galois.ecc.P384ECC64.set_unit {
  var args[0] :: int[12];
  ensure valueOf(args[0]) := split(1:[384]) : [12][32];
  verify abc;
};

method com.galois.ecc.P384ECC64.assign {
  var args[0], args[1] :: int[12];
  ensure valueOf(args[0]) := valueOf(args[1]);
  verify abc;
};

// Field operation verification {{{1

// field_add {{{2
//
// field_add takes three valueOfs as arguments: args[0], args[1], and args[2].
// To avoid allocating memory, it stores the result of adding args[1] and args[2]
// into the first argument "args[0]".
method com.galois.ecc.P384ECC64.field_add {
  // Simulator types for references must give explicit length for valueOfs.

  // Note: If debugging information is available, we could eventually support
  // using the argument names from the Java debugging information.  However, for
  // our initial release, arguments must be refered to by position.
  var args[0], args[1], args[2] :: int[12];

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Allow any of the valueOfs to alias the other valueOfs.
  // Complicates verification, but necessary for correctness of higher-level
  // operations such as "ec_double".
  mayAlias { args[0], args[1], args[2] };

  // Result of executing method.
  // In this case, we store the result of adding args[1] and args[2] inside of
  // args[0].
  ensure valueOf(args[0]) := 
    split(field_add(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];

  quickcheck 100;
  //verify abc;
};

// field_sub {{{2

method com.galois.ecc.P384ECC64.field_sub {
  var args[0], args[1], args[2] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1], args[2] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) :=
    split(field_sub(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];
  verify abc;
};

// field_dbl {{{2

method com.galois.ecc.P384ECC64.field_dbl {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  ensure valueOf(args[0]) := split(field_add(jarg1, jarg1)) : [12][32];
  verify abc;
};

// field_dbl_dec {{{2

rule eq_elim : forAll {x:a}. x == x -> true;

rule join_split : forAll {x:[384]}.
  join(split(x) : [12][32]) -> x;

method com.galois.ecc.P384ECC64.field_dbl_dec {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Require that args[0] and args[1] are valid field elements.
  // assert is_field(join(valueOf(args[0])));
  // assert is_field(join(valueOf(args[1])));

  let jarg0 = join(valueOf(args[0]));
  let jarg1 = join(valueOf(args[1]));
  ensure valueOf(args[0]) := split(field_sub(field_sub(jarg0, jarg1), jarg1)) : [12][32];
  verify rewrite;
};

// field_mul3 {{{2

method com.galois.ecc.P384ECC64.field_mul3 {
  // Require arguments are 12-element integer valueOfs.
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // assert is_field(join(valueOf(args[0])));
  // assert is_field(join(valueOf(args[1])));

  // Let jarg1 equals args[1] value as a single 384-bit number.
  let jarg1 = join(valueOf(args[1]));

  // Store result of jarg1 + jarg1 + jarg1 inside first argument valueOf.
  ensure valueOf(args[0]) := split(field_add(jarg1, field_add(jarg1, jarg1))) : [12][32];

  verify abc;
};

// field_mul4 {{{2
method com.galois.ecc.P384ECC64.field_mul4 {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  let dbl = field_add(jarg1, jarg1);
  ensure valueOf(args[0]) := split(field_add(dbl, dbl)) : [12][32];
  verify abc;
};

// field_mul8 {{{2
method com.galois.ecc.P384ECC64.field_mul8 {
  var args[0], args[1] :: int[12];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  let jarg1 = join(valueOf(args[1]));
  let dbl = field_add(jarg1, jarg1);
  let quad = field_add(dbl, dbl);
  ensure valueOf(args[0]) := split(field_add(quad, quad)) : [12][32];
  verify abc;
};

// field_red {{{2
method com.galois.ecc.P384ECC64.field_red {
  var args[0] :: int[12];
  var args[1] :: int[24];
  var this.field_prime :: int[12];

  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) := split(field_mod(join(valueOf(args[1])))) : [12][32];

  quickcheck 100;
};

// field_mul {{{2
method com.galois.ecc.P384ECC64.field_mul {
  // Require arguments are 12-element integer valueOfs.
  var args[0], args[1], args[2] :: int[12];
  // Require "this.a" is a temporary buffer capable of storing 24 integers.
  var this.a :: int[24];
  var this.field_prime :: int[12];

  // Allow three arguments to alias.
  mayAlias { args[0], args[1], args[2] };

  // Require that args[1] and args[2] are valid field elements.
  // assert is_field(join(valueOf(args[1])));
  // assert is_field(join(valueOf(args[2])));

  // Require Java this.field_prime field equals SAWScript field_prime constant.
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Store result of args[1] * args[2] inside args[0].
  ensure valueOf(args[0]) := split(field_mul(join(valueOf(args[1])), join(valueOf(args[2])))) : [12][32];

  // Indicate that the value of this.a after execution may be an arbitrary value.
  // This is implemented in symbolic simulator by creating a new fresh variable
  // after executing field_mul.
  modify valueOf(this.a);

  // Test field_mul using quickcheck.
  //verify quickcheck 100;
};

// field_sq {{{2
method com.galois.ecc.P384ECC64.field_sq {
  var args[0], args[1] :: int[12];
  var this.a :: int[24];
  var this.field_prime :: int[12];
  mayAlias { args[0], args[1] };
  // assert is_field(join(valueOf(args[1])));
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) := split(field_mul(join(valueOf(args[1])), join(valueOf(args[1])))) : [12][32];
  modify valueOf(this.a);
};

// mod_half {{{2
method com.galois.ecc.P384ECC64.mod_half {
  var args[0] :: int[12];
  var args[1] :: int[12];
  // assert that second argument is field_prime;
  assert valueOf(args[1]) := split(field_prime) : [12][32];
  ensure valueOf(args[0]) := split(field_half(join(valueOf(args[0])))) : [12][32];
  verify abc;
};

set verification on;

// mod_div {{{2
method com.galois.ecc.P384ECC64.mod_div {
  var args[0], args[1], args[2], args[3] :: int[12];
  var this.t1, this.t2, this.t3 :: int[12];


//  ensure valueOf(args[0]) 
//    := split(p384_prime_div(join(valueOf(args[3])),
//                            join(valueOf(args[1])),
//                            join(valueOf(args[2])))) : [12][32];
//  modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

  at 44 {
    var swapped :: boolean;
    var a, ra, b, rb :: int[12];
    var this.t1, this.t2, this.t3 :: int[12];

    if (swapped == 0:[32]) {
      assert swapped := false;
      assert this.t1 := a;
      assert this.t2 := b;
      assert this.t3 := rb;

//      ensure valueOf(ra) 
//       := split(p384_egcd(join(valueOf(a)),
//                          join(valueOf(ra)),
//                          join(valueOf(b)),
//                          join(valueOf(rb)))) : [12][32];
    } else {
      assert swapped := true;
      assert this.t1 := b;
      assert this.t2 := a;
      assert this.t3 := ra;

//      ensure valueOf(rb) 
//       := split(p384_egcd(join(valueOf(a)),
//                          join(valueOf(ra)),
//                          join(valueOf(b)),
//                          join(valueOf(rb)))) : [12][32];
    };

    modify valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  };

  /*
  verify {
    if (initialPC == 44) {
       expand p384_egcd(join(valueOf(a)),
                        join(valueOf(ra)),
                        join(valueOf(b)),
                        join(valueOf(rb)));
    }
    uninterpret p384_egcd;
    yices;
  };
  */
};

set verification on;

// Point operation verification {{{1

// Diable field operations.
//disable is_field;
//disable field_add;
//disable field_sub;

// Define rules for rewriting verification {{{2

// Strategies used in creating rewrite rules.
//   Push split and join towards bottom of terms.
//   Prefer join to split in equals.
//   Cancel unnessary applications wherever possible
//     with cancelation/elimination rules.

// Misc cancelation rules{{{3
rule not_not : forAll {x:Bit}.  not(not(x)) -> x;
rule eq_elim : forAll {x:a}. x == x -> true;

rule join_split : forAll {x:[384]}.
  join(split(x) : [12][32]) -> x;

// Boolean elimination rules {{{3

rule and_true_elim1 : forAll {x:Bit}. true && x -> x;
rule and_true_elim2 : forAll {x:Bit}. x && true -> x;
rule and_false_elim1 : forAll {x:Bit}. false && x -> false;
rule and_false_elim2 : forAll {x:Bit}. x && false -> false;
rule and_left_assoc : forAll {x:Bit, y:Bit, z:Bit}.
 x && (y && z) -> (x && y) && z;

rule or_true_elim1 : forAll {x:Bit}. true || x -> true;
rule or_true_elim1 : forAll {x:Bit}. x || true -> true;
rule or_false_elim1 : forAll {x:Bit}. false || x -> x;
rule or_false_elim2 : forAll {x:Bit}. x || false -> x;

// Move not inside {{{3
rule not_or : forAll {x:Bit, y:Bit}.
  not (x || y) -> not x && not y;
rule not_and : forAll {x:Bit, y:Bit}.
  not (x && y) -> not x || not y;

rule or_trivial : forAll {x:Bit}. not x || x -> true;

// Redundancy {{{3
rule or_redundant1 : forAll {x:Bit,y:Bit}. (x || y) || y -> x || y;
rule or_redundant2 : forAll {x:Bit,y:Bit}. (x || y) || x -> x || y;
rule and_redundant1 : forAll {x:Bit,y:Bit}. (x && y) && y -> x && y;
rule and_redundant2 : forAll {x:Bit,y:Bit}. (x && y) && x -> x && y;

// Generic ite rules {{{3
rule ite_not :
  forAll { b:Bit, x:a, y:a }.
    (if (not b) then x else y) -> if b then y else x;
rule ite_elim_1 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then (if b then x else y) else z)
  -> if b then x else z;
rule ite_elim_2 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then x else (if b then y else z))
  -> if b then x else z;
rule ite_bit : forAll {b:Bit, c:Bit, d:Bit}.
  if b then c else d -> (not b || c) && (b || d);

// Bit level ite rules {{{3
rule ite_bit_false_1 :
  forAll { b:Bit, c:Bit }.
    (if b then false else c) -> not b && c;

rule ite_bit_true_1 :
  forAll { b:Bit, c:Bit }.
    (if b then true else c) -> b || c;

// Eq-split rules{{{3

let zeroArray = split(0:[384]) : [12][32];
let unitArray = split(1:[384]) : [12][32];

rule eq_split_cong_1 : forAll {x:[384], y:[12][32]}.
  split(x):[12][32] == y -> x == join(y);
rule eq_split_cong_2 : forAll {x:[12][32], y:[384]}.
  x == split(y):[12][32] -> join(x) == y;

// Special purpose rules
// N.B. In the long term, it should be able to write more general rules
// than this.
rule eq_split_valueOf_zeroArray : forAll { x:[12][32]}.
  x == zeroArray -> join(x) == 0:[384];
rule eq_split_valueOf_unitArray : forAll { x:[12][32]}.
  x == unitArray -> join(x) == 1:[384];

// ite congruence rules {{{3

rule ite_eq_cong_1 :
  forAll { b:Bit, x:a, y:a, z:a }.
    (if b then x else y) == z -> if b then (x == z) else (y == z);
rule ite_eq_cong_2 :
  forAll { b:Bit, x:a, y:a, z:a }.
    z == (if b then x else y) -> if b then (z == x) else (z == y);
rule ite_split_cong :
  forAll { b:Bit, x:[384], y:[384] }.
    split(if b then x else y) : [12][32] -> 
      if b then split(x) : [12][32] else split(y) : [12][32];
rule ite_join_cong :
  forAll { b:Bit, x:[12][32], y:[12][32] }.
    join(if b then x else y) -> 
      if b then join(x) else join(y);

// Record elimination rules {{{3

rule jacobianX :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.x -> x0;
rule jacobianY :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.y -> y0;
rule jacobianZ :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.z -> z0;

rule affineX :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.x -> x0;
rule affineY :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.y -> y0;


// Field-specific elimination rules {{{3

rule field_sq_def :
  forAll { x:[384] }.
   field_sq(x) -> field_mul(x, x);

rule ite_zero_field_mul :
  forAll { x:[384], y:[384], z:[384], c:Bit }.
    (if (x == 0:[384]) then (field_mul(x, y) == z:[384]) else c)
     -> (if (x == 0:[384]) then (z:[384] == 0:[384]) else c);

// }}}3

// ec_double {{{2
enable ec_double;
// Point doubling spec.
// Point doubling take a single Jacobian point and modify it's fields so that
// they refer to the point after it has been doubled.
// It uses some temporary buffers for storing results, but allocates no new memory.
method com.galois.ecc.P384ECC64.ec_double {
  // Indicate type for argument.
  var args[0] :: com.galois.ecc.JacobianPoint;
  // Indicate type for fields of Java JacobianPoint.
  var args[0].x, args[0].y, args[0].z :: int[12];
  // Provide types for temporary buffers.
  var this.a :: int[24];
  var this.t1, this.t2 :: int[12];

  // Declare field prime.
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  // Require that fields for Jacobian point are valid field elements.
  // assert is_field(join(valueOf(args[0].x)));
  // assert is_field(join(valueOf(args[0].y)));
  // assert is_field(join(valueOf(args[0].z)));


  // Let res denote the Cryptol struct formed from Cryptol ec_double operation.
  let res = ec_double({ x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) });

  // Split results of Cryptol operation into Java fields.
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];

  // Indicate temporary buffers are modify.
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2);

  // Use rewriting to verify ec_double.
  verify rewrite;
};
disable ec_double;

// ec_full_add {{{2
enable ec_full_add;
method com.galois.ecc.P384ECC64.ec_full_add {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var this.a :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y :: int[12];
  
  assert is_field(join(valueOf(args[0].x)));
  assert is_field(join(valueOf(args[0].y)));
  assert is_field(join(valueOf(args[0].z)));
  assert is_field(join(valueOf(args[1].x)));
  assert is_field(join(valueOf(args[1].y)));

  // Declare field prime.
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res =
    ec_full_add(
      { x = join(valueOf(args[0].x)) ;
        y = join(valueOf(args[0].y)) ;
        z = join(valueOf(args[0].z)) },
      { x = join(valueOf(args[1].x)) ;
        y = join(valueOf(args[1].y)) }
      );
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
};

// ec_full_sub {{{2
method com.galois.ecc.P384ECC64.ec_full_sub {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var this.a  :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y            :: int[12];
  assert is_field(join(valueOf(args[0].x)));
  assert is_field(join(valueOf(args[0].y)));
  assert is_field(join(valueOf(args[0].z)));
  assert is_field(join(valueOf(args[1].x)));
  assert is_field(join(valueOf(args[1].y)));

  // Declare field prime.
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res =
    ec_full_sub(
      { x = join(valueOf(args[0].x)) ; y = join(valueOf(args[0].y)) ; z = join(valueOf(args[0].z)) },
      { x = join(valueOf(args[1].x)) ; y = join(valueOf(args[1].y)) }
      );
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
};

// ec_mul_merge_aux {{{2
method com.galois.ecc.P384ECC64.ec_mul_merge_aux {
  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[1] :: com.galois.ecc.AffinePoint;
  var args[2] :: int;
  var args[3] :: int;
  var args[4] :: int;
  var this.a :: int[24];
  var this.t1, this.t2, this.t3 :: int[12];
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1].x, args[1].y :: int[12];
  assert is_field(join(valueOf(args[0].x)));
  assert is_field(join(valueOf(args[0].y)));
  assert is_field(join(valueOf(args[0].z)));
  assert is_field(join(valueOf(args[1].x)));
  assert is_field(join(valueOf(args[1].y)));

  // Declare field prime.
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  let res = ec_mul_aux({ x = join(valueOf(args[0].x))
                       ; y = join(valueOf(args[0].y))
                       ; z = join(valueOf(args[0].z))
                       },
                       { x = join(valueOf(args[1].x))
                       ; y = join(valueOf(args[1].y))
                       },
                       args[2],
                       args[3],
                       args[4]);
  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  modify valueOf(this.a), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);
  //verify rewrite;
};

// ec_mul {{{2
method com.galois.ecc.P384ECC64.ec_mul {

  var args[0] :: com.galois.ecc.JacobianPoint;
  var args[0].x, args[0].y, args[0].z :: int[12];
  var args[1] :: int[12];
  var args[2] :: com.galois.ecc.AffinePoint;
  var args[2].x, args[2].y            :: int[12];

  var this.a  :: int[24];
  var this.h  :: int[12];
  var this.t1, this.t2, this.t3       :: int[12];

  assert is_field(join(valueOf(args[1])));
  assert is_field(join(valueOf(args[2].x)));
  assert is_field(join(valueOf(args[2].y)));

  // Declare field prime.
  var this.field_prime :: int[12];
  assert valueOf(this.field_prime) := split(field_prime) : [12][32];

  /*
  localSpec 162 {
      let lres = ec_mul_aux(
                   { x = join(valueOf(args[0].x))
                   ; y = join(valueOf(args[0].y))
                   ; z = join(valueOf(args[0].z))
                   },
                   { x = join(valueOf(args[2].x))
                   ; y = join(valueOf(args[2].y))
                   },
                   TODO,
                   TODO,
                   TODO);
      ensure: valueOf(args[0].x) := split(lres.x);
      ensure: valueOf(args[0].y) := split(lres.y);
      ensure: valueOf(args[0].z) := split(lres.z);

  }
  */

  let res = ec_mul(join(valueOf(args[1])),
                   { x = join(valueOf(args[2].x))
                   ; y = join(valueOf(args[2].y))
                   });

  ensure valueOf(args[0].x) := split(res.x) : [12][32];
  ensure valueOf(args[0].y) := split(res.y) : [12][32];
  ensure valueOf(args[0].z) := split(res.z) : [12][32];
  /*modify valueOf(args[0].x), valueOf(args[0].y), valueOf(args[0].z);*/
  modify valueOf(this.a), valueOf(this.h), valueOf(this.t1), valueOf(this.t2), valueOf(this.t3);

};

----------------------------------
rules.saw

////////////////////////////////////////////////////////////////////////////////
// Rewrite Rules
//
// This section defines common rules for verification tasks that use the
// rewrite.
// 
// Strategies for creating rewrite rules:
//   Push split and join towards bottom of terms.
//   Prefer join to split in equals.
//   Cancel unnessary applications wherever possible
//     with cancelation/elimination rules.

// Misc cancelation rules

rule eq_elim    : forAll {x:a}. x == x -> true;
rule join_split : forAll {x:[384]}. join(split(x) : [12][32]) -> x;
rule not_not    : forAll {x:Bit}. not(not(x)) -> x;
rule split_join : forAll {x:[12][32]}. split(join(x) : [384]) : [12][32] -> x;

rule join_split2 : forAll {x:[768]}. join(split(x) : [24][32]) -> x;
rule split_join2 : forAll {x:[24][32]}. split(join(x) : [768]) : [24][32] -> x;

// Boolean elimination rules 

rule and_true_elim1  : forAll {x:Bit}. true && x -> x;
rule and_true_elim2  : forAll {x:Bit}. x && true -> x;
rule and_false_elim1 : forAll {x:Bit}. false && x -> false;
rule and_false_elim2 : forAll {x:Bit}. x && false -> false;
rule and_left_assoc  : forAll {x:Bit, y:Bit, z:Bit}.  x && (y && z) -> (x && y) && z;
// rule and_contr_elim1 : forAll {x:Bit}. x && not x -> false;
// rule and_contr_elim2 : forAll {x:Bit}. not x && x -> false;

rule or_true_elim1  : forAll {x:Bit}. true || x -> true;
rule or_true_elim2  : forAll {x:Bit}. x || true -> true;
rule or_false_elim1 : forAll {x:Bit}. false || x -> x;
rule or_false_elim2 : forAll {x:Bit}. x || false -> x;
rule or_trivial     : forAll {x:Bit}. not x || x -> true;

rule or_redundant1  : forAll {x:Bit,y:Bit}. (x || y) || y -> x || y;
rule or_redundant2  : forAll {x:Bit,y:Bit}. (x || y) || x -> x || y;
rule and_redundant1 : forAll {x:Bit,y:Bit}. (x && y) && y -> x && y;
rule and_redundant2 : forAll {x:Bit,y:Bit}. (x && y) && x -> x && y;

rule imp_true_elim1  : forAll {x:Bit}. x     ==> true  -> true;
/*
rule imp_true_elim2  : forAll {x:Bit}. true  ==> x     -> x;
rule imp_false_elim1 : forAll {x:Bit}. x     ==> false -> not x;
rule imp_false_elim2 : forAll {x:Bit}. false ==> x     -> true;
*/

// De Morgan's 
rule not_or  : forAll {x:Bit, y:Bit}. not (x || y) -> not x && not y;
rule not_and : forAll {x:Bit, y:Bit}. not (x && y) -> not x || not y;

rule and_idem : forAll {x:Bit}. x && x -> x;
rule and_idem_not1 : forAll {x:Bit}. not x && x -> false;
rule and_idem_not2 : forAll {x:Bit}. x && not x -> false;

// Generic ite rules 

rule ite_not :
  forAll { b:Bit, x:a, y:a }.
    (if (not b) then x else y) -> if b then y else x;

rule ite_elim_1 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then (if b then x else y) else z)
  -> if b then x else z;

rule ite_elim_2 : forAll { b:Bit, x:a, y:a, z:a }.
  (if b then x else (if b then y else z))
  -> if b then x else z;

rule ite_bit : forAll {b:Bit, c:Bit, d:Bit}.
  if b then c else d -> (not b || c) && (b || d);

// Bit-level ite rules

rule ite_bit_false_1 :
  forAll { b:Bit, c:Bit }.
    (if b then false else c) -> not b && c;

rule ite_bit_true_1 :
  forAll { b:Bit, c:Bit }.
    (if b then true else c) -> b || c;

// Congruence rules for ite 

rule ite_eq_cong_1 :
  forAll { b:Bit, x:a, y:a, z:a }.
    (if b then x else y) == z -> if b then (x == z) else (y == z);

rule ite_eq_cong_2 :
  forAll { b:Bit, x:a, y:a, z:a }.
    z == (if b then x else y) -> if b then (z == x) else (z == y);

rule ite_split_cong :
  forAll { b:Bit, x:[384], y:[384] }.
    split(if b then x else y) : [12][32] -> 
      if b then split(x) : [12][32] else split(y) : [12][32];

rule ite_join_cong :
  forAll { b:Bit, x:[12][32], y:[12][32] }.
    join(if b then x else y) -> 
      if b then join(x) else join(y);

// Eq-split rules

let zeroArray = split(0:[384]) : [12][32];
let unitArray = split(1:[384]) : [12][32];

rule eq_split_cong_1 : forAll {x:[384], y:[12][32]}.
  split(x):[12][32] == y -> x == join(y);

rule eq_split_cong_2 : forAll {x:[12][32], y:[384]}.
  x == split(y):[12][32] -> join(x) == y;

// Special purpose eq-split rules
// N.B. In the long term, it should be able to write more general rules
// than this.

rule eq_split_valueOf_zeroArray : forAll { x:[12][32]}.
  x == zeroArray -> join(x) == 0:[384];

rule eq_split_valueOf_unitArray : forAll { x:[12][32]}.
  x == unitArray -> join(x) == 1:[384];

// Record elimination rules

rule jacobianX :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.x -> x0;

rule jacobianY :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.y -> y0;

rule jacobianZ :
  forAll { x0 : a, y0 : a, z0 : a }.
    { x = x0 ; y = y0 ; z = z0 }.z -> z0;

rule affineX :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.x -> x0;

rule affineY :
  forAll { x0 : a, y0 : a }.
    { x = x0 ; y = y0 }.y -> y0;

rule sigR :
  forAll { r0 : a, s0 : a }.
    { r = r0 ; s = s0 }.r -> r0;

rule sigS :
  forAll { r0 : a, s0 : a }.
    { r = r0 ; s = s0 }.s -> s0;

rule resR :
  forAll { r0 : a, sMt0 : b, sPt0 : c }.
      { r = r0 ; sMt = sMt0 ; sPt = sPt0 }.r -> r0;

rule resSPt :
  forAll { r0 : a, sMt0 : b, sPt0 : c }.
      { r = r0 ; sMt = sMt0 ; sPt = sPt0 }.sPt ->
      sPt0;

rule resSMt :
  forAll { r0 : a, sMt0 : b, sPt0 : c }.
      { r = r0 ; sMt = sMt0 ; sPt = sPt0 }.sMt ->
      sMt0;

rule mji_a :
  forAll { a0 : a, d0 : b }.
      { mji_a = a0 ; mji_d = d0 }.mji_a -> a0;

rule mji_d :
  forAll { a0 : a, d0 : b }.
      { mji_a = a0 ; mji_d = d0 }.mji_d -> d0;

/*
rule gra_r :
  forAll { r0 : a, b0 : b }.
      { gra_r = r0 ; gra_b = b0 }.gra_r -> r0;

rule gra_b :
  forAll { r0 : a, b0 : b }.
      { gra_r = r0 ; gra_b = b0 }.gra_b -> b0;
*/

////

rule trunc_shift_get : forAll {x:[384], s:[9]}.
  trunc (x >>u s) : [32] ->
  aget (split(x) : [12][32], (s >>u 5:[9]) # 0:[23]);

rule shift_zero : forAll {x:[a]}.  x >>u 0:[6] -> x;

// Field-specific elimination rules

rule ite_zero_field_mul :
  forAll { x:[384], y:[384], z:[384], c:Bit }.
    (if (x == 0:[384]) then (ref_field_mul(x, y) == z:[384]) else c)
     -> (if (x == 0:[384]) then (z:[384] == 0:[384]) else c);

----------------------------------
set_unit.saw

method com.galois.ecc.P384ECC64.set_unit
{
  var x :: int[12];
  ensure valueOf(x) := split(1:[384]) : [12][32];
  verify abc;
};



----------------------------------
set_zero.saw

method com.galois.ecc.P384ECC64.set_zero
{
  var x :: int[12];
  ensure valueOf(x) := split(0:[384]) : [12][32];
  verify abc;
};

----------------------------------
shr.saw

method com.galois.ecc.P384ECC64.shr
{
  var z, x :: int[12];
  var c :: int;
  mayAlias { z, x };
  let x' = join(valueOf(x)) : [384];
  let mask = (0 : [352]) # (c << 31:[5]);
  let x'' = mask | (x' >>u 1:[5]);
  ensure valueOf(z) := split(x'') : [12][32];
  verify yices;
};

----------------------------------
sq.saw

import "common.saw";
import "rules.saw";

set verification off;
import "mul_inner.spec";
import "sq_loop.spec";
import "sq_inner1.spec";
import "sq_inner2.spec";
set verification on;

enable ref_aset_768;
enable ref_sq_java;
import "sq.spec";

----------------------------------
sq.spec

method com.galois.ecc.P384ECC64.sq
{
  var a :: int[24];
  var x :: int[12];
  let a' = join(valueOf(a)) : [768];
  let x' = join(valueOf(x)) : [384];
  ensure valueOf(a) := split(ref_sq_java(a', x')) : [24][32];
  verify rewrite;
};

----------------------------------
sq_inner1.saw

import "common.saw";
import "rules.saw";
enable ref_sq_java_inner1;
import "sq_inner1.spec";

----------------------------------
sq_inner1.spec

method com.galois.ecc.P384ECC64.sq_inner1
{
  var a       :: int[24];
  var ij      :: int;
  var c       :: long;

  assert (ij >=s 0 :[32]) && (ij <=s 23:[32]);

  let ja  = join(valueOf(a)) : [768];
  let res = ref_sq_java_inner1(ja, ij, c);

  ensure valueOf(a) := split(res.mji_a) : [24][32];
  return res.mji_d;

  verify abc;
};

----------------------------------
sq_inner2.saw

import "common.saw";
import "rules.saw";
enable ref_sq_java_inner2;
import "sq_inner2.spec";

----------------------------------
sq_inner2.spec

method com.galois.ecc.P384ECC64.sq_inner2
{
  var a       :: int[24];
  var ij      :: int;
  var xati    :: int;
  var c       :: long;

  assert (ij >=s 0 :[32]) && (ij <=s 23:[32]);

  let ja  = join(valueOf(a)) : [768];
  let res = ref_sq_java_inner2(ja, ij, xati, c);

  ensure valueOf(a) := split(res.mji_a) : [24][32];
  return res.mji_d;

  verify abc;
};

----------------------------------
sq_loop.saw

import "common.saw";
import "rules.saw";

set verification off;
import "mul_inner.spec";
set verification on;

enable ref_aset_768;
enable ref_sq_java_loop;
import "sq_loop.spec";

----------------------------------
sq_loop.spec

method com.galois.ecc.P384ECC64.sq_loop
{
  var a       :: int[24];
  var x       :: int[12];

  let ja  = join(valueOf(a)) : [768];
  let jx  = join(valueOf(x)) : [384];
  let res = ref_sq_java_loop(ja, jx);

  ensure valueOf(a) := split(res) : [24][32];

  verify rewrite;
};

----------------------------------
sub.saw

method com.galois.ecc.P384ECC64.sub
{
  var z, x, y :: int[12];
  mayAlias { z, x, y };
  let jx = join(valueOf(x));
  let jy = join(valueOf(y));
  ensure valueOf(z) := split(jx - jy) : [12][32]; 
  return if jx >=u jy then 0:[32] else -(1:[32]);
  verify yices;
};

----------------------------------
toplevel.saw

import "common.saw";
import "rules.saw";

disable imp_true_elim1;

import "assign.saw";
import "is_equal.saw";
import "is_zero.saw";
import "set_unit.saw";
import "set_zero.saw";

import "add.saw";
import "leq.saw";
import "shr.saw";
import "sub.saw";

import "mul_inner.spec";

enable ref_mul_java;
enable ref_aset_768;
import "mul.spec";
disable ref_mul_java;

enable ref_sq_java_loop;
import "sq_loop.spec";

import "sq_inner1.spec";
import "sq_inner2.spec";
enable ref_sq_java;
import "sq.spec";
disable ref_sq_java;

rule mul_java_elim: forAll {a:[768], x:[384], y:[384]}.
  ref_mul_java(a, x, y) -> ref_safe_product(x, y);

rule sq_java_elim: forAll {a:[768], x:[384]}.
  ref_sq_java(a, x) -> ref_safe_product(x, x);

enable ref_decFieldPrime;
import "decFieldPrime.spec";
enable ref_incFieldPrime;
import "incFieldPrime.spec";

enable ref_mod_half;
import "mod_half.spec";
disable ref_mod_half;

enable ref_mod_add;
import "group_add.spec";
enable ref_mod_sub;
import "mod_sub.spec";
disable ref_mod_sub;

enable ref_aset_384;
enable ref_group_red_aux;
import "group_red_aux.spec";
disable ref_group_red_aux;

enable ref_group_red;
import "group_red.spec";
disable ref_group_red;

enable ref_group_mul_aux;
import "group_mul_aux.spec";
disable ref_group_mul_aux;

enable ref_group_mul;
import "array_shift.saw";
import "group_mul.spec";
disable ref_group_mul;

enable even;
enable ref_mod_div;
import "mod_div.spec";

enable ref_field_add;
import "field_add.spec";
enable ref_field_sub;
import "field_sub.spec";
import "field_dbl.spec";
import "field_dbl_dec.spec";
enable ref_field_mod;
import "field_red.spec";

enable ref_field_mul;
import "field_mul.spec";
disable ref_field_mul;
import "field_mul3.spec";
import "field_mul4.spec";
import "field_mul8.spec";
enable ref_field_sq;
import "field_sq.spec";
disable ref_field_add;
disable ref_field_sub;
disable ref_field_mod;
disable ref_field_mul;
disable ref_field_sq;

enable ref_ec_double;
import "ec_double.spec";
enable ref_ec_full_add;
import "ec_full_add.spec";
disable ref_ec_full_add;
enable ref_ec_full_sub;
import "ec_full_sub.spec";

disable ref_mod_add;
disable ref_field_mul;
disable ref_field_sq;
disable ref_mod_add;
disable ref_mod_sub;
disable ref_mod_div;
disable ref_ec_double;
disable ref_ec_full_add;
disable ref_ec_full_sub;

enable ref_ec_mul_init;
import "ec_mul_init.spec";
enable ref_ec_mul_aux;
import "ec_mul_aux.spec";
enable ref_ec_mul;
import "ec_mul.spec";
//import "ec_mul_window.qcspec";

disable ref_ec_mul;

enable imp_true_elim1;

extern SBV ref_ec_twin_mul("../spec/sbv/generated/p384_ec_twin_mul.sbv") :
  ([384], { x: [384]; y: [384] }, [384], { x: [384]; y: [384] }) ->
  { x: [384]; y: [384]; z: [384] };

enable ref_ec_twin_mul_init;
import "ec_twin_mul_init.spec";
enable ref_ec_twin_mul_aux_f;
import "ec_twin_mul_aux_f.spec";

enable ref_ec_twin_mul_aux1;
import "ec_twin_mul_aux1.spec";
enable ref_ec_twin_mul_aux2;
import "ec_twin_mul_aux2.spec";
enable ref_ec_twin_mul;
import "ec_twin_mul.spec";

disable ref_ec_twin_mul;

enable ref_ecdsa_sign;
import "ecdsa_sign.spec";

extern SBV ref_ecdsa_public_verify(
    "../spec/sbv/generated/p384_ecdsa_public_verify.sbv"
  ) : ([384], [384], [384], { x:[384]; y:[384] }) -> Bit;

enable ref_ecdsa_public_verify;
import "ecdsa_public_verify.spec";
