module EnumLib where
import Prelude;

-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));

myTypes3 : ListSort;
myTypes3 = LS_Cons UnitType (LS_Cons UnitType (LS_Cons Bool LS_Nil));

myTypes2 : ListSort;
myTypes2 = listSortDrop myTypes3 (0 : Nat);
  -- TODO: error in `listSortDrop` or its documentation.

testA : sort 0;
testA = listSortGet myTypes3 (1 : Nat); -- works as expected.

y3 : Eithers myTypes3;
y3 = Left UnitType (Eithers myTypes2) Unit;

{-
- alternatives
  A. see below: for code savings , split constructor and generic injN
  B. just forget the code savings and generate full code for each constructor!
    - TODO: look at this!

- designing constructors
enum TY <as> = C1 CT1
             | C2 CT2

MyC1 {as} v = inj1 {CT1} {{CT2}} v
                         ---------- this is the rest of translated type
MyC2 {as} v = inj2 {CT2} {{ Void }} v

  - can you setup with two lists: types before, r type, types after.

- designing injections
  A.
inj1 : {r,a}    r -> Either r a
inj2 : {r,a,b1} r -> Either b1 (Either r a)
inj3 : {...}    r -> Either b2 (Either b1 (Either r a))

inj1 : r ->   Eithers [r,a]
inj2 : r ->   Eithers [b1,r,a]
inj3 : r ->   Eithers [b2,b1,r,a]

case1 : FunsTo
case2 : FunsTo
-}

--------------------------------------------------------
-- old, ...
SumOf2 : (a1 a2       : sort 0) -> sort 0;
SumOf2 a1 a2 = Either a1 a2;

SumOf3 : (a1 a2 a3    : sort 0) -> sort 0;
SumOf3 a1 a2 a3 = Either a1 (SumOf2 a2 a3);

SumOf4 : (a1 a2 a3 a4 : sort 0) -> sort 0;
SumOf4 a1 a2 a3 a4 = Either a1 (SumOf3 a2 a3 a4);

inj1 : (a1 b : sort 0) -> a1 -> SumOf2 a1 b;
inj1 a1 b x = Left a1 b x;

inj2 : (a1 a2 b : sort 0) -> a2 -> SumOf3 a1 a2 b;
inj2 a1 a2 b x    = Right a1 (Either a2 b) (inj1 a2 b x);

inj3 : (a1 a2 a3 b : sort 0) -> a3 -> SumOf4 a1 a2 a3 b;
inj3 a1 a2 a3 b x = Right a1 (SumOf3 a2 a3 b) (inj2 a2 a3 b x);

case2 : (a b c : sort 0) -> (a -> c) -> (b -> c) -> Either a b -> c;
case2 = either;

-- case3
-- ...
-- TODO: figure how to do all this with SAWCore.Prelude Eithers and eithers
