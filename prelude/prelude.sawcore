module SAWScriptPrelude where

import Prelude;

-- Questions:
--   - should we have lists? Useful for rule lists, override lists,
--     uninterpret lists
--   - can we have some built-ins polymorphic over block type? Or a generic
--     block within an LLVM or Java block?
--   - should we have different top-level versus spec-level proof commands?
--   - is the LLVMObject/JavaObject approach reasonable?
--   - should the type parameter in CryptolSetup, etc., be used for anything
--     in the simulators?
--   - should we use  underscore_naming or camelCase?
--   - what sort of syntactic sugar should we provide on top of these
--     primitive functions?
--

data TopLevel :: sort 0 -> sort 0 where { }
data CryptolSetup :: sort 0 -> sort 0 where { }
data CryptolVerifyResult :: sort 0 where { }
data JavaSetup :: sort 0 -> sort 0 where { }
data JavaVerifyResult :: sort 0 where { }
data LLVMSetup :: sort 0 -> sort 0 where { }
data LLVMVerifyResult :: sort 0 where { }
data List :: sort 0 -> sort 0 where { }

-- We start by declaring the types of some primitive functions.

data Context :: sort 0 where {
   TopLevelContext :: Context;
}

block :: Context -> sort 0 -> sort 0;
block TopLevelContext t = TopLevel t;

topBind :: (a b :: sort 0) -> TopLevel a -> (a -> TopLevel b) -> TopLevel b;
topReturn :: (a :: sort 0) -> a -> TopLevel a;

bind :: (m :: Context) -> (a b :: sort 0) -> block m a -> (a -> block m b) -> block m b;
bind TopLevelContext = topBind;

return :: (m :: Context) -> (a :: sort 0) -> a -> block m a;
return TopLevelContext = topReturn;

-- A type to represent SAWCore shared terms.
data Term :: sort 0 where { }

-- SharedTerm primitives
termTrue :: TopLevel Term;
termFalse :: TopLevel Term;
termNat :: Nat -> TopLevel Term;
termVec :: (n :: Nat) -> Term -> Vec n Term -> TopLevel Term;
termGet :: Term -> Term -> Term -> TopLevel Term;
termTuple :: (n :: Nat) -> Vec n Term -> TopLevel Term;
termRecord :: (n :: Nat) -> Vec n #(String, Term) -> TopLevel Term;
termSelect :: Term -> String -> TopLevel Term;
termLocalVar :: Nat -> Term -> TopLevel Term;
termGlobal :: String -> TopLevel Term;
termLambda :: String -> Term -> Term -> TopLevel Term;
termApp :: Term -> Term -> TopLevel Term;
termEqual :: Term -> Term -> TopLevel Term;
termNot :: Term -> TopLevel Term;

termUnit :: TopLevel Term;
termUnit = termTuple 0 (EmptyVec Term);

topTraverse :: (a b :: sort 0) -> (n :: Nat) -> (a -> TopLevel b) -> Vec n a -> TopLevel (Vec n b);
topTraverse a b _ f (EmptyVec _) = topReturn (Vec 0 b) (EmptyVec b);
topTraverse a b _ f (ConsVec _ x n xs) =
  topBind b (Vec (Succ n) b) (f x) (\(y::b) ->
  topBind (Vec n b) (Vec (Succ n) b) (topTraverse a b n f xs) (\(ys::Vec n b) ->
  topReturn (Vec (Succ n) b) (ConsVec b y n ys)));

topSequence :: (a :: sort 0) -> (n :: Nat) -> Vec n (TopLevel a) -> TopLevel (Vec n a);
topSequence a n = topTraverse (TopLevel a) a n (\(x::TopLevel a) -> x);
{-
topSequence a _ (EmptyVec _) = topReturn (Vec 0 a) (EmptyVec a);
topSequence a _ (ConsVec _ x n xs) =
  topBind a (Vec (Succ n) a) x (\(y::a) ->
  topBind (Vec n a) (Vec (Succ n) a) (topSequence a n xs) (\(ys::Vec n a) ->
  topReturn (Vec (Succ n) a) (ConsVec a y n ys)));
-}

termVec' :: (n :: Nat) -> TopLevel Term -> Vec n (TopLevel Term) -> TopLevel Term;
termVec' n m ms =
  topBind Term Term m (\(a::Term) ->
  topBind (Vec n Term) Term (topSequence Term n ms) (termVec n a));

termTuple' :: (n :: Nat) -> Vec n (TopLevel Term) -> TopLevel Term;
termTuple' n ms = topBind (Vec n Term) Term (topSequence Term n ms) (termTuple n);

termRecord' :: (n :: Nat) -> Vec n #(String, TopLevel Term) -> TopLevel Term;
termRecord' n v =
  topBind (Vec n #(String, Term)) Term
    (topTraverse #(String, TopLevel Term) #(String, Term) n
      (\(x::#(String, TopLevel Term)) ->
        topBind Term #(String, Term) (x.2) (\(t::Term) -> topReturn #(String, Term) (x.1, t)))
    v) (termRecord n);

termSelect' :: TopLevel Term -> String -> TopLevel Term;
termSelect' m s = topBind Term Term m (\(t::Term) -> termSelect t s);

termLocalVar' :: Nat -> TopLevel Term -> TopLevel Term;
termLocalVar' n m = topBind Term Term m (\(t::Term) -> termLocalVar n t);

termLambda' :: String -> TopLevel Term -> TopLevel Term -> TopLevel Term;
termLambda' s m1 m2 =
  topBind Term Term m1 (\(t1::Term) ->
  topBind Term Term m2 (\(t2::Term) -> termLambda s t1 t2));

termApp' :: TopLevel Term -> TopLevel Term -> TopLevel Term;
termApp' m1 m2 =
  topBind Term Term m1 (\(t1::Term) ->
  topBind Term Term m2 (\(t2::Term) -> termApp t1 t2));

bvNatIdent :: String;

termBvNat :: Nat -> Nat -> TopLevel Term;
termBvNat w x =
  topBind Term Term (termGlobal bvNatIdent) (\(t0::Term) ->
  topBind Term Term (termNat w) (\(t1::Term) ->
  topBind Term Term (termApp t0 t1) (\(t2::Term) ->
  topBind Term Term (termNat x) (\(t3::Term) ->
  termApp t2 t3))));

evaluate :: (a :: sort 0) -> Term -> a;

read_sbv :: String -> TopLevel Term;
read_aig :: String -> TopLevel Term;

write_aig :: String -> Term -> TopLevel #();
write_smtlib1 :: String -> Term -> TopLevel #();
write_smtlib2 :: String -> Term -> TopLevel #();

-- A VerifyResult encodes either a statement of what it proved, or a
-- counterexample. These work like the method specs in the first version
-- of SAWScript.
cryptol_verify :: String -> String -> CryptolSetup #()
               -> TopLevel CryptolVerifyResult;
llvm_verify :: String -> String -> LLVMSetup #() -> TopLevel LLVMVerifyResult;
java_verify :: String -> JavaSetup #() -> TopLevel JavaVerifyResult;

-- Extract pure models from suitably well-structured programs. We assume
-- that these are well-typed, and check at runtime.
cryptol_extract :: String -> String -> CryptolSetup #() -> TopLevel Term;
llvm_extract :: String -> String -> LLVMSetup #() -> TopLevel Term;
java_extract :: String -> String -> JavaSetup #() -> TopLevel Term;

-- One method is currently available for Cryptol extraction.
sbv :: CryptolSetup #();

-- Set up symbolic simulation for a pure function from fixed-size arguments
-- to fixed-size return value.
llvm_pure :: LLVMSetup #();
java_pure :: JavaSetup #();

-- A successful proof about a method can be used to override calls to
-- the method. The requirement to provide verification results serves
-- two purposes:
--   - it tells the simulator how to provide inputs and interpret outputs
--   - it ensures soundness by only allowing overrides that are proven correct
llvm_override :: List LLVMVerifyResult -> LLVMSetup #();
java_override :: List JavaVerifyResult -> JavaSetup #();

-- We can uninterpret particular names along with overrides. Is this
-- the right approach? For Cryptol, uninterpreting is the only form of
-- overriding. For LLVM and Java, it can complement overriding by causing
-- portions of the overriding model to be left uninterpreted.
java_uninterpret :: List String -> JavaSetup #();
llvm_uninterpret :: List String -> LLVMSetup #();

-- It would be nice to allow some sort of type classing, or something
-- similar, so that certain operations would be legal in multiple
-- contexts (e.g., Java and LLVM).

-- State that the current function returns the given value. We assume,
-- again, that the argument is of the right type, and check at runtime.
java_return :: Term -> JavaSetup #();
llvm_return :: Term -> LLVMSetup #();

-- Declare that the particular expression is an output, for model
-- extraction.
java_output :: Term -> JavaSetup #();
llvm_output :: Term -> LLVMSetup #();

-- Declare that the particular expression is an input, for model
-- extraction.
java_input :: Term -> JavaSetup #();
llvm_input :: Term -> LLVMSetup #();

-- Assert a particular starting condition.
java_assert :: Bool -> JavaSetup #();
llvm_assert :: Bool -> LLVMSetup #();

data JavaObject :: sort 0 where { }
data LLVMObject :: sort 0 where { }

-- Assign the given value to the given object before execution.
java_assume_equal :: JavaObject -> Term -> JavaSetup #();
llvm_assume_equal :: LLVMObject -> Term -> LLVMSetup #();

-- Ensure that the given object is assigned the given value on
-- termination.
java_ensure_equal :: JavaObject -> Term -> JavaSetup #();
llvm_ensure_equal :: LLVMObject -> Term -> LLVMSetup #();

-- Java and LLVM statements that a particular object is modified with
-- an arbitrary value.
java_modify :: JavaObject -> JavaSetup #();
llvm_modify :: LLVMObject -> LLVMSetup #();

data ProofScript :: sort 0 -> sort 0 where { }
data ProofResult :: sort 0 where { }

-- These work in the context of an implicit goal.

data JavaType :: sort 0 where { }
data LLVMType :: sort 0 where { }

-- These allow us to refer to objects in the LLVM world.
llvm_var :: String -> LLVMType -> LLVMObject;
llvm_arg :: Nat -> LLVMType -> LLVMObject;
llvm_field :: LLVMObject -> String -> LLVMObject;
llvm_deref :: LLVMObject -> LLVMObject;

-- And in the Java world.
java_var :: String -> JavaType -> JavaObject;
java_arg :: Nat -> JavaType -> JavaObject;
java_field :: JavaObject -> String -> JavaObject;

-- And LLVM types.
llvm_struct :: String -> LLVMType;
llvm_ptr :: LLVMType -> LLVMType;
llvm_int :: Nat -> LLVMType; -- An LLVM integer with the given number of bits.
llvm_array :: Nat -> LLVMType -> LLVMType;

-- And Java types.
java_class :: String -> JavaType;
java_array :: Nat -> JavaType -> JavaType;
java_byte :: JavaType;
java_char :: JavaType;
java_int :: JavaType;
java_long :: JavaType;

llvm_may_alias :: List LLVMObject -> LLVMSetup #();
java_may_alias :: List JavaObject -> LLVMSetup #();

-- This allows us to project from an LLVM value into a native value.
-- We assume that these are well-typed, and check at runtime.
from_llvm :: LLVMObject -> Term;
from_java :: JavaObject -> Term;

-- Send the current goal to Yices, and return proof status.
yices :: ProofScript ProofResult;

-- Send the current goal to abc, and return proof status.
abc :: ProofScript ProofResult;

-- Prove the same goal with multiple provers.
multi_prove :: List (ProofScript ProofResult) -> ProofScript ProofResult;

-- TODO: might some theorem provers return new, simplified goals?

data Rule :: sort 0 where { }
data Goal :: sort 0 where { }

-- Rewrite rules.
rule :: ?(a :: sort 0) -> a -> a -> Rule;
expand :: ?(a :: sort 0) -> a -> Rule;

-- Rewrite the current goal with a default set of rules, and return
-- the rewritten term (also updating the implicit state?).
rewrite :: ProofScript Goal;

-- Rewrite with a specific set of results.
rewrite_with :: List Rule -> ProofScript Goal;

-- Any boolean expression can be a goal.
goal :: Bool -> Goal;

-- Goals can have quantifiers added.
forall :: ?(a :: sort 0) -> (a -> Goal) -> Goal;
exists :: ?(a :: sort 0) -> (a -> Goal) -> Goal;

-- Example:
--   forall (\a -> exists (\b -> goal (a == b)))

-- Top level proof commands.
-- Term arguments should have type Goal.
prove :: ProofScript ProofResult -> Term -> TopLevel ProofResult;
sat :: ProofScript ProofResult -> Term -> TopLevel ProofResult;
quickcheck :: ProofScript ProofResult -> Term -> TopLevel ProofResult;

-- Printing is polymorphic for now.
print :: ?(a :: sort 0) -> a -> TopLevel #();

data JavaOverride :: sort 0 where { }
data LLVMOverride :: sort 0 where { }
data JavaCounterExample :: sort 0 where { }
data LLVMCounterExample :: sort 0 where { }
data Theorem :: sort 0 where { }

java_verify_result :: ?(a :: sort 0)
                   -> JavaVerifyResult
                   -> (JavaOverride -> a)
                   -> (JavaCounterExample -> a)
                   -> a;

llvm_verify_result :: ?(a :: sort 0)
                   -> LLVMVerifyResult
                   -> (LLVMOverride -> a)
                   -> (LLVMCounterExample -> a)
                   -> a;

--proof_result :: ?(a :: sort 0)
--             -> ProofResult -> (Theorem -> a) -> (CounterExample -> a) -> a;

-- Something to make it easy to print the result of a proof. We don't
-- have case expressions in the language at the moment, and instead use
-- destructor functions for any built-in algebraic data types.
--show_result :: ProofResult #() -> TopLevel #()
--show_result r = proof_result r
--                (\thm -> print "Success!")
--                (\cex -> do { print "Failure:" ; print cex })
