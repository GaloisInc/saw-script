-- Copyright   : Galois, Inc. 2012-2014
-- License     : BSD3
-- Maintainer  : jhendrix@galois.com

module Prelude where

-- Grammar for the core prelude types.
--
-- We use double colons "::" to represent the type constraint on the core symbols.
--   e.g., "Bool :: sort 0" indicates "Bool" has type "sort 0"
-- Functions use "->" to separate arguments from result.
--   e.g., "f :: Bool -> Bool -> Bool"indicates "f" is a binary operation on Booleans.
--
-- Single colons ":" are used for for scoping variables to be used in subsequent arguments.
--   "f :: n : Integer -> Signed n -> Signed n"
-- This  indicates "f" is a function that takes an integer argument "n", and returns a function
-- that takes "n"-bit signed integer and returns another "n"-bit signed integer.


id :: (a :: sort 0) -> a -> a;
id _ x = x;

-- FIXME: We eventually need to remove this, as it violates soundness...
primitive fix :: (a :: sort 0) -> (a -> a) -> a;


-- FIXME: below are some defined data-types that could be used in place of
-- the SAW primitive types

--------------------------------------------------------------------------------
-- The Unit type

data UnitType :: sort 0 where {
    Unit :: UnitType;
  }

-- The recursor for the Unit type at sort 0
UnitType__rec :: (p :: UnitType -> sort 0) -> p Unit -> (u :: UnitType) -> p u;
UnitType__rec p f1 Unit = f1;


--------------------------------------------------------------------------------
-- Pair types

data PairType :: (a b :: sort 0) -> sort 0 where {
  PairValue :: (a b :: sort 0) -> a -> b -> PairType a b;
}

-- The recursor for primitive pair types at sort 1
Pair__rec :: (a b :: sort 0) -> (p :: PairType a b -> sort 0) ->
             ((x::a) -> (y::b) -> p (PairValue a b x y)) ->
             (pair :: PairType a b) -> p pair;
Pair__rec _ _ _ f (PairValue _ _ x y) = f x y;

Pair_fst :: (a b :: sort 0) -> PairType a b -> a;
Pair_fst a b = Pair__rec a b (\ (p::PairType a b) -> a)
                             (\ (x::a) -> \ (y:: b) -> x);

Pair_snd :: (a b :: sort 0) -> PairType a b -> b;
Pair_snd a b = Pair__rec a b (\ (p::PairType a b) -> b)
                             (\ (x::a) -> \ (y::b) -> y);

fst :: (a b :: sort 0) -> #(a | b) -> a;
fst a b (x | y) = x;

snd :: (a b :: sort 0) -> #(a | b) -> b;
snd a b (x | y) = y;

uncurry :: (a b c :: sort 0) -> (a -> b -> c) -> (#(a, b) -> c);
uncurry a b c f =
  (\ (x :: #(a, b)) -> f x.1 x.2);


--------------------------------------------------------------------------------
-- Record types

-- The empty record
data EmptyType :: sort 0 where {
  Empty :: EmptyType;
}

-- The recursor for the empty type at sort 0
EmptyType__rec :: (p :: EmptyType -> sort 0) -> p Empty -> (u :: EmptyType) -> p u;
EmptyType__rec p f1 Empty = f1;

-- Add a named field to a record type
data RecordType :: (s::String) -> (a b ::sort 0) -> sort 0 where {
  RecordValue :: (s::String) -> (a b ::sort 0) -> a -> b -> RecordType s a b;
}

-- The recursor for record types at sort 0
RecordType__rec :: (s::String) -> (a b ::sort 0) ->
                   (p:: RecordType s a b -> sort 1) ->
                   ((x::a) -> (y::b) -> p (RecordValue s a b x y)) ->
                   (r::RecordType s a b) -> p r;
RecordType__rec _ _ _ _ f1 (RecordValue _ _ _ x y) = f1 x y;


--------------------------------------------------------------------------------
-- String values

primitive String :: sort 0;

primitive error :: (a :: sort 1) -> String -> a;


--------------------------------------------------------------------------------
-- Equality proofs.

data Eq :: (t :: sort 1) -> t -> t -> sort 1 where {
    Refl :: (u :: sort 1) -> (x :: u) -> Eq u x x;
  }

-- The eliminator for the Eq type at sort 1, assuming the usual parameter-index
-- structure of the Eq type
Eq__rec :: (t :: sort 1) -> (x :: t) -> (p :: (y :: t) -> Eq t x y -> sort 1) ->
           p x (Refl t x) -> (y :: t) -> (e :: Eq t x y) -> p y e;
Eq__rec t x p f1 _ (Refl _ _) = f1;

-- Congruence closure for equality
eq_cong :: (t :: sort 1) -> (x :: t) -> (y :: t) -> Eq t x y ->
           (u :: sort 1) -> (f :: t -> u) -> Eq u (f x) (f y);
eq_cong t x y eq u f =
  Eq__rec t x (\ (y'::t) -> \ (eq'::Eq t x y') -> Eq u (f x) (f y'))
          (Refl u (f x)) y eq;

sym :: (a :: sort 1) -> (x y :: a) -> Eq a x y -> Eq a y x;
sym a x y eq =
  Eq__rec a x (\ (y'::a) -> \ (eq'::Eq a x y') -> Eq a y' x) (Refl a x) y eq;

trans :: (a :: sort 1) -> (x y z :: a) -> Eq a x y -> Eq a y z -> Eq a x z;
trans a x y z eq1 eq2 =
  Eq__rec a y (\ (y'::a) -> \ (eq'::Eq a y y') -> Eq a x y') eq1 z eq2;


trans4 :: (a :: sort 1) -> (w x y z :: a) ->
          Eq a w x -> Eq a x y -> Eq a y z -> Eq a w z;
trans4 a w x y z eq1 eq2 eq3 =
  trans a w x z eq1 (trans a x y z eq2 eq3);

eq_inv_map :: (a b :: sort 1) -> (a1 a2 :: a) -> Eq a a1 a2 ->
              (f1 f2 :: a -> b) -> Eq b (f1 a2) (f2 a2) ->
              Eq b (f1 a1) (f2 a1);
eq_inv_map a b a1 a2 eq_a f1 f2 eq_f =
  trans
    b (f1 a1) (f1 a2) (f2 a1)
    (eq_cong a a1 a2 eq_a b f1)
    (trans b (f1 a2) (f2 a2) (f2 a1) eq_f
           (eq_cong a a2 a1 (sym a a1 a2 eq_a) b f2));

-- Unchecked assertion that two types are equal.
axiom unsafeAssert :: (a :: sort 1) -> (x :: a) -> (y :: a) -> Eq a x y;


primitive coerce :: (a b :: sort 0) -> Eq (sort 0) a b -> a -> b;

coerce__def :: (a b :: sort 0) -> Eq (sort 0) a b -> a -> b;
coerce__def a b eq x =
   Eq__rec (sort 0) a (\ (b'::sort 0) -> \ (eq'::Eq (sort 0) a b') -> b') x b eq;

axiom coerce__eq ::
  Eq ((a b :: sort 0) -> Eq (sort 0) a b -> a -> b) coerce coerce__def;


-- NOTE: this is equivalent to UIP / Axiom K
{-
coerce_same :: (a :: sort 0) -> (q :: Eq (sort 0) a a) -> (x :: a) -> Eq a (coerce a a q x) x;
coerce_same a (Refl _ _) x = Refl a x;
-}

rcoerce :: (a b :: sort 0) -> Eq (sort 0) a b -> b -> a;
rcoerce a b q = coerce b a (sym (sort 0) a b q);

-- NOTE: this is equivalent to UIP / Axiom K
{-
rcoerce_same :: (a :: sort 0) -> (q :: Eq (sort 0) a a) -> (x :: a) -> Eq a (rcoerce a a q x) x;
rcoerce_same a q x = coerce_same a (sym (sort 0) a a q) x;
-}

unsafeCoerce :: (a b :: sort 0) -> a -> b;
unsafeCoerce a b = coerce a b (unsafeAssert (sort 0) a b);

axiom unsafeCoerce_same :: (a :: sort 0) -> (x :: a) ->
                           Eq a (unsafeCoerce a a x) x;

-- NOTE: We could prove unsafeCoerce_same if we were willing to allow UIP...
{-
unsafeCoerce_same :: (a :: sort 0) -> (x :: a) -> Eq a (unsafeCoerce a a x) x;
unsafeCoerce_same a x = coerce_same a (unsafeAssert (sort 0) a a) x;
-}

piCong0 :: (r x y :: sort 0) -> Eq (sort 0) x y -> (Eq (sort 0) (x -> r) (y -> r));
piCong0 r x y eq =
  Eq__rec
    (sort 0) x
    (\ (y':: sort 0) -> \ (eq':: Eq (sort 0) x y') ->
       Eq (sort 0) (x -> r) (y' -> r))
    (Refl (sort 0) (x -> r)) y eq;

piCong1 :: (r x y :: sort 0) -> Eq (sort 0) x y -> (Eq (sort 0) (r -> x) (r -> y));
piCong1 r x y eq =
  Eq__rec
    (sort 0) x
    (\ (y':: sort 0) -> \ (eq':: Eq (sort 0) x y') ->
       Eq (sort 0) (r -> x) (r -> y'))
    (Refl (sort 0) (r -> x)) y eq;


--------------------------------------------------------------------------------
-- Booleans
data Bool :: sort 0 where {
    True :: Bool;
    False :: Bool;
  }

Bool__rec :: (p :: Bool -> sort 1) -> (p True) -> (p False) -> (b::Bool) -> p b;
Bool__rec p f1 f2 (True) = f1;
Bool__rec p f1 f2 (False) = f2;


primitive not :: Bool -> Bool;

not__def :: Bool -> Bool;
not__def = \ (b::Bool) -> Bool__rec (\ (b::Bool) -> Bool) False True b;

axiom not__eq :: Eq (Bool -> Bool) not not__def;


primitive and :: Bool -> Bool -> Bool;

and__def :: Bool -> Bool -> Bool;
and__def = \ (b1::Bool) -> \ (b2::Bool) ->
             Bool__rec (\ (b::Bool) -> Bool) b2 False b1;

axiom and__eq :: Eq (Bool -> Bool -> Bool) and and__def;


primitive or :: Bool -> Bool -> Bool;

or__def :: Bool -> Bool -> Bool;
or__def = \ (b1::Bool) -> \ (b2::Bool) ->
            Bool__rec (\ (b::Bool) -> Bool) True b2 b1;

axiom or__eq :: Eq (Bool -> Bool -> Bool) or or__def;


primitive xor :: Bool -> Bool -> Bool;

xor__def :: Bool -> Bool -> Bool;
xor__def = \ (b1::Bool) -> \ (b2::Bool) ->
             Bool__rec (\ (b::Bool) -> Bool) (not b2) b2 b1;

axiom xor__eq :: Eq (Bool -> Bool -> Bool) xor xor__def;


{-
primitive implies :: Bool -> Bool -> Bool;

implies__def :: Bool -> Bool -> Bool;
implies__def = \ (a::Bool) -> \ (b::Bool) -> or (not a) b;

axiom implies__eq :: Eq (Bool -> Bool -> Bool) implies implies__def;
-}

-- Implies is not a primitive, as it is not mapped by any of the simulator
-- back-ends; instead, it is just defined in terms of or and not
implies :: Bool -> Bool -> Bool;
implies = \ (a::Bool) -> \ (b::Bool) -> or (not a) b;


primitive boolEq :: Bool -> Bool -> Bool;

boolEq__def :: Bool -> Bool -> Bool;
boolEq__def = \ (b1::Bool) -> \ (b2::Bool) ->
                Bool__rec (\ (b::Bool) -> Bool) b2 (not b2) b1;

axiom boolEq__eq :: Eq (Bool -> Bool -> Bool) boolEq boolEq__def;


primitive ite :: (a :: sort 1) -> Bool -> a -> a -> a;

ite__def :: (a :: sort 1) -> Bool -> a -> a -> a;
ite__def = \ (a::sort 1) -> \ (b::Bool) -> \ (a1::a) -> \ (a2::a) ->
             Bool__rec (\ (b::Bool) -> a) a1 a2 b;

-- FIXME: we need universe polymorphism to write this equality correctly!
axiom ite__eq :: (a::sort 1) -> Eq (Bool -> a -> a -> a) (ite a) (ite__def a);


-- Rewrite rules for booleans.

not_not :: (x :: Bool) -> Eq Bool (not (not x)) x;
not_not x =
  trans
    Bool (not (not x)) (not__def (not__def x)) x
    (eq_cong (Bool -> Bool) not not__def not__eq Bool
             (\ (f::Bool -> Bool) -> f (f x)))
    (Bool__rec (\ (x::Bool) -> Eq Bool (not__def (not__def x)) x)
               (Refl Bool True) (Refl Bool False) x);

and__def_True :: (x :: Bool) -> Eq Bool (and__def x True) x;
and__def_True x =
  Bool__rec (\ (x::Bool) -> Eq Bool (and__def x True) x)
            (Refl Bool True) (Refl Bool False) x;

and_True :: (x :: Bool) -> Eq Bool (and x True) x;
and_True x =
  trans
    Bool (and x True) (and__def x True) x
    (eq_cong (Bool -> Bool -> Bool) and and__def and__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f x True))
    (and__def_True x);

and_False :: (x :: Bool) -> Eq Bool (and x False) False;
and_False x =
  trans
    Bool (and x False) (and__def x False) False
    (eq_cong (Bool -> Bool -> Bool) and and__def and__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f x False))
    (Bool__rec (\ (x::Bool) -> Eq Bool (and__def x False) False)
               (Refl Bool False) (Refl Bool False) x);

and_True2 :: (x :: Bool) -> Eq Bool (and True x) x;
and_True2 x =
  trans
    Bool (and True x) (and__def True x) x
    (eq_cong (Bool -> Bool -> Bool) and and__def and__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f True x))
    (Refl Bool x);

and_False2 :: (x :: Bool) -> Eq Bool (and False x) False;
and_False2 x =
  trans
    Bool (and False x) (and__def False x) False
    (eq_cong (Bool -> Bool -> Bool) and and__def and__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f False x))
    (Refl Bool False);

and_assoc :: (x y z :: Bool) -> Eq Bool (and x (and y z)) (and (and x y) z);
and_assoc x y z =
  eq_inv_map
    (Bool -> Bool -> Bool) Bool and and__def and__eq
    (\ (f::Bool -> Bool -> Bool) -> f x (f y z))
    (\ (f::Bool -> Bool -> Bool) -> f (f x y ) z)
    (Bool__rec (\ (b::Bool) ->
                  Eq Bool (and__def b (and__def y z))
                     (and__def (and__def b y) z))
                     (Refl Bool (and__def y z))
                     (Refl Bool False)
                     x);

and_idem :: (x :: Bool) -> Eq Bool (and x x) x;
and_idem x =
  trans
    Bool (and x x) (and__def x x) x
    (eq_cong (Bool -> Bool -> Bool) and and__def and__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f x x))
    (Bool__rec (\ (b::Bool) -> Eq Bool (and__def b b) b)
               (Refl Bool True) (Refl Bool False) x);

or_True :: (x :: Bool) -> Eq Bool (or x True) True;
or_True x =
  trans
    Bool (or x True) (or__def x True) True
    (eq_cong (Bool -> Bool -> Bool) or or__def or__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f x True))
    (Bool__rec (\ (b::Bool) -> Eq Bool (or__def b True) True)
               (Refl Bool True) (Refl Bool True) x);

or_False :: (x :: Bool) -> Eq Bool (or x False) x;
or_False x =
  trans
    Bool (or x False) (or__def x False) x
    (eq_cong (Bool -> Bool -> Bool) or or__def or__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f x False))
    (Bool__rec (\ (b::Bool) -> Eq Bool (or__def b False) b)
               (Refl Bool True) (Refl Bool False) x);

or_True2 :: (x :: Bool) -> Eq Bool (or True x) True;
or_True2 x =
  trans
    Bool (or True x) (or__def True x) True
    (eq_cong (Bool -> Bool -> Bool) or or__def or__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f True x))
    (Refl Bool True);

or_False2 :: (x :: Bool) -> Eq Bool (or False x) x;
or_False2 x =
  trans
    Bool (or False x) (or__def False x) x
    (eq_cong (Bool -> Bool -> Bool) or or__def or__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f False x))
    (Refl Bool x);

or_assoc :: (x y z :: Bool) -> Eq Bool (or x (or y z)) (or (or x y) z);
or_assoc x y z =
  eq_inv_map
    (Bool -> Bool -> Bool) Bool or or__def or__eq
    (\ (f::Bool -> Bool -> Bool) -> f x (f y z))
    (\ (f::Bool -> Bool -> Bool) -> f (f x y ) z)
    (Bool__rec (\ (b::Bool) ->
                  Eq Bool (or__def b (or__def y z))
                     (or__def (or__def b y) z))
                     (Refl Bool True)
                     (Refl Bool (or__def y z))
                     x);

or_idem :: (x :: Bool) -> Eq Bool (or x x) x;
or_idem x =
  trans
    Bool (or x x) (or__def x x) x
    (eq_cong (Bool -> Bool -> Bool) or or__def or__eq Bool
             (\ (f::Bool -> Bool -> Bool) -> f x x))
    (Bool__rec (\ (b::Bool) -> Eq Bool (or__def b b) b)
               (Refl Bool True) (Refl Bool False) x);

true_implies :: (x :: Bool) -> Eq Bool (implies True x) x;
true_implies x =
  trans
    Bool (or (not True) x) (or False x) x
    (eq_cong (Bool -> Bool) not not__def not__eq Bool
             (\ (f::Bool -> Bool) -> or (f True) x))
    (or_False2 x);

not_or :: (x y :: Bool) -> Eq Bool (not (or x y)) (and (not x) (not y));
not_or x y =
  trans4
    Bool (not (or x y)) (not (or__def x y))
         (and__def (not x) (not y)) (and (not x) (not y))
    (eq_cong (Bool -> Bool -> Bool) or or__def or__eq Bool
             (\ (f :: Bool -> Bool -> Bool) -> not (f x y)))
    (eq_inv_map
       (Bool -> Bool) Bool not not__def not__eq
       (\ (f :: Bool -> Bool) -> f (or__def x y))
       (\ (f :: Bool -> Bool) -> and__def (f x) (f y))
       (Bool__rec (\ (b::Bool) ->
                     Eq Bool (not__def (or__def b y))
                        (and__def (not__def b) (not__def y)))
                  (Refl Bool False)
                  (Refl Bool (not__def y)) x))
    (eq_cong (Bool -> Bool -> Bool) and__def and
             (sym (Bool -> Bool -> Bool) and and__def and__eq) Bool
             (\ (f :: Bool -> Bool -> Bool) -> f (not x) (not y)));

not_and :: (x y :: Bool) -> Eq Bool (not (and x y)) (or (not x) (not y));
not_and x y =
  trans4
    Bool (not (and x y)) (not (and__def x y))
         (or__def (not x) (not y)) (or (not x) (not y))
    (eq_cong (Bool -> Bool -> Bool) and and__def and__eq Bool
             (\ (f :: Bool -> Bool -> Bool) -> not (f x y)))
    (eq_inv_map
       (Bool -> Bool) Bool not not__def not__eq
       (\ (f :: Bool -> Bool) -> f (and__def x y))
       (\ (f :: Bool -> Bool) -> or__def (f x) (f y))
       (Bool__rec (\ (b::Bool) ->
                     Eq Bool (not__def (and__def b y))
                     (or__def (not__def b) (not__def y)))
                  (Refl Bool (not__def y))
                  (Refl Bool True) x))
    (eq_cong (Bool -> Bool -> Bool) or__def or
             (sym (Bool -> Bool -> Bool) or or__def or__eq) Bool
             (\ (f :: Bool -> Bool -> Bool) -> f (not x) (not y)));

ite_not :: (a :: sort 1) -> (b :: Bool) -> (x y :: a) ->
           Eq a (ite a (not b) x y) (ite a b y x);
ite_not a b x y =
  trans
    a (ite a (not b) x y) (ite a (not__def b) x y) (ite a b y x)
    (eq_cong (Bool -> Bool) not not__def not__eq a
             (\ (f :: Bool -> Bool) -> ite a (f b) x y))
    (eq_inv_map
       (Bool -> a -> a -> a) a (ite a) (ite__def a) (ite__eq a)
       (\ (g :: Bool -> a -> a -> a) -> g (not__def b) x y)
       (\ (g :: Bool -> a -> a -> a) -> g b y x)
       (Bool__rec (\ (b'::Bool) ->
                     Eq a (ite__def a (not__def b') x y) (ite__def a b' y x))
                  (Refl a y) (Refl a x) b));

ite_nest1 :: (a :: sort 1) -> (b :: Bool) -> (x y z :: a) ->
             Eq a (ite a b x (ite a b y z)) (ite a b x z);
ite_nest1 a b x y z =
  eq_inv_map
    (Bool -> a -> a -> a) a (ite a) (ite__def a) (ite__eq a)
    (\ (f :: Bool -> a -> a -> a) -> f b x (f b y z))
    (\ (f :: Bool -> a -> a -> a) -> f b x z)
    (Bool__rec (\ (b'::Bool) ->
                  Eq a (ite__def a b' x (ite__def a b' y z)) (ite__def a b' x z))
               (Refl a x) (Refl a z) b);

ite_nest2 :: (a :: sort 1) -> (b :: Bool) -> (x y z :: a) ->
             Eq a (ite a b (ite a b x y) z) (ite a b x z);
ite_nest2 a b x y z =
  eq_inv_map
    (Bool -> a -> a -> a) a (ite a) (ite__def a) (ite__eq a)
    (\ (f :: Bool -> a -> a -> a) -> f b (f b x y) z)
    (\ (f :: Bool -> a -> a -> a) -> f b x z)
    (Bool__rec (\ (b'::Bool) ->
                  Eq a (ite__def a b' (ite__def a b' x y) z) (ite__def a b' x z))
               (Refl a x) (Refl a z) b);

ite_bit :: (b :: Bool) -> (c :: Bool) -> (d :: Bool) ->
           Eq Bool (ite Bool b c d) (and (or (not b) c) (or b d));
ite_bit b c d =
  trans4
    Bool (ite Bool b c d) (ite__def Bool b c d)
    (and__def (or__def (not__def b) c) (or__def b d))
    (and (or (not b) c) (or b d))
    (eq_cong
       (Bool -> Bool -> Bool -> Bool) (ite Bool) (ite__def Bool)
       (ite__eq Bool) Bool
       (\ (f::Bool -> Bool -> Bool -> Bool) -> (f b c d)))
    (Bool__rec
       (\ (b'::Bool) ->
          Eq Bool (ite__def Bool b' c d)
          (and__def (or__def (not__def b') c) (or__def b' d)))
       (sym Bool (and__def c True) c (and__def_True c)) (Refl Bool d) b)
    (trans4
       Bool (and__def (or__def (not__def b) c) (or__def b d))
       (and__def (or (not__def b) c) (or b d))
       (and (or (not__def b) c) (or b d))
       (and (or (not b) c) (or b d))
       (eq_cong
          (Bool -> Bool -> Bool) or__def or
          (sym (Bool -> Bool -> Bool) or or__def or__eq)
          Bool
          (\ (f::Bool -> Bool -> Bool) ->
             (and__def (f (not__def b) c) (f b d))))
       (eq_cong
          (Bool -> Bool -> Bool) and__def and
          (sym (Bool -> Bool -> Bool) and and__def and__eq)
          Bool
          (\ (f::Bool -> Bool -> Bool) ->
             (f (or (not__def b) c) (or b d))))
       (eq_cong
          (Bool -> Bool) not__def not
          (sym (Bool -> Bool) not not__def not__eq)
          Bool
          (\ (f::Bool -> Bool) ->
             (and (or (f b) c) (or b d)))));

ite_bit_false_1 :: (b :: Bool) -> (c :: Bool) ->
                   Eq Bool (ite Bool b False c) (and (not b) c);
ite_bit_false_1 b c =
  trans4
    Bool (ite Bool b False c) (ite__def Bool b False c)
    (and__def (not__def b) c) (and (not b) c)
    (eq_cong
       (Bool -> Bool -> Bool -> Bool) (ite Bool) (ite__def Bool)
       (ite__eq Bool) Bool
       (\ (f::Bool -> Bool -> Bool -> Bool) -> (f b False c)))
    (Bool__rec
       (\ (b'::Bool) ->
          Eq Bool (ite__def Bool b' False c) (and__def (not__def b') c))
       (Refl Bool False) (Refl Bool c) b)
    (trans
       Bool (and__def (not__def b) c) (and (not__def b) c) (and (not b) c)
       (eq_cong
          (Bool -> Bool -> Bool) and__def and
          (sym (Bool -> Bool -> Bool) and and__def and__eq) Bool
          (\ (f::Bool -> Bool -> Bool) -> (f (not__def b) c)))
       (eq_cong
          (Bool -> Bool) not__def not
          (sym (Bool -> Bool) not not__def not__eq)
          Bool
          (\ (f::Bool -> Bool) -> (and (f b) c))));

ite_bit_true_1 :: (b :: Bool) -> (c :: Bool) ->
                  Eq Bool (ite Bool b True c) (or b c);
ite_bit_true_1 b c =
  trans4
    Bool (ite Bool b True c) (ite__def Bool b True c) (or__def b c) (or b c)
    (eq_cong
       (Bool -> Bool -> Bool -> Bool) (ite Bool) (ite__def Bool)
       (ite__eq Bool) Bool
       (\ (f::Bool -> Bool -> Bool -> Bool) -> (f b True c)))
    (Bool__rec
       (\ (b'::Bool) -> Eq Bool (ite__def Bool b' True c) (or__def b' c))
       (Refl Bool True) (Refl Bool c) b)
    (eq_cong
       (Bool -> Bool -> Bool) or__def or
       (sym (Bool -> Bool -> Bool) or or__def or__eq)
       Bool
       (\ (f::Bool -> Bool -> Bool) -> f b c));

ite_fold_not :: (b :: Bool) -> Eq Bool (ite Bool b False True) (not b);
ite_fold_not b =
  trans4
    Bool (ite Bool b False True) (ite__def Bool b False True)
    (not__def b) (not b)
    (eq_cong
       (Bool -> Bool -> Bool -> Bool) (ite Bool) (ite__def Bool)
       (ite__eq Bool) Bool
       (\ (f::Bool -> Bool -> Bool -> Bool) -> (f b False True)))
    (Bool__rec
       (\ (b'::Bool) -> Eq Bool (ite__def Bool b' False True) (not__def b'))
       (Refl Bool False) (Refl Bool True) b)
    (eq_cong
       (Bool -> Bool) not__def not
       (sym (Bool -> Bool) not not__def not__eq)
       Bool (\ (f::Bool -> Bool) -> f b));

ite_eq :: (a :: sort 1) -> (b :: Bool) -> (x :: a) -> Eq a (ite a b x x) x;
ite_eq a b x =
  trans
    a (ite a b x x) (ite__def a b x x) x
    (eq_cong
       (Bool -> a -> a -> a) (ite a) (ite__def a) (ite__eq a) a
       (\ (f::Bool -> a -> a -> a) -> (f b x x)))
    (Bool__rec (\ (b'::Bool) ->
                  Eq a (ite__def a b' x x) x) (Refl a x) (Refl a x) b);

ite_true :: (a :: sort 1) -> (x y :: a) -> Eq a (ite a True x y) x;
ite_true a x y =
  trans
    a (ite a True x y) (ite__def a True x y) x
    (eq_cong
       (Bool -> a -> a -> a) (ite a) (ite__def a) (ite__eq a) a
       (\ (f::Bool -> a -> a -> a) -> (f True x y)))
    (Refl a x);

ite_false :: (a :: sort 1) -> (x y :: a) -> Eq a (ite a False x y) y;
ite_false a x y =
  trans
    a (ite a False x y) (ite__def a False x y) y
    (eq_cong
       (Bool -> a -> a -> a) (ite a) (ite__def a) (ite__eq a) a
       (\ (f::Bool -> a -> a -> a) -> (f False x y)))
    (Refl a y);

or_triv1 :: (x :: Bool) -> Eq Bool (or x (not x)) True;
or_triv1 x =
  trans4
    Bool (or x (not x)) (or x (not__def x)) (or__def x (not__def x)) True
    (eq_cong
       (Bool -> Bool) not not__def not__eq Bool
       (\ (f::Bool -> Bool) -> or x (f x)))
    (eq_cong
       (Bool -> Bool -> Bool) or or__def or__eq Bool
       (\ (f::Bool -> Bool -> Bool) -> f x (not__def x)))
    (Bool__rec
       (\ (b::Bool) -> Eq Bool (or__def b (not__def b)) True)
       (Refl Bool True) (Refl Bool True) x);

or_triv2 :: (x :: Bool) -> Eq Bool (or (not x) x) True;
or_triv2 x =
  trans4
    Bool (or (not x) x) (or (not__def x) x) (or__def (not__def x) x) True
    (eq_cong
       (Bool -> Bool) not not__def not__eq Bool
       (\ (f::Bool -> Bool) -> or (f x) x))
    (eq_cong
       (Bool -> Bool -> Bool) or or__def or__eq Bool
       (\ (f::Bool -> Bool -> Bool) -> f (not__def x) x))
    (Bool__rec
       (\ (b::Bool) -> Eq Bool (or__def (not__def b) b) True)
       (Refl Bool True) (Refl Bool True) x);

and_triv1 :: (x :: Bool) -> Eq Bool (and x (not x)) False;
and_triv1 x =
  trans4
    Bool (and x (not x)) (and x (not__def x)) (and__def x (not__def x)) False
    (eq_cong
       (Bool -> Bool) not not__def not__eq Bool
       (\ (f::Bool -> Bool) -> and x (f x)))
    (eq_cong
       (Bool -> Bool -> Bool) and and__def and__eq Bool
       (\ (f::Bool -> Bool -> Bool) -> f x (not__def x)))
    (Bool__rec
       (\ (b::Bool) -> Eq Bool (and__def b (not__def b)) False)
       (Refl Bool False) (Refl Bool False) x);

and_triv2 :: (x :: Bool) -> Eq Bool (and (not x) x) False;
and_triv2 x =
  trans4
    Bool (and (not x) x) (and (not__def x) x) (and__def (not__def x) x) False
    (eq_cong
       (Bool -> Bool) not not__def not__eq Bool
       (\ (f::Bool -> Bool) -> and (f x) x))
    (eq_cong
       (Bool -> Bool -> Bool) and and__def and__eq Bool
       (\ (f::Bool -> Bool -> Bool) -> f (not__def x) x))
    (Bool__rec
       (\ (b::Bool) -> Eq Bool (and__def (not__def b) b) False)
       (Refl Bool False) (Refl Bool False) x);


--------------------------------------------------------------------------------
-- Decidable equality

-- FIXME: replace universal decidable equality with a typeclass that determines
-- which types have an equality tester

primitive eq :: (a :: sort 0) -> a -> a -> Bool;

axiom eq_refl :: (a :: sort 0) -> (x :: a) -> Eq Bool (eq a x x) True;

axiom eq_Bool :: Eq (Bool -> Bool -> Bool) (eq Bool) boolEq;

axiom ite_eq_cong_1 :: (a :: sort 0)
              -> (b :: Bool) -> (x :: a) -> (y :: a) -> (z :: a)
              -> Eq Bool (eq a (ite a b x y) z) (ite Bool b (eq a x z) (eq a y z));
axiom ite_eq_cong_2 :: (a :: sort 0)
              -> (b :: Bool) -> (x :: a) -> (y :: a) -> (z :: a)
              -> Eq Bool (eq a z (ite a b x y)) (ite Bool b (eq a z x) (eq a z y));


--------------------------------------------------------------------------------
-- Either

data Either :: sort 0 -> sort 0 -> sort 0 where {
    Left  :: (s t :: sort 0) -> s -> Either s t;
    Right :: (s t :: sort 0) -> t -> Either s t;
  }

Either__rec :: (s t :: sort 0) -> (p :: Either s t -> sort 0) ->
               ((l :: s) -> p (Left s t l)) ->
               ((r :: t) -> p (Right s t r)) ->
               (e :: Either s t) -> p e;
Either__rec s t p f1 f2 (Left _ _ l) = f1 l;
Either__rec s t p f1 f2 (Right _ _ r) = f2 r;

either :: (a b c :: sort 0) -> (a -> c) -> (b -> c) -> Either a b -> c;
either a b c f g e =
  Either__rec a b (\ (p:: Either a b) -> c) f g e;

eitherCong0 :: (t x y :: sort 0) -> Eq (sort 0) x y ->
               Eq (sort 0) (Either x t) (Either y t);
eitherCong0 t x y eq =
  eq_cong (sort 0) x y eq (sort 0) (\ (y'::sort 0) -> Either y' t);

eitherCong1 :: (t x y :: sort 0) -> Eq (sort 0) x y ->
               Eq (sort 0) (Either t x) (Either t y);
eitherCong1 t x y eq =
  eq_cong (sort 0) x y eq (sort 0) (\ (y'::sort 0) -> Either t y');


--------------------------------------------------------------------------------
-- Maybe

data Maybe :: sort 0 -> sort 0 where {
    Nothing :: (a :: sort 0) -> Maybe a;
    Just :: (a :: sort 0) -> a -> Maybe a;
  }

Maybe__rec :: (a :: sort 0) -> (p :: (Maybe a) -> sort 0) ->
              p (Nothing a) -> ((x::a) -> p (Just a x)) -> (m :: Maybe a) -> p m;
Maybe__rec a p f1 f2 (Nothing _) = f1;
Maybe__rec a p f1 f2 (Just _ x) = f2 x;

maybe :: (a b :: sort 0) -> b -> (a -> b) -> Maybe a -> b;
maybe a b f1 f2 m = Maybe__rec a (\ (m'::Maybe a) -> b) f1 f2 m;


--------------------------------------------------------------------------------
-- Nat

data Nat :: sort 0 where {
    Zero :: Nat;
    Succ :: Nat -> Nat;
  }

Nat__rec :: (p :: Nat -> sort 1) -> p Zero -> ((n::Nat) -> p n -> p (Succ n)) ->
            (n::Nat) -> p n;
Nat__rec p f1 f2 Zero = f1;
Nat__rec p f1 f2 (Succ n) = f2 n (Nat__rec p f1 f2 n);

Nat_cases :: (a::sort 1) -> a -> (Nat -> a -> a) -> Nat -> a;
Nat_cases a f1 f2 n = Nat__rec (\ (n::Nat) -> a) f1 f2 n;

-- Build a binary function for Nats that satisfies:
--   Nat_cases2 a f1 f2 f3 Zero y = f1 y
--   Nat_cases2 a f1 f2 f3 (Succ x) Zero = f2 x
--   Nat_cases2 a f1 f2 f3 (Succ x) (Succ y) = f3 x y (Nat_cases2 ... x y)
Nat_cases2 :: (a::sort 1) -> (Nat -> a) -> (Nat -> a) ->
              (Nat -> Nat -> a -> a) -> Nat -> Nat -> a;
Nat_cases2 a f1 f2 f3 n m =
  Nat__rec (\ (n::Nat) -> Nat -> a) f1
          (\ (n::Nat) -> \ (f_rec :: Nat -> a) -> \ (m::Nat) ->
             Nat__rec (\ (m'::Nat) -> a) (f2 n)
                      (\ (m'::Nat) -> \ (frec'::a) -> f3 n m' (f_rec m')) m) n m;

eqNat :: Nat -> Nat -> sort 1;
eqNat x y = Eq Nat x y;

eqNatSucc :: (x y :: Nat) -> eqNat x y -> eqNat (Succ x) (Succ y);
eqNatSucc x y eq = eq_cong Nat x y eq Nat (\ (n::Nat) -> Succ n);

-- Predecessor
pred :: Nat -> Nat;
pred x = Nat_cases Nat Zero (\ (n::Nat) -> \ (m::Nat) -> n) x;

eqNatPrec :: (x y :: Nat) -> eqNat (Succ x) (Succ y) -> eqNat x y;
eqNatPrec x y eq' =
  eq_cong Nat (Succ x) (Succ y) eq' Nat pred;

-- | Addition
addNat :: Nat -> Nat -> Nat;
addNat x y =
  Nat_cases Nat y (\ (_::Nat) -> \ (prev_sum::Nat) -> Succ prev_sum) x;

eqNatAdd0 :: (x :: Nat) -> eqNat (addNat x 0) x;
eqNatAdd0 x =
  Nat__rec (\ (n::Nat) -> eqNat (addNat n 0) n)
           (Refl Nat 0)
           (\ (n::Nat) -> eqNatSucc (addNat n 0) n)
           x;

eqNatAddS :: (x y :: Nat) -> eqNat (addNat x (Succ y)) (Succ (addNat x y));
eqNatAddS x y =
  Nat__rec (\ (x'::Nat) -> (y'::Nat) ->
              eqNat (addNat x' (Succ y')) (Succ (addNat x' y')))
           (\ (y'::Nat) -> Refl Nat (Succ y'))
           (\ (x'::Nat) ->
            \ (eqF :: (y'::Nat) ->
                      eqNat (addNat x' (Succ y')) (Succ (addNat x' y'))) ->
            \ (y'::Nat) ->
              eqNatSucc (addNat x' (Succ y')) (Succ (addNat x' y')) (eqF y'))
           x y;

eqNatAddComm :: (x y :: Nat) -> eqNat (addNat x y) (addNat y x);
eqNatAddComm x y =
  Nat__rec (\ (y'::Nat) -> (x'::Nat) -> eqNat (addNat x' y') (addNat y' x'))
           (\ (x'::Nat) -> eqNatAdd0 x')
           (\ (y'::Nat) ->
            \ (eqF :: (x'::Nat) -> eqNat (addNat x' y') (addNat y' x')) ->
            \ (x'::Nat) ->
              trans Nat
                    (addNat x' (Succ y'))
                    (Succ (addNat x' y'))
                    (Succ (addNat y' x'))
                    (eqNatAddS x' y')
                    (eqNatSucc (addNat x' y') (addNat y' x') (eqNatAddComm x' y')))
           y x;

addNat_assoc :: (x y z :: Nat) ->
                eqNat (addNat x (addNat y z)) (addNat (addNat x y) z);
addNat_assoc x y z =
  Nat__rec (\ (x'::Nat) -> eqNat (addNat x' (addNat y z)) (addNat (addNat x' y) z))
           (Refl Nat (addNat y z))
           (\ (x'::Nat) ->
            \ (eq :: eqNat (addNat x' (addNat y z)) (addNat (addNat x' y) z)) ->
              eqNatSucc (addNat x' (addNat y z)) (addNat (addNat x' y) z) eq)
           x;

-- | Multiplication
mulNat :: Nat -> Nat -> Nat;
mulNat x y =
  Nat__rec (\ (x'::Nat) -> Nat) 0
           (\ (x'::Nat) -> \ (prod::Nat) -> addNat y prod) x;

equal0Nat :: Nat -> Bool;
equal0Nat n =
  Nat_cases Bool True (\ (n::Nat) -> \ (b::Bool) -> False) n;

equalNat :: Nat -> Nat -> Bool;
equalNat x y =
  Nat_cases (Nat -> Bool) equal0Nat
            (\ (n'::Nat) -> \ (eqN :: Nat -> Bool) -> \ (m::Nat) ->
               Nat_cases Bool False
                         (\ (m'::Nat) -> \ (b::Bool) -> eqN m') m) x y;

ltNat :: Nat -> Nat -> Bool;
ltNat x y =
  Nat_cases2 Bool (\ (x'::Nat) -> False)
             (\ (y'::Nat) -> True)
             (\ (y'::Nat) -> \ (x'::Nat) -> \ (lt_mn::Bool) -> lt_mn) y x;

-- | Subtraction
subNat :: Nat -> Nat -> Nat;
subNat x y =
  Nat_cases2 Nat (\ (x'::Nat) -> x')
             (\ (y'::Nat) -> Zero)
             (\ (y'::Nat) -> \ (x'::Nat) -> \ (sub_xy::Nat) -> sub_xy) y x;

-- | Minimum
minNat :: Nat -> Nat -> Nat;
minNat x y =
  Nat_cases2 Nat (\ (y'::Nat) -> Zero)
             (\ (x'::Nat) -> Zero)
             (\ (x'::Nat) -> \ (y'::Nat) -> \ (min_xy::Nat) -> Succ min_xy) x y;

-- | Maximum
maxNat :: Nat -> Nat -> Nat;
maxNat x y =
  Nat_cases2 Nat (\ (x'::Nat) -> x')
             (\ (y'::Nat) -> Succ y')
             (\ (y'::Nat) -> \ (x'::Nat) -> \ (sub_xy::Nat) -> sub_xy) y x;

-- | Width(n) = 1 + floor(log_2(n))
primitive widthNat :: Nat -> Nat;

-- | Axiom: equalNat implements *the* equality on type Nat.
axiom eq_Nat :: Eq (Nat -> Nat -> Bool) (eq Nat) equalNat;

-- | Natural exponentiation
expNat :: Nat -> Nat -> Nat;
expNat b e =
  Nat_cases Nat 1 (\ (e'::Nat) -> \ (exp_b_e::Nat) -> mulNat b exp_b_e) e;

-- | Natural division and modulus
primitive divModNat :: Nat -> Nat -> #(Nat, Nat);

divNat :: Nat -> Nat -> Nat;
divNat x y = (divModNat x y).1;

modNat :: Nat -> Nat -> Nat;
modNat x y = (divModNat x y).2;

-- There are implicit constructors from integer literals.

-- Dependent, non-recursive pattern matching combinator for natural numbers
natCase :: (p :: Nat -> sort 0) -> p Zero -> ((n :: Nat) -> p (Succ n)) ->
           (n :: Nat) -> p n;
natCase p z s = Nat__rec p z (\ (n::Nat) -> \ (r::p n) -> s n);

--------------------------------------------------------------------------------
-- "Vec n a" is an array of n elements, each with type "a".
primitive Vec :: Nat -> sort 0 -> sort 0;

-- Primitive function for generating an array.
primitive gen :: (n :: Nat) -> (a :: sort 0) -> (Nat -> a) -> Vec n a;

primitive atWithDefault :: (n :: Nat) -> (a :: sort 0) -> a -> Vec n a -> Nat -> a;

at :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Nat -> a;
at n a v i = atWithDefault n a (error a "at: index out of bounds") v i;
-- `at n a v i` has the precondition `ltNat i n`

primitive EmptyVec :: (a :: sort 0) -> Vec 0 a;

ConsVec :: (a :: sort 0) -> a -> (n :: Nat) -> Vec n a -> Vec (Succ n) a;
ConsVec a x n v =
  gen (Succ n) a (Nat_cases a x (\ (i::Nat) -> \ (a'::a) -> at n a v i));

upd :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Nat -> a -> Vec n a;
upd n a v j x = gen n a (\ (i :: Nat) -> ite a (equalNat i j) x (at n a v i));
-- TODO: assertion that j < n

-- | Return true if two vectors are equal, given a comparison function
-- for elements.
vecEq :: (n :: Nat) -> (a :: sort 0) -> (a -> a -> Bool)
      -> Vec n a -> Vec n a -> Bool;
vecEq n a eqFn x y =
  foldr Bool Bool n and True (zipWith a a Bool eqFn n x y);

axiom eq_Vec :: (n :: Nat) -> (a :: sort 0)
       -> Eq (Vec n a -> Vec n a -> Bool) (eq (Vec n a)) (vecEq n a (eq a));

-- | Take a prefix of a vector.
take :: (a :: sort 0) -> (m n :: Nat) -> Vec (addNat m n) a -> Vec m a;
take a m n v = gen m a (\ (i :: Nat) -> at (addNat m n) a v i);

vecCong :: (a :: sort 0) -> (m n :: Nat) -> Eq Nat m n ->
           Eq (sort 0) (Vec m a) (Vec n a);
vecCong a m n eq = eq_cong Nat m n eq (sort 0) (\ (i::Nat) -> Vec i a);

coerceVec :: (a :: sort 0) -> (m n :: Nat) -> Eq Nat m n -> Vec m a -> Vec n a;
coerceVec a m n q = coerce (Vec m a) (Vec n a) (vecCong a m n q);

-- | Simplify take  all elements from a vector.
axiom take0 :: (a :: sort 0)
       -> (m :: Nat)
       -> (v :: Vec (addNat m 0) a)
       -> Eq (Vec m a)
             (take a m 0 v)
             (coerceVec a (addNat m 0) m (eqNatAdd0 m) v);

-- | Returns a suffix of a vector after a given number of elements.
drop :: (a :: sort 0) -> (m n :: Nat) -> Vec (addNat m n) a -> Vec n a;
drop a m n v = gen n a (\ (i :: Nat) -> at (addNat m n) a v (addNat m i));

-- | Simplify drop 0-elements from a vector.
axiom drop0 :: (a :: sort 0)
       -> (n :: Nat)
       -> (v :: Vec (addNat 0 n) a)
       -> Eq (Vec n a) (drop a 0 n v) v;

-- | Select a range [i,..,i+n] of values from the array.
slice :: (a :: sort 0)
      -> (m n o :: Nat)
      -> Vec (addNat (addNat m n) o) a -> Vec n a;
slice a m n o v = drop a m n (take a (addNat m n) o v);

-- | Defines a function that maps array elements from one range to another.
map :: (a b :: sort 0) -> (a -> b) -> (n :: Nat) -> Vec n a -> Vec n b;
map a b f n v = gen n b (\ (i :: Nat) -> f (at n a v i));

-- | Defines a function that maps array elements from one range to another.
zipWith :: (a b c :: sort 0)
        -> (a -> b -> c)
        -> (n :: Nat) -> Vec n a -> Vec n b -> Vec n c;
zipWith a b c f n x y = gen n c (\ (i :: Nat) -> f (at n a x i) (at n b y i));

-- replicate n x returns an array with n copies of x.
replicate :: (n :: Nat) -> (a :: sort 0) -> a -> Vec n a;
replicate n a x = gen n a (\ (_ :: Nat) -> x);

-- | Create a vector of length 1.
single :: (a :: sort 0) -> a -> Vec 1 a;
single = replicate 1;

axiom at_single :: (a :: sort 0) -> (x :: a) -> (i :: Nat) -> Eq a (at 1 a (single a x) i) x;

-- Concatenate arrays together.
join  :: (m n :: Nat)
       -> (a :: sort 0)
       -> Vec m (Vec n a)
       -> Vec (mulNat m n) a;
join m n a v =
  gen (mulNat m n) a (\ (i :: Nat) ->
    at n a (at m (Vec n a) v (divNat i n)) (modNat i n));

-- Split array into list
split :: (m n :: Nat) -> (a :: sort 0) -> Vec (mulNat m n) a -> Vec m (Vec n a);
split m n a v =
  gen m (Vec n a) (\ (i :: Nat) ->
    gen n a (\ (j :: Nat) ->
      at (mulNat m n) a v (addNat (mulNat i n) j)));

-- Append two arrays together.
append :: (m n :: Nat) -> (a :: sort 0) -> Vec m a -> Vec n a -> Vec (addNat m n) a;
append m n a x y =
  gen (addNat m n) a
    (\ (i :: Nat) ->
      ite a (ltNat i m) (at m a x i) (at n a y (subNat i m)));

-- Rotate array to the left.
primitive rotateL :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Nat -> Vec n a;
-- rotateL n a v i = gen n a (\ (j::Nat) -> at n a v (modNat (addNat i j) n));

-- Rotate array to the right.
primitive rotateR :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Nat -> Vec n a;
-- rotateR n a v i = gen n a (\ (j::Nat) -> at n a v (modNat (addNat (subNat n i) j) n));

-- Shift array to the left.
primitive shiftL :: (n :: Nat) -> (a :: sort 0) -> a -> Vec n a -> Nat -> Vec n a;

-- Shift array to the right.
primitive shiftR :: (n :: Nat) -> (a :: sort 0) -> a -> Vec n a -> Nat -> Vec n a;

-- Zip together two lists (truncating the longer of the two).
primitive zip :: (a b :: sort 0) -> (m n :: Nat) -> Vec m a -> Vec n b -> Vec (minNat m n) #(a, b);

primitive foldr :: (a b :: sort 0) -> (n :: Nat) -> (a -> b -> b) -> b -> Vec n a -> b;

reverse :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Vec n a;
reverse n a xs = gen n a (\ (i :: Nat) -> at n a xs (subNat (subNat n 1) i));

transpose :: (m n :: Nat) -> (a :: sort 0) -> Vec m (Vec n a) -> Vec n (Vec m a);
transpose m n a xss =
  gen n (Vec m a) (\ (j :: Nat) ->
    gen m a (\ (i :: Nat) -> at n a (at m (Vec n a) xss i) j));

joinLittleEndian  :: (m n :: Nat)
                  -> (a :: sort 0)
                  -> Vec m (Vec n a)
                  -> Vec (mulNat m n) a;
joinLittleEndian m n a v = join m n a (reverse m (Vec n a) v);

splitLittleEndian :: (m n :: Nat)
                  -> (a :: sort 0)
                  -> Vec (mulNat m n) a
                  -> Vec m (Vec n a);
splitLittleEndian m n a v = reverse m (Vec n a) (split m n a v);

--------------------------------------------------------------------------------
-- Bitvectors

-- | Bitvector operations expect the most-significant bit first.
bitvector :: (n :: Nat) -> sort 0;
bitvector n = Vec n Bool;

-- | Returns most-significant bit in a signed bitvector.
msb :: (n :: Nat) -> bitvector (Succ n) -> Bool;
msb n v = at (Succ n) Bool v 0;

-- | Returns least-significant bit in a bitvector.
lsb :: (n :: Nat) -> bitvector (Succ n) -> Bool;
lsb n v = at (Succ n) Bool v n;

-- | (bvNat n x) yields (x mod 2^n) as an n-bit vector.
primitive bvNat :: (n :: Nat) -> Nat -> bitvector n;

-- | Satisfies @bvNat n (bvToNat n x) = x@.
primitive bvToNat :: (n :: Nat) -> bitvector n -> Nat;

bvAt :: (n :: Nat) -> (a :: sort 0) -> (w :: Nat) -> Vec n a -> bitvector w
     -> a;
bvAt n a w xs i = at n a xs (bvToNat w i);

bvUpd :: (n :: Nat) -> (a :: sort 0) -> (w :: Nat) -> Vec n a -> bitvector w
      -> a -> Vec n a;
bvUpd n a w xs i y = upd n a xs (bvToNat w i) y;

bvRotateL :: (n :: Nat) -> (a :: sort 0) -> (w :: Nat) -> Vec n a -> bitvector w -> Vec n a;
bvRotateL n a w xs i = rotateL n a xs (bvToNat w i);

bvRotateR :: (n :: Nat) -> (a :: sort 0) -> (w :: Nat) -> Vec n a -> bitvector w -> Vec n a;
bvRotateR n a w xs i = rotateR n a xs (bvToNat w i);

bvShiftL :: (n :: Nat) -> (a :: sort 0) -> (w :: Nat) -> a -> Vec n a -> bitvector w -> Vec n a;
bvShiftL n a w z xs i = shiftL n a z xs (bvToNat w i);

bvShiftR :: (n :: Nat) -> (a :: sort 0) -> (w :: Nat) -> a -> Vec n a -> bitvector w -> Vec n a;
bvShiftR n a w z xs i = shiftR n a z xs (bvToNat w i);

primitive bvAdd :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;

bvCarry :: (n :: Nat) -> bitvector n -> bitvector n -> Bool;
bvCarry n x y = bvult n (bvAdd n x y) x;

bvSCarry :: (n :: Nat) -> bitvector (Succ n) -> bitvector (Succ n) -> Bool;
bvSCarry n x y = and (boolEq (msb n x) (msb n y)) (xor (msb n x) (msb n (bvAdd (Succ n) x y)));

bvAddWithCarry :: (n :: Nat) -> bitvector n -> bitvector n -> #(Bool, bitvector n);
bvAddWithCarry n x y = (bvCarry n x y, bvAdd n x y);

axiom bvAddZeroL :: (n :: Nat) -> (x :: bitvector n) -> Eq (bitvector n) (bvAdd n (bvNat n 0) x) x;
axiom bvAddZeroR :: (n :: Nat) -> (x :: bitvector n) -> Eq (bitvector n) (bvAdd n x (bvNat n 0)) x;

primitive bvNeg :: (n :: Nat) -> bitvector n -> bitvector n;
primitive bvSub :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
primitive bvMul :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
primitive bvLg2 :: (n :: Nat) -> bitvector n -> bitvector n;

-- Unsigned division and remainder.
--
-- When the divisor is 0, bvUDiv returns a vector with all bits set.
-- (Equal to 2^x - 1), and bvURem returns the divident unchanged.
--
-- These two functions satisfy the property that:
--   bvAdd x (bvMul x (bvUDiv x u v) v) (bvURem x u v) == u
primitive bvUDiv :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
primitive bvURem :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;


-- Signed division.
-- When the divisor is 0, bvSDiv returns 2^x - 1 when the dividend
-- is non-negative, and -1 when the dividend is negative; bvSRem
-- returns the dividend unchanged.
--
-- Otherwise, the sign of the quotient is the exclusive xor of
-- the sign bit of the dividend and divisor; the remainder is negative
-- if the dividend is negative.

-- bvSDiv and bvSRem satisfy the property that:
--
--   bvAdd x (bvMul x (bvSDiv x u v) v) (bvSRem x u v) == u
primitive bvSDiv :: (x :: Nat) -> bitvector (Succ x) -> bitvector (Succ x) -> bitvector (Succ x);
primitive bvSRem :: (x :: Nat) -> bitvector (Succ x) -> bitvector (Succ x)
       -> bitvector (Succ x);
--TODO:

-- | Shift left by the given number of bits.
-- New bits are False.
primitive bvShl :: (w :: Nat) -> bitvector w -> Nat -> bitvector w;

-- Logical right shift.  New bits are False.
primitive bvShr :: (w :: Nat) -> bitvector w -> Nat -> bitvector w;

-- | Signed right shift.  New bits are equal to most-significant bit.
primitive bvSShr :: (w :: Nat) -> bitvector (Succ w) -> Nat -> bitvector (Succ w);

axiom bvShiftL_bvShl ::
  (n :: Nat) -> (w :: Nat) -> (x :: Vec n Bool) -> (i :: bitvector w) ->
  Eq (Vec n Bool) (bvShiftL n Bool w False x i) (bvShl n x (bvToNat w i));

axiom bvShiftR_bvShr ::
  (n :: Nat) -> (w :: Nat) -> (x :: Vec n Bool) -> (i :: bitvector w) ->
  Eq (Vec n Bool) (bvShiftR n Bool w False x i) (bvShr n x (bvToNat w i));

-- | Zipwith specialized to bitvectors.
bvZipWith :: (Bool -> Bool -> Bool)
          -> (n :: Nat)
          -> bitvector n -> bitvector n -> bitvector n;
bvZipWith = zipWith Bool Bool Bool;

-- | Bitwise complement.
bvNot :: (n :: Nat) -> bitvector n -> bitvector n;
bvNot = map Bool Bool not;

-- | Pairwise conjunction, disjunction, and exclusive or.
bvAnd bvOr bvXor :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvAnd = bvZipWith and;
bvOr  = bvZipWith or;
bvXor = bvZipWith xor;

-- | Return true if two bitvectors are equal.
bvEq :: (n :: Nat) -> bitvector n -> bitvector n -> Bool;
bvEq n x y = vecEq n Bool boolEq x y;

-- | Axiom: bvEq implements *the* equality operation on bitvectors.
axiom eq_bitvector :: (n :: Nat) -> Eq (bitvector n -> bitvector n -> Bool) (eq (bitvector n)) (bvEq n);

axiom eq_VecBool :: (n :: Nat) -> Eq (Vec n Bool -> Vec n Bool -> Bool) (eq (Vec n Bool)) (bvEq n);

axiom eq_VecVec :: (n :: Nat) -> (m :: Nat) -> (a :: sort 0)
          -> Eq (Vec n (Vec m a) -> Vec n (Vec m a) -> Bool)
                (eq (Vec n (Vec m a)))
                (vecEq n (Vec m a) (eq (Vec m a)));

axiom equalNat_bv :: (n :: Nat) -> (x :: bitvector n) -> (i :: Nat) ->
               Eq Bool (equalNat i (bvToNat n x)) (bvEq n (bvNat n i) x);

-- | Return true if the bitvector is nonzero
bvNonzero :: (n :: Nat) -> bitvector n -> Bool;
bvNonzero n x = bvNe n x (bvNat n 0);

-- | Returns the bitvector 1 if the boolean is true,
--   and returns 0 otherwise
bvBool :: (n :: Nat) -> Bool -> bitvector n;
bvBool n b = ite (bitvector n) b (bvNat n 1) (bvNat n 0);

-- | Return true if two bitvectors are not equal.
bvNe :: (n :: Nat) -> bitvector n -> bitvector n -> Bool;
bvNe n x y = not (bvEq n x y);

-- | Unsigned and signed comparison functions.
primitive bvugt bvuge bvult bvule :: (n :: Nat) -> bitvector n -> bitvector n -> Bool;
primitive bvsgt bvsge bvslt bvsle :: (n :: Nat) -> bitvector n -> bitvector n -> Bool;

-- | Truncates a vector a smaller size.
-- msb implementation:
bvTrunc :: (x y :: Nat) -> bitvector (addNat x y) -> bitvector y;
bvTrunc = drop Bool;
-- lsb implementation:
-- bvTrunc :: (x y :: Nat) -> bitvector (addNat y x) -> bitvector y;
-- bvTrunc x y = take Bool y x;

-- | Perform a unsigned extension of the bitvector.
-- @bvUExt m n x@ adds m bits of zeros to the most-significant bits of
-- the n-bit vector x.
-- msb implementation:
bvUExt :: (m n :: Nat) -> bitvector n -> bitvector (addNat m n);
bvUExt m n x = append m n Bool (replicate m Bool False) x;
-- lsb implementation:
-- bvUExt :: (m n :: Nat) -> bitvector n -> bitvector (addNat n m);
-- bvUExt m n a = append n m Bool x (bvNat m 0);

-- | Perform a signed extension of the bitvector.
-- msb implementation:
bvSExt :: (m n :: Nat) -> bitvector (Succ n) -> bitvector (addNat m (Succ n));
bvSExt m n x = append m (Succ n) Bool (replicate m Bool (msb n x)) x;
-- lsb implementation:
-- bvSExt :: (m n :: Nat) -> bitvector (Succ n) -> bitvector (addNat (Succ n) m);
-- bvSExt m n x = append (Succ n) m Bool x (replicate m Bool (msb n x));

--------------------------------------------------------------------------------
-- Polynomial operations

bvPMul :: (m n :: Nat) ->
  bitvector (Succ m) -> bitvector (Succ n) -> bitvector (Succ (addNat m n));
bvPMul m n x =
  foldr Bool (bitvector (Succ (addNat m n))) (Succ n)
    (\ (b :: Bool) -> \ (a :: bitvector (Succ (addNat m n))) ->
      bvXor (Succ (addNat m n))
        (bvShr (Succ (addNat m n)) a 1)
        (ite (bitvector (Succ (addNat m n))) b
          (append (Succ m) n Bool x (bvNat n 0))
          (bvNat (Succ (addNat m n)) 0)))
    (bvNat (Succ (addNat m n)) 0);

snoc :: (a :: sort 0) -> (n :: Nat) -> Vec n a -> a -> Vec (Succ n) a;
snoc a n xs x = rotateL (Succ n) a (ConsVec a x n xs) 1;

nextPDivModC :: (n :: Nat) -> bitvector n -> Bool;
nextPDivModC n r = msb n (snoc Bool n r False);

nextPDivModR :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
nextPDivModR n mask r =
  ite (bitvector n) (nextPDivModC n r)
  (bvXor n mask (bvShl n r 1))
  (bvShl n r 1);

nextPDivModQ :: (m n :: Nat) -> bitvector m -> bitvector n -> bitvector m;
nextPDivModQ m n q r = drop Bool 1 m (snoc Bool m q (nextPDivModC n r));

-- bvPModAux m n x y = bvPMod m n x (ConsVec Bool True n y);
bvPModAux :: (m n :: Nat) -> bitvector m -> bitvector n -> bitvector n;
bvPModAux m n x mask =
  (foldr Bool #(bitvector n, bitvector n) m
    (\ (b :: Bool) -> \ (acc :: #(bitvector n, bitvector n)) ->
      (nextPDivModR n mask acc.1,
       ite (bitvector n) b (bvXor n acc.1 acc.2) acc.2))
    (bvNat n 1, bvNat n 0) x).2;

bvPMod :: (m n :: Nat) -> bitvector m -> bitvector (Succ n) -> bitvector n;
bvPMod m n x y =
  ite (bitvector n) (msb n y) (bvPModAux m n x (drop Bool 1 n y))
    (natCase
      (\ (i :: Nat) -> bitvector i -> bitvector i)
      (\ (z :: bitvector 0) -> z)
      (\ (i :: Nat) -> \ (a :: bitvector (Succ i)) -> ConsVec Bool False i (bvPMod m i x a))
      n (drop Bool 1 n y));

-- bvPDivAux m n x y = bvPDiv m (Succ n) x (ConsVec Bool True n y);
bvPDivAux :: (m n :: Nat) -> bitvector m -> bitvector n -> bitvector m;
bvPDivAux m n x mask =
  (foldr Bool #(bitvector m, bitvector n, bitvector m) m
    (\ (b :: Bool) -> \ (acc :: #(bitvector m, bitvector n, bitvector m)) ->
      (nextPDivModQ m n acc.1 acc.2,
       nextPDivModR n mask acc.2,
       ite (bitvector m) b (bvXor m acc.1 acc.3) acc.3))
    (take Bool m n (bvNat (addNat m n) 1), bvNat n 1, bvNat m 0) x).3;

bvPDiv :: (m n :: Nat) -> bitvector m -> bitvector n -> bitvector m;
bvPDiv m n x y =
  natCase
    (\ (n' :: Nat) -> bitvector n' -> bitvector m)
    (\ (_ :: bitvector 0) -> bvNat m 0)
    (\ (n' :: Nat) -> \ (y' :: bitvector (Succ n')) ->
      ite (bitvector m) (msb n' y') (bvPDivAux m n' x (drop Bool 1 n' y'))
        (bvPDiv m n' x (drop Bool 1 n' y')))
    n y;

--------------------------------------------------------------------------------
-- Infinite streams

data Stream :: sort 0 -> sort 0 where {
    MkStream :: (a :: sort 0) -> (Nat -> a) -> Stream a;
  }

Stream__rec :: (a::sort 0) -> (p::Stream a -> sort 0) ->
               ((f::Nat -> a) -> p (MkStream a f)) -> (s::Stream a) -> p s;
Stream__rec a p f1 (MkStream _ f) = f1 f;

streamUpd :: (a :: sort 0) -> Stream a -> Nat -> a -> Stream a;
streamUpd a strm i y =
  Stream__rec a (\ (strm'::Stream a) -> Stream a)
              (\ (s::Nat -> a) ->
                 MkStream a (\ (j :: Nat) -> ite a (equalNat i j) y (s j))) strm;

bvStreamUpd :: (a :: sort 0) -> (w :: Nat) ->
     Stream a -> bitvector w -> a -> Stream a;
bvStreamUpd a w xs i y = streamUpd a xs (bvToNat w i) y;

streamGet :: (a :: sort 0) -> Stream a -> Nat -> a;
streamGet a strm i =
  Stream__rec a (\ (strm'::Stream a) -> a) (\ (s::Nat -> a) -> s i) strm;

streamConst :: (a :: sort 0) -> a -> Stream a;
streamConst a x = MkStream a (\ (i :: Nat) -> x);

streamMap :: (a b :: sort 0) -> (a -> b) -> Stream a -> Stream b;
streamMap a b f xs = MkStream b (\ (i :: Nat) -> f (streamGet a xs i));

streamMap2 :: (a b c :: sort 0) -> (a -> b -> c) ->
              Stream a -> Stream b -> Stream c;
streamMap2 a b c f xs ys =
  MkStream c (\ (i :: Nat) -> f (streamGet a xs i) (streamGet b ys i));

streamTake :: (a :: sort 0) -> (n :: Nat) -> Stream a -> Vec n a;
streamTake a n xs = gen n a (\ (i :: Nat) -> streamGet a xs i);

streamDrop :: (a :: sort 0) -> (n :: Nat) -> Stream a -> Stream a;
streamDrop a n xs = MkStream a (\ (i :: Nat) -> streamGet a xs (addNat n i));

streamAppend :: (a :: sort 0) -> (n :: Nat) -> Vec n a -> Stream a -> Stream a;
streamAppend a n xs ys =
  MkStream a (\ (i :: Nat) ->
    atWithDefault n a (streamGet a ys (subNat i n)) xs i);

streamJoin :: (a :: sort 0) -> (n :: Nat)
           -> Stream (Vec (Succ n) a)
           -> (Stream a);
streamJoin a n s =
  MkStream a (\ (i::Nat) ->
     at (Succ n) a (streamGet (Vec (Succ n) a) s (divNat i (Succ n)))
                   (modNat i (Succ n)) );

streamSplit :: (a :: sort 0) -> (n :: Nat) -> Stream a -> Stream (Vec n a);
streamSplit a n xs =
  MkStream (Vec n a) (\ (i :: Nat) ->
    gen n a (\ (j :: Nat) ->
      streamGet a xs (addNat (mulNat i n) j)));

bvStreamGet :: (a :: sort 0) -> (w :: Nat) -> Stream a -> bitvector w -> a;
bvStreamGet a w xs i = streamGet a xs (bvToNat w i);

bvStreamShiftL :: (a :: sort 0) -> (w :: Nat) -> Stream a -> bitvector w -> Stream a;
bvStreamShiftL a w xs i = streamDrop a (bvToNat w i) xs;

bvStreamShiftR :: (a :: sort 0) -> (w :: Nat) -> a -> Stream a -> bitvector w -> Stream a;
bvStreamShiftR a w x xs i = streamAppend a (bvToNat w i) (replicate (bvToNat w i) a x) xs;

--------------------------------------------------------------------------------
-- Integer values
--   integer values of unbounded precision

primitive Integer :: sort 0;

primitive intAdd :: Integer -> Integer -> Integer;
primitive intSub :: Integer -> Integer -> Integer;
primitive intMul :: Integer -> Integer -> Integer;
primitive intDiv :: Integer -> Integer -> Integer;
primitive intMod :: Integer -> Integer -> Integer;
primitive intMin :: Integer -> Integer -> Integer;
primitive intMax :: Integer -> Integer -> Integer;
primitive intNeg :: Integer -> Integer;
primitive intEq  :: Integer -> Integer -> Bool;
primitive intLe  :: Integer -> Integer -> Bool;
primitive intLt  :: Integer -> Integer -> Bool;

-- intToNat x == max 0 x
primitive intToNat :: Integer -> Nat;
primitive natToInt :: Nat -> Integer;

-- for x >= 0, intToBv n x = x `mod` 2^n
-- for x <  0, intToBv n x = bvNeg n (-x `mod` 2^n)
primitive intToBv :: (n::Nat) -> Integer -> bitvector n;

-- return the unsigned value of the bitvector as an integer
primitive bvToInt :: (n::Nat) -> bitvector n -> Integer;

-- return the 2's complement signed value of the bitvector as an integer
primitive sbvToInt :: (n::Nat) -> bitvector n -> Integer;


--------------------------------------------------------------------------------
-- Point-update functions

updNatFun :: (a::sort 0)
	  -> (Nat -> a) -> Nat -> a -> (Nat -> a);
updNatFun a f i v x = ite a (equalNat i x) v (f x);

updBvFun :: (n::Nat) -> (a::sort 0)
	 -> (bitvector n -> a) -> bitvector n -> a -> (bitvector n -> a);
updBvFun n a f i v x = ite a (bvEq n i x) v (f x);

--------------------------------------------------------------------------------
-- Floating-point values
--    Currently commented out because they are not implemented...

primitive Float :: sort 0;

-- primitive bvToFloat :: bitvector 32 -> Float;
-- primitive floatToBV :: Float -> bitvector 32;

primitive Double :: sort 0;

-- primitive bvToDouble :: bitvector 64 -> Double;
-- primitive doubleToBV :: Double -> bitvector 64;


axiom bveq_sameL :: (n :: Nat)
           -> (x z :: bitvector n)
           -> Eq Bool
                 (bvEq n x (bvAdd n x z))
                 (bvEq n (bvNat n 0) z);

axiom bveq_sameR :: (n :: Nat)
           -> (x y :: bitvector n)
           -> Eq Bool
                 (bvEq n (bvAdd n x y) x)
                 (bvEq n y (bvNat n 0));

axiom bveq_same2 :: (n :: Nat)
           -> (x y z :: bitvector n)
           -> Eq Bool
                 (bvEq n (bvAdd n x y) (bvAdd n x z))
                 (bvEq n y z);

axiom bvNat_bvToNat :: (n :: Nat)
              -> (x :: bitvector n)
              -> Eq (bitvector n)
                    (bvNat n (bvToNat n x))
                    x;

axiom ite_split_cong :: (b :: Bool) -> (x :: Vec 384 Bool) -> (y :: Vec 384 Bool)
               -> Eq (Vec 12 (Vec 32 Bool))
                     (split 12 32 Bool (ite (Vec 384 Bool) b x y))
                     (ite (Vec 12 (Vec 32 Bool)) b (split 12 32 Bool x) (split 12 32 Bool y));

axiom ite_join_cong :: (b :: Bool)
              -> (x :: Vec 12 (Vec 32 Bool))
              -> (y :: Vec 12 (Vec 32 Bool))
              -> Eq (Vec 384 Bool)
                    (join 12 32 Bool (ite (Vec 12 (Vec 32 Bool)) b x y))
                    (ite (Vec 384 Bool) b (join 12 32 Bool x) (join 12 32 Bool y));

axiom map_map :: (a b c :: sort 0) -> (f :: a -> b) -> (g :: b -> c) ->
                 (n :: Nat) -> (xs :: Vec n a) ->
                 Eq (Vec n c) (map b c g n (map a b f n xs))
                              (map a c (\ (x::a) -> g (f x)) n xs);
