

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Compound data types &mdash; SAW Documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/sphinx_rtd_theme.css?v=3234e928" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/js/hoverxref.js"></script>
      <script src="../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../_static/js/micromodal.min.js"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/versions.js?v=302bdcf2"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Overrides and compositional verification" href="overrides-and-compositional-verification.html" />
    <link rel="prev" title="Reference types" href="reference-types.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SAW Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../llvm-java-verification-with-saw/index.html">LLVM/Java Verification with SAW</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Rust Verification with SAW</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="prerequisites.html">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="about-mir-json.html">About <code class="docutils literal notranslate"><span class="pre">mir-json</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="saw-basics.html">SAW basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference-types.html">Reference types</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Compound data types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#array-types">Array types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tuple-types">Tuple types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-types">Struct types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#symbolic-structs">Symbolic structs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#enum-types">Enum types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#symbolic-enums">Symbolic enums</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#slices">Slices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#aside-slices-of-arbitrary-length">Aside: slices of arbitrary length</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="overrides-and-compositional-verification.html">Overrides and compositional verification</a></li>
<li class="toctree-l2"><a class="reference internal" href="static-items.html">Static items</a></li>
<li class="toctree-l2"><a class="reference internal" href="case-study-salsa20.html">Case study: Salsa20</a></li>
<li class="toctree-l2"><a class="reference internal" href="a-final-word.html">A final word</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../saw-user-manual/index.html">SAW User Manual</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SAW Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Rust Verification with SAW</a></li>
      <li class="breadcrumb-item active">Compound data types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rust-verification-with-saw/compound-data-types.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="compound-data-types">
<h1>Compound data types<a class="headerlink" href="#compound-data-types" title="Link to this heading"></a></h1>
<p>Besides integer types and reference types, Rust also features a variety of other
interesting data types. This part of the tutorial will briefly go over some of
these data types and how to interface with them in SAW.</p>
<section id="array-types">
<h2>Array types<a class="headerlink" href="#array-types" title="Link to this heading"></a></h2>
<p>Rust includes array types where the length of the array is known ahead of time.
For instance, this <code class="docutils literal notranslate"><span class="pre">index</span></code> function takes an <code class="docutils literal notranslate"><span class="pre">arr</span></code> argument that must contain
exactly three <code class="docutils literal notranslate"><span class="pre">u32</span></code> values:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">index</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While Rust is good at catching many classes of programmer errors at compile
time, one thing that it cannot catch in general is out-of-bounds array
accesses. In this <code class="docutils literal notranslate"><span class="pre">index</span></code> example, calling the function with a value of <code class="docutils literal notranslate"><span class="pre">idx</span></code>
ranging from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">2</span></code> is fine, but any other choice of <code class="docutils literal notranslate"><span class="pre">idx</span></code> will cause the
program to crash, since the <code class="docutils literal notranslate"><span class="pre">idx</span></code> will be out of the bounds of <code class="docutils literal notranslate"><span class="pre">arr</span></code>.</p>
<p>SAW is suited to checking for these sorts of out-of-bound accesses. Let’s write
an incorrect spec for <code class="docutils literal notranslate"><span class="pre">index</span></code> to illustrate this:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">index_fail_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;arr&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">idx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;idx&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">idx</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">arr</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_load_module</span><span class="w"> </span><span class="s2">&quot;arrays.linked-mir.json&quot;</span><span class="p">;</span>

<span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;arrays::index&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">index_fail_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Before we run this with SAW, let’s highlight some of the new concepts that this
spec uses:</p>
<ol class="arabic simple">
<li><p>The type of the <code class="docutils literal notranslate"><span class="pre">arr</span></code> variable is specified using <code class="docutils literal notranslate"><span class="pre">mir_array</span> <span class="pre">3</span> <span class="pre">mir_u32</span></code>.
Here, the <code class="docutils literal notranslate"><span class="pre">mir_array</span></code> function takes the length of the array and the element
type as arguments, just as in Rust.</p></li>
<li><p>The spec declares the return value to be <code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">arr</span> <span class="pre">&#64;</span> <span class="pre">idx</span> <span class="pre">}}</span></code>, where <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> is
Cryptol’s indexing operator. Also note that it is completely valid to embed
a MIR array type into a Cryptol expression, as Cryptol has a sequence type
that acts much like arrays do in MIR.</p></li>
</ol>
<p>As we hinted above, this spec is wrong, as it says that this should work for
<em>any</em> possible values of <code class="docutils literal notranslate"><span class="pre">idx</span></code>. SAW will catch this mistake:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>saw<span class="w"> </span>arrays-fail.saw



<span class="go">[21:03:05.374] Loading file &quot;arrays-fail.saw&quot;</span>
<span class="go">[21:03:05.411] Verifying arrays/47a26581::index[0] ...</span>
<span class="go">[21:03:05.425] Simulating arrays/47a26581::index[0] ...</span>
<span class="go">[21:03:05.426] Checking proof obligations arrays/47a26581::index[0] ...</span>
<span class="go">[21:03:05.445] Subgoal failed: arrays/47a26581::index[0] index out of bounds: the length is move _4 but the index is _3</span>
<span class="go">[21:03:05.445] SolverStats {solverStatsSolvers = fromList [&quot;SBV-&gt;Z3&quot;], solverStatsGoalSize = 53}</span>
<span class="go">[21:03:05.445] ----------Counterexample----------</span>
<span class="go">[21:03:05.445]   idx: 2147483648</span>
<span class="go">[21:03:05.445] Stack trace:</span>
<span class="go">&quot;mir_verify&quot; (arrays-fail.saw:14:1-14:11)</span>
<span class="go">Proof failed.</span>
</pre></div>
</div>
<p>We can repair this spec by adding some preconditions:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">index_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;arr&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">idx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;idx&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">mir_precond</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="ow">=</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span><span class="w"> </span><span class="c c-Singleline">// Lower bound of idx</span>
<span class="w">  </span><span class="n">mir_precond</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span><span class="w"> </span><span class="c c-Singleline">// Upper bound of idx</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">idx</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">arr</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>An alternative way of writing this spec is by using SAW’s <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code>
command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_array_value</span>
<span class="go">MIRType -&gt; [MIRValue] -&gt; MIRValue</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">MIRType</span></code> argument represents the element type, and the list of
<code class="docutils literal notranslate"><span class="pre">MIRValue</span></code> arguments are the element values of the array. We can rewrite
<code class="docutils literal notranslate"><span class="pre">index_spec</span></code> using <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code> like so:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">index_alt_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">arr0</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;arr0&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>
<span class="w">  </span><span class="n">arr1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;arr1&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>
<span class="w">  </span><span class="n">arr2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;arr2&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_array_value</span><span class="w"> </span><span class="n">mir_u32</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">arr0</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">arr1</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">arr2</span><span class="p">];</span>

<span class="w">  </span><span class="n">idx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;idx&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">mir_precond</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="ow">=</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span><span class="w"> </span><span class="c c-Singleline">// Lower bound of idx</span>
<span class="w">  </span><span class="n">mir_precond</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="ow">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span><span class="w"> </span><span class="c c-Singleline">// Upper bound of idx</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">idx</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">[</span><span class="nf">arr</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nf">arr</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nf">arr</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="nf">idx</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">[arr0,</span> <span class="pre">arr1,</span> <span class="pre">arr2]</span></code> is Cryptol notation for constructing a length-3
sequence consisting of <code class="docutils literal notranslate"><span class="pre">arr0</span></code>, <code class="docutils literal notranslate"><span class="pre">arr1</span></code>, and <code class="docutils literal notranslate"><span class="pre">arr2</span></code> as the elements.
<code class="docutils literal notranslate"><span class="pre">index_alt_spec</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">index_spec</span></code>, albeit more verbose. For this
reason, it is usually preferable to use <code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code> to create an entire
symbolic array rather than creating separate symbolic values for each element
and combining them with <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code>.</p>
<p>There are some situations where <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code> is the only viable choice,
however. Consider this variant of the <code class="docutils literal notranslate"><span class="pre">index</span></code> function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">index_ref_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When writing a SAW spec for <code class="docutils literal notranslate"><span class="pre">index_ref_arr</span></code>, we can’t just create a symbolic
variable for <code class="docutils literal notranslate"><span class="pre">arr</span></code> using <code class="docutils literal notranslate"><span class="pre">mir_alloc</span> <span class="pre">(mir_array</span> <span class="pre">3</span> <span class="pre">...)</span></code>, as the reference values
in the array wouldn’t point to valid memory. Instead, we must individually
allocate the elements of <code class="docutils literal notranslate"><span class="pre">arr</span></code> using separate calls to <code class="docutils literal notranslate"><span class="pre">mir_alloc</span></code> and then
build up the array using <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code>. (As an exercise, try writing and
verifying a spec for <code class="docutils literal notranslate"><span class="pre">index_ref_arr</span></code>).</p>
</section>
<section id="tuple-types">
<h2>Tuple types<a class="headerlink" href="#tuple-types" title="Link to this heading"></a></h2>
<p>Rust includes tuple types where the elements of the tuple can be of different
types. For example:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">flip</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SAW includes a <code class="docutils literal notranslate"><span class="pre">mir_tuple</span></code> function for specifying the type of a tuple value.
In addition, one can embed MIR tuples into Cryptol, as Cryptol also includes
tuple types whose fields can be indexed with <code class="docutils literal notranslate"><span class="pre">.0</span></code>, <code class="docutils literal notranslate"><span class="pre">.1</span></code>, etc. Here is a spec
for <code class="docutils literal notranslate"><span class="pre">flip</span></code> that makes use of all these features:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">flip_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_tuple</span><span class="w"> </span><span class="p">[</span><span class="n">mir_u32</span><span class="p">,</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">]);</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nf">x</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>SAW also includes a <code class="docutils literal notranslate"><span class="pre">mir_tuple_value</span></code> function for constructing a tuple value
from other <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>s:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_tuple_value</span>
<span class="go">[MIRValue] -&gt; MIRValue</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mir_tuple_value</span></code> plays a similar role for tuples as <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code> does for
arrays.</p>
</section>
<section id="struct-types">
<h2>Struct types<a class="headerlink" href="#struct-types" title="Link to this heading"></a></h2>
<p>Rust supports the ability for users to define custom struct types. Structs are
uniquely identified by their names, so if you have two structs like these:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">);</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">T</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">);</span>
</pre></div>
</div>
<p>Then even though the fields of the <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> structs are the same, they are
<em>not</em> the same struct. This is a type system feature that Cryptol does not
have, and for this reason, it is not possible to embed MIR struct values into
Cryptol. It is also not possible to use <code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code> to create a symbolic
struct value. Instead, one can use the <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code> command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_struct_value</span>
<span class="go">MIRAdt -&gt; [MIRValue] -&gt; MIRValue</span>
</pre></div>
</div>
<p>Like with <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_tuple_value</span></code>, the <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code>
function takes a list of <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>s as arguments. What makes
<code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code> unique is its <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> argument, which we have not seen up
to this point. In this context, “<code class="docutils literal notranslate"><span class="pre">Adt</span></code>” is shorthand for “<a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data
type</a>”, and Rust’s structs
are an example of ADTs. (Rust also supports enums, another type of ADT that we
will see later in this tutorial.)</p>
<p>ADTs in Rust are named entities, and as such, they have unique identifiers in
the MIR JSON file in which they are defined. Looking up these identifiers can
be somewhat error-prone, so SAW offers a <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> command that computes
an ADT’s identifier and returns the <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> associated with it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_find_adt</span>
<span class="go">MIRModule -&gt; String -&gt; [MIRType] -&gt; MIRAdt</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">MIRModule</span></code> correspond to the MIR JSON file containing the ADT
definition, and the <code class="docutils literal notranslate"><span class="pre">String</span></code> is the name of the ADT whose identifier we want to
look up. The list of <code class="docutils literal notranslate"><span class="pre">MIRType</span></code>s represent types to instantiate any type
parameters to the struct (more on this in a bit).</p>
<p>As an example, we can look up the <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> structs from above like so:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_load_module</span><span class="w"> </span><span class="s2">&quot;structs.linked-mir.json&quot;</span><span class="p">;</span>

<span class="kr">let</span><span class="w"> </span><span class="n">s_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;structs::S&quot;</span><span class="w"> </span><span class="p">[];</span>
<span class="kr">let</span><span class="w"> </span><span class="n">t_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;structs::T&quot;</span><span class="w"> </span><span class="p">[];</span>
</pre></div>
</div>
<p>We pass an empty list of <code class="docutils literal notranslate"><span class="pre">MIRType</span></code>s to each use of <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>, as neither
<code class="docutils literal notranslate"><span class="pre">S</span></code> nor <code class="docutils literal notranslate"><span class="pre">T</span></code> have any type parameters. An example of a struct that does include
type parameters can be seen here:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
</pre></div>
</div>
<p>As mentioned before, SAW doesn’t support generic definitions out of the box, so
the only way that we can make use of the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> struct is by looking up a
particular instantiation of <code class="docutils literal notranslate"><span class="pre">Foo</span></code>’s type parameters. If we define a function
like this, for example:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">make_foo</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then this function instantiates <code class="docutils literal notranslate"><span class="pre">Foo</span></code>’s <code class="docutils literal notranslate"><span class="pre">A</span></code> type parameter with <code class="docutils literal notranslate"><span class="pre">u32</span></code> and the
<code class="docutils literal notranslate"><span class="pre">B</span></code> type parameter with <code class="docutils literal notranslate"><span class="pre">u64</span></code>. We can use <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> to look up this
particular instantiation of <code class="docutils literal notranslate"><span class="pre">Foo</span></code> like so:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">foo_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;structs::Foo&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_u32</span><span class="p">,</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">];</span>
</pre></div>
</div>
<p>In general, a MIR JSON file can have many separate instantiations of a single
struct’s type parameters, and each instantiation must be looked up separately
using <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>.</p>
<p>Having looked up <code class="docutils literal notranslate"><span class="pre">Foo&lt;u32,</span> <span class="pre">u64&gt;</span></code> using <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>, let’s use the resulting
<code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> in a spec:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">make_foo_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span>
<span class="w">              </span><span class="n">foo_adt</span>
<span class="w">              </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">27</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;structs::make_foo&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">make_foo_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that we are directly writing out the values <code class="docutils literal notranslate"><span class="pre">27</span></code> and <code class="docutils literal notranslate"><span class="pre">42</span></code> in Cryptol.
Cryptol’s numeric literals can take on many different types, so in order to
disambiguate which type they should be, we give each numeric literal an
explicit type annotation. For instance, the expression <code class="docutils literal notranslate"><span class="pre">27</span> <span class="pre">:</span> <span class="pre">[32]</span></code> means that
<code class="docutils literal notranslate"><span class="pre">27</span></code> should be a 32-bit integer.</p>
<section id="symbolic-structs">
<h3>Symbolic structs<a class="headerlink" href="#symbolic-structs" title="Link to this heading"></a></h3>
<p>Let’s now verify a function that takes a struct value as an argument:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Bar</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">do_stuff_with_bar</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Moreover, let’s verify this function for all possible <code class="docutils literal notranslate"><span class="pre">Bar</span></code> values. One way to
do this is to write a SAW spec that constructs a struct value whose fields are
themselves symbolic:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">bar_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;structs::Bar&quot;</span><span class="w"> </span><span class="p">[];</span>

<span class="kr">let</span><span class="w"> </span><span class="n">do_stuff_with_bar_spec1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">z1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;z1&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>
<span class="w">  </span><span class="n">z2</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;z2&quot;</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span>
<span class="w">            </span><span class="n">foo_adt</span>
<span class="w">            </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">z1</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">z2</span><span class="p">];</span>

<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">;</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="w"> </span><span class="n">mir_u16</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span>
<span class="w">            </span><span class="n">bar_adt</span>
<span class="w">            </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">];</span>

<span class="w">  </span><span class="c c-Singleline">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is a rather tedious process, however, as we had to repeatedly use
<code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code> to create a fresh, symbolic value for each field. Moreover,
because <code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code> does not work for structs, we had to recursively apply
this process in order to create a fresh <code class="docutils literal notranslate"><span class="pre">Foo</span></code> value. It works, but it takes a
lot of typing to accomplish.</p>
<p>To make this process less tedious, SAW offers a <code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code>
command that allows one to create symbolic values of many more types. While
<code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code> is limited to those MIR types that can be directly converted to
Cryptol, <code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> can create symbolic structs by automating
the process of creating fresh values for each field. This process also applies
recursively for struct fields, such as the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> field in <code class="docutils literal notranslate"><span class="pre">Bar</span></code>.</p>
<p>As an example, a much shorter way to write the spec above using
<code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> is:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">do_stuff_with_bar_spec2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_expanded_value</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">bar_adt</span><span class="p">);</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">];</span>

<span class="w">  </span><span class="c c-Singleline">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>That’s it! Note that the string <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code> is used as a prefix for all fresh names
that <code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> generates, so if SAW produces a counterexample
involving this symbolic struct value, one can expect to see names such as
<code class="docutils literal notranslate"><span class="pre">b_0</span></code>, <code class="docutils literal notranslate"><span class="pre">b_1</span></code>, etc. for the fields of the struct.</p>
<p><code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> makes it easier to construct large, compound values
that consist of many smaller, inner values. The drawback is that you can’t
refer to these inner values in the postconditions of a spec. As a result, there
are some functions for which <code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> isn’t suitable, so keep
this in mind before reaching for it.</p>
</section>
</section>
<section id="enum-types">
<h2>Enum types<a class="headerlink" href="#enum-types" title="Link to this heading"></a></h2>
<p>Besides structs, another form of ADT that Rust supports are enums. Each enum
has a number of different <em>variants</em> that describe the different ways that an
enum value can look like. A famous example of a Rust enum is the <code class="docutils literal notranslate"><span class="pre">Option</span></code> type,
which is defined by the standard library like so:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">None</span><span class="p">,</span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Option</span></code> is commonly used in Rust code to represent a value that may be present
(<code class="docutils literal notranslate"><span class="pre">Some</span></code>) or absent (<code class="docutils literal notranslate"><span class="pre">None</span></code>). For this reason, we will use <code class="docutils literal notranslate"><span class="pre">Option</span></code> as our
motivating example of an enum in this section.</p>
<p>First, let’s start by defining some functions that make use of <code class="docutils literal notranslate"><span class="pre">Option</span></code>’s
variants:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">i_found_something</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">i_got_nothing</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">None</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both functions return an <code class="docutils literal notranslate"><span class="pre">Option&lt;u32&gt;</span></code> value, but each function returns a
different variant. In order to tell these variants apart, we need a SAW
function which can construct an enum value that allows the user to pick which
variant they want to construct. The `mir_enum_value function does exactly that:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_enum_value</span>
<span class="go">MIRAdt -&gt; String -&gt; [MIRValue] -&gt; MIRValue</span>
</pre></div>
</div>
<p>Like <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code>, <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code> also requires a <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> argument in
order to discern which particular enum you want. Unlike <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code>,
however, it also requires a <code class="docutils literal notranslate"><span class="pre">String</span></code> which variant of the enum you want. In the
case of <code class="docutils literal notranslate"><span class="pre">Option</span></code>, this <code class="docutils literal notranslate"><span class="pre">String</span></code> will either be <code class="docutils literal notranslate"><span class="pre">&quot;None&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;Some&quot;</span></code>. Finally,
the <code class="docutils literal notranslate"><span class="pre">[MIRValue]</span></code> arguments represent the fields of the enum variant.</p>
<p>Let’s now verify some enum-related code with SAW. First, we must look up the
<code class="docutils literal notranslate"><span class="pre">Option&lt;u32&gt;</span></code> ADT, which works just as if you had a struct type:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">option_u32</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;core::option::Option&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_u32</span><span class="p">];</span>
</pre></div>
</div>
<p>Next, we can use this ADT to construct enum values. We shall use
<code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code> to create a <code class="docutils literal notranslate"><span class="pre">Some</span></code> value in the spec for <code class="docutils literal notranslate"><span class="pre">i_found_something</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">i_found_something_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_enum_value</span><span class="w"> </span><span class="n">option_u32</span><span class="w"> </span><span class="s2">&quot;Some&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;enums::i_found_something&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">i_found_something_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that while we used the full identifier <code class="docutils literal notranslate"><span class="pre">core::option::Option</span></code> to look up
the <code class="docutils literal notranslate"><span class="pre">Option</span></code> ADT, we do not need to use the <code class="docutils literal notranslate"><span class="pre">core::option</span></code> prefix when
specifying the <code class="docutils literal notranslate"><span class="pre">&quot;Some&quot;</span></code> variant. This is because SAW already knows what the
prefix should be from the <code class="docutils literal notranslate"><span class="pre">option_u32</span></code> ADT, so the <code class="docutils literal notranslate"><span class="pre">&quot;Some&quot;</span></code> shorthand suffices.</p>
<p>Similarly, we can also write a spec for <code class="docutils literal notranslate"><span class="pre">i_got_nothing</span></code>, which uses the <code class="docutils literal notranslate"><span class="pre">None</span></code>
variant:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">i_got_nothing_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_enum_value</span><span class="w"> </span><span class="n">option_u32</span><span class="w"> </span><span class="s2">&quot;None&quot;</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;enums::i_got_nothing&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">i_got_nothing_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<section id="symbolic-enums">
<h3>Symbolic enums<a class="headerlink" href="#symbolic-enums" title="Link to this heading"></a></h3>
<p>In order to create a symbolic struct, one could create symbolic fields and pack
them into a larger struct value using <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code>. The same process is
not possible with <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code>, however, as a symbolic enum value would
need to range over <em>all</em> possible variants in an enum.</p>
<p>Just as <code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> supports creating symbolic structs,
<code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> also supports creating symbolic enum values. For
example, given this function that accepts an <code class="docutils literal notranslate"><span class="pre">Option&lt;u32&gt;</span></code> value as an
argument:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">do_stuff_with_option</span><span class="p">(</span><span class="n">o</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can write a spec for this function that considers all possible <code class="docutils literal notranslate"><span class="pre">Option&lt;u32&gt;</span></code>
values like so:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">do_stuff_with_option_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">o</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_expanded_value</span><span class="w"> </span><span class="s2">&quot;o&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">option_u32</span><span class="p">);</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">o</span><span class="p">];</span>

<span class="w">  </span><span class="c c-Singleline">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">o</span></code> can be a <code class="docutils literal notranslate"><span class="pre">None</span></code> value, or it can be a <code class="docutils literal notranslate"><span class="pre">Some</span></code> value with a symbolic
field.</p>
</section>
</section>
<section id="slices">
<h2>Slices<a class="headerlink" href="#slices" title="Link to this heading"></a></h2>
<p>Slices are a particular type of reference that allow referencing contiguous
sequences of elements in a collection, such as an array. Unlike ordinary
references (e.g., <code class="docutils literal notranslate"><span class="pre">&amp;u32</span></code>), SAW does not permit allocating a slice directly.
Instead, one must take a slice of an existing reference. To better illustrate
this distinction, consider this function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">sum_of_prefix</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u32</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sum_of_prefix</span></code> takes a slice to a sequence of <code class="docutils literal notranslate"><span class="pre">u32</span></code>s as an argument, indexes
into the first two elements in the sequence, and adds them together. There are
many possible ways we can write a spec for this function, as the slice argument
may be backed by many different sequences. For example, the slice might be
backed by an array whose length is exactly two:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a1</span><span class="p">[</span><span class="o">..</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_of_prefix</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
</pre></div>
</div>
<p>We could also make a slice whose length is longer than two:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a2</span><span class="p">[</span><span class="o">..</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_of_prefix</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternatively, the slice might be a subset of an array whose length is longer
than two:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a3</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_of_prefix</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span>
</pre></div>
</div>
<p>All of these are valid ways of building the slice argument to <code class="docutils literal notranslate"><span class="pre">sum_of_prefix</span></code>.
Let’s try to write SAW specifications that construct these different forms of
slices. To do so, we will need SAW functions that take a reference to a
collection (e.g., an array) and converts them into a slice reference. The
<code class="docutils literal notranslate"><span class="pre">mir_slice_value</span></code> function is one such function:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_slice_value</span>
<span class="go">MIRValue -&gt; MIRValue</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">arr_ref</span></code> is the SAW equivalent of writing <code class="docutils literal notranslate"><span class="pre">arr_ref[..]</span></code>. That
is, if <code class="docutils literal notranslate"><span class="pre">arr_ref</span></code> is of type <code class="docutils literal notranslate"><span class="pre">&amp;[T;</span> <span class="pre">N]</span></code>, then <code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">arr_ref</span></code> is of
type <code class="docutils literal notranslate"><span class="pre">&amp;[T]</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">arr_ref</span></code> must be a <em>reference</em> to an array, not an
array itself.</p>
<p>Let’s use <code class="docutils literal notranslate"><span class="pre">mir_slice_value</span></code> to write a spec for <code class="docutils literal notranslate"><span class="pre">sum_of_prefix</span></code> when the slice
argument is backed by an array of length two:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">sum_of_prefix_spec1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">a_val</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">a_val</span><span class="p">);</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_slice_value</span><span class="w"> </span><span class="n">a_ref</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">(</span><span class="nf">a_val</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nf">a_val</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The first part of this spec allocates an array reference <code class="docutils literal notranslate"><span class="pre">a_ref</span></code> and declares
that it points to a fresh array value <code class="docutils literal notranslate"><span class="pre">a_val</span></code>. The next part declares a slice
<code class="docutils literal notranslate"><span class="pre">s</span></code> that is backed by the entirety of <code class="docutils literal notranslate"><span class="pre">a_ref</span></code>, which is then passed as an
argument to the function itself. Finally, the return value is declared to be
the sum of the first and second elements of <code class="docutils literal notranslate"><span class="pre">a_val</span></code>, which are the same values
that back the slice <code class="docutils literal notranslate"><span class="pre">s</span></code> itself.</p>
<p>As noted above, the <code class="docutils literal notranslate"><span class="pre">sum_of_prefix</span></code> function can work with slices of many
different lengths. Here is a slight modification to this spec that declares it
to take a slice of length 5 rather than a slice of length 2:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">sum_of_prefix_spec2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">a_val</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">a_val</span><span class="p">);</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_slice_value</span><span class="w"> </span><span class="n">a_ref</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">(</span><span class="nf">a_val</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nf">a_val</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Both of these examples declare a slice whose length matches the length of the
underlying array. In general, there is no reason that these have to be the
same, and it is perfectly fine for a slice’s length to be less than the the
length of the underlying array. In Rust, for example, we can write a slice of a
subset of an array by writing <code class="docutils literal notranslate"><span class="pre">&amp;arr_ref[0..2]</span></code>. The SAW equivalent of this can
be achieved with the <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span></code> function:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type mir_slice_range_value</span>
<span class="go">MIRValue -&gt; Int -&gt; Int -&gt; MIRValue</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span></code> takes takes two additional <code class="docutils literal notranslate"><span class="pre">Int</span></code> arguments that
represent (1) the index to start the slice from, and (2) the index at which the
slice ends. For example, <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span> <span class="pre">arr_ref</span> <span class="pre">0</span> <span class="pre">2</span></code> creates a slice
that is backed by the first element (index <code class="docutils literal notranslate"><span class="pre">0</span></code>) and the second element (index
<code class="docutils literal notranslate"><span class="pre">1</span></code>) of <code class="docutils literal notranslate"><span class="pre">arr_ref</span></code>. Note that the range <code class="docutils literal notranslate"><span class="pre">[0..2]</span></code> is half-open, so this range
does <em>not</em> include the third element (index <code class="docutils literal notranslate"><span class="pre">2</span></code>).</p>
<p>For example, here is how to write a spec for <code class="docutils literal notranslate"><span class="pre">sum_of_prefix</span></code> where the slice is
a length-2 subset of the original array:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">sum_of_prefix_spec3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">a_val</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">a_val</span><span class="p">);</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_slice_range_value</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">];</span>

<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">(</span><span class="nf">a_val</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nf">a_val</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that both <code class="docutils literal notranslate"><span class="pre">Int</span></code> arguments to <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span></code> must be concrete
(i.e., not symbolic). (See the section below if you want an explanation for why
they are not allowed to be symbolic.)</p>
<section id="aside-slices-of-arbitrary-length">
<h3>Aside: slices of arbitrary length<a class="headerlink" href="#aside-slices-of-arbitrary-length" title="Link to this heading"></a></h3>
<p>After reading the section about slices above, one might reasonably wonder: is
there a way to write a more general spec for <code class="docutils literal notranslate"><span class="pre">sum_of_prefix</span></code>: that covers all
possible slice lengths <code class="docutils literal notranslate"><span class="pre">n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is greater than or equal to 2? In this
case, the answer is “no”.</p>
<p>This is a fundamental limitation of the way SAW’s symbolic execution works. The
full reason for why this is the case is somewhat technical (keep reading if you
want to learn more), but the short answer is that if SAW attempts to
simulate code whose length is bounded by a symbolic integer, then SAW will go
into an infinite loop. To avoid this pitfall, the <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span></code>
function very deliberately requires the start and end values to be concrete
integers, as allowing these values to be symbolic would allow users to
inadvertently introduce infinite loops in their specifications.</p>
<p>A longer answer as to why SAW loops forever on computations that are bounded by
symbolic lengths: due to the way SAW’s symblolic execution works, it creates a
complete model of the behavior of a function for all possible inputs. The way
that SAW achieves this is by exploring all possible execution paths through a
program. If a program involves a loop, for example, then SAW will unroll all
iterations of the loop to construct a model of the loop’s behavior. Similarly,
if a sequence (e.g., a slice or array) has an unspecified length, then SAW must
consider all possible lengths of the array.</p>
<p>SAW’s ability to completely characterize the behavior of all paths through a
function is one of its strengths, as this allows it to prove theorems that
other program verification techniques would not. This strength is also a
weakness, however. If a loop has a symbolic number of iterations, for example,
then SAW will spin forever trying to unroll the loop. Similarly, if a slice
were to have a symbolic length, then SAW would spin forever trying to simulate
the program for all possible slice lengths.</p>
<p>In general, SAW cannot prevent users from writing programs whose length is
bounded by a symbolic value. For now, however, SAW removes one potential
footgun by requiring that slice values always have a concrete length.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="reference-types.html" class="btn btn-neutral float-left" title="Reference types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="overrides-and-compositional-verification.html" class="btn btn-neutral float-right" title="Overrides and compositional verification" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Galois, Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <!-- Adapted from: -->
<!-- https://github.com/brechtm/rinohtype/commit/1270802c4959eb4742c51d3307222930ac73a80c -->


  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Versions</span>
      v: v1.4
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl id="docs-versions">
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>