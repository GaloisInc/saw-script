-------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) -> #(a1, a2) -> #(b1, b2);
pairMap _ _ _ _ f g (x, y) = (f x, g y);

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) -> (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) -> #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 _ _ _ _ _ _ f1 f2 (x1, x2) (y1, y2) = (f1 x1 y1, f2 x2 y2);

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvExp n x y = foldr Bool (bitvector n) n
  (\ (b :: Bool) -> \ (a :: bitvector n) ->
    ite (bitvector n) b (bvMul n x (bvMul n a a)) (bvMul n a a))
  (bvNat n 1)
  (reverse n Bool y);

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
tcSub TCInf (TCNum _) = TCInf;
-- other cases are undefined

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcDiv (TCNum x) (TCNum y) = TCNum ((divModNat x y).1);
tcDiv (TCNum _) TCInf = TCNum Zero;
-- other cases undefined

tcMod :: Num -> Num -> Num;
tcMod (TCNum x) (TCNum y) = TCNum ((divModNat x y).2);
tcMod (TCNum x) TCInf = TCNum x;
-- other cases undefined

tcExp :: Num -> Num -> Num;
tcExp (TCNum Zero) _ = TCNum Zero;
tcExp (TCNum (Succ Zero)) _ = TCNum (Succ Zero);
tcExp _ (TCNum Zero) = TCNum (Succ Zero);
tcExp (TCNum x) (TCNum y) = TCNum (expNat x y);
-- other cases undefined

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;
tcMax (TCNum x) (TCNum y) = TCNum (maxNat x y);
tcMax (TCNum _) TCInf = TCInf;
tcMax TCInf (TCNum _) = TCInf;
tcMax TCInf TCInf = TCInf;

ceilDivNat :: Nat -> Nat -> Nat;
ceilDivNat x y = divNat (addNat x (subNat y 1)) y;

ceilModNat :: Nat -> Nat -> Nat;
ceilModNat x y = subNat (mulNat (ceilDivNat x y) y) x;

tcCeilDiv :: Num -> Num -> Num;
tcCeilDiv (TCNum x) (TCNum y) = TCNum (ceilDivNat x y);
-- other cases undefined

tcCeilMod :: Num -> Num -> Num;
tcCeilMod (TCNum x) (TCNum y) = TCNum (ceilModNat x y);
-- other cases undefined

tcLenFromThen_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThen_Nat x y w =
  tcLenFromThenTo_Nat x y (ite Nat (ltNat x y) (subNat (expNat 2 w) 1) 0);

tcLenFromThenTo_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThenTo_Nat x y z =
  ite Nat (ltNat x y)
    (ite Nat (ltNat z x) 0 (addNat (divNat (subNat z x) (subNat y x)) 1)) -- increasing
    (ite Nat (ltNat x z) 0 (addNat (divNat (subNat x z) (subNat x y)) 1)); -- decreasing

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThen (TCNum x) (TCNum y) (TCNum w) = TCNum (tcLenFromThen_Nat x y w);
-- tcLenFromThen is undefined on TCInf

tcLenFromThenTo :: Num -> Num -> Num -> Num;
tcLenFromThenTo (TCNum x) (TCNum y) (TCNum z) = TCNum (tcLenFromThenTo_Nat x y z);
-- tcLenFromThenTo is undefined on TCInf

--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq (TCNum n) a = Vec n a;
seq TCInf a = Stream a;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b (TCNum n) f = map a b f n;
seqMap a b TCInf f = streamMap a b f;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst (TCNum n) = replicate n;
seqConst TCInf = streamConst;

--------------------------------------------------------------------------------
-- Auxiliary functions

eListSel :: (a :: sort 0) -> (n :: Num) -> seq n a -> Nat -> a;
eListSel a (TCNum n) xs i = at n a xs i;
eListSel a TCInf xs i = streamGet a xs i;

--------------------------------------------------------------------------------
-- List comprehensions

from :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> (a -> seq n b) -> seq (tcMul m n) #(a, b);
from a b (TCNum m) (TCNum n) =
  \ (xs :: Vec m a) ->
  \ (k :: a -> Vec n b) ->
  join m n #(a, b)
  (map a (Vec n #(a, b))
    (\(x :: a) -> map b #(a, b) (\(y :: b) -> (x, y)) n (k x))
    m xs);

from a b (TCNum m) TCInf =
  natCase
    (\ (m'::Nat) -> (Vec m' a -> (a -> Stream b) ->
        seq (ite Num (equalNat 0 m') (TCNum 0) TCInf) #(a, b)))
      (\ (xs :: Vec 0 a) ->
       \ (k :: a -> Stream b) -> EmptyVec #(a, b))
      (\ (m' :: Nat) ->
       \ (xs :: Vec (Succ m') a) ->
       \ (k :: a -> Stream b) ->
        (\ (x :: a) -> streamMap b #(a, b) (\ (y::b) -> (x, y)) (k x))
        (at (Succ m') a xs 0))
      m;

from a b TCInf (TCNum n) =
  natCase
    (\ (n'::Nat) -> (Stream a -> (a -> Vec n' b) ->
        seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) #(a, b)))
      (\ (xs :: Stream a) ->
       \ (k :: a -> Vec 0 b) -> EmptyVec #(a, b))
      (\ (n' :: Nat) ->
       \ (xs :: Stream a) ->
       \ (k :: a -> Vec (Succ n') b) ->
         streamJoin #(a, b) n'
         (streamMap a (Vec (Succ n') #(a, b))
           (\ (x::a) -> map b #(a, b) (\ (y::b) -> (x, y)) (Succ n') (k x))
           xs))
      n;

from a b TCInf TCInf =
  \ (xs :: Stream a) ->
  \ (k :: a -> Stream b) ->
    (\ (x :: a) -> streamMap b #(a, b) (\ (y :: b) -> (x, y)) (k x))
    (streamGet a xs 0);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> seq n b) -> seq n #(a, b);
mlet a b (TCNum n) x f = map b #(a, b) (\(y :: b) -> (x, y)) n (f x);
mlet a b TCInf x f = streamMap b #(a, b) (\(y :: b) -> (x, y)) (f x);

seqZip :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> seq n b -> seq (tcMin m n) #(a, b);
seqZip a b (TCNum m) (TCNum n) xs ys = zip a b m n xs ys;
seqZip a b (TCNum m) TCInf xs ys = gen m #(a, b) (\(i :: Nat) -> (at m a xs i, streamGet b ys i));
seqZip a b TCInf (TCNum n) xs ys = gen n #(a, b) (\(i :: Nat) -> (streamGet a xs i, at n b ys i));
seqZip a b TCInf TCInf xs ys = streamMap2 a b #(a, b) (\(x::a) -> \(y::b) -> (x, y)) xs ys;

--------------------------------------------------------------------------------
-- Arith and Logic functions

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) -> seq n a -> seq n a -> seq n a;
seqBinary (TCNum n) a f = zipWith a a a f n;
seqBinary TCInf a f = streamMap2 a a a f;

unitUnary :: #() -> #();
unitUnary _ = ();

emptyUnary :: #{} -> #{};
emptyUnary _ = {};

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairUnary :: (a b :: sort 0) -> (a -> a) -> (b -> b) -> #(a | b) -> #(a | b);
pairUnary _ _ f g (x | y) = (f x | g y);

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
           -> #(a | b) -> #(a | b) -> #(a | b);
pairBinary a b f g (x1 | x2) (y1 | y2) = (f x1 y1 | g x2 y2);

emptyBinary :: #{} -> #{} -> #{};
emptyBinary _ _ = {};

fieldUnary :: (s :: String) -> (a b :: sort 0) -> (a -> a) -> (b -> b)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldUnary s _ _ f g { (_) = x | y } = { (s) = f x | g y };

fieldBinary :: (s :: String) -> (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
            -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldBinary s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } = { (s) = f x1 y1 | g x2 y2 };

funBinary :: (a b :: sort 0) -> (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b);
funBinary a b op f g x = op (f x) (g x);

errorUnary :: (a :: sort 0) -> a -> a;
errorUnary a _ = error a "invalid class instance";

errorBinary :: (a :: sort 0) -> a -> a -> a;
errorBinary a _ _ = error a "invalid class instance";

--------------------------------------------------------------------------------
-- Comparisons

boolCmp :: Bool -> Bool -> Bool -> Bool;
boolCmp x y k = ite Bool x (and y k) (or y k);

integerCmp :: Integer -> Integer -> Bool -> Bool;
integerCmp x y k = or (intLt x y) (and (intEq x y) k);

bvCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvCmp n x y k = or (bvult n x y) (and (bvEq n x y) k);

bvSCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvSCmp n x y k = or (bvslt n x y) (and (bvEq n x y) k);

vecCmp :: (n :: Nat) -> (a :: sort 0) -> (a -> a -> Bool -> Bool)
       -> (Vec n a -> Vec n a -> Bool -> Bool);
vecCmp n a f xs ys k =
  foldr (Bool -> Bool) Bool n (\(f :: Bool -> Bool) -> f) k
    (zipWith a a (Bool -> Bool) f n xs ys);

unitCmp :: #() -> #() -> Bool -> Bool;
unitCmp _ _ _ = False;

emptyCmp :: #{} -> #{} -> Bool -> Bool;
emptyCmp _ _ _ = False;

pairCmp :: (a b :: sort 0) -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
        -> #(a | b) -> #(a | b) -> Bool -> Bool;
pairCmp a b f g (x1 | x2) (y1 | y2) k = f x1 y1 (g x2 y2 k);

fieldCmp :: (s :: String) -> (a b :: sort 0)
         -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> Bool -> Bool;
fieldCmp s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } k = f x1 y1 (g x2 y2 k);

errorCmp :: (a :: sort 0) -> a -> a -> Bool -> Bool;
errorCmp _ _ _ _ = error Bool "invalid Cmp instance";

--------------------------------------------------------------------------------
-- Dictionaries and overloading

-- Zero class

PZero :: sort 0 -> sort 0;
PZero a = a;

PZeroBit :: PZero Bool;
PZeroBit = False;

PZeroInteger :: PZero Integer;
PZeroInteger = natToInt 0;

PZeroSeq :: (n :: Num) -> (a :: sort 0) -> PZero a -> PZero (seq n a);
PZeroSeq n a pa = seqConst n a pa;

PZeroSeqBool :: (n :: Num) -> PZero (seq n Bool);
PZeroSeqBool (TCNum n) = bvNat n 0;
PZeroSeqBool TCInf = streamConst Bool False;

PZeroFun :: (a b :: sort 0) -> PZero b -> PZero (a -> b);
PZeroFun a b pb = (\(_ :: a) -> pb);

-- Logic class

PLogic :: sort 0 -> sort 0;
PLogic a =
  #{ and  :: a -> a -> a
   , or   :: a -> a -> a
   , xor  :: a -> a -> a
   , not  :: a -> a
   };

PLogicBit :: PLogic Bool;
PLogicBit =
  { and  = and
  , or   = or
  , xor  = xor
  , not  = not
  };

PLogicVec :: (n :: Nat) -> (a :: sort 0) -> PLogic a -> PLogic (Vec n a);
PLogicVec n a pa =
  { and  = zipWith a a a pa.and n
  , or   = zipWith a a a pa.or  n
  , xor  = zipWith a a a pa.xor n
  , not  = map a a pa.not n
  };

PLogicStream :: (a :: sort 0) -> PLogic a -> PLogic (Stream a);
PLogicStream a pa =
  { and  = streamMap2 a a a pa.and
  , or   = streamMap2 a a a pa.or
  , xor  = streamMap2 a a a pa.xor
  , not  = streamMap a a pa.not
  };

PLogicSeq :: (n :: Num) -> (a :: sort 0) -> PLogic a -> PLogic (seq n a);
PLogicSeq (TCNum n) = PLogicVec n;
PLogicSeq TCInf = PLogicStream;

PLogicWord :: (n :: Nat) -> PLogic (Vec n Bool);
PLogicWord n =
  { and  = bvAnd n
  , or   = bvOr  n
  , xor  = bvXor n
  , not  = bvNot n
  };

PLogicSeqBool :: (n :: Num) -> PLogic (seq n Bool);
PLogicSeqBool (TCNum n) = PLogicWord n;
PLogicSeqBool TCInf = PLogicStream Bool PLogicBit;

PLogicFun :: (a b :: sort 0) -> PLogic b -> PLogic (a -> b);
PLogicFun a b pb =
  { and  = funBinary a b pb.and
  , or   = funBinary a b pb.or
  , xor  = funBinary a b pb.xor
  , not  = compose a b b pb.not
  };

PLogicUnit :: PLogic #();
PLogicUnit =
  { and  = unitBinary
  , or   = unitBinary
  , xor  = unitBinary
  , not  = unitUnary
  };

PLogicPair :: (a b :: sort 0) -> PLogic a -> PLogic b -> PLogic #(a | b);
PLogicPair a b pa pb =
  { and  = pairBinary a b pa.and pb.and
  , or   = pairBinary a b pa.or  pb.or
  , xor  = pairBinary a b pa.xor pb.xor
  , not  = pairUnary a b pa.not pb.not
  };

PLogicEmpty :: PLogic #{};
PLogicEmpty =
  { and  = emptyBinary
  , or   = emptyBinary
  , xor  = emptyBinary
  , not  = emptyUnary
  };

PLogicField :: (s :: String) -> (a b :: sort 0) -> PLogic a -> PLogic b -> PLogic #{ (s) :: a | b };
PLogicField s a b pa pb =
  { and  = fieldBinary s a b pa.and pb.and
  , or   = fieldBinary s a b pa.or  pb.or
  , xor  = fieldBinary s a b pa.xor pb.xor
  , not  = fieldUnary s a b pa.not pb.not
  };

-- Arith class

PArith :: sort 0 -> sort 0;
PArith a =
  #{ add  :: a -> a -> a
   , sub  :: a -> a -> a
   , mul  :: a -> a -> a
   , div  :: a -> a -> a
   , mod  :: a -> a -> a
   , exp  :: a -> a -> a
   , lg2  :: a -> a
   , neg  :: a -> a
   , sdiv :: a -> a -> a
   , smod :: a -> a -> a
   };

PArithInteger :: PArith Integer;
PArithInteger =
  { add = intAdd
  , sub = intSub
  , mul = intMul
  , div = intDiv
  , mod = intMod
  , exp = errorBinary Integer
  , lg2 = errorUnary Integer
  , neg = intNeg
  , sdiv = errorBinary Integer
  , smod = errorBinary Integer
  };

PArithVec :: (n :: Nat) -> (a :: sort 0) -> PArith a -> PArith (Vec n a);
PArithVec n a pa =
  { add = zipWith a a a pa.add n
  , sub = zipWith a a a pa.sub n
  , mul = zipWith a a a pa.mul n
  , div = zipWith a a a pa.div n
  , mod = zipWith a a a pa.mod n
  , exp = zipWith a a a pa.exp n
  , lg2 = map a a pa.lg2 n
  , neg = map a a pa.neg n
  , sdiv = zipWith a a a pa.sdiv n
  , smod = zipWith a a a pa.smod n
  };

PArithStream :: (a :: sort 0) -> PArith a -> PArith (Stream a);
PArithStream a pa =
  { add = streamMap2 a a a pa.add
  , sub = streamMap2 a a a pa.sub
  , mul = streamMap2 a a a pa.mul
  , div = streamMap2 a a a pa.div
  , mod = streamMap2 a a a pa.mod
  , exp = streamMap2 a a a pa.exp
  , lg2 = streamMap a a pa.lg2
  , neg = streamMap a a pa.neg
  , sdiv = streamMap2 a a a pa.sdiv
  , smod = streamMap2 a a a pa.smod
  };

PArithSeq :: (n :: Num) -> (a :: sort 0) -> PArith a -> PArith (seq n a);
PArithSeq (TCNum n) = PArithVec n;
PArithSeq TCInf = PArithStream;

PArithWord :: (n :: Nat) -> PArith (Vec n Bool);
PArithWord n =
  { add = bvAdd n
  , sub = bvSub n
  , mul = bvMul n
  , div = bvUDiv n
  , mod = bvURem n
  , exp = bvExp n
  , lg2 = bvLg2 n
  , neg = bvNeg n
  , sdiv = natCase (\(w::Nat) -> bitvector w -> bitvector w -> bitvector w)
           (errorBinary (bitvector 0)) bvSDiv n
  , smod = natCase (\(w::Nat) -> bitvector w -> bitvector w -> bitvector w)
           (errorBinary (bitvector 0)) bvSRem n
  };

PArithSeqBool :: (n :: Num) -> PArith (seq n Bool);
PArithSeqBool (TCNum n) = PArithWord n;

PArithFun :: (a b :: sort 0) -> PArith b -> PArith (a -> b);
PArithFun a b pb =
  { add = funBinary a b pb.add
  , sub = funBinary a b pb.sub
  , mul = funBinary a b pb.mul
  , div = funBinary a b pb.div
  , mod = funBinary a b pb.mod
  , exp = funBinary a b pb.exp
  , lg2 = compose a b b pb.lg2
  , neg = compose a b b pb.neg
  , sdiv = funBinary a b pb.sdiv
  , smod = funBinary a b pb.smod
  };

PArithUnit :: PArith #();
PArithUnit =
  { add = unitBinary
  , sub = unitBinary
  , mul = unitBinary
  , div = unitBinary
  , mod = unitBinary
  , exp = unitBinary
  , lg2 = unitUnary
  , neg = unitUnary
  , sdiv = unitBinary
  , smod = unitBinary
  };

PArithPair :: (a b :: sort 0) -> PArith a -> PArith b -> PArith #(a | b);
PArithPair a b pa pb =
  { add = pairBinary a b pa.add pb.add
  , sub = pairBinary a b pa.sub pb.sub
  , mul = pairBinary a b pa.mul pb.mul
  , div = pairBinary a b pa.div pb.div
  , mod = pairBinary a b pa.mod pb.mod
  , exp = pairBinary a b pa.exp pb.exp
  , lg2 = pairUnary a b pa.lg2 pb.lg2
  , neg = pairUnary a b pa.neg pb.neg
  , sdiv = pairBinary a b pa.sdiv pb.sdiv
  , smod = pairBinary a b pa.smod pb.smod
  };

PArithEmpty :: PArith #{};
PArithEmpty =
  { add = emptyBinary
  , sub = emptyBinary
  , mul = emptyBinary
  , div = emptyBinary
  , mod = emptyBinary
  , exp = emptyBinary
  , lg2 = emptyUnary
  , neg = emptyUnary
  , sdiv = emptyBinary
  , smod = emptyBinary
  };

PArithField :: (s :: String) -> (a b :: sort 0) -> PArith a -> PArith b -> PArith #{ (s) :: a | b };
PArithField s a b pa pb =
  { add = fieldBinary s a b pa.add pb.add
  , sub = fieldBinary s a b pa.sub pb.sub
  , mul = fieldBinary s a b pa.mul pb.mul
  , div = fieldBinary s a b pa.div pb.div
  , mod = fieldBinary s a b pa.mod pb.mod
  , exp = fieldBinary s a b pa.exp pb.exp
  , lg2 = fieldUnary s a b pa.lg2 pb.lg2
  , neg = fieldUnary s a b pa.neg pb.neg
  , sdiv = fieldBinary s a b pa.sdiv pb.sdiv
  , smod = fieldBinary s a b pa.smod pb.smod
  };

-- Cmp class

PCmp :: sort 0 -> sort 0;
PCmp a = #{ cmp :: a -> a -> Bool -> Bool };

PCmpBit :: PCmp Bool;
PCmpBit = { cmp = boolCmp };

PCmpInteger :: PCmp Integer;
PCmpInteger = { cmp = integerCmp };

PCmpVec :: (n :: Nat) -> (a :: sort 0) -> PCmp a -> PCmp (Vec n a);
PCmpVec n a pa = { cmp = vecCmp n a pa.cmp };

PCmpSeq :: (n :: Num) -> (a :: sort 0) -> PCmp a -> PCmp (seq n a);
PCmpSeq (TCNum n) a pa = PCmpVec n a pa;
PCmpSeq TCInf a pa = { cmp = errorCmp (Stream a) };

PCmpWord :: (n :: Nat) -> PCmp (Vec n Bool);
PCmpWord n = { cmp = bvCmp n };

PCmpSeqBool :: (n :: Num) -> PCmp (seq n Bool);
PCmpSeqBool (TCNum n) = PCmpWord n;
PCmpSeqBool TCInf = { cmp = errorCmp (Stream Bool) };

PCmpUnit :: PCmp #();
PCmpUnit = { cmp = unitCmp };

PCmpPair :: (a b :: sort 0) -> PCmp a -> PCmp b -> PCmp #(a | b);
PCmpPair a b pa pb = { cmp = pairCmp a b pa.cmp pb.cmp };

PCmpEmpty :: PCmp #{};
PCmpEmpty = { cmp = emptyCmp };

PCmpField :: (s :: String) -> (a b :: sort 0) -> PCmp a -> PCmp b -> PCmp #{ (s) :: a | b };
PCmpField s a b pa pb = { cmp = fieldCmp s a b pa.cmp pb.cmp };

-- SignedCmp class

PSignedCmp :: sort 0 -> sort 0;
PSignedCmp a = #{ scmp :: a -> a -> Bool -> Bool };

PSignedCmpVec :: (n :: Nat) -> (a :: sort 0) -> PSignedCmp a -> PSignedCmp (Vec n a);
PSignedCmpVec n a pa = { scmp = vecCmp n a pa.scmp };

PSignedCmpWord :: (n :: Nat) -> PSignedCmp (Vec n Bool);
PSignedCmpWord n = { scmp = bvSCmp n };

PSignedCmpUnit :: PSignedCmp #();
PSignedCmpUnit = { scmp = unitCmp };

PSignedCmpPair :: (a b :: sort 0) -> PSignedCmp a -> PSignedCmp b -> PSignedCmp #(a | b);
PSignedCmpPair a b pa pb = { scmp = pairCmp a b pa.scmp pb.scmp };

PSignedCmpEmpty :: PSignedCmp #{};
PSignedCmpEmpty = { scmp = emptyCmp };

PSignedCmpField :: (s :: String) -> (a b :: sort 0) -> PSignedCmp a -> PSignedCmp b -> PSignedCmp #{ (s) :: a | b };
PSignedCmpField s a b pa pb = { scmp = fieldCmp s a b pa.scmp pb.scmp };

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> seq bits Bool;
ecDemote (TCNum val) (TCNum bits) = bvNat bits val;

ecInteger :: (val :: Num) -> Integer;
ecInteger (TCNum val) = natToInt val;

ecToInteger :: (n :: Num) -> seq n Bool -> Integer;
ecToInteger (TCNum n) = bvToInt n;

ecFromInteger :: (n :: Num) -> Integer -> seq n Bool;
ecFromInteger (TCNum n) = intToBv n;

-- Arith
ecPlus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecPlus a pa = pa.add;

ecMinus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMinus a pa = pa.sub;

ecMul :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMul a pa = pa.mul;

ecDiv :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecDiv a pa = pa.div;

ecMod :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMod a pa = pa.mod;

ecExp :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecExp a pa = pa.exp;

ecLg2 :: (a :: sort 0) -> PArith a -> a -> a;
ecLg2 a pa = pa.lg2;

ecNeg :: (a :: sort 0) -> PArith a -> a -> a;
ecNeg a pa = pa.neg;

ecSDiv :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecSDiv a pa = pa.sdiv;

ecSMod :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecSMod a pa = pa.smod;

-- Cmp
ecLt :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecLt a pa x y = pa.cmp x y False;

ecGt :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecSLt :: (a :: sort 0) -> PSignedCmp a -> a -> a -> Bool;
ecSLt a pa x y = pa.scmp x y False;

ecEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecEq a _ = eq a;

ecNotEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

-- Logic
ecAnd :: (a :: sort 0) -> PLogic a -> a -> a -> a;
ecAnd a pa = pa.and;

ecOr :: (a :: sort 0) -> PLogic a -> a -> a -> a;
ecOr a pa = pa.or;

ecXor :: (a :: sort 0) -> PLogic a -> a -> a -> a;
ecXor a pa = pa.xor;

ecCompl :: (a :: sort 0) -> PLogic a -> a -> a;
ecCompl a pa = pa.not;

ecZero :: (a :: sort 0) -> PZero a -> a;
ecZero a pa = pa;

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: sort 0) -> PZero a -> seq m a -> seq n Bool -> seq m a;
ecShiftL (TCNum m) (TCNum n) a pa = bvShiftL m a n (ecZero a pa);
ecShiftL TCInf (TCNum n) a _ = bvStreamShiftL a n;

ecShiftR :: (m n :: Num) -> (a :: sort 0) -> PZero a -> seq m a -> seq n Bool -> seq m a;
ecShiftR (TCNum m) (TCNum n) a pa = bvShiftR m a n (ecZero a pa);
ecShiftR TCInf (TCNum n) a pa = bvStreamShiftR a n (ecZero a pa);

ecSShiftR :: (n k :: Num) -> seq n Bool -> seq k Bool -> seq n Bool;
ecSShiftR (TCNum n) (TCNum k) =
  natCase (\(w :: Nat) -> bitvector w -> bitvector k -> bitvector w)
  (\(x :: bitvector 0) -> \(i :: bitvector k) -> x)
  (\(w :: Nat) -> \(x :: bitvector (Succ w)) -> \(i :: bitvector k) -> bvSShr w x (bvToNat k i))
  n;

ecCarry :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecCarry (TCNum n) = bvCarry n;

ecSCarry :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSCarry (TCNum n) =
  natCase (\(w :: Nat) -> bitvector w -> bitvector w -> Bool)
  (\(_ :: bitvector 0) (_ :: bitvector 0) -> error Bool "invalid SCarry instance")
  bvSCarry n;

ecRotL :: (m n :: Num) -> (a :: sort 0) -> seq m a -> seq n Bool -> seq m a;
ecRotL (TCNum m) (TCNum n) a = bvRotateL m a n;

ecRotR :: (m n :: Num) -> (a :: sort 0) -> seq m a -> seq n Bool -> seq m a;
ecRotR (TCNum m) (TCNum n) a = bvRotateR m a n;

ecCat :: (m n :: Num) -> (a :: sort 0) -> seq m a -> seq n a -> seq (tcAdd m n) a;
ecCat (TCNum m) (TCNum n) a = append m n a;
ecCat (TCNum m) TCInf a = streamAppend a m;

ecSplitAt :: (m n :: Num) -> (a :: sort 0) -> seq (tcAdd m n) a -> #(seq m a, seq n a);
ecSplitAt (TCNum m) (TCNum n) a xs = (take a m n xs, drop a m n xs);
ecSplitAt (TCNum m) TCInf a xs = (streamTake a m xs, streamDrop a m xs);

ecJoin :: (m n :: Num) -> (a :: sort 0) -> seq m (seq n a) -> seq (tcMul m n) a;
ecJoin (TCNum m) (TCNum n) a = join m n a;
ecJoin TCInf (TCNum n) a =
  natCase
    (\ (n'::Nat) -> Stream (Vec n' a) -> seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) a)
      (\ (s::Stream (Vec 0 a)) -> EmptyVec a)
      (\ (n'::Nat) -> \ (s::Stream (Vec (Succ n') a)) -> streamJoin a n' s)
      n;

ecSplit :: (m n :: Num) -> (a :: sort 0) -> seq (tcMul m n) a -> seq m (seq n a);
ecSplit (TCNum m) (TCNum n) a = split m n a;
ecSplit TCInf (TCNum n) a =
  natCase
  (\(n :: Nat) -> seq (ite Num (equalNat 0 n) (TCNum 0) TCInf) a -> Stream (Vec n a))
  (streamConst (Vec 0 a)) (\(n :: Nat) -> streamSplit a (Succ n)) n;

ecReverse :: (n :: Num) -> (a :: sort 0) -> seq n a -> seq n a;
ecReverse (TCNum n) a = reverse n a;

ecTranspose :: (m n :: Num) -> (a :: sort 0) -> seq m (seq n a) -> seq n (seq m a);
ecTranspose (TCNum m) (TCNum n) a = transpose m n a;
-- TODO: other cases

ecAt :: (n :: Num) -> (a :: sort 0) -> (i :: Num) -> seq n a -> seq i Bool -> a;
ecAt (TCNum n) a (TCNum i) = bvAt n a i;
ecAt TCInf a (TCNum i) = bvStreamGet a i;

ecAtRange :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> seq n a -> seq m (seq i Bool) -> seq m a;
ecAtRange n a m i xs = seqMap (seq i Bool) a m (ecAt n a i xs);

ecAtBack :: (n :: Num) -> (a :: sort 0) -> (i :: Num) -> seq n a -> seq i Bool -> a;
ecAtBack n a i xs = ecAt n a i (ecReverse n a xs);

ecAtRangeBack :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> seq n a -> seq m (seq i Bool) -> seq m a;
ecAtRangeBack n a m i xs = seqMap (seq i Bool) a m (ecAtBack n a i xs);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> seq len (seq bits Bool);
ecFromThen (TCNum first) (TCNum next) (TCNum bits) (TCNum len) =
  gen len (Vec bits Bool)
    (\(i :: Nat) -> bvAdd bits (bvNat bits first)
                          (bvMul bits (bvSub bits (bvNat bits next) (bvNat bits first))
			              (bvNat bits i)));

ecFromTo :: (first last bits :: Num)
         -> seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo (TCNum first) (TCNum last) (TCNum bits) =
  gen (addNat 1 (subNat last first)) (Vec bits Bool)
    (\(i :: Nat) -> bvNat bits (addNat i first));

ecFromThenTo :: (first next last bits len :: Num) -> seq len (seq bits Bool);
ecFromThenTo (TCNum first) (TCNum next) _ (TCNum bits) (TCNum len) =
  gen len (Vec bits Bool)
    (\(i :: Nat) ->
      bvNat bits (subNat (addNat first (mulNat i next)) (mulNat i first)));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom (TCNum n) w = MkStream (bitvector n) (\(i :: Nat) -> bvAdd n w (bvNat n i));

ecInfFromThen :: (n :: Num) -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFromThen (TCNum n) first next =
  MkStream (bitvector n) (\(i :: Nat) ->
    bvAdd n first (bvMul n (bvSub n next first) (bvNat n i)));

-- Run-time error
primitive cryError :: (a :: sort 0) -> (n :: Nat) -> Vec n (bitvector 8) -> a;

ecError :: (a :: sort 0) -> (len :: Num) -> seq len (bitvector 8) -> a;
ecError a (TCNum n) = cryError a n;

-- Polynomials
ecPMul :: (a b :: Num) -> seq (tcAdd (TCNum 1) a) Bool -> seq (tcAdd (TCNum 1) b) Bool
       -> seq (tcAdd (TCNum 1) (tcAdd a b)) Bool;
ecPMul (TCNum a) (TCNum b) = bvPMul a b;

ecPDiv :: (a b :: Num) -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv (TCNum a) (TCNum b) = bvPDiv a b;

ecPMod :: (a b :: Num) -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool -> seq b Bool;
ecPMod (TCNum a) (TCNum b) = bvPMod a b;

-- Random values
ecRandom :: (a :: sort 0) -> bitvector 32 -> a;
ecRandom a _ = error a "Cryptol.random";

-- Trace function; simply return the final argument
ecTrace :: (n :: Num) -> (a b :: sort 0) -> seq n (bitvector 8) -> a -> b -> b;
ecTrace _ _ _ _ _ x = x;

--------------------------------------------------------------------------------
-- Extra primitives

-- Array update
ecUpdate :: (n :: Num) -> (a :: sort 0) -> (w :: Num)
  -> seq n a -> seq w Bool -> a -> seq n a;
ecUpdate (TCNum n) a (TCNum w) = bvUpd n a w;
ecUpdate TCInf     a (TCNum w) = bvStreamUpd a w;

ecUpdateEnd :: (n :: Num) -> (a :: sort 0) -> (w :: Num)
  -> seq n a -> seq w Bool -> a -> seq n a;
ecUpdateEnd (TCNum n) a (TCNum w) xs i y = upd n a xs (subNat (subNat n 1) (bvToNat w i)) y;

-- Bitvector truncation
ecTrunc :: (m n :: Num) -> seq (tcAdd m n) Bool -> seq n Bool;
ecTrunc (TCNum m) (TCNum n) = bvTrunc m n;

-- Zero extension
ecUExt :: (m n :: Num) -> seq n Bool -> seq (tcAdd m n) Bool;
ecUExt (TCNum m) (TCNum n) = bvUExt m n;

-- Sign extension
ecSExt :: (m n :: Num) -> seq n Bool -> seq (tcAdd m n) Bool;
ecSExt (TCNum m) (TCNum n) =
  natCase
  (\(n' :: Nat) -> bitvector n' -> bitvector (addNat m n'))
  (\(_ :: bitvector 0) -> bvNat (addNat m 0) 0)
  (bvSExt m)
  n;

-- Signed greater-than
ecSgt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSgt (TCNum n) = bvsgt n;

-- Signed greater-or-equal
ecSge :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSge (TCNum n) = bvsge n;

-- Signed less-than
ecSlt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSlt (TCNum n) = bvslt n;

-- Signed less-or-equal
ecSle :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSle (TCNum n) = bvsle n;

--------------------------------------------------------------------------------
-- Rewrite rules

axiom replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

axiom subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

axiom demote_add_distr
  :: (w :: Nat)
  -> (x y :: Num)
  -> Eq (bitvector w)
        (ecDemote (tcAdd x y) (TCNum w))
        (bvAdd w (ecDemote x (TCNum w)) (ecDemote y (TCNum w)));

--------------------------------------------------------------------------------
