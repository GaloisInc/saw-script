enable_experimental;

import "test.cry";
mod <- llvm_load_module "test.bc";

llvm_ffi_verify mod {{ add8 }} [] true z3;
llvm_ffi_verify mod {{ sub16 }} [] true z3;
llvm_ffi_verify mod {{ mul32 }} [] true z3;
llvm_ffi_verify mod {{ div64 }} [] true z3;

llvm_ffi_verify mod {{ extendInput }} [] true z3;
llvm_ffi_verify mod {{ maskOutput }} [] true z3;
llvm_ffi_verify mod {{ noBits }} [] true z3;

not_ov <- llvm_ffi_verify mod {{ not }} [] true z3;

llvm_ffi_verify mod {{ usesTypeSynonym }} [] true z3;

llvm_ffi_verify mod {{ sum10 }} [] true z3;
llvm_ffi_verify mod {{ reverse5 }} [] true z3;

compoundTypes_ov <- llvm_ffi_verify mod {{ compoundTypes }} [] true z3;

for [0, 12345, 4294967297] (\n ->
  llvm_ffi_verify mod {{ typeToValue`{n} }} [] true z3);
for [0, 1, 5, 42, 100] (\n ->
  llvm_ffi_verify mod {{ sumPoly`{n} }} [] true z3);
for [1, 3, 72] (\n ->
  llvm_ffi_verify mod {{ inits`{n} }} [] true z3);
let dims = [1, 2, 3];
for dims (\n ->
  for dims (\m ->
    for dims (\p ->
      llvm_ffi_verify mod {{ zipMul3`{n, m, p} }} [] true z3)));

for dims (\a ->
  for dims (\b ->
    for dims (\c ->
      for dims (\d ->
        llvm_ffi_verify mod {{ reshape`{a, b, c, d} }} [] true z3))));

let same_setup = llvm_ffi_setup {{ same }};
llvm_verify mod "same" [] true same_setup z3;
llvm_verify mod "same" [compoundTypes_ov] true same_setup z3;

let notnot_setup = llvm_ffi_setup {{ notnot }};
llvm_verify mod "notnot" [] true notnot_setup z3;
llvm_verify mod "notnot" [not_ov] true notnot_setup z3;
