// Tests that Yosys built-in comparison, boolean, and reduction cell types
// which return 1 bit of data are allowed to have output widths of more than
// one bit (zero-padded).
enable_experimental;
m <- yosys_import "test.json";

let {{

  pad : Bit -> { Y : [4] }
  pad b = { Y = zero # [b] }

  reduce : (Bit -> Bit -> Bit) -> [2] -> Bit
  reduce f [a, b] = f a b

  toBool : [2] -> Bit
  toBool = reduce (||)

  bool : (Bit -> Bit -> Bit) -> [2] -> [2] -> Bit
  bool f a b = f (toBool a) (toBool b)

  unary : ([2] -> Bit) -> { A : [2] } -> { Y : [4] }
  unary f in = pad (f in.A)

  binary : ([2] -> [2] -> Bit) -> { A : [2], B : [2] } -> { Y : [4] }
  binary f in = pad (f in.A in.B)

}};

// These definitions are based on the behavior of the Yosys "eval" command for
// these modules. Note: eq/ne and eqx/nex differ in their treatment of z and x
// values (not currently supported by SAW).
prove_print w4 {{ m.eq === binary (==) }};
prove_print w4 {{ m.eqx === binary (==) }};
prove_print w4 {{ m.ne === binary (!=) }};
prove_print w4 {{ m.nex === binary (!=) }};

prove_print w4 {{ m.lt === binary (<) }};
prove_print w4 {{ m.le === binary (<=) }};
prove_print w4 {{ m.gt === binary (>) }};
prove_print w4 {{ m.ge === binary (>=) }};
prove_print w4 {{ m.logic_or === binary (bool (||)) }};
prove_print w4 {{ m.logic_and === binary (bool (&&)) }};
prove_print w4 {{ m.logic_not === unary (\a -> ~toBool a) }};

prove_print w4 {{ m.reduce_xor === unary (reduce (^)) }};
prove_print w4 {{ m.reduce_xnor === unary (reduce (\a b -> ~ (a ^ b))) }};
prove_print w4 {{ m.reduce_or === unary toBool }};
prove_print w4 {{ m.reduce_bool === unary toBool }};
prove_print w4 {{ m.reduce_and === unary (reduce (&&)) }};


