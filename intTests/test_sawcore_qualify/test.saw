let require_convertible t1 t2 = do {
  b <- is_convertible t1 t2;
  if b then return () else
  fail (str_concats
    [ "Terms are not convertible:\n"
    , show_term t1
    , "\n\nvs.\n\n"
    , show_term t2
    ]);
};

let no_parse s =
  fails (do { let _ = parse_core s; print "Unexpected success"; } );

let parse_as s t2 = do {
  let t1 = parse_core s;
  require_convertible t1 t2;
  let t1' = parse_core (show_term t1);
  require_convertible t1' t1;
  print_term t2;
  let t2' = parse_core (show_term t2);
  require_convertible t2' t2;
  return t1;
};

import "A/B.cry";

x_cryptol <- parse_as "x" {{ 0x1 }};
parse_as "A::B:|:C::x@cryptol" x_cryptol;
parse_as "|:C::x@cryptol" x_cryptol;

print_term x_cryptol;

x_fresh <- define "x" {{ 0 : Integer }};

print_term x_cryptol;

no_parse "x";

parse_as "x@cryptol" x_cryptol;
parse_as "A::B:|:C::x" x_cryptol;
parse_as "x@fresh" x_fresh;

no_parse "x@core";

enable_experimental;

import "A.cry";

no_parse "x@cryptol";

A_x_cryptol <- parse_as "A::x" {{ 0x2 }};
parse_as "A::B::x" x_cryptol;
parse_as "|:C::x" x_cryptol;

load_sawcore_from_file "A.sawcore";

// as a special case, we attempt to disambiguate names
// by adding @core implicitly
x_core <- parse_as "x" (parse_core "True");
parse_as "A::x" x_core;
parse_as "x@core" x_core;

parse_as "A::x@cryptol" A_x_cryptol;
parse_as "A::B::x" x_cryptol;
parse_as "x@fresh" x_fresh;

load_sawcore_from_file "B.sawcore";

// now 'x' is no longer unambiguous, even with @core
no_parse "x";
no_parse "x@core";

parse_as "A::x" x_core;

import "D.cry";

let bang_huh = {{ \a b -> a !? b }};

parse_as "!?\"!?\"" bang_huh;
parse_as "D::!?\"!?\"" bang_huh;
parse_as "D::!?\"!?\"@cryptol" bang_huh;

let bang_backslash = {{ \a b -> a !\ b }};

write_core "D.extcore" bang_backslash;
bang_backslash2 <- read_core "D.extcore";

let s = show_term bang_backslash;
print s;

ab <- define "a\nb" {{ \a b -> a !? b }};
parse_as "!?\"a\\nb\"" ab;

let garble_s = "let { !?\"a\\nc\" = (!?\"a\\nb\",!?\"!?\"); x = (!?\"a\\nb\",!?\"a\\nc\"); } in (!?\"a\\nc\",!?\"a\\nb\",x)";
let garble = parse_core garble_s;
print_term garble;

parse_as garble_s garble;

let garble2 = unfold_term ["!?\"a\\nb\""] garble;
print_term garble2;
parse_as garble_s garble2;


let x_frees = parse_core "let { x@free : Bool; y = (\\(z : Nat) -> let { x@free : Bool; } in (x@free,(z,z),(z,z),(z,z))); } in (x@free, y,y)";
let x_frees' = parse_core (show_term x_frees);

// re-parses into a distinct term, since x@free is refreshed
fails (require_convertible x_frees x_frees');

// fresh_symbolic results in @fresh variables, which are distinguished and not considered free
x_fresh2 <- fresh_symbolic "x" {| Bool |};
// this now clashes with the previous defined "x"
no_parse "x@fresh";

z_fresh <- fresh_symbolic "z" {| Bool |};
parse_as "z@fresh" z_fresh;
parse_as "z" z_fresh;

// when parsing, the name "z@free" here is locally scoped and thus
// the two uses are considered unambiguous (as with lambda bindings, the most recent
// binding has precedence).
// the "@free" namespace qualifier is mandatory, so "z" is unambigously resolved to
// the above "z@fresh" until it is masked by the let-binding
// the printer, however, renames free variables in order to disambiguate them
let t = parse_core
    "let { z@free : Bool; z = let { x = z@free; z@free : Bool; } in (x,z, z@free); } in (z@free,z@fresh,z)";

// the printed term is stable after a round trip (needs to be checked via log diff)
print_term t;
print_term (parse_core (show_term t));

// this is an undeclared free variable, and is therefore always distinct
// when re-parsed
let x_free = parse_core "let { x@free : Bool;} in x@free";
let x_free2 = parse_core (show_term x_free);
fails (require_convertible x_free x_free2);

let x_free_eq = parse_core "let { x@free : Bool; } in \\(x : Bool) -> EqTrue (boolEq x@free x)";
let test = beta_reduce_term (term_apply x_free_eq [x_free]);
print_term test;

fails (prove_extcore z3 test);

// if "fresh_symbolic" is given an invalid identifer, it is implicitly
// quoted when creating the formal name
x_y <- fresh_symbolic "x&&y" {| Bool |};
// despite being declared, if it appears under a binder it is
// treated as bound there
parse_as "(\\(y : Bool) -> y)" (lambda x_y x_y);

// despite all 3 occurances being the same formal variable, it
// is printed according to its bound name under the lambda, but
// according to its "declared" name outside the lambda
let x_y_app_x_y = term_apply (lambda x_y x_y) [x_y];
parse_as "(\\(y : Bool) -> y) !?\"x&&y\"@fresh" x_y_app_x_y;

print "Success";