let require_convertible t1 t2 = do {
  b <- is_convertible t1 t2;
  if b then return () else
  fail (str_concats
    [ "Terms are not convertible:\n"
    , show_term t1
    , "\n\nvs.\n\n"
    , show_term t2
    ]);
};

let no_parse s =
  fails (do { let _ = parse_core s; print "Unexpected success"; } );

let parse_as s t2 = do {
  let t1 = parse_core s;
  require_convertible t1 t2;
  let t1' = parse_core (show_term t1);
  require_convertible t1' t1;
  print_term t2;
  let t2' = parse_core (show_term t2);
  require_convertible t2' t2;
  return t1;
};

import "A/B.cry";

x_cryptol <- parse_as "x" {{ 0x1 }};
parse_as "A::B:|:C::x@cryptol" x_cryptol;
parse_as "|:C::x@cryptol" x_cryptol;

print_term x_cryptol;

x_fresh <- define "x" {{ 0 : Integer }};

print_term x_cryptol;

no_parse "x";

parse_as "x@cryptol" x_cryptol;
parse_as "A::B:|:C::x" x_cryptol;
parse_as "x@fresh" x_fresh;

no_parse "x@core";

enable_experimental;

import "A.cry";

no_parse "x@cryptol";

A_x_cryptol <- parse_as "A::x" {{ 0x2 }};
parse_as "A::B::x" x_cryptol;
parse_as "|:C::x" x_cryptol;

load_sawcore_from_file "A.sawcore";

// as a special case, we attempt to disambiguate names
// by adding @core implicitly
x_core <- parse_as "x" (parse_core "True");
parse_as "A::x" x_core;
parse_as "x@core" x_core;

parse_as "A::x@cryptol" A_x_cryptol;
parse_as "A::B::x" x_cryptol;
parse_as "x@fresh" x_fresh;

load_sawcore_from_file "B.sawcore";

// now 'x' is no longer unambiguous, even with @core
no_parse "x";
no_parse "x@core";

parse_as "A::x" x_core;

import "D.cry";

let bang_huh = {{ \a b -> a !? b }};

parse_as "!?\"!?\"" bang_huh;
parse_as "D::!?\"!?\"" bang_huh;
parse_as "D::!?\"!?\"@cryptol" bang_huh;

let bang_backslash = {{ \a b -> a !\ b }};

write_core "D.extcore" bang_backslash;
bang_backslash2 <- read_core "D.extcore";

let s = show_term bang_backslash;
print s;

ab <- define "a\nb" {{ \a b -> a !? b }};
parse_as "!?\"a\\nb\"" ab;

let garble_s = "let { !?\"a\\nc\" = (!?\"a\\nb\",!?\"!?\"); x = (!?\"a\\nb\",!?\"a\\nc\"); } in (!?\"a\\nc\",!?\"a\\nb\",x)";
let garble = parse_core garble_s;
print_term garble;

parse_as garble_s garble;

let garble2 = unfold_term ["!?\"a\\nb\""] garble;
print_term garble2;
parse_as garble_s garble2;


let x_frees = parse_core "let { x@free : Bool; y = (\\(z : Nat) -> let { x@free : Bool; } in (x@free,(z,z),(z,z),(z,z))); } in (x@free, y,y)";
let x_frees' = parse_core (show_term x_frees);

// re-parses into a distinct term, since x@free is refreshed
fails (require_convertible x_frees x_frees');

// fresh_symbolic results in @free variables, but these are still refreshed on printing/parsing
x_free <- fresh_symbolic "x" {| Bool |};
print_term x_free;

let x_free_eq = parse_core "let { x@free : Bool; } in \\(x : Bool) -> EqTrue (boolEq x@free x)";
let test = beta_reduce_term (term_apply x_free_eq [x_free]);
print_term test;

fails (prove_extcore z3 test);

print "Success";