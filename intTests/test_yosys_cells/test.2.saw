enable_experimental;
m <- yosys_import "test.json";
let {{
  (===>) : {a, y} (fin y) => (a -> {Y: [y](Option Bit)}) -> (a -> {Y: [y]}) -> a -> Bit
  (===>) spec impl a = and [i == fromOption i s | i <- (impl a).Y | s <- (spec a).Y]
                       where
                         fromOption : {b} b -> Option b -> b
                         fromOption def opt = case opt of
                                                Some x -> x
                                                None   -> def

  spec_and : {A: [0], B: [0]} -> {Y: [0](Option Bit)}
  spec_and in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = []

  spec_or : {A: [0], B: [0]} -> {Y: [0](Option Bit)}
  spec_or in = {Y = out}
               where
                 out = spec (in.A, in.B)
                 spec a = []

  spec_ge : {A: [0], B: [0]} -> {Y: [0](Option Bit)}
  spec_ge in = {Y = out}
               where
                 out = spec (in.A, in.B)
                 spec a = []

  spec_eq1 : {A: [0], B: [0]} -> {Y: [2](Option Bit)}
  spec_eq1 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = [Some 0, Some 1]

  spec_sub1 : {A: [0], B: [0]} -> {Y: [2](Option Bit)}
  spec_sub1 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = [Some 0, Some 0]

  spec_gt1 : {A: [0], B: [0]} -> {Y: [2](Option Bit)}
  spec_gt1 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = [Some 0, Some 0]

  spec_eqx2 : {A: [2], B: [2]} -> {Y: [2](Option Bit)}
  spec_eqx2 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, 0b00) then [Some 0, Some 1]
                             | a == (0b00, 0b01) then [Some 0, Some 0]
                             | a == (0b00, 0b10) then [Some 0, Some 0]
                             | a == (0b00, 0b11) then [Some 0, Some 0]
                             | a == (0b01, 0b00) then [Some 0, Some 0]
                             | a == (0b01, 0b01) then [Some 0, Some 1]
                             | a == (0b01, 0b10) then [Some 0, Some 0]
                             | a == (0b01, 0b11) then [Some 0, Some 0]
                             | a == (0b10, 0b00) then [Some 0, Some 0]
                             | a == (0b10, 0b01) then [Some 0, Some 0]
                             | a == (0b10, 0b10) then [Some 0, Some 1]
                             | a == (0b10, 0b11) then [Some 0, Some 0]
                             | a == (0b11, 0b00) then [Some 0, Some 0]
                             | a == (0b11, 0b01) then [Some 0, Some 0]
                             | a == (0b11, 0b10) then [Some 0, Some 0]
                             | a == (0b11, 0b11) then [Some 0, Some 1]
                            else repeat None

  spec_xnor2 : {A: [2], B: [2]} -> {Y: [2](Option Bit)}
  spec_xnor2 in = {Y = out}
                  where
                    out = spec (in.A, in.B)
                    spec a = if a == (0b00, 0b00) then [Some 1, Some 1]
                              | a == (0b00, 0b01) then [Some 1, Some 0]
                              | a == (0b00, 0b10) then [Some 0, Some 1]
                              | a == (0b00, 0b11) then [Some 0, Some 0]
                              | a == (0b01, 0b00) then [Some 1, Some 0]
                              | a == (0b01, 0b01) then [Some 1, Some 1]
                              | a == (0b01, 0b10) then [Some 0, Some 0]
                              | a == (0b01, 0b11) then [Some 0, Some 1]
                              | a == (0b10, 0b00) then [Some 0, Some 1]
                              | a == (0b10, 0b01) then [Some 0, Some 0]
                              | a == (0b10, 0b10) then [Some 1, Some 1]
                              | a == (0b10, 0b11) then [Some 1, Some 0]
                              | a == (0b11, 0b00) then [Some 0, Some 0]
                              | a == (0b11, 0b01) then [Some 0, Some 1]
                              | a == (0b11, 0b10) then [Some 1, Some 0]
                              | a == (0b11, 0b11) then [Some 1, Some 1]
                             else repeat None

  spec_le2 : {A: [2], B: [2]} -> {Y: [2](Option Bit)}
  spec_le2 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = if a == (0b00, 0b00) then [Some 0, Some 1]
                            | a == (0b00, 0b01) then [Some 0, Some 1]
                            | a == (0b00, 0b10) then [Some 0, Some 1]
                            | a == (0b00, 0b11) then [Some 0, Some 1]
                            | a == (0b01, 0b00) then [Some 0, Some 0]
                            | a == (0b01, 0b01) then [Some 0, Some 1]
                            | a == (0b01, 0b10) then [Some 0, Some 1]
                            | a == (0b01, 0b11) then [Some 0, Some 1]
                            | a == (0b10, 0b00) then [Some 0, Some 0]
                            | a == (0b10, 0b01) then [Some 0, Some 0]
                            | a == (0b10, 0b10) then [Some 0, Some 1]
                            | a == (0b10, 0b11) then [Some 0, Some 1]
                            | a == (0b11, 0b00) then [Some 0, Some 0]
                            | a == (0b11, 0b01) then [Some 0, Some 0]
                            | a == (0b11, 0b10) then [Some 0, Some 0]
                            | a == (0b11, 0b11) then [Some 0, Some 1]
                           else repeat None

  spec_mul3 : {A: [2], B: [0]} -> {Y: [1](Option Bit)}
  spec_mul3 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, zero) then [Some 0]
                             | a == (0b01, zero) then [Some 0]
                             | a == (0b10, zero) then [Some 0]
                             | a == (0b11, zero) then [Some 0]
                            else repeat None

  spec_xor3 : {A: [2], B: [0]} -> {Y: [1](Option Bit)}
  spec_xor3 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, zero) then [Some 0]
                             | a == (0b01, zero) then [Some 1]
                             | a == (0b10, zero) then [Some 0]
                             | a == (0b11, zero) then [Some 1]
                            else repeat None

  spec_lt3 : {A: [2], B: [0]} -> {Y: [1](Option Bit)}
  spec_lt3 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = if a == (0b00, zero) then [Some 0]
                            | a == (0b01, zero) then [Some 0]
                            | a == (0b10, zero) then [Some 1]
                            | a == (0b11, zero) then [Some 1]
                           else repeat None

  spec_ne4 : {A: [0], B: [2]} -> {Y: [1](Option Bit)}
  spec_ne4 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = if a == (zero, 0b00) then [Some 0]
                            | a == (zero, 0b01) then [Some 1]
                            | a == (zero, 0b10) then [Some 1]
                            | a == (zero, 0b11) then [Some 1]
                           else repeat None

  spec_div4 : {A: [0], B: [2]} -> {Y: [1](Option Bit)}
  spec_div4 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (zero, 0b00) then [None]
                             | a == (zero, 0b01) then [Some 0]
                             | a == (zero, 0b10) then [Some 0]
                             | a == (zero, 0b11) then [Some 0]
                            else repeat None

  spec_add5 : {A: [2], B: [2]} -> {Y: [1](Option Bit)}
  spec_add5 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, 0b00) then [Some 0]
                             | a == (0b00, 0b01) then [Some 1]
                             | a == (0b00, 0b10) then [Some 0]
                             | a == (0b00, 0b11) then [Some 1]
                             | a == (0b01, 0b00) then [Some 1]
                             | a == (0b01, 0b01) then [Some 0]
                             | a == (0b01, 0b10) then [Some 1]
                             | a == (0b01, 0b11) then [Some 0]
                             | a == (0b10, 0b00) then [Some 0]
                             | a == (0b10, 0b01) then [Some 1]
                             | a == (0b10, 0b10) then [Some 0]
                             | a == (0b10, 0b11) then [Some 1]
                             | a == (0b11, 0b00) then [Some 1]
                             | a == (0b11, 0b01) then [Some 0]
                             | a == (0b11, 0b10) then [Some 1]
                             | a == (0b11, 0b11) then [Some 0]
                            else repeat None

  spec_nex5 : {A: [2], B: [2]} -> {Y: [1](Option Bit)}
  spec_nex5 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, 0b00) then [Some 0]
                             | a == (0b00, 0b01) then [Some 1]
                             | a == (0b00, 0b10) then [Some 1]
                             | a == (0b00, 0b11) then [Some 1]
                             | a == (0b01, 0b00) then [Some 1]
                             | a == (0b01, 0b01) then [Some 0]
                             | a == (0b01, 0b10) then [Some 1]
                             | a == (0b01, 0b11) then [Some 1]
                             | a == (0b10, 0b00) then [Some 1]
                             | a == (0b10, 0b01) then [Some 1]
                             | a == (0b10, 0b10) then [Some 0]
                             | a == (0b10, 0b11) then [Some 1]
                             | a == (0b11, 0b00) then [Some 1]
                             | a == (0b11, 0b01) then [Some 1]
                             | a == (0b11, 0b10) then [Some 1]
                             | a == (0b11, 0b11) then [Some 0]
                            else repeat None

  spec_mod5 : {A: [2], B: [2]} -> {Y: [1](Option Bit)}
  spec_mod5 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, 0b00) then [None]
                             | a == (0b00, 0b01) then [Some 0]
                             | a == (0b00, 0b10) then [Some 0]
                             | a == (0b00, 0b11) then [Some 0]
                             | a == (0b01, 0b00) then [None]
                             | a == (0b01, 0b01) then [Some 0]
                             | a == (0b01, 0b10) then [Some 1]
                             | a == (0b01, 0b11) then [Some 0]
                             | a == (0b10, 0b00) then [None]
                             | a == (0b10, 0b01) then [Some 0]
                             | a == (0b10, 0b10) then [Some 0]
                             | a == (0b10, 0b11) then [Some 0]
                             | a == (0b11, 0b00) then [None]
                             | a == (0b11, 0b01) then [Some 0]
                             | a == (0b11, 0b10) then [Some 1]
                             | a == (0b11, 0b11) then [Some 0]
                            else repeat None

  spec_and6 : {A: [2], B: [2]} -> {Y: [3](Option Bit)}
  spec_and6 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, 0b00) then [Some 0, Some 0, Some 0]
                             | a == (0b00, 0b01) then [Some 0, Some 0, Some 0]
                             | a == (0b00, 0b10) then [Some 0, Some 0, Some 0]
                             | a == (0b00, 0b11) then [Some 0, Some 0, Some 0]
                             | a == (0b01, 0b00) then [Some 0, Some 0, Some 0]
                             | a == (0b01, 0b01) then [Some 0, Some 0, Some 1]
                             | a == (0b01, 0b10) then [Some 0, Some 0, Some 0]
                             | a == (0b01, 0b11) then [Some 0, Some 0, Some 1]
                             | a == (0b10, 0b00) then [Some 0, Some 0, Some 0]
                             | a == (0b10, 0b01) then [Some 0, Some 0, Some 0]
                             | a == (0b10, 0b10) then [Some 1, Some 1, Some 0]
                             | a == (0b10, 0b11) then [Some 1, Some 1, Some 0]
                             | a == (0b11, 0b00) then [Some 0, Some 0, Some 0]
                             | a == (0b11, 0b01) then [Some 0, Some 0, Some 1]
                             | a == (0b11, 0b10) then [Some 1, Some 1, Some 0]
                             | a == (0b11, 0b11) then [Some 1, Some 1, Some 1]
                            else repeat None

  spec_or6 : {A: [2], B: [2]} -> {Y: [3](Option Bit)}
  spec_or6 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = if a == (0b00, 0b00) then [Some 0, Some 0, Some 0]
                            | a == (0b00, 0b01) then [Some 0, Some 0, Some 1]
                            | a == (0b00, 0b10) then [Some 1, Some 1, Some 0]
                            | a == (0b00, 0b11) then [Some 1, Some 1, Some 1]
                            | a == (0b01, 0b00) then [Some 0, Some 0, Some 1]
                            | a == (0b01, 0b01) then [Some 0, Some 0, Some 1]
                            | a == (0b01, 0b10) then [Some 1, Some 1, Some 1]
                            | a == (0b01, 0b11) then [Some 1, Some 1, Some 1]
                            | a == (0b10, 0b00) then [Some 1, Some 1, Some 0]
                            | a == (0b10, 0b01) then [Some 1, Some 1, Some 1]
                            | a == (0b10, 0b10) then [Some 1, Some 1, Some 0]
                            | a == (0b10, 0b11) then [Some 1, Some 1, Some 1]
                            | a == (0b11, 0b00) then [Some 1, Some 1, Some 1]
                            | a == (0b11, 0b01) then [Some 1, Some 1, Some 1]
                            | a == (0b11, 0b10) then [Some 1, Some 1, Some 1]
                            | a == (0b11, 0b11) then [Some 1, Some 1, Some 1]
                           else repeat None

  spec_ge6 : {A: [2], B: [2]} -> {Y: [3](Option Bit)}
  spec_ge6 in = {Y = out}
                where
                  out = spec (in.A, in.B)
                  spec a = if a == (0b00, 0b00) then [Some 0, Some 0, Some 1]
                            | a == (0b00, 0b01) then [Some 0, Some 0, Some 0]
                            | a == (0b00, 0b10) then [Some 0, Some 0, Some 1]
                            | a == (0b00, 0b11) then [Some 0, Some 0, Some 1]
                            | a == (0b01, 0b00) then [Some 0, Some 0, Some 1]
                            | a == (0b01, 0b01) then [Some 0, Some 0, Some 1]
                            | a == (0b01, 0b10) then [Some 0, Some 0, Some 1]
                            | a == (0b01, 0b11) then [Some 0, Some 0, Some 1]
                            | a == (0b10, 0b00) then [Some 0, Some 0, Some 0]
                            | a == (0b10, 0b01) then [Some 0, Some 0, Some 0]
                            | a == (0b10, 0b10) then [Some 0, Some 0, Some 1]
                            | a == (0b10, 0b11) then [Some 0, Some 0, Some 0]
                            | a == (0b11, 0b00) then [Some 0, Some 0, Some 0]
                            | a == (0b11, 0b01) then [Some 0, Some 0, Some 0]
                            | a == (0b11, 0b10) then [Some 0, Some 0, Some 1]
                            | a == (0b11, 0b11) then [Some 0, Some 0, Some 1]
                           else repeat None

  spec_shift : {A: [1], B: [0]} -> {Y: [1](Option Bit)}
  spec_shift in = {Y = out}
                  where
                    out = spec (in.A, in.B)
                    spec a = if a == (0b0, zero) then [Some 0]
                              | a == (0b1, zero) then [Some 1]
                             else repeat None

  spec_shift2 : {A: [2], B: [2]} -> {Y: [3](Option Bit)}
  spec_shift2 in = {Y = out}
                   where
                     out = spec (in.A, in.B)
                     spec a = if a == (0b00, 0b00) then [Some 0, Some 0, Some 0]
                               | a == (0b00, 0b01) then [Some 0, Some 0, Some 0]
                               | a == (0b00, 0b10) then [Some 0, Some 0, Some 0]
                               | a == (0b00, 0b11) then [Some 0, Some 0, Some 0]
                               | a == (0b01, 0b00) then [Some 0, Some 0, Some 1]
                               | a == (0b01, 0b01) then [Some 0, Some 0, Some 0]
                               | a == (0b01, 0b10) then [Some 0, Some 0, Some 0]
                               | a == (0b01, 0b11) then [Some 0, Some 0, Some 0]
                               | a == (0b10, 0b00) then [Some 0, Some 1, Some 0]
                               | a == (0b10, 0b01) then [Some 0, Some 0, Some 1]
                               | a == (0b10, 0b10) then [Some 0, Some 0, Some 0]
                               | a == (0b10, 0b11) then [Some 0, Some 0, Some 0]
                               | a == (0b11, 0b00) then [Some 0, Some 1, Some 1]
                               | a == (0b11, 0b01) then [Some 0, Some 0, Some 1]
                               | a == (0b11, 0b10) then [Some 0, Some 0, Some 0]
                               | a == (0b11, 0b11) then [Some 0, Some 0, Some 0]
                              else repeat None

  spec_shift4 : {A: [1], B: [0]} -> {Y: [1](Option Bit)}
  spec_shift4 in = {Y = out}
                   where
                     out = spec (in.A, in.B)
                     spec a = if a == (0b0, zero) then [Some 0]
                               | a == (0b1, zero) then [Some 1]
                              else repeat None

  spec_shift6 : {A: [2], B: [2]} -> {Y: [3](Option Bit)}
  spec_shift6 in = {Y = out}
                   where
                     out = spec (in.A, in.B)
                     spec a = if a == (0b00, 0b00) then [Some 0, Some 0, Some 0]
                               | a == (0b00, 0b01) then [Some 0, Some 0, Some 0]
                               | a == (0b00, 0b10) then [Some 0, Some 0, Some 0]
                               | a == (0b00, 0b11) then [Some 0, Some 0, Some 0]
                               | a == (0b01, 0b00) then [Some 0, Some 0, Some 1]
                               | a == (0b01, 0b01) then [Some 0, Some 0, Some 0]
                               | a == (0b01, 0b10) then [Some 1, Some 0, Some 0]
                               | a == (0b01, 0b11) then [Some 0, Some 1, Some 0]
                               | a == (0b10, 0b00) then [Some 1, Some 1, Some 0]
                               | a == (0b10, 0b01) then [Some 0, Some 1, Some 1]
                               | a == (0b10, 0b10) then [Some 0, Some 0, Some 0]
                               | a == (0b10, 0b11) then [Some 1, Some 0, Some 0]
                               | a == (0b11, 0b00) then [Some 1, Some 1, Some 1]
                               | a == (0b11, 0b01) then [Some 0, Some 1, Some 1]
                               | a == (0b11, 0b10) then [Some 1, Some 0, Some 0]
                               | a == (0b11, 0b11) then [Some 1, Some 1, Some 0]
                              else repeat None

  spec_reduce_bool : {A: [0]} -> {Y: [3](Option Bit)}
  spec_reduce_bool in = {Y = out}
                        where
                          out = spec in.A
                          spec a = [Some 0, Some 0, Some 0]

  spec_not1 : {A: [1]} -> {Y: [3](Option Bit)}
  spec_not1 in = {Y = out}
                 where
                   out = spec in.A
                   spec a = if a == 0b0 then [Some 1, Some 1, Some 1]
                             | a == 0b1 then [Some 1, Some 1, Some 0]
                            else repeat None

  spec_reduce_xor1 : {A: [1]} -> {Y: [3](Option Bit)}
  spec_reduce_xor1 in = {Y = out}
                        where
                          out = spec in.A
                          spec a = if a == 0b0 then [Some 0, Some 0, Some 0]
                                    | a == 0b1 then [Some 0, Some 0, Some 1]
                                   else repeat None

  spec_reduce_bool2 : {A: [2]} -> {Y: [2](Option Bit)}
  spec_reduce_bool2 in = {Y = out}
                         where
                           out = spec in.A
                           spec a = if a == 0b00 then [Some 0, Some 0]
                                     | a == 0b01 then [Some 0, Some 1]
                                     | a == 0b10 then [Some 0, Some 1]
                                     | a == 0b11 then [Some 0, Some 1]
                                    else repeat None

  spec_not3 : {A: [3]} -> {Y: [1](Option Bit)}
  spec_not3 in = {Y = out}
                 where
                   out = spec in.A
                   spec a = if a == 0b000 then [Some 1]
                             | a == 0b001 then [Some 0]
                             | a == 0b010 then [Some 1]
                             | a == 0b011 then [Some 0]
                             | a == 0b100 then [Some 1]
                             | a == 0b101 then [Some 0]
                             | a == 0b110 then [Some 1]
                             | a == 0b111 then [Some 0]
                            else repeat None

  spec_reduce_xor3 : {A: [3]} -> {Y: [1](Option Bit)}
  spec_reduce_xor3 in = {Y = out}
                        where
                          out = spec in.A
                          spec a = if a == 0b000 then [Some 0]
                                    | a == 0b001 then [Some 1]
                                    | a == 0b010 then [Some 1]
                                    | a == 0b011 then [Some 0]
                                    | a == 0b100 then [Some 1]
                                    | a == 0b101 then [Some 0]
                                    | a == 0b110 then [Some 0]
                                    | a == 0b111 then [Some 1]
                                   else repeat None

  spec_reduce_bool4 : {A: [0]} -> {Y: [3](Option Bit)}
  spec_reduce_bool4 in = {Y = out}
                         where
                           out = spec in.A
                           spec a = [Some 0, Some 0, Some 0]

  spec_not5 : {A: [1]} -> {Y: [3](Option Bit)}
  spec_not5 in = {Y = out}
                 where
                   out = spec in.A
                   spec a = if a == 0b0 then [Some 1, Some 1, Some 1]
                             | a == 0b1 then [Some 0, Some 0, Some 0]
                            else repeat None

  spec_reduce_xor5 : {A: [1]} -> {Y: [3](Option Bit)}
  spec_reduce_xor5 in = {Y = out}
                        where
                          out = spec in.A
                          spec a = if a == 0b0 then [Some 0, Some 0, Some 0]
                                    | a == 0b1 then [Some 0, Some 0, Some 1]
                                   else repeat None

  spec_reduce_bool6 : {A: [2]} -> {Y: [2](Option Bit)}
  spec_reduce_bool6 in = {Y = out}
                         where
                           out = spec in.A
                           spec a = if a == 0b00 then [Some 0, Some 0]
                                     | a == 0b01 then [Some 0, Some 1]
                                     | a == 0b10 then [Some 0, Some 1]
                                     | a == 0b11 then [Some 0, Some 1]
                                    else repeat None

  spec_not7 : {A: [3]} -> {Y: [1](Option Bit)}
  spec_not7 in = {Y = out}
                 where
                   out = spec in.A
                   spec a = if a == 0b000 then [Some 1]
                             | a == 0b001 then [Some 0]
                             | a == 0b010 then [Some 1]
                             | a == 0b011 then [Some 0]
                             | a == 0b100 then [Some 1]
                             | a == 0b101 then [Some 0]
                             | a == 0b110 then [Some 1]
                             | a == 0b111 then [Some 0]
                            else repeat None

  spec_reduce_xor7 : {A: [3]} -> {Y: [1](Option Bit)}
  spec_reduce_xor7 in = {Y = out}
                        where
                          out = spec in.A
                          spec a = if a == 0b000 then [Some 0]
                                    | a == 0b001 then [Some 1]
                                    | a == 0b010 then [Some 1]
                                    | a == 0b011 then [Some 0]
                                    | a == 0b100 then [Some 1]
                                    | a == 0b101 then [Some 0]
                                    | a == 0b110 then [Some 0]
                                    | a == 0b111 then [Some 1]
                                   else repeat None

  spec_shr1 : {A: [1], B: [0]} -> {Y: [1](Option Bit)}
  spec_shr1 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b0, zero) then [Some 0]
                             | a == (0b1, zero) then [Some 1]
                            else repeat None

  spec_sshr2 : {A: [1], B: [1]} -> {Y: [1](Option Bit)}
  spec_sshr2 in = {Y = out}
                  where
                    out = spec (in.A, in.B)
                    spec a = if a == (0b0, 0b0) then [Some 0]
                              | a == (0b0, 0b1) then [Some 0]
                              | a == (0b1, 0b0) then [Some 1]
                              | a == (0b1, 0b1) then [Some 0]
                             else repeat None

  spec_shr4 : {A: [2], B: [1]} -> {Y: [2](Option Bit)}
  spec_shr4 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b00, 0b0) then [Some 0, Some 0]
                             | a == (0b00, 0b1) then [Some 0, Some 0]
                             | a == (0b01, 0b0) then [Some 0, Some 1]
                             | a == (0b01, 0b1) then [Some 0, Some 0]
                             | a == (0b10, 0b0) then [Some 1, Some 0]
                             | a == (0b10, 0b1) then [Some 0, Some 1]
                             | a == (0b11, 0b0) then [Some 1, Some 1]
                             | a == (0b11, 0b1) then [Some 0, Some 1]
                            else repeat None

  spec_sshr5 : {A: [2], B: [2]} -> {Y: [2](Option Bit)}
  spec_sshr5 in = {Y = out}
                  where
                    out = spec (in.A, in.B)
                    spec a = if a == (0b00, 0b00) then [Some 0, Some 0]
                              | a == (0b00, 0b01) then [Some 0, Some 0]
                              | a == (0b00, 0b10) then [Some 0, Some 0]
                              | a == (0b00, 0b11) then [Some 0, Some 0]
                              | a == (0b01, 0b00) then [Some 0, Some 1]
                              | a == (0b01, 0b01) then [Some 0, Some 0]
                              | a == (0b01, 0b10) then [Some 0, Some 0]
                              | a == (0b01, 0b11) then [Some 0, Some 0]
                              | a == (0b10, 0b00) then [Some 1, Some 0]
                              | a == (0b10, 0b01) then [Some 0, Some 1]
                              | a == (0b10, 0b10) then [Some 0, Some 0]
                              | a == (0b10, 0b11) then [Some 0, Some 0]
                              | a == (0b11, 0b00) then [Some 1, Some 1]
                              | a == (0b11, 0b01) then [Some 0, Some 1]
                              | a == (0b11, 0b10) then [Some 0, Some 0]
                              | a == (0b11, 0b11) then [Some 0, Some 0]
                             else repeat None

  spec_shr7 : {A: [1], B: [1]} -> {Y: [1](Option Bit)}
  spec_shr7 in = {Y = out}
                 where
                   out = spec (in.A, in.B)
                   spec a = if a == (0b0, 0b0) then [Some 0]
                             | a == (0b0, 0b1) then [Some 0]
                             | a == (0b1, 0b0) then [Some 1]
                             | a == (0b1, 0b1) then [Some 0]
                            else repeat None

  spec_sshr8 : {A: [1], B: [2]} -> {Y: [3](Option Bit)}
  spec_sshr8 in = {Y = out}
                  where
                    out = spec (in.A, in.B)
                    spec a = if a == (0b0, 0b00) then [Some 0, Some 0, Some 0]
                              | a == (0b0, 0b01) then [Some 0, Some 0, Some 0]
                              | a == (0b0, 0b10) then [Some 0, Some 0, Some 0]
                              | a == (0b0, 0b11) then [Some 0, Some 0, Some 0]
                              | a == (0b1, 0b00) then [Some 1, Some 1, Some 1]
                              | a == (0b1, 0b01) then [Some 1, Some 1, Some 1]
                              | a == (0b1, 0b10) then [Some 1, Some 1, Some 1]
                              | a == (0b1, 0b11) then [Some 1, Some 1, Some 1]
                             else repeat None

  spec_shiftx1 : {A: [0], B: [1]} -> {Y: [1](Option Bit)}
  spec_shiftx1 in = {Y = out}
                    where
                      out = spec (in.A, in.B)
                      spec a = if a == (zero, 0b0) then [None]
                                | a == (zero, 0b1) then [None]
                               else repeat None

  spec_shiftx7 : {A: [1], B: [0]} -> {Y: [1](Option Bit)}
  spec_shiftx7 in = {Y = out}
                    where
                      out = spec (in.A, in.B)
                      spec a = if a == (0b0, zero) then [Some 0]
                                | a == (0b1, zero) then [Some 1]
                               else repeat None

  spec_mux : {A: [0], B: [0], S: [1]} -> {Y: [0](Option Bit)}
  spec_mux in = {Y = out}
                where
                  out = spec (in.A, in.B, in.S)
                  spec a = if a == (zero, zero, 0b0) then []
                            | a == (zero, zero, 0b1) then []
                           else repeat None

  spec_mux2 : {A: [1], B: [1], S: [1]} -> {Y: [1](Option Bit)}
  spec_mux2 in = {Y = out}
                 where
                   out = spec (in.A, in.B, in.S)
                   spec a = if a == (0b0, 0b0, 0b0) then [Some 0]
                             | a == (0b0, 0b0, 0b1) then [Some 0]
                             | a == (0b0, 0b1, 0b0) then [Some 0]
                             | a == (0b0, 0b1, 0b1) then [Some 1]
                             | a == (0b1, 0b0, 0b0) then [Some 1]
                             | a == (0b1, 0b0, 0b1) then [Some 0]
                             | a == (0b1, 0b1, 0b0) then [Some 1]
                             | a == (0b1, 0b1, 0b1) then [Some 1]
                            else repeat None

}};
prove_print w4 {{ spec_and ===> m.and }};
prove_print w4 {{ spec_or ===> m.or }};
prove_print w4 {{ spec_ge ===> m.ge }};
prove_print w4 {{ spec_eq1 ===> m.eq1 }};
prove_print w4 {{ spec_sub1 ===> m.sub1 }};
prove_print w4 {{ spec_gt1 ===> m.gt1 }};
prove_print w4 {{ spec_eqx2 ===> m.eqx2 }};
prove_print w4 {{ spec_xnor2 ===> m.xnor2 }};
prove_print w4 {{ spec_le2 ===> m.le2 }};
prove_print w4 {{ spec_mul3 ===> m.mul3 }};
prove_print w4 {{ spec_xor3 ===> m.xor3 }};
prove_print w4 {{ spec_lt3 ===> m.lt3 }};
prove_print w4 {{ spec_ne4 ===> m.ne4 }};
prove_print w4 {{ spec_div4 ===> m.div4 }};
prove_print w4 {{ spec_add5 ===> m.add5 }};
prove_print w4 {{ spec_nex5 ===> m.nex5 }};
prove_print w4 {{ spec_mod5 ===> m.mod5 }};
prove_print w4 {{ spec_and6 ===> m.and6 }};
prove_print w4 {{ spec_or6 ===> m.or6 }};
prove_print w4 {{ spec_ge6 ===> m.ge6 }};
prove_print w4 {{ spec_shift ===> m.shift }};
prove_print w4 {{ spec_shift2 ===> m.shift2 }};
prove_print w4 {{ spec_shift4 ===> m.shift4 }};
prove_print w4 {{ spec_shift6 ===> m.shift6 }};
prove_print w4 {{ spec_reduce_bool ===> m.reduce_bool }};
prove_print w4 {{ spec_not1 ===> m.not1 }};
prove_print w4 {{ spec_reduce_xor1 ===> m.reduce_xor1 }};
prove_print w4 {{ spec_reduce_bool2 ===> m.reduce_bool2 }};
prove_print w4 {{ spec_not3 ===> m.not3 }};
prove_print w4 {{ spec_reduce_xor3 ===> m.reduce_xor3 }};
prove_print w4 {{ spec_reduce_bool4 ===> m.reduce_bool4 }};
prove_print w4 {{ spec_not5 ===> m.not5 }};
prove_print w4 {{ spec_reduce_xor5 ===> m.reduce_xor5 }};
prove_print w4 {{ spec_reduce_bool6 ===> m.reduce_bool6 }};
prove_print w4 {{ spec_not7 ===> m.not7 }};
prove_print w4 {{ spec_reduce_xor7 ===> m.reduce_xor7 }};
prove_print w4 {{ spec_shr1 ===> m.shr1 }};
prove_print w4 {{ spec_sshr2 ===> m.sshr2 }};
prove_print w4 {{ spec_shr4 ===> m.shr4 }};
prove_print w4 {{ spec_sshr5 ===> m.sshr5 }};
prove_print w4 {{ spec_shr7 ===> m.shr7 }};
prove_print w4 {{ spec_sshr8 ===> m.sshr8 }};
prove_print w4 {{ spec_shiftx1 ===> m.shiftx1 }};
prove_print w4 {{ spec_shiftx7 ===> m.shiftx7 }};
prove_print w4 {{ spec_mux ===> m.mux }};
prove_print w4 {{ spec_mux2 ===> m.mux2 }};