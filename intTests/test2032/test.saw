enable_experimental;

m <- mir_load_module "test.linked-mir.json";

// We now have the mir_vec_of command for creating Vec values, which is tested
// below, but we first test that we are able to construct a Vec using the
// mir_alloc_raw_ptr_const_multi and mir_points_to_multi primitives in the same
// way that mir_vec_of does internally. If this works but mir_vec_of fails then
// we can isolate where the problem is coming from.

let GlobalAlloc = mir_find_adt m "alloc::alloc::Global" [];
let Vec_i32 = mir_find_adt m "alloc::vec::Vec" [mir_i32, mir_adt GlobalAlloc];
let RawVec_i32 = mir_find_adt m "alloc::raw_vec::RawVec" [mir_i32, mir_adt GlobalAlloc];
let TypedAllocator_i32 = mir_find_adt m "crucible::alloc::TypedAllocator" [mir_i32];
let RawVecInner_i32 = mir_find_adt m "alloc::raw_vec::RawVecInner" [mir_adt TypedAllocator_i32];
let Unique_u8 = mir_find_adt m "core::ptr::unique::Unique" [mir_u8];
let NonNull_u8 = mir_find_adt m "core::ptr::non_null::NonNull" [mir_u8];
let PhantomData = mir_find_adt m "core::marker::PhantomData";
let PhantomData_u8 = PhantomData [mir_u8];
let PhantomData_i32 = PhantomData [mir_i32]; 
let UsizeNoHighBit = mir_find_adt m "core::num::niche_types::UsizeNoHighBit" [];

let mk_vec_i32 len contents = do {
    ptr <- mir_alloc_raw_ptr_const_multi len mir_i32;
    cap <- mir_fresh_var "cap" mir_usize;
    mir_assert {{ cap <= 0x7fff_ffff_ffff_ffff / (32 / 8) }};
    mir_assert {{ cap >= `len }};
    mir_points_to_multi ptr contents;
    return (mir_struct_value Vec_i32 [
        mir_struct_value RawVec_i32 [
            mir_struct_value RawVecInner_i32 [
                mir_struct_value Unique_u8 [
                    mir_struct_value NonNull_u8 [
                        mir_cast_raw_ptr ptr mir_u8
                    ],
                    mir_struct_value PhantomData_u8 []
                ],
                mir_struct_value UsizeNoHighBit [
                    mir_term cap
                ],
                mir_struct_value TypedAllocator_i32 [
                    mir_struct_value PhantomData_i32 []
                ]
            ],
            mir_struct_value GlobalAlloc [],
            mir_struct_value PhantomData_i32 []
        ],
        mir_term {{ `len : [64] }}
    ]);
};

let rev_i32_spec_manual len = do {
    contents <- mir_fresh_var "contents" (mir_array len mir_i32);
    in_vec <- mk_vec_i32 len (mir_term contents);
    mir_execute_func [in_vec];
    out_vec <- mk_vec_i32 len (mir_term {{ reverse contents }});
    mir_return out_vec;
};

rev_i32_ov_manual <- mir_verify m "test::rev_i32" [] false (rev_i32_spec_manual 10) z3;

let rev_rev_i32_spec_manual len = do {
    contents <- mir_fresh_var "contents" (mir_array len mir_i32);
    in_vec <- mk_vec_i32 len (mir_term contents);
    mir_execute_func [in_vec];
    out_vec <- mk_vec_i32 len (mir_term contents);
    mir_return out_vec;
};

mir_verify m "test::rev_rev_i32" [rev_i32_ov_manual] false (rev_rev_i32_spec_manual 10) z3;

// Test mir_vec_of.

let rev_spec_auto ty len = do {
    contents <- mir_fresh_var "contents" (mir_array len ty);
    in_vec <- mir_vec_of "in_vec" ty (mir_term contents);
    mir_execute_func [in_vec];
    out_vec <- mir_vec_of "out_vec" ty (mir_term {{ reverse contents }});
    mir_return out_vec;
};

let rev_rev_spec_auto ty len = do {
    contents <- mir_fresh_var "contents" (mir_array len ty);
    in_vec <- mir_vec_of "in_vec" ty (mir_term contents);
    mir_execute_func [in_vec];
    out_vec <- mir_vec_of "out_vec" ty (mir_term contents);
    mir_return out_vec;
};

rev_i32_ov_auto <- mir_verify m "test::rev_i32" [] false (rev_spec_auto mir_i32 10) z3;
mir_verify m "test::rev_rev_i32" [rev_i32_ov_auto] false (rev_rev_spec_auto mir_i32 10) z3;

rev_tuple_ov_auto <- mir_verify m "test::rev_tuple" [] false (rev_spec_auto (mir_tuple [mir_u8, mir_i64, mir_u128]) 10) z3;
mir_verify m "test::rev_rev_tuple" [rev_tuple_ov_auto] false (rev_rev_spec_auto (mir_tuple [mir_u8, mir_i64, mir_u128]) 10) z3;

// Uncomment this when Vec of ZST is supported in crucible (blocked by at least
// crucible#1497 and #1504).

// rev_unit_ov_auto <- mir_verify m "test::rev_unit" [] false (rev_spec_auto (mir_tuple []) 10) z3;
// mir_verify m "test::rev_rev_unit" [rev_unit_ov_auto] false (rev_rev_spec_auto (mir_tuple []) 10) z3;

// Test that empty Vecs work.

/*
This test is disabled for now while we work on improving the Vec API in #2666.

let empty_spec = do {
    mir_execute_func [];
    out_vec <- mir_vec_of "out_vec" mir_i32 (mir_array_value mir_i32 []);
    mir_return out_vec;
};

empty_ov <- mir_verify m "test::empty" [] false empty_spec z3;

let empty_len_spec = do {
    mir_execute_func [];
    mir_return (mir_term {{ 0 : [64] }});
};

mir_verify m "test::empty_len" [empty_ov] false empty_len_spec z3;
*/
