let sharing_idxs = [1,2,4];

let roundtrip' t = do {
  for sharing_idxs (\i -> do {
    set_min_sharing i;
    let s' = show_term t;
    print (str_concats ["Output: \n", s']);
    let t' = parse_core s';
    b <- is_convertible t t';
    if b then print "Terms are convertible\n" else
      fail "Terms are NOT convertible\n";
  });
};

let roundtrip s = do {
  print (str_concats ["Input: \n", s, "\n"]);
  let t = parse_core s;
  roundtrip' t;
};

let roundtrip_prelude s = do {
  let t = unfold_term [s] (parse_core s);
  set_min_sharing 2;
  print (str_concats ["Input: \n", show_term t, "\n"]);
  roundtrip' t;
};

roundtrip "let { x = Prop; y = (Eq Nat 1 1 : x); } in y";
roundtrip "let { x`1 = Prop; x`1 = let { x`1 = x`1; } in (Eq Nat 1 1 : x`1); } in (x`1 : Prop)";

// x`# identifiers are only valid for let-bindings
fails (do {
  let s = "\\(x`1 : Nat) -> (x`1, (x`1,Prop))";
  let t = parse_core s;
  print (str_concats ["Unexpected success parsing term: ", s]);
});

roundtrip "(x : Pos) -> Eq Pos (posInc (Bit1 x)) (Bit0 (posInc x))";
roundtrip "(x y : Pos) -> Eq Pos (posAdd (Bit1 x) (Bit1 y)) (Bit0 (posInc (posAdd x y)))";
roundtrip "(x y : Pos) -> Eq Pos (posMul x (Bit1 y)) (posAdd x (Bit0 (posMul x y)))";
roundtrip "(x y : Pos) -> (k : Bool) -> Eq Bool (posCmp (Bit1 x) (Bit1 y) k) (posCmp x y k)";
roundtrip "(x y : Pos) -> Eq Bool (posLe (Bit1 x) (Bit1 y)) (posLe x y)";
roundtrip "(x y : Pos) -> Eq Nat (addNat (NatPos x) (NatPos y)) (NatPos (posAdd x y))";
roundtrip "(x y : Pos) -> Eq Bool (equalNat (NatPos x) (NatPos y)) (posEq x y)";
roundtrip "(x y : Pos) -> Eq Bool (ltNat (NatPos x) (NatPos y)) (posLt x y)";
roundtrip "(x : Pos) -> Eq Nat (widthNat (NatPos (Bit1 x))) (Succ (widthNat (NatPos x)))";
roundtrip "(x y : Pos) -> Eq Z (posSub (Bit1 x) (Bit1 y)) (dblZ (posSub x y))";

roundtrip_prelude "inverse_eta_rule";
roundtrip_prelude "coerce__def_trans";
roundtrip_prelude "coerce_trans";
roundtrip_prelude "Nat_cases2";
