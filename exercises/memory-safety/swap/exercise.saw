///////////////////////////////////////////////////////////////////////////////
// Exercise: Swap Memory Safety
///////////////////////////////////////////////////////////////////////////////

// `include` in SAW works like #include in C: it inlines the contents of the
// included file.
include "../../common/helpers.saw";

///////////////////////////////////////////////////////////////////////////////
// Part 1: Swap Different Pointers Spec
///////////////////////////////////////////////////////////////////////////////

// Write a memory safety spec for `swap`.  Assume that the caller passes in two
// different pointers for both arguments.  Use `ptr_to_fresh` from
// `helpers.saw` in your specification.  Feel free to use both the `add` example
// and your `popcount` exercises as a guide!

///////////////////////////////////////////////////////////////////////////////
// Part 2: Swap Different Pointers Proofs
///////////////////////////////////////////////////////////////////////////////

// Use `llvm_verify` to prove that `swap` and `xor_swap` both satisfy your SAW
// spec. You will need to use separate invocations of `llvm_verify` for each
// proof.

///////////////////////////////////////////////////////////////////////////////
// Part 3: Swap Same Pointers Spec
///////////////////////////////////////////////////////////////////////////////

// Write a memory safety spec for `swap` like in part 1, but this time, assume
// that the caller passes in the same pointer for both arguments.

///////////////////////////////////////////////////////////////////////////////
// Part 4: Swap Same Pointers Proofs
///////////////////////////////////////////////////////////////////////////////

// Use `llvm_verify` to prove that `swap` satisfies the spec you wrote in part
// 3.

///////////////////////////////////////////////////////////////////////////////
// Part 5: Selection Sort Spec
///////////////////////////////////////////////////////////////////////////////

// Uncomment and fill in in the parameterized memory safety proof for selection sort below
// Remember:
// * Use `llvm_array <size> <element type>` to specify an array type
// * Use `{{ <cryptol> }}` to inline Cryptol
// * SAW function parameters are Cryptol type variables

/*
let selection_sort_spec size = do {

};
*/

///////////////////////////////////////////////////////////////////////////////
// Part 6: Selection Sort Proofs
///////////////////////////////////////////////////////////////////////////////

// Prove `selection_sort` satisfies `selection_sort_spec` for `size` values of
// 2, 3, and 8.


///////////////////////////////////////////////////////////////////////////////
// Part 7: Selection Sort Proof Composition
///////////////////////////////////////////////////////////////////////////////

// Modify your selection sort proof to use your `swap` proofs as overrides.
// How does this change SAW's output?


///////////////////////////////////////////////////////////////////////////////
// Part 8: Selection Sort Errors
///////////////////////////////////////////////////////////////////////////////

// Introduce a memory error into the selection_sort C implementation (for
// example, causing an out-of-bounds write) and rebuild `swap.bc`.  What
// happens now when you run your proof?  Can you fool SAW with a memory error
// it fails to detect?
