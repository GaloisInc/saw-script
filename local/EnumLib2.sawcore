module EnumLib2 where
import Prelude;

-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));

---- The various Sawcore Lists -------------------------------------
{-
REFERENCE:

ListSort__rec : (P : ListSort -> sort 1)  --
             -> P LS_Nil
             -> ((A:sort 0) -> (l:ListSort) -> P l -> P (LS_Cons A l))
             -> (l:ListSort)
             -> P l;

data List (a : sort 0) : sort 0
  where {
    Nil : List a;
    Cons : a -> List a -> List a;
  }

-- The type List1 itself
data List1 (a:sort 1) : sort 1 where {
  Nil1 : List1 a;
  Cons1 : a -> List1 a -> List1 a;
}

-- A list of types, i.e. `List (sort 0)` if `List` was universe polymorphic
data ListSort : sort 1
  where {
    LS_Nil : ListSort;
    LS_Cons : sort 0 -> ListSort -> ListSort;
}

-- The type of a list of functions to a particular output type a
data FunsTo (a:sort 0) : sort 1 where {
  FunsTo_Nil : FunsTo a;
  FunsTo_Cons : (tp:sort 0) -> (tp -> a) -> FunsTo a -> FunsTo a;
}

-- The type of a list of values
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

-}

xx : Nat = 1;

test1 : List1 Nat;
test1 = Cons1 Nat xx (Cons1 Nat xx (Nil1 Nat));

---- NTuples: useful?? ---------------------------------------------

-- A list of types and values.
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

ntup1 : NTuple = NTuple_Cons Bool True NTuple_Nil;
ntup2 : NTuple = NTuple_Cons Bool True (NTuple_Cons Bool True NTuple_Nil);

{-
-- The recursor for NTuple
NTuple__rec : (P : FunsTo a -> sort 1)
          -> P (FunsTo_Nil a) ->
              ((tp:sort 0) -> (f:tp -> a) -> (es:FunsTo a) ->
               P es -> P (FunsTo_Cons a tp f es)) ->
              (es:FunsTo a) -> P es;
NTuple__rec a P f1 f2 es = NTuple#rec a P f1 f2 es;


-- This very much like arrows, except you have no
Tuple :: ListSort -> sort 0
Tuple ls =

-- NTuple__rec : Bool;
-- NTuple__rec P f1 f2 es = NTuple#rec P f1 f2 es;

-}

{-
eithers2' : (ts: ListSort)  -- the 'as' are in the 'ts'
        -> (b: sort 0)
        -> arrowsSort (MapRightArrow b ts)
                      (Eithers' ts -> b);
eithers2' ts b = ListSort__rec ...

eithers3' : (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> List_Cases b ts
         -> Eithers' ts
         -> b
eithers3' ts b = ListSort__
-}

---- MapRightArrow -------------------------------------------------

MapRightArrow : (b : sort 0) -> ListSort -> ListSort;
MapRightArrow b =
  ListSort__rec
    (\ (_:ListSort) -> ListSort)
    LS_Nil
    (\ (tp:sort 0) (_:ListSort) (rec:ListSort) -> LS_Cons (tp->b) rec);

ls1 : ListSort;
ls1 = LS_Cons Bool (LS_Cons UnitType LS_Nil);

test : ListSort;
test = MapRightArrow Bool ls1;

---- thinking about eithers ----------------------------------------
{-
eithers' :  (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> ArrowsType (MapRightArrow b ts)
                       (Eithers' ts -> b);


eithers_EnumType : (as : sort 0)
                -> (b: sort 0)
                -> (CT1 as -> b) -> (CT2 as -> b)
                -> EnumType as
                -> b;
-}


-------------------------------------------------------------------
-- Translation
-------------------------------------------------------------------

---- Cryptol: ------------------------------------------------------
{-
- Cryptol
enum EnumType as = C1 CT1
                 | C2 CT2
                 -- 'as' can be free in CT1, CT2 types
-}

---- SawCore: ------------------------------------------------------
-- types:

-- NOTE all the 'base types' (elements of the sum) should all be parameterized by 'as':
EnumType__ArgType_C1 (as : sort 0) : sort 0 = as;
EnumType__ArgType_C2 (as : sort 0) : sort 0 = Bool;

EnumType__TypeList : sort 0 -> ListSort;
EnumType__TypeList as = LS_Cons (EnumType__ArgType_C1 as) (LS_Cons (EnumType__ArgType_C2 as) LS_Nil);

-- Define the type:
EnumType : (as : sort 0) -> sort 0;
EnumType as = Eithers' (EnumType__TypeList as);

-- constructors:
EnumType__C1 : (as : sort 0) -> EnumType__ArgType_C1 as -> EnumType as;
EnumType__C1 as x = Left (EnumType__ArgType_C1 as) (Eithers' (LS_Cons (EnumType__ArgType_C2 as) LS_Nil)) x;

EnumType__C2 : (as : sort 0) -> EnumType__ArgType_C2 as -> EnumType as;
EnumType__C2 as x = Right (EnumType__ArgType_C1 as) (Eithers' (LS_Cons (EnumType__ArgType_C2 as) LS_Nil))
                    (Left (EnumType__ArgType_C2 as) (Eithers' LS_Nil)
                      x);

EnumType_eithers : (as : sort 0)
                -> (b: sort 0)
                -> (EnumType__ArgType_C1 as -> b) -> (EnumType__ArgType_C2 as -> b)
                -> EnumType as
                -> b;
EnumType_eithers as b f1 f2 =
  either (EnumType__ArgType_C1 as) (Eithers' (LS_Cons (EnumType__ArgType_C2 as) LS_Nil)) b f1
    (either (EnumType__ArgType_C2 as) Void b f2
       (elimVoid b));

-- case for EnumType:
{-
EnumType_eithers  :  (b: sort 0)
               -> MapRightArrow b EnumType__TypeList
               -> Eithers EnumType__TypeList  -- AKA EnumType
               -> b;

EnumType_eithers = eithers' EnumType__TypeList
-}

---- examples of EnumType -----------------------------------------------------
val1 : EnumType  Nat;
val1 = EnumType__C1 Nat 5;

val2 : (as : sort 0) -> EnumType  as;
val2 as = EnumType__C2 as True;
