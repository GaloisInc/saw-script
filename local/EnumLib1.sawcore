module EnumLib1 where
import Prelude;

-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));


-- A ListSort with the first n (or all, if n > length) entries removed
--  - This is the original (buggy), reformatted:
listSortDrop' : ListSort -> Nat -> ListSort;
listSortDrop' = ListSort__rec
  (\ (_:ListSort) -> Nat -> ListSort)
  (\ (_:Nat) -> LS_Nil)
     -- Nil to Nil, what every the _:Nat is.
  (\ (_:sort 0) (Ds:ListSort)
                (rec : Nat -> ListSort) -- result on l, the smaller list
    ->
     Nat_cases ListSort
        Ds
        (\ (n:Nat) (_ : ListSort) -> rec n));

fold_ListSort : (a: sort 1) ->
                a ->
                (sort 0 -> (l:ListSort) -> a -> a) ->
                ListSort -> a;
fold_ListSort a base f ls =
  ListSort__rec (\(_:ListSort)-> a) base f ls;
  -- FIXME: need 1st argument of f?

length_ListSort : ListSort -> Nat;
length_ListSort = fold_ListSort Nat
                    0
                    (\(_:sort 0) (l:ListSort) (n:Nat)-> Succ n);

listSortDrop3 : ListSort -> Nat -> ListSort;
listSortDrop3 ss n =
  Nat__rec
    (\(_:Nat) -> ListSort -> ListSort)
    (\(l : ListSort) -> l)
    (\(n' : Nat) (rec_n' : ListSort -> ListSort) ->
      (\(l : ListSort)->
          rec_n' (fold_ListSort ListSort
                    LS_Nil
                    (\(_:sort 0) (l:ListSort) (tail:ListSort) -> tail)
                    l
                 )
      ))
    n
    ss;

-- Exploring/learning here
listSortSilly : ListSort -> Nat -> ListSort;
listSortSilly ss n =
  Nat__rec
    (\(_:Nat) -> ListSort -> ListSort)
    (\(l : ListSort) -> l)
    (\(n' : Nat) (rec_n' : ListSort -> ListSort) ->
       -- result here must be P(Succ n) == ListSort -> ListSort:
       (\(l : ListSort)-> LS_Cons UnitType (rec_n' l))
       {- \(l : ListSort)->
         ListSort__rec -- P=?
           (?) (?)
       -}
    )
    n
    ss;

test_s1 : ListSort = listSortSilly LS_Nil 5;


myTypes3 : ListSort;
myTypes3 = LS_Cons UnitType (LS_Cons UnitType (LS_Cons Bool LS_Nil));

myTypes2 : ListSort;
myTypes2 = listSortDrop myTypes3 (0 : Nat);
  -- TODO: error in `listSortDrop` or its documentation.

test1  : ListSort = myTypes2;
test1a : ListSort = listSortDrop3 myTypes3 0;
test1b : ListSort = listSortDrop3 myTypes3 1;
test1c : ListSort = listSortDrop3 myTypes3 3;
test1d : ListSort = listSortDrop3 myTypes3 5;
test1e : ListSort = listSortDrop3 LS_Nil 5;

testA : sort 0;
testA = listSortGet myTypes3 (1 : Nat); -- works as expected.

y3 : Eithers myTypes3;
y3 = Left UnitType (Eithers myTypes2) Unit;

{-
- alternatives
  A. see below: for code savings , split constructor and generic injN
  B. just forget the code savings and generate full code for each constructor!
    - TODO: look at this!

- designing constructors
enum TY <as> = C1 CT1
             | C2 CT2

MyC1 {as} v = inj1 {CT1} {{CT2}} v
                         ---------- this is the rest of translated type
MyC2 {as} v = inj2 {CT2} {{ Void }} v

  - can you setup with two lists: types before, r type, types after.

- designing injections
  A.
inj1 : {r,a}    r -> Either r a
inj2 : {r,a,b1} r -> Either b1 (Either r a)
inj3 : {...}    r -> Either b2 (Either b1 (Either r a))

inj1 : r ->   Eithers [r,a]
inj2 : r ->   Eithers [b1,r,a]
inj3 : r ->   Eithers [b2,b1,r,a]

case1 : FunsTo
case2 : FunsTo
-}

--------------------------------------------------------
-- old, ...
SumOf2 : (a1 a2       : sort 0) -> sort 0;
SumOf2 a1 a2 = Either a1 a2;

SumOf3 : (a1 a2 a3    : sort 0) -> sort 0;
SumOf3 a1 a2 a3 = Either a1 (SumOf2 a2 a3);

SumOf4 : (a1 a2 a3 a4 : sort 0) -> sort 0;
SumOf4 a1 a2 a3 a4 = Either a1 (SumOf3 a2 a3 a4);

inj1 : (a1 b : sort 0) -> a1 -> SumOf2 a1 b;
inj1 a1 b x = Left a1 b x;

inj2 : (a1 a2 b : sort 0) -> a2 -> SumOf3 a1 a2 b;
inj2 a1 a2 b x    = Right a1 (Either a2 b) (inj1 a2 b x);

inj3 : (a1 a2 a3 b : sort 0) -> a3 -> SumOf4 a1 a2 a3 b;
inj3 a1 a2 a3 b x = Right a1 (SumOf3 a2 a3 b) (inj2 a2 a3 b x);

case2 : (a b c : sort 0) -> (a -> c) -> (b -> c) -> Either a b -> c;
case2 = either;

-- case3
-- ...
-- TODO: figure how to do all this with SAWCore.Prelude Eithers and eithers
