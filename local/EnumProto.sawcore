module EnumProto where

import Prelude;

---- Import Eithers by Hand ----------------------------------------
-- import Eithers;  -- DOES NOT WORK!!, Thus


-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));


-- An eliminator for the Eithers' type
eithers' : (a:sort 0) -> (es:FunsTo a) -> Eithers' (FunsToIns a es) -> a;
eithers' a =
  FunsTo__rec
    a
    (\ (es: FunsTo a) -> Eithers' (FunsToIns a es) -> a) -- P
    (\ (v:Void) -> elimVoid a v)                         -- P(FunsToNil a)
    (\ (tp : sort 0)                                     -- type arg
       (f  : tp -> a)                                     --
       (es : FunsTo a)                                    --
       (rec: Eithers' (FunsToIns a es) -> a)              -- P es
    ->
       -- P (FunsTo_Cons a tp f es):
       either tp (Eithers' (FunsToIns a es)) a f rec
    );


-------------------------------------------------------------------
-- Prototyping the Translation
-------------------------------------------------------------------

---- Cryptol: ------------------------------------------------------
{-
- Cryptol
-- ETT = Enum Test Type
enum ETT as = C1 CT1
            | C2 CT2
            | C3 CT3a CT3b  -- not done yet!
             -- 'as' can be free in CT1, CT2, ... types
-}

---- SawCore: ------------------------------------------------------
-- types:

-- Just Like EnumLib3, but let's inline things:

-- NOTE all the 'base types' (elements of the sum) should all be parameterized by 'as':
ETT__ArgType_C1 (as : sort 0) : sort 0 = as;
ETT__ArgType_C2 (as : sort 0) : sort 0 = Bool;
ETT__ArgType_C3 (as : sort 0) : sort 0 = PairType UnitType as;

  -- NOTE: don't need to name these, just use the below.

ETT__LS : sort 0 -> ListSort;
ETT__LS as = LS_Cons (ETT__ArgType_C1 as)
             (LS_Cons (ETT__ArgType_C2 as)
               LS_Nil);

-- Define the type:
ETT : (as : sort 0) -> sort 0;
ETT as = Eithers' (ETT__LS as);

-- constructors (these aren't new, already in Cryptol, and AFAIK mapped into SawCore),
-- thus straightforward names.
C1 : (as : sort 0) -> ETT__ArgType_C1 as -> ETT as;
C1 as x = Left (ETT__ArgType_C1 as) (Eithers' (LS_Cons (ETT__ArgType_C2 as) LS_Nil)) x;

C2 : (as : sort 0) -> ETT__ArgType_C2 as -> ETT as;
C2 as x = Right (ETT__ArgType_C1 as) (Eithers' (LS_Cons (ETT__ArgType_C2 as) LS_Nil))
                    (Left (ETT__ArgType_C2 as) (Eithers' LS_Nil)
                      x);

-- implement per the below framework:
C1' : (as : sort 0) -> listSortGet (ETT__LS as) 0 -> ETT as;
C1' as x = Left (listSortGet (ETT__LS as) 0)
                (Eithers' (listSortDrop (ETT__LS as) 1))
                x;

{-
C0..C3:
C0 : (a b.. : sort0)->listSortGet (ETT_TL a b..) 0 -> EithersV (ETT_TL a b..)
C1 : (a b.. : sort0)->listSortGet (ETT_TL a b..) 1 -> EithersV (ETT_TL a b..)
C2 : (a b.. : sort0)->listSortGet (ETT_TL a b..) 2 -> EithersV (ETT_TL a b..)

C0 a b.. = L (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
C1 a b.. = R (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ L (listSortGet (ETT_TL a b..) 1) (EithersV (drop (ETT_TL a b..) 2))
C2 a b.. = R (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ R (listSortGet (ETT_TL a b..) 1) (EithersV (drop (ETT_TL a b..) 2))
         $ L (listSortGet (ETT_TL a b..) 2) (EithersV (drop (ETT_TL a b..) 3))
-}

-- For now (after all these TEMPESTS) just do the above ^.
--  later, see Eithers.sawcore for explorations re 'generic' injection.

ETT_eithers : (as : sort 0)
           -> (b: sort 0)
           -> (ETT__ArgType_C1 as -> b)
           -> (ETT__ArgType_C2 as -> b)
           -> ETT as
           -> b;
ETT_eithers as b f1 f2 =
  either (ETT__ArgType_C1 as) (Eithers' (LS_Cons (ETT__ArgType_C2 as) LS_Nil)) b f1
    (either (ETT__ArgType_C2 as) Void b f2
       (elimVoid b));


ETT_eithers2 : (as : sort 0)
            -> (b: sort 0)
            -> (ETT__ArgType_C1 as -> b)
            -> (ETT__ArgType_C2 as -> b)
            -> ETT as
            -> b;
ETT_eithers2 as b f1 f2 =
  eithers' b (FunsTo_Cons b (ETT__ArgType_C1 as) f1
             (FunsTo_Cons b (ETT__ArgType_C2 as) f2
             (FunsTo_Nil b)));


-- NOTE: See Eithers.sawcore for a discussion of other alternatives.



---- examples of ETT ------------------------------------------

val1 : ETT  Nat;
val1 = C1 Nat 5;

val2 : (as : sort 0) -> ETT  as;
val2 as = C2 as True;

fun : ETT Nat -> Bool;
fun = ETT_eithers2 Nat Bool
        (\(n : ETT__ArgType_C1 Nat) -> equal0Nat n)
        (\(b : ETT__ArgType_C2 Nat) -> b          );


---- test misc -----------------------------------------------------

test20 : sort 0 = listSortGet (ETT__LS Nat) 0;
test21 : sort 0 = listSortGet (ETT__LS Nat) 1;
test22 : sort 0 = listSortGet (ETT__LS Nat) 2;

test1 : sort 0 = test20;

---- tests ---------------------------------------------------------

test10  : ETT Nat = val1;
test11  : Bool    = fun val1;
test12  : Bool    = fun (C1 Nat      0);
test12' : Bool    = fun (C1' Nat      0);
test13  : Bool    = fun (C2 Nat  False);
test14  : Bool    = fun (C2 Nat  True);

-- test1  : Bool    = test14;
