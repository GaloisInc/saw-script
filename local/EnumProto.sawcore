module EnumProto where

import Prelude;

-------------------------------------------------------------------
-- Prototyping the Translation
-------------------------------------------------------------------

---- Cryptol: ------------------------------------------------------
{-
- Cryptol
enum ETT as = C1
            | C2 Nat
            | C3 Bool as
             -- 'as' can be free in CT1, CT2, ... types
  -- ETT = Enum Test Type
-}

---- ListSort combinators [TODO: move to Prelude] -----------------------------

listSort_FoldL : (b : sort 1) -> (b -> sort 0 -> b) -> b -> ListSort -> b;
listSort_FoldL b f init ls =
  ListSort__rec
    (\(_ls: ListSort) -> b->b)
    (\(x: b)-> x)
    (\(A: sort 0) (_: ListSort) (g: b->b) ->
       \(acc: b)-> g (f acc A)  -- <- has type b->b
    )
    ls
    init;

listSort_Reverse : ListSort -> ListSort;
listSort_Reverse = listSort_FoldL
                     ListSort
                     (\(ls: ListSort) (A:sort 0)-> LS_Cons A ls)
                     (LS_Nil);

---- Pairs... [TODO: Move to Prelude] ------------------------------

TupleR : ListSort -> sort 0;
TupleR = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (tp * rec));

TupleL : ListSort -> sort 0;
TupleL = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (rec * tp));

  -- TupleL [t1,t2,t3] == ((((UnitType),t3),t2),t1)

pairsLeftFold: ListSort -> sort 0;
pairsLeftFold ls = TupleL (listSort_Reverse ls);

  -- TupleLeftFold [t1,t2,t3] == (((UnitType,t1),t2),t3)

---- SawCore: Type Definitions -------------------------------------

-- The products in each of the constructors:
ETT__ArgType_C1_LS (as : sort 0) : ListSort = LS_Nil;
ETT__ArgType_C2_LS (as : sort 0) : ListSort = LS_Cons Nat LS_Nil;
ETT__ArgType_C3_LS (as : sort 0) : ListSort = LS_Cons Bool (LS_Cons as LS_Nil);

  -- ^ don't put into environment, we'll do in the code generation.

-- NOTE all the 'base types' (elements of the sum) should all be parameterized by 'as':
ETT__ArgType_C1 (as : sort 0) : sort 0 = TupleR (ETT__ArgType_C1_LS as);
ETT__ArgType_C2 (as : sort 0) : sort 0 = TupleR (ETT__ArgType_C2_LS as);
ETT__ArgType_C3 (as : sort 0) : sort 0 = TupleR (ETT__ArgType_C3_LS as);
  -- NOTE: don't need to name these, just use the below.

ETT__LS : sort 0 -> ListSort;
ETT__LS as = LS_Cons    (ETT__ArgType_C1 as)
              (LS_Cons  (ETT__ArgType_C2 as)
               (LS_Cons (ETT__ArgType_C3 as)
                 LS_Nil));

-- Define the type:
ETT : (as : sort 0) -> sort 0;
ETT as = EithersV (ETT__LS as);


---- SawCore: Constructors -----------------------------------------

-- constructors (these aren't new, already in Cryptol, and AFAIK mapped into SawCore),
-- thus straightforward names.

{-
C0..C3:
C0 : (a b.. : sort0)->(CURRIED[listSortGet (ETT_TL a b..) 0]) -> EithersV (ETT_TL a b..)
C1 : (a b.. : sort0)->(CURRIED[listSortGet (ETT_TL a b..) 1]) -> EithersV (ETT_TL a b..)
C2 : (a b.. : sort0)->(CURRIED[listSortGet (ETT_TL a b..) 2]) -> EithersV (ETT_TL a b..)

C0 a b.. = \x1 x2..->
           L (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ C[x1,x2,...]
C1 a b.. = \y1 y2..->
           R (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ L (listSortGet (ETT_TL a b..) 1) (EithersV (drop (ETT_TL a b..) 2))
         $ C[y1,y2,...]

C2 a b.. = \z1 z2..->
           R (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ R (listSortGet (ETT_TL a b..) 1) (EithersV (drop (ETT_TL a b..) 2))
         $ L (listSortGet (ETT_TL a b..) 2) (EithersV (drop (ETT_TL a b..) 3))
         $ C[z1,z2,...]
-}


-- implement per the above framework:
C1 : (as : sort 0) -> listSortGet (ETT__LS as) 0 -> ETT as;
C1 as x = Left (listSortGet (ETT__LS as) 0) (EithersV (listSortDrop (ETT__LS as) 1))
               x;

C2 : (as : sort 0) -> listSortGet (ETT__LS as) 1 -> ETT as;
C2 as x =
  Right (listSortGet (ETT__LS as) 0) (EithersV (listSortDrop (ETT__LS as) 1))
  (Left (listSortGet (ETT__LS as) 1) (EithersV (listSortDrop (ETT__LS as) 2))
   x);

C3 : (as : sort 0) -> listSortGet (ETT__LS as) 2 -> ETT as;
C3 as x =
 Right   (listSortGet (ETT__LS as) 0) (EithersV (listSortDrop (ETT__LS as) 1))
  (Right (listSortGet (ETT__LS as) 1) (EithersV (listSortDrop (ETT__LS as) 2))
   (Left (listSortGet (ETT__LS as) 2) (EithersV (listSortDrop (ETT__LS as) 3))
   x));


---- SawCore: case/eithers function --------------------------------

ETT_eithers  : (as : sort 0)
            -> (b: sort 0)
            -> (ETT__ArgType_C1 as -> b)
            -> (ETT__ArgType_C2 as -> b)
            -> (ETT__ArgType_C3 as -> b)
            -> ETT as
            -> b;
ETT_eithers as b f1 f2 f3 =
  eithersV b (FunsTo_Cons b (ETT__ArgType_C1 as) f1
             (FunsTo_Cons b (ETT__ArgType_C2 as) f2
             (FunsTo_Cons b (ETT__ArgType_C3 as) f3
             (FunsTo_Nil b))));


---- Examples ------------------------------------------------------

val1 : ETT  Nat;
val1 = C1 Nat Unit;

val2 : (as : sort 0) -> ETT as;
val2 as = C2 as (1,Unit);

val3 : ETT Nat = C3 Nat (True,(2,Unit));

fun : ETT Nat -> Bool;
fun = ETT_eithers Nat Bool
        (\(_ : ETT__ArgType_C1 Nat) -> True)
        (\(x : ETT__ArgType_C2 Nat) -> equal0Nat (x.1))
        (\(x : ETT__ArgType_C3 Nat) -> x.1);


---- Now, curried eithers/case: ------------------------------------

ETT_case1 :  (as : sort 0)
          -> (b: sort 0)
          -> (arrowsType (ETT__ArgType_C1_LS as) b)
          -> (arrowsType (ETT__ArgType_C2_LS as) b)
          -> (arrowsType (ETT__ArgType_C3_LS as) b)
          -> ETT as
          -> b;
ETT_case1 as b f1 f2 f3 =
  ETT_eithers as b
    (\(x: ETT__ArgType_C1 as) -> f1)
    (\(x: ETT__ArgType_C2 as) -> f2 (x.1))
    (\(x: ETT__ArgType_C3 as) -> f3 x.1 x.2);

-- or inlining ETT_eithers:

ETT_case2 : (as : sort 0)
         -> (b: sort 0)
         -> (arrowsType (ETT__ArgType_C1_LS as) b)
         -> (arrowsType (ETT__ArgType_C2_LS as) b)
         -> (arrowsType (ETT__ArgType_C3_LS as) b)
         -> ETT as
         -> b;

ETT_case2 as b f1 f2 f3 =
  eithersV b
    (FunsTo_Cons b (ETT__ArgType_C1 as) (\(x: ETT__ArgType_C1 as) -> f1)
    (FunsTo_Cons b (ETT__ArgType_C2 as) (\(x: ETT__ArgType_C2 as) -> f2 x.1)
    (FunsTo_Cons b (ETT__ArgType_C3 as) (\(x: ETT__ArgType_C3 as) -> f3 x.1 x.2)
    (FunsTo_Nil b))));

---- tests ---------------------------------------------------------

test00 : sort 0 = listSortGet (ETT__LS Nat) 0;
test01 : sort 0 = listSortGet (ETT__LS Nat) 1;
test02 : sort 0 = listSortGet (ETT__LS Nat) 2;

test10  : ETT Nat = val1;
test11  : ETT Nat = val2 Nat;
test12  : ETT Nat = val3;

test13  : Bool    = fun val1;
test14  : Bool    = fun (C1 Nat Unit);
test15  : Bool    = fun (C2 Nat (2,Unit));
test16  : Bool    = fun (val2 Nat);
test17  : Bool    = fun val3;

---- more: sawscript from command line -----------------------------

{-
SAWSCRIPT:

enable_experimental;
load_sawcore_from_file "local/EnumProto.sawcore";

return (normalize_term (parse_core_mod "EnumProto" "TypeOfUnCurryLS (Vec 0 Bool) (ETT__ArgeType_C3_LS Nat)"))
sawscript> return (type (parse_core_mod "Pairs" "listSort_FoldL"))
return (normalize_term (parse_core_mod "EnumProto" "ETT Nat"))
return (normalize_term (parse_core_mod "EnumProto" "typeC3"))

return (type (parse_core_mod "EnumProto" "ETT_case"))


return (normalize_term (type (parse_core_mod "EnumProto" "ETT_case")))
  -- NOTE: can't do.

-}
