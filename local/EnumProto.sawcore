module EnumProto where

import Prelude;

-------------------------------------------------------------------
-- Prototyping the Translation
-------------------------------------------------------------------

---- Cryptol: ------------------------------------------------------
{-
- Cryptol
-- ETT = Enum Test Type
enum ETT as = C1 CT1
            | C2 CT2
            | C3 CT3a CT3b  -- not done yet!
             -- 'as' can be free in CT1, CT2, ... types
-}

---- SawCore: Type Definitions -------------------------------------

-- Just Like EnumLib3, but let's inline things:

-- NOTE all the 'base types' (elements of the sum) should all be parameterized by 'as':
ETT__ArgType_C1 (as : sort 0) : sort 0 = as;
ETT__ArgType_C2 (as : sort 0) : sort 0 = Bool;
ETT__ArgType_C3 (as : sort 0) : sort 0 = PairType UnitType as;

  -- NOTE: don't need to name these, just use the below.

ETT__LS : sort 0 -> ListSort;
ETT__LS as = LS_Cons (ETT__ArgType_C1 as)
             (LS_Cons (ETT__ArgType_C2 as)
             (LS_Cons (ETT__ArgType_C3 as)
               LS_Nil));

-- Define the type:
ETT : (as : sort 0) -> sort 0;
ETT as = EithersV (ETT__LS as);

---- For Later, type-level lists we'll use for the case/eithers: ---
-- we don't put into environment, we'll do in the code generation:

ETT_C1_LS : (as: sort 0) -> ListSort;
ETT_C1_LS as = LS_Nil;

ETT_C2_LS : (as: sort 0) -> ListSort;
ETT_C2_LS as = LS_Cons Bool LS_Nil;

ETT_C3_LS : (as: sort 0) -> ListSort;
ETT_C3_LS as = LS_Cons UnitType (LS_Cons as LS_Nil);


---- SawCore: Constructors -----------------------------------------

-- constructors (these aren't new, already in Cryptol, and AFAIK mapped into SawCore),
-- thus straightforward names.

{-
C0..C3:
C0 : (a b.. : sort0)->(CURRIED[listSortGet (ETT_TL a b..) 0]) -> EithersV (ETT_TL a b..)
C1 : (a b.. : sort0)->(CURRIED[listSortGet (ETT_TL a b..) 1]) -> EithersV (ETT_TL a b..)
C2 : (a b.. : sort0)->(CURRIED[listSortGet (ETT_TL a b..) 2]) -> EithersV (ETT_TL a b..)

C0 a b.. = \x1 x2..->
           L (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ C[x1,x2,...]
C1 a b.. = \y1 y2..->
           R (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ L (listSortGet (ETT_TL a b..) 1) (EithersV (drop (ETT_TL a b..) 2))
         $ C[y1,y2,...]

C2 a b.. = \z1 z2..->
           R (listSortGet (ETT_TL a b..) 0) (EithersV (drop (ETT_TL a b..) 1))
         $ R (listSortGet (ETT_TL a b..) 1) (EithersV (drop (ETT_TL a b..) 2))
         $ L (listSortGet (ETT_TL a b..) 2) (EithersV (drop (ETT_TL a b..) 3))
         $ C[z1,z2,...]
-}


-- implement per the above framework:
C1 : (as : sort 0) -> listSortGet (ETT__LS as) 0 -> ETT as;
C1 as x = Left (listSortGet (ETT__LS as) 0) (EithersV (listSortDrop (ETT__LS as) 1))
               x;

-- C1c : (as : sort 0) -> listSortGet (ETT__LS as) 0 -> ETT as;
-- C1c as x = Left (listSortGet (ETT__LS as) 0)
--                (EithersV (listSortDrop (ETT__LS as) 1))
--                x;
--   -- TODO: make curried!

C2 : (as : sort 0) -> listSortGet (ETT__LS as) 1 -> ETT as;
C2 as x =
  Right (listSortGet (ETT__LS as) 0) (EithersV (listSortDrop (ETT__LS as) 1))
  (Left (listSortGet (ETT__LS as) 1) (EithersV (listSortDrop (ETT__LS as) 2))
   x);

C3 : (as : sort 0) -> listSortGet (ETT__LS as) 2 -> ETT as;
C3 as x =
 Right   (listSortGet (ETT__LS as) 0) (EithersV (listSortDrop (ETT__LS as) 1))
  (Right (listSortGet (ETT__LS as) 1) (EithersV (listSortDrop (ETT__LS as) 2))
   (Left (listSortGet (ETT__LS as) 2) (EithersV (listSortDrop (ETT__LS as) 3))
   x));


---- ListSort combinators [TODO: move to Prelude] -----------------------------

listSort_FoldL : (b : sort 1) -> (b -> sort 0 -> b) -> b -> ListSort -> b;
listSort_FoldL b f init ls =
  ListSort__rec
    (\(_ls: ListSort) -> b->b)
    (\(x: b)-> x)
    (\(A: sort 0) (_: ListSort) (g: b->b) ->
       \(acc: b)-> g (f acc A)  -- <- has type b->b
    )
    ls
    init;

listSort_Reverse : ListSort -> ListSort;
listSort_Reverse = listSort_FoldL
                     ListSort
                     (\(ls: ListSort) (A:sort 0)-> LS_Cons A ls)
                     (LS_Nil);

---- Pairs... [TODO: Move to Prelude] ------------------------------

PairsR : ListSort -> sort 0;
PairsR = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType tp rec));

PairsL : ListSort -> sort 0;
PairsL = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType rec tp));

  -- PairsL [t1,t2,t3] == ((((UnitType),t3),t2),t1)

pairsLeftFold: ListSort -> sort 0;
pairsLeftFold ls = PairsL (listSort_Reverse ls);

  -- PairsLeftFold [t1,t2,t3] == ((((UnitType),t1),t2),t3)

---- SawCore: case/eithers function --------------------------------

ETT_eithers  : (as : sort 0)
            -> (b: sort 0)
            -> (ETT__ArgType_C1 as -> b)
            -> (ETT__ArgType_C2 as -> b)
            -> (ETT__ArgType_C3 as -> b)
            -> ETT as
            -> b;
ETT_eithers as b f1 f2 f3 =
  eithersV b (FunsTo_Cons b (ETT__ArgType_C1 as) f1
             (FunsTo_Cons b (ETT__ArgType_C2 as) f2
             (FunsTo_Cons b (ETT__ArgType_C3 as) f3
             (FunsTo_Nil b))));


---- examples of ETT ------------------------------------------

fun : ETT Nat -> Bool;
fun = ETT_eithers Nat Bool
        (\(n : ETT__ArgType_C1 Nat) -> equal0Nat n)
        (\(b : ETT__ArgType_C2 Nat) -> b          )
        (\(n : ETT__ArgType_C3 Nat) -> True       );


val1 : ETT  Nat;
val1 = C1 Nat 5;

val2 : (as : sort 0) -> ETT as;
val2 as = C2 as True;

val3 : ETT Nat = C3 Nat (PairValue UnitType Nat   Unit 1);


---- tests ---------------------------------------------------------

test00 : sort 0 = listSortGet (ETT__LS Nat) 0;
test01 : sort 0 = listSortGet (ETT__LS Nat) 1;
test02 : sort 0 = listSortGet (ETT__LS Nat) 2;

test10  : ETT Nat = val1;
test11  : ETT Nat = val2 Nat;
test12  : ETT Nat = val3;

test13  : Bool    = fun val1;
test14  : Bool    = fun (C1 Nat      0);
test15  : Bool    = fun (C2 Nat  False);
test16  : Bool    = fun (val2 Nat);
test17  : Bool    = fun val3;

---- more: sawscript from command line -----------------------------

{-

return (normalize_term (parse_core_mod "EnumProto" "TypeOfUnCurryLS (ETT__LS Nat) (Vec 0 Bool)"))

-}

---- Now, curried eithers/case: ------------------------------------

TypeOfUnCurryLS : ListSort -> sort 0 -> sort 1;
TypeOfUnCurryLS ls b = arrowsType ls b -> pairsLeftFold ls -> b;
