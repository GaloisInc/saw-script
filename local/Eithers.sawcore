module Eithers where

import Prelude;

-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));

---- The various Sawcore Lists -------------------------------------
{-
REFERENCE:

ListSort__rec : (P : ListSort -> sort 1)  --
             -> P LS_Nil
             -> ((A:sort 0) -> (l:ListSort) -> P l -> P (LS_Cons A l))
             -> (l:ListSort)
             -> P l;

data List (a : sort 0) : sort 0
  where {
    Nil : List a;
    Cons : a -> List a -> List a;
  }

-- The type List1 itself
data List1 (a:sort 1) : sort 1 where {
  Nil1 : List1 a;
  Cons1 : a -> List1 a -> List1 a;
}

-- A list of types, i.e. `List (sort 0)` if `List` was universe polymorphic
data ListSort : sort 1
  where {
    LS_Nil : ListSort;
    LS_Cons : sort 0 -> ListSort -> ListSort;
}

-- The type of a list of functions to a particular output type a
data FunsTo (a:sort 0) : sort 1 where {
  FunsTo_Nil : FunsTo a;
  FunsTo_Cons : (tp:sort 0) -> (tp -> a) -> FunsTo a -> FunsTo a;
}

-- The type of a list of values
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

-}

---- NTuples: useful?? ---------------------------------------------

-- A list of types and values.
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

ntup1 : NTuple = NTuple_Cons Bool True NTuple_Nil;
ntup2 : NTuple = NTuple_Cons Bool True (NTuple_Cons Bool True NTuple_Nil);

{-
-- The recursor for NTuple
NTuple__rec : (P : FunsTo a -> sort 1)
          -> P (FunsTo_Nil a) ->
              ((tp:sort 0) -> (f:tp -> a) -> (es:FunsTo a) ->
               P es -> P (FunsTo_Cons a tp f es)) ->
              (es:FunsTo a) -> P es;
NTuple__rec a P f1 f2 es = NTuple#rec a P f1 f2 es;


-- This very much like arrows, except you have no
Tuple :: ListSort -> sort 0
Tuple ls =

-- NTuple__rec : Bool;
-- NTuple__rec P f1 f2 es = NTuple#rec P f1 f2 es;

-}

---- MapRightArrow -------------------------------------------------

MapRightArrow : (b : sort 0) -> ListSort -> ListSort;
MapRightArrow b =
  ListSort__rec
    (\ (_:ListSort) -> ListSort)
    LS_Nil
    (\ (tp:sort 0) (_:ListSort) (rec:ListSort) -> LS_Cons (tp->b) rec);

ls1 : ListSort;
ls1 = LS_Cons Bool (LS_Cons UnitType LS_Nil);

test : ListSort;
test = MapRightArrow Bool ls1;

---- Misc ----------------------------------------------------------

test1 : ListSort = test;

---- thinking about eithers ----------------------------------------

{-
eithers2' : (ts: ListSort)  -- the 'as' are in the 'ts'
        -> (b: sort 0)
        -> arrowsSort (MapRightArrow b ts)
                      (Eithers' ts -> b);
eithers2' ts b = ListSort__rec ...

eithers3' : (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> List_Cases b ts
         -> Eithers' ts
         -> b
eithers3' ts b = ListSort__
-}

{-
eithers' :  (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> ArrowsType (MapRightArrow b ts)
                       (Eithers' ts -> b);


eithers_EnumType : (as : sort 0)
                -> (b: sort 0)
                -> (CT1 as -> b) -> (CT2 as -> b)
                -> EnumType as
                -> b;
-}

--   BTW, re sawcore precedence
--             name: b -> c
--     EQUIV   name: (b -> c)
--   - nice to do spacing according to precedence, so don't do THIS
--       nm:b -> c

-- TODO: Bite the bullet, follow Prelude.sawcore and use FunsToIns. Here:

-- An eliminator for the Eithers' type
eithers' : (a:sort 0) -> (es:FunsTo a) -> Eithers' (FunsToIns a es) -> a;
eithers' a =
  FunsTo__rec
    a
    (\ (es: FunsTo a) -> Eithers' (FunsToIns a es) -> a) -- P
    (\ (v:Void) -> elimVoid a v)                         -- P(FunsToNil a)
    (\ (tp : sort 0)                                     -- type arg
       (f  : tp -> a)                                     --
       (es : FunsTo a)                                    --
       (rec: Eithers' (FunsToIns a es) -> a)              -- P es
    ->
       -- P (FunsTo_Cons a tp f es):
       either tp (Eithers' (FunsToIns a es)) a f rec
    );


{-

FunsTo__rec :
     (a:sort 0)
  -> (P : FunsTo a -> sort 1)
  -> P (FunsTo_Nil a)
  -> ((tp:sort 0)
      -> (f:tp -> a)
      -> (es:FunsTo a)
      -> P es
      -> P (FunsTo_Cons a tp f es))
  -> (es:FunsTo a)
  -> P es;


eithers : (a:sort 0) -> (es:FunsTo a) -> Eithers (FunsToIns a es) -> a;
eithers a =
  FunsTo__rec
    a
    (\ (es:FunsTo a) -> Eithers (FunsToIns a es) -> a)
    (\ (contra:FalseProp) -> efq a contra)
    (\ (tp:sort 0)
       (f:tp -> a)
       (es:   FunsTo a)
       (rec:  Eithers (FunsToIns a es) -> a)
       (eiths: Eithers (LS_Cons tp (FunsToIns a es)))
       ->
       eithers1 tp (FunsToIns a es) a eiths f rec);
-}
