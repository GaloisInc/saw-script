module Eithers where

import Prelude;

-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));

---- The various Sawcore Lists -------------------------------------
{-
REFERENCE:

ListSort__rec : (P : ListSort -> sort 1)  --
             -> P LS_Nil
             -> ((A:sort 0) -> (l:ListSort) -> P l -> P (LS_Cons A l))
             -> (l:ListSort)
             -> P l;

-- Term level lists:
data List (a : sort 0) : sort 0
  where {
    Nil : List a;
    Cons : a -> List a -> List a;
  }

-- The type List1 itself [!?]
-- Type level lists, a 'kind' ... HELP!

data List1 (a:sort 1) : sort 1 where {
  Nil1 : List1 a;
  Cons1 : a -> List1 a -> List1 a;
}

-- A list of types, i.e. `List (sort 0)` if `List` was universe polymorphic
data ListSort : sort 1
  where {
    LS_Nil : ListSort;
    LS_Cons : sort 0 -> ListSort -> ListSort;
}

-- "The type of a list of functions to a particular output type a" [ugh]
--  - contains types AND contains the functions.

data FunsTo (a:sort 0) : sort 1 where {
  FunsTo_Nil : FunsTo a;
  FunsTo_Cons : (tp:sort 0) -> (tp -> a) -> FunsTo a -> FunsTo a;
}

-- The type of a list of values
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

-}

-- TODO: understand List1.

test1  : List1 (Nat->Nat) = Nil1 (Nat->Nat);
test1b : List1 (ListSort) = Nil1 (ListSort);  -- !
-- test1c : List1 (a : sort 0) = Nil1 a;  -- !

---- NTuples: useful?? ---------------------------------------------

-- A list of types and values.
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

ntup1 : NTuple = NTuple_Cons Bool True NTuple_Nil;
ntup2 : NTuple = NTuple_Cons Bool True (NTuple_Cons Bool True NTuple_Nil);

{-
-- The recursor for NTuple
NTuple__rec : (P : FunsTo a -> sort 1)
          -> P (FunsTo_Nil a) ->
              ((tp:sort 0) -> (f:tp -> a) -> (es:FunsTo a) ->
               P es -> P (FunsTo_Cons a tp f es)) ->
              (es:FunsTo a) -> P es;
NTuple__rec a P f1 f2 es = NTuple#rec a P f1 f2 es;


-- This very much like arrows, except you have no
Tuple :: ListSort -> sort 0
Tuple ls =

-- NTuple__rec : Bool;
-- NTuple__rec P f1 f2 es = NTuple#rec P f1 f2 es;

-}

---- MapRightArrow -------------------------------------------------

MapRightArrow : (b : sort 0) -> ListSort -> ListSort;
MapRightArrow b =
  ListSort__rec
    (\ (_:ListSort) -> ListSort)
    LS_Nil
    (\ (tp:sort 0) (_:ListSort) (rec:ListSort) -> LS_Cons (tp->b) rec);

ls1 : ListSort;
ls1 = LS_Cons Bool (LS_Cons UnitType LS_Nil);

test : ListSort;
test = MapRightArrow Bool ls1;

---- Misc ----------------------------------------------------------

test2 : ListSort = test;

---- thinking about eithers ----------------------------------------

{-
eithers2' : (ts: ListSort)  -- the 'as' are in the 'ts'
        -> (b: sort 0)
        -> arrowsSort (MapRightArrow b ts)
                      (Eithers' ts -> b);
eithers2' ts b = ListSort__rec ...

eithers3' : (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> List_Cases b ts
         -> Eithers' ts
         -> b
eithers3' ts b = ListSort__
-}

{-
eithers' :  (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> ArrowsType (MapRightArrow b ts)
                       (Eithers' ts -> b);


eithers_EnumType : (as : sort 0)
                -> (b: sort 0)
                -> (CT1 as -> b) -> (CT2 as -> b)
                -> EnumType as
                -> b;
-}

--   BTW, re sawcore precedence
--             name: b -> c
--     EQUIV   name: (b -> c)
--   - nice to do spacing according to precedence, so don't do THIS
--       nm:b -> c

{-
 TODO: Bite the bullet, follow Prelude.sawcore and use FunsToIns. Here:
   - Just feels like poor staging!
      - FunsTo has both types and functions!
      - In the definition, FunsTo always used with FunsToIns [dropping functions]
   - Because you cannot do this:
      enumTypeA_LS = ...
      enumTypeA    = Eithers' enumTypeA_LS
      caseTypeA =
         eithers' enumTypeA_LS
          :: (a:sort 0) -> (MapRightArrow a enumTypeA_LS) -> Eithers' enumTypeA_LS -> a;
-}

-- An eliminator for the Eithers' type
eithers' : (a:sort 0) -> (es:FunsTo a) -> Eithers' (FunsToIns a es) -> a;
eithers' a =
  FunsTo__rec
    a
    (\ (es: FunsTo a) -> Eithers' (FunsToIns a es) -> a) -- P
    (\ (v:Void) -> elimVoid a v)                         -- P(FunsToNil a)
    (\ (tp : sort 0)                                     -- type arg
       (f  : tp -> a)                                     --
       (es : FunsTo a)                                    --
       (rec: Eithers' (FunsToIns a es) -> a)              -- P es
    ->
       -- P (FunsTo_Cons a tp f es):
       either tp (Eithers' (FunsToIns a es)) a f rec
    );

{-
 TODO: the following is wrong, it should actually be

  eithersLS : (a:sort 0) -> (ts:ListSort)
             -> Pairs (MapRightArrow a ts)
             ->  Eithers' ts -> a;

eithersLS : (a:sort 0) -> (ts:ListSort) -> Eithers' (MapRightArrow a ts) -> a;
eithersLS a =
  ListSort__rec
    (\ (ts: ListSort) -> Eithers' (MapRightArrow a ts) -> a) -- P
    (\ (v:Void) -> elimVoid a v)                         -- P(FunsToNil a)
    (\ (tp  : sort 0)                                    -- type arg
       (ts : ListSort)                                   -- base/inductive 'ts'
       (rec: Eithers' (MapRightArrow a ts) -> a)         -- P ts
    ->
       -- P (LS_Cons tp ts):
       either tp (Eithers' (MapRightArrow a ts)) a f rec
    );
-}

{-
myFunsTo (a: sort 0) -> FunsTo a;
myFunsTo = FunsTo_Cons  Bool ?
            (FunsTo_Cons  UnitType   (\(_:Bool)     -> (0x02 : MyResTy))
              (FunsTo_Nil a)
            );
-}

-- my3Types = LS_Cons Bool (LS_Cons UnitType (LS_Cons Bool LS_Nil));

my3Types : ListSort;
my3Types = LS_Cons Bool (LS_Cons UnitType (LS_Cons Bool LS_Nil));


MySum : sort 0 = Eithers' my3Types;

-- TODO
-- test2 = eithers' Bool
