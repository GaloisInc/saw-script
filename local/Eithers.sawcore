module Eithers where

import Prelude;

-- A right-nested sequence of Either types, defined as
--   Eithers' [] = Void
--   Eithers' (tp:tps) = Either tp (Eithers' tps)
Eithers' : ListSort -> sort 0;
Eithers' = ListSort__rec
            (\ (_:ListSort) -> sort 0)
            Void
            (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (Either tp rec));

-- An eliminator for the Eithers' type
eithers' : (a:sort 0) -> (es:FunsTo a) -> Eithers' (FunsToIns a es) -> a;
eithers' a =
  FunsTo__rec
    a
    (\ (es: FunsTo a) -> Eithers' (FunsToIns a es) -> a) -- P
    (\ (v:Void) -> elimVoid a v)                         -- P(FunsToNil a)
    (\ (tp : sort 0)                                     -- type arg
       (f  : tp -> a)                                     --
       (es : FunsTo a)                                    --
       (rec: Eithers' (FunsToIns a es) -> a)              -- P es
    ->
       -- P (FunsTo_Cons a tp f es):
       either tp (Eithers' (FunsToIns a es)) a f rec
    );

---- a generic injection -------------------------------------------
-- TODO: is this the right design?
--   - listSortGet must reflect that __
--   - refer to EnumProto.sawcore

{-
inj : (ts: ListSort) -> (n: Nat) -> listSortGet ts n -> Eithers' ts;
inj =
  ListSort__rec
    (\ (ts:ListSort) -> (n: Nat) -> listSortGet ts n -> Eithers' ts)
    (\ (_: Nat) (_: sort 0) -> FalseProp)            -- LS_Nil: fails
    (\ (A:sort 0) (ts:ListSort) (rec : (n: Nat) -> listSortGet ts n -> Eithers' ts) ->
      -- A is not input type, it's just the new HEAD of 'ts'
      -- expect type:
      --   P (LS_Cons A ts) ==
      --     (n:Nat) -> ListSortGet (LS_Cons A ts) -> Eithers' (LS_Cons A ts)
      Nat__rec
        -- P:
        (\(n:Nat)-> listSortGet ts n -> Eithers' (LS_Cons A ts))

        -- P Zero ==
        --    listSortGet ts Zero -> Eithers (LS_Cons A ts)
        (\(a: A)-> Left A (Eithers' ts) a) -- in this case A == codomain.

        -- ((n:Nat) -> P n -> P (Succ n)) =
        --    (n:Nat) ->
        --    (listSortGet ts n -> Eithers' (LS_Cons A ts)) ->
        --    (listSortGet ts (Succ n) -> Eithers' (LS_Cons A ts)))

        (\(n : Nat) ->
           -- P n ==
           --   listSortGet ts n -> Eithers' (LS_Cons A ts))

        -- expect type:
        --  Nat -> (sort 0 -> Eithers' (LS_Cons A ts))
        --      -> (sort 0 -> Eithers' (LS_Cons A ts))
        -- (\ (n: Nat) (_: A -> Eithers' (LS_Cons A ts))->

        -- HMMM: have two 'n's in scope now.

        (\ (n: Nat) (_: sort 0)->
         \ (a': listSortGet ts n)-> Right A (Eithers' ts) (rec n a'))
    );

------------------------------------------

- if you split the injection into two??
  - comparably: splitting TL into two parts

  Part 1: create the 'i : 0..' nested rights
   i=2
    injRs :: (ts: SortList) -> (a: sort 0) -> a -> Eithers' (ts ++ [a])
    injRs x = R T1 (Eithers(drop 1 TL))
            $ R T2 (Eithers(drop 2 TL))
              x

      -- the above is wrong
        -- using ListSort__rec you can create a base case, i.e., write SNOC!
        -- or ...

    injRs [t1,t2] a :: a -> t1+(t2+a)

  Part 2: inject at top, this just Left
    injL : a -> b -> Either a b
    injL A B = L

inj' : (ts: SortList) -> (A : sort 0) -> (r: sort 0)
     -> A -> Eithers (ts ++ [A `Either` r])
inj' ts A r a = injRs ts (injL A r a)

-----------

Have you gained much by using inj' ?
  - do we have erasure and thus no duplication of code?

C0 :: TL.0 -> Eithers TL
C1 :: TL.1 -> Eithers TL
C2 :: TL.2 -> Eithers TL
C0 = inj' (take 0 TS) TL.0 (Eithers (drop 1 TS))
C1 = inj' (take 1 TS) TL.1 (Eithers (drop 2 TS))
C2 = inj' (take 2 TS) TL.2 (Eithers (drop 3 TS))
-}


---- REFERENCE: CODE/TYPES ------------------------------------------
{-
Nat_cases : (a:sort 1) -> a -> (Nat -> a -> a) -> Nat -> a;

-- The sort at the given index in a ListSort or `Eq Bool True False` if
--  the index is out of bounds
listSortGet : ListSort -> Nat -> sort 0;
listSortGet = ListSort__rec (\ (_:ListSort) -> Nat -> sort 0)
  (\ (_:Nat) -> Eq Bool True False)
  (\ (A:sort 0) (_:ListSort) (rec : Nat -> sort 0) ->
     Nat_cases (sort 0) A (\ (n:Nat) (_:sort 0) -> rec n));


-}

---- REFERENCE: Various Sawcore Lists -------------------------------------
{-
ListSort__rec : (P : ListSort -> sort 1)  --
             -> P LS_Nil
             -> ((A:sort 0) -> (l:ListSort) -> P l -> P (LS_Cons A l))
             -> (l:ListSort)
             -> P l;

-- Term level lists:
data List (a : sort 0) : sort 0
  where {
    Nil : List a;
    Cons : a -> List a -> List a;
  }

-- The type List1 itself [!?]
-- Type level lists, a 'kind' ... HELP!

data List1 (a:sort 1) : sort 1 where {
  Nil1 : List1 a;
  Cons1 : a -> List1 a -> List1 a;
}

-- A list of types, i.e. `List (sort 0)` if `List` was universe polymorphic
data ListSort : sort 1
  where {
    LS_Nil : ListSort;
    LS_Cons : sort 0 -> ListSort -> ListSort;
}

-- "The type of a list of functions to a particular output type a" [ugh]
--  - contains types AND contains the functions.

data FunsTo (a:sort 0) : sort 1 where {
  FunsTo_Nil : FunsTo a;
  FunsTo_Cons : (tp:sort 0) -> (tp -> a) -> FunsTo a -> FunsTo a;
}

-- The type of a list of values
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

-}

-- see Exploring.sawcore for understanding List1


---- NTuples: useful?? ---------------------------------------------

-- A list of types and values.
data NTuple : sort 1 where {
  NTuple_Nil : NTuple;
  NTuple_Cons : (tp:sort 0) -> tp -> NTuple -> NTuple;
}

ntup1 : NTuple = NTuple_Cons Bool True NTuple_Nil;
ntup2 : NTuple = NTuple_Cons Bool True (NTuple_Cons Bool True NTuple_Nil);

{-
-- The recursor for NTuple
NTuple__rec : (P : FunsTo a -> sort 1)
          -> P (FunsTo_Nil a) ->
              ((tp:sort 0) -> (f:tp -> a) -> (es:FunsTo a) ->
               P es -> P (FunsTo_Cons a tp f es)) ->
              (es:FunsTo a) -> P es;
NTuple__rec a P f1 f2 es = NTuple#rec a P f1 f2 es;


-- This very much like arrows, except you have no
Tuple :: ListSort -> sort 0
Tuple ls =

-- NTuple__rec : Bool;
-- NTuple__rec P f1 f2 es = NTuple#rec P f1 f2 es;

-}

---- MapRightArrow -------------------------------------------------

MapRightArrow : (b : sort 0) -> ListSort -> ListSort;
MapRightArrow b =
  ListSort__rec
    (\ (_:ListSort) -> ListSort)
    LS_Nil
    (\ (tp:sort 0) (_:ListSort) (rec:ListSort) -> LS_Cons (tp->b) rec);

ls1 : ListSort;
ls1 = LS_Cons Bool (LS_Cons UnitType LS_Nil);

test : ListSort;
test = MapRightArrow Bool ls1;

---- thinking about eithers (n-ary case) ---------------------------

{-
eithers2' : (ts: ListSort)  -- the 'as' are in the 'ts'
        -> (b: sort 0)
        -> arrowsSort (MapRightArrow b ts)
                      (Eithers' ts -> b);
eithers2' ts b = ListSort__rec ...

eithers3' : (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> List_Cases b ts
         -> Eithers' ts
         -> b
eithers3' ts b = ListSort__
-}

{-
eithers' :  (ts: ListSort)  -- the 'as' are in the 'ts'
         -> (b: sort 0)
         -> ArrowsType (MapRightArrow b ts)
                       (Eithers' ts -> b);


eithers_EnumType : (as : sort 0)
                -> (b: sort 0)
                -> (CT1 as -> b) -> (CT2 as -> b)
                -> EnumType as
                -> b;
-}

--   BTW, re sawcore precedence
--             name: b -> c
--     EQUIV   name: (b -> c)
--   - nice to do spacing according to precedence, so don't do THIS
--       nm:b -> c

{-
 TODO: Bite the bullet, follow Prelude.sawcore and use FunsToIns. Here:
   - Just feels like poor staging!
      - FunsTo has both types and functions!
      - In the definition, FunsTo always used with FunsToIns [dropping functions]
   - Because you cannot do this:
      enumTypeA_LS = ...
      enumTypeA    = Eithers' enumTypeA_LS
      caseTypeA =
         eithers' enumTypeA_LS
          :: (a:sort 0) -> (MapRightArrow a enumTypeA_LS) -> Eithers' enumTypeA_LS -> a;
-}

{-
 TODO: the following is wrong, it should actually be

  eithersLS : (a:sort 0) -> (ts:ListSort)
             -> Pairs (MapRightArrow a ts)
             ->  Eithers' ts -> a;

eithersLS : (a:sort 0) -> (ts:ListSort) -> Eithers' (MapRightArrow a ts) -> a;
eithersLS a =
  ListSort__rec
    (\ (ts: ListSort) -> Eithers' (MapRightArrow a ts) -> a) -- P
    (\ (v:Void) -> elimVoid a v)                         -- P(FunsToNil a)
    (\ (tp  : sort 0)                                    -- type arg
       (ts : ListSort)                                   -- base/inductive 'ts'
       (rec: Eithers' (MapRightArrow a ts) -> a)         -- P ts
    ->
       -- P (LS_Cons tp ts):
       either tp (Eithers' (MapRightArrow a ts)) a f rec
    );
-}

{-
myFunsTo (a: sort 0) -> FunsTo a;
myFunsTo = FunsTo_Cons  Bool ?
            (FunsTo_Cons  UnitType   (\(_:Bool)     -> (0x02 : MyResTy))
              (FunsTo_Nil a)
            );
-}

-- my3Types = LS_Cons Bool (LS_Cons UnitType (LS_Cons Bool LS_Nil));

my3Types : ListSort;
my3Types = LS_Cons Bool (LS_Cons UnitType (LS_Cons Bool LS_Nil));


MySum : sort 0 = Eithers' my3Types;

test1 : sort 0 = MySum;

-- TODO
-- test2 = eithers' Bool
