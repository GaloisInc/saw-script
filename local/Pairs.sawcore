module Pairs where

import Prelude;

PairsR : ListSort -> sort 0;
PairsR = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType tp rec));

PairsL : ListSort -> sort 0;
PairsL = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType rec tp));


ls1 : ListSort;
ls1 = LS_Cons (Vec 1 Bool) (LS_Cons (Vec 2 Bool) LS_Nil);

{-
i.e., arrowsType:
  MyCurry : ListSort -> sort 0 -> sort 0
  MyCurry []     a = a
  MyCurry (t:ts) b = t -> MyCurry ts b)
-}

{-
UnCurryN1 : (ls: ListSort) -> (b: sort 0) -> arrowsType ls b -> PairsL ls -> b;
UnCurryN1 ls b f =
  ListSort__rec
       (\(ls:ListSort) -> PairsL ls -> b)          -- P
       (\(_:UnitType)-> f)                         -- P(LS_Nil)
       (\ (tp:sort 0) (ls:ListSort) (rec: arrowsType ls b) ->
            uncurry tp (PairsL ls) b rec
       )
  f;

  -- ^ HIGHLY FLAWED.

UnCurryN2 : (b: sort 0) -> (ls: ListSort) -> arrowsType ls b -> PairsL ls -> b;
UnCurryN2 b =
  ListSort__rec
       (\(ls:ListSort) -> arrowsType ls b -> PairsL ls -> b)          -- P
       (\(x:b) (_:UnitType)-> x)                                      -- P(LS_Nil)
       (\ (A:   sort 0)
          (ls:  ListSort)
          (rec: arrowsType ls b -> PairsL ls -> b)
          -- P(LS_Cons A ls) ==
          --    arrowsType (LS_Cons A ls) b -> PairsL (LS_Cons A ls) -> b;
         -> \(f: arrowsType (LS_Cons A ls) b) -> uncurry (PairsL ls) A b (rec f)
       );

   -- ^ NO, each induction step must instantiate 'b' differently!

-}

UnCurryN : (ls: ListSort) -> (b: sort 0) -> arrowsType ls b -> PairsL ls -> b;
UnCurryN =
  ListSort__rec
       (\(ls:ListSort) -> (b: sort 0) -> arrowsType ls b -> PairsL ls -> b) -- P
       (\(b: sort 0) (x: b) (_y: UnitType) -> x)                          -- P(LS_Nil)
       (\ (A:   sort 0)
          (ls:  ListSort)
          (rec: (b: sort 0) -> arrowsType ls b -> PairsL ls -> b)
          -- the following must be of type
          --     P(LS_Cons A ls)
          --  == (b: sort 0) -> arrowsType (LS_Cons A ls) b -> PairsL (LS_Cons A ls) -> b;
         -> \(b: sort 0)->
            \(f: arrowsType ls (A->b))->
            uncurry (PairsL ls) A b (rec (A->b) f)
       );


-- inferred for `f`
--   A -> arrowsType ls b
-- expected for `f`
--   arrowsType ls (A -> B)

testa : arrowsType ls1 Bool -> PairsL ls1 -> Bool;
testa = UnCurryN ls1 Bool;


{-

uncurry b []         :: b               -> U -> b
uncurry b [a1]       :: (a1 -> b)       -> (U,a1) -> b

uncurry b [a1,a2]    :: (a1->a2->b)     -> ((U,a1),a2)->b

uncurry b [a1,a2,a3] :: (a1->a2->a3->b) -> (((U,a1),a2),a3)->b

                         s/b/a3->b/

b^a1      ===  b^(1*a1)
(b^a2)^a1 ===  b^(1*a1*a2)

transforming:
  (b^a2)^a1 ===  b^(1*a1*a2)

  ((b'^a3)^a2)^a1  === (b'^a3)^(1*a1*a2)
                   ==  b'^(1*a1*a2*a3)

create rather
  uncurryN (n:Nat) (a1 ... an : sort 0) = ...

uncurry b [] = ?

:t uc . uc . uc . uc . (\x () -> x)
  :: (a1 -> a3 -> a4 -> a5 -> b) -> (a5, (a4, (a3, (a1, ())))) -> b



unc0 b = \(U)-> b
unc1 f = \((U,a1)-> f a1
unc2 f = \((U,a1),a2)-> f a1 a2

----------
?
-}


testbR : sort 0 = PairsR ls1;
testbL : sort 0 = PairsL ls1;
testbA : sort 0 = arrowsType ls1 Nat;

test1 : sort 0 = testbR;
test2 : sort 0 = testbL;
test3 : sort 0 = testbA;
