module Pairs where

import Prelude;

PairsR : ListSort -> sort 0;
PairsR = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType tp rec));

PairsL : ListSort -> sort 0;
PairsL = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType rec tp));

---- ListSort combinators [to Prelude] -----------------------------

listSort_FoldL : (b : sort 1) -> (b -> sort 0 -> b) -> b -> ListSort -> b;
listSort_FoldL b f init ls =
  ListSort__rec
    (\(_ls: ListSort) -> b->b)
    (\(x: b)-> x)
    (\(A: sort 0) (l: ListSort) (g: b->b) ->
       \(acc: b)-> g (f acc A)  -- <- has type b->b
    )
    ls
    init;

listSort_Reverse : ListSort -> ListSort;
listSort_Reverse = listSort_FoldL
                     ListSort
                     (\(ls: ListSort) (A:sort 0)-> LS_Cons A ls)
                     (LS_Nil);

---- Testing -------------------------------------------------------
ls1 : ListSort;
ls1 = LS_Cons (Vec 1 Bool) (LS_Cons (Vec 2 Bool) LS_Nil);

{-
i.e., arrowsType:
  MyCurry : ListSort -> sort 0 -> sort 0
  MyCurry []     a = a
  MyCurry (t:ts) b = t -> MyCurry ts b)
-}

{-
UnCurryN1 : (ls: ListSort) -> (b: sort 0) -> arrowsType ls b -> PairsL ls -> b;
UnCurryN1 ls b f =
  ListSort__rec
       (\(ls:ListSort) -> PairsL ls -> b)          -- P
       (\(_:UnitType)-> f)                         -- P(LS_Nil)
       (\ (tp:sort 0) (ls:ListSort) (rec: arrowsType ls b) ->
            uncurry tp (PairsL ls) b rec
       )
  f;

  -- ^ HIGHLY FLAWED.

UnCurryN2 : (b: sort 0) -> (ls: ListSort) -> arrowsType ls b -> PairsL ls -> b;
UnCurryN2 b =
  ListSort__rec
       (\(ls:ListSort) -> arrowsType ls b -> PairsL ls -> b)          -- P
       (\(x:b) (_:UnitType)-> x)                                      -- P(LS_Nil)
       (\ (A:   sort 0)
          (ls:  ListSort)
          (rec: arrowsType ls b -> PairsL ls -> b)
          -- P(LS_Cons A ls) ==
          --    arrowsType (LS_Cons A ls) b -> PairsL (LS_Cons A ls) -> b;
         -> \(f: arrowsType (LS_Cons A ls) b) -> uncurry (PairsL ls) A b (rec f)
       );

   -- ^ NO, each induction step must instantiate 'b' differently!

-}

{-
listSort_FoldL : (a b : sort 1) -> (b -> a -> b) -> b -> ListSort -> b;
listSort_FoldL a b f init ls =
  listSort_cases
    b
    ls
    (\(a: sort 0) (l:ListSort) a ->  )
  (\(x : b)-> x)
  ls
  init
-}

{-
-- A ListSort with the first n (or all, if n > length) entries removed
listSortReverse : ListSort -> ListSort;
listSortReverse ss =
  Nat__rec
    (\(_:Nat) -> ListSort -> ListSort)
    (\(l : ListSort) -> l)
    (\(_ : Nat) (rec_n' : ListSort -> ListSort) ->
       (\(l : ListSort)->
          rec_n' (listSort_cases ListSort
                    LS_Nil
                    (\(_:sort 0) (tail:ListSort) (_:ListSort) -> tail)
                    l
                 )
      ))
    n
    ss;
-}

{-
DEAD CODE:
arrowsTypeL : ListSort -> sort 0 -> sort 0;
arrowsTypeL as b =
  ListSort__rec (\ (_:ListSort) -> sort 0)
    b
    (\ (a:sort 0) (_:ListSort) (rec:sort 0) -> rec -> a )
    as;
-}
{-
UnCurryN : (ls: ListSort) -> (b: sort 0) -> arrowsType ls b -> PairsL ls -> b;
UnCurryN =
  ListSort__rec
       (\(ls:ListSort) -> (b: sort 0) -> arrowsType ls b -> PairsL ls -> b) -- P
       (\(b: sort 0) (x: b) (_y: UnitType) -> x)                          -- P(LS_Nil)
       (\ (A:   sort 0)
          (ls:  ListSort)
          (rec: (b: sort 0) -> arrowsType ls b -> PairsL ls -> b)
          -- the following must be of type
          --     P(LS_Cons A ls)
          --  == (b: sort 0) -> arrowsType (LS_Cons A ls) b -> PairsL (LS_Cons A ls) -> b;
         -> \(b: sort 0)->
            \(f: arrowsType (LS_Cons A ls))->
            uncurry (PairsL ls) A b (rec (A->b) f)
       );


-- inferred for `f`
--   A -> arrowsType ls b
-- expected for `f`
--   arrowsType ls (A -> B)

testa : arrowsType ls1 Bool -> PairsL ls1 -> Bool;
testa = UnCurryN ls1 Bool;
-}

{-

REF:
  arrowsTypeL [T1,T2] b  ==  (b->T1)->T2
  arrowsTypeR [T1,T2] b  ==  T1->(T2->b)

uncurry b []         :: b               -> U -> b
uncurry b [a1]       :: (a1 -> b)       -> (U,a1) -> b

uncurry b [a1,a2]    :: (a1->a2->b)     -> ((U,a1),a2)->b

uncurry b [a1,a2,a3] :: (a1->a2->a3->b) -> (((U,a1),a2),a3)->b

                         s/b/a3->b/

b^a1      ===  b^(1*a1)
(b^a2)^a1 ===  b^(1*a1*a2)

transforming:
  (b^a2)^a1 ===  b^(1*a1*a2)

  ((b'^a3)^a2)^a1  === (b'^a3)^(1*a1*a2)
                   ==  b'^(1*a1*a2*a3)

create rather
  uncurryN (n:Nat) (a1 ... an : sort 0) = ...

uncurry b [] = ?

:t uc . uc . uc . uc . (\x () -> x)
  :: (a1 -> a3 -> a4 -> a5 -> b) -> (a5, (a4, (a3, (a1, ())))) -> b



unc0 b = \(U)-> b
unc1 f = \((U,a1)-> f a1
unc2 f = \((U,a1),a2)-> f a1 a2

----------
?
-}


testbR : sort 0 = PairsR ls1;
testbL : sort 0 = PairsL ls1;
testbA : sort 0 = arrowsType ls1 Nat;

test1 : sort 0 = testbR;
test2 : sort 0 = testbL;
test3 : sort 0 = testbA;


---- latest:

test4 : Nat      = listSort_FoldL Nat (\(x:Nat) (_:sort 0)-> Succ x) 0 ls1;

test5 : ListSort = listSort_Reverse ls1;

test6 : ListSort = ls1;
