module Pairs where

import Prelude;

---- ListSort combinators [to Prelude] -----------------------------

listSort_FoldL : (b : sort 1) -> (b -> sort 0 -> b) -> b -> ListSort -> b;
listSort_FoldL b f init ls =
  ListSort__rec
    (\(_ls: ListSort) -> b->b)
    (\(x: b)-> x)
    (\(A: sort 0) (_: ListSort) (g: b->b) ->
       \(acc: b)-> g (f acc A)  -- <- has type b->b
    )
    ls
    init;

listSort_Reverse : ListSort -> ListSort;
listSort_Reverse = listSort_FoldL
                     ListSort
                     (\(ls: ListSort) (A:sort 0)-> LS_Cons A ls)
                     (LS_Nil);

---- Pairs... ------------------------------------------------------

PairsR : ListSort -> sort 0;
PairsR = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType tp rec));

PairsL : ListSort -> sort 0;
PairsL = ListSort__rec
          (\ (_:ListSort) -> sort 0)
          UnitType
          (\ (tp:sort 0) (_:ListSort) (rec:sort 0) ->
               (PairType rec tp));

  -- PairsL [t1,t2,t3] == ((((UnitType),t3),t2),t1)

PairsLeftFold: ListSort -> sort 0;
PairsLeftFold ls = PairsL (listSort_Reverse ls);

  -- PairsLeftFold [t1,t2,t3] == ((((UnitType),t1),t2),t3)

---- Testing -------------------------------------------------------

ls1 : ListSort;
ls1 = LS_Cons (Vec 1 Bool) (LS_Cons (Vec 2 Bool) LS_Nil);

{-
i.e., arrowsType:
  MyCurry : ListSort -> sort 0 -> sort 0
  MyCurry []     a = a
  MyCurry (t:ts) b = t -> MyCurry ts b)
-}

UnCurryN : (ls: ListSort) -> (b: sort 0)
        -> arrowsType ls b -> PairsLeftFold ls -> b;
UnCurryN =
  ListSort__rec
       -- P:
       (\(ls:ListSort) -> (b: sort 0)
         -> arrowsType ls b -> PairsLeftFold ls -> b)
       -- P(LS_Nil):
       (\(b: sort 0) (x: b) (_y: UnitType) -> x)

       -- ((A:sort 0) -> (l:ListSort) -> P ls -> P (LS_Cons A ls)):
       (\ (A:   sort 0)
          (ls:  ListSort)
          (rec: (b: sort 0) -> arrowsType ls b -> PairsLeftFold ls -> b)
          -- the following must be of type
          --     P(LS_Cons A ls)
          --  == (b: sort 0) ->
          --     arrowsType (LS_Cons A ls) b ->
          --     PairsLeftFold (LS_Cons A ls) -> b;
         -> \(b: sort 0)->
            \(f: arrowsType ls (A->b)) ->
               uncurry (PairsLeftFold ls) A b (rec (A->b) f)
       );


testa : arrowsType ls1 Bool -> PairsLeftFold ls1 -> Bool;
testa = UnCurryN ls1 Bool;

{-
REF:
  arrowsTypeL [T1,T2] b  ==  (b->T1)->T2
  arrowsTypeR [T1,T2] b  ==  T1->(T2->b)

uncurry b []         :: b               -> U -> b
uncurry b [a1]       :: (a1 -> b)       -> (U,a1) -> b

uncurry b [a1,a2]    :: (a1->a2->b)     -> ((U,a1),a2)->b

uncurry b [a1,a2,a3] :: (a1->a2->a3->b) -> (((U,a1),a2),a3)->b

                         s/b/a3->b/

b^a1      ===  b^(1*a1)
(b^a2)^a1 ===  b^(1*a1*a2)

transforming:
  (b^a2)^a1 ===  b^(1*a1*a2)

  ((b'^a3)^a2)^a1  === (b'^a3)^(1*a1*a2)
                   ==  b'^(1*a1*a2*a3)

create rather
  uncurryN (n:Nat) (a1 ... an : sort 0) = ...

uncurry b [] = ?

:t uc . uc . uc . uc . (\x () -> x)
  :: (a1 -> a3 -> a4 -> a5 -> b) -> (a5, (a4, (a3, (a1, ())))) -> b



unc0 b = \(U)-> b
unc1 f = \((U,a1)-> f a1
unc2 f = \((U,a1),a2)-> f a1 a2

----------
?
-}


testbR : sort 0 = PairsR ls1;
testbL : sort 0 = PairsL ls1;
testbA : sort 0 = arrowsType ls1 Nat;

test1 : sort 0 = testbR;
test2 : sort 0 = testbL;
test3 : sort 0 = testbA;


---- latest:

test4 : Nat      = listSort_FoldL Nat (\(x:Nat) (_:sort 0)-> Succ x) 0 ls1;

test5 : ListSort = listSort_Reverse ls1;

test6 : ListSort = ls1;
