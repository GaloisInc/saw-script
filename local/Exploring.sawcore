module Exploring where
import Prelude;

data Either2 (s t : sort 0) : sort 0 where {
    Left2  : s -> Either2 s t;
    Right2 : t -> Either2 s t;
  }

-- x : Bool
-- x = ?

{-
Testing:

data ListSortX : sort 0
  where {
    LSX_Nil  : ListSortX;
    LSX_Cons : sort 0 -> ListSortX -> ListSortX;
  }

Result:
Malformed declaration for "ListSortX"
Universe level of constructors should be strictly contained in that of the datatype
-}

xx : Nat = 1;

test1 : List1 Nat;
test1 = Cons1 Nat xx (Cons1 Nat xx (Nil1 Nat));

test2 : Void -> Nat -> Bool = elimVoid (Nat -> Bool);

-- eta-expanded version of the Left constructor
left2 : (a b : sort 0) -> a -> Either2 a b;
left2 a b x = Left2 a b x;

  -- AHA: one can curry this, but cannot curry Left2.

data Maybe2 (a : sort 0) : sort 0 where {
    Nothing2 : Maybe2 a;
    Just2 : a -> Maybe2 a;
  }

Maybe2__rec : (a : sort 0)
           -> (p : (Maybe2 a) -> sort 0)
           -> p (Nothing2 a)
           -> ((x:a) -> p (Just2 a x))
           -> (m : Maybe2 a)
           -> p m;
Maybe2__rec a p f1 f2 m = Maybe2#rec a p f1 f2 m;


 -- HMMM: something more general than case, ...
 -- TODO: how to use to generate the case?
 --   - See defn of 'either' in Prelude.

myTypes : ListSort;
myTypes = LS_Cons UnitType (LS_Cons Bool LS_Nil);

mySum : sort 0;
mySum = Eithers myTypes;

x : mySum;
x = Right UnitType Bool True;

MyResTy  : sort 0;
MyResTy  = Vec 8 Bool;

myFuns : FunsTo MyResTy;
myFuns = FunsTo_Cons MyResTy UnitType (\(_:UnitType) -> (0x01 : MyResTy))
          (FunsTo_Cons MyResTy Bool   (\(_:Bool)     -> (0x02 : MyResTy))
           (FunsTo_Nil MyResTy)
          );

y : MyResTy;
y = eithers MyResTy myFuns x;

-- Now, with 3-sum:

myTypes3 : ListSort;
myTypes3 = LS_Cons UnitType (LS_Cons UnitType (LS_Cons Bool LS_Nil));

SumOf2 : (a1 a2       : sort 0) -> sort 0;
SumOf2 a1 a2 = Either a1 a2;

SumOf3 : (a1 a2 a3    : sort 0) -> sort 0;
SumOf3 a1 a2 a3 = Either a1 (SumOf2 a2 a3);

y3 : Eithers myTypes3;
y3 = Left UnitType (SumOf2 UnitType Bool) Unit;

-- polymorphic:
y3' : (a1  a2 : sort 0) -> Eithers (LS_Cons UnitType (LS_Cons a1 (LS_Cons a2 LS_Nil)));
y3' a1 a2 = Left UnitType (SumOf2 a1 a2) Unit;

-- more polymorphic:
y3'' : (a1 : sort 0) -> Eithers (LS_Cons UnitType (LS_Cons a1 LS_Nil));
y3'' a1 = Left UnitType a1 Unit;

-- Now, with type variable s:

-- constructed values are going to be polymorphic, e.g.
-- y3 : SumOf3 UnitType UnitType Bool;
-- and each constructor [per cryptol AND SawCore] is going have 'all'
-- "top level" type parameters [follows from last]
