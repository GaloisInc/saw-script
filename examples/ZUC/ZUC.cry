// Copyright (c) 2011 Galois, Inc.
// An implementation of ZUC, Version 1.5


// Version info: If the following variable is set to True, then we implement
// Version 1.5 of ZUC. Otherwise, version 1.4 is implemented. There are
// precisely two points below where the difference matters, search for
// occurrences of version1_5 to spot them.
version1_5 : Bit;
version1_5 = True;

type LFSR = [16][31];

// addition in GF(2^31-1)
add : {a} (fin a) => [a][31] -> [31];
add xs = sums ! 0
 where {
   sums = [0] # [| plus (s, x) || s <- sums || x <- xs |];
   plus : ([31], [31]) -> [31];
   plus (a, b) = if sab!0 then sab'+1 else sab'
     where { sab : [32];
             sab  = (a # zero) + (b # zero);
             sab' : [31];
             sab' = take(31, sab);
           };
  };

LFSRWithInitializationMode : ([31], LFSR) -> LFSR;
LFSRWithInitializationMode (u, ss) = (ss @@ [1 .. 15]) # [s16]
  where {
    v = add [| s <<< c
            || s <- ss @@ [15 13 10 4 0 0]
            || c <- [15 17 21 20 8 0]
            |];
    vu = if version1_5
         then add [v u]
         else v ^ u;
    s16 = if vu == 0 then 0x7fffffff else vu;
  };

LFSRWithWorkMode : LFSR -> LFSR;
LFSRWithWorkMode ss = (ss @@ [1 .. 15]) # [s16]
  where {
    v = add [| s <<< c || s <- ss @@ [15 13 10 4 0 0]
                       || c <- [15 17 21 20 8 0]
            |];
    s16 = if v == 0 then 0x7fffffff else v;
  };

BitReorganization : LFSR -> [4][32];
BitReorganization ss = [| y # x || (x, y) <- [(hi s15, lo s14) (lo s11, hi s9) (lo s7, hi s5) (lo s2, hi s0)] |]
  where {
    lo, hi : [31] -> [16];
    lo x = x @@ [0 .. 15];
    hi x = x @@ [15 .. 30];
    [s0 s2 s5 s7 s9 s11 s14 s15] = ss @@ [0 2 5 7 9 11 14 15];
  };

BitReorganization' : LFSR -> ([32], [32], [32], [32]);
BitReorganization' lfsr = (r@0, r@1, r@2, r@3)
  where r = BitReorganization lfsr;

F : ([3][32], [2][32]) -> ([32], [32], [32]);
F ([X0 X1 X2], [R1 R2]) = (W, R1', R2')
  where {
    W   = (X0 ^ R1) + R2;
    W1  = R1 + X1;
    W2  = R2 ^ X2;
    [W1L W1H] = split W1;
    [W2L W2H] = split W2;
    R1' = S(L1(W2H # W1L));
    R2' = S(L2(W1H # W2L));
  };

S : [32] -> [32];
S X = Y0 # Y1 # Y2 # Y3
  where {
    [X3 X2 X1 X0] = split X;
    [Y3 Y2 Y1 Y0] = [(S0 X0) (S1 X1) (S2 X2) (S3 X3)];
  };

S0, S1, S2, S3 : [8] -> [8];
S0 x = S0Table @ x;
S1 x = S1Table @ x;
S2   = S0;
S3   = S1;

S0Table : [256][8];
S0Table = [0x3e 0x72 0x5b 0x47 0xca 0xe0 0x00 0x33 0x04 0xd1 0x54 0x98 0x09 0xb9 0x6d 0xcb
           0x7b 0x1b 0xf9 0x32 0xaf 0x9d 0x6a 0xa5 0xb8 0x2d 0xfc 0x1d 0x08 0x53 0x03 0x90
           0x4d 0x4e 0x84 0x99 0xe4 0xce 0xd9 0x91 0xdd 0xb6 0x85 0x48 0x8b 0x29 0x6e 0xac
           0xcd 0xc1 0xf8 0x1e 0x73 0x43 0x69 0xc6 0xb5 0xbd 0xfd 0x39 0x63 0x20 0xd4 0x38
           0x76 0x7d 0xb2 0xa7 0xcf 0xed 0x57 0xc5 0xf3 0x2c 0xbb 0x14 0x21 0x06 0x55 0x9b
           0xe3 0xef 0x5e 0x31 0x4f 0x7f 0x5a 0xa4 0x0d 0x82 0x51 0x49 0x5f 0xba 0x58 0x1c
           0x4a 0x16 0xd5 0x17 0xa8 0x92 0x24 0x1f 0x8c 0xff 0xd8 0xae 0x2e 0x01 0xd3 0xad
           0x3b 0x4b 0xda 0x46 0xeb 0xc9 0xde 0x9a 0x8f 0x87 0xd7 0x3a 0x80 0x6f 0x2f 0xc8
           0xb1 0xb4 0x37 0xf7 0x0a 0x22 0x13 0x28 0x7c 0xcc 0x3c 0x89 0xc7 0xc3 0x96 0x56
           0x07 0xbf 0x7e 0xf0 0x0b 0x2b 0x97 0x52 0x35 0x41 0x79 0x61 0xa6 0x4c 0x10 0xfe
           0xbc 0x26 0x95 0x88 0x8a 0xb0 0xa3 0xfb 0xc0 0x18 0x94 0xf2 0xe1 0xe5 0xe9 0x5d
           0xd0 0xdc 0x11 0x66 0x64 0x5c 0xec 0x59 0x42 0x75 0x12 0xf5 0x74 0x9c 0xaa 0x23
           0x0e 0x86 0xab 0xbe 0x2a 0x02 0xe7 0x67 0xe6 0x44 0xa2 0x6c 0xc2 0x93 0x9f 0xf1
           0xf6 0xfa 0x36 0xd2 0x50 0x68 0x9e 0x62 0x71 0x15 0x3d 0xd6 0x40 0xc4 0xe2 0x0f
           0x8e 0x83 0x77 0x6b 0x25 0x05 0x3f 0x0c 0x30 0xea 0x70 0xb7 0xa1 0xe8 0xa9 0x65
           0x8d 0x27 0x1a 0xdb 0x81 0xb3 0xa0 0xf4 0x45 0x7a 0x19 0xdf 0xee 0x78 0x34 0x60];

S1Table : [256][8];
S1Table = [0x55 0xc2 0x63 0x71 0x3b 0xc8 0x47 0x86 0x9f 0x3c 0xda 0x5b 0x29 0xaa 0xfd 0x77
           0x8c 0xc5 0x94 0x0c 0xa6 0x1a 0x13 0x00 0xe3 0xa8 0x16 0x72 0x40 0xf9 0xf8 0x42
           0x44 0x26 0x68 0x96 0x81 0xd9 0x45 0x3e 0x10 0x76 0xc6 0xa7 0x8b 0x39 0x43 0xe1
           0x3a 0xb5 0x56 0x2a 0xc0 0x6d 0xb3 0x05 0x22 0x66 0xbf 0xdc 0x0b 0xfa 0x62 0x48
           0xdd 0x20 0x11 0x06 0x36 0xc9 0xc1 0xcf 0xf6 0x27 0x52 0xbb 0x69 0xf5 0xd4 0x87
           0x7f 0x84 0x4c 0xd2 0x9c 0x57 0xa4 0xbc 0x4f 0x9a 0xdf 0xfe 0xd6 0x8d 0x7a 0xeb
           0x2b 0x53 0xd8 0x5c 0xa1 0x14 0x17 0xfb 0x23 0xd5 0x7d 0x30 0x67 0x73 0x08 0x09
           0xee 0xb7 0x70 0x3f 0x61 0xb2 0x19 0x8e 0x4e 0xe5 0x4b 0x93 0x8f 0x5d 0xdb 0xa9
           0xad 0xf1 0xae 0x2e 0xcb 0x0d 0xfc 0xf4 0x2d 0x46 0x6e 0x1d 0x97 0xe8 0xd1 0xe9
           0x4d 0x37 0xa5 0x75 0x5e 0x83 0x9e 0xab 0x82 0x9d 0xb9 0x1c 0xe0 0xcd 0x49 0x89
           0x01 0xb6 0xbd 0x58 0x24 0xa2 0x5f 0x38 0x78 0x99 0x15 0x90 0x50 0xb8 0x95 0xe4
           0xd0 0x91 0xc7 0xce 0xed 0x0f 0xb4 0x6f 0xa0 0xcc 0xf0 0x02 0x4a 0x79 0xc3 0xde
           0xa3 0xef 0xea 0x51 0xe6 0x6b 0x18 0xec 0x1b 0x2c 0x80 0xf7 0x74 0xe7 0xff 0x21
           0x5a 0x6a 0x54 0x1e 0x41 0x31 0x92 0x35 0xc4 0x33 0x07 0x0a 0xba 0x7e 0x0e 0x34
           0x88 0xb1 0x98 0x7c 0xf3 0x3d 0x60 0x6c 0x7b 0xca 0xd3 0x1f 0x32 0x65 0x04 0x28
           0x64 0xbe 0x85 0x9b 0x2f 0x59 0x8a 0xd7 0xb0 0x25 0xac 0xaf 0x12 0x03 0xe2 0xf2];

L1 : [32] -> [32];
L1 X = X ^ (X <<< 2) ^ (X <<< 10) ^ (X <<< 18) ^ (X <<< 24);

L2 : [32] -> [32];
L2 X = X ^ (X <<< 8) ^ (X <<< 14) ^ (X <<< 22) ^ (X <<< 30);

LoadKey : ([128], [128]) -> LFSR;
LoadKey (key, iv) = [| i # d # k || k <- ks || i <- is || d <- ds |]
  where {
    ks : [16][8];
    ks = split key;
    is : [16][8];
    is = split iv;
    ds : [16][15];
    ds = [0b100010011010111 0b010011010111100 0b110001001101011 0b001001101011110
          0b101011110001001 0b011010111100010 0b111000100110101 0b000100110101111
          0b100110101111000 0b010111100010011 0b110101111000100 0b001101011110001
          0b101111000100110 0b011110001001101 0b111100010011010 0b100011110101100];
  };

type ZUC = (LFSR, [32], [32]);

// Return an infinite sequence of ZUC states by applying the initialization step
// repeatedly
InitializeZUC : ([128], [128]) -> [inf]ZUC;
InitializeZUC (key, iv) = outs
  where {
    initLFSR = LoadKey (key, iv);
    outs = [(initLFSR, 0, 0)] # [| step out || out <- outs |];
    step (lfsr, R1, R2) = (LFSRWithInitializationMode(take(31, w >> 1), lfsr), R1', R2')
       where { [X0 X1 X2 X3] = BitReorganization(lfsr);
               (w', R1', R2') = F ([X0 X1 X2], [R1 R2]);
               w = if version1_5
                   then w'
                   else w' ^ X3;
             };
  };

WorkingStage : ZUC -> ZUC;
WorkingStage (lfsr, R1, R2) = (lfsr', R1', R2')
   where {
     [X0 X1 X2 _] = BitReorganization(lfsr);
     (_, R1', R2') = F ([X0 X1 X2], [R1 R2]);
     lfsr' = LFSRWithWorkMode(lfsr);
   };

ProductionStage : ZUC -> ([32], ZUC);
ProductionStage (lfsr, R1, R2) = (w ^ X3, (lfsr', R1', R2'))
   where {
     [X0 X1 X2 X3] = BitReorganization(lfsr);
     (w, R1', R2') = F ([X0 X1 X2], [R1 R2]);
     lfsr' = LFSRWithWorkMode(lfsr);
   };

// ZUC API
ZUC : ([128], [128]) -> [inf][32];
ZUC (key, iv) = tail [| w || (w, _) <- zucs |]
  where { initZuc = WorkingStage(InitializeZUC(key, iv) @ 32);
          zucs    = [(zero, initZuc)] # [| ProductionStage zuc || (_, zuc) <- zucs |];
        };

// Test vectors
theorem ZUC_TestVectors: t1 & t2 & t3 & t4
  where {
    t1 = take(2, ZUC(zero, zero))   == [0x27bede74 0x018082da];
    t2 = take(2, ZUC(~zero, ~zero)) == [0x0657cfa0 0x7096398b];
    t3 = take(2, ZUC( join [0x3d 0x4c 0x4b 0xe9 0x6a 0x82 0xfd 0xae
                             0xb5 0x8f 0x64 0x1d 0xb1 0x7b 0x45 0x5b]
                     , join [0x84 0x31 0x9a 0xa8 0xde 0x69 0x15 0xca
                             0x1f 0x6b 0xda 0x6b 0xfb 0xd8 0xc7 0x66])) == [0x14f1c272 0x3279c419];
    t4 =  take(2, ks) # [(ks @ 1999)] == [0xed4400e7 0x0633e5c5 0x7a574cdb]
      where ks = ZUC( join [0x4d 0x32 0x0b 0xfa 0xd4 0xc2 0x85 0xbf
                            0xd6 0xb8 0xbd 0x00 0xf3 0x9d 0x8b 0x41]
                    , join [0x52 0x95 0x9d 0xab 0xa0 0xbf 0x17 0x6e
                            0xce 0x2d 0xc3 0x15 0x04 0x9e 0xb5 0x74]);
  };

// Collision attack on ZUC. Only version1.5 is resistant to it. Thus, the following theorem
// holds only when version1_5 is set to True.
//
// NB. We only compare the first output of the InitializeZUC sequence, as it cuts
// down on the problem size and is sufficient to ensure the iv's will be the same.
// That is, if this theorem fails, then so would the final iv's used by ZUC.
theorem ZUC_isResistantToCollisionAttack: {k iv1 iv2}.
   if(iv1 != iv2)
   then InitializeZUC(k, iv1) @ 1 != InitializeZUC(k, iv2) @ 1
   else True;
