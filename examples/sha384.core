pure :: ?(m :: Type 0 -> Type 0) -> ??(Setup m) -> m ();
pure = return ();

long, int, char, byte :: Type 0;
long = Signed 64;
int = Signed 32;
char = Signed 16;
byte = Signed 8;

([_]) :: TODO -> Type 0;
[n] = Unsigned n;

/* I'll use Haskell's >>= and >> operators here for readability,
though we may not have them as operators in SAWCore. We'll still
have them as functions. */

main =
  extractCryptol "SHA384.cry" "Ch" >>=
    \cryptol_Ch : (([64], [64], [64]) -> [64]) ->

  extractCryptol "SHA384.cry" "Maj" >>=
    \cryptol_Maj : (([64], [64], [64]) -> [64]) ->

  extractCryptol "SHA384.cry" "UpperSigma_0" >>=
    \cryptol_Sum0 : ([64] -> [64]) ->
 
  extractCryptol "SHA384.cry" "UpperSigma_1" >>=
    \cryptol_Sum1 : ([64] -> [64]) ->

  extractCryptol "SHA384.cry" "LowerSigma_0" >>=
    \cryptol_Sigma0 : ([64] -> [64]) ->

  extractCryptol "SHA384.cry" "LowerSigma_1" >>=
    \cryptol_Sigma1 : ([64] -> [64]) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.K" pure >>=
    \java_K : Array 80 long ->

  extractCryptol "SHA384.cry" "block512" >>=
    \cryptol_Block : ((Array 8 [64], Array 16 [64]) -> Array 8 [64]) ->

  extractCryptol "SHA384.cry" "Ks512" >>= \cryptol_K : Array 80 [64] ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Ch"
    pure >>= \java_Ch : ((long, long, long) -> long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Maj"
    pure >>= \java_Maj : ((long, long, long) -> long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sum0"
    pure >>= \java_Sum0 : (long -> long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sum1"
    pure >>= \java_Sum1 : (long -> long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sigma0"
    pure >>= \java_Sigma0 : (long -> long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sigma1"
    pure >>= \java_Sigma1 : (long -> long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.processBlock" (
      /* This introduces new local names for Java variables, because
      otherwise it's a little difficult to deal with names like "this.H1",
      unless we implicitly introduce all variables as records (which is
      certainly a possibility). I'm open to other suggestions. */

      javaVar "this.H1" long >>= \x1 ->
      javaVar "this.H2" long >>= \x2 ->
      javaVar "this.H3" long >>= \x3 ->
      javaVar "this.H4" long >>= \x4 ->
      javaVar "this.H5" long >>= \x5 ->
      javaVar "this.H6" long >>= \x6 ->
      javaVar "this.H7" long >>= \x7 ->
      javaVar "this.H8" long >>= \x8 ->
      javaVar "this.W" (Array 80 long) >>= \x9 ->
      javaVar "this.wOff" int >>= \x10 ->
      javaVar "this.byteCount1" long >>= \x11 ->
      javaVar "this.byteCount2" long >>= \x12 ->

      input x11 >>
      input x12 >>
      input x1 >>
      input x2 >>
      input x3 >>
      input x4 >>
      input x5 >>
      input x6 >>
      input x7 >>
      input x8 >>
      input x9 >>

      output x11 >>
      output x12 >>
      output x1 >>
      output x2 >>
      output x3 >>
      output x4 >>
      output x5 >>
      output x6 >>
      output x7 >>
      output x8 >>
      output x9 >>
      modify x10

  ) >>= \java_Block : ((long, long, Array 8 long, Array 80 long) ->
                       (long, long, Array 8 long, Array 80 long)) ->

  let reset_spec = (
      javaVar "this.H1" long >>= \x1 ->
      javaVar "this.H2" long >>= \x2 ->
      javaVar "this.H3" long >>= \x3 ->
      javaVar "this.H4" long >>= \x4 ->
      javaVar "this.H5" long >>= \x5 ->
      javaVar "this.H6" long >>= \x6 ->
      javaVar "this.H7" long >>= \x7 ->
      javaVar "this.H8" long >>= \x8 ->
      javaVar "this.xBuf" (Array 8 byte) >>= \x9 ->
      javaVar "this.xBufOff" long >>= \x10 ->
      javaVar "this.W" (Array 80 long) >>= \x11 ->
      javaVar "this.wOff" long >>= \x12 ->
      output x1 >>
      output x2 >>
      output x3 >>
      output x4 >>
      output x5 >>
      output x6 >>
      output x7 >>
      output x8 >>
      modify x9 >>
      modify x10 >>
      modify x11 >>
      modify x12
  ) in
  
  let reset_verify_spec = (
      javaVar "this.H1" long >>= \x1 ->
      javaVar "this.H2" long >>= \x2 ->
      javaVar "this.H3" long >>= \x3 ->
      javaVar "this.H4" long >>= \x4 ->
      javaVar "this.H5" long >>= \x5 ->
      javaVar "this.H6" long >>= \x6 ->
      javaVar "this.H7" long >>= \x7 ->
      javaVar "this.H8" long >>= \x8 ->
      javaVar "this.xBuf" (Array 8 byte) >>= \x9 ->
      javaVar "this.xBufOff" long >>= \x10 ->
      javaVar "this.W" (Array 80 long) >>= \x11 ->
      javaVar "this.wOff" long >>= \x12 ->
      ensure x1 == refH1 &&
             x2 == refH2 &&
             x3 == refH3 &&
             x4 == refH4 &&
             x5 == refH5 &&
             x6 == refH6 &&
             x7 == refH7 &&
             x8 == refH8 >>
      modify x9 >>
      modify x10 >>
      modify x11 >>
      modify x12
  ) in

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.reset"
    reset_spec >>= \java_H : (Array 8 long) ->

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.reset"
    reset_verify_spec >>= \java_H_valid : Bool ->

  extractJava "org.foo.AliasExample.m" {
      javaVar "x" (Array 16 int) >>= x1 ->
      javaVar "y" (Array 16 int) >>= x2 ->
      mayAlias x1 x2 >>
      output x
  } >>= \java_foo : ( (Array 16 int, Array 16 int) -> Array 16 int
                    , Array 16 int -> Array 16 int
                    ) ->

  extractJava "org.foo.AliasExample.m" {
      javaVar "x" (Array 16 int) >>= x1 ->
      javaVar "y" (Array 16 int) >>= x2 ->
      mayAlias x1 x2 >>
      ensureI (join x) (add (join x) (join y))
  } >>= \java_foo_valid : ((Array 16 int, Array 16 int) -> Bool) ->


  // Other formats

  load AIG "Sum0.aig" >>= \aig_Sum0 : ([64] -> [64]) ->

  load BTOR "Sum0.btor" >>= \btor_Sum0 : ([64] -> [64]) ->

  extractLLVM "sha512.bc" "ROTR" pure >>=
    \llvm_ROTR : (([64], [64]) -> [64]) ->

  extractLLVM "sha512.bc" "Ch" pure >>=
    \llvm_Ch : (([64], [64], [64]) -> [64]) ->

  extractLLVM "sha512.bc" "Maj" pure >>=
    \llvm_Maj : (([64], [64], [64]) -> [64]) ->

  extractLLVM "sha512.bc" "Sum0" pure >>= \llvm_Sum0 : ([64] -> [64]) ->

  extractLLVM "sha512.bc" "Sum1" pure >>= \llvm_Sum1 : ([64] -> [64]) ->

  extractLLVM "sha512.bc" "transform" (
      llvmVar "hd" (Array 8 long) >>= \x1 ->
      llvmVar "data" (Array 128 byte) >>= \x2 ->
      input x1 >>
      input x2 >>
      output x2
  ) >>= \llvm_Block : ((Array 8 long, Array 128 byte) -> Array 128 byte) ->

  extractLLVM "sha512.bc" "transform.k" >>= \llvm_k : Array 80 long ->

  /* Assuming we have let bindings for the moment. Could easily be
  translated if we don't. */

  let llvm_cryptol_Ch = eq llvm_Ch cryptol_Ch in
  let java_cryptol_Ch = eq java_Ch cryptol_Ch in
  let java_llvm_Ch = eq java_Ch llvm_Ch in

  let aig_btor_Sum0 = eq aig_Sum0 btor_sum0 in

  let and_idem = \x : Bool -> (rule (and x x) x) in
  let or_idem = \x : Bool ->  (rule (or x x) x) in
  let and_or_rules = [and_idem, or_idem] in

  prove llvm_cryptol_Ch (
    rewrite and_or_rules goal >>= \goal' ->
    yices goal
  ) >>= \cex1 ->
  prove aig_btor_Sum0 abc >>= \cex2 ->
  sat java_llvm_Ch picosat >>= \assgn ->

  export DIMACS llvm_cryptol_Ch "llvm_cryptol_Ch.cnf" >>

  export AIG llvm_Ch "llvm_Ch.aig" >>

  rewrite [] llvm_Ch >>= \llvm_Ch' ->

  rewrite [and_idem] llvm_Block >>= \llvm_Block' ->

  rewrite and_or_rules llvm_Transform >>= \llvm_Transform' ->

  /* TODO: should main always return ()? */
  return ()
  ;
  
