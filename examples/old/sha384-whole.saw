type ProofResult = ();
type Rule = ();
type Goal = ();
type Theorem = ();
type CounterExample = ();
type CryptolVerifyResult = ();
type JavaVerifyResult = ();
type LLVMVerifyResult = ();
type JavaObject = ();
type JavaOverride = ();
type JavaVar = ();
type JavaType = ();
type Nat = ();
type JavaCounterExample = ();
type LLVMObject = ();
type LLVMOverride = ();
type LLVMVar = ();
type LLVMType = ();
type LLVMCounterExample = ();

/* Send the current goal to Yices, and return proof status. */
yices : ProofScript ProofResult;

/* Send the current goal to abc, and return proof status. */
abc : ProofScript ProofResult;

/* Prove the same goal with multiple provers. */
//multi_prove : {a} [a](ProofScript ProofResult) -> ProofScript ProofResult;

/* TODO: might some theorem provers return new, simplified goals? */

/* Rewrite rules. */
rule : {a} a -> a -> Rule;
expand : {a} a -> Rule;

/* Rewrite the current goal with a default set of rules, and return
 * the rewritten term (also updating the implicit state?).
 */
rewrite : ProofScript Goal;

/* Rewrite with a specific set of results. */
//rewrite_with : {a} [a]Rule -> ProofScript Goal;

/* Any boolean expression can be a goal. */
goal : Bit -> Goal;

/* Goals can have quantifiers added. */
forall : {a} (a -> Goal) -> Goal;
exists : {a} (a -> Goal) -> Goal;

/*
Example:
  forall (\a -> exists (\b -> goal (a == b)))
*/

/* Top level proof commands. */
prove : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
sat : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
quickcheck : Goal -> ProofScript ProofResult -> TopLevel ProofResult;

proof_result : {a} ProofResult -> (Theorem -> a) -> (CounterExample -> a) -> a;

/* A VerifyResult encodes either a statement of what it proved, or a
 * counterexample. These work like the method specs in the first version
 * of SAWScript.
 */
cryptol_verify : String -> String -> CryptolSetup () -> TopLevel CryptolVerifyResult;

/* Extract pure models from suitably well-structured programs. We assume
 * that these are well-typed, and check at runtime.
 */
cryptol_extract : {a} String -> String -> CryptolSetup () -> TopLevel a;

/* One method is currently available for Cryptol extraction. */
sbv : CryptolSetup ();

cryptol_uninterpret : String -> CryptolSetup ();

/*
/* NB: eventually the "java_" prefix will be removed, and qualified
 * module imports will be supported. */

/* A VerifyResult encodes either a statement of what it proved, or a
 * counterexample. These work like the method specs in the first version
 * of SAWScript.
 */
java_verify : String -> JavaSetup () -> TopLevel JavaVerifyResult;

/* Extract pure models from suitably well-structured programs. We assume
 * that these are well-typed, and check at runtime.
 */
java_extract : {a} String -> JavaSetup () -> TopLevel a;

/* Set up symbolic simulation for a pure function from fixed-size arguments
 * to fixed-size return value.
 */
java_pure : JavaSetup ();

/* A successful proof about a method can be used to override calls to
 * the method. The requirement to provide verification results serves
 * two purposes:
 *   - it tells the simulator how to provide inputs and interpret outputs
 *   - it ensures soundness by only allowing overrides that are proven correct
 */
java_override : JavaVerifyResult -> JavaSetup ();

/* We can uninterpret particular names along with overrides. Is this
 * the right approach? For Cryptol, uninterpreting is the only form of
 * overriding. For Java, it can complement overriding by causing
 * portions of the overriding model to be left uninterpreted.
 */
java_uninterpret : String -> JavaSetup ();

/* State that the current function returns the given value. We assume,
 * again, that the argument is of the right type, and check at runtime.
 */
java_return : {a} a -> JavaSetup ();

/* Declare that the particular expression is an output, for model
 * extraction.
 */
java_output : {a} a -> JavaSetup ();

/* Declare that the particular expression is an input, for model
 * extraction.
 */
java_input : {a} a -> JavaSetup ();

/* Assert a particular starting condition. */
java_assert : Bit -> JavaSetup ();

/* Assign the given value to the given object before execution. */
java_assume_equal : {a} JavaObject -> a -> JavaSetup();

/* Ensure that the given object is assigned the given value on
 * termination.
 */
java_ensure_equal : {a} JavaObject -> a -> JavaSetup ();

/* State that a particular object is modified with an arbitrary value.  */
java_modify : JavaObject -> JavaSetup ();

/* And in the Java world. */
java_var : String -> JavaType -> JavaObject;
java_arg : Nat -> JavaType -> JavaObject;
java_field : JavaObject -> String -> JavaObject;

/* And Java types. */
java_class : String -> JavaType;
java_array : Nat -> JavaType -> JavaType;
java_byte : JavaType;
java_char : JavaType;
java_int : JavaType;
java_long : JavaType;

//java_may_alias : [JavaObject] -> JavaSetup ();

/* This allows us to project from a Java value into a native value.
 * We assume that these are well-typed, and check at runtime.
 */
from_java : {a} JavaObject -> a;

java_verify_result : {a} JavaVerifyResult
                   -> (JavaOverride -> a)
                   -> (JavaCounterExample -> a)
                   -> a;

/* We start by declaring the types of some primitive functions. */

/* A VerifyResult encodes either a statement of what it proved, or a
 * counterexample. These work like the method specs in the first version
 * of SAWScript.
 */
llvm_verify : String -> String -> LLVMSetup () -> TopLevel LLVMVerifyResult;

/* Extract pure models from suitably well-structured programs. We assume
 * that these are well-typed, and check at runtime.
 */
llvm_extract : {a} String -> String -> LLVMSetup () -> TopLevel a;

/* Set up symbolic simulation for a pure function from fixed-size arguments
 * to fixed-size return value.
 */
llvm_pure : LLVMSetup ();

/* A successful proof about a method can be used to override calls to
 * the method. The requirement to provide verification results serves
 * two purposes:
 *   - it tells the simulator how to provide inputs and interpret outputs
 *   - it ensures soundness by only allowing overrides that are proven correct
 */
llvm_override : LLVMVerifyResult -> LLVMSetup ();

/* We can uninterpret particular names along with overrides. Is this
 * the right approach? For Cryptol, uninterpreting is the only form of
 * overriding. For LLVM, it can complement overriding by causing
 * portions of the overriding model to be left uninterpreted.
 */
llvm_uninterpret : String -> LLVMSetup ();

/* State that the current function returns the given value. We assume,
 * again, that the argument is of the right type, and check at runtime.
 */
llvm_return : {a} a -> LLVMSetup ();

/* Declare that the particular expression is an output, for model
 * extraction.
 */
llvm_output : {a} a -> LLVMSetup ();

/* Declare that the particular expression is an input, for model
 * extraction.
 */
llvm_input : {a} a -> LLVMSetup ();

/* Assert a particular starting condition. */
llvm_assert : Bit -> LLVMSetup ();

/* Assign the given value to the given object before execution. */
llvm_assume_equal : {a} LLVMObject -> a -> LLVMSetup ();

/* Ensure that the given object is assigned the given value on
 * termination.
 */
llvm_ensure_equal : {a} LLVMObject -> a -> LLVMSetup ();

/* State that a particular object is modified with an arbitrary value.  */
llvm_modify : LLVMObject -> LLVMSetup ();

/* These work in the context of an implicit goal. */

/* These allow us to refer to objects in the LLVM world. */
llvm_var : String -> LLVMType -> LLVMObject;
llvm_arg : Nat -> LLVMType -> LLVMObject;
llvm_field : LLVMObject -> String -> LLVMObject;
llvm_deref : LLVMObject -> LLVMObject;

/* And LLVM types. */
llvm_struct : String -> LLVMType;
llvm_ptr : LLVMType -> LLVMType;
llvm_int : Nat -> LLVMType; /* An LLVM integer with the given number of bits. */
llvm_array : Nat -> LLVMType -> LLVMType;

//llvm_may_alias : [LLVMObject] -> LLVMSetup ();

/* This allows us to project from an LLVM value into a native value.
 * We assume that these are well-typed, and check at runtime.
 */
from_llvm : {a} LLVMObject -> a;

llvm_verify_result : {a} LLVMVerifyResult
                   -> (LLVMOverride -> a)
                   -> (LLVMCounterExample -> a)
                   -> a;
*/

/* Printing is polymorphic for now. */
print : {a} a -> TopLevel ();


main = do {

  /* Cryptol extraction is straightforward. Initially, it'll go through
   * SBV, but later it'll be a direct compilation. We allow "[x]y" as
   * sugar for "Array x y", where "y" defaults to "Bit". The last parameter
   * consists of a simulator setup block, and for most Cryptol code this can
   * be "pure". The "extract" functions automatically coerce from target
   * language types into internal types.
   */
 
  cryptol_Ch : ([64], [64], [64] ) -> [64];
  cryptol_Ch <- cryptol_extract "SHA384.cry" "Ch" sbv;

  /*
  cryptol_Maj : ([64],[64],[64]) -> [64];
  cryptol_Maj <- cryptol_extract "SHA384.cry" "Maj" sbv;

  cryptol_UpperSigma_0 : [64] -> [64];
  cryptol_UpperSigma_0 <- cryptol_extract "SHA384.cry" "UpperSigma_0" sbv;

  cryptol_UpperSigma_1 : [64] -> [64];
  cryptol_UpperSigma_1 <- cryptol_extract "SHA384.cry" "UpperSigma_1" sbv;

  cryptol_LowerSigma_0 : [64] -> [64];
  cryptol_LowerSigma_0 <- cryptol_extract "SHA384.cry" "LowerSigma_0" sbv;

  cryptol_LowerSigma_1 : [64] -> [64];
  cryptol_LowerSigma_1 <- cryptol_extract "SHA384.cry" "LowerSigma_1" sbv;

  cryptol_Block512_T1 : [6][64] -> [64];
  cryptol_Block512_T1 <- cryptol_extract "SHA384-Ops.cry" "Block512_T1"
    (do { sbv; cryptol_uninterpret "UpperSigma_1"; cryptol_uninterpret "Ch"; });

  cryptol_Block512_T2 : [3][64] -> [64];
  cryptol_Block512_T2 <- extract "SHA384-Ops.cry" "Block512_T2"
    (do { sbv; cryptol_uninterpret "LowerSigma_1"; cryptol_uninterpret "LowerSigma_0"; });

  cryptol_Block512_W : [4][64] -> [64];
  cryptol_Block512_W <- extract "SHA384-Ops.cry" "Block512_W"
    (do { sbv; cryptol_uninterpret "LowerSigma_0"; cryptol_uninterpret "LowerSigma_1"; });

  cryptol_Block512_Inner : ([80][64], [9][64]) -> [9][64];
  cryptol_Block512_Inner <- extract "SHA384-Ops.cry" "Block512_Inner"
    (do { sbv; cryptol_uninterpret "Block512_T1"; cryptol_uninterpret "Block512_T2"; });

  cryptol_Transform : ([8][64], [16][64]) -> [8][64];
  cryptol_Transform <- extract "SHA384-Ops.cry" "Transform"
    (do { sbv; cryptol_uninterpret "Block512_Inner"; cryptol_uninterpret "Block512_W"; });

  cryptol_sha384_init : [8][64];
  cryptol_sha384_init <- cryptol_extract "SHA384.cry" "iv384" sbv;

  cryptol_block512 : ([8][64], [16][64]) -> [8][64];
  cryptol_block512 <- cryptol_extract "SHA384.cry" "block512" (do {
    sbv;
    cryptol_uninterpret "LowerSigma_0"
    cryptol_uninterpret "LowerSigma_1";
    cryptol_uninterpret "UpperSigma_0";
    cryptol_uninterpret "UpperSigma_1";
    cryptol_uninterpret "Ch";
    cryptol_uninterpret "Maj";
  });
  */

  /* Since Ch is such a simple function, we can extract it directly
   * from an LLVM implementation without any fuss. */
  /*
  llvm_Ch : ([64],[64],[64]) -> [64];
  llvm_Ch <- llvm_extract_llvm "sha384.bc" "Ch" llvm_pure_llvm;
  */

  /* Same for some others. */
  /*
  llvm_Maj : ([64],[64],[64]) -> [64];
  llvm_Maj <- llvm_extract_llvm "sha384.bc" "Maj" llvm_pure_llvm;
  llvm_Sum0 : ([64]) -> [64];
  llvm_Sum0 <- llvm_extract_llvm "sha384.bc" "Sum0" llvm_pure_llvm;
  llvm_Sum1 : ([64]) -> [64];
  llvm_Sum1 <- llvm_extract_llvm "sha384.bc" "Sum1" llvm_pure_llvm;
  llvm_ROTR : ([64], [64]) -> [64];
  llvm_ROTR <- llvm_extract_llvm "sha384.bc" "ROTR" llvm_pure_llvm;
  */

  /* We can state a simple theorem that the Cryptol and LLVM
   * implementations are equivalent. */
  llvm_cryptol_Ch : ([64],[64],[64]) -> Bit;
  // TODO: Don't yet have pattern matching.
  //let llvm_cryptol_Ch (x, y, z) = cryptol_Ch(x, y, z) == llvm_Ch(x, y, z);

  llvm_cryptol_Maj : ([64],[64],[64]) -> Bit;
  //let llvm_cryptol_Maj (x, y, z) = cryptol_Maj(x, y, z) == llvm_Maj(x, y, z);

  /*
  llvm_cryptol_UpperSigma0 : [64] -> Bit;
  let llvm_cryptol_UpperSigma0 x = (cryptol_UpperSigma0 x) == (llvm_Sum0 x);

  llvm_cryptol_UpperSigma1 : [64] -> Bit;
  let llvm_cryptol_UpperSigma1 x = cryptol_UpperSigma1 x == llvm_Sum1 x;

  prove llvm_cryptol_Ch abc;
  prove llvm_cryptol_Maj abc;
  prove llvm_cryptol_UpperSigma0 abc;
  prove llvm_cryptol_UpperSigma1 abc;
  */

  /* We can also use SAWScript1-style specification blocks (which are
   * necessary for more complex functions). Here we prove that the LLVM
   * Ch implementation is equivalent to the model we just extracted from
   * it. Should be obviously true. :)
   */
  /*
  llvm_Ch_result_trivial <- llvm_verify "sha384.bc" "Ch" (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    llvm_return llvm_Ch(llvm_from x, llvm_from y, llvm_from z);
    llvm_verify rewrite;
  });
  */

  /* Here we prove that the LLVM Ch impelementation is equivalent to the
   * Cryptol version.
   */
  /*
  llvm_Ch_result <- llvm_verify (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    // Alternatively: x <- llvm_arg 0 (llvm_int 64)
    llvm_return cryptol_Ch(llvm_from(x), llvm_from(y), llvm_from(z));
    llvm_verify abc;
  });
  show_result llvm_Ch_result;
  */

  /* TODO: similar code for LLVM Maj, UpperSigma_*, and LowerSigma_*. */

  /* For more complex functions, specification blocks can be necessary. */
  /*
  llvm_Block512_W_result <- llvm_verify "sha384.bc" "Block512_W" (do {
    w2  <- llvm_var "w2" (llvm_int 64);
    w7  <- llvm_var "w7" (llvm_int 64);
    w15 <- llvm_var "w15" (llvm_int 64);
    w16 <- llvm_var "w16" (llvm_int 64);

    // Use the following equivalence proofs to override calls.
    llvm_override [llvm_S0_result, llvm_S1_result];

    // In the result, leave these functions uninterpreted.
    llvm_uninterpret ["LowerSigma_0", "LowerSigma_1"];

    llvm_return cryptol_Block512_W(llvm_from(w2), llvm_from(w7),
                                   llvm_from(w15), llvm_from(w16));
    llvm_verify abc;
  });
  */

    /* We can refer to arguments by number, in case debug info isn't
     * available. Also, any pointer variables are allocated to point
     * to an instance of the appropriate type, recursively, unless
     * stated otherwise (and we currently don't have a way to state
     * otherwise). All pointers point to distinct objects unless
     * a may_alias statement says otherwise.
     */
  /*
  llvm_sha384_init_result <- llvm_verify "sha384.bc" "sha384_init" (do {
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ llvm_from (llvm_field ctx "h0")
              , llvm_from (llvm_field ctx "h1")
              , llvm_from (llvm_field ctx "h2")
              , llvm_from (llvm_field ctx "h3")
              , llvm_from (llvm_field ctx "h4")
              , llvm_from (llvm_field ctx "h5")
              , llvm_from (llvm_field ctx "h6")
              , llvm_from (llvm_field ctx "h7")
              ]
    llvm_ensure_equal (llvm_field ctx "nblocks") 0;
    llvm_ensure_equal (llvm_field ctx "count") 0;
    llvm_ensure (res == cryptol_sha384_init);
  });
  */

  /*
  llvm_sha384_init <- llvm_extract "sha384.bc" "sha384_init" (do {
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ llvm_from (llvm_field ctx "h0")
              , llvm_from (llvm_field ctx "h1")
              , llvm_from (llvm_field ctx "h2")
              , llvm_from (llvm_field ctx "h3")
              , llvm_from (llvm_field ctx "h4")
              , llvm_from (llvm_field ctx "h5")
              , llvm_from (llvm_field ctx "h6")
              , llvm_from (llvm_field ctx "h7")
              ]
    // These are checked after symbolic simulation, but before returning
    // a model.
    llvm_ensure_equal (llvm_field ctx "nblocks") 0;
    llvm_ensure_equal (llvm_field ctx "count") 0;

    // This tells us what model to return. No "input" clauses means
    // it'll be a constant.
    llvm_output res;
  });
  */
  print 0;
};
