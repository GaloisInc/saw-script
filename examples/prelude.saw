import cryptol_prelude as cryptol;
import java_prelude as java;
import llvm_prelude as llvm;

/* Send the current goal to Yices, and return proof status. */
yices : ProofScript ProofResult;

/* Send the current goal to abc, and return proof status. */
abc : ProofScript ProofResult;

/* Prove the same goal with multiple provers. */
multi_prove : [ProofScript ProofResult] -> ProofScript ProofResult;

/* TODO: might some theorem provers return new, simplified goals? */

/* Rewrite rules. */
rule : {a} a -> a -> Rule;
expand : {a} a -> Rule;

/* Rewrite the current goal with a default set of rules, and return
 * the rewritten term (also updating the implicit state?).
 */
rewrite : ProofScript Goal;

/* Rewrite with a specific set of results. */
rewrite_with : [Rule] -> ProofScript Goal;

/* Any boolean expression can be a goal. */
goal : Bit -> Goal;

/* Goals can have quantifiers added. */
forall : {a} (a -> Goal) -> Goal;
exists : {a} (a -> Goal) -> Goal;

/*
Example:
  forall (\a -> exists (\b -> goal (a == b)))
*/

/* Top level proof commands. */
prove : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
sat : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
quickcheck : Goal -> ProofScript ProofResult -> TopLevel ProofResult;

/* Printing is polymorphic for now. */
print : {a} a -> TopLevel ();

proof_result : {a} ProofResult -> (Theorem -> a) -> (CounterExample -> a) -> a;

/* Something to make it easy to print the result of a proof. We don't
 * have case expressions in the language at the moment, and instead use
 * destructor functions for any built-in algebraic data types.
 */
show_result : ProofResult () -> TopLevel ()
show_result r = proof_result r
                (\thm -> print "Success!")
                (\cex -> do { print "Failure:" ; print cex })
