/* Questions:
 *   - should we have lists? Useful for rule lists, override lists,
 *     uninterpret lists
 *   - can we have some built-ins polymorphic over block type? Or a generic
 *     block within an LLVM or Java block?
 *   - should we have different top-level versus spec-level proof commands?
 *   - is the LLVMObject/JavaObject approach reasonable?
 *   - should the type parameter in CryptolSetup, etc., be used for anything
 *     in the simulators?
 *   - should we use  underscore_naming or camelCase?
 *   - what sort of syntactic sugar should we provide on top of these
 *     primitive functions?
 */

/* We start by declaring the types of some primitive functions. */

/* A VerifyResult encodes either a statement of what it proved, or a
 * counterexample. These work like the method specs in the first version
 * of SAWScript.
 */
verify_cryptol : String -> String -> CryptolSetup () -> CryptolVerifyResult ();
verify_llvm : String -> String -> LLVMSetup () -> LLVMVerifyResult ();
verify_java : String -> JavaSetup () -> JavaVerifyResult ();

/* Extract pure models from suitably well-structured programs. We assume
 * that these are well-typed, and check at runtime.
 */
extract_cryptol : String -> String -> CryptolSetup () -> a;
extract_llvm : String -> String -> LLVMSetup () -> a;
extract_java : String -> JavaSetup () -> a;

/* One method is currently available for Cryptol extraction. */
sbv : CryptolSetup ();

/* Set up symbolic simulation for a pure function from fixed-size arguments
 * to fixed-size return value.
 */
pure_llvm : LLVMSetup ();
pure_java : LLVMSetup ();

/* A successful proof about a method can be used to override calls to
 * the method. The requirement to provide verification results serves
 * two purposes:
 *   - it tells the simulator how to provide inputs and interpret outputs
 *   - it ensures soundness by only allowing overrides that are proven correct
 */
override_llvm : [LLVMVerifyResult ()] -> LLVMSetup ();
override_java : [JavaVerifyResult ()] -> JavaSetup ();

/* We can uninterpret particular names along with overrides. Is this
 * the right approach? For Cryptol, uninterpreting is the only form of
 * overriding. For LLVM and Java, it can complement overriding by causing
 * portions of the overriding model to be left uninterpreted.
 */
java_uninterpret : [String] -> JavaSetup ();
llvm_uninterpret : [String] -> LLVMSetup ();

/* It would be nice to allow some sort of type classing, or something
 * similar, so that certain operations would be legal in multiple
 * contexts (e.g., Java and LLVM).
 */

/* State that the current function returns the given value. We assume,
 * again, that the argument is of the right type, and check at runtime.
 */
java_return : a -> JavaSetup ();
llvm_return : a -> LLVMSetup ();

/* Declare that the particular expression is an output, for model
 * extraction.
 */
java_output : a -> JavaSetup ();
llvm_output : a -> LLVMSetup ();

/* Declare that the particular expression is an input, for model
 * extraction.
 */
java_input : a -> JavaSetup ();
llvm_input : a -> LLVMSetup ();

/* Assert a particular starting condition. */
assert_java : Bit -> JavaSetup ();
assert_llvm : Bit -> LLVMSetup ();

/* Assign the given value to the given object before execution. */
assume_equal_java : JavaObject -> a -> JavaSetup();
assume_equal_llvm : LLVMObject -> a -> LLVMSetup();

/* Ensure that the given object is assigned the given value on
 * termination.
 */
ensure_equal_java : JavaObject -> a -> JavaSetup ();
ensure_equal_llvm : LLVMObject -> a -> LLVMSetup ();

/* Java and LLVM statements that a particular object is modified with
 * an arbitrary value.
 */
modify_java : JavaObject -> JavaSetup ();
modify_llvm : LLVMObject -> JavaSetup ();

/* We can verify a function by writing a proof script. */
verify_java : ProofScript () -> JavaSetup ();
verify_llvm : ProofScript () -> LLVMSetup (); 

/* These work in the context of an implicit goal. */

/* These allow us to refer to objects in the LLVM world. */
llvm_var : String -> LLVMType -> LLVMObject;
llvm_arg : Nat -> LLVMType -> LLVMObject;
llvm_field : LLVMObject -> String -> LLVMObject
llvm_deref : LLVMObject -> LLVMObject

/* And in the Java world. */
java_var : String -> JavaType -> JavaObject;
java_arg : Nat -> JavaType -> JavaObject;
java_field : JavaObject -> String -> JavaObject;

/* And LLVM types. */
llvm_struct : String -> LLVMType;
llvm_ptr : LLVMType -> LLVMType;
llvm_int : Nat -> LLVMType; /* An LLVM integer with the given number of bits. */
llvm_array : Nat -> LLVMType -> LLVMType;

/* And Java types. */
java_class : String -> JavaType;
java_array : Nat -> JavaType -> JavaType;
java_byte : JavaType;
java_char : JavaType;
java_int : JavaType;
java_long : JavaType;

may_alias_llvm : [LLVMObject] -> LLVMSetup ();
may_alias_java : [JavaObject] -> LLVMSetup ();

/* This allows us to project from an LLVM value into a native value.
 * We assume that these are well-typed, and check at runtime.
 */
from_llvm : LLVMObject -> a;
from_java : JavaObject -> a;

/* Send the current goal to Yices, and return proof status. */
yices : ProofScript ProofResult;

/* Send the current goal to abc, and return proof status. */
abc : ProofScript ProofResult;

/* Prove the same goal with multiple provers. */
multi_prove : [ProofScript ProofResult] -> ProofScript ProofResult;

/* TODO: might some theorem provers return new, simplified goals? */

/* Rewrite rules. */
rule : a -> a -> Rule;
expand : a -> Rule;

/* Rewrite the current goal with a default set of rules, and return
 * the rewritten term (also updating the implicit state?).
 */
rewrite : ProofScript Goal;

/* Rewrite with a specific set of results. */
rewrite_with : [Rule] -> ProofScript Goal;

/* Any boolean expression can be a goal. */
goal : Bit -> Goal;

/* Goals can have quantifiers added. */
forall : (a -> Goal) -> Goal;
exists : (a -> Goal) -> Goal;

/*
Example:
  forall (\a -> exists (\b -> goal (a == b)))
*/

/* Top level proof commands. */
prove : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
sat : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
quickcheck : Goal -> ProofScript ProofResult -> TopLevel ProofResult;

/* Printing is polymorphic for now. */
print : a -> TopLevel ()

java_verify_result : JavaVerifyResult
                   -> (JavaOverride -> a)
                   -> (JavaCounterExample -> a)
                   -> a;

llvm_verify_result : LLVMVerifyResult
                   -> (LLVMOverride -> a)
                   -> (LLVMCounterExample -> a)
                   -> a;

proof_result : ProofResult -> (Theorem -> a) -> (CounterExample -> a) -> a;

/* Something to make it easy to print the result of a proof. We don't
 * have case expressions in the language at the moment, and instead use
 * destructor functions for any built-in algebraic data types.
 */
show_result : ProofResult () -> TopLevel ()
show_result r = proof_result r
                (\thm -> print "Success!")
                (\cex -> do { print "Failure:" ; print cex })
