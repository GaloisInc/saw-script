import cryptol_prelude;
import java_prelude;
import llvm_prelude;

/* Send the current goal to Yices, and return proof status. */
yices : ProofScript ProofResult;

/* Send the current goal to abc, and return proof status. */
abc : ProofScript ProofResult;

/* Prove the same goal with multiple provers. */
multi_prove : {a} [a](ProofScript ProofResult) -> ProofScript ProofResult;

/* TODO: might some theorem provers return new, simplified goals? */

/* Rewrite rules. */
rule : {a} a -> a -> Rule;
expand : {a} a -> Rule;

/* Rewrite the current goal with a default set of rules, and return
 * the rewritten term (also updating the implicit state?).
 */
rewrite : ProofScript Goal;

/* Rewrite with a specific set of results. */
rewrite_with : {a} [a]Rule -> ProofScript Goal;

/* Any boolean expression can be a goal. */
goal : Bit -> Goal;

/* Goals can have quantifiers added. */
forall : {a} (a -> Goal) -> Goal;
exists : {a} (a -> Goal) -> Goal;

/*
Example:
  forall (\a -> exists (\b -> goal (a == b)))
*/

/* Top level proof commands. */
prove : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
sat : Goal -> ProofScript ProofResult -> TopLevel ProofResult;
quickcheck : Goal -> ProofScript ProofResult -> TopLevel ProofResult;

/* Printing is polymorphic for now. */
print : {a} a -> TopLevel ();

proof_result : {a} ProofResult -> (Theorem -> a) -> (CounterExample -> a) -> a;
