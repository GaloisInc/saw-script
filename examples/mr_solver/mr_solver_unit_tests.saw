enable_experimental;

let eq_bool b1 b2 =
  if b1 then
    if b2 then true else false
  else
    if b2 then false else true;

let fail = do { print "Test failed"; exit 1; };
let run_test name test expected =
  do { print (str_concat "Test: " name);
       actual <- test;
       if eq_bool actual expected then print "Success" else
         do { print "Test failed"; exit 1; }; };

// The constant 0 function
const0 <- parse_core "\\ (_:Vec 64 Bool) -> returnM (Vec 64 Bool) (bvNat 64 0)";

// The constant 1 function
const1 <- parse_core "\\ (_:Vec 64 Bool) -> returnM (Vec 64 Bool) (bvNat 64 1)";

// const0 <= const0
run_test "mr_solver const0 const0" (mr_solver const0 const0) true;

test_fun0 <- parse_core "test_fun0";
run_test "mr_solver const0 test_fun0" (mr_solver const0 test_fun0) true;

// not const0 <= const1
run_test "mr_solver const0 const1" (mr_solver const0 const1) false;

test_fun1 <- parse_core "test_fun1";
run_test "mr_solver const0 test_fun1" (mr_solver const0 test_fun1) false;

// If x == 0 then x else 0; should be equal to 0
ifxEq0 <- parse_core "\\ (x:Vec 64 Bool) -> \
                       \ ite (CompM (Vec 64 Bool)) (bvEq 64 x (bvNat 64 0)) \
                       \     (returnM (Vec 64 Bool) x) \
                       \     (returnM (Vec 64 Bool) (bvNat 64 0))";

// ifxEq0 <= const0
run_test "mr_solver ifxEq0 const0" (mr_solver ifxEq0 const0) true;

// not ifxEq0 <= const1
run_test "mr_solver ifxEq0 const1" (mr_solver ifxEq0 const1) false;

// The universal success computation exists x. returnM x at type bv 64
noErrors1 <- parse_core "\\ (x:Vec 64 Bool) -> \
                          \ existsM (Vec 64 Bool) (Vec 64 Bool) \
                          \ (\\ (x:Vec 64 Bool) -> returnM (Vec 64 Bool) x)";

// const0 <= noErrors
run_test "mr_solver const0 noErrors1" (mr_solver const0 noErrors1) true;

// const1 <= noErrors
run_test "mr_solver const1 noErrors1" (mr_solver const1 noErrors1) true;
