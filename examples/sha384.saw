extract_cryptol : String -> String -> CryptolSetup -> a;
extract_llvm : String -> String -> LLVMSetup -> a;
verify_llvm : String -> String -> LLVMSetup -> ProofResult;
returns : Bit -> Setup;
verify : ProofScript -> Setup;
yices : ProofScript;
abc : ProofScript;
rewrite : ProofScript;

llvm_var : String -> LLVMType -> LLVMObject;
llvm_field : LLVMObject -> String -> LLVMObject
from_llvm : LLVMObject -> a;

print : String -> TopLevel

show_result : ProofResult -> TopLevel
show_result r = proof_result r
                (\thm -> print "Success!")
                (\cex -> do { print "Failure:" ; print cex })

pure = do {};

main = do {

  /* Cryptol extraction is straightforward. Initially, it'll go through
   * SBV, but later it'll be a direct compilation. We allow "[x]y" as
   * sugar for "Array x y", where "y" defaults to "Bit".
   */
  cryptol_Ch : ([64],[64],[64]) -> [64];
  cryptol_Ch <- extract_cryptol "SHA384.cry" "Ch" pure;

  cryptol_Maj : ([64],[64],[64]) -> [64];
  cryptol_Maj <- extract_cryptol "SHA384.cry" "Maj" pure;

  cryptol_UpperSigma_0 : [64] -> [64];
  cryptol_UpperSigma_0 <- extract_cryptol "SHA384.cry" "UpperSigma_0" pure;

  cryptol_UpperSigma_1 : [64] -> [64];
  cryptol_UpperSigma_1 <- extract_cryptol "SHA384.cry" "UpperSigma_1" pure;

  cryptol_LowerSigma_0 : [64] -> [64];
  cryptol_LowerSigma_0 <- extract_cryptol "SHA384.cry" "LowerSigma_0" pure;

  cryptol_LowerSigma_1 : [64] -> [64];
  cryptol_LowerSigma_1 <- extract_cryptol "SHA384.cry" "LowerSigma_1" pure;

  cryptol_Block512_W : [4][64] -> [64];
  cryptol_Block512_W <- extract_cryptol "SHA384-Ops.cry" "Block512_W"
    (uninterpret ["LowerSigma_0", "LowerSigma_1"])

  cryptol_sha384_init : [8][64];
  cryptol_sha384_init <- extract_cryptol "SHA384.cry" "iv384" pure;

  cryptol_block512 : ([8][64], [16][64]) -> [8][64];
  cryptol_block512 <- extract_cryptol "SHA384.cry" "block512"
    (uninterpret ["LowerSigma_0", "LowerSigma_1",
                  "UpperSigma_0", "UpperSigma_1", "Ch", "Maj"])


  /* Since Ch is such a simple function, we can extract it directly,
   * without any fuss. */
  llvm_Ch : ([64],[64],[64]) -> [64];
  llvm_Ch <- extract_llvm "sha384.bc" "Ch" pure;

  /* We can state a simple theorem that the Cryptol and LLVM
   * implementations are equivalent. */
  llvm_cryptol_Ch : ([64],[64],[64]) -> Bit;
  let llvm_cryptol_Ch (x, y, z) =
    cryptol_Ch(x, y, z) == llvm_Ch(x, y, z);

  /* We can also use SAWScript1-style specification blocks (which are
   * necessary for more complex functions). Here we prove that the LLVM
   * Ch implementation is equivalent to the model we just extracted from
   * it. Should be obviously true. :)
   *
   * For the moment, we're ignoring the complication that Ch is a macro.
   * TODO: address this.
   */
  llvm_Ch_result_trivial <- verify_llvm "sha384.bc" "Ch" (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    returns llvm_Ch(from_llvm(x), from_llvm(y), from_llvm(z));
    verify rewrite;
  });

  /* Here we prove that the LLVM Ch impelementation is equivalent to the
   * Cryptol version.
   */
  llvm_Ch_result <- llvm_verify (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    /* Alternatively: x <- argLLVM 0 (llvm_int 64) */
    returns cryptol_Ch(from_llvm(x), from_llvm(y), from_llvm(z));
    verify abc;
  });
  show_result llvm_Ch_result;

  /* TODO: similar code for LLVM Maj, UpperSigma_*, and LowerSigma_*. */

  llvm_Block512_W_result <- llvm_verify "sha384.bc" (do {
    w2  <- llvm_var "w2" (llvm_int 64);
    w7  <- llvm_var "w7" (llvm_int 64);
    w15 <- llvm_var "w15" (llvm_int 64);
    w16 <- llvm_var "w16" (llvm_int 64);

    /* Use the following equivalence proofs to override calls. */
    override [llvm_S0_result, llvm_S1_result];

    /* In the result, leave these functions uninterpreted. */
    uninterpret ["LowerSigma_0", "LowerSigma_1"];

    returns cryptol_Block512_W(w2, w7, w15, w16);
    verify abc;
  });

  llvm_sha384_init_result <- verify_llvm "sha384.bc" "sha384_init" (do {
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ from_llvm (llvm_field ctx "h0")
              , from_llvm (llvm_field ctx "h1")
              , from_llvm (llvm_field ctx "h2")
              , from_llvm (llvm_field ctx "h3")
              , from_llvm (llvm_field ctx "h4")
              , from_llvm (llvm_field ctx "h5")
              , from_llvm (llvm_field ctx "h6")
              , from_llvm (llvm_field ctx "h7")
              ]
    ensure from_llvm (llvm_field ctx "nblocks") == 0;
    ensure from_llvm (llvm_field ctx "count") == 0;
    ensure res == cryptol_sha384_init;
  });

  llvm_sha384_init <- extract_llvm "sha384.bc" "sha384_init" (do {
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ from_llvm (llvm_field ctx "h0")
              , from_llvm (llvm_field ctx "h1")
              , from_llvm (llvm_field ctx "h2")
              , from_llvm (llvm_field ctx "h3")
              , from_llvm (llvm_field ctx "h4")
              , from_llvm (llvm_field ctx "h5")
              , from_llvm (llvm_field ctx "h6")
              , from_llvm (llvm_field ctx "h7")
              ]
    /* These are checked after symbolic simulation, but before returning
     * a model.
     */
    ensure from_llvm (llvm_field ctx "nblocks") == 0;
    ensure from_llvm (llvm_field ctx "count") == 0;
    
    /* This tells us what model to return. No "input" clauses means
     * it'll be a constant. */
    output res;
  });
};
