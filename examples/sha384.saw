import prelude;

main = do {

  /* Cryptol extraction is straightforward. Initially, it'll go through
   * SBV, but later it'll be a direct compilation. We allow "[x]y" as
   * sugar for "Array x y", where "y" defaults to "Bit". The last parameter
   * consists of a simulator setup block, and for most Cryptol code this can
   * be "pure". The "extract_*" functions automatically coerce from target
   * language types into internal types.
   */
  cryptol_Ch : ([64],[64],[64]) -> [64];
  cryptol_Ch <- extract_cryptol "SHA384.cry" "Ch" sbv;

  cryptol_Maj : ([64],[64],[64]) -> [64];
  cryptol_Maj <- extract_cryptol "SHA384.cry" "Maj" sbv;

  cryptol_UpperSigma_0 : [64] -> [64];
  cryptol_UpperSigma_0 <- extract_cryptol "SHA384.cry" "UpperSigma_0" sbv;

  cryptol_UpperSigma_1 : [64] -> [64];
  cryptol_UpperSigma_1 <- extract_cryptol "SHA384.cry" "UpperSigma_1" sbv;

  cryptol_LowerSigma_0 : [64] -> [64];
  cryptol_LowerSigma_0 <- extract_cryptol "SHA384.cry" "LowerSigma_0" sbv;

  cryptol_LowerSigma_1 : [64] -> [64];
  cryptol_LowerSigma_1 <- extract_cryptol "SHA384.cry" "LowerSigma_1" sbv;

  cryptol_Block512_T1 : [6][64] -> [64];
  cryptol_Block512_T1 <- extract_cryptol "SHA384-Ops.cry" "Block512_T1"
    (do { sbv; uninterpret ["UpperSigma_1", "Ch"]; })

  cryptol_Block512_T2 : [3][64] -> [64];
  cryptol_Block512_T2 <- extract_cryptol "SHA384-Ops.cry" "Block512_T2"
    (do { sbv; uninterpret ["LowerSigma_1", "LowerSigma_0"]; })

  cryptol_Block512_W : [4][64] -> [64];
  cryptol_Block512_W <- extract_cryptol "SHA384-Ops.cry" "Block512_W"
    (do { sbv; uninterpret ["LowerSigma_0", "LowerSigma_1"]; })

  cryptol_Block512_Inner : ([80][64], [9][64]) -> [9][64];
  cryptol_Block512_Inner <- extract_cryptol "SHA384-Ops.cry" "Block512_Inner"
    (do { sbv; uninterpret ["Block512_T1", "Block512_T2"]; })

  cryptol_Transform : ([8][64], [16][64]) -> [8][64];
  cryptol_Transform <- extract_cryptol "SHA384-Ops.cry" "Transform"
    (do { sbv; uninterpret ["Block512_Inner", "Block512_W"] })

  cryptol_sha384_init : [8][64];
  cryptol_sha384_init <- extract_cryptol "SHA384.cry" "iv384" sbv;

  cryptol_block512 : ([8][64], [16][64]) -> [8][64];
  cryptol_block512 <- extract_cryptol "SHA384.cry" "block512"
    (do { sbv ; uninterpret ["LowerSigma_0", "LowerSigma_1",
                             "UpperSigma_0", "UpperSigma_1", "Ch", "Maj"] })


  /* Since Ch is such a simple function, we can extract it directly
   * from an LLVM implementation without any fuss. */
  llvm_Ch : ([64],[64],[64]) -> [64];
  llvm_Ch <- extract_llvm "sha384.bc" "Ch" pure_llvm;

  /* Same for some others. */
  llvm_Maj : ([64],[64],[64]) -> [64];
  llvm_Maj <- extract_llvm "sha384.bc" "Maj" pure_llvm;
  llvm_Sum0 : ([64]) -> [64];
  llvm_Sum0 <- extract_llvm "sha384.bc" "Sum0" pure_llvm;
  llvm_Sum1 : ([64]) -> [64];
  llvm_Sum1 <- extract_llvm "sha384.bc" "Sum1" pure_llvm;
  llvm_ROTR : ([64], [64]) -> [64];
  llvm_ROTR <- extract_llvm "sha384.bc" "ROTR" pure_llvm;

  /* We can state a simple theorem that the Cryptol and LLVM
   * implementations are equivalent. */
  llvm_cryptol_Ch : ([64],[64],[64]) -> Bit;
  let llvm_cryptol_Ch (x, y, z) = cryptol_Ch(x, y, z) == llvm_Ch(x, y, z);

  llvm_cryptol_Maj : ([64],[64],[64]) -> Bit;
  let llvm_cryptol_Maj (x, y, z) = cryptol_Maj(x, y, z) == llvm_Maj(x, y, z);

  llvm_cryptol_UpperSigma0 : ([64]) -> Bit;
  let llvm_cryptol_UpperSigma0 (x) = cryptol_UpperSigma0(x) == llvm_Sum0(x);

  llvm_cryptol_UpperSigma1 : ([64]) -> Bit;
  let llvm_cryptol_UpperSigma1 (x) = cryptol_UpperSigma1(x) == llvm_Sum1(x);

  prove llvm_cryptol_Ch abc;
  prove llvm_cryptol_Maj abc;
  prove llvm_cryptol_UpperSigma0 abc;
  prove llvm_cryptol_UpperSigma1 abc;

  /* We can also use SAWScript1-style specification blocks (which are
   * necessary for more complex functions). Here we prove that the LLVM
   * Ch implementation is equivalent to the model we just extracted from
   * it. Should be obviously true. :)
   */
  llvm_Ch_result_trivial <- verify_llvm "sha384.bc" "Ch" (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    returns llvm_Ch(from_llvm(x), from_llvm(y), from_llvm(z));
    verify rewrite;
  });

  /* Here we prove that the LLVM Ch impelementation is equivalent to the
   * Cryptol version.
   */
  llvm_Ch_result <- llvm_verify (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    /* Alternatively: x <- argLLVM 0 (llvm_int 64) */
    return_llvm cryptol_Ch(from_llvm(x), from_llvm(y), from_llvm(z));
    verify_llvm abc;
  });
  show_result llvm_Ch_result;

  /* TODO: similar code for LLVM Maj, UpperSigma_*, and LowerSigma_*. */

  /* For more complex functions, specification blocks can be necessary. */
  llvm_Block512_W_result <- llvm_verify "sha384.bc" "Block512_W" (do {
    w2  <- llvm_var "w2" (llvm_int 64);
    w7  <- llvm_var "w7" (llvm_int 64);
    w15 <- llvm_var "w15" (llvm_int 64);
    w16 <- llvm_var "w16" (llvm_int 64);

    /* Use the following equivalence proofs to override calls. */
    override_llvm [llvm_S0_result, llvm_S1_result];

    /* In the result, leave these functions uninterpreted. */
    uninterpret_llvm ["LowerSigma_0", "LowerSigma_1"];

    return_llvm cryptol_Block512_W(from_llvm(w2), from_llvm(w7),
                               from_llvm(w15), from_llvm(w16));
    verify_llvm abc;
  });

  llvm_sha384_init_result <- verify_llvm "sha384.bc" "sha384_init" (do {
    /* We can refer to arguments by number, in case debug info isn't
     * available. Also, any pointer variables are allocated to point
     * to an instance of the appropriate type, recursively, unless
     * stated otherwise (and we currently don't have a way to state
     * otherwise). All pointers point to distinct objects unless
     * a may_alias statement says otherwise.
     */
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ from_llvm (llvm_field ctx "h0")
              , from_llvm (llvm_field ctx "h1")
              , from_llvm (llvm_field ctx "h2")
              , from_llvm (llvm_field ctx "h3")
              , from_llvm (llvm_field ctx "h4")
              , from_llvm (llvm_field ctx "h5")
              , from_llvm (llvm_field ctx "h6")
              , from_llvm (llvm_field ctx "h7")
              ]
    ensure_equal_llvm (llvm_field ctx "nblocks") 0;
    ensure_equal_llvm (llvm_field ctx "count") 0;
    ensure_llvm (res == cryptol_sha384_init);
  });

  llvm_sha384_init <- extract_llvm "sha384.bc" "sha384_init" (do {
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ from_llvm (llvm_field ctx "h0")
              , from_llvm (llvm_field ctx "h1")
              , from_llvm (llvm_field ctx "h2")
              , from_llvm (llvm_field ctx "h3")
              , from_llvm (llvm_field ctx "h4")
              , from_llvm (llvm_field ctx "h5")
              , from_llvm (llvm_field ctx "h6")
              , from_llvm (llvm_field ctx "h7")
              ]
    /* These are checked after symbolic simulation, but before returning
     * a model.
     */
    ensure_equal_llvm (llvm_field ctx "nblocks") 0;
    ensure_equal_llvm (llvm_field ctx "count") 0;
    
    /* This tells us what model to return. No "input" clauses means
     * it'll be a constant. */
    output_llvm res;
  });
};
