import prelude;
import cryptol_prelude as Cryptol;
import java_prelude as Java;
import llvm_prelude as LLVM;

main = do {

  /* Cryptol extraction is straightforward. Initially, it'll go through
   * SBV, but later it'll be a direct compilation. We allow "[x]y" as
   * sugar for "Array x y", where "y" defaults to "Bit". The last parameter
   * consists of a simulator setup block, and for most Cryptol code this can
   * be "pure". The "extract" functions automatically coerce from target
   * language types into internal types.
   */
  cryptol_Ch : ([64],[64],[64]) -> [64];
  cryptol_Ch <- Cryptol.extract "SHA384.cry" "Ch" sbv;

  cryptol_Maj : ([64],[64],[64]) -> [64];
  cryptol_Maj <- Cryptol.extract "SHA384.cry" "Maj" sbv;

  cryptol_UpperSigma_0 : [64] -> [64];
  cryptol_UpperSigma_0 <- Cryptol.extract "SHA384.cry" "UpperSigma_0" sbv;

  cryptol_UpperSigma_1 : [64] -> [64];
  cryptol_UpperSigma_1 <- Cryptol.extract "SHA384.cry" "UpperSigma_1" sbv;

  cryptol_LowerSigma_0 : [64] -> [64];
  cryptol_LowerSigma_0 <- Cryptol.extract "SHA384.cry" "LowerSigma_0" sbv;

  cryptol_LowerSigma_1 : [64] -> [64];
  cryptol_LowerSigma_1 <- Cryptol.extract "SHA384.cry" "LowerSigma_1" sbv;

  cryptol_Block512_T1 : [6][64] -> [64];
  cryptol_Block512_T1 <- extract "SHA384-Ops.cry" "Block512_T1"
    (do { Cryptol.sbv; Cryptol.uninterpret ["UpperSigma_1", "Ch"]; })

  cryptol_Block512_T2 : [3][64] -> [64];
  cryptol_Block512_T2 <- extract "SHA384-Ops.cry" "Block512_T2"
    (do { Cryptol.sbv; Cryptol.uninterpret ["LowerSigma_1", "LowerSigma_0"]; })

  cryptol_Block512_W : [4][64] -> [64];
  cryptol_Block512_W <- extract "SHA384-Ops.cry" "Block512_W"
    (do { Cryptol.sbv; Cryptol.uninterpret ["LowerSigma_0", "LowerSigma_1"]; })

  cryptol_Block512_Inner : ([80][64], [9][64]) -> [9][64];
  cryptol_Block512_Inner <- extract "SHA384-Ops.cry" "Block512_Inner"
    (do { Cryptol.sbv; Cryptol.uninterpret ["Block512_T1", "Block512_T2"]; })

  cryptol_Transform : ([8][64], [16][64]) -> [8][64];
  cryptol_Transform <- extract "SHA384-Ops.cry" "Transform"
    (do { Cryptol.sbv; Cryptol.uninterpret ["Block512_Inner", "Block512_W"] })

  cryptol_sha384_init : [8][64];
  cryptol_sha384_init <- Cryptol.extract "SHA384.cry" "iv384" Cryptol.sbv;

  cryptol_block512 : ([8][64], [16][64]) -> [8][64];
  cryptol_block512 <- Cryptol.extract "SHA384.cry" "block512"
    (do { Cryptol.sbv 
        ; Cryptol.uninterpret ["LowerSigma_0", "LowerSigma_1",
                               "UpperSigma_0", "UpperSigma_1", "Ch", "Maj"]
        })


  /* Since Ch is such a simple function, we can extract it directly
   * from an LLVM implementation without any fuss. */
  llvm_Ch : ([64],[64],[64]) -> [64];
  llvm_Ch <- LLVM.extract_llvm "sha384.bc" "Ch" LLVM.pure_llvm;

  /* Same for some others. */
  llvm_Maj : ([64],[64],[64]) -> [64];
  llvm_Maj <- LLVM.extract_llvm "sha384.bc" "Maj" LLVM.pure_llvm;
  llvm_Sum0 : ([64]) -> [64];
  llvm_Sum0 <- LLVM.extract_llvm "sha384.bc" "Sum0" LLVM.pure_llvm;
  llvm_Sum1 : ([64]) -> [64];
  llvm_Sum1 <- LLVM.extract_llvm "sha384.bc" "Sum1" LLVM.pure_llvm;
  llvm_ROTR : ([64], [64]) -> [64];
  llvm_ROTR <- LLVM.extract_llvm "sha384.bc" "ROTR" LLVM.pure_llvm;

  /* We can state a simple theorem that the Cryptol and LLVM
   * implementations are equivalent. */
  llvm_cryptol_Ch : ([64],[64],[64]) -> Bit;
  let llvm_cryptol_Ch (x, y, z) = cryptol_Ch(x, y, z) == llvm_Ch(x, y, z);

  llvm_cryptol_Maj : ([64],[64],[64]) -> Bit;
  let llvm_cryptol_Maj (x, y, z) = cryptol_Maj(x, y, z) == llvm_Maj(x, y, z);

  llvm_cryptol_UpperSigma0 : ([64]) -> Bit;
  let llvm_cryptol_UpperSigma0 (x) = cryptol_UpperSigma0(x) == llvm_Sum0(x);

  llvm_cryptol_UpperSigma1 : ([64]) -> Bit;
  let llvm_cryptol_UpperSigma1 (x) = cryptol_UpperSigma1(x) == llvm_Sum1(x);

  prove llvm_cryptol_Ch abc;
  prove llvm_cryptol_Maj abc;
  prove llvm_cryptol_UpperSigma0 abc;
  prove llvm_cryptol_UpperSigma1 abc;

  /* We can also use SAWScript1-style specification blocks (which are
   * necessary for more complex functions). Here we prove that the LLVM
   * Ch implementation is equivalent to the model we just extracted from
   * it. Should be obviously true. :)
   */
  llvm_Ch_result_trivial <- LLVM.verify "sha384.bc" "Ch" (do {
    x <- LLVM.var "x" (LLVM.int 64);
    y <- LLVM.var "y" (LLVM.int 64);
    z <- LLVM.var "z" (LLVM.int 64);
    LLVM.return llvm_Ch(LLVM.from(x), LLVM.from(y), LLVM.from(z));
    LLVM.verify rewrite;
  });

  /* Here we prove that the LLVM Ch impelementation is equivalent to the
   * Cryptol version.
   */
  llvm_Ch_result <- LLVM.verify (do {
    x <- LLVM.var "x" (LLVM.int 64);
    y <- LLVM.var "y" (LLVM.int 64);
    z <- LLVM.var "z" (LLVM.int 64);
    /* Alternatively: x <- LLVM.arg 0 (llvm_int 64) */
    LLVM.return cryptol_Ch(LLVM.from(x), LLVM.from(y), LLVM.from(z));
    LLVM.verify abc;
  });
  show_result llvm_Ch_result;

  /* TODO: similar code for LLVM Maj, UpperSigma_*, and LowerSigma_*. */

  /* For more complex functions, specification blocks can be necessary. */
  llvm_Block512_W_result <- LLVM.verify "sha384.bc" "Block512_W" (do {
    w2  <- LLVM.var "w2" (LLVM.int 64);
    w7  <- LLVM.var "w7" (LLVM.int 64);
    w15 <- LLVM.var "w15" (LLVM.int 64);
    w16 <- LLVM.var "w16" (LLVM.int 64);

    /* Use the following equivalence proofs to override calls. */
    LLVM.override [llvm_S0_result, llvm_S1_result];

    /* In the result, leave these functions uninterpreted. */
    LLVM.uninterpret ["LowerSigma_0", "LowerSigma_1"];

    LLVM.return cryptol_Block512_W(LLVM.from(w2), LLVM.from(w7),
                                   LLVM.from(w15), LLVM.from(w16));
    LLVM.verify abc;
  });

  llvm_sha384_init_result <- LLVM.verify "sha384.bc" "sha384_init" (do {
    /* We can refer to arguments by number, in case debug info isn't
     * available. Also, any pointer variables are allocated to point
     * to an instance of the appropriate type, recursively, unless
     * stated otherwise (and we currently don't have a way to state
     * otherwise). All pointers point to distinct objects unless
     * a may_alias statement says otherwise.
     */
    ctx <- LLVM.arg 0 (LLVM.ptr (LLVM.struct "SHA512_CONTEXT"));
    let res = [ LLVM.from (LLVM.field ctx "h0")
              , LLVM.from (LLVM.field ctx "h1")
              , LLVM.from (LLVM.field ctx "h2")
              , LLVM.from (LLVM.field ctx "h3")
              , LLVM.from (LLVM.field ctx "h4")
              , LLVM.from (LLVM.field ctx "h5")
              , LLVM.from (LLVM.field ctx "h6")
              , LLVM.from (LLVM.field ctx "h7")
              ]
    LLVM.ensure_equal (LLVM.field ctx "nblocks") 0;
    LLVM.ensure_equal (LLVM.field ctx "count") 0;
    LLVM.ensure (res == cryptol_sha384_init);
  });

  llvm_sha384_init <- LLVM.extract "sha384.bc" "sha384_init" (do {
    ctx <- LLVM.arg 0 (LLVM.ptr (LLVM.struct "SHA512_CONTEXT"));
    let res = [ LLVM.from (LLVM.field ctx "h0")
              , LLVM.from (LLVM.field ctx "h1")
              , LLVM.from (LLVM.field ctx "h2")
              , LLVM.from (LLVM.field ctx "h3")
              , LLVM.from (LLVM.field ctx "h4")
              , LLVM.from (LLVM.field ctx "h5")
              , LLVM.from (LLVM.field ctx "h6")
              , LLVM.from (LLVM.field ctx "h7")
              ]
    /* These are checked after symbolic simulation, but before returning
     * a model.
     */
    LLVM.ensure_equal (LLVM.field ctx "nblocks") 0;
    LLVM.ensure_equal (LLVM.field ctx "count") 0;
    
    /* This tells us what model to return. No "input" clauses means
     * it'll be a constant. */
    LLVM.output res;
  });
};
