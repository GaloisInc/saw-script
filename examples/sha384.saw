import prelude;
import cryptol_prelude;
import java_prelude;
import llvm_prelude;

main = do {

  /* Cryptol extraction is straightforward. Initially, it'll go through
   * SBV, but later it'll be a direct compilation. We allow "[x]y" as
   * sugar for "Array x y", where "y" defaults to "Bit". The last parameter
   * consists of a simulator setup block, and for most Cryptol code this can
   * be "pure". The "extract" functions automatically coerce from target
   * language types into internal types.
   */
  cryptol_Ch : ([64], [64], [64] ) -> [64];
  cryptol_Ch <- cryptol_extract "SHA384.cry" "Ch" sbv;

  cryptol_Maj : ([64],[64],[64]) -> [64];
  cryptol_Maj <- cryptol_extract "SHA384.cry" "Maj" sbv;

  cryptol_UpperSigma_0 : [64] -> [64];
  cryptol_UpperSigma_0 <- cryptol_extract "SHA384.cry" "UpperSigma_0" sbv;

  cryptol_UpperSigma_1 : [64] -> [64];
  cryptol_UpperSigma_1 <- cryptol_extract "SHA384.cry" "UpperSigma_1" sbv;

  cryptol_LowerSigma_0 : [64] -> [64];
  cryptol_LowerSigma_0 <- cryptol_extract "SHA384.cry" "LowerSigma_0" sbv;

  cryptol_LowerSigma_1 : [64] -> [64];
  cryptol_LowerSigma_1 <- cryptol_extract "SHA384.cry" "LowerSigma_1" sbv;

  cryptol_Block512_T1 : [6][64] -> [64];
  cryptol_Block512_T1 <- extract "SHA384-Ops.cry" "Block512_T1"
    (do { sbv; cryptol_uninterpret ["UpperSigma_1", "Ch"]; });

  cryptol_Block512_T2 : [3][64] -> [64];
  cryptol_Block512_T2 <- extract "SHA384-Ops.cry" "Block512_T2"
    (do { sbv; cryptol_uninterpret ["LowerSigma_1", "LowerSigma_0"]; });

  cryptol_Block512_W : [4][64] -> [64];
  cryptol_Block512_W <- extract "SHA384-Ops.cry" "Block512_W"
    (do { sbv; cryptol_uninterpret ["LowerSigma_0", "LowerSigma_1"]; });

  cryptol_Block512_Inner : ([80][64], [9][64]) -> [9][64];
  cryptol_Block512_Inner <- extract "SHA384-Ops.cry" "Block512_Inner"
    (do { sbv; cryptol_uninterpret ["Block512_T1", "Block512_T2"]; });

  cryptol_Transform : ([8][64], [16][64]) -> [8][64];
  cryptol_Transform <- extract "SHA384-Ops.cry" "Transform"
    (do { sbv; cryptol_uninterpret ["Block512_Inner", "Block512_W"]; });

  cryptol_sha384_init : [8][64];
  cryptol_sha384_init <- cryptol_extract "SHA384.cry" "iv384" sbv;

  cryptol_block512 : ([8][64], [16][64]) -> [8][64];
  cryptol_block512 <- cryptol_extract "SHA384.cry" "block512" (do {
    sbv;
    cryptol_uninterpret ["LowerSigma_0", "LowerSigma_1",
                         "UpperSigma_0", "UpperSigma_1", "Ch", "Maj"];
  });


  /* Since Ch is such a simple function, we can extract it directly
   * from an LLVM implementation without any fuss. */
  llvm_Ch : ([64],[64],[64]) -> [64];
  llvm_Ch <- llvm_extract_llvm "sha384.bc" "Ch" llvm_pure_llvm;

  /* Same for some others. */
  llvm_Maj : ([64],[64],[64]) -> [64];
  llvm_Maj <- llvm_extract_llvm "sha384.bc" "Maj" llvm_pure_llvm;
  llvm_Sum0 : ([64]) -> [64];
  llvm_Sum0 <- llvm_extract_llvm "sha384.bc" "Sum0" llvm_pure_llvm;
  llvm_Sum1 : ([64]) -> [64];
  llvm_Sum1 <- llvm_extract_llvm "sha384.bc" "Sum1" llvm_pure_llvm;
  llvm_ROTR : ([64], [64]) -> [64];
  llvm_ROTR <- llvm_extract_llvm "sha384.bc" "ROTR" llvm_pure_llvm;

  /* We can state a simple theorem that the Cryptol and LLVM
   * implementations are equivalent. */
  llvm_cryptol_Ch : ([64],[64],[64]) -> Bit;
  // TODO: Don't yet have pattern matching.
  //let llvm_cryptol_Ch (x, y, z) = cryptol_Ch(x, y, z) == llvm_Ch(x, y, z);

  llvm_cryptol_Maj : ([64],[64],[64]) -> Bit;
  //let llvm_cryptol_Maj (x, y, z) = cryptol_Maj(x, y, z) == llvm_Maj(x, y, z);

  llvm_cryptol_UpperSigma0 : [64] -> Bit;
  let llvm_cryptol_UpperSigma0 x = (cryptol_UpperSigma0 x) == (llvm_Sum0 x);

  llvm_cryptol_UpperSigma1 : [64] -> Bit;
  let llvm_cryptol_UpperSigma1 x = cryptol_UpperSigma1 x == llvm_Sum1 x;

  prove llvm_cryptol_Ch abc;
  prove llvm_cryptol_Maj abc;
  prove llvm_cryptol_UpperSigma0 abc;
  prove llvm_cryptol_UpperSigma1 abc;

  /* We can also use SAWScript1-style specification blocks (which are
   * necessary for more complex functions). Here we prove that the LLVM
   * Ch implementation is equivalent to the model we just extracted from
   * it. Should be obviously true. :)
   */
  llvm_Ch_result_trivial <- llvm_verify "sha384.bc" "Ch" (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    llvm_return llvm_Ch(llvm_from x, llvm_from y, llvm_from z);
    llvm_verify rewrite;
  });

  /* Here we prove that the LLVM Ch impelementation is equivalent to the
   * Cryptol version.
   */
  llvm_Ch_result <- llvm_verify (do {
    x <- llvm_var "x" (llvm_int 64);
    y <- llvm_var "y" (llvm_int 64);
    z <- llvm_var "z" (llvm_int 64);
    /* Alternatively: x <- llvm_arg 0 (llvm_int 64) */
    llvm_return cryptol_Ch(llvm_from(x), llvm_from(y), llvm_from(z));
    llvm_verify abc;
  });
  show_result llvm_Ch_result;

  /* TODO: similar code for LLVM Maj, UpperSigma_*, and LowerSigma_*. */

  /* For more complex functions, specification blocks can be necessary. */
  llvm_Block512_W_result <- llvm_verify "sha384.bc" "Block512_W" (do {
    w2  <- llvm_var "w2" (llvm_int 64);
    w7  <- llvm_var "w7" (llvm_int 64);
    w15 <- llvm_var "w15" (llvm_int 64);
    w16 <- llvm_var "w16" (llvm_int 64);

    /* Use the following equivalence proofs to override calls. */
    llvm_override [llvm_S0_result, llvm_S1_result];

    /* In the result, leave these functions uninterpreted. */
    llvm_uninterpret ["LowerSigma_0", "LowerSigma_1"];

    llvm_return cryptol_Block512_W(llvm_from(w2), llvm_from(w7),
                                   llvm_from(w15), llvm_from(w16));
    llvm_verify abc;
  });

  llvm_sha384_init_result <- llvm_verify "sha384.bc" "sha384_init" (do {
    /* We can refer to arguments by number, in case debug info isn't
     * available. Also, any pointer variables are allocated to point
     * to an instance of the appropriate type, recursively, unless
     * stated otherwise (and we currently don't have a way to state
     * otherwise). All pointers point to distinct objects unless
     * a may_alias statement says otherwise.
     */
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ llvm_from (llvm_field ctx "h0")
              , llvm_from (llvm_field ctx "h1")
              , llvm_from (llvm_field ctx "h2")
              , llvm_from (llvm_field ctx "h3")
              , llvm_from (llvm_field ctx "h4")
              , llvm_from (llvm_field ctx "h5")
              , llvm_from (llvm_field ctx "h6")
              , llvm_from (llvm_field ctx "h7")
              ]
    llvm_ensure_equal (llvm_field ctx "nblocks") 0;
    llvm_ensure_equal (llvm_field ctx "count") 0;
    llvm_ensure (res == cryptol_sha384_init);
  });

  llvm_sha384_init <- llvm_extract "sha384.bc" "sha384_init" (do {
    ctx <- llvm_arg 0 (llvm_ptr (llvm_struct "SHA512_CONTEXT"));
    let res = [ llvm_from (llvm_field ctx "h0")
              , llvm_from (llvm_field ctx "h1")
              , llvm_from (llvm_field ctx "h2")
              , llvm_from (llvm_field ctx "h3")
              , llvm_from (llvm_field ctx "h4")
              , llvm_from (llvm_field ctx "h5")
              , llvm_from (llvm_field ctx "h6")
              , llvm_from (llvm_field ctx "h7")
              ]
    /* These are checked after symbolic simulation, but before returning
     * a model.
     */
    llvm_ensure_equal (llvm_field ctx "nblocks") 0;
    llvm_ensure_equal (llvm_field ctx "count") 0;

    /* This tells us what model to return. No "input" clauses means
     * it'll be a constant. */
    llvm_output res;
  });
};
