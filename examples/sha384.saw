/* The top-level scope  of a file is simply a collection of
 * newline-delimited variable bindings.  Maybe have a command line
 * option that has the effect of wrapping an entire file in "main = do {
 * ... }" so that we can just have a list of commands without any clutter.
 */

/* The following abbreviations would probably be builtin, but are here
 * for illustration.
 */

/* Perform no setup action. Useful for setting up the simulator to
 * extracts models of simple functions from arguments to return values.
 */
pure = return ()

/* Java type synonyms, for convenience. Java and LLVM types will
 * automatically be converted to and from internal types, but names
 * familiar in the target language would be useful. Maybe, instead of
 * binding these at the top level, they'd be bound within the context of
 * a setup block. These type synonyms could, in some contexts, be useful
 * for LLVM, as well.
 */
long = Signed 64;
int = Signed 32;
char = Signed 16;
byte = Signed 8;

/* Built in: [n] = Unsigned n; */

import Cryptol "SHA384.cry" as cryptol_sha384;
import Java "org.bouncycastle.crypto.digests.SHA384Digest" as java_sha384;
import LLVM "SHA384.bc" as llvm_sha384;

main = do {
  // Cryptol imports. (Type annotations unnecessary, but helpful documentation.)

  /* Question: should these be commands, and declarative imports? May have both as options? */
  extractCryptol "SHA384.cry" "Ch" as cryptol_Ch : ([64], [64], [64]) -> [64];
  // Alternatively:
  // cryptol_Ch : ([64], [64], [64]) -> [64];
  // cryptol_Ch <- extractCryptol "SHA384.cry" "Ch";
  // Which is nicer?

  cryptol_Ch : ([64], [64], [64]) -> [64];
  cryptol_Ch <- extractCryptol cryptol_sha384.Ch;

  extractCryptol "SHA384.cry" "Maj" as cryptol_Maj : ([64], [64], [64]) -> [64];

  extractCryptol "SHA384.cry" "UpperSigma_0" as cryptol_Sum0 : [64] -> [64];

  extractCryptol "SHA384.cry" "UpperSigma_1" as cryptol_Sum1 : [64] -> [64];

  extractCryptol "SHA384.cry" "LowerSigma_0" as cryptol_Sigma0 : [64] -> [64];

  extractCryptol "SHA384.cry" "LowerSigma_1" as cryptol_Sigma1 : [64] -> [64];

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.K"
    pure as java_K : Array 80 long;

  extractCryptol "SHA384.cry" "block512"
    as cryptol_Block : (Array 8 [64], Array 16 [64]) -> Array 8 [64];

  // We can import constants as well as functions.
  extractCryptol "SHA384.cry" "Ks512" as cryptol_K : Array 80 [64];

  // Java imports. (Bouncy Castle)

  /* Pure methods, i.e. methods that just produce a return value as a
   * function of their inputs, can be imported with minimum fuss.
   */

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Ch"
    pure as java_Ch : (long, long, long) -> long;

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Maj"
    pure as java_Maj : (long, long, long) -> long;

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sum0"
    pure as java_Sum0 : long -> long;

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sum1"
    pure as java_Sum1 : long -> long;

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sigma0"
    pure as java_Sigma0 : long -> long;

  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sigma1"
    pure as java_Sigma1 : long -> long;

  extractJava java_sha384.processBlock (\x1 -> do {
    this.H1 := x1.H1;
    run;
    get [this.H1, this.H2, this.H3, this.H4];
  })

  extractJava java_sha384.processBlock {

      /* Double colons indicate foreign language types, with the
       * specific language determined by context. Variable type
       * specifications can refine the statically-declared types
       * of variables by specifying array sizes or subclasses. We
       * need to provide types for all Java variables we mention.
       */
      this :: org.bouncycastle.crypto.digests.SHA384Digest;
      this.H1 :: long;
      this.H2 :: long;
      this.H3 :: long;
      this.H4 :: long;
      this.H5 :: long;
      this.H6 :: long;
      this.H7 :: long;
      this.H8 :: long;
      this.W :: long[80];
      this.wOff :: long;
      this.byteCount1 :: long;
      this.byteCount2 :: long;

      input this.byteCount1, this.byteCount2;
      input this.H1, this.H2, this.H3, this.H4,
            this.H5, this.H6, this.H7, this.H8;
      input this.W;

      output this.byteCount1, this.byteCount2;
      output this.H1, this.H2, this.H3, this.H4,
             this.H5, this.H6, this.H7, this.H8;
      output this.W;
      modify this.wOff;

      /* The type declared below is convertible to the list of inputs
       * and outputs. We could be more direct and use a type like this:
       *   ( long, long
       *   , long, long, long, long, long, long, long, long
       *   , Array 80 long
       *   )
       */
  } as java_Block : (long, long, Array 8 long, Array 80 long) ->
                    (long, long, Array 8 long, Array 80 long);


  /* The 'spec' keyword here is used to differentiate it from a record.
   * The keyword isn't required when used inline in an 'extract' command.
   * It could also be declared at the top level, outside of main, without
   * requiring the 'let' keyword, as in Haskell.
   */
  let reset_spec = spec {
      this.H1 :: long;
      this.H2 :: long;
      this.H3 :: long;
      this.H4 :: long;
      this.H5 :: long;
      this.H6 :: long;
      this.H7 :: long;
      this.H8 :: long;
      this.xBuf :: byte[8];
      this.xBufOff :: long;
      this.W :: long[80];
      this.wOff :: long;
      output this.H1, this.H2, this.H3, this.H4,
             this.H5, this.H6, this.H7, this.H8;
      modify this.xBufOff, this.xBuf;
      modify this.wOff, this.W;
  }

  let reset_verify_spec = spec {
      this.H1 :: long;
      this.H2 :: long;
      this.H3 :: long;
      this.H4 :: long;
      this.H5 :: long;
      this.H6 :: long;
      this.H7 :: long;
      this.H8 :: long;
      this.xBuf :: byte[8];
      this.xBufOff :: long;
      this.W :: long[80];
      this.wOff :: long;
      /* When an 'ensure' clause is present, it is translated to a
       * 1-bit output. If there are no 'modify' clauses, then extraction
       * with this spec results in a model that can be passed to 'prove'
       * or 'sat'. Definitions of refH1 to refH8 are omitted for brevity.
       * Expression is evaluated in final context.
       */
      output this.H1 == refH1 &&
             this.H2 == refH2 &&
             this.H3 == refH3 &&
             this.H4 == refH4 &&
             this.H5 == refH5 &&
             this.H6 == refH6 &&
             this.H7 == refH7 &&
             this.H8 == refH8;
      modify this.xBufOff, this.xBuf;
      modify this.wOff, this.W;

      /* It might be nice to allow this sort of syntax for inputs or
       * outputs, similar to the expression allowed by 'ensure'.
       */
      /*
      output ([ this.H1, this.H2, this.H3, this.H4
              , this.H5, this.H6. this.H7, this.H8
              ]);
      */
  }

  /* The result here is the value written by reset. */
  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.reset"
    reset_spec as java_H : Array 8 long;

  /* The result here is a bit representing whether reset writes the
   * expected value.
   */
  extractJava "org.bouncycastle.crypto.digests.SHA384Digest.reset"
    reset_verify_spec as java_H_valid : Bool;

  /* Returns one model for each aliasing configuration, and these
   * models may have different types.
   */
  extractJava "org.foo.AliasExample.m" {
      x :: int[16];
      y :: int[16];
      mayAlias {x, y};
      output x;
  } as java_foo : ( (Array 16 int, Array 16 int) -> Array 16 int
                  , Array 16 int -> Array 16 int
                  );

  /* Alternatively, we can add an "ensure" to check validity of all aliasing
   * configurations as one theorem. The configuration in which x and y are
   * aliased ignores the second input array.
   */
  extractJava "org.foo.AliasExample.m" {
      x :: int[16];
      y :: int[16];
      mayAlias {x, y};
      /* Imperative version of 'ensure'. LHS is evaluated in final context,
       * RHS is evaluated in initial context, like in original SAWScript.
       */
      ensure join(x) := join(x) + join(y);
  } as java_foo_valid : (Array 16 int, Array 16 int) -> Bool;


  // Other formats

  load AIG "Sum0.aig" as aig_Sum0 : [64] -> [64];

  load BTOR "Sum0.btor" as btor_Sum0 : [64] -> [64];

  // LLVM imports (libgcrypt).

  // Sigma0 and Sigma1 are macros. TODO: what's the best way to deal with this?

  // Pure functions in LLVM are similar to Java.
  extractLLVM "sha512.bc" "ROTR" pure as llvm_ROTR : ([64], [64]) -> [64];

  extractLLVM "sha512.bc" "Ch"
    pure as llvm_Ch : ([64], [64], [64]) -> [64];

  extractLLVM "sha512.bc" "Maj"
    pure as llvm_Maj : ([64], [64], [64]) -> [64];

  extractLLVM "sha512.bc" "Sum0" pure as llvm_Sum0 : [64] -> [64];

  extractLLVM "sha512.bc" "Sum1" pure as llvm_Sum1 : [64] -> [64];

  extractLLVM "sha512.bc" "transform" {
      hd :: long[8];
      data :: char[128];
      input hd;
      input data;
      output data;
  } as llvm_Block : (Array 8 long, Array 128 byte) -> Array 128 byte;

  extractLLVM "sha512.bc" "transform.k" as llvm_k : Array 80 long;

  // Theorems, properties, equivalences.

  /* Don't strictly need to have all three of these, but it's illustrative.
   * Functions of compatible types can be asserted to be equal without
   * mentioning input or output variables.
   */
  let llvm_cryptol_Ch = llvm_Ch == cryptol_Ch;
  /* llvm_cryptol_Ch has type ([64], [64], [64]) -> Bool */
  let java_cryptol_Ch = java_Ch == cryptol_Ch;
  let java_llvm_Ch = java_Ch == llvm_Ch;

  let aig_btor_Sum0 = aig_Sum0 == btor_sum0;

  /* TODO: want to be able to refer to counter-examples or satisfying
   * assignments. Also want to be able to specify quantifiers. Both
   * universal and existential quantification should be possible. Sean is
   * very keen on QBF lately, and we'd like to be able to talk to QBF
   * solvers.
   */

  // Proofs.

  let and_idem = forall (x :: Bool). x && x -> x;
  let or_idem = forall (x :: Bool). x || x -> x;
  let and_or_rules = [and_idem, or_idem];

  /* We can prove or check satisfiability of any term of type a -> Bool. */
  cex1 <- prove llvm_cryptol_Ch using {
      goal' <- rewrite goal using and_or_rules;
      yices goal';
  };
  cex2 <- prove aig_btor_Sum0 using abc;
  assgn <- sat java_llvm_Ch using picosat;
  /* The results, cex1, cex2, and assgn are algebraic data types. */

  // Exporting theorems ...
  export DIMACS llvm_cryptol_Ch "llvm_cryptol_Ch.cnf";

  // ... or models
  export AIG llvm_Ch "llvm_Ch.aig";

  // Rewriting models without immediately proving or exporting
  llvm_Ch' <- rewrite llvm_Ch;

  // Rewriting with specific options, such as choice of rewrite rules.

  // Rewrite only redundant "and" terms.
  llvm_Block' <- rewrite llvm_Block using [and_idem];

  // Rewrite redundant "and" and "or" terms.
  llvm_Transform' <- rewrite llvm_Transform using and_or_rules;
}
