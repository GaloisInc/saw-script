/* The top-level scope  of a file is simply a collection of
 * newline-delimited variable bindings.  Maybe have a command line
 * option that has the effect of wrapping an entire file in "main = do {
 * ... }" so that we can just have a list of commands without any clutter.
 */

/* The following abbreviations would probably be builtin, but are here
 * for illustration.
 */

/* Perform no setup action. Useful for setting up the simulator to
 * extracts models of simple functions from arguments to return values.
 */
let pure = return ();

/* Java type synonyms, for convenience. Java and LLVM types will
 * automatically be converted to and from internal types, but names
 * familiar in the target language would be useful. Maybe, instead of
 * binding these at the top level, they'd be bound within the context of
 * a setup block. These type synonyms could, in some contexts, be useful
 * for LLVM, as well.
 */
type long = Signed64;
type int  = Signed32;
type char = Signed16;
type byte = Signed8;

/* Built in: [n] = Unsigned n; */

let cryptol_sha384 = extract Cryptol "SHA384.cry"
and java_sha384    = extract Java "org.bouncycastle.crypto.digests.SHA384Digest"
and llvm_sha384    = extract LLVM "SHA384.bc";

let main = do { 
  // Cryptol imports. (Type annotations unnecessary, but helpful documentation.)

  /* Question: should these be commands, and declarative imports? May have both as options? */
  let cryptol_Ch = extract Cryptol "SHA384.cry" "Ch" : ([64], [64], [64]) -> [64];

  cryptol_Ch :: ([64], [64], [64]) -> [64];
  cryptol_Ch <- extractCryptol cryptol_sha384.Ch;

  let cryptol_Maj    = extractCryptol "SHA384.cry" "Maj" : ([64], [64], [64]) -> [64]
  and cryptol_Sum0   = extractCryptol "SHA384.cry" "UpperSigma_0" : [64] -> [64]
  and cryptol_Sum1   = extractCryptol "SHA384.cry" "UpperSigma_1" : [64] -> [64]
  and cryptol_Sigma0 = extractCryptol "SHA384.cry" "LowerSigma_0" : [64] -> [64]
  and cryptol_Sigma1 = extractCryptol "SHA384.cry" "LowerSigma_1" : [64] -> [64];

  let java_K = 
    extractJava "org.bouncycastle.crypto.digests.SHA384Digest.K" pure : [80] long;

  let cryptol_Block = 
    extractCryptol "SHA384.cry" "block512" : ([8][64],[16][64]) -> [8][64];

  // We can import constants as well as functions.
  let cryptol_K = extractCryptol "SHA384.cry" "Ks512" : [80][64];

  // Java imports. (Bouncy Castle)

  /* Pure methods, i.e. methods that just produce a return value as a
   * function of their inputs, can be imported with minimum fuss.
   */

  let java_Ch     = extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Ch" pure : (long, long, long) -> long
  and java_Maj    = extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Maj" pure : (long, long, long) -> long
  and java_Sum0   = extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sum0" pure : long -> long
  and java_Sum1   = extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sum1" pure : long -> long
  and java_Sigma0 = extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sigma0" pure : long -> long
  and java_Sigma1 = extractJava "org.bouncycastle.crypto.digests.SHA384Digest.Sigma1" pure : long -> long;

  extractJava java_sha384.processBlock (fun x1 -> do {
    this.H1 := x1.H1;
    run;
    get [this.H1, this.H2, this.H3, this.H4];
  });

  /* Double colons indicate foreign language types, with the
   * specific language determined by context. Variable type
   * specifications can refine the statically-declared types
   * of variables by specifying array sizes or subclasses. We
   * need to provide types for all Java variables we mention.
   */
  this :: org.bouncycastle.crypto.digests.SHA384Digest;
  this.H1 :: long;
  this.H2 :: long;
  this.H3 :: long;
  this.H4 :: long;
  this.H5 :: long;
  this.H6 :: long;
  this.H7 :: long;
  this.H8 :: long;
  this.W :: [80] long;
  this.wOff :: long;
  this.byteCount1 :: long;
  this.byteCount2 :: long;

  let java_Block : (long, long, [8] long, [80] long) -> (long, long,  [8] long, [80] long) 
    = extract Java java_sha384.processBlock do {

      input ["this.byteCount1", "this.byteCount2"];
      input ["this.H1", "this.H2", "this.H3", "this.H4",
             "this.H5", "this.H6", "this.H7", "this.H8"];
      input ["this.W"];
  
      output ["this.byteCount1", "this.byteCount2"];
      output ["this.H1", "this.H2", "this.H3", "this.H4",
              "this.H5", "this.H6", "this.H7", "this.H8"];
      output ["this.W"];
      modify ["this.wOff"];

      /* The type declared below is convertible to the list of inputs
       * and outputs. We could be more direct and use a type like this:
       *   ( long, long
       *   , long, long, long, long, long, long, long, long
       *   , Array 80 long
       *   )
       */
      };

   /* The 'spec' keyword here is used to differentiate it from a record.
   * The keyword isn't required when used inline in an 'extract' command.
   * It could also be declared at the top level, outside of main, without
   * requiring the 'let' keyword, as in Haskell.
   */
  let reset_spec = do {
      this.H1 :: long;
      this.H2 :: long;
      this.H3 :: long;
      this.H4 :: long;
      this.H5 :: long;
      this.H6 :: long;
      this.H7 :: long;
      this.H8 :: long;
      this.xBuf :: [8] byte;
      this.xBufOff :: long;
      this.W :: [80] long;
      this.wOff :: long;
      output [this.H1, this.H2, this.H3, this.H4,
              this.H5, this.H6, this.H7, this.H8];
      modify [this.xBufOff, this.xBuf];
      modify [this.wOff, this.W];
  };

  let reset_verify_spec = do {
      this.H1 :: long;
      this.H2 :: long;
      this.H3 :: long;
      this.H4 :: long;
      this.H5 :: long;
      this.H6 :: long;
      this.H7 :: long;
      this.H8 :: long;
      this.xBuf :: [8] byte;
      this.xBufOff :: long;
      this.W :: [80] long;
      this.wOff :: long;
      /* When an 'ensure' clause is present, it is translated to a
       * 1-bit output. If there are no 'modify' clauses, then extraction
       * with this spec results in a model that can be passed to 'prove'
       * or 'sat'. Definitions of refH1 to refH8 are omitted for brevity.
       * Expression is evaluated in final context.
       */
      output this.H1 == refH1 &&
             this.H2 == refH2 &&
             this.H3 == refH3 &&
             this.H4 == refH4 &&
             this.H5 == refH5 &&
             this.H6 == refH6 &&
             this.H7 == refH7 &&
             this.H8 == refH8;
      modify [this.xBufOff, this.xBuf];
      modify [this.wOff, this.W];

      /* It might be nice to allow this sort of syntax for inputs or
       * outputs, similar to the expression allowed by 'ensure'.
       */
      /*
      output ([ this.H1, this.H2, this.H3, this.H4
              , this.H5, this.H6. this.H7, this.H8
              ]);
      */
  };
};