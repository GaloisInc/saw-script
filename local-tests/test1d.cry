// test1d.cry

module Test1d where

// as in Test1b

enum Either a b = Left a
                | Right b

v_er1 : Either Bit [16]
v_er1 = Right 1

v_er1_p : {a} Either a [16]
v_er1_p = Right 1

v_el1 : Either Bit [16]
v_el1 = Left True

f1 e = case e of
        Right x -> x
        _       -> 0

/*
f1' : {c} Either c [8] -> [8]
f1' e = case e of
          Right x -> x
          _       -> 0
// RESULTS IN
//   Location:  importType TVBound: TV (a) is not in type environment
//                                  -- !
*/


f1NoDflt e = case e of
                 Right x -> x
                 Left _  -> 0

f1NoDflt' : {c} Either c [8] -> [8]
f1NoDflt' e = case e of
                Right x -> x
                Left _  -> 0

f2 y e = case e of
           Right x -> x
           _       -> y

f3 n = if n < 100 then n else 100


/*

f2 e = case e of
        Right x -> Right x
        _       -> _

[error] ...
    Value not in scope: _
good: AS WE EXPECT.
*/

/*
f3 e = case e of
        Right x -> x
        y       -> 0
  Message:   default case alternative that binds scrutinee is not supported.
  - a way to get location info?
*/
/*
f4 e = case e of
        Right x  -> Right x
        y       -> y
        // ERROR!
*/

t_f1_er1 = f1 v_er1
t_f1_el1 = f1 v_el1

t_f1_r = f1NoDflt (Right 1)
t_f1_l = f1NoDflt (Left True)

/*
return (type {{ f1 }})
return (type {{ t_f1_r }})
return (type {{ t_f1_l }})
return (normalize_term {{ t_f1_r }})
return (normalize_term {{ t_f1_l }})
*/

t_f1NoDflt_r = f1NoDflt (Right 1)
t_f1NoDflt_l = f1NoDflt (Left True)

/*
return (type {{ f1NoDflt }})
return (type {{ t_f1NoDflt_r }})
return (type {{ t_f1NoDflt_l }})
return (normalize_term {{ t_f1NoDflt_r }})
return (normalize_term {{ t_f1NoDflt_l }})
*/

/*
 - the types are ~confusing as we end up with various type constraints!
 - but AFAIK, types and values are good.
*/
