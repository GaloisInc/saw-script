 Loading file "test_cryptol_primitives.saw"

(** Mandatory imports from saw-core-coq *)
From Coq Require Import Lists.List.
From Coq Require Import String.
From Coq Require Import Vectors.Vector.
From CryptolToCoq Require Import SAWCoreScaffolding.
From CryptolToCoq Require Import SAWCoreVectorsAsCoqVectors.
Import VectorNotations.

(** Post-preamble section specified by you *)
From CryptolToCoq Require Import SAWCorePrelude.
Import SAWCorePrelude.
From CryptolToCoq Require Import SAWCorePreludeExtra.


(** Code generated by saw-core-coq *)

Module CryptolPrimitivesForSAWCore.

Definition const : forall (a : Type), forall (b : Type), forall (_1 : a), forall (_2 : b), a :=
  fun (a : Type) (b : Type) (x : a) (y : b) => x.

Definition compose : forall (a : Type), forall (b : Type), forall (c : Type), forall (_1 : forall (_1 : b), c), forall (_2 : forall (_2 : a), b), forall (_3 : a), c :=
  fun (a : Type) (b : Type) (c : Type) (f : forall (_1 : b), c) (g : forall (_1 : a), b) (x : a) => f (g x).

Definition bvExp : forall (n : Coq.Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool :=
  fun (n : Coq.Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.foldr Coq.Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) n (fun (b : Coq.Init.Datatypes.bool) (a : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) => let var__0   := SAWCoreVectorsAsCoqVectors.bvMul n a a in
  if b then SAWCoreVectorsAsCoqVectors.bvMul n x var__0 else var__0) (SAWCoreVectorsAsCoqVectors.bvNat n 1) (SAWCorePrelude.reverse n Coq.Init.Datatypes.bool y).

Definition updFst : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), a), forall (_2 : prod a b), prod a b :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), a) (x : prod a b) => pair (f (fst x)) (snd x).

Definition updSnd : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : b), b), forall (_2 : prod a b), prod a b :=
  fun (a : Type) (b : Type) (f : forall (_1 : b), b) (x : prod a b) => pair (fst x) (f (snd x)).

Inductive Num : Type :=
| TCNum : forall (_1 : Coq.Init.Datatypes.nat), Num
| TCInf : Num
.

Definition Num__rec : forall (p : forall (_1 : Num), Type), forall (_1 : forall (n : Coq.Init.Datatypes.nat), p (TCNum n)), forall (_2 : p TCInf), forall (n : Num), p n :=
  fun (p : forall (_1 : Num), Type) (f1 : forall (n : Coq.Init.Datatypes.nat), p (TCNum n)) (f2 : p TCInf) (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect p f1 f2 n.

Definition tcFin : forall (_1 : Num), Coq.Init.Datatypes.bool :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => Coq.Init.Datatypes.bool) (fun (n1 : Coq.Init.Datatypes.nat) => Coq.Init.Datatypes.true) Coq.Init.Datatypes.false n.

Definition getFinNat : forall (n : Num), Coq.Init.Datatypes.nat :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => Coq.Init.Datatypes.nat) (fun (n1 : Coq.Init.Datatypes.nat) => n1) (SAWCoreScaffolding.error Coq.Init.Datatypes.nat "Unexpected Fin constraint violation!"%string) n.

Definition finNumRec : forall (p : forall (_1 : Num), Type), forall {Inh_p : forall (_1 : Num), SAWCoreScaffolding.Inhabited (p _1)}, forall (_1 : forall (n : Coq.Init.Datatypes.nat), p (TCNum n)), forall (n : Num), p n :=
  fun (p : forall (_1 : Num), Type) {Inh_p : forall (_1 : Num), SAWCoreScaffolding.Inhabited (p _1)} (f : forall (n : Coq.Init.Datatypes.nat), p (TCNum n)) (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect p f (SAWCoreScaffolding.error (p TCInf) "Unexpected Fin constraint violation!"%string) n.

Definition finNumRec2 : forall (p : forall (_1 : Num), forall (_2 : Num), Type), forall {Inh_p : forall (_1 : Num), forall (_2 : Num), SAWCoreScaffolding.Inhabited (p _1 _2)}, forall (_1 : forall (m : Coq.Init.Datatypes.nat), forall (n : Coq.Init.Datatypes.nat), p (TCNum m) (TCNum n)), forall (m : Num), forall (n : Num), p m n :=
  fun (p : forall (_1 : Num), forall (_2 : Num), Type) {Inh_p : forall (_1 : Num), forall (_2 : Num), SAWCoreScaffolding.Inhabited (p _1 _2)} (f : forall (m : Coq.Init.Datatypes.nat), forall (n : Coq.Init.Datatypes.nat), p (TCNum m) (TCNum n)) => finNumRec (fun (m : Num) => forall (n : Num), p m n) (fun (m : Coq.Init.Datatypes.nat) => finNumRec (p (TCNum m)) (f m)).

Definition binaryNumFun : forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), Num), forall (_3 : forall (_3 : Coq.Init.Datatypes.nat), Num), forall (_4 : Num), forall (_5 : Num), forall (_6 : Num), Num :=
  fun (f1 : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat) (f2 : forall (_1 : Coq.Init.Datatypes.nat), Num) (f3 : forall (_1 : Coq.Init.Datatypes.nat), Num) (f4 : Num) (num1 : Num) (num2 : Num) => let var__0   := @CryptolPrimitivesForSAWCore.Num_rect in
  var__0 (fun (num1' : Num) => Num) (fun (n1 : Coq.Init.Datatypes.nat) => var__0 (fun (num2' : Num) => Num) (fun (n2 : Coq.Init.Datatypes.nat) => TCNum (f1 n1 n2)) (f2 n1) num2) (var__0 (fun (num2' : Num) => Num) f3 f4 num2) num1.

Definition ternaryNumFun : forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), forall (_3 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat), forall (_2 : Num), forall (_3 : Num), forall (_4 : Num), forall (_5 : Num), Num :=
  fun (f1 : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), forall (_3 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat) (f2 : Num) (num1 : Num) (num2 : Num) (num3 : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (num1' : Num) => Num) (fun (n1 : Coq.Init.Datatypes.nat) => @CryptolPrimitivesForSAWCore.Num_rect (fun (num2' : Num) => Num) (fun (n2 : Coq.Init.Datatypes.nat) => @CryptolPrimitivesForSAWCore.Num_rect (fun (num3' : Num) => Num) (fun (n3 : Coq.Init.Datatypes.nat) => TCNum (f1 n1 n2 n3)) f2 num3) f2 num2) f2 num1.

Definition tcWidth : forall (_1 : Num), Num :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => Num) (fun (x : Coq.Init.Datatypes.nat) => TCNum (SAWCoreScaffolding.widthNat x)) TCInf n.

Definition tcAdd : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun SAWCoreScaffolding.addNat (fun (x : Coq.Init.Datatypes.nat) => TCInf) (fun (y : Coq.Init.Datatypes.nat) => TCInf) TCInf.

Definition tcSub : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun SAWCorePrelude.subNat (fun (x : Coq.Init.Datatypes.nat) => TCNum 0) (fun (y : Coq.Init.Datatypes.nat) => TCInf) (TCNum 0).

Definition tcMul : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun SAWCoreScaffolding.mulNat (fun (x : Coq.Init.Datatypes.nat) => SAWCorePrelude.if0Nat Num x (TCNum 0) TCInf) (fun (y : Coq.Init.Datatypes.nat) => SAWCorePrelude.if0Nat Num y (TCNum 0) TCInf) TCInf.

Definition tcDiv : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun (fun (x : Coq.Init.Datatypes.nat) (y : Coq.Init.Datatypes.nat) => SAWCorePrelude.divNat x y) (fun (x : Coq.Init.Datatypes.nat) => TCNum 0) (fun (y : Coq.Init.Datatypes.nat) => TCInf) (TCNum 1).

Definition tcMod : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun (fun (x : Coq.Init.Datatypes.nat) (y : Coq.Init.Datatypes.nat) => SAWCorePrelude.modNat x y) (fun (x : Coq.Init.Datatypes.nat) => TCNum 0) (fun (y : Coq.Init.Datatypes.nat) => TCNum 0) (TCNum 0).

Definition tcExp : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun SAWCorePrelude.expNat (fun (x : Coq.Init.Datatypes.nat) => SAWCorePrelude.natCase (fun (_1 : Coq.Init.Datatypes.nat) => Num) (TCNum 0) (fun (x_minus_1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.if0Nat Num x_minus_1 (TCNum 1) TCInf) x) (fun (y : Coq.Init.Datatypes.nat) => SAWCorePrelude.if0Nat Num y (TCNum 1) TCInf) TCInf.

Definition tcMin : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun SAWCorePrelude.minNat (fun (x : Coq.Init.Datatypes.nat) => TCNum x) (fun (y : Coq.Init.Datatypes.nat) => TCNum y) TCInf.

Definition tcMax : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun SAWCorePrelude.maxNat (fun (x : Coq.Init.Datatypes.nat) => TCInf) (fun (y : Coq.Init.Datatypes.nat) => TCInf) TCInf.

Definition ceilDivNat : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat :=
  fun (x : Coq.Init.Datatypes.nat) (y : Coq.Init.Datatypes.nat) => SAWCorePrelude.divNat (SAWCoreScaffolding.addNat x (SAWCorePrelude.subNat y 1)) y.

Definition ceilModNat : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat :=
  fun (x : Coq.Init.Datatypes.nat) (y : Coq.Init.Datatypes.nat) => SAWCorePrelude.subNat (SAWCoreScaffolding.mulNat (ceilDivNat x y) y) x.

Definition tcCeilDiv : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun ceilDivNat (fun (x : Coq.Init.Datatypes.nat) => TCNum 0) (fun (y : Coq.Init.Datatypes.nat) => TCInf) TCInf.

Definition tcCeilMod : forall (_1 : Num), forall (_2 : Num), Num :=
  binaryNumFun ceilModNat (fun (x : Coq.Init.Datatypes.nat) => TCNum 0) (fun (y : Coq.Init.Datatypes.nat) => TCNum 0) TCInf.

Definition tcLenFromThenTo_Nat : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), forall (_3 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.nat :=
  fun (x : Coq.Init.Datatypes.nat) (y : Coq.Init.Datatypes.nat) (z : Coq.Init.Datatypes.nat) => if SAWCorePrelude.ltNat x y then if SAWCorePrelude.ltNat z x then 0 else SAWCoreScaffolding.addNat (SAWCorePrelude.divNat (SAWCorePrelude.subNat z x) (SAWCorePrelude.subNat y x)) 1 else if SAWCorePrelude.ltNat x z then 0 else SAWCoreScaffolding.addNat (SAWCorePrelude.divNat (SAWCorePrelude.subNat x z) (SAWCorePrelude.subNat x y)) 1.

Definition tcLenFromThenTo : forall (_1 : Num), forall (_2 : Num), forall (_3 : Num), Num :=
  ternaryNumFun tcLenFromThenTo_Nat TCInf.

Definition binaryNumPred : forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.bool), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.bool), forall (_3 : forall (_3 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.bool), forall (_4 : Coq.Init.Datatypes.bool), forall (_5 : Num), forall (_6 : Num), Coq.Init.Datatypes.bool :=
  fun (f1 : forall (_1 : Coq.Init.Datatypes.nat), forall (_2 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.bool) (f2 : forall (_1 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.bool) (f3 : forall (_1 : Coq.Init.Datatypes.nat), Coq.Init.Datatypes.bool) (f4 : Coq.Init.Datatypes.bool) (num1 : Num) (num2 : Num) => let var__0   := @CryptolPrimitivesForSAWCore.Num_rect in
  var__0 (fun (num1' : Num) => Coq.Init.Datatypes.bool) (fun (n1 : Coq.Init.Datatypes.nat) => var__0 (fun (num2' : Num) => Coq.Init.Datatypes.bool) (fun (n2 : Coq.Init.Datatypes.nat) => f1 n1 n2) (f2 n1) num2) (var__0 (fun (num2' : Num) => Coq.Init.Datatypes.bool) f3 f4 num2) num1.

Definition tcEqual : forall (_1 : Num), forall (_2 : Num), Coq.Init.Datatypes.bool :=
  binaryNumPred SAWCorePrelude.equalNat (fun (x : Coq.Init.Datatypes.nat) => Coq.Init.Datatypes.false) (fun (y : Coq.Init.Datatypes.nat) => Coq.Init.Datatypes.false) Coq.Init.Datatypes.true.

Definition tcLt : forall (_1 : Num), forall (_2 : Num), Coq.Init.Datatypes.bool :=
  binaryNumPred SAWCorePrelude.ltNat (fun (x : Coq.Init.Datatypes.nat) => Coq.Init.Datatypes.true) (fun (y : Coq.Init.Datatypes.nat) => Coq.Init.Datatypes.false) Coq.Init.Datatypes.true.

Definition seq : forall (_1 : Num), forall (_2 : Type), Type :=
  fun (num : Num) (a : Type) => @CryptolPrimitivesForSAWCore.Num_rect (fun (num1 : Num) => Type) (fun (n : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n a) (SAWCorePrelude.Stream a) num.

Definition seq_TCNum : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), @Coq.Init.Logic.eq Type (seq (TCNum n) a) (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) => @Coq.Init.Logic.eq_refl Type (SAWCoreVectorsAsCoqVectors.Vec n a).

Definition seq_TCInf : forall (a : Type), @Coq.Init.Logic.eq Type (seq TCInf a) (SAWCorePrelude.Stream a) :=
  fun (a : Type) => @Coq.Init.Logic.eq_refl Type (SAWCorePrelude.Stream a).

Definition seqMap : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall (n : Num), forall (_1 : forall (_1 : a), b), forall (_2 : seq n a), seq n b :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) (n : Num) (f : forall (_1 : a), b) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 a), seq n1 b) (SAWCorePrelude.map a b f) (SAWCorePrelude.streamMap a b f) n.

Definition seqConst : forall (n : Num), forall (a : Type), forall (_1 : a), seq n a :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall (_1 : a), seq n1 a) SAWCorePrelude.replicate SAWCorePrelude.streamConst n.

Definition seqInhabited : forall (n : Num), forall (a : Type), forall (x : a), seq n a :=
  CryptolPrimitivesForSAWCore.Num__rec (fun (n : Num) => forall (a : Type), forall (x : a), seq n a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) (x : a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : Coq.Init.Datatypes.nat) => x)) (fun (a : Type) (x : a) => SAWCorePrelude.MkStream a (fun (i : Coq.Init.Datatypes.nat) => x)).

Instance Inhabited_seq (n:Num) (a:Type) (Ha:Inhabited a) : Inhabited (seq n a) := MkInhabited (seq n a) (seqInhabited n a inhabitant).
Definition IntModNum : forall (num : Num), Type :=
  fun (num : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer num.

Definition Rational : Type :=
  unit : Type.

Definition ecRatio : forall (_1 : SAWCoreScaffolding.Integer), forall (_2 : SAWCoreScaffolding.Integer), Rational :=
  fun (x : SAWCoreScaffolding.Integer) (y : SAWCoreScaffolding.Integer) => tt.

Definition eqRational : forall (_1 : Rational), forall (_2 : Rational), Coq.Init.Datatypes.bool :=
  fun (x : unit : Type) (y : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: (==) Rational"%string.

Definition leRational : forall (_1 : Rational), forall (_2 : Rational), Coq.Init.Datatypes.bool :=
  fun (x : unit : Type) (y : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: (<=) Rational"%string.

Definition ltRational : forall (_1 : Rational), forall (_2 : Rational), Coq.Init.Datatypes.bool :=
  fun (x : unit : Type) (y : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: (<) Rational"%string.

Definition addRational : forall (_1 : Rational), forall (_2 : Rational), Rational :=
  fun (x : unit : Type) (y : unit : Type) => SAWCoreScaffolding.error Rational "Unimplemented: (+) Rational"%string.

Definition subRational : forall (_1 : Rational), forall (_2 : Rational), Rational :=
  fun (x : unit : Type) (y : unit : Type) => SAWCoreScaffolding.error Rational "Unimplemented: (-) Rational"%string.

Definition mulRational : forall (_1 : Rational), forall (_2 : Rational), Rational :=
  fun (x : unit : Type) (y : unit : Type) => SAWCoreScaffolding.error Rational "Unimplemented: (*) Rational"%string.

Definition negRational : forall (_1 : Rational), Rational :=
  fun (x : unit : Type) => SAWCoreScaffolding.error Rational "Unimplemented: negate Rational"%string.

Definition integerToRational : forall (_1 : SAWCoreScaffolding.Integer), Rational :=
  fun (x : SAWCoreScaffolding.Integer) => SAWCoreScaffolding.error Rational "Unimplemented: fromInteger Rational"%string.

Definition seq_cong : forall (m : Num), forall (n : Num), forall (a : Type), forall (b : Type), forall (_1 : @Coq.Init.Logic.eq Num m n), forall (_2 : @Coq.Init.Logic.eq Type a b), @Coq.Init.Logic.eq Type (seq m a) (seq n b) :=
  fun (m : Num) (n : Num) (a : Type) (b : Type) (eq_mn : @Coq.Init.Logic.eq Num m n) (eq_ab : @Coq.Init.Logic.eq Type a b) => SAWCorePrelude.trans Type (seq m a) (seq n a) (seq n b) (SAWCorePrelude.eq_cong Num m n eq_mn Type (fun (x : Num) => seq x a)) (SAWCorePrelude.eq_cong Type a b eq_ab Type (fun (x : Type) => seq n x)).

Definition seq_cong1 : forall (m : Num), forall (n : Num), forall (a : Type), forall (_1 : @Coq.Init.Logic.eq Num m n), @Coq.Init.Logic.eq Type (seq m a) (seq n a) :=
  fun (m : Num) (n : Num) (a : Type) (eq_mn : @Coq.Init.Logic.eq Num m n) => SAWCorePrelude.eq_cong Num m n eq_mn Type (fun (x : Num) => seq x a).

Definition IntModNum_cong : forall (m : Num), forall (n : Num), forall (_1 : @Coq.Init.Logic.eq Num m n), @Coq.Init.Logic.eq Type (IntModNum m) (IntModNum n) :=
  fun (m : Num) (n : Num) (eq_mn : @Coq.Init.Logic.eq Num m n) => SAWCorePrelude.eq_cong Num m n eq_mn Type IntModNum.

Definition fun_cong : forall (a : Type), forall (b : Type), forall (c : Type), forall (d : Type), forall (_1 : @Coq.Init.Logic.eq Type a b), forall (_2 : @Coq.Init.Logic.eq Type c d), @Coq.Init.Logic.eq Type (forall (_3 : a), c) (forall (_3 : b), d) :=
  fun (a : Type) (b : Type) (c : Type) (d : Type) (eq_ab : @Coq.Init.Logic.eq Type a b) (eq_cd : @Coq.Init.Logic.eq Type c d) => SAWCorePrelude.trans Type (forall (_1 : a), c) (forall (_1 : b), c) (forall (_1 : b), d) (SAWCorePrelude.eq_cong Type a b eq_ab Type (fun (x : Type) => forall (_1 : x), c)) (SAWCorePrelude.eq_cong Type c d eq_cd Type (fun (x : Type) => forall (_1 : b), x)).

Definition pair_cong : forall (a : Type), forall (a' : Type), forall (b : Type), forall (b' : Type), forall (_1 : @Coq.Init.Logic.eq Type a a'), forall (_2 : @Coq.Init.Logic.eq Type b b'), @Coq.Init.Logic.eq Type (prod a b) (prod a' b') :=
  fun (a : Type) (a' : Type) (b : Type) (b' : Type) (eq_a : @Coq.Init.Logic.eq Type a a') (eq_b : @Coq.Init.Logic.eq Type b b') => SAWCorePrelude.trans Type (prod a b) (prod a' b) (prod a' b') (SAWCorePrelude.eq_cong Type a a' eq_a Type (fun (x : Type) => prod x b)) (SAWCorePrelude.eq_cong Type b b' eq_b Type (fun (x : Type) => prod a' x)).

Definition pair_cong1 : forall (a : Type), forall (a' : Type), forall (b : Type), forall (_1 : @Coq.Init.Logic.eq Type a a'), @Coq.Init.Logic.eq Type (prod a b) (prod a' b) :=
  fun (a : Type) (a' : Type) (b : Type) (eq_a : @Coq.Init.Logic.eq Type a a') => SAWCorePrelude.eq_cong Type a a' eq_a Type (fun (x : Type) => prod x b).

Definition pair_cong2 : forall (a : Type), forall (b : Type), forall (b' : Type), forall (_1 : @Coq.Init.Logic.eq Type b b'), @Coq.Init.Logic.eq Type (prod a b) (prod a b') :=
  fun (a : Type) (b : Type) (b' : Type) (eq_b : @Coq.Init.Logic.eq Type b b') => SAWCorePrelude.eq_cong Type b b' eq_b Type (fun (x : Type) => prod a x).

(* "Cryptol.unsafeAssert_same_Num" was skipped *)

Definition eListSel : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (n : Num), forall (_1 : seq n a), forall (_2 : Coq.Init.Datatypes.nat), a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => forall (_1 : seq num a), forall (_2 : Coq.Init.Datatypes.nat), a) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.sawAt n1 a) (SAWCorePrelude.streamGet a) n.

Definition from : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (m : Num), forall (n : Num), forall (_1 : seq m a), forall (_2 : forall (_2 : a), seq n b), seq (tcMul m n) (prod a b) :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (m : Num) (n : Num) => let var__0   := @CryptolPrimitivesForSAWCore.Num_rect in
  var__0 (fun (m1 : Num) => forall (_1 : seq m1 a), forall (_2 : forall (_2 : a), seq n b), seq (tcMul m1 n) (prod a b)) (fun (m1 : Coq.Init.Datatypes.nat) => var__0 (fun (n1 : Num) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m1 a), forall (_2 : forall (_2 : a), seq n1 b), seq (tcMul (TCNum m1) n1) (prod a b)) (fun (n1 : Coq.Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec m1 a) (k : forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec n1 b) => let var__1   := prod a b in
  SAWCorePrelude.join m1 n1 var__1 (SAWCorePrelude.map a (SAWCoreVectorsAsCoqVectors.Vec n1 var__1) (fun (x : a) => SAWCorePrelude.map b var__1 (fun (y : b) => pair x y) n1 (k x)) m1 xs)) (SAWCorePrelude.natCase (fun (m' : Coq.Init.Datatypes.nat) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m' a), forall (_2 : forall (_2 : a), SAWCorePrelude.Stream b), seq (SAWCorePrelude.if0Nat Num m' (TCNum 0) TCInf) (prod a b)) (fun (xs : SAWCoreVectorsAsCoqVectors.Vec 0 a) (k : forall (_1 : a), SAWCorePrelude.Stream b) => SAWCoreVectorsAsCoqVectors.EmptyVec (prod a b)) (fun (m' : Coq.Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ m') a) (k : forall (_1 : a), SAWCorePrelude.Stream b) => (fun (x : a) => SAWCorePrelude.streamMap b (prod a b) (fun (y : b) => pair x y) (k x)) (SAWCorePrelude.sawAt (SAWCoreScaffolding.Succ m') a xs 0)) m1) n) (var__0 (fun (n1 : Num) => forall (_1 : SAWCorePrelude.Stream a), forall (_2 : forall (_2 : a), seq n1 b), seq (tcMul TCInf n1) (prod a b)) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.natCase (fun (n' : Coq.Init.Datatypes.nat) => forall (_1 : SAWCorePrelude.Stream a), forall (_2 : forall (_2 : a), SAWCoreVectorsAsCoqVectors.Vec n' b), seq (SAWCorePrelude.if0Nat Num n' (TCNum 0) TCInf) (prod a b)) (fun (xs : SAWCorePrelude.Stream a) (k : forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec 0 b) => SAWCoreVectorsAsCoqVectors.EmptyVec (prod a b)) (fun (n' : Coq.Init.Datatypes.nat) (xs : SAWCorePrelude.Stream a) (k : forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n') b) => let var__1   := prod a b in
  SAWCorePrelude.streamJoin var__1 n' (SAWCorePrelude.streamMap a (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n') var__1) (fun (x : a) => SAWCorePrelude.map b var__1 (fun (y : b) => pair x y) (SAWCoreScaffolding.Succ n') (k x)) xs)) n1) (fun (xs : SAWCorePrelude.Stream a) (k : forall (_1 : a), SAWCorePrelude.Stream b) => (fun (x : a) => SAWCorePrelude.streamMap b (prod a b) (fun (y : b) => pair x y) (k x)) (SAWCorePrelude.streamGet a xs 0)) n) m.

Definition mlet : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (n : Num), forall (_1 : a), forall (_2 : forall (_2 : a), seq n b), seq n (prod a b) :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : a), forall (_2 : forall (_2 : a), seq n1 b), seq n1 (prod a b)) (fun (n1 : Coq.Init.Datatypes.nat) (x : a) (f : forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec n1 b) => SAWCorePrelude.map b (prod a b) (fun (y : b) => pair x y) n1 (f x)) (fun (x : a) (f : forall (_1 : a), SAWCorePrelude.Stream b) => SAWCorePrelude.streamMap b (prod a b) (fun (y : b) => pair x y) (f x)) n.

Definition seqZip : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (m : Num), forall (n : Num), forall (_1 : seq m a), forall (_2 : seq n b), seq (tcMin m n) (prod a b) :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (m : Num) (n : Num) => let var__0   := @CryptolPrimitivesForSAWCore.Num_rect in
  var__0 (fun (m1 : Num) => forall (_1 : seq m1 a), forall (_2 : seq n b), seq (tcMin m1 n) (prod a b)) (fun (m1 : Coq.Init.Datatypes.nat) => var__0 (fun (n1 : Num) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m1 a), forall (_2 : seq n1 b), seq (tcMin (TCNum m1) n1) (prod a b)) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.zip a b m1 n1) (fun (xs : SAWCoreVectorsAsCoqVectors.Vec m1 a) (ys : SAWCorePrelude.Stream b) => SAWCoreVectorsAsCoqVectors.gen m1 (prod a b) (fun (i : Coq.Init.Datatypes.nat) => pair (SAWCorePrelude.sawAt m1 a xs i) (SAWCorePrelude.streamGet b ys i))) n) (var__0 (fun (n1 : Num) => forall (_1 : SAWCorePrelude.Stream a), forall (_2 : seq n1 b), seq (tcMin TCInf n1) (prod a b)) (fun (n1 : Coq.Init.Datatypes.nat) (xs : SAWCorePrelude.Stream a) (ys : SAWCoreVectorsAsCoqVectors.Vec n1 b) => SAWCoreVectorsAsCoqVectors.gen n1 (prod a b) (fun (i : Coq.Init.Datatypes.nat) => pair (SAWCorePrelude.streamGet a xs i) (SAWCorePrelude.sawAt n1 b ys i))) (SAWCorePrelude.streamMap2 a b (prod a b) (fun (x : a) (y : b) => pair x y)) n) m.

Definition zipSame : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (n : Coq.Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n b), SAWCoreVectorsAsCoqVectors.Vec n (prod a b) :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (n : Coq.Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n a) (y : SAWCoreVectorsAsCoqVectors.Vec n b) => SAWCoreVectorsAsCoqVectors.gen n (prod a b) (fun (i : Coq.Init.Datatypes.nat) => pair (SAWCorePrelude.sawAt n a x i) (SAWCorePrelude.sawAt n b y i)).

Definition seqZipSame : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (n : Num), forall (_1 : seq n a), forall (_2 : seq n b), seq n (prod a b) :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 a), forall (_2 : seq n1 b), seq n1 (prod a b)) (fun (n1 : Coq.Init.Datatypes.nat) => zipSame a b n1) (SAWCorePrelude.streamMap2 a b (prod a b) (fun (x : a) (y : b) => pair x y)) n.

Definition seqBinary : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : forall (_1 : a), forall (_2 : a), a), forall (_2 : seq n a), forall (_3 : seq n a), seq n a :=
  fun (n : Num) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (f : forall (_1 : a), forall (_2 : a), a) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 a), forall (_2 : seq n1 a), seq n1 a) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.zipWith a a a f n1) (SAWCorePrelude.streamMap2 a a a f) n.

Definition unitUnary : forall (_1 : unit : Type), unit : Type :=
  fun (_1 : unit : Type) => tt.

Definition unitBinary : forall (_1 : unit : Type), forall (_2 : unit : Type), unit : Type :=
  fun (_1 : unit : Type) (_2 : unit : Type) => tt.

Definition pairUnary : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), a), forall (_2 : forall (_2 : b), b), forall (_3 : prod a b), prod a b :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), a) (g : forall (_1 : b), b) (xy : prod a b) => pair (f (fst xy)) (g (snd xy)).

Definition pairBinary : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), forall (_2 : a), a), forall (_2 : forall (_2 : b), forall (_3 : b), b), forall (_3 : prod a b), forall (_4 : prod a b), prod a b :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), forall (_2 : a), a) (g : forall (_1 : b), forall (_2 : b), b) (x12 : prod a b) (y12 : prod a b) => pair (f (fst x12) (fst y12)) (g (snd x12) (snd y12)).

Definition funBinary : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : b), forall (_2 : b), b), forall (_2 : forall (_2 : a), b), forall (_3 : forall (_3 : a), b), forall (_4 : a), b :=
  fun (a : Type) (b : Type) (op : forall (_1 : b), forall (_2 : b), b) (f : forall (_1 : a), b) (g : forall (_1 : a), b) (x : a) => op (f x) (g x).

Definition errorUnary : forall (s : Coq.Strings.String.string), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : a), a :=
  fun (s : Coq.Strings.String.string) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (_1 : a) => SAWCoreScaffolding.error a s.

Definition errorBinary : forall (s : Coq.Strings.String.string), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : a), forall (_2 : a), a :=
  fun (s : Coq.Strings.String.string) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (_1 : a) (_2 : a) => SAWCoreScaffolding.error a s.

Definition boolCmp : forall (_1 : Coq.Init.Datatypes.bool), forall (_2 : Coq.Init.Datatypes.bool), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (x : Coq.Init.Datatypes.bool) (y : Coq.Init.Datatypes.bool) (k : Coq.Init.Datatypes.bool) => if x then Coq.Init.Datatypes.andb y k else Coq.Init.Datatypes.orb y k.

Definition boolLt : forall (_1 : Coq.Init.Datatypes.bool), forall (_2 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (x : Coq.Init.Datatypes.bool) (y : Coq.Init.Datatypes.bool) => Coq.Init.Datatypes.andb (Coq.Init.Datatypes.negb x) y.

Definition integerCmp : forall (_1 : SAWCoreScaffolding.Integer), forall (_2 : SAWCoreScaffolding.Integer), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (x : SAWCoreScaffolding.Integer) (y : SAWCoreScaffolding.Integer) (k : Coq.Init.Datatypes.bool) => Coq.Init.Datatypes.orb (SAWCoreScaffolding.intLt x y) (Coq.Init.Datatypes.andb (SAWCoreScaffolding.intEq x y) k).

Definition rationalCmp : forall (_1 : Rational), forall (_2 : Rational), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (x : unit : Type) (y : unit : Type) (k : Coq.Init.Datatypes.bool) => Coq.Init.Datatypes.orb (ltRational x y) (Coq.Init.Datatypes.andb (eqRational x y) k).

Definition bvCmp : forall (n : Coq.Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (n : Coq.Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (k : Coq.Init.Datatypes.bool) => Coq.Init.Datatypes.orb (SAWCoreVectorsAsCoqVectors.bvult n x y) (Coq.Init.Datatypes.andb (SAWCorePrelude.bvEq n x y) k).

Definition bvSCmp : forall (n : Coq.Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (n : Coq.Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (k : Coq.Init.Datatypes.bool) => Coq.Init.Datatypes.orb (SAWCoreVectorsAsCoqVectors.bvslt n x y) (Coq.Init.Datatypes.andb (SAWCorePrelude.bvEq n x y) k).

Definition vecCmp : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_4 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (f : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (ys : SAWCoreVectorsAsCoqVectors.Vec n a) (k : Coq.Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.foldr (forall (_1 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) Coq.Init.Datatypes.bool n (fun (f1 : forall (_1 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) => f1) k (SAWCorePrelude.zipWith a a (forall (_1 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) f n xs ys).

Definition vecLt : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool), forall (_2 : forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_4 : SAWCoreVectorsAsCoqVectors.Vec n a), Coq.Init.Datatypes.bool :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (f : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (g : forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (ys : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.foldr (forall (_1 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) Coq.Init.Datatypes.bool n (fun (f1 : forall (_1 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) => f1) Coq.Init.Datatypes.false (SAWCorePrelude.zipWith a a (forall (_1 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) f n xs ys).

Definition unitCmp : forall (_1 : unit : Type), forall (_2 : unit : Type), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (_1 : unit : Type) (_2 : unit : Type) (k : Coq.Init.Datatypes.bool) => k.

Definition unitLe : forall (_1 : unit : Type), forall (_2 : unit : Type), Coq.Init.Datatypes.bool :=
  fun (_1 : unit : Type) (_2 : unit : Type) => Coq.Init.Datatypes.true.

Definition unitLt : forall (_1 : unit : Type), forall (_2 : unit : Type), Coq.Init.Datatypes.bool :=
  fun (_1 : unit : Type) (_2 : unit : Type) => Coq.Init.Datatypes.false.

Definition pairCmp : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool), forall (_2 : forall (_2 : b), forall (_3 : b), forall (_4 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool), forall (_3 : prod a b), forall (_4 : prod a b), forall (_5 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (g : forall (_1 : b), forall (_2 : b), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (x12 : prod a b) (y12 : prod a b) (k : Coq.Init.Datatypes.bool) => f (fst x12) (fst y12) (g (snd x12) (snd y12) k).

Definition pairLt : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool), forall (_2 : forall (_2 : b), forall (_3 : b), Coq.Init.Datatypes.bool), forall (_3 : prod a b), forall (_4 : prod a b), Coq.Init.Datatypes.bool :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (g : forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) (x : prod a b) (y : prod a b) => f (fst x) (fst y) (g (snd x) (snd y)).

Definition PEq : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil.

Definition PEqBit : PEq Coq.Init.Datatypes.bool :=
  RecordCons "eq" SAWCoreScaffolding.boolEq RecordNil.

Definition PEqInteger : PEq SAWCoreScaffolding.Integer :=
  RecordCons "eq" SAWCoreScaffolding.intEq RecordNil.

Definition PEqRational : PEq Rational :=
  RecordCons "eq" eqRational RecordNil.

Definition PEqIntMod : forall (n : Coq.Init.Datatypes.nat), PEq (SAWCoreScaffolding.IntMod n) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "eq" (SAWCoreScaffolding.intModEq n) RecordNil.

Definition PEqIntModNum : forall (num : Num), PEq (IntModNum num) :=
  fun (num : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => PEq (IntModNum n)) PEqIntMod PEqInteger num.

Definition PEqVec : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PEq a), PEq (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) => RecordCons "eq" (SAWCorePrelude.vecEq n a (RecordProj pa "eq")) RecordNil.

Definition PEqSeq : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PEq a), PEq (seq n a) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PEq a), PEq (seq n1 a)) (fun (n1 : Coq.Init.Datatypes.nat) => PEqVec n1) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PEq a) => SAWCoreScaffolding.error (PEq (SAWCorePrelude.Stream a)) "invalid Eq instance"%string) n.

Definition PEqWord : forall (n : Coq.Init.Datatypes.nat), PEq (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "eq" (SAWCorePrelude.bvEq n) RecordNil.

Definition PEqSeqBool : forall (n : Num), PEq (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PEq (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => PEqWord n1) (SAWCoreScaffolding.error (PEq (SAWCorePrelude.Stream Coq.Init.Datatypes.bool)) "invalid Eq instance"%string) n.

Definition PEqUnit : PEq (unit : Type) :=
  RecordCons "eq" (fun (x : unit : Type) (y : unit : Type) => Coq.Init.Datatypes.true) RecordNil.

Definition PEqPair : forall (a : Type), forall (b : Type), forall (_1 : PEq a), forall (_2 : PEq b), PEq (prod a b) :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (pb : RecordTypeCons "eq" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) RecordTypeNil) => RecordCons "eq" (SAWCorePrelude.pairEq a b (RecordProj pa "eq") (RecordProj pb "eq")) RecordNil.

Definition PCmp : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (PEq a) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil))).

Definition PCmpBit : PCmp Coq.Init.Datatypes.bool :=
  RecordCons "cmp" boolCmp (RecordCons "cmpEq" PEqBit (RecordCons "le" SAWCorePrelude.implies (RecordCons "lt" boolLt RecordNil))).

Definition PCmpInteger : PCmp SAWCoreScaffolding.Integer :=
  RecordCons "cmp" integerCmp (RecordCons "cmpEq" PEqInteger (RecordCons "le" SAWCoreScaffolding.intLe (RecordCons "lt" SAWCoreScaffolding.intLt RecordNil))).

Definition PCmpRational : PCmp Rational :=
  RecordCons "cmp" rationalCmp (RecordCons "cmpEq" PEqRational (RecordCons "le" leRational (RecordCons "lt" ltRational RecordNil))).

Definition PCmpVec : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PCmp a), PCmp (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) => let var__0   := SAWCoreVectorsAsCoqVectors.Vec n a in
  RecordCons "cmp" (vecCmp n a (RecordProj pa "cmp")) (RecordCons "cmpEq" (PEqVec n a (RecordProj pa "cmpEq")) (RecordCons "le" (fun (x : var__0) (y : var__0) => vecCmp n a (RecordProj pa "cmp") x y Coq.Init.Datatypes.true) (RecordCons "lt" (fun (x : var__0) (y : var__0) => vecCmp n a (RecordProj pa "cmp") x y Coq.Init.Datatypes.false) RecordNil))).

Definition PCmpSeq : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PCmp a), PCmp (seq n a) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PCmp a), PCmp (seq n1 a)) (fun (n1 : Coq.Init.Datatypes.nat) => PCmpVec n1) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PCmp a) => SAWCoreScaffolding.error (PCmp (SAWCorePrelude.Stream a)) "invalid Cmp instance"%string) n.

Definition PCmpWord : forall (n : Coq.Init.Datatypes.nat), PCmp (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "cmp" (bvCmp n) (RecordCons "cmpEq" (PEqWord n) (RecordCons "le" (SAWCoreVectorsAsCoqVectors.bvule n) (RecordCons "lt" (SAWCoreVectorsAsCoqVectors.bvult n) RecordNil))).

Definition PCmpSeqBool : forall (n : Num), PCmp (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PCmp (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => PCmpWord n1) (SAWCoreScaffolding.error (PCmp (SAWCorePrelude.Stream Coq.Init.Datatypes.bool)) "invalid Cmp instance"%string) n.

Definition PCmpUnit : PCmp (unit : Type) :=
  RecordCons "cmp" unitCmp (RecordCons "cmpEq" PEqUnit (RecordCons "le" unitLe (RecordCons "lt" unitLt RecordNil))).

Definition PCmpPair : forall (a : Type), forall (b : Type), forall (_1 : PCmp a), forall (_2 : PCmp b), PCmp (prod a b) :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (pb : RecordTypeCons "cmp" (forall (_1 : b), forall (_2 : b), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) RecordTypeNil)))) => let var__0   := RecordProj pa "cmp" in
  RecordCons "cmp" (pairCmp a b var__0 (RecordProj pb "cmp")) (RecordCons "cmpEq" (PEqPair a b (RecordProj pa "cmpEq") (RecordProj pb "cmpEq")) (RecordCons "le" (pairLt a b var__0 (RecordProj pb "le")) (RecordCons "lt" (pairLt a b var__0 (RecordProj pb "lt")) RecordNil))).

Definition PSignedCmp : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "scmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "signedCmpEq" (PEq a) (RecordTypeCons "sle" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "slt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil))).

Definition PSignedCmpVec : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PSignedCmp a), PSignedCmp (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : RecordTypeCons "scmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "signedCmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "sle" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "slt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) => let var__0   := SAWCoreVectorsAsCoqVectors.Vec n a in
  RecordCons "scmp" (vecCmp n a (RecordProj pa "scmp")) (RecordCons "signedCmpEq" (PEqVec n a (RecordProj pa "signedCmpEq")) (RecordCons "sle" (fun (x : var__0) (y : var__0) => vecCmp n a (RecordProj pa "scmp") x y Coq.Init.Datatypes.true) (RecordCons "slt" (fun (x : var__0) (y : var__0) => vecCmp n a (RecordProj pa "scmp") x y Coq.Init.Datatypes.false) RecordNil))).

Definition PSignedCmpSeq : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PSignedCmp a), PSignedCmp (seq n a) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PSignedCmp a), PSignedCmp (seq n1 a)) (fun (n1 : Coq.Init.Datatypes.nat) => PSignedCmpVec n1) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PSignedCmp a) => SAWCoreScaffolding.error (PSignedCmp (SAWCorePrelude.Stream a)) "invalid SignedCmp instance"%string) n.

Definition PSignedCmpWord : forall (n : Coq.Init.Datatypes.nat), PSignedCmp (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "scmp" (bvSCmp n) (RecordCons "signedCmpEq" (PEqWord n) (RecordCons "sle" (SAWCoreVectorsAsCoqVectors.bvsle n) (RecordCons "slt" (SAWCoreVectorsAsCoqVectors.bvslt n) RecordNil))).

Definition PSignedCmpSeqBool : forall (n : Num), PSignedCmp (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PSignedCmp (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => PSignedCmpWord n1) (SAWCoreScaffolding.error (PSignedCmp (SAWCorePrelude.Stream Coq.Init.Datatypes.bool)) "invalid SignedCmp instance"%string) n.

Definition PSignedCmpUnit : PSignedCmp (unit : Type) :=
  RecordCons "scmp" unitCmp (RecordCons "signedCmpEq" PEqUnit (RecordCons "sle" unitLe (RecordCons "slt" unitLt RecordNil))).

Definition PSignedCmpPair : forall (a : Type), forall (b : Type), forall (_1 : PSignedCmp a), forall (_2 : PSignedCmp b), PSignedCmp (prod a b) :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "scmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "signedCmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "sle" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "slt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (pb : RecordTypeCons "scmp" (forall (_1 : b), forall (_2 : b), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "signedCmpEq" (RecordTypeCons "eq" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "sle" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) (RecordTypeCons "slt" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) RecordTypeNil)))) => let var__0   := RecordProj pa "scmp" in
  RecordCons "scmp" (pairCmp a b var__0 (RecordProj pb "scmp")) (RecordCons "signedCmpEq" (PEqPair a b (RecordProj pa "signedCmpEq") (RecordProj pb "signedCmpEq")) (RecordCons "sle" (pairLt a b var__0 (RecordProj pb "sle")) (RecordCons "slt" (pairLt a b var__0 (RecordProj pb "slt")) RecordNil))).

Definition PZero : forall (_1 : Type), Type :=
  fun (a : Type) => a.

Definition PZeroBit : PZero Coq.Init.Datatypes.bool :=
  Coq.Init.Datatypes.false.

Definition PZeroInteger : PZero SAWCoreScaffolding.Integer :=
  0%Z.

Definition PZeroIntMod : forall (n : Coq.Init.Datatypes.nat), PZero (SAWCoreScaffolding.IntMod n) :=
  fun (n : Coq.Init.Datatypes.nat) => SAWCoreScaffolding.toIntMod n 0%Z.

Definition PZeroRational : PZero Rational :=
  integerToRational 0%Z.

Definition PZeroIntModNum : forall (num : Num), PZero (IntModNum num) :=
  fun (num : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => PZero (IntModNum n)) PZeroIntMod PZeroInteger num.

Definition PZeroSeq : forall (n : Num), forall (a : Type), forall (_1 : PZero a), PZero (seq n a) :=
  fun (n : Num) (a : Type) (pa : a) => seqConst n a pa.

Definition PZeroSeqBool : forall (n : Num), PZero (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PZero (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.bvNat n1 0) (SAWCorePrelude.streamConst Coq.Init.Datatypes.bool Coq.Init.Datatypes.false) n.

Definition PZeroFun : forall (a : Type), forall (b : Type), forall (_1 : PZero b), PZero (forall (_2 : a), b) :=
  fun (a : Type) (b : Type) (pb : b) (_1 : a) => pb.

Definition PLogic : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" (PZero a) (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))).

Definition PLogicBit : PLogic Coq.Init.Datatypes.bool :=
  RecordCons "and" Coq.Init.Datatypes.andb (RecordCons "logicZero" PZeroBit (RecordCons "not" Coq.Init.Datatypes.negb (RecordCons "or" Coq.Init.Datatypes.orb (RecordCons "xor" Coq.Init.Datatypes.xorb RecordNil)))).

Definition PLogicVec : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLogic a), PLogic (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) => RecordCons "and" (SAWCorePrelude.zipWith a a a (RecordProj pa "and") n) (RecordCons "logicZero" (SAWCorePrelude.replicate n a (RecordProj pa "logicZero")) (RecordCons "not" (SAWCorePrelude.map a a (RecordProj pa "not") n) (RecordCons "or" (SAWCorePrelude.zipWith a a a (RecordProj pa "or") n) (RecordCons "xor" (SAWCorePrelude.zipWith a a a (RecordProj pa "xor") n) RecordNil)))).

Definition PLogicStream : forall (a : Type), forall (_1 : PLogic a), PLogic (SAWCorePrelude.Stream a) :=
  fun (a : Type) (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) => RecordCons "and" (SAWCorePrelude.streamMap2 a a a (RecordProj pa "and")) (RecordCons "logicZero" (SAWCorePrelude.streamConst a (RecordProj pa "logicZero")) (RecordCons "not" (SAWCorePrelude.streamMap a a (RecordProj pa "not")) (RecordCons "or" (SAWCorePrelude.streamMap2 a a a (RecordProj pa "or")) (RecordCons "xor" (SAWCorePrelude.streamMap2 a a a (RecordProj pa "xor")) RecordNil)))).

Definition PLogicSeq : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLogic a), PLogic (seq n a) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLogic a), PLogic (seq n1 a)) (fun (n1 : Coq.Init.Datatypes.nat) => PLogicVec n1) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => PLogicStream a) n.

Definition PLogicWord : forall (n : Coq.Init.Datatypes.nat), PLogic (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "and" (SAWCorePrelude.bvAnd n) (RecordCons "logicZero" (SAWCoreVectorsAsCoqVectors.bvNat n 0) (RecordCons "not" (SAWCorePrelude.bvNot n) (RecordCons "or" (SAWCorePrelude.bvOr n) (RecordCons "xor" (SAWCorePrelude.bvXor n) RecordNil)))).

Definition PLogicSeqBool : forall (n : Num), PLogic (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PLogic (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => PLogicWord n1) (PLogicStream Coq.Init.Datatypes.bool PLogicBit) n.

Definition PLogicFun : forall (a : Type), forall (b : Type), forall (_1 : PLogic b), PLogic (forall (_2 : a), b) :=
  fun (a : Type) (b : Type) (pb : RecordTypeCons "and" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "logicZero" b (RecordTypeCons "not" (forall (_1 : b), b) (RecordTypeCons "or" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "xor" (forall (_1 : b), forall (_2 : b), b) RecordTypeNil))))) => RecordCons "and" (funBinary a b (RecordProj pb "and")) (RecordCons "logicZero" (PZeroFun a b (RecordProj pb "logicZero")) (RecordCons "not" (compose a b b (RecordProj pb "not")) (RecordCons "or" (funBinary a b (RecordProj pb "or")) (RecordCons "xor" (funBinary a b (RecordProj pb "xor")) RecordNil)))).

Definition PLogicUnit : PLogic (unit : Type) :=
  RecordCons "and" unitBinary (RecordCons "logicZero" tt (RecordCons "not" unitUnary (RecordCons "or" unitBinary (RecordCons "xor" unitBinary RecordNil)))).

Definition PLogicPair : forall (a : Type), forall (b : Type), forall (_1 : PLogic a), forall (_2 : PLogic b), PLogic (prod a b) :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) (pb : RecordTypeCons "and" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "logicZero" b (RecordTypeCons "not" (forall (_1 : b), b) (RecordTypeCons "or" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "xor" (forall (_1 : b), forall (_2 : b), b) RecordTypeNil))))) => RecordCons "and" (pairBinary a b (RecordProj pa "and") (RecordProj pb "and")) (RecordCons "logicZero" (pair (RecordProj pa "logicZero") (RecordProj pb "logicZero")) (RecordCons "not" (pairUnary a b (RecordProj pa "not") (RecordProj pb "not")) (RecordCons "or" (pairBinary a b (RecordProj pa "or") (RecordProj pb "or")) (RecordCons "xor" (pairBinary a b (RecordProj pa "xor") (RecordProj pb "xor")) RecordNil)))).

Definition PRing : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" (PZero a) (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))).

Definition PRingInteger : PRing SAWCoreScaffolding.Integer :=
  RecordCons "add" SAWCoreScaffolding.intAdd (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) => i) (RecordCons "mul" SAWCoreScaffolding.intMul (RecordCons "neg" SAWCoreScaffolding.intNeg (RecordCons "ringZero" PZeroInteger (RecordCons "sub" SAWCoreScaffolding.intSub RecordNil))))).

Definition PRingIntMod : forall (n : Coq.Init.Datatypes.nat), PRing (SAWCoreScaffolding.IntMod n) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "add" (SAWCoreScaffolding.intModAdd n) (RecordCons "int" (SAWCoreScaffolding.toIntMod n) (RecordCons "mul" (SAWCoreScaffolding.intModMul n) (RecordCons "neg" (SAWCoreScaffolding.intModNeg n) (RecordCons "ringZero" (PZeroIntMod n) (RecordCons "sub" (SAWCoreScaffolding.intModSub n) RecordNil))))).

Definition PRingIntModNum : forall (num : Num), PRing (IntModNum num) :=
  fun (num : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => PRing (IntModNum n)) PRingIntMod PRingInteger num.

Definition PRingRational : PRing Rational :=
  RecordCons "add" addRational (RecordCons "int" integerToRational (RecordCons "mul" mulRational (RecordCons "neg" negRational (RecordCons "ringZero" PZeroRational (RecordCons "sub" subRational RecordNil))))).

Definition PRingVec : forall (n : Coq.Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PRing a), PRing (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordCons "add" (SAWCorePrelude.zipWith a a a (RecordProj pa "add") n) (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) => SAWCorePrelude.replicate n a (RecordProj pa "int" i)) (RecordCons "mul" (SAWCorePrelude.zipWith a a a (RecordProj pa "mul") n) (RecordCons "neg" (SAWCorePrelude.map a a (RecordProj pa "neg") n) (RecordCons "ringZero" (SAWCorePrelude.replicate n a (RecordProj pa "ringZero")) (RecordCons "sub" (SAWCorePrelude.zipWith a a a (RecordProj pa "sub") n) RecordNil))))).

Definition PRingStream : forall (a : Type), forall (_1 : PRing a), PRing (SAWCorePrelude.Stream a) :=
  fun (a : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordCons "add" (SAWCorePrelude.streamMap2 a a a (RecordProj pa "add")) (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) => SAWCorePrelude.streamConst a (RecordProj pa "int" i)) (RecordCons "mul" (SAWCorePrelude.streamMap2 a a a (RecordProj pa "mul")) (RecordCons "neg" (SAWCorePrelude.streamMap a a (RecordProj pa "neg")) (RecordCons "ringZero" (SAWCorePrelude.streamConst a (RecordProj pa "ringZero")) (RecordCons "sub" (SAWCorePrelude.streamMap2 a a a (RecordProj pa "sub")) RecordNil))))).

Definition PRingSeq : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PRing a), PRing (seq n a) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PRing a), PRing (seq n1 a)) (fun (n1 : Coq.Init.Datatypes.nat) => PRingVec n1) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => PRingStream a) n.

Definition PRingWord : forall (n : Coq.Init.Datatypes.nat), PRing (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "add" (SAWCoreVectorsAsCoqVectors.bvAdd n) (RecordCons "int" (SAWCoreVectorsAsCoqVectors.intToBv n) (RecordCons "mul" (SAWCoreVectorsAsCoqVectors.bvMul n) (RecordCons "neg" (SAWCoreVectorsAsCoqVectors.bvNeg n) (RecordCons "ringZero" (SAWCoreVectorsAsCoqVectors.bvNat n 0) (RecordCons "sub" (SAWCoreVectorsAsCoqVectors.bvSub n) RecordNil))))).

Definition PRingSeqBool : forall (n : Num), PRing (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PRing (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => PRingWord n1) (SAWCoreScaffolding.error (PRing (SAWCorePrelude.Stream Coq.Init.Datatypes.bool)) "PRingSeqBool: no instance for streams"%string) n.

Definition PRingFun : forall (a : Type), forall (b : Type), forall (_1 : PRing b), PRing (forall (_2 : a), b) :=
  fun (a : Type) (b : Type) (pb : RecordTypeCons "add" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), b) (RecordTypeCons "mul" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "neg" (forall (_1 : b), b) (RecordTypeCons "ringZero" b (RecordTypeCons "sub" (forall (_1 : b), forall (_2 : b), b) RecordTypeNil)))))) => RecordCons "add" (funBinary a b (RecordProj pb "add")) (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) (_1 : a) => RecordProj pb "int" i) (RecordCons "mul" (funBinary a b (RecordProj pb "mul")) (RecordCons "neg" (compose a b b (RecordProj pb "neg")) (RecordCons "ringZero" (PZeroFun a b (RecordProj pb "ringZero")) (RecordCons "sub" (funBinary a b (RecordProj pb "sub")) RecordNil))))).

Definition PRingUnit : PRing (unit : Type) :=
  RecordCons "add" unitBinary (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) => tt) (RecordCons "mul" unitBinary (RecordCons "neg" unitUnary (RecordCons "ringZero" tt (RecordCons "sub" unitBinary RecordNil))))).

Definition PRingPair : forall (a : Type), forall (b : Type), forall (_1 : PRing a), forall (_2 : PRing b), PRing (prod a b) :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (pb : RecordTypeCons "add" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), b) (RecordTypeCons "mul" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "neg" (forall (_1 : b), b) (RecordTypeCons "ringZero" b (RecordTypeCons "sub" (forall (_1 : b), forall (_2 : b), b) RecordTypeNil)))))) => RecordCons "add" (pairBinary a b (RecordProj pa "add") (RecordProj pb "add")) (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) => pair (RecordProj pa "int" i) (RecordProj pb "int" i)) (RecordCons "mul" (pairBinary a b (RecordProj pa "mul") (RecordProj pb "mul")) (RecordCons "neg" (pairUnary a b (RecordProj pa "neg") (RecordProj pb "neg")) (RecordCons "ringZero" (pair (RecordProj pa "ringZero") (RecordProj pb "ringZero")) (RecordCons "sub" (pairBinary a b (RecordProj pa "sub") (RecordProj pb "sub")) RecordNil))))).

Definition PIntegral : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "div" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "integralRing" (PRing a) (RecordTypeCons "mod" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : a), r) (RecordTypeCons "toInt" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil)))).

Definition PIntegralInteger : PIntegral SAWCoreScaffolding.Integer :=
  RecordCons "div" SAWCoreScaffolding.intDiv (RecordCons "integralRing" PRingInteger (RecordCons "mod" SAWCoreScaffolding.intMod (RecordCons "posNegCases" (fun (r : Type) (pos : forall (_1 : Coq.Init.Datatypes.nat), r) (neg : forall (_1 : Coq.Init.Datatypes.nat), r) (i : SAWCoreScaffolding.Integer) => if SAWCoreScaffolding.intLe 0%Z i then pos (SAWCoreScaffolding.intToNat i) else neg (SAWCoreScaffolding.intToNat (SAWCoreScaffolding.intNeg i))) (RecordCons "toInt" (fun (i : SAWCoreScaffolding.Integer) => i) RecordNil)))).

Definition PIntegralWord : forall (n : Coq.Init.Datatypes.nat), PIntegral (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) :=
  fun (n : Coq.Init.Datatypes.nat) => RecordCons "div" (SAWCoreVectorsAsCoqVectors.bvUDiv n) (RecordCons "integralRing" (PRingWord n) (RecordCons "mod" (SAWCoreVectorsAsCoqVectors.bvURem n) (RecordCons "posNegCases" (fun (r : Type) (pos : forall (_1 : Coq.Init.Datatypes.nat), r) (neg : forall (_1 : Coq.Init.Datatypes.nat), r) (i : SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) => pos (SAWCoreVectorsAsCoqVectors.bvToNat n i)) (RecordCons "toInt" (SAWCoreVectorsAsCoqVectors.bvToInt n) RecordNil)))).

Definition PIntegralSeqBool : forall (n : Num), PIntegral (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PIntegral (seq n1 Coq.Init.Datatypes.bool)) (fun (n1 : Coq.Init.Datatypes.nat) => PIntegralWord n1) (SAWCoreScaffolding.error (PIntegral (SAWCorePrelude.Stream Coq.Init.Datatypes.bool)) "PIntegralSeqBool: no instance for streams"%string) n.

Definition PField : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (PRing a) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil)).

Definition PFieldRational : PField Rational :=
  RecordCons "fieldDiv" (fun (x : Rational) (y : Rational) => SAWCoreScaffolding.error Rational "Unimplemented: (/.) Rational"%string) (RecordCons "fieldRing" PRingRational (RecordCons "recip" (fun (x : Rational) => SAWCoreScaffolding.error Rational "Unimplemented: recip Rational"%string) RecordNil)).

Definition PFieldIntMod : forall (n : Coq.Init.Datatypes.nat), PField (SAWCoreScaffolding.IntMod n) :=
  fun (n : Coq.Init.Datatypes.nat) => let var__0   := SAWCoreScaffolding.IntMod n in
  RecordCons "fieldDiv" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: (/.) IntMod"%string) (RecordCons "fieldRing" (PRingIntMod n) (RecordCons "recip" (fun (x : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: recip IntMod"%string) RecordNil)).

Definition PFieldIntModNum : forall (n : Num), PField (IntModNum n) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PField (IntModNum n1)) PFieldIntMod (SAWCoreScaffolding.error (PField (IntModNum TCInf)) "PFieldIntModNum: no instance for inf"%string) n.

Definition PRound : forall (_1 : Type), Type :=
  fun (a : Type) => RecordTypeCons "ceiling" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "floor" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundAway" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundCmp" (PCmp a) (RecordTypeCons "roundField" (PField a) (RecordTypeCons "roundToEven" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "trunc" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil)))))).

Definition PRoundRational : PRound Rational :=
  RecordCons "ceiling" (fun (x : Rational) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: ceiling Rational"%string) (RecordCons "floor" (fun (x : Rational) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: floor Rational"%string) (RecordCons "roundAway" (fun (x : Rational) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: roundAway Rational"%string) (RecordCons "roundCmp" PCmpRational (RecordCons "roundField" PFieldRational (RecordCons "roundToEven" (fun (x : Rational) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: roundToEven Rational"%string) (RecordCons "trunc" (fun (x : Rational) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: trunc Rational"%string) RecordNil)))))).

Definition PLiteral : forall (a : Type), Type :=
  fun (a : Type) => forall (_1 : Coq.Init.Datatypes.nat), a.

Definition PLiteralLessThan : forall (a : Type), Type :=
  fun (a : Type) => forall (_1 : Coq.Init.Datatypes.nat), a.

Definition PLiteralSeqBool : forall (n : Num), PLiteral (seq n Coq.Init.Datatypes.bool) :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => PLiteral (seq n1 Coq.Init.Datatypes.bool)) SAWCoreVectorsAsCoqVectors.bvNat (SAWCoreScaffolding.error (PLiteral (SAWCorePrelude.Stream Coq.Init.Datatypes.bool)) "PLiteralSeqBool: no instance for streams"%string) n.

Definition PLiteralBit : PLiteral Coq.Init.Datatypes.bool :=
  SAWCorePrelude.Nat_cases Coq.Init.Datatypes.bool Coq.Init.Datatypes.false (fun (n : Coq.Init.Datatypes.nat) (b : Coq.Init.Datatypes.bool) => Coq.Init.Datatypes.true).

Definition PLiteralInteger : PLiteral SAWCoreScaffolding.Integer :=
  SAWCoreScaffolding.natToInt.

Definition PLiteralIntMod : forall (n : Coq.Init.Datatypes.nat), PLiteral (SAWCoreScaffolding.IntMod n) :=
  fun (n : Coq.Init.Datatypes.nat) (x : Coq.Init.Datatypes.nat) => SAWCoreScaffolding.toIntMod n (SAWCoreScaffolding.natToInt x).

Definition PLiteralIntModNum : forall (num : Num), PLiteral (IntModNum num) :=
  fun (num : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => PLiteral (IntModNum n)) PLiteralIntMod PLiteralInteger num.

Definition PLiteralRational : PLiteral Rational :=
  fun (x : Coq.Init.Datatypes.nat) => SAWCoreScaffolding.error Rational "Unimplemented: Literal Rational"%string.

Definition ecNumber : forall (val : Num), forall (a : Type), forall (_1 : PLiteral a), a :=
  fun (val : Num) (a : Type) (pa : forall (_1 : Coq.Init.Datatypes.nat), a) => @CryptolPrimitivesForSAWCore.Num_rect (fun (_1 : Num) => a) pa (pa 0) val.

Definition ecFromZ : forall (n : Num), forall (_1 : IntModNum n), SAWCoreScaffolding.Integer :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : IntModNum n1), SAWCoreScaffolding.Integer) SAWCoreScaffolding.fromIntMod (fun (x : SAWCoreScaffolding.Integer) => x) n.

Definition ecFromInteger : forall (a : Type), forall (_1 : PRing a), forall (_2 : SAWCoreScaffolding.Integer), a :=
  fun (a : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordProj pa "int".

Definition ecPlus : forall (a : Type), forall (_1 : PRing a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordProj pa "add".

Definition ecMinus : forall (a : Type), forall (_1 : PRing a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordProj pa "sub".

Definition ecMul : forall (a : Type), forall (_1 : PRing a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordProj pa "mul".

Definition ecNeg : forall (a : Type), forall (_1 : PRing a), forall (_2 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) => RecordProj pa "neg".

Definition ecToInteger : forall (a : Type), forall (_1 : PIntegral a), forall (_2 : a), SAWCoreScaffolding.Integer :=
  fun (a : Type) (pa : RecordTypeCons "div" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : a), r) (RecordTypeCons "toInt" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))) => RecordProj pa "toInt".

Definition ecDiv : forall (a : Type), forall (_1 : PIntegral a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pi : RecordTypeCons "div" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : a), r) (RecordTypeCons "toInt" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))) => RecordProj pi "div".

Definition ecMod : forall (a : Type), forall (_1 : PIntegral a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pi : RecordTypeCons "div" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : a), r) (RecordTypeCons "toInt" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))) => RecordProj pi "mod".

Definition ecExp : forall (a : Type), forall (b : Type), forall (_1 : PRing a), forall (_2 : PIntegral b), forall (_3 : a), forall (_4 : b), a :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (pi : RecordTypeCons "div" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), b) (RecordTypeCons "mul" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "neg" (forall (_1 : b), b) (RecordTypeCons "ringZero" b (RecordTypeCons "sub" (forall (_1 : b), forall (_2 : b), b) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : b), forall (_2 : b), b) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : b), r) (RecordTypeCons "toInt" (forall (_1 : b), SAWCoreScaffolding.Integer) RecordTypeNil))))) (x : a) => RecordProj pi "posNegCases" a (SAWCorePrelude.expByNat a (RecordProj pa "int" 1%Z) (RecordProj pa "mul") x) (fun (_1 : Coq.Init.Datatypes.nat) => RecordProj pa "int" 1%Z).

Definition ecRecip : forall (a : Type), forall (_1 : PField a), forall (_2 : a), a :=
  fun (a : Type) (pf : RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) => RecordProj pf "recip".

Definition ecFieldDiv : forall (a : Type), forall (_1 : PField a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pf : RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) => RecordProj pf "fieldDiv".

Definition ecCeiling : forall (a : Type), forall (_1 : PRound a), forall (_2 : a), SAWCoreScaffolding.Integer :=
  fun (a : Type) (pr : RecordTypeCons "ceiling" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "floor" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundAway" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundCmp" (RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (RecordTypeCons "roundField" (RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) (RecordTypeCons "roundToEven" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "trunc" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))))) => RecordProj pr "ceiling".

Definition ecFloor : forall (a : Type), forall (_1 : PRound a), forall (_2 : a), SAWCoreScaffolding.Integer :=
  fun (a : Type) (pr : RecordTypeCons "ceiling" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "floor" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundAway" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundCmp" (RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (RecordTypeCons "roundField" (RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) (RecordTypeCons "roundToEven" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "trunc" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))))) => RecordProj pr "floor".

Definition ecTruncate : forall (a : Type), forall (_1 : PRound a), forall (_2 : a), SAWCoreScaffolding.Integer :=
  fun (a : Type) (pr : RecordTypeCons "ceiling" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "floor" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundAway" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundCmp" (RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (RecordTypeCons "roundField" (RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) (RecordTypeCons "roundToEven" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "trunc" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))))) => RecordProj pr "trunc".

Definition ecRoundAway : forall (a : Type), forall (_1 : PRound a), forall (_2 : a), SAWCoreScaffolding.Integer :=
  fun (a : Type) (pr : RecordTypeCons "ceiling" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "floor" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundAway" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundCmp" (RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (RecordTypeCons "roundField" (RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) (RecordTypeCons "roundToEven" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "trunc" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))))) => RecordProj pr "roundAway".

Definition ecRoundToEven : forall (a : Type), forall (_1 : PRound a), forall (_2 : a), SAWCoreScaffolding.Integer :=
  fun (a : Type) (pr : RecordTypeCons "ceiling" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "floor" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundAway" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "roundCmp" (RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (RecordTypeCons "roundField" (RecordTypeCons "fieldDiv" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "fieldRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "recip" (forall (_1 : a), a) RecordTypeNil))) (RecordTypeCons "roundToEven" (forall (_1 : a), SAWCoreScaffolding.Integer) (RecordTypeCons "trunc" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))))) => RecordProj pr "roundToEven".

Definition ecLg2 : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), seq n Coq.Init.Datatypes.bool :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 Coq.Init.Datatypes.bool), seq n1 Coq.Init.Datatypes.bool) SAWCoreVectorsAsCoqVectors.bvLg2 (SAWCoreScaffolding.error (forall (_1 : SAWCorePrelude.Stream Coq.Init.Datatypes.bool), SAWCorePrelude.Stream Coq.Init.Datatypes.bool) "ecLg2: expected finite word"%string) n.

Definition ecSDiv : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), seq n Coq.Init.Datatypes.bool :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 Coq.Init.Datatypes.bool), forall (_2 : seq n1 Coq.Init.Datatypes.bool), seq n1 Coq.Init.Datatypes.bool) (SAWCorePrelude.Nat__rec (fun (n1 : Coq.Init.Datatypes.nat) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n1 Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n1 Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n1 Coq.Init.Datatypes.bool) (SAWCoreScaffolding.error (forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool) "ecSDiv: illegal 0-width word"%string) (fun (n' : Coq.Init.Datatypes.nat) (_1 : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.bvSDiv n')) (SAWCoreScaffolding.error (forall (_1 : SAWCorePrelude.Stream Coq.Init.Datatypes.bool), forall (_2 : SAWCorePrelude.Stream Coq.Init.Datatypes.bool), SAWCorePrelude.Stream Coq.Init.Datatypes.bool) "ecSDiv: expected finite word"%string) n.

Definition ecSMod : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), seq n Coq.Init.Datatypes.bool :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 Coq.Init.Datatypes.bool), forall (_2 : seq n1 Coq.Init.Datatypes.bool), seq n1 Coq.Init.Datatypes.bool) (SAWCorePrelude.Nat__rec (fun (n1 : Coq.Init.Datatypes.nat) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n1 Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n1 Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n1 Coq.Init.Datatypes.bool) (SAWCoreScaffolding.error (forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool) "ecSMod: illegal 0-width word"%string) (fun (n' : Coq.Init.Datatypes.nat) (_1 : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.bvSRem n')) (SAWCoreScaffolding.error (forall (_1 : SAWCorePrelude.Stream Coq.Init.Datatypes.bool), forall (_2 : SAWCorePrelude.Stream Coq.Init.Datatypes.bool), SAWCorePrelude.Stream Coq.Init.Datatypes.bool) "ecSMod: expected finite word"%string) n.

Definition toSignedInteger : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), SAWCoreScaffolding.Integer :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 Coq.Init.Datatypes.bool), SAWCoreScaffolding.Integer) SAWCoreVectorsAsCoqVectors.sbvToInt (SAWCoreScaffolding.error (forall (_1 : SAWCorePrelude.Stream Coq.Init.Datatypes.bool), SAWCoreScaffolding.Integer) "toSignedInteger: expected finite word"%string) n.

Definition ecEq : forall (a : Type), forall (_1 : PEq a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) => RecordProj pa "eq".

Definition ecNotEq : forall (a : Type), forall (_1 : PEq a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (x : a) (y : a) => Coq.Init.Datatypes.negb (ecEq a pa x y).

Definition ecLt : forall (a : Type), forall (_1 : PCmp a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) => RecordProj pa "lt".

Definition ecGt : forall (a : Type), forall (_1 : PCmp a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (x : a) (y : a) => ecLt a pa y x.

Definition ecLtEq : forall (a : Type), forall (_1 : PCmp a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) => RecordProj pa "le".

Definition ecGtEq : forall (a : Type), forall (_1 : PCmp a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "cmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "cmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "le" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "lt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) (x : a) (y : a) => ecLtEq a pa y x.

Definition ecSLt : forall (a : Type), forall (_1 : PSignedCmp a), forall (_2 : a), forall (_3 : a), Coq.Init.Datatypes.bool :=
  fun (a : Type) (pa : RecordTypeCons "scmp" (forall (_1 : a), forall (_2 : a), forall (_3 : Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) (RecordTypeCons "signedCmpEq" (RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (RecordTypeCons "sle" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) (RecordTypeCons "slt" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil)))) => RecordProj pa "slt".

Definition ecAnd : forall (a : Type), forall (_1 : PLogic a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) => RecordProj pa "and".

Definition ecOr : forall (a : Type), forall (_1 : PLogic a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) => RecordProj pa "or".

Definition ecXor : forall (a : Type), forall (_1 : PLogic a), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) => RecordProj pa "xor".

Definition ecCompl : forall (a : Type), forall (_1 : PLogic a), forall (_2 : a), a :=
  fun (a : Type) (pa : RecordTypeCons "and" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "logicZero" a (RecordTypeCons "not" (forall (_1 : a), a) (RecordTypeCons "or" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "xor" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil))))) => RecordProj pa "not".

Definition ecZero : forall (a : Type), forall (_1 : PZero a), a :=
  fun (a : Type) (pa : a) => pa.

Definition ecFraction : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCoreScaffolding.error a "Unimplemented: fraction"%string.

Definition ecShiftL : forall (m : Num), forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : PZero a), forall (_3 : seq m a), forall (_4 : ix), seq m a :=
  fun (m : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (m1 : Num) => forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : PZero a), forall (_3 : seq m1 a), forall (_4 : ix), seq m1 a) (fun (m1 : Coq.Init.Datatypes.nat) (ix : Type) (a : Type) (pix : PIntegral ix) (pz : PZero a) (xs : SAWCoreVectorsAsCoqVectors.Vec m1 a) => let var__0   := ecZero a pz in
  RecordProj pix "posNegCases" (SAWCoreVectorsAsCoqVectors.Vec m1 a) (SAWCoreVectorsAsCoqVectors.shiftL m1 a var__0 xs) (SAWCoreVectorsAsCoqVectors.shiftR m1 a var__0 xs)) (fun (ix : Type) (a : Type) (pix : PIntegral ix) (pz : PZero a) (xs : SAWCorePrelude.Stream a) => RecordProj pix "posNegCases" (SAWCorePrelude.Stream a) (SAWCorePrelude.streamShiftL a xs) (SAWCorePrelude.streamShiftR a pz xs)) m.

Definition ecShiftR : forall (m : Num), forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : PZero a), forall (_3 : seq m a), forall (_4 : ix), seq m a :=
  fun (m : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (m1 : Num) => forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : PZero a), forall (_3 : seq m1 a), forall (_4 : ix), seq m1 a) (fun (m1 : Coq.Init.Datatypes.nat) (ix : Type) (a : Type) (pix : PIntegral ix) (pz : PZero a) (xs : SAWCoreVectorsAsCoqVectors.Vec m1 a) => let var__0   := ecZero a pz in
  RecordProj pix "posNegCases" (SAWCoreVectorsAsCoqVectors.Vec m1 a) (SAWCoreVectorsAsCoqVectors.shiftR m1 a var__0 xs) (SAWCoreVectorsAsCoqVectors.shiftL m1 a var__0 xs)) (fun (ix : Type) (a : Type) (pix : PIntegral ix) (pz : PZero a) (xs : SAWCorePrelude.Stream a) => RecordProj pix "posNegCases" (SAWCorePrelude.Stream a) (SAWCorePrelude.streamShiftR a pz xs) (SAWCorePrelude.streamShiftL a xs)) m.

Definition ecSShiftR : forall (n : Num), forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : ix), seq n Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : ix), seq n Coq.Init.Datatypes.bool) (fun (n : Coq.Init.Datatypes.nat) (ix : Type) (pix : PIntegral ix) => SAWCorePrelude.natCase (fun (w : Coq.Init.Datatypes.nat) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec w Coq.Init.Datatypes.bool), forall (_2 : ix), SAWCoreVectorsAsCoqVectors.Vec w Coq.Init.Datatypes.bool) (fun (xs : SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool) (_1 : ix) => xs) (fun (w : Coq.Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ w) Coq.Init.Datatypes.bool) => let var__0   := SAWCoreScaffolding.Succ w in
  RecordProj pix "posNegCases" (SAWCoreVectorsAsCoqVectors.Vec var__0 Coq.Init.Datatypes.bool) (SAWCoreVectorsAsCoqVectors.bvSShr w xs) (SAWCoreVectorsAsCoqVectors.bvShl var__0 xs)) n).

Definition ecRotL : forall (m : Num), forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : seq m a), forall (_3 : ix), seq m a :=
  finNumRec (fun (m : Num) => forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : seq m a), forall (_3 : ix), seq m a) (fun (m : Coq.Init.Datatypes.nat) (ix : Type) (a : Type) (pix : PIntegral ix) (xs : SAWCoreVectorsAsCoqVectors.Vec m a) => RecordProj pix "posNegCases" (SAWCoreVectorsAsCoqVectors.Vec m a) (SAWCoreVectorsAsCoqVectors.rotateL m a xs) (SAWCoreVectorsAsCoqVectors.rotateR m a xs)).

Definition ecRotR : forall (m : Num), forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : seq m a), forall (_3 : ix), seq m a :=
  finNumRec (fun (m : Num) => forall (ix : Type), forall (a : Type), forall (_1 : PIntegral ix), forall (_2 : seq m a), forall (_3 : ix), seq m a) (fun (m : Coq.Init.Datatypes.nat) (ix : Type) (a : Type) (pix : PIntegral ix) (xs : SAWCoreVectorsAsCoqVectors.Vec m a) => RecordProj pix "posNegCases" (SAWCoreVectorsAsCoqVectors.Vec m a) (SAWCoreVectorsAsCoqVectors.rotateR m a xs) (SAWCoreVectorsAsCoqVectors.rotateL m a xs)).

Definition ecCat : forall (m : Num), forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq m a), forall (_2 : seq n a), seq (tcAdd m n) a :=
  finNumRec (fun (m : Num) => forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq m a), forall (_2 : seq n a), seq (tcAdd m n) a) (fun (m : Coq.Init.Datatypes.nat) => CryptolPrimitivesForSAWCore.Num__rec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m a), forall (_2 : seq n a), seq (tcAdd (TCNum m) n) a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCorePrelude.append m n a) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCorePrelude.streamAppend a m)).

Definition ecTake : forall (m : Num), forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd m n) a), seq m a :=
  CryptolPrimitivesForSAWCore.Num__rec (fun (m : Num) => forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd m n) a), seq m a) (fun (m : Coq.Init.Datatypes.nat) => CryptolPrimitivesForSAWCore.Num__rec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd (TCNum m) n) a), SAWCoreVectorsAsCoqVectors.Vec m a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a) => SAWCorePrelude.take a m n xs) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCorePrelude.Stream a) => SAWCorePrelude.streamTake a m xs)) (CryptolPrimitivesForSAWCore.Num__rec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd TCInf n) a), SAWCorePrelude.Stream a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCorePrelude.Stream a) => xs) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCorePrelude.Stream a) => xs)).

Definition ecDrop : forall (m : Num), forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd m n) a), seq n a :=
  finNumRec (fun (m : Num) => forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd m n) a), seq n a) (fun (m : Coq.Init.Datatypes.nat) => CryptolPrimitivesForSAWCore.Num__rec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcAdd (TCNum m) n) a), seq n a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a) => SAWCorePrelude.drop a m n xs) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (xs : SAWCorePrelude.Stream a) => SAWCorePrelude.streamDrop a m xs)).

Definition ecJoin : forall (m : Num), forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq m (seq n a)), seq (tcMul m n) a :=
  fun (m : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (m1 : Num) => forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq m1 (seq n a)), seq (tcMul m1 n) a) (fun (m1 : Coq.Init.Datatypes.nat) => finNumRec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m1 (seq n a)), seq (tcMul (TCNum m1) n) a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCorePrelude.join m1 n a)) (finNumRec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCorePrelude.Stream (seq n a)), seq (tcMul TCInf n) a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCorePrelude.natCase (fun (n' : Coq.Init.Datatypes.nat) => forall (_1 : SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec n' a)), seq (SAWCorePrelude.if0Nat Num n' (TCNum 0) TCInf) a) (fun (s : SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 0 a)) => SAWCoreVectorsAsCoqVectors.EmptyVec a) (fun (n' : Coq.Init.Datatypes.nat) (s : SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n') a)) => SAWCorePrelude.streamJoin a n' s) n)) m.

Definition ecSplit : forall (m : Num), forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcMul m n) a), seq m (seq n a) :=
  fun (m : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (m1 : Num) => forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcMul m1 n) a), seq m1 (seq n a)) (fun (m1 : Coq.Init.Datatypes.nat) => finNumRec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcMul (TCNum m1) n) a), SAWCoreVectorsAsCoqVectors.Vec m1 (seq n a)) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCorePrelude.split m1 n a)) (finNumRec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq (tcMul TCInf n) a), SAWCorePrelude.Stream (seq n a)) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => SAWCorePrelude.natCase (fun (n' : Coq.Init.Datatypes.nat) => forall (_1 : seq (SAWCorePrelude.if0Nat Num n' (TCNum 0) TCInf) a), SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec n' a)) (SAWCorePrelude.streamConst (SAWCoreVectorsAsCoqVectors.Vec 0 a)) (fun (n' : Coq.Init.Datatypes.nat) => SAWCorePrelude.streamSplit a (SAWCoreScaffolding.Succ n')) n)) m.

Definition ecReverse : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq n a), seq n a :=
  finNumRec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq n a), seq n a) SAWCorePrelude.reverse.

Definition ecTranspose : forall (m : Num), forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : seq m (seq n a)), seq n (seq m a) :=
  fun (m : Num) (n : Num) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => let var__0   := @CryptolPrimitivesForSAWCore.Num_rect in
  var__0 (fun (m1 : Num) => forall (_1 : seq m1 (seq n a)), seq n (seq m1 a)) (fun (m1 : Coq.Init.Datatypes.nat) => var__0 (fun (n1 : Num) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m1 (seq n1 a)), seq n1 (SAWCoreVectorsAsCoqVectors.Vec m1 a)) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.transpose m1 n1 a) (fun (xss : SAWCoreVectorsAsCoqVectors.Vec m1 (SAWCorePrelude.Stream a)) => SAWCorePrelude.MkStream (SAWCoreVectorsAsCoqVectors.Vec m1 a) (fun (i : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.gen m1 a (fun (j : Coq.Init.Datatypes.nat) => SAWCorePrelude.streamGet a (SAWCorePrelude.sawAt m1 (SAWCorePrelude.Stream a) xss j) i))) n) (var__0 (fun (n1 : Num) => forall (_1 : SAWCorePrelude.Stream (seq n1 a)), seq n1 (SAWCorePrelude.Stream a)) (fun (n1 : Coq.Init.Datatypes.nat) (xss : SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec n1 a)) => SAWCoreVectorsAsCoqVectors.gen n1 (SAWCorePrelude.Stream a) (fun (i : Coq.Init.Datatypes.nat) => SAWCorePrelude.MkStream a (fun (j : Coq.Init.Datatypes.nat) => SAWCorePrelude.sawAt n1 a (SAWCorePrelude.streamGet (SAWCoreVectorsAsCoqVectors.Vec n1 a) xss j) i))) (fun (xss : SAWCorePrelude.Stream (SAWCorePrelude.Stream a)) => SAWCorePrelude.MkStream (SAWCorePrelude.Stream a) (fun (i : Coq.Init.Datatypes.nat) => SAWCorePrelude.MkStream a (fun (j : Coq.Init.Datatypes.nat) => SAWCorePrelude.streamGet a (SAWCorePrelude.streamGet (SAWCorePrelude.Stream a) xss j) i))) n) m.

Definition ecAt : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n a), forall (_3 : ix), a :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n1 a), forall (_3 : ix), a) (fun (n1 : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (ix : Type) (pix : PIntegral ix) (xs : SAWCoreVectorsAsCoqVectors.Vec n1 a) => RecordProj pix "posNegCases" a (SAWCorePrelude.sawAt n1 a xs) (fun (_1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.sawAt n1 a xs 0)) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (ix : Type) (pix : PIntegral ix) (xs : SAWCorePrelude.Stream a) => RecordProj pix "posNegCases" a (SAWCorePrelude.streamGet a xs) (fun (_1 : Coq.Init.Datatypes.nat) => SAWCorePrelude.streamGet a xs 0)) n.

Definition ecAtBack : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n a), forall (_3 : ix), a :=
  fun (n : Num) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (ix : Type) (pix : RecordTypeCons "div" (forall (_1 : ix), forall (_2 : ix), ix) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : ix), forall (_2 : ix), ix) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), ix) (RecordTypeCons "mul" (forall (_1 : ix), forall (_2 : ix), ix) (RecordTypeCons "neg" (forall (_1 : ix), ix) (RecordTypeCons "ringZero" ix (RecordTypeCons "sub" (forall (_1 : ix), forall (_2 : ix), ix) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : ix), forall (_2 : ix), ix) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : ix), r) (RecordTypeCons "toInt" (forall (_1 : ix), SAWCoreScaffolding.Integer) RecordTypeNil))))) (xs : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n1 a) (SAWCorePrelude.Stream a) n) => ecAt n a ix pix (ecReverse n a xs).

Definition ecFromTo : forall (first : Num), forall (last : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcSub last first)) a :=
  finNumRec (fun (first : Num) => forall (last : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcSub last first)) a) (fun (first : Coq.Init.Datatypes.nat) => finNumRec (fun (last : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcSub last (TCNum first))) a) (fun (last : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PLiteral a) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.addNat 1 (SAWCorePrelude.subNat last first)) a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCoreScaffolding.addNat i first)))).

Definition ecFromToLessThan : forall (first : Num), forall (bound : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteralLessThan a), seq (tcSub bound first) a :=
  fun (first : Num) (bound : Num) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => finNumRec (fun (first1 : Num) => forall (_1 : PLiteralLessThan a), seq (tcSub bound first1) a) (fun (first1 : Coq.Init.Datatypes.nat) => @CryptolPrimitivesForSAWCore.Num_rect (fun (bound1 : Num) => forall (_1 : PLiteralLessThan a), seq (tcSub bound1 (TCNum first1)) a) (fun (bound1 : Coq.Init.Datatypes.nat) (pa : PLiteralLessThan a) => SAWCoreVectorsAsCoqVectors.gen (SAWCorePrelude.subNat bound1 first1) a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCoreScaffolding.addNat i first1))) (fun (pa : PLiteralLessThan a) => SAWCorePrelude.MkStream a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCoreScaffolding.addNat i first1))) bound) first.

Definition ecFromThenTo : forall (first : Num), forall (next : Num), forall (last : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (len : Num), forall (_1 : PLiteral a), forall (_2 : PLiteral a), forall (_3 : PLiteral a), seq len a :=
  fun (first : Num) (next : Num) (_1 : Num) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => finNumRec (fun (len : Num) => forall (_2 : PLiteral a), forall (_3 : PLiteral a), forall (_4 : PLiteral a), seq len a) (fun (len : Coq.Init.Datatypes.nat) (pa : PLiteral a) (_2 : PLiteral a) (_3 : PLiteral a) => SAWCoreVectorsAsCoqVectors.gen len a (fun (i : Coq.Init.Datatypes.nat) => let var__0   := getFinNat first in
  pa (SAWCorePrelude.subNat (SAWCoreScaffolding.addNat var__0 (SAWCoreScaffolding.mulNat i (getFinNat next))) (SAWCoreScaffolding.mulNat i var__0)))).

Definition ecFromToBy : forall (first : Num), forall (last : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (tcSub last first) stride)) a :=
  finNumRec (fun (first : Num) => forall (last : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (tcSub last first) stride)) a) (fun (first : Coq.Init.Datatypes.nat) => finNumRec (fun (last : Num) => forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (tcSub last (TCNum first)) stride)) a) (fun (last : Coq.Init.Datatypes.nat) => finNumRec (fun (stride : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (TCNum (SAWCorePrelude.subNat last first)) stride)) a) (fun (stride : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PLiteral a) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.addNat 1 (SAWCorePrelude.divNat (SAWCorePrelude.subNat last first) stride)) a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCoreScaffolding.addNat first (SAWCoreScaffolding.mulNat i stride)))))).

Definition ecFromToByLessThan : forall (first : Num), forall (bound : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteralLessThan a), seq (tcCeilDiv (tcSub bound first) stride) a :=
  finNumRec (fun (first : Num) => forall (bound : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteralLessThan a), seq (tcCeilDiv (tcSub bound first) stride) a) (fun (first : Coq.Init.Datatypes.nat) => CryptolPrimitivesForSAWCore.Num__rec (fun (bound : Num) => forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteralLessThan a), seq (tcCeilDiv (tcSub bound (TCNum first)) stride) a) (fun (bound : Coq.Init.Datatypes.nat) => finNumRec (fun (stride : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteralLessThan a), seq (tcCeilDiv (TCNum (SAWCorePrelude.subNat bound first)) stride) a) (fun (stride : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PLiteralLessThan a) => SAWCoreVectorsAsCoqVectors.gen (ceilDivNat (SAWCorePrelude.subNat bound first) stride) a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCoreScaffolding.addNat first (SAWCoreScaffolding.mulNat i stride))))) (finNumRec (fun (stride : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteralLessThan a), seq (tcCeilDiv TCInf stride) a) (fun (stride : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PLiteralLessThan a) => SAWCorePrelude.MkStream a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCoreScaffolding.addNat first (SAWCoreScaffolding.mulNat i stride)))))).

Definition ecFromToDownBy : forall (first : Num), forall (last : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (tcSub first last) stride)) a :=
  finNumRec (fun (first : Num) => forall (last : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (tcSub first last) stride)) a) (fun (first : Coq.Init.Datatypes.nat) => finNumRec (fun (last : Num) => forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (tcSub (TCNum first) last) stride)) a) (fun (last : Coq.Init.Datatypes.nat) => finNumRec (fun (stride : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcAdd (TCNum 1) (tcDiv (TCNum (SAWCorePrelude.subNat first last)) stride)) a) (fun (stride : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PLiteral a) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.addNat 1 (SAWCorePrelude.divNat (SAWCorePrelude.subNat first last) stride)) a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCorePrelude.subNat first (SAWCoreScaffolding.mulNat i stride)))))).

Definition ecFromToDownByGreaterThan : forall (first : Num), forall (bound : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcCeilDiv (tcSub first bound) stride) a :=
  finNumRec (fun (first : Num) => forall (bound : Num), forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcCeilDiv (tcSub first bound) stride) a) (fun (first : Coq.Init.Datatypes.nat) => finNumRec (fun (bound : Num) => forall (stride : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcCeilDiv (tcSub (TCNum first) bound) stride) a) (fun (bound : Coq.Init.Datatypes.nat) => finNumRec (fun (stride : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : PLiteral a), seq (tcCeilDiv (TCNum (SAWCorePrelude.subNat first bound)) stride) a) (fun (stride : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (pa : PLiteral a) => SAWCoreVectorsAsCoqVectors.gen (ceilDivNat (SAWCorePrelude.subNat first bound) stride) a (fun (i : Coq.Init.Datatypes.nat) => pa (SAWCorePrelude.subNat first (SAWCoreScaffolding.mulNat i stride)))))).

Definition ecInfFrom : forall (a : Type), forall (_1 : PIntegral a), forall (_2 : a), seq TCInf a :=
  fun (a : Type) (pa : RecordTypeCons "div" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : a), r) (RecordTypeCons "toInt" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))) (x : a) => SAWCorePrelude.MkStream a (fun (i : Coq.Init.Datatypes.nat) => let var__0   := RecordProj pa "integralRing" in
  RecordProj var__0 "add" x (RecordProj var__0 "int" (SAWCoreScaffolding.natToInt i))).

Definition ecInfFromThen : forall (a : Type), forall (_1 : PIntegral a), forall (_2 : a), forall (_3 : a), seq TCInf a :=
  fun (a : Type) (pa : RecordTypeCons "div" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "integralRing" (RecordTypeCons "add" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "int" (forall (_1 : SAWCoreScaffolding.Integer), a) (RecordTypeCons "mul" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "neg" (forall (_1 : a), a) (RecordTypeCons "ringZero" a (RecordTypeCons "sub" (forall (_1 : a), forall (_2 : a), a) RecordTypeNil)))))) (RecordTypeCons "mod" (forall (_1 : a), forall (_2 : a), a) (RecordTypeCons "posNegCases" (forall (r : Type), forall (_1 : forall (_1 : Coq.Init.Datatypes.nat), r), forall (_2 : forall (_2 : Coq.Init.Datatypes.nat), r), forall (_3 : a), r) (RecordTypeCons "toInt" (forall (_1 : a), SAWCoreScaffolding.Integer) RecordTypeNil))))) (x : a) (y : a) => SAWCorePrelude.MkStream a (fun (i : Coq.Init.Datatypes.nat) => let var__0   := RecordProj pa "integralRing" in
  RecordProj var__0 "add" x (RecordProj var__0 "mul" (RecordProj var__0 "sub" y x) (RecordProj var__0 "int" (SAWCoreScaffolding.natToInt i)))).

Definition ecError : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (len : Num), forall (_1 : seq len (SAWCoreVectorsAsCoqVectors.Vec 8 Coq.Init.Datatypes.bool)), a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} => finNumRec (fun (len : Num) => forall (_1 : seq len (SAWCoreVectorsAsCoqVectors.Vec 8 Coq.Init.Datatypes.bool)), a) (fun (len : Coq.Init.Datatypes.nat) (msg : SAWCoreVectorsAsCoqVectors.Vec len (SAWCoreVectorsAsCoqVectors.Vec 8 Coq.Init.Datatypes.bool)) => SAWCoreScaffolding.error a (SAWCoreScaffolding.appendString "encountered call to the Cryptol 'error' function: "%string (SAWCorePrelude.bytesToString len msg))).

Definition ecRandom : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool), a :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (_1 : SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) => SAWCoreScaffolding.error a "Cryptol.random"%string.

Definition ecTrace : forall (n : Num), forall (a : Type), forall (b : Type), forall (_1 : seq n (SAWCoreVectorsAsCoqVectors.Vec 8 Coq.Init.Datatypes.bool)), forall (_2 : a), forall (_3 : b), b :=
  fun (n : Num) (a : Type) (b : Type) (_1 : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n1 (SAWCoreVectorsAsCoqVectors.Vec 8 Coq.Init.Datatypes.bool)) (SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 8 Coq.Init.Datatypes.bool)) n) (_2 : a) (x : b) => x.

Definition ecDeepseq : forall (a : Type), forall (b : Type), forall (_1 : PEq a), forall (_2 : a), forall (_3 : b), b :=
  fun (a : Type) (b : Type) (pa : RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) (x : a) (y : b) => y.

Definition ecParmap : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (n : Num), forall (_1 : PEq b), forall (_2 : forall (_2 : a), b), forall (_3 : seq n a), seq n b :=
  fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (n : Num) (pb : RecordTypeCons "eq" (forall (_1 : b), forall (_2 : b), Coq.Init.Datatypes.bool) RecordTypeNil) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : forall (_1 : a), b), forall (_2 : seq n1 a), seq n1 b) (fun (n1 : Coq.Init.Datatypes.nat) (f : forall (_1 : a), b) (xs : SAWCoreVectorsAsCoqVectors.Vec n1 a) => SAWCorePrelude.map a b f n1 xs) (fun (f : forall (_1 : a), b) (xs : SAWCorePrelude.Stream a) => SAWCoreScaffolding.error (SAWCorePrelude.Stream b) "Unexpected infinite stream in parmap"%string) n.

Definition ecFoldl : forall (n : Num), forall (a : Type), forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (_1 : forall (_1 : a), forall (_2 : b), a), forall (_2 : a), forall (_3 : seq n b), a :=
  fun (n : Num) (a : Type) (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (f : forall (_1 : a), forall (_2 : b), a) (z : a) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 b), a) (fun (n1 : Coq.Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n1 b) => SAWCoreVectorsAsCoqVectors.foldl b a n1 f z xs) (fun (xs : SAWCorePrelude.Stream b) => SAWCoreScaffolding.error a "Unexpected infinite stream in foldl"%string) n.

Definition ecFoldlPrime : forall (n : Num), forall (a : Type), forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (_1 : PEq a), forall (_2 : forall (_2 : a), forall (_3 : b), a), forall (_3 : a), forall (_4 : seq n b), a :=
  fun (n : Num) (a : Type) (b : Type) {Inh_b : SAWCoreScaffolding.Inhabited b} (pa : RecordTypeCons "eq" (forall (_1 : a), forall (_2 : a), Coq.Init.Datatypes.bool) RecordTypeNil) => ecFoldl n a b.

Definition ecScanl : forall (n : Num), forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), forall (_2 : b), a), forall (_2 : a), forall (_3 : seq n b), seq (tcAdd (TCNum 1) n) a :=
  fun (n : Num) (a : Type) (b : Type) (f : forall (_1 : a), forall (_2 : b), a) (z : a) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (_1 : seq n1 b), seq (tcAdd (TCNum 1) n1) a) (fun (n1 : Coq.Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n1 b) => SAWCoreVectorsAsCoqVectors.scanl b a n1 f z xs) (fun (xs : SAWCorePrelude.Stream b) => SAWCorePreludeExtra.streamScanl b a f z xs) n.

Definition TCFloat : forall (_1 : Num), forall (_2 : Num), Type :=
  fun (_1 : Num) (_2 : Num) => unit : Type.

Definition PEqFloat : forall (e : Num), forall (p : Num), PEq (TCFloat e p) :=
  fun (e : Num) (p : Num) => RecordCons "eq" (fun (x : TCFloat e p) (y : TCFloat e p) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: (==) Float"%string) RecordNil.

Definition PCmpFloat : forall (e : Num), forall (p : Num), PCmp (TCFloat e p) :=
  fun (e : Num) (p : Num) => let var__0   := TCFloat e p in
  RecordCons "cmp" (fun (x : var__0) (y : var__0) (k : Coq.Init.Datatypes.bool) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: Cmp Float"%string) (RecordCons "cmpEq" (PEqFloat e p) (RecordCons "le" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: Cmp Float"%string) (RecordCons "lt" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: Cmp Float"%string) RecordNil))).

Definition PZeroFloat : forall (e : Num), forall (p : Num), PZero (TCFloat e p) :=
  fun (e : Num) (p : Num) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: Zero Float"%string.

Definition PRingFloat : forall (e : Num), forall (p : Num), PRing (TCFloat e p) :=
  fun (e : Num) (p : Num) => let var__0   := TCFloat e p in
  RecordCons "add" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: (+) Float"%string) (RecordCons "int" (fun (i : SAWCoreScaffolding.Integer) => SAWCoreScaffolding.error var__0 "Unimplemented: toInteger Float"%string) (RecordCons "mul" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: (*) Float"%string) (RecordCons "neg" (fun (x : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: neg Float"%string) (RecordCons "ringZero" (PZeroFloat e p) (RecordCons "sub" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: (-) Float"%string) RecordNil))))).

Definition PFieldFloat : forall (e : Num), forall (p : Num), PField (TCFloat e p) :=
  fun (e : Num) (p : Num) => let var__0   := TCFloat e p in
  RecordCons "fieldDiv" (fun (x : var__0) (y : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: (/.) Float"%string) (RecordCons "fieldRing" (PRingFloat e p) (RecordCons "recip" (fun (x : var__0) => SAWCoreScaffolding.error var__0 "Unimplemented: recip Float"%string) RecordNil)).

Definition PRoundFloat : forall (e : Num), forall (p : Num), PRound (TCFloat e p) :=
  fun (e : Num) (p : Num) => let var__0   := TCFloat e p in
  RecordCons "ceiling" (fun (x : var__0) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: ceiling Float"%string) (RecordCons "floor" (fun (x : var__0) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: floor Float"%string) (RecordCons "roundAway" (fun (x : var__0) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: roundAway Float"%string) (RecordCons "roundCmp" (PCmpFloat e p) (RecordCons "roundField" (PFieldFloat e p) (RecordCons "roundToEven" (fun (x : var__0) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: roundToEven Float"%string) (RecordCons "trunc" (fun (x : var__0) => SAWCoreScaffolding.error SAWCoreScaffolding.Integer "Unimplemented: trunc Float"%string) RecordNil)))))).

Definition PLiteralFloat : forall (e : Num), forall (p : Num), PLiteral (TCFloat e p) :=
  fun (e : Num) (p : Num) (x : Coq.Init.Datatypes.nat) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: Literal Float"%string.

Definition ecFpNaN : forall (e : Num), forall (p : Num), TCFloat e p :=
  fun (e : Num) (p : Num) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpNaN"%string.

Definition ecFpPosInf : forall (e : Num), forall (p : Num), TCFloat e p :=
  fun (e : Num) (p : Num) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpPosInf"%string.

Definition ecFpFromBits : forall (e : Num), forall (p : Num), forall (_1 : seq (tcAdd e p) Coq.Init.Datatypes.bool), TCFloat e p :=
  fun (e : Num) (p : Num) (_1 : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (SAWCorePrelude.Stream Coq.Init.Datatypes.bool) (@CryptolPrimitivesForSAWCore.Num_rect (fun (num1' : Num) => Num) (fun (n1 : Coq.Init.Datatypes.nat) => @CryptolPrimitivesForSAWCore.Num_rect (fun (num2' : Num) => Num) (fun (n2 : Coq.Init.Datatypes.nat) => TCNum (SAWCoreScaffolding.addNat n1 n2)) ((fun (x : Coq.Init.Datatypes.nat) => TCInf) n1) p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (num2' : Num) => Num) (fun (y : Coq.Init.Datatypes.nat) => TCInf) TCInf p) e)) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpFromBits"%string.

Definition ecFpToBits : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), seq (tcAdd e p) Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (_1 : unit : Type) => SAWCoreScaffolding.error (seq (tcAdd e p) Coq.Init.Datatypes.bool) "Unimplemented: fpToBits"%string.

Definition ecFpEq : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), forall (_2 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (_1 : unit : Type) (_2 : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: =.="%string.

Definition ecFpAdd : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : TCFloat e p), forall (_3 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (_2 : unit : Type) (_3 : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpAdd"%string.

Definition ecFpSub : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : TCFloat e p), forall (_3 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (_2 : unit : Type) (_3 : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpSub"%string.

Definition ecFpMul : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : TCFloat e p), forall (_3 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (_2 : unit : Type) (_3 : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpMul"%string.

Definition ecFpDiv : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : TCFloat e p), forall (_3 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (_2 : unit : Type) (_3 : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpDiv"%string.

Definition ecFpToRational : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Rational :=
  fun (e : Num) (p : Num) (_1 : unit : Type) => SAWCoreScaffolding.error Rational "Unimplemented: fpToRational"%string.

Definition ecFpFromRational : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : Rational), TCFloat e p :=
  fun (e : Num) (p : Num) (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (_2 : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpFromRational"%string.

Definition fpIsNaN : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: fpIsNaN"%string.

Definition fpIsInf : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: fpIsInf"%string.

Definition fpIsZero : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: fpIsZero"%string.

Definition fpIsNeg : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: fpIsNeg"%string.

Definition fpIsNormal : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: fpIsNormal"%string.

Definition fpIsSubnormal : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), Coq.Init.Datatypes.bool :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error Coq.Init.Datatypes.bool "Unimplemented: fpIsSubnormal"%string.

Definition fpFMA : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : TCFloat e p), forall (_3 : TCFloat e p), forall (_4 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (r : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (x : unit : Type) (y : unit : Type) (z : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpFMA"%string.

Definition fpAbs : forall (e : Num), forall (p : Num), forall (_1 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (x : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpAbs"%string.

Definition fpSqrt : forall (e : Num), forall (p : Num), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool), forall (_2 : TCFloat e p), TCFloat e p :=
  fun (e : Num) (p : Num) (r : SAWCoreVectorsAsCoqVectors.Vec 3 Coq.Init.Datatypes.bool) (x : unit : Type) => SAWCoreScaffolding.error (TCFloat e p) "Unimplemented: fpSqrt"%string.

Definition ecUpdate : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n a), forall (_3 : ix), forall (_4 : a), seq n a :=
  fun (n : Num) => @CryptolPrimitivesForSAWCore.Num_rect (fun (n1 : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n1 a), forall (_3 : ix), forall (_4 : a), seq n1 a) (fun (n1 : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (ix : Type) (pix : PIntegral ix) (xs : SAWCoreVectorsAsCoqVectors.Vec n1 a) => RecordProj pix "posNegCases" (forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec n1 a) (SAWCorePrelude.upd n1 a xs) (fun (_1 : Coq.Init.Datatypes.nat) (_2 : a) => xs)) (fun (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (ix : Type) (pix : PIntegral ix) (xs : SAWCorePrelude.Stream a) => RecordProj pix "posNegCases" (forall (_1 : a), SAWCorePrelude.Stream a) (SAWCorePrelude.streamUpd a xs) (fun (_1 : Coq.Init.Datatypes.nat) (_2 : a) => xs)) n.

Definition ecUpdateEnd : forall (n : Num), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n a), forall (_3 : ix), forall (_4 : a), seq n a :=
  finNumRec (fun (n : Num) => forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (ix : Type), forall (_1 : PIntegral ix), forall (_2 : seq n a), forall (_3 : ix), forall (_4 : a), seq n a) (fun (n : Coq.Init.Datatypes.nat) (a : Type) {Inh_a : SAWCoreScaffolding.Inhabited a} (ix : Type) (pix : PIntegral ix) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) => RecordProj pix "posNegCases" (forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec n a) (fun (i : Coq.Init.Datatypes.nat) => SAWCorePrelude.upd n a xs (SAWCorePrelude.subNat (SAWCorePrelude.subNat n 1) i)) (fun (_1 : Coq.Init.Datatypes.nat) (_2 : a) => xs)).

Definition ecTrunc : forall (m : Num), forall (n : Num), forall (_1 : seq (tcAdd m n) Coq.Init.Datatypes.bool), seq n Coq.Init.Datatypes.bool :=
  finNumRec2 (fun (m : Num) (n : Num) => forall (_1 : seq (tcAdd m n) Coq.Init.Datatypes.bool), seq n Coq.Init.Datatypes.bool) SAWCorePrelude.bvTrunc.

Definition ecUExt : forall (m : Num), forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), seq (tcAdd m n) Coq.Init.Datatypes.bool :=
  finNumRec2 (fun (m : Num) (n : Num) => forall (_1 : seq n Coq.Init.Datatypes.bool), seq (tcAdd m n) Coq.Init.Datatypes.bool) SAWCorePrelude.bvUExt.

Definition ecSExt : forall (m : Num), forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), seq (tcAdd m n) Coq.Init.Datatypes.bool :=
  finNumRec2 (fun (m : Num) (n : Num) => forall (_1 : seq n Coq.Init.Datatypes.bool), seq (tcAdd m n) Coq.Init.Datatypes.bool) (fun (m : Coq.Init.Datatypes.nat) (n : Coq.Init.Datatypes.nat) => SAWCorePrelude.natCase (fun (n' : Coq.Init.Datatypes.nat) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n' Coq.Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n') Coq.Init.Datatypes.bool) (fun (_1 : SAWCoreVectorsAsCoqVectors.Vec 0 Coq.Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.bvNat (SAWCoreScaffolding.addNat m 0) 0) (SAWCorePrelude.bvSExt m) n).

Definition ecSgt : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) SAWCoreVectorsAsCoqVectors.bvsgt.

Definition ecSge : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) SAWCoreVectorsAsCoqVectors.bvsge.

Definition ecSlt : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) SAWCoreVectorsAsCoqVectors.bvslt.

Definition ecSle : forall (n : Num), forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (_1 : seq n Coq.Init.Datatypes.bool), forall (_2 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) SAWCoreVectorsAsCoqVectors.bvsle.

Definition ecArrayConstant : forall (a : Type), forall (b : Type), forall (_1 : b), SAWCorePrelude.Array a b :=
  SAWCorePrelude.arrayConstant.

Definition ecArrayLookup : forall (a : Type), forall (b : Type), forall (_1 : SAWCorePrelude.Array a b), forall (_2 : a), b :=
  SAWCorePrelude.arrayLookup.

Definition ecArrayUpdate : forall (a : Type), forall (b : Type), forall (_1 : SAWCorePrelude.Array a b), forall (_2 : a), forall (_3 : b), SAWCorePrelude.Array a b :=
  SAWCorePrelude.arrayUpdate.

Definition ecArrayCopy : forall (n : Num), forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_4 : seq n Coq.Init.Datatypes.bool), forall (_5 : seq n Coq.Init.Datatypes.bool), SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a :=
  finNumRec (fun (n : Num) => forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_4 : seq n Coq.Init.Datatypes.bool), forall (_5 : seq n Coq.Init.Datatypes.bool), SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a) SAWCorePrelude.arrayCopy.

Definition ecArrayEq : forall (n : Num), forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), Coq.Init.Datatypes.bool) (fun (n : Coq.Init.Datatypes.nat) => SAWCorePrelude.arrayEq (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool)).

Definition ecArraySet : forall (n : Num), forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : a), forall (_4 : seq n Coq.Init.Datatypes.bool), SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a :=
  finNumRec (fun (n : Num) => forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : a), forall (_4 : seq n Coq.Init.Datatypes.bool), SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a) SAWCorePrelude.arraySet.

Definition ecArrayRangeEq : forall (n : Num), forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_4 : seq n Coq.Init.Datatypes.bool), forall (_5 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool :=
  finNumRec (fun (n : Num) => forall (a : Type), forall (_1 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_2 : seq n Coq.Init.Datatypes.bool), forall (_3 : SAWCorePrelude.Array (seq n Coq.Init.Datatypes.bool) a), forall (_4 : seq n Coq.Init.Datatypes.bool), forall (_5 : seq n Coq.Init.Datatypes.bool), Coq.Init.Datatypes.bool) SAWCorePrelude.arrayRangeEq.

Definition AESEncRound : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)), SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (x : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: AESEncRound"%string.

Definition AESEncFinalRound : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)), SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (x : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: AESEncFinalRound"%string.

Definition AESDecRound : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)), SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (x : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: AESDecRound"%string.

Definition AESDecFinalRound : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)), SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (x : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: AESDecFinalRound"%string.

Definition AESInvMixColumns : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)), SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (x : SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 4 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: AESInvMixColumns"%string.

Definition AESKeyExpand : forall (k : Num), forall (_1 : seq k (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)), seq (tcMul (TCNum 4) (tcAdd (TCNum 7) k)) (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (k : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) (SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) k) => SAWCoreScaffolding.error (seq (tcMul (TCNum 4) (tcAdd (TCNum 7) k)) (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: AESKeyExpand"%string.

Definition processSHA2_224 : forall (n : Num), forall (_1 : seq n (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool))), SAWCoreVectorsAsCoqVectors.Vec 7 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (n : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n1 (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool))) (SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool))) n) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 7 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: processSHA2_224"%string.

Definition processSHA2_256 : forall (n : Num), forall (_1 : seq n (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool))), SAWCoreVectorsAsCoqVectors.Vec 8 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool) :=
  fun (n : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n1 (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool))) (SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool))) n) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 8 (SAWCoreVectorsAsCoqVectors.Vec 32 Coq.Init.Datatypes.bool)) "Unimplemented: processSHA2_256"%string.

Definition processSHA2_384 : forall (n : Num), forall (_1 : seq n (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool))), SAWCoreVectorsAsCoqVectors.Vec 6 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool) :=
  fun (n : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n1 (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool))) (SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool))) n) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 6 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool)) "Unimplemented: processSHA2_384"%string.

Definition processSHA2_512 : forall (n : Num), forall (_1 : seq n (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool))), SAWCoreVectorsAsCoqVectors.Vec 8 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool) :=
  fun (n : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (num : Num) => Type) (fun (n1 : Coq.Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec n1 (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool))) (SAWCorePrelude.Stream (SAWCoreVectorsAsCoqVectors.Vec 16 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool))) n) => SAWCoreScaffolding.error (SAWCoreVectorsAsCoqVectors.Vec 8 (SAWCoreVectorsAsCoqVectors.Vec 64 Coq.Init.Datatypes.bool)) "Unimplemented: processSHA2_512"%string.

Definition ec_double : forall (p : Num), forall (_1 : prod (IntModNum p) (prod (IntModNum p) (IntModNum p))), let var__0   := IntModNum p in
  prod var__0 (prod var__0 var__0) :=
  fun (p : Num) (x : prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p))) => let var__0   := IntModNum p in
  SAWCoreScaffolding.error (prod var__0 (prod var__0 var__0)) "Unimplemented: ec_double"%string.

Definition ec_add_nonzero : forall (p : Num), forall (_1 : prod (IntModNum p) (prod (IntModNum p) (IntModNum p))), forall (_2 : prod (IntModNum p) (prod (IntModNum p) (IntModNum p))), let var__0   := IntModNum p in
  prod var__0 (prod var__0 var__0) :=
  fun (p : Num) (x : prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p))) (y : prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p))) => let var__0   := IntModNum p in
  SAWCoreScaffolding.error (prod var__0 (prod var__0 var__0)) "Unimplemented: ec_add_nonzero"%string.

Definition ec_mult : forall (p : Num), forall (_1 : IntModNum p), forall (_2 : prod (IntModNum p) (prod (IntModNum p) (IntModNum p))), let var__0   := IntModNum p in
  prod var__0 (prod var__0 var__0) :=
  fun (p : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (y : prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p))) => let var__0   := IntModNum p in
  SAWCoreScaffolding.error (prod var__0 (prod var__0 var__0)) "Unimplemented: ec_mult"%string.

Definition ec_twin_mult : forall (p : Num), forall (_1 : IntModNum p), forall (_2 : prod (IntModNum p) (prod (IntModNum p) (IntModNum p))), forall (_3 : prod (IntModNum p) (prod (IntModNum p) (IntModNum p))), let var__0   := IntModNum p in
  prod var__0 (prod var__0 var__0) :=
  fun (p : Num) (x : @CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (y : prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p))) (z : prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (prod (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p) (@CryptolPrimitivesForSAWCore.Num_rect (fun (n : Num) => Type) SAWCoreScaffolding.IntMod SAWCoreScaffolding.Integer p))) => let var__0   := IntModNum p in
  SAWCoreScaffolding.error (prod var__0 (prod var__0 var__0)) "Unimplemented: ec_twin_mult"%string.

Axiom replicate_False : forall (n : Coq.Init.Datatypes.nat), @Coq.Init.Logic.eq (SAWCoreVectorsAsCoqVectors.Vec n Coq.Init.Datatypes.bool) (SAWCorePrelude.replicate n Coq.Init.Datatypes.bool Coq.Init.Datatypes.false) (SAWCoreVectorsAsCoqVectors.bvNat n 0) .

Axiom subNat_0 : forall (n : Coq.Init.Datatypes.nat), @Coq.Init.Logic.eq Coq.Init.Datatypes.nat (SAWCorePrelude.subNat n 0) n .

End CryptolPrimitivesForSAWCore.

