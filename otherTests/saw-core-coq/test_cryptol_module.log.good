 Loading file "test_cryptol_module.saw"
Malformed term: let { x@1 = Cryptol.TCNum 0
      x@2 = Cryptol.TCNum 1
      x@3 = Cryptol.TCNum 8
      x@4 = Cryptol.TCNum 64
      x@5 = Cryptol.seq x@4 Prelude.Bool
      x@6 = Cryptol.TCNum 80
      x@7 = Cryptol.seq x@6 x@5
      x@8 = Cryptol.TCNum 81
      x@9 = Cryptol.seq x@8 x@5
      x@10 = #{T1 : x@7
      ,T2 : x@9
      ,as : x@9
      ,bs : x@9
      ,cs : x@9
      ,ds : x@9
      ,es : x@9
      ,fs : x@9
      ,gs : x@9
      ,hs : x@9}
      x@11 = x@5 * x@5
      x@12 = x@5 * x@11
      x@13 = Cryptol.tcMin x@8 x@6
      x@14 = x@5 * x@12
      x@15 = Cryptol.tcMin x@8 x@13
      x@16 = x@5 * x@14
      x@17 = Cryptol.tcMin x@8 x@15
      x@18 = Cryptol.tcMin x@8 x@17
      x@19 = Cryptol.PRingSeqBool x@4
      x@20 = Cryptol.tcAdd x@2 x@8
      x@21 = Cryptol.seq x@20 x@5
      x@22 = Cryptol.tcAdd x@8 x@2
      x@23 = Cryptol.seq x@22 x@5
      x@24 = Cryptol.seq_cong1 x@20 x@22 x@5
               (Prelude.unsafeAssert Cryptol.Num x@20 x@22)
      x@25 = Cryptol.tcAdd x@2 x@6
      x@26 = Cryptol.seq x@25 x@5
      x@27 = Cryptol.tcAdd x@8 x@1
      x@28 = Cryptol.seq x@27 x@5
      x@29 = Cryptol.seq_cong1 x@25 x@27 x@5
               (Prelude.unsafeAssert Cryptol.Num x@25 x@27)
      x@30 = Cryptol.tcMin x@6 x@8
    }
 in Prelude.fix x@10
      (\(fixRecord : x@10) ->
         let { x@31 = fixRecord.T1
               x@32 = fixRecord.gs
               x@33 = fixRecord.fs
               x@34 = fixRecord.es
               x@35 = fixRecord.cs
               x@36 = fixRecord.bs
               x@37 = fixRecord.as
             }
          in {T1 =
           Prelude.coerce (Cryptol.seq x@18 x@5) x@7
             (Cryptol.seq_cong1 x@18 x@6 x@5
                (Prelude.unsafeAssert Cryptol.Num x@18 x@6))
             (Cryptol.seqMap (x@5 * x@16) x@5 x@18
                (Prelude.uncurry x@5 x@16 x@5
                   (\(h : x@5) ->
                      Prelude.uncurry x@5 x@14 x@5
                        (\(e : x@5) ->
                           Prelude.uncurry x@5 x@12 x@5
                             (\(f : x@5) ->
                                Prelude.uncurry x@5 x@11 x@5
                                  (\(g : x@5) ->
                                     Prelude.uncurry x@5 x@5 x@5
                                       (\(k_t : x@5) ->
                                          \(w_t : x@5) ->
                                            Cryptol.ecPlus x@5 x@19
                                              (Cryptol.ecPlus x@5 x@19
                                                 (Cryptol.ecPlus x@5 x@19
                                                    (Cryptol.ecPlus x@5 x@19 h (cryptol:/SHA512/S1 e))
                                                    (cryptol:/SHA512/Ch e f g))
                                                 k_t)
                                              w_t))))))
                (Cryptol.seqZip x@5 x@16 x@8 x@17 fixRecord.hs
                   (Cryptol.seqZip x@5 x@14 x@8 x@15 x@34
                      (Cryptol.seqZip x@5 x@12 x@8 x@13 x@33
                         (Cryptol.seqZip x@5 x@11 x@8 x@6 x@32
                            (Cryptol.seqZipSame x@5 x@5 x@6 cryptol:/SHA512/SHA__parameter/K
                               W))))))
         ,T2 =
           Cryptol.seqMap x@12 x@5 x@8
             (Prelude.uncurry x@5 x@11 x@5
                (\(a : x@5) ->
                   Prelude.uncurry x@5 x@5 x@5
                     (\(b : x@5) ->
                        \(c : x@5) ->
                          Cryptol.ecPlus x@5 x@19 (cryptol:/SHA512/S0 a)
                            (cryptol:/SHA512/Maj a b c))))
             (Cryptol.seqZipSame x@5 x@11 x@8 x@37
                (Cryptol.seqZipSame x@5 x@5 x@8 x@36 x@35))
         ,as =
           Cryptol.ecTake x@8 x@1 x@5
             (Prelude.coerce x@26 x@28 x@29
                (Cryptol.ecCat x@2 x@6 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber x@1 Prelude.Integer Cryptol.PLiteralInteger) ]
                   (Prelude.coerce (Cryptol.seq x@30 x@5) x@7
                      (Cryptol.seq_cong1 x@30 x@6 x@5
                         (Prelude.unsafeAssert Cryptol.Num x@30 x@6))
                      (Cryptol.seqMap x@11 x@5 x@30
                         (Prelude.uncurry x@5 x@5 x@5
                            (\(t1 : x@5) -> \(t2 : x@5) -> Cryptol.ecPlus x@5 x@19 t1 t2))
                         (Cryptol.seqZip x@5 x@5 x@6 x@8 x@31 fixRecord.T2)))))
         ,bs =
           Cryptol.ecTake x@8 x@2 x@5
             (Prelude.coerce x@21 x@23 x@24
                (Cryptol.ecCat x@2 x@8 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber x@2 Prelude.Integer Cryptol.PLiteralInteger) ]
                   x@37))
         ,cs =
           Cryptol.ecTake x@8 x@2 x@5
             (Prelude.coerce x@21 x@23 x@24
                (Cryptol.ecCat x@2 x@8 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber (Cryptol.TCNum 2) Prelude.Integer
                          Cryptol.PLiteralInteger) ]
                   x@36))
         ,ds =
           Cryptol.ecTake x@8 x@2 x@5
             (Prelude.coerce x@21 x@23 x@24
                (Cryptol.ecCat x@2 x@8 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber (Cryptol.TCNum 3) Prelude.Integer
                          Cryptol.PLiteralInteger) ]
                   x@35))
         ,es =
           Cryptol.ecTake x@8 x@1 x@5
             (Prelude.coerce x@26 x@28 x@29
                (Cryptol.ecCat x@2 x@6 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber (Cryptol.TCNum 4) Prelude.Integer
                          Cryptol.PLiteralInteger) ]
                   (Prelude.coerce (Cryptol.seq x@13 x@5) x@7
                      (Cryptol.seq_cong1 x@13 x@6 x@5
                         (Prelude.unsafeAssert Cryptol.Num x@13 x@6))
                      (Cryptol.seqMap x@11 x@5 x@13
                         (Prelude.uncurry x@5 x@5 x@5
                            (\(d : x@5) -> \(t1 : x@5) -> Cryptol.ecPlus x@5 x@19 d t1))
                         (Cryptol.seqZip x@5 x@5 x@8 x@6 fixRecord.ds x@31)))))
         ,fs =
           Cryptol.ecTake x@8 x@2 x@5
             (Prelude.coerce x@21 x@23 x@24
                (Cryptol.ecCat x@2 x@8 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber (Cryptol.TCNum 5) Prelude.Integer
                          Cryptol.PLiteralInteger) ]
                   x@34))
         ,gs =
           Cryptol.ecTake x@8 x@2 x@5
             (Prelude.coerce x@21 x@23 x@24
                (Cryptol.ecCat x@2 x@8 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber (Cryptol.TCNum 6) Prelude.Integer
                          Cryptol.PLiteralInteger) ]
                   x@33))
         ,hs =
           Cryptol.ecTake x@8 x@2 x@5
             (Prelude.coerce x@21 x@23 x@24
                (Cryptol.ecCat x@2 x@8 x@5
                   [ Cryptol.ecAt x@3 x@5 Prelude.Integer Cryptol.PIntegralInteger
                       H
                       (Cryptol.ecNumber (Cryptol.TCNum 7) Prelude.Integer
                          Cryptol.PLiteralInteger) ]
                   x@32))})
