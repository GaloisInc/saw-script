Loading file "test_prelude.saw"

(** Mandatory imports from saw-core-coq *)
From Stdlib       Require Import Lists.List.
From Stdlib       Require Import String.
#[local] Set Warnings "-stdlib-vector".
From Stdlib       Require Import Vectors.Vector.
#[local] Set Warnings "stdlib-vector".
From CryptolToCoq Require Import SAWCoreScaffolding.
From CryptolToCoq Require Import SAWCoreVectorsAsCoqVectors.
Import VectorNotations.

(** Post-preamble section specified by you *)


(** Code generated by saw-core-coq *)

Module SAWCorePrelude.

(* "Prelude.id" was skipped *)

(* "Prelude.fix" was skipped *)

(* "Prelude.sawLet" was skipped *)

(* Prelude.UnitType was skipped *)

(* "Prelude.UnitType__rec" was skipped *)

(* Prelude.PairType was skipped *)

Definition pair_example : forall (a : Type), forall (b : Type), forall (_1 : a), forall (_2 : b), SAWCoreScaffolding.PairType a b :=
  fun (a : Type) (b : Type) (x : a) (y : b) => SAWCoreScaffolding.PairValue a b x y.

(* "Prelude.Pair__rec" was skipped *)

Definition Pair_fst : forall (a : Type), forall (b : Type), forall (_1 : SAWCoreScaffolding.PairType a b), a :=
  fun (a : Type) (b : Type) => SAWCoreScaffolding.Pair__rec a b (fun (p : SAWCoreScaffolding.PairType a b) => a) (fun (x : a) (y : b) => x).

Definition Pair_snd : forall (a : Type), forall (b : Type), forall (_1 : SAWCoreScaffolding.PairType a b), b :=
  fun (a : Type) (b : Type) => SAWCoreScaffolding.Pair__rec a b (fun (p : SAWCoreScaffolding.PairType a b) => b) (fun (x : a) (y : b) => y).

(* "Prelude.fst" was skipped *)

(* "Prelude.snd" was skipped *)

Definition uncurry : forall (a : Type), forall (b : Type), forall (c : Type), forall (f : forall (_1 : a), forall (_2 : b), c), forall (_1 : prod a b), c :=
  fun (a : Type) (b : Type) (c : Type) (f : forall (_1 : a), forall (_2 : b), c) (x : prod a b) => f (fst x) (snd x).

(* "Prelude.String" was skipped *)

(* "Prelude.error" was skipped *)

(* Prelude.EmptyType was skipped *)

(* "Prelude.EmptyType__rec" was skipped *)

(* Prelude.RecordType was skipped *)

(* "Prelude.RecordType__rec" was skipped *)

(* Prelude.Void was skipped *)

Definition elimVoid : forall (a : Type), forall (_1 : Init.Datatypes.Empty_set), a :=
  fun (a : Type) (v : Init.Datatypes.Empty_set) => @Init.Datatypes.Empty_set_rect (fun (_1 : Init.Datatypes.Empty_set) => a) v.

(* Prelude.Eq was skipped *)

(* "Prelude.Eq__rec" was skipped *)

(* "Prelude.uip" was skipped *)

Definition eq_cong : forall (t : Type), forall (x : t), forall (y : t), forall (_1 : @Init.Logic.eq t x y), forall (u : Type), forall (f : forall (_2 : t), u), @Init.Logic.eq u (f x) (f y) :=
  fun (t : Type) (x : t) (y : t) (eq : @Init.Logic.eq t x y) (u : Type) (f : forall (_1 : t), u) => SAWCoreScaffolding.Eq__rec t x (fun (y' : t) (eq' : @Init.Logic.eq t x y') => @Init.Logic.eq u (f x) (f y')) (@Init.Logic.eq_refl u (f x)) y eq.

Definition sym : forall (a : Type), forall (x : a), forall (y : a), forall (_1 : @Init.Logic.eq a x y), @Init.Logic.eq a y x :=
  fun (a : Type) (x : a) (y : a) (eq : @Init.Logic.eq a x y) => SAWCoreScaffolding.Eq__rec a x (fun (y' : a) (eq' : @Init.Logic.eq a x y') => @Init.Logic.eq a y' x) (@Init.Logic.eq_refl a x) y eq.

Definition trans : forall (a : Type), forall (x : a), forall (y : a), forall (z : a), forall (_1 : @Init.Logic.eq a x y), forall (_2 : @Init.Logic.eq a y z), @Init.Logic.eq a x z :=
  fun (a : Type) (x : a) (y : a) (z : a) (eq1 : @Init.Logic.eq a x y) (eq2 : @Init.Logic.eq a y z) => SAWCoreScaffolding.Eq__rec a y (fun (y' : a) (eq' : @Init.Logic.eq a y y') => @Init.Logic.eq a x y') eq1 z eq2.

Definition trans2 : forall (a : Type), forall (x : a), forall (y : a), forall (z : a), forall (_1 : @Init.Logic.eq a x z), forall (_2 : @Init.Logic.eq a y z), @Init.Logic.eq a x y :=
  fun (a : Type) (x : a) (y : a) (z : a) (eq1 : @Init.Logic.eq a x z) (eq2 : @Init.Logic.eq a y z) => trans a x z y eq1 (sym a y z eq2).

Definition trans4 : forall (a : Type), forall (w : a), forall (x : a), forall (y : a), forall (z : a), forall (_1 : @Init.Logic.eq a w x), forall (_2 : @Init.Logic.eq a x y), forall (_3 : @Init.Logic.eq a y z), @Init.Logic.eq a w z :=
  fun (a : Type) (w : a) (x : a) (y : a) (z : a) (eq1 : @Init.Logic.eq a w x) (eq2 : @Init.Logic.eq a x y) (eq3 : @Init.Logic.eq a y z) => trans a w x z eq1 (trans a x y z eq2 eq3).

Definition eq_inv_map : forall (a : Type), forall (b : Type), forall (a1 : a), forall (a2 : a), forall (_1 : @Init.Logic.eq a a1 a2), forall (f1 : forall (_2 : a), b), forall (f2 : forall (_2 : a), b), forall (_2 : @Init.Logic.eq b (f1 a2) (f2 a2)), @Init.Logic.eq b (f1 a1) (f2 a1) :=
  fun (a : Type) (b : Type) (a1 : a) (a2 : a) (eq_a : @Init.Logic.eq a a1 a2) (f1 : forall (_1 : a), b) (f2 : forall (_1 : a), b) (eq_f : @Init.Logic.eq b (f1 a2) (f2 a2)) => let var__0   := f1 a2 in
  let var__1   := f2 a1 in
  trans b (f1 a1) var__0 var__1 (eq_cong a a1 a2 eq_a b f1) (trans b var__0 (f2 a2) var__1 eq_f (eq_cong a a2 a1 (sym a a1 a2 eq_a) b f2)).

Inductive EqDep (t : Type) (P : forall (_1 : t), Type) (x : t) (p : P x) : forall (y : t), forall (_1 : P y), Prop :=
| ReflDep :  EqDep t P x p x p
.

(* "Prelude.fix_unfold" was skipped *)

Definition inverse_eta_rule : forall (a : Type), forall (b : Type), forall (f : forall (_1 : a), b), forall (g : forall (_1 : a), b), forall (_1 : @Init.Logic.eq (forall (_1 : a), b) f g), forall (x : a), @Init.Logic.eq b (f x) (g x) :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), b) (g : forall (_1 : a), b) (H : @Init.Logic.eq (forall (_1 : a), b) f g) => SAWCoreScaffolding.Eq__rec (forall (_1 : a), b) f (fun (g' : forall (_1 : a), b) (H' : @Init.Logic.eq (forall (_1 : a), b) f g') => forall (x : a), @Init.Logic.eq b (f x) (g' x)) (fun (x : a) => @Init.Logic.eq_refl b (f x)) g H.

(* "Prelude.unsafeAssert" was skipped *)

(* "Prelude.coerce" was skipped *)

(* "Prelude.coerce__def" was skipped *)

(* "Prelude.coerce__eq" was skipped *)

Definition coerce_same : forall (a : Type), forall (q : @Init.Logic.eq Type a a), forall (x : a), @Init.Logic.eq a (SAWCoreScaffolding.coerce a a q x) x :=
  fun (a : Type) (q : @Init.Logic.eq Type a a) (x : a) => let var__0   := @Init.Logic.eq Type a a in
  let var__1   := @Init.Logic.eq_refl Type a in
  trans a (SAWCoreScaffolding.coerce a a q x) (SAWCoreScaffolding.coerce a a q x) x (eq_cong (forall (a1 : Type), forall (b : Type), forall (_1 : @Init.Logic.eq Type a1 b), forall (_2 : a1), b) SAWCoreScaffolding.coerce SAWCoreScaffolding.coerce eq_refl a (fun (f : forall (a1 : Type), forall (b : Type), forall (_1 : @Init.Logic.eq Type a1 b), forall (_2 : a1), b) => f a a q x)) (eq_cong var__0 q var__1 (UIP Type a a q var__1) a (fun (q' : var__0) => SAWCoreScaffolding.coerce a a q' x)).

Definition coerce__def_trans : forall (a : Type), forall (b : Type), forall (c : Type), forall (pf1 : @Init.Logic.eq Type a b), forall (pf2 : @Init.Logic.eq Type b c), forall (x : a), @Init.Logic.eq c (SAWCoreScaffolding.coerce b c pf2 (SAWCoreScaffolding.coerce a b pf1 x)) (SAWCoreScaffolding.coerce a c (trans Type a b c pf1 pf2) x) :=
  fun (a : Type) (b : Type) (c : Type) (pf1 : @Init.Logic.eq Type a b) (pf2 : @Init.Logic.eq Type b c) (x : a) => SAWCoreScaffolding.Eq__rec Type b (fun (c' : Type) (pf2' : @Init.Logic.eq Type b c') => @Init.Logic.eq c' (SAWCoreScaffolding.coerce b c' pf2' (SAWCoreScaffolding.coerce a b pf1 x)) (SAWCoreScaffolding.coerce a c' (trans Type a b c' pf1 pf2') x)) (@Init.Logic.eq_refl b (SAWCoreScaffolding.coerce a b pf1 x)) c pf2.

Definition coerce_trans : forall (a : Type), forall (b : Type), forall (c : Type), forall (pf1 : @Init.Logic.eq Type a b), forall (pf2 : @Init.Logic.eq Type b c), forall (x : a), @Init.Logic.eq c (SAWCoreScaffolding.coerce b c pf2 (SAWCoreScaffolding.coerce a b pf1 x)) (SAWCoreScaffolding.coerce a c (trans Type a b c pf1 pf2) x) :=
  fun (a : Type) (b : Type) (c : Type) (pf1 : @Init.Logic.eq Type a b) (pf2 : @Init.Logic.eq Type b c) (x : a) => let var__0   := trans Type a b c pf1 pf2 in
  trans4 c (SAWCoreScaffolding.coerce b c pf2 (SAWCoreScaffolding.coerce a b pf1 x)) (SAWCoreScaffolding.coerce b c pf2 (SAWCoreScaffolding.coerce a b pf1 x)) (SAWCoreScaffolding.coerce a c var__0 x) (SAWCoreScaffolding.coerce a c var__0 x) (eq_cong (forall (t : Type), forall (u : Type), forall (_1 : @Init.Logic.eq Type t u), forall (_2 : t), u) SAWCoreScaffolding.coerce SAWCoreScaffolding.coerce eq_refl c (fun (f : forall (a1 : Type), forall (b1 : Type), forall (_1 : @Init.Logic.eq Type a1 b1), forall (_2 : a1), b1) => f b c pf2 (f a b pf1 x))) (coerce__def_trans a b c pf1 pf2 x) (eq_cong (forall (t : Type), forall (u : Type), forall (_1 : @Init.Logic.eq Type t u), forall (_2 : t), u) SAWCoreScaffolding.coerce SAWCoreScaffolding.coerce (sym (forall (t : Type), forall (u : Type), forall (_1 : @Init.Logic.eq Type t u), forall (_2 : t), u) SAWCoreScaffolding.coerce SAWCoreScaffolding.coerce eq_refl) c (fun (f : forall (a1 : Type), forall (b1 : Type), forall (_1 : @Init.Logic.eq Type a1 b1), forall (_2 : a1), b1) => f a c var__0 x)).

Definition rcoerce : forall (a : Type), forall (b : Type), forall (_1 : @Init.Logic.eq Type a b), forall (_2 : b), a :=
  fun (a : Type) (b : Type) (q : @Init.Logic.eq Type a b) => SAWCoreScaffolding.coerce b a (sym Type a b q).

Definition rcoerce_same : forall (a : Type), forall (q : @Init.Logic.eq Type a a), forall (x : a), @Init.Logic.eq a (rcoerce a a q x) x :=
  fun (a : Type) (q : @Init.Logic.eq Type a a) (x : a) => coerce_same a (sym Type a a q) x.

(* "Prelude.unsafeCoerce" was skipped *)

(* "Prelude.unsafeCoerce_same" was skipped *)

Definition piCong0 : forall (r : Type), forall (x : Type), forall (y : Type), forall (_1 : @Init.Logic.eq Type x y), @Init.Logic.eq Type (forall (_2 : x), r) (forall (_2 : y), r) :=
  fun (r : Type) (x : Type) (y : Type) (eq : @Init.Logic.eq Type x y) => SAWCoreScaffolding.Eq__rec Type x (fun (y' : Type) (eq' : @Init.Logic.eq Type x y') => @Init.Logic.eq Type (forall (_1 : x), r) (forall (_1 : y'), r)) (@Init.Logic.eq_refl Type (forall (_1 : x), r)) y eq.

Definition piCong1 : forall (r : Type), forall (x : Type), forall (y : Type), forall (_1 : @Init.Logic.eq Type x y), @Init.Logic.eq Type (forall (_2 : r), x) (forall (_2 : r), y) :=
  fun (r : Type) (x : Type) (y : Type) (eq : @Init.Logic.eq Type x y) => SAWCoreScaffolding.Eq__rec Type x (fun (y' : Type) (eq' : @Init.Logic.eq Type x y') => @Init.Logic.eq Type (forall (_1 : r), x) (forall (_1 : r), y')) (@Init.Logic.eq_refl Type (forall (_1 : r), x)) y eq.

(* Prelude.Bool was skipped *)

(* "Prelude.iteDep" was skipped *)

(* "Prelude.iteDep_True" was skipped *)

(* "Prelude.iteDep_False" was skipped *)

(* "Prelude.ite" was skipped *)

(* "Prelude.ite_eq_iteDep" was skipped *)

Definition ite_true : forall (a : Type), forall (x : a), forall (y : a), @Init.Logic.eq a (if Init.Datatypes.true then x else y) x :=
  fun (a : Type) (x : a) (y : a) => trans a (if Init.Datatypes.true then x else y) (SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => a) Init.Datatypes.true x y) x (SAWCoreScaffolding.ite_eq_iteDep a Init.Datatypes.true x y) (SAWCoreScaffolding.iteDep_True (fun (_1 : Init.Datatypes.bool) => a) x y).

Definition ite_false : forall (a : Type), forall (x : a), forall (y : a), @Init.Logic.eq a (if Init.Datatypes.false then x else y) y :=
  fun (a : Type) (x : a) (y : a) => trans a (if Init.Datatypes.false then x else y) (SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => a) Init.Datatypes.false x y) y (SAWCoreScaffolding.ite_eq_iteDep a Init.Datatypes.false x y) (SAWCoreScaffolding.iteDep_False (fun (_1 : Init.Datatypes.bool) => a) x y).

Definition iteWithProof : forall (a : Type), forall (b : Init.Datatypes.bool), forall (_1 : forall (_1 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.true), a), forall (_2 : forall (_2 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.false), a), a :=
  fun (a : Type) (b : Init.Datatypes.bool) (f1 : forall (_1 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.true), a) (f2 : forall (_1 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.false), a) => SAWCoreScaffolding.iteDep (fun (b1 : Init.Datatypes.bool) => forall (_1 : @Init.Logic.eq Init.Datatypes.bool b b1), a) b f1 f2 (@Init.Logic.eq_refl Init.Datatypes.bool b).

Definition ifWithProof : forall (a : Type), forall (b : Init.Datatypes.bool), forall (_1 : a), forall (_2 : forall (_2 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.true), a), a :=
  fun (a : Type) (b : Init.Datatypes.bool) (x : a) (f : forall (_1 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.true), a) => iteWithProof a b f (fun (_1 : @Init.Logic.eq Init.Datatypes.bool b Init.Datatypes.false) => x).

(* "Prelude.not" was skipped *)

(* "Prelude.and" was skipped *)

(* "Prelude.or" was skipped *)

(* "Prelude.xor" was skipped *)

(* "Prelude.boolEq" was skipped *)

(* "Prelude.not__eq" was skipped *)

(* "Prelude.and__eq" was skipped *)

(* "Prelude.or__eq" was skipped *)

(* "Prelude.xor__eq" was skipped *)

(* "Prelude.boolEq__eq" was skipped *)

Definition implies : forall (_1 : Init.Datatypes.bool), forall (_2 : Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (a : Init.Datatypes.bool) (b : Init.Datatypes.bool) => Init.Datatypes.orb (Init.Datatypes.negb a) b.

Definition implies__eq : forall (a : Init.Datatypes.bool), forall (b : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (implies a b) (Init.Datatypes.orb (Init.Datatypes.negb a) b) :=
  fun (a : Init.Datatypes.bool) (b : Init.Datatypes.bool) => @Init.Logic.eq_refl Init.Datatypes.bool (implies a b).

Definition unitEq : forall (_1 : SAWCoreScaffolding.UnitType), forall (_2 : SAWCoreScaffolding.UnitType), Init.Datatypes.bool :=
  fun (_1 : SAWCoreScaffolding.UnitType) (_2 : SAWCoreScaffolding.UnitType) => Init.Datatypes.true.

Definition pairEq : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), forall (_2 : a), Init.Datatypes.bool), forall (_2 : forall (_2 : b), forall (_3 : b), Init.Datatypes.bool), forall (_3 : prod a b), forall (_4 : prod a b), Init.Datatypes.bool :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), forall (_2 : a), Init.Datatypes.bool) (g : forall (_1 : b), forall (_2 : b), Init.Datatypes.bool) (x : prod a b) (y : prod a b) => Init.Datatypes.andb (f (fst x) (fst y)) (g (snd x) (snd y)).

Definition not_True : @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb Init.Datatypes.true) Init.Datatypes.false :=
  trans Init.Datatypes.bool (Init.Datatypes.negb Init.Datatypes.true) (if Init.Datatypes.true then Init.Datatypes.false else Init.Datatypes.true) Init.Datatypes.false (SAWCoreScaffolding.not__eq Init.Datatypes.true) (ite_true Init.Datatypes.bool Init.Datatypes.false Init.Datatypes.true).

Definition not_False : @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb Init.Datatypes.false) Init.Datatypes.true :=
  trans Init.Datatypes.bool (Init.Datatypes.negb Init.Datatypes.false) (if Init.Datatypes.false then Init.Datatypes.false else Init.Datatypes.true) Init.Datatypes.true (SAWCoreScaffolding.not__eq Init.Datatypes.false) (ite_false Init.Datatypes.bool Init.Datatypes.false Init.Datatypes.true).

Definition not_not : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb (Init.Datatypes.negb x)) x :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  let var__1   := Init.Datatypes.negb Init.Datatypes.false in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb (Init.Datatypes.negb b)) b) x (trans Init.Datatypes.bool (Init.Datatypes.negb var__0) var__1 Init.Datatypes.true (eq_cong Init.Datatypes.bool var__0 Init.Datatypes.false not_True Init.Datatypes.bool Init.Datatypes.negb) not_False) (trans Init.Datatypes.bool (Init.Datatypes.negb var__1) var__0 Init.Datatypes.false (eq_cong Init.Datatypes.bool var__1 Init.Datatypes.true not_False Init.Datatypes.bool Init.Datatypes.negb) not_True).

Definition and_True1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb Init.Datatypes.true x) x :=
  fun (x : Init.Datatypes.bool) => trans Init.Datatypes.bool (Init.Datatypes.andb Init.Datatypes.true x) (if Init.Datatypes.true then x else Init.Datatypes.false) x (SAWCoreScaffolding.and__eq Init.Datatypes.true x) (ite_true Init.Datatypes.bool x Init.Datatypes.false).

Definition and_False1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb Init.Datatypes.false x) Init.Datatypes.false :=
  fun (x : Init.Datatypes.bool) => trans Init.Datatypes.bool (Init.Datatypes.andb Init.Datatypes.false x) (if Init.Datatypes.false then x else Init.Datatypes.false) Init.Datatypes.false (SAWCoreScaffolding.and__eq Init.Datatypes.false x) (ite_false Init.Datatypes.bool x Init.Datatypes.false).

Definition and_True2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb x Init.Datatypes.true) x :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb b Init.Datatypes.true) b) x (and_True1 Init.Datatypes.true) (and_False1 Init.Datatypes.true).

Definition and_False2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb x Init.Datatypes.false) Init.Datatypes.false :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb b Init.Datatypes.false) Init.Datatypes.false) x (and_True1 Init.Datatypes.false) (and_False1 Init.Datatypes.false).

Definition and_assoc : forall (x : Init.Datatypes.bool), forall (y : Init.Datatypes.bool), forall (z : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb x (Init.Datatypes.andb y z)) (Init.Datatypes.andb (Init.Datatypes.andb x y) z) :=
  fun (x : Init.Datatypes.bool) (y : Init.Datatypes.bool) (z : Init.Datatypes.bool) => let var__0   := Init.Datatypes.andb x in
  let var__1   := Init.Datatypes.andb x y in
  let var__2   := Init.Datatypes.andb y Init.Datatypes.true in
  let var__3   := Init.Datatypes.andb y Init.Datatypes.false in
  let var__4   := Init.Datatypes.andb x var__3 in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb x (Init.Datatypes.andb y b)) (Init.Datatypes.andb var__1 b)) z (trans2 Init.Datatypes.bool (Init.Datatypes.andb x var__2) (Init.Datatypes.andb var__1 Init.Datatypes.true) var__1 (eq_cong Init.Datatypes.bool var__2 y (and_True2 y) Init.Datatypes.bool var__0) (and_True2 var__1)) (trans2 Init.Datatypes.bool var__4 (Init.Datatypes.andb var__1 Init.Datatypes.false) Init.Datatypes.false (trans Init.Datatypes.bool var__4 (Init.Datatypes.andb x Init.Datatypes.false) Init.Datatypes.false (eq_cong Init.Datatypes.bool var__3 Init.Datatypes.false (and_False2 y) Init.Datatypes.bool var__0) (and_False2 x)) (and_False2 var__1)).

Definition and_idem : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb x x) x :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb b b) b) x (and_True1 Init.Datatypes.true) (and_False1 Init.Datatypes.false).

Definition or_True1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb Init.Datatypes.true x) Init.Datatypes.true :=
  fun (x : Init.Datatypes.bool) => trans Init.Datatypes.bool (Init.Datatypes.orb Init.Datatypes.true x) (if Init.Datatypes.true then Init.Datatypes.true else x) Init.Datatypes.true (SAWCoreScaffolding.or__eq Init.Datatypes.true x) (ite_true Init.Datatypes.bool Init.Datatypes.true x).

Definition or_False1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb Init.Datatypes.false x) x :=
  fun (x : Init.Datatypes.bool) => trans Init.Datatypes.bool (Init.Datatypes.orb Init.Datatypes.false x) (if Init.Datatypes.false then Init.Datatypes.true else x) x (SAWCoreScaffolding.or__eq Init.Datatypes.false x) (ite_false Init.Datatypes.bool Init.Datatypes.true x).

Definition or_True2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb x Init.Datatypes.true) Init.Datatypes.true :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb b Init.Datatypes.true) Init.Datatypes.true) x (or_True1 Init.Datatypes.true) (or_False1 Init.Datatypes.true).

Definition or_False2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb x Init.Datatypes.false) x :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb b Init.Datatypes.false) b) x (or_True1 Init.Datatypes.false) (or_False1 Init.Datatypes.false).

Definition or_assoc : forall (x : Init.Datatypes.bool), forall (y : Init.Datatypes.bool), forall (z : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb x (Init.Datatypes.orb y z)) (Init.Datatypes.orb (Init.Datatypes.orb x y) z) :=
  fun (x : Init.Datatypes.bool) (y : Init.Datatypes.bool) (z : Init.Datatypes.bool) => let var__0   := Init.Datatypes.orb x in
  let var__1   := Init.Datatypes.orb x y in
  let var__2   := Init.Datatypes.orb y Init.Datatypes.true in
  let var__3   := Init.Datatypes.orb x var__2 in
  let var__4   := Init.Datatypes.orb y Init.Datatypes.false in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb x (Init.Datatypes.orb y b)) (Init.Datatypes.orb var__1 b)) z (trans2 Init.Datatypes.bool var__3 (Init.Datatypes.orb var__1 Init.Datatypes.true) Init.Datatypes.true (trans Init.Datatypes.bool var__3 (Init.Datatypes.orb x Init.Datatypes.true) Init.Datatypes.true (eq_cong Init.Datatypes.bool var__2 Init.Datatypes.true (or_True2 y) Init.Datatypes.bool var__0) (or_True2 x)) (or_True2 var__1)) (trans2 Init.Datatypes.bool (Init.Datatypes.orb x var__4) (Init.Datatypes.orb var__1 Init.Datatypes.false) var__1 (eq_cong Init.Datatypes.bool var__4 y (or_False2 y) Init.Datatypes.bool var__0) (or_False2 var__1)).

Definition or_idem : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb x x) x :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb b b) b) x (or_True1 Init.Datatypes.true) (or_False1 Init.Datatypes.false).

Definition implies_True1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (implies Init.Datatypes.true x) x :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  trans Init.Datatypes.bool (Init.Datatypes.orb var__0 x) (Init.Datatypes.orb Init.Datatypes.false x) x (eq_cong Init.Datatypes.bool var__0 Init.Datatypes.false not_True Init.Datatypes.bool (fun (y : Init.Datatypes.bool) => Init.Datatypes.orb y x)) (or_False1 x).

Definition implies_False1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (implies Init.Datatypes.false x) Init.Datatypes.true :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.false in
  trans Init.Datatypes.bool (Init.Datatypes.orb var__0 x) (Init.Datatypes.orb Init.Datatypes.true x) Init.Datatypes.true (eq_cong Init.Datatypes.bool var__0 Init.Datatypes.true not_False Init.Datatypes.bool (fun (y : Init.Datatypes.bool) => Init.Datatypes.orb y x)) (or_True1 x).

Definition true_implies : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (implies Init.Datatypes.true x) x :=
  fun (x : Init.Datatypes.bool) => implies_True1 x.

Definition xor_True1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.true x) (Init.Datatypes.negb x) :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb x in
  trans Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.true x) (if Init.Datatypes.true then var__0 else x) var__0 (SAWCoreScaffolding.xor__eq Init.Datatypes.true x) (ite_true Init.Datatypes.bool var__0 x).

Definition xor_False1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.false x) x :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb x in
  trans Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.false x) (if Init.Datatypes.false then var__0 else x) x (SAWCoreScaffolding.xor__eq Init.Datatypes.false x) (ite_false Init.Datatypes.bool var__0 x).

Definition xor_False2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb x Init.Datatypes.false) x :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb b Init.Datatypes.false) b) x (trans Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.true Init.Datatypes.false) (Init.Datatypes.negb Init.Datatypes.false) Init.Datatypes.true (xor_True1 Init.Datatypes.false) not_False) (xor_False1 Init.Datatypes.false).

Definition xor_True2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb x Init.Datatypes.true) (Init.Datatypes.negb x) :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb b Init.Datatypes.true) (Init.Datatypes.negb b)) x (xor_True1 Init.Datatypes.true) (trans2 Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.false Init.Datatypes.true) (Init.Datatypes.negb Init.Datatypes.false) Init.Datatypes.true (xor_False1 Init.Datatypes.true) not_False).

Definition xor_same : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb x x) Init.Datatypes.false :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.xorb b b) Init.Datatypes.false) x (trans Init.Datatypes.bool (Init.Datatypes.xorb Init.Datatypes.true Init.Datatypes.true) (Init.Datatypes.negb Init.Datatypes.true) Init.Datatypes.false (xor_True1 Init.Datatypes.true) not_True) (xor_False1 Init.Datatypes.false).

Definition boolEq_True1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.true x) x :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb x in
  trans Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.true x) (if Init.Datatypes.true then x else var__0) x (SAWCoreScaffolding.boolEq__eq Init.Datatypes.true x) (ite_true Init.Datatypes.bool x var__0).

Definition boolEq_False1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.false x) (Init.Datatypes.negb x) :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb x in
  trans Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.false x) (if Init.Datatypes.false then x else var__0) var__0 (SAWCoreScaffolding.boolEq__eq Init.Datatypes.false x) (ite_false Init.Datatypes.bool x var__0).

Definition boolEq_True2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq x Init.Datatypes.true) x :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq b Init.Datatypes.true) b) x (boolEq_True1 Init.Datatypes.true) (trans Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.false Init.Datatypes.true) (Init.Datatypes.negb Init.Datatypes.true) Init.Datatypes.false (boolEq_False1 Init.Datatypes.true) not_True).

Definition boolEq_False2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq x Init.Datatypes.false) (Init.Datatypes.negb x) :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq b Init.Datatypes.false) (Init.Datatypes.negb b)) x (trans2 Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.true Init.Datatypes.false) (Init.Datatypes.negb Init.Datatypes.true) Init.Datatypes.false (boolEq_True1 Init.Datatypes.false) not_True) (boolEq_False1 Init.Datatypes.false).

Definition boolEq_same : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq x x) Init.Datatypes.true :=
  fun (x : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.boolEq b b) Init.Datatypes.true) x (boolEq_True1 Init.Datatypes.true) (trans Init.Datatypes.bool (SAWCoreScaffolding.boolEq Init.Datatypes.false Init.Datatypes.false) (Init.Datatypes.negb Init.Datatypes.false) Init.Datatypes.true (boolEq_False1 Init.Datatypes.false) not_False).

Definition not_or : forall (x : Init.Datatypes.bool), forall (y : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb (Init.Datatypes.orb x y)) (Init.Datatypes.andb (Init.Datatypes.negb x) (Init.Datatypes.negb y)) :=
  fun (x : Init.Datatypes.bool) (y : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  let var__1   := Init.Datatypes.negb Init.Datatypes.false in
  let var__2   := Init.Datatypes.negb y in
  let var__3   := Init.Datatypes.andb var__0 var__2 in
  let var__4   := Init.Datatypes.orb Init.Datatypes.true y in
  let var__5   := Init.Datatypes.negb var__4 in
  let var__6   := Init.Datatypes.andb var__1 var__2 in
  let var__7   := Init.Datatypes.orb Init.Datatypes.false y in
  let var__8   := Init.Datatypes.andb Init.Datatypes.false var__2 in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb (Init.Datatypes.orb b y)) (Init.Datatypes.andb (Init.Datatypes.negb b) var__2)) x (trans Init.Datatypes.bool var__5 Init.Datatypes.false var__3 (trans Init.Datatypes.bool var__5 var__0 Init.Datatypes.false (eq_cong Init.Datatypes.bool var__4 Init.Datatypes.true (or_True1 y) Init.Datatypes.bool Init.Datatypes.negb) not_True) (trans Init.Datatypes.bool Init.Datatypes.false var__8 var__3 (sym Init.Datatypes.bool var__8 Init.Datatypes.false (and_False1 var__2)) (eq_cong Init.Datatypes.bool Init.Datatypes.false var__0 (sym Init.Datatypes.bool var__0 Init.Datatypes.false not_True) Init.Datatypes.bool (fun (z : Init.Datatypes.bool) => Init.Datatypes.andb z var__2)))) (trans Init.Datatypes.bool (Init.Datatypes.negb var__7) var__2 var__6 (eq_cong Init.Datatypes.bool var__7 y (or_False1 y) Init.Datatypes.bool Init.Datatypes.negb) (sym Init.Datatypes.bool var__6 var__2 (trans Init.Datatypes.bool var__6 (Init.Datatypes.andb Init.Datatypes.true var__2) var__2 (eq_cong Init.Datatypes.bool var__1 Init.Datatypes.true not_False Init.Datatypes.bool (fun (z : Init.Datatypes.bool) => Init.Datatypes.andb z var__2)) (and_True1 var__2)))).

Definition not_and : forall (x : Init.Datatypes.bool), forall (y : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb (Init.Datatypes.andb x y)) (Init.Datatypes.orb (Init.Datatypes.negb x) (Init.Datatypes.negb y)) :=
  fun (x : Init.Datatypes.bool) (y : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  let var__1   := Init.Datatypes.negb Init.Datatypes.false in
  let var__2   := Init.Datatypes.negb y in
  let var__3   := Init.Datatypes.orb var__0 var__2 in
  let var__4   := Init.Datatypes.andb Init.Datatypes.true y in
  let var__5   := Init.Datatypes.orb var__1 var__2 in
  let var__6   := Init.Datatypes.andb Init.Datatypes.false y in
  let var__7   := Init.Datatypes.negb var__6 in
  let var__8   := Init.Datatypes.orb Init.Datatypes.true var__2 in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.negb (Init.Datatypes.andb b y)) (Init.Datatypes.orb (Init.Datatypes.negb b) var__2)) x (trans Init.Datatypes.bool (Init.Datatypes.negb var__4) var__2 var__3 (eq_cong Init.Datatypes.bool var__4 y (and_True1 y) Init.Datatypes.bool Init.Datatypes.negb) (sym Init.Datatypes.bool var__3 var__2 (trans Init.Datatypes.bool var__3 (Init.Datatypes.orb Init.Datatypes.false var__2) var__2 (eq_cong Init.Datatypes.bool var__0 Init.Datatypes.false not_True Init.Datatypes.bool (fun (z : Init.Datatypes.bool) => Init.Datatypes.orb z var__2)) (or_False1 var__2)))) (trans Init.Datatypes.bool var__7 Init.Datatypes.true var__5 (trans Init.Datatypes.bool var__7 var__1 Init.Datatypes.true (eq_cong Init.Datatypes.bool var__6 Init.Datatypes.false (and_False1 y) Init.Datatypes.bool Init.Datatypes.negb) not_False) (trans Init.Datatypes.bool Init.Datatypes.true var__8 var__5 (sym Init.Datatypes.bool var__8 Init.Datatypes.true (or_True1 var__2)) (eq_cong Init.Datatypes.bool Init.Datatypes.true var__1 (sym Init.Datatypes.bool var__1 Init.Datatypes.true not_False) Init.Datatypes.bool (fun (z : Init.Datatypes.bool) => Init.Datatypes.orb z var__2)))).

Definition ite_not : forall (a : Type), forall (b : Init.Datatypes.bool), forall (x : a), forall (y : a), @Init.Logic.eq a (if Init.Datatypes.negb b then x else y) (if b then y else x) :=
  fun (a : Type) (b : Init.Datatypes.bool) (x : a) (y : a) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  let var__1   := Init.Datatypes.negb Init.Datatypes.false in
  let var__2   := if Init.Datatypes.true then y else x in
  let var__3   := if var__0 then x else y in
  let var__4   := if Init.Datatypes.false then y else x in
  let var__5   := if var__1 then x else y in
  SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq a (if Init.Datatypes.negb b' then x else y) (if b' then y else x)) b (trans a var__3 y var__2 (trans a var__3 (if Init.Datatypes.false then x else y) y (eq_cong Init.Datatypes.bool var__0 Init.Datatypes.false not_True a (fun (z : Init.Datatypes.bool) => if z then x else y)) (ite_false a x y)) (sym a var__2 y (ite_true a y x))) (trans a var__5 x var__4 (trans a var__5 (if Init.Datatypes.true then x else y) x (eq_cong Init.Datatypes.bool var__1 Init.Datatypes.true not_False a (fun (z : Init.Datatypes.bool) => if z then x else y)) (ite_true a x y)) (sym a var__4 x (ite_false a y x))).

Definition ite_nest1 : forall (a : Type), forall (b : Init.Datatypes.bool), forall (x : a), forall (y : a), forall (z : a), @Init.Logic.eq a (if b then if b then x else y else z) (if b then x else z) :=
  fun (a : Type) (b : Init.Datatypes.bool) (x : a) (y : a) (z : a) => let var__0   := if Init.Datatypes.true then x else z in
  let var__1   := if Init.Datatypes.true then x else y in
  let var__2   := if Init.Datatypes.true then var__1 else z in
  let var__3   := if Init.Datatypes.false then x else z in
  let var__4   := if Init.Datatypes.false then x else y in
  SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq a (if b' then if b' then x else y else z) (if b' then x else z)) b (trans a var__2 x var__0 (trans a var__2 var__1 x (ite_true a var__1 z) (ite_true a x y)) (sym a var__0 x (ite_true a x z))) (trans a (if Init.Datatypes.false then var__4 else z) z var__3 (ite_false a var__4 z) (sym a var__3 z (ite_false a x z))).

Definition ite_nest2 : forall (a : Type), forall (b : Init.Datatypes.bool), forall (x : a), forall (y : a), forall (z : a), @Init.Logic.eq a (if b then x else if b then y else z) (if b then x else z) :=
  fun (a : Type) (b : Init.Datatypes.bool) (x : a) (y : a) (z : a) => let var__0   := if Init.Datatypes.true then x else z in
  let var__1   := if Init.Datatypes.true then y else z in
  let var__2   := if Init.Datatypes.false then x else z in
  let var__3   := if Init.Datatypes.false then y else z in
  let var__4   := if Init.Datatypes.false then x else var__3 in
  SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq a (if b' then x else if b' then y else z) (if b' then x else z)) b (trans a (if Init.Datatypes.true then x else var__1) x var__0 (ite_true a x var__1) (sym a var__0 x (ite_true a x z))) (trans a var__4 z var__2 (trans a var__4 var__3 z (ite_false a x var__3) (ite_false a y z)) (sym a var__2 z (ite_false a x z))).

(* "Prelude.ite_bit" was skipped *)

Definition ite_bit_false_1 : forall (b : Init.Datatypes.bool), forall (c : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (if b then Init.Datatypes.false else c) (Init.Datatypes.andb (Init.Datatypes.negb b) c) :=
  fun (b : Init.Datatypes.bool) (c : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  let var__1   := Init.Datatypes.negb Init.Datatypes.false in
  let var__2   := Init.Datatypes.andb var__0 c in
  let var__3   := Init.Datatypes.andb var__1 c in
  SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (if b' then Init.Datatypes.false else c) (Init.Datatypes.andb (Init.Datatypes.negb b') c)) b (trans Init.Datatypes.bool (if Init.Datatypes.true then Init.Datatypes.false else c) Init.Datatypes.false var__2 (ite_true Init.Datatypes.bool Init.Datatypes.false c) (sym Init.Datatypes.bool var__2 Init.Datatypes.false (trans Init.Datatypes.bool var__2 (Init.Datatypes.andb Init.Datatypes.false c) Init.Datatypes.false (eq_cong Init.Datatypes.bool var__0 Init.Datatypes.false not_True Init.Datatypes.bool (fun (z : Init.Datatypes.bool) => Init.Datatypes.andb z c)) (and_False1 c)))) (trans Init.Datatypes.bool (if Init.Datatypes.false then Init.Datatypes.false else c) c var__3 (ite_false Init.Datatypes.bool Init.Datatypes.false c) (sym Init.Datatypes.bool var__3 c (trans Init.Datatypes.bool var__3 (Init.Datatypes.andb Init.Datatypes.true c) c (eq_cong Init.Datatypes.bool var__1 Init.Datatypes.true not_False Init.Datatypes.bool (fun (z : Init.Datatypes.bool) => Init.Datatypes.andb z c)) (and_True1 c)))).

Definition ite_bit_true_1 : forall (b : Init.Datatypes.bool), forall (c : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (if b then Init.Datatypes.true else c) (Init.Datatypes.orb b c) :=
  fun (b : Init.Datatypes.bool) (c : Init.Datatypes.bool) => let var__0   := Init.Datatypes.orb Init.Datatypes.true c in
  let var__1   := Init.Datatypes.orb Init.Datatypes.false c in
  SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (if b' then Init.Datatypes.true else c) (Init.Datatypes.orb b' c)) b (trans Init.Datatypes.bool (if Init.Datatypes.true then Init.Datatypes.true else c) Init.Datatypes.true var__0 (ite_true Init.Datatypes.bool Init.Datatypes.true c) (sym Init.Datatypes.bool var__0 Init.Datatypes.true (or_True1 c))) (trans Init.Datatypes.bool (if Init.Datatypes.false then Init.Datatypes.true else c) c var__1 (ite_false Init.Datatypes.bool Init.Datatypes.true c) (sym Init.Datatypes.bool var__1 c (or_False1 c))).

Definition ite_fold_not : forall (b : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (if b then Init.Datatypes.false else Init.Datatypes.true) (Init.Datatypes.negb b) :=
  fun (b : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  let var__1   := Init.Datatypes.negb Init.Datatypes.false in
  SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (if b' then Init.Datatypes.false else Init.Datatypes.true) (Init.Datatypes.negb b')) b (trans Init.Datatypes.bool (if Init.Datatypes.true then Init.Datatypes.false else Init.Datatypes.true) Init.Datatypes.false var__0 (ite_true Init.Datatypes.bool Init.Datatypes.false Init.Datatypes.true) (sym Init.Datatypes.bool var__0 Init.Datatypes.false not_True)) (trans Init.Datatypes.bool (if Init.Datatypes.false then Init.Datatypes.false else Init.Datatypes.true) Init.Datatypes.true var__1 (ite_false Init.Datatypes.bool Init.Datatypes.false Init.Datatypes.true) (sym Init.Datatypes.bool var__1 Init.Datatypes.true not_False)).

Definition ite_eq : forall (a : Type), forall (b : Init.Datatypes.bool), forall (x : a), @Init.Logic.eq a (if b then x else x) x :=
  fun (a : Type) (b : Init.Datatypes.bool) (x : a) => SAWCoreScaffolding.iteDep (fun (b' : Init.Datatypes.bool) => @Init.Logic.eq a (if b' then x else x) x) b (ite_true a x x) (ite_false a x x).

Definition or_triv1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb x (Init.Datatypes.negb x)) Init.Datatypes.true :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.false in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb b (Init.Datatypes.negb b)) Init.Datatypes.true) x (or_True1 (Init.Datatypes.negb Init.Datatypes.true)) (trans Init.Datatypes.bool (Init.Datatypes.orb Init.Datatypes.false var__0) var__0 Init.Datatypes.true (or_False1 var__0) not_False).

Definition or_triv2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb (Init.Datatypes.negb x) x) Init.Datatypes.true :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.false in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.orb (Init.Datatypes.negb b) b) Init.Datatypes.true) x (or_True2 (Init.Datatypes.negb Init.Datatypes.true)) (trans Init.Datatypes.bool (Init.Datatypes.orb var__0 Init.Datatypes.false) var__0 Init.Datatypes.true (or_False2 var__0) not_False).

Definition and_triv1 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb x (Init.Datatypes.negb x)) Init.Datatypes.false :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb b (Init.Datatypes.negb b)) Init.Datatypes.false) x (trans Init.Datatypes.bool (Init.Datatypes.andb Init.Datatypes.true var__0) var__0 Init.Datatypes.false (and_True1 var__0) not_True) (and_False1 (Init.Datatypes.negb Init.Datatypes.false)).

Definition and_triv2 : forall (x : Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb (Init.Datatypes.negb x) x) Init.Datatypes.false :=
  fun (x : Init.Datatypes.bool) => let var__0   := Init.Datatypes.negb Init.Datatypes.true in
  SAWCoreScaffolding.iteDep (fun (b : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (Init.Datatypes.andb (Init.Datatypes.negb b) b) Init.Datatypes.false) x (trans Init.Datatypes.bool (Init.Datatypes.andb var__0 Init.Datatypes.true) var__0 Init.Datatypes.false (and_True2 var__0) not_True) (and_False2 (Init.Datatypes.negb Init.Datatypes.false)).

Definition EqTrue : forall (_1 : Init.Datatypes.bool), Prop :=
  fun (x : Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool x Init.Datatypes.true.

Definition TrueProp : Prop :=
  EqTrue Init.Datatypes.true.

Definition TrueI : EqTrue Init.Datatypes.true :=
  @Init.Logic.eq_refl Init.Datatypes.bool Init.Datatypes.true.

Definition andI : forall (x : Init.Datatypes.bool), forall (y : Init.Datatypes.bool), forall (_1 : EqTrue x), forall (_2 : EqTrue y), EqTrue (Init.Datatypes.andb x y) :=
  fun (x : Init.Datatypes.bool) (y : Init.Datatypes.bool) (p : EqTrue x) (q : EqTrue y) => trans4 Init.Datatypes.bool (Init.Datatypes.andb x y) (Init.Datatypes.andb x Init.Datatypes.true) x Init.Datatypes.true (eq_cong Init.Datatypes.bool y Init.Datatypes.true q Init.Datatypes.bool (Init.Datatypes.andb x)) (and_True2 x) p.

Definition impliesI : forall (x : Init.Datatypes.bool), forall (y : Init.Datatypes.bool), forall (_1 : forall (_1 : EqTrue x), EqTrue y), EqTrue (implies x y) :=
  fun (x : Init.Datatypes.bool) (y : Init.Datatypes.bool) => SAWCoreScaffolding.iteDep (fun (x1 : Init.Datatypes.bool) => forall (_1 : forall (_1 : EqTrue x1), EqTrue y), EqTrue (implies x1 y)) x (fun (H : forall (_1 : EqTrue Init.Datatypes.true), EqTrue y) => trans Init.Datatypes.bool (implies Init.Datatypes.true y) y Init.Datatypes.true (implies_True1 y) (H TrueI)) (fun (_1 : forall (_1 : EqTrue Init.Datatypes.false), EqTrue y) => implies_False1 y).

(* Prelude.Either was skipped *)

Definition Either__rec : forall (s : Type), forall (t : Type), forall (p : forall (_1 : Init.Datatypes.sum s t), Type), forall (_1 : forall (l : s), p (@Init.Datatypes.inl s t l)), forall (_2 : forall (r : t), p (@Init.Datatypes.inr s t r)), forall (e : Init.Datatypes.sum s t), p e :=
  fun (s : Type) (t : Type) (p : forall (_1 : Init.Datatypes.sum s t), Type) (f1 : forall (l : s), p (@Init.Datatypes.inl s t l)) (f2 : forall (r : t), p (@Init.Datatypes.inr s t r)) (e : Init.Datatypes.sum s t) => @Init.Datatypes.sum_rect s t p f1 f2 e.

Definition either : forall (a : Type), forall (b : Type), forall (c : Type), forall (_1 : forall (_1 : a), c), forall (_2 : forall (_2 : b), c), forall (_3 : Init.Datatypes.sum a b), c :=
  fun (a : Type) (b : Type) (c : Type) (f : forall (_1 : a), c) (g : forall (_1 : b), c) (e : Init.Datatypes.sum a b) => Either__rec a b (fun (p : Init.Datatypes.sum a b) => c) f g e.

Definition left : forall (a : Type), forall (b : Type), forall (_1 : a), Init.Datatypes.sum a b :=
  fun (a : Type) (b : Type) (x : a) => @Init.Datatypes.inl a b x.

Definition right : forall (a : Type), forall (b : Type), forall (_1 : b), Init.Datatypes.sum a b :=
  fun (a : Type) (b : Type) (x : b) => @Init.Datatypes.inr a b x.

Definition eitherCong0 : forall (t : Type), forall (x : Type), forall (y : Type), forall (_1 : @Init.Logic.eq Type x y), @Init.Logic.eq Type (Init.Datatypes.sum x t) (Init.Datatypes.sum y t) :=
  fun (t : Type) (x : Type) (y : Type) (eq : @Init.Logic.eq Type x y) => eq_cong Type x y eq Type (fun (y' : Type) => Init.Datatypes.sum y' t).

Definition eitherCong1 : forall (t : Type), forall (x : Type), forall (y : Type), forall (_1 : @Init.Logic.eq Type x y), @Init.Logic.eq Type (Init.Datatypes.sum t x) (Init.Datatypes.sum t y) :=
  fun (t : Type) (x : Type) (y : Type) (eq : @Init.Logic.eq Type x y) => eq_cong Type x y eq Type (fun (y' : Type) => Init.Datatypes.sum t y').

Definition boolToEither : forall (_1 : Init.Datatypes.bool), Init.Datatypes.sum (unit : Type) (unit : Type) :=
  fun (b : Init.Datatypes.bool) => if b then @Init.Datatypes.inl (unit : Type) (unit : Type) tt else @Init.Datatypes.inr (unit : Type) (unit : Type) tt.

Inductive Maybe (a : Type) : Type :=
| Nothing :  Maybe a
| Just : forall (_1 : a), Maybe a
.

Definition Maybe__rec : forall (a : Type), forall (p : forall (_1 : Maybe a), Type), forall (_1 : p (Nothing a)), forall (_2 : forall (x : a), p (Just a x)), forall (m : Maybe a), p m :=
  fun (a : Type) (p : forall (_1 : Maybe a), Type) (f1 : p (Nothing a)) (f2 : forall (x : a), p (Just a x)) (m : Maybe a) => @SAWCorePrelude.Maybe_rect a p f1 f2 m.

Definition maybe : forall (a : Type), forall (b : Type), forall (_1 : b), forall (_2 : forall (_2 : a), b), forall (_3 : Maybe a), b :=
  fun (a : Type) (b : Type) (f1 : b) (f2 : forall (_1 : a), b) (m : Maybe a) => Maybe__rec a (fun (m' : Maybe a) => b) f1 f2 m.

(* Prelude.Pos was skipped *)

(* "Prelude.Pos_cases" was skipped *)

(* "Prelude.posInc" was skipped *)

(* "Prelude.posAdd" was skipped *)

(* "Prelude.posMul" was skipped *)

(* "Prelude.posExp" was skipped *)

Definition posEq : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Stdlib.PArith.BinPos.positive), Init.Datatypes.bool :=
  SAWCoreScaffolding.Pos_cases (forall (_1 : Stdlib.PArith.BinPos.positive), Init.Datatypes.bool) (SAWCoreScaffolding.Pos_cases Init.Datatypes.bool Init.Datatypes.true (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Init.Datatypes.bool) => Init.Datatypes.false) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Init.Datatypes.bool) => Init.Datatypes.false)) (fun (x : Stdlib.PArith.BinPos.positive) (rx : forall (_1 : Stdlib.PArith.BinPos.positive), Init.Datatypes.bool) => SAWCoreScaffolding.Pos_cases Init.Datatypes.bool Init.Datatypes.false (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Init.Datatypes.bool) => rx y) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Init.Datatypes.bool) => Init.Datatypes.false)) (fun (x : Stdlib.PArith.BinPos.positive) (rx : forall (_1 : Stdlib.PArith.BinPos.positive), Init.Datatypes.bool) => SAWCoreScaffolding.Pos_cases Init.Datatypes.bool Init.Datatypes.false (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Init.Datatypes.bool) => Init.Datatypes.false) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Init.Datatypes.bool) => rx y)).

Definition posCmp : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Stdlib.PArith.BinPos.positive), forall (_3 : Init.Datatypes.bool), Init.Datatypes.bool :=
  SAWCoreScaffolding.Pos_cases (forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Init.Datatypes.bool), Init.Datatypes.bool) (SAWCoreScaffolding.Pos_cases (forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (fun (k : Init.Datatypes.bool) => k) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (k : Init.Datatypes.bool) => Init.Datatypes.true) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (k : Init.Datatypes.bool) => Init.Datatypes.true)) (fun (x : Stdlib.PArith.BinPos.positive) (rx : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Init.Datatypes.bool), Init.Datatypes.bool) => SAWCoreScaffolding.Pos_cases (forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (fun (k : Init.Datatypes.bool) => Init.Datatypes.false) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (k : Init.Datatypes.bool) => rx y k) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (k : Init.Datatypes.bool) => rx y Init.Datatypes.true)) (fun (x : Stdlib.PArith.BinPos.positive) (rx : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Init.Datatypes.bool), Init.Datatypes.bool) => SAWCoreScaffolding.Pos_cases (forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (fun (k : Init.Datatypes.bool) => Init.Datatypes.false) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (k : Init.Datatypes.bool) => rx y Init.Datatypes.false) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : forall (_1 : Init.Datatypes.bool), Init.Datatypes.bool) (k : Init.Datatypes.bool) => rx y k)).

Definition posLe : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Stdlib.PArith.BinPos.positive), Init.Datatypes.bool :=
  fun (x : Stdlib.PArith.BinPos.positive) (y : Stdlib.PArith.BinPos.positive) => posCmp x y Init.Datatypes.true.

Definition posLt : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Stdlib.PArith.BinPos.positive), Init.Datatypes.bool :=
  fun (x : Stdlib.PArith.BinPos.positive) (y : Stdlib.PArith.BinPos.positive) => posCmp x y Init.Datatypes.false.

(* Prelude.Nat was skipped *)

(* "Prelude.Succ" was skipped *)

(* "Prelude.addNat" was skipped *)

(* "Prelude.mulNat" was skipped *)

(* "Prelude.expNat" was skipped *)

(* "Prelude.equalNat" was skipped *)

(* "Prelude.ltNat" was skipped *)

(* "Prelude.leNat" was skipped *)

(* "Prelude.minNat" was skipped *)

(* "Prelude.maxNat" was skipped *)

(* "Prelude.widthNat" was skipped *)

(* Prelude.Z was skipped *)

Definition Z_cases : forall (a : Type), forall (_1 : a), forall (_2 : forall (_2 : Stdlib.PArith.BinPos.positive), a), forall (_3 : forall (_3 : Stdlib.PArith.BinPos.positive), a), forall (_4 : Stdlib.ZArith.BinInt.Z), a :=
  fun (a : Type) => @Stdlib.ZArith.BinInt.Z_rect (fun (_1 : Stdlib.ZArith.BinInt.Z) => a).

(* "Prelude.BitM" was skipped *)

Definition dblZ : forall (_1 : Stdlib.ZArith.BinInt.Z), Stdlib.ZArith.BinInt.Z :=
  Z_cases Stdlib.ZArith.BinInt.Z Stdlib.ZArith.BinInt.Z0 (fun (x : Stdlib.PArith.BinPos.positive) => Stdlib.ZArith.BinInt.Zpos (Stdlib.PArith.BinPos.xO x)) (fun (x : Stdlib.PArith.BinPos.positive) => Stdlib.ZArith.BinInt.Zneg (Stdlib.PArith.BinPos.xO x)).

Definition dblZinc : forall (_1 : Stdlib.ZArith.BinInt.Z), Stdlib.ZArith.BinInt.Z :=
  Z_cases Stdlib.ZArith.BinInt.Z (Stdlib.ZArith.BinInt.Zpos Stdlib.PArith.BinPos.xH) (fun (x : Stdlib.PArith.BinPos.positive) => Stdlib.ZArith.BinInt.Zpos (Stdlib.PArith.BinPos.xI x)) (fun (x : Stdlib.PArith.BinPos.positive) => Stdlib.ZArith.BinInt.Zneg (Stdlib.PArith.BinPos.Pos.pred_double x)).

Definition dblZdec : forall (_1 : Stdlib.ZArith.BinInt.Z), Stdlib.ZArith.BinInt.Z :=
  Z_cases Stdlib.ZArith.BinInt.Z (Stdlib.ZArith.BinInt.Zneg Stdlib.PArith.BinPos.xH) (fun (x : Stdlib.PArith.BinPos.positive) => Stdlib.ZArith.BinInt.Zpos (Stdlib.PArith.BinPos.Pos.pred_double x)) (fun (x : Stdlib.PArith.BinPos.positive) => Stdlib.ZArith.BinInt.Zneg (Stdlib.PArith.BinPos.xI x)).

Definition posSub : forall (_1 : Stdlib.PArith.BinPos.positive), forall (_2 : Stdlib.PArith.BinPos.positive), Stdlib.ZArith.BinInt.Z :=
  SAWCoreScaffolding.Pos_cases (forall (_1 : Stdlib.PArith.BinPos.positive), Stdlib.ZArith.BinInt.Z) (SAWCoreScaffolding.Pos_cases Stdlib.ZArith.BinInt.Z Stdlib.ZArith.BinInt.Z0 (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Stdlib.ZArith.BinInt.Z) => Stdlib.ZArith.BinInt.Zneg (Stdlib.PArith.BinPos.Pos.pred_double y)) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Stdlib.ZArith.BinInt.Z) => Stdlib.ZArith.BinInt.Zneg (Stdlib.PArith.BinPos.xO y))) (fun (x : Stdlib.PArith.BinPos.positive) (rx : forall (_1 : Stdlib.PArith.BinPos.positive), Stdlib.ZArith.BinInt.Z) => SAWCoreScaffolding.Pos_cases Stdlib.ZArith.BinInt.Z (Stdlib.ZArith.BinInt.Zpos (Stdlib.PArith.BinPos.Pos.pred_double x)) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Stdlib.ZArith.BinInt.Z) => dblZ (rx y)) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Stdlib.ZArith.BinInt.Z) => dblZdec (rx y))) (fun (x : Stdlib.PArith.BinPos.positive) (rx : forall (_1 : Stdlib.PArith.BinPos.positive), Stdlib.ZArith.BinInt.Z) => SAWCoreScaffolding.Pos_cases Stdlib.ZArith.BinInt.Z (Stdlib.ZArith.BinInt.Zpos (Stdlib.PArith.BinPos.xO x)) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Stdlib.ZArith.BinInt.Z) => dblZinc (rx y)) (fun (y : Stdlib.PArith.BinPos.positive) (_1 : Stdlib.ZArith.BinInt.Z) => dblZ (rx y))).

(* "Prelude.subNZ" was skipped *)

Definition ZtoNat : forall (_1 : Stdlib.ZArith.BinInt.Z), Init.Datatypes.nat :=
  Z_cases Init.Datatypes.nat SAWCoreScaffolding.Zero Stdlib.PArith.BinPos.Pos.to_nat (fun (_1 : Stdlib.PArith.BinPos.positive) => SAWCoreScaffolding.Zero).

(* "Prelude.subNat" was skipped *)

(* "Prelude.doubleNat" was skipped *)

(* "Prelude.posDivMod" was skipped *)

(* "Prelude.divModNat" was skipped *)

Definition divNat : forall (_1 : Init.Datatypes.nat), forall (_2 : Init.Datatypes.nat), Init.Datatypes.nat :=
  fun (x : Init.Datatypes.nat) (y : Init.Datatypes.nat) => fst (SAWCoreScaffolding.divModNat x y).

Definition modNat : forall (_1 : Init.Datatypes.nat), forall (_2 : Init.Datatypes.nat), Init.Datatypes.nat :=
  fun (x : Init.Datatypes.nat) (y : Init.Datatypes.nat) => snd (SAWCoreScaffolding.divModNat x y).

(* Prelude.AccessiblePos was skipped *)

(* "Prelude.AccessiblePos_Bit0" was skipped *)

(* "Prelude.AccessiblePos_Bit1" was skipped *)

(* "Prelude.AccessiblePos_all" was skipped *)

(* Prelude.AccessibleNat was skipped *)

(* "Prelude.AccessibleNat_NatPos" was skipped *)

(* "Prelude.AccessibleNat_all" was skipped *)

(* "Prelude.Nat__rec" was skipped *)

Definition Nat_cases : forall (a : Type), forall (_1 : a), forall (_2 : forall (_2 : Init.Datatypes.nat), forall (_3 : a), a), forall (_3 : Init.Datatypes.nat), a :=
  fun (a : Type) (f1 : a) (f2 : forall (_1 : Init.Datatypes.nat), forall (_2 : a), a) (n : Init.Datatypes.nat) => SAWCoreScaffolding.Nat__rec (fun (n1 : Init.Datatypes.nat) => a) f1 f2 n.

Definition Nat_cases2 : forall (a : Type), forall (_1 : forall (_1 : Init.Datatypes.nat), a), forall (_2 : forall (_2 : Init.Datatypes.nat), a), forall (_3 : forall (_3 : Init.Datatypes.nat), forall (_4 : Init.Datatypes.nat), forall (_5 : a), a), forall (_4 : Init.Datatypes.nat), forall (_5 : Init.Datatypes.nat), a :=
  fun (a : Type) (f1 : forall (_1 : Init.Datatypes.nat), a) (f2 : forall (_1 : Init.Datatypes.nat), a) (f3 : forall (_1 : Init.Datatypes.nat), forall (_2 : Init.Datatypes.nat), forall (_3 : a), a) (n : Init.Datatypes.nat) (m : Init.Datatypes.nat) => SAWCoreScaffolding.Nat__rec (fun (n1 : Init.Datatypes.nat) => forall (_1 : Init.Datatypes.nat), a) f1 (fun (n1 : Init.Datatypes.nat) (f_rec : forall (_1 : Init.Datatypes.nat), a) (m1 : Init.Datatypes.nat) => SAWCoreScaffolding.Nat__rec (fun (m' : Init.Datatypes.nat) => a) (f2 n1) (fun (m' : Init.Datatypes.nat) (frec' : a) => f3 n1 m' (f_rec m')) m1) n m.

Definition eqNat : forall (_1 : Init.Datatypes.nat), forall (_2 : Init.Datatypes.nat), Prop :=
  fun (x : Init.Datatypes.nat) (y : Init.Datatypes.nat) => @Init.Logic.eq Init.Datatypes.nat x y.

Definition eqNatSucc : forall (x : Init.Datatypes.nat), forall (y : Init.Datatypes.nat), forall (_1 : eqNat x y), eqNat (SAWCoreScaffolding.Succ x) (SAWCoreScaffolding.Succ y) :=
  fun (x : Init.Datatypes.nat) (y : Init.Datatypes.nat) (eq : eqNat x y) => eq_cong Init.Datatypes.nat x y eq Init.Datatypes.nat (fun (n : Init.Datatypes.nat) => SAWCoreScaffolding.Succ n).

Definition pred : forall (_1 : Init.Datatypes.nat), Init.Datatypes.nat :=
  fun (x : Init.Datatypes.nat) => Nat_cases Init.Datatypes.nat SAWCoreScaffolding.Zero (fun (n : Init.Datatypes.nat) (m : Init.Datatypes.nat) => n) x.

(* "Prelude.eqNatPrec" was skipped *)

(* Prelude.IsLeNat was skipped *)

(* "Prelude.IsLtNat" was skipped *)

(* "Prelude.IsLeNat__rec" was skipped *)

Axiom natCompareLe : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), Init.Datatypes.sum (SAWCoreScaffolding.IsLtNat m n) (SAWCoreScaffolding.IsLeNat n m) .

Definition proveEqNat : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), Maybe (@Init.Logic.eq Init.Datatypes.nat m n) :=
  SAWCoreScaffolding.Nat__rec (fun (m : Init.Datatypes.nat) => forall (n : Init.Datatypes.nat), Maybe (@Init.Logic.eq Init.Datatypes.nat m n)) (SAWCoreScaffolding.Nat__rec (fun (n : Init.Datatypes.nat) => Maybe (@Init.Logic.eq Init.Datatypes.nat SAWCoreScaffolding.Zero n)) (Just (@Init.Logic.eq Init.Datatypes.nat SAWCoreScaffolding.Zero SAWCoreScaffolding.Zero) (@Init.Logic.eq_refl Init.Datatypes.nat SAWCoreScaffolding.Zero)) (fun (n : Init.Datatypes.nat) (_1 : Maybe (@Init.Logic.eq Init.Datatypes.nat SAWCoreScaffolding.Zero n)) => Nothing (@Init.Logic.eq Init.Datatypes.nat SAWCoreScaffolding.Zero (SAWCoreScaffolding.Succ n)))) (fun (m : Init.Datatypes.nat) (rec : forall (n : Init.Datatypes.nat), Maybe (@Init.Logic.eq Init.Datatypes.nat m n)) => SAWCoreScaffolding.Nat__rec (fun (n : Init.Datatypes.nat) => Maybe (@Init.Logic.eq Init.Datatypes.nat (SAWCoreScaffolding.Succ m) n)) (Nothing (@Init.Logic.eq Init.Datatypes.nat (SAWCoreScaffolding.Succ m) SAWCoreScaffolding.Zero)) (fun (n : Init.Datatypes.nat) (_1 : Maybe (@Init.Logic.eq Init.Datatypes.nat (SAWCoreScaffolding.Succ m) n)) => let var__0   := @Init.Logic.eq Init.Datatypes.nat m n in
  let var__1   := @Init.Logic.eq Init.Datatypes.nat (SAWCoreScaffolding.Succ m) (SAWCoreScaffolding.Succ n) in
  maybe var__0 (Maybe var__1) (Nothing var__1) (fun (e : var__0) => Just var__1 (eqNatSucc m n e)) (rec n))).

Axiom proveLeNat : forall (x : Init.Datatypes.nat), forall (y : Init.Datatypes.nat), Maybe (SAWCoreScaffolding.IsLeNat x y) .

Definition proveLtNat : forall (x : Init.Datatypes.nat), forall (y : Init.Datatypes.nat), Maybe (SAWCoreScaffolding.IsLtNat x y) :=
  fun (x : Init.Datatypes.nat) (y : Init.Datatypes.nat) => proveLeNat (SAWCoreScaffolding.Succ x) y.

(* "Prelude.eqNatAdd0" was skipped *)

(* "Prelude.eqNatAddS" was skipped *)

(* "Prelude.eqNatAddComm" was skipped *)

(* "Prelude.addNat_assoc" was skipped *)

Definition equal0Nat : forall (_1 : Init.Datatypes.nat), Init.Datatypes.bool :=
  SAWCoreScaffolding.equalNat SAWCoreScaffolding.Zero.

Axiom equalNatToEqNat : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : @Init.Logic.eq Init.Datatypes.bool (SAWCoreScaffolding.equalNat m n) Init.Datatypes.true), eqNat m n .

Definition ifEqNatWithProof : forall (a : Type), forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : a), forall (_2 : forall (_2 : eqNat m n), a), a :=
  fun (a : Type) (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (x : a) (f : forall (_1 : eqNat m n), a) => let var__0   := SAWCoreScaffolding.equalNat m n in
  ifWithProof a var__0 x (fun (pf : @Init.Logic.eq Init.Datatypes.bool var__0 Init.Datatypes.true) => f (equalNatToEqNat m n pf)).

Definition natCase : forall (p : forall (_1 : Init.Datatypes.nat), Type), forall (_1 : p SAWCoreScaffolding.Zero), forall (_2 : forall (n : Init.Datatypes.nat), p (SAWCoreScaffolding.Succ n)), forall (n : Init.Datatypes.nat), p n :=
  fun (p : forall (_1 : Init.Datatypes.nat), Type) (z : p SAWCoreScaffolding.Zero) (s : forall (n : Init.Datatypes.nat), p (SAWCoreScaffolding.Succ n)) => SAWCoreScaffolding.Nat__rec p z (fun (n : Init.Datatypes.nat) (r : p n) => s n).

(* "Prelude.if0Nat" was skipped *)

Axiom expByNat : forall (a : Type), forall (_1 : a), forall (_2 : forall (_2 : a), forall (_3 : a), a), forall (_3 : a), forall (_4 : Init.Datatypes.nat), a .

Definition IsLeNat_transitive : forall (n : Init.Datatypes.nat), forall (m : Init.Datatypes.nat), forall (o : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLeNat n m), forall (_2 : SAWCoreScaffolding.IsLeNat m o), SAWCoreScaffolding.IsLeNat n o :=
  fun (n : Init.Datatypes.nat) (m : Init.Datatypes.nat) (o : Init.Datatypes.nat) (Hnm : SAWCoreScaffolding.IsLeNat n m) (Hmo : SAWCoreScaffolding.IsLeNat m o) => SAWCoreScaffolding.IsLeNat__rec m (fun (x : Init.Datatypes.nat) (H : SAWCoreScaffolding.IsLeNat m x) => SAWCoreScaffolding.IsLeNat n x) Hnm (fun (x : Init.Datatypes.nat) (H1 : SAWCoreScaffolding.IsLeNat m x) (H2 : SAWCoreScaffolding.IsLeNat n x) => SAWCoreScaffolding.IsLeNat_succ n x H2) o Hmo.

(* "Prelude.IsLtNat_Zero_absurd" was skipped *)

(* "Prelude.IsLeNat_SuccSucc" was skipped *)

Definition Nat_complete_induction : forall (p : forall (_1 : Init.Datatypes.nat), Prop), forall (_1 : forall (n : Init.Datatypes.nat), forall (_1 : forall (m : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLtNat m n), p m), p n), forall (n : Init.Datatypes.nat), p n :=
  fun (p : forall (_1 : Init.Datatypes.nat), Prop) (f : forall (n : Init.Datatypes.nat), forall (_1 : forall (m : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLtNat m n), p m), p n) (n : Init.Datatypes.nat) => SAWCoreScaffolding.Nat__rec (fun (n1 : Init.Datatypes.nat) => forall (m : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLeNat m n1), p m) (fun (n1 : Init.Datatypes.nat) (Hn : SAWCoreScaffolding.IsLeNat n1 SAWCoreScaffolding.Zero) => f n1 (fun (m : Init.Datatypes.nat) (Hm : SAWCoreScaffolding.IsLeNat (SAWCoreScaffolding.Succ m) n1) => SAWCoreScaffolding.IsLtNat_Zero_absurd (p m) m (IsLeNat_transitive (SAWCoreScaffolding.Succ m) n1 SAWCoreScaffolding.Zero Hm Hn))) (fun (n1 : Init.Datatypes.nat) (Hind : forall (m : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLeNat m n1), p m) (r : Init.Datatypes.nat) (Hr : SAWCoreScaffolding.IsLeNat r (SAWCoreScaffolding.Succ n1)) => f r (fun (m : Init.Datatypes.nat) (Hm : SAWCoreScaffolding.IsLeNat (SAWCoreScaffolding.Succ m) r) => Hind m (SAWCoreScaffolding.IsLeNat_SuccSucc m n1 (IsLeNat_transitive (SAWCoreScaffolding.Succ m) r (SAWCoreScaffolding.Succ n1) Hm Hr)))) n n (SAWCoreScaffolding.IsLeNat_base n).

(* "Prelude.Vec" was skipped *)

(* "Prelude.gen" was skipped *)

(* "Prelude.head" was skipped *)

(* "Prelude.tail" was skipped *)

(* "Prelude.head_gen" was skipped *)

(* "Prelude.tail_gen" was skipped *)

Definition atWithDefault' : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : Init.Datatypes.nat), a :=
  fun (n : Init.Datatypes.nat) (a : Type) (d : a) => SAWCoreScaffolding.Nat__rec (fun (n1 : Init.Datatypes.nat) => forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n1 a), forall (_2 : Init.Datatypes.nat), a) (fun (_1 : SAWCoreVectorsAsCoqVectors.Vec SAWCoreScaffolding.Zero a) (_2 : Init.Datatypes.nat) => d) (fun (n1 : Init.Datatypes.nat) (rec_f : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n1 a), forall (_2 : Init.Datatypes.nat), a) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n1) a) (i : Init.Datatypes.nat) => Nat_cases a (SAWCoreVectorsAsCoqVectors.head n1 a v) (fun (i_prev : Init.Datatypes.nat) (_1 : a) => rec_f (SAWCoreVectorsAsCoqVectors.tail n1 a v) i_prev) i) n.

(* "Prelude.atWithDefault" was skipped *)

Definition sawAt : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : Init.Datatypes.nat), a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (v : SAWCoreVectorsAsCoqVectors.Vec n a) (i : Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.atWithDefault n a (SAWCoreScaffolding.error a "at: index out of bounds"%string) v i.

(* "Prelude.EmptyVec" was skipped *)

Definition ConsVec : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : a), forall (n : Init.Datatypes.nat), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (x : a) (n : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.Succ n) a (Nat_cases a x (fun (i : Init.Datatypes.nat) (a' : a) => SAWCorePrelude.sawAt n a v i)).

Definition upd : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : Init.Datatypes.nat), forall (_3 : a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (v : SAWCoreVectorsAsCoqVectors.Vec n a) (j : Init.Datatypes.nat) (x : a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : Init.Datatypes.nat) => if SAWCoreScaffolding.equalNat i j then x else SAWCorePrelude.sawAt n a v i).

Definition map : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall (_1 : forall (_1 : a), b), forall (n : Init.Datatypes.nat), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), SAWCoreVectorsAsCoqVectors.Vec n b :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (b : Type) (f : forall (_1 : a), b) (n : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen n b (fun (i : Init.Datatypes.nat) => f (SAWCorePrelude.sawAt n a v i)).

Definition zipWith : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (b : Type), forall {Inh_b : SAWCoreScaffolding.Inhabited b}, forall (c : Type), forall (_1 : forall (_1 : a), forall (_2 : b), c), forall (n : Init.Datatypes.nat), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec n b), SAWCoreVectorsAsCoqVectors.Vec n c :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (b : Type) (Inh_b : SAWCoreScaffolding.Inhabited b) (c : Type) (f : forall (_1 : a), forall (_2 : b), c) (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n a) (y : SAWCoreVectorsAsCoqVectors.Vec n b) => SAWCoreVectorsAsCoqVectors.gen n c (fun (i : Init.Datatypes.nat) => f (SAWCorePrelude.sawAt n a x i) (SAWCorePrelude.sawAt n b y i)).

Definition replicate : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (x : a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (_1 : Init.Datatypes.nat) => x).

Definition single : forall (a : Type), forall (_1 : a), SAWCoreVectorsAsCoqVectors.Vec (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH) a :=
  replicate (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH).

(* "Prelude.at_single" was skipped *)


Fixpoint zip (a b : sort 0) (m n : nat) (xs : Vec m a) (ys : Vec n b)
  : Vec (minNat m n) (a * b) :=
  match
    xs in Vector.t _ m'
    return Vector.t _ (minNat m' n)
  with
  | Vector.nil => Vector.nil _
  | Vector.cons x pm xs =>
    match
      ys in Vector.t _ n'
      return Vector.t _ (minNat (S pm) n')
    with
    | Vector.nil => Vector.nil _
    | Vector.cons y pm' ys => Vector.cons _ (x, y) _ (zip _ _ _ _ xs ys)
    end
  end
.

(* "Prelude.foldr" was skipped *)

(* "Prelude.foldl" was skipped *)

(* "Prelude.scanl" was skipped *)

(* "Prelude.foldr_nil" was skipped *)

(* "Prelude.foldr_cons" was skipped *)

(* "Prelude.foldl_nil" was skipped *)

(* "Prelude.foldl_cons" was skipped *)

Definition reverse : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : Init.Datatypes.nat) => SAWCorePrelude.sawAt n a xs (SAWCoreScaffolding.subNat (SAWCoreScaffolding.subNat n (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH)) i)).

Definition transpose : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)), SAWCoreVectorsAsCoqVectors.Vec n (SAWCoreVectorsAsCoqVectors.Vec m a) :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (xss : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)) => SAWCoreVectorsAsCoqVectors.gen n (SAWCoreVectorsAsCoqVectors.Vec m a) (fun (j : Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.gen m a (fun (i : Init.Datatypes.nat) => SAWCorePrelude.sawAt n a (SAWCorePrelude.sawAt m (SAWCoreVectorsAsCoqVectors.Vec n a) xss i) j)).

Definition vecEq : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : forall (_1 : a), forall (_2 : a), Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec n a), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (eqFn : forall (_1 : a), forall (_2 : a), Init.Datatypes.bool) (x : SAWCoreVectorsAsCoqVectors.Vec n a) (y : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.foldr Init.Datatypes.bool Init.Datatypes.bool n Init.Datatypes.andb Init.Datatypes.true (zipWith a a Init.Datatypes.bool eqFn n x y).

Axiom vecEq_refl : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (eqFn : forall (_1 : a), forall (_2 : a), Init.Datatypes.bool), forall (_1 : forall (x : a), @Init.Logic.eq Init.Datatypes.bool (eqFn x x) Init.Datatypes.true), forall (x : SAWCoreVectorsAsCoqVectors.Vec n a), @Init.Logic.eq Init.Datatypes.bool (vecEq n a eqFn x x) Init.Datatypes.true .

Definition take : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a), SAWCoreVectorsAsCoqVectors.Vec m a :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a) => SAWCoreVectorsAsCoqVectors.gen m a (fun (i : Init.Datatypes.nat) => SAWCorePrelude.sawAt (SAWCoreScaffolding.addNat m n) a v i).

Definition vecCong : forall (a : Type), forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : @Init.Logic.eq Init.Datatypes.nat m n), @Init.Logic.eq Type (SAWCoreVectorsAsCoqVectors.Vec m a) (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (a : Type) (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (eq : @Init.Logic.eq Init.Datatypes.nat m n) => eq_cong Init.Datatypes.nat m n eq Type (fun (i : Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.Vec i a).

(* "Prelude.coerceVec" was skipped *)

(* "Prelude.take0" was skipped *)

Definition drop : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : Init.Datatypes.nat) => SAWCorePrelude.sawAt (SAWCoreScaffolding.addNat m n) a v (SAWCoreScaffolding.addNat m i)).

(* "Prelude.drop0" was skipped *)

Definition slice : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (o : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat (SAWCoreScaffolding.addNat m n) o) a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (o : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat (SAWCoreScaffolding.addNat m n) o) a) => drop a m n (take a (SAWCoreScaffolding.addNat m n) o v).

Definition join : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.mulNat m n) a :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (v : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.mulNat m n) a (fun (i : Init.Datatypes.nat) => SAWCorePrelude.sawAt n a (SAWCorePrelude.sawAt m (SAWCoreVectorsAsCoqVectors.Vec n a) v (divNat i n)) (modNat i n)).

Definition split : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.mulNat m n) a), SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.mulNat m n) a) => SAWCoreVectorsAsCoqVectors.gen m (SAWCoreVectorsAsCoqVectors.Vec n a) (fun (i : Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.gen n a (fun (j : Init.Datatypes.nat) => SAWCorePrelude.sawAt (SAWCoreScaffolding.mulNat m n) a v (SAWCoreScaffolding.addNat (SAWCoreScaffolding.mulNat i n) j))).

Definition append : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) a :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (x : SAWCoreVectorsAsCoqVectors.Vec m a) (y : SAWCoreVectorsAsCoqVectors.Vec n a) => SAWCoreVectorsAsCoqVectors.gen (SAWCoreScaffolding.addNat m n) a (fun (i : Init.Datatypes.nat) => if SAWCoreScaffolding.ltNat i m then SAWCorePrelude.sawAt m a x i else SAWCorePrelude.sawAt n a y (SAWCoreScaffolding.subNat i m)).

(* "Prelude.rotateL" was skipped *)

(* "Prelude.rotateR" was skipped *)

(* "Prelude.shiftL" was skipped *)

(* "Prelude.shiftR" was skipped *)

Definition joinLittleEndian : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.mulNat m n) a :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (v : SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a)) => join m n a (reverse m (SAWCoreVectorsAsCoqVectors.Vec n a) v).

Definition splitLittleEndian : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.mulNat m n) a), SAWCoreVectorsAsCoqVectors.Vec m (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.mulNat m n) a) => reverse m (SAWCoreVectorsAsCoqVectors.Vec n a) (split m n a v).

(* "Prelude.appendString" was skipped *)

Axiom bytesToString : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n (SAWCoreVectorsAsCoqVectors.Vec (Stdlib.PArith.BinPos.Pos.to_nat (Stdlib.PArith.BinPos.xO (Stdlib.PArith.BinPos.xO (Stdlib.PArith.BinPos.xO Stdlib.PArith.BinPos.xH)))) Init.Datatypes.bool)), Stdlib.Strings.String.string .

(* "Prelude.equalString" was skipped *)

Definition msb : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => SAWCorePrelude.sawAt (SAWCoreScaffolding.Succ n) Init.Datatypes.bool v SAWCoreScaffolding.Zero.

Definition lsb : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (v : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => SAWCorePrelude.sawAt (SAWCoreScaffolding.Succ n) Init.Datatypes.bool v n.

(* "Prelude.bvNat" was skipped *)

(* "Prelude.bvToNat" was skipped *)

Axiom bvNat_bvToNat : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), @Init.Logic.eq (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (SAWCoreVectorsAsCoqVectors.bvNat n (SAWCoreVectorsAsCoqVectors.bvToNat n x)) x .

Definition bvAt : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => SAWCorePrelude.sawAt n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvUpd : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_3 : a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) (y : a) => upd n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i) y.

Definition bvRotateL : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.rotateL n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvRotateR : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.rotateR n a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvShiftL : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (z : a) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.shiftL n a z xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvShiftR : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (z : a) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.shiftR n a z xs (SAWCoreVectorsAsCoqVectors.bvToNat w i).

Definition bvSShiftR : forall (n : Init.Datatypes.nat), forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (w : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a :=
  fun (n : Init.Datatypes.nat) (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (w : Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => let var__0   := SAWCoreScaffolding.Succ n in
  bvShiftR var__0 a w (SAWCorePrelude.sawAt var__0 a xs SAWCoreScaffolding.Zero) xs i.

(* "Prelude.bvAdd" was skipped *)

(* "Prelude.bvugt" was skipped *)

(* "Prelude.bvuge" was skipped *)

(* "Prelude.bvult" was skipped *)

(* "Prelude.bvule" was skipped *)

(* "Prelude.bvsgt" was skipped *)

(* "Prelude.bvsge" was skipped *)

(* "Prelude.bvslt" was skipped *)

(* "Prelude.bvsle" was skipped *)

(* "Prelude.bvPopcount" was skipped *)

(* "Prelude.bvCountLeadingZeros" was skipped *)

(* "Prelude.bvCountTrailingZeros" was skipped *)

(* "Prelude.bvForall" was skipped *)

Definition bvCarry : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => SAWCoreVectorsAsCoqVectors.bvult n (SAWCoreVectorsAsCoqVectors.bvAdd n x y) x.

Definition bvSCarry : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => let var__0   := msb n x in
  Init.Datatypes.andb (SAWCoreScaffolding.boolEq var__0 (msb n y)) (Init.Datatypes.xorb var__0 (msb n (SAWCoreVectorsAsCoqVectors.bvAdd (SAWCoreScaffolding.Succ n) x y))).

Definition bvAddWithCarry : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), prod Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => pair (bvCarry n x y) (SAWCoreVectorsAsCoqVectors.bvAdd n x y).

(* "Prelude.bvAddZeroL" was skipped *)

(* "Prelude.bvAddZeroR" was skipped *)

(* "Prelude.bvNeg" was skipped *)

(* "Prelude.bvSub" was skipped *)

Definition bvSBorrow : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => let var__0   := msb n x in
  Init.Datatypes.andb (Init.Datatypes.xorb var__0 (msb n y)) (Init.Datatypes.xorb var__0 (msb n (SAWCoreVectorsAsCoqVectors.bvSub (SAWCoreScaffolding.Succ n) x y))).

(* "Prelude.bvMul" was skipped *)

(* "Prelude.bvLg2" was skipped *)

(* "Prelude.bvUDiv" was skipped *)

(* "Prelude.bvURem" was skipped *)

(* "Prelude.bvSDiv" was skipped *)

(* "Prelude.bvSRem" was skipped *)

(* "Prelude.bvShl" was skipped *)

(* "Prelude.bvShr" was skipped *)

(* "Prelude.bvSShr" was skipped *)

(* "Prelude.bvShiftL_bvShl" was skipped *)

(* "Prelude.bvShiftR_bvShr" was skipped *)

Definition bvZipWith : forall (_1 : forall (_1 : Init.Datatypes.bool), forall (_2 : Init.Datatypes.bool), Init.Datatypes.bool), forall (n : Init.Datatypes.nat), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  zipWith Init.Datatypes.bool Init.Datatypes.bool Init.Datatypes.bool.

Definition bvNot : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  map Init.Datatypes.bool Init.Datatypes.bool Init.Datatypes.negb.

Definition bvAnd : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  bvZipWith Init.Datatypes.andb.

Definition bvOr : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  bvZipWith Init.Datatypes.orb.

Definition bvXor : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  bvZipWith Init.Datatypes.xorb.

Definition bvEq : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => vecEq n Init.Datatypes.bool SAWCoreScaffolding.boolEq x y.

(* "Prelude.bvEq_refl" was skipped *)

(* "Prelude.equalNat_bv" was skipped *)

Definition bvBool : forall (n : Init.Datatypes.nat), forall (_1 : Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (b : Init.Datatypes.bool) => if b then SAWCoreVectorsAsCoqVectors.bvNat n (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH) else SAWCoreVectorsAsCoqVectors.bvNat n SAWCoreScaffolding.Zero.

Definition bvNe : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => Init.Datatypes.negb (bvEq n x y).

Definition bvNonzero : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => bvNe n x (SAWCoreVectorsAsCoqVectors.bvNat n SAWCoreScaffolding.Zero).

Definition bvTrunc : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  drop Init.Datatypes.bool.

Definition bvUExt : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m n) Init.Datatypes.bool :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => append m n Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.bvNat m SAWCoreScaffolding.Zero) x.

Definition replicateBool : forall (n : Init.Datatypes.nat), forall (_1 : Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (b : Init.Datatypes.bool) => let var__0   := SAWCoreVectorsAsCoqVectors.bvNat n SAWCoreScaffolding.Zero in
  if b then bvNot n var__0 else var__0.

Definition bvSExt : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.addNat m (SAWCoreScaffolding.Succ n)) Init.Datatypes.bool :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => append m (SAWCoreScaffolding.Succ n) Init.Datatypes.bool (replicateBool m (msb n x)) x.

Definition bvMin : forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => if SAWCoreVectorsAsCoqVectors.bvule n x y then x else y.

Definition polyMul : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ m) Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ (SAWCoreScaffolding.addNat m n)) Init.Datatypes.bool :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ m) Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => let var__0   := SAWCoreScaffolding.Succ (SAWCoreScaffolding.addNat m n) in
  let var__1   := SAWCoreVectorsAsCoqVectors.Vec var__0 Init.Datatypes.bool in
  SAWCoreVectorsAsCoqVectors.foldl Init.Datatypes.bool var__1 (SAWCoreScaffolding.Succ n) (fun (z : var__1) (yi : Init.Datatypes.bool) => let var__2   := SAWCoreScaffolding.Succ m in
  let var__3   := SAWCoreScaffolding.addNat m n in
  let var__4   := SAWCoreScaffolding.Succ var__3 in
  let var__5   := SAWCoreScaffolding.addNat n var__2 in
  let var__6   := SAWCoreScaffolding.addNat n m in
  bvXor var__4 (SAWCoreVectorsAsCoqVectors.bvShl var__4 z (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH)) (SAWCoreScaffolding.coerce (SAWCoreVectorsAsCoqVectors.Vec var__5 Init.Datatypes.bool) var__1 (vecCong Init.Datatypes.bool var__5 var__4 (trans Init.Datatypes.nat var__5 (SAWCoreScaffolding.Succ var__6) var__4 (SAWCoreScaffolding.eqNatAddS n m) (eqNatSucc var__6 var__3 (SAWCoreScaffolding.eqNatAddComm n m)))) (bvUExt n var__2 (if yi then x else SAWCoreVectorsAsCoqVectors.bvNat var__2 SAWCoreScaffolding.Zero)))) (SAWCoreVectorsAsCoqVectors.bvNat var__0 SAWCoreScaffolding.Zero) y.

Definition polyMod : forall (m : Init.Datatypes.nat), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec m Init.Datatypes.bool), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool), SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool :=
  fun (m : Init.Datatypes.nat) (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec m Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool) => let var__0   := SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) Init.Datatypes.bool in
  (fun (reduce : forall (_1 : var__0), var__0) => let var__1   := SAWCoreScaffolding.Succ n in
  fst (SAWCoreVectorsAsCoqVectors.foldr Init.Datatypes.bool (prod (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) var__0) m (fun (xi : Init.Datatypes.bool) (acc : prod (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) var__0) => let var__2   := snd acc in
  pair (bvXor n (fst acc) (if xi then SAWCoreVectorsAsCoqVectors.tail n Init.Datatypes.bool var__2 else SAWCoreVectorsAsCoqVectors.bvNat n SAWCoreScaffolding.Zero)) (reduce (SAWCoreVectorsAsCoqVectors.bvShl var__1 var__2 (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH)))) (pair (SAWCoreVectorsAsCoqVectors.bvNat n SAWCoreScaffolding.Zero) (reduce (SAWCoreVectorsAsCoqVectors.bvNat var__1 (Stdlib.PArith.BinPos.Pos.to_nat Stdlib.PArith.BinPos.xH)))) x)) (fun (u : var__0) => let var__1   := SAWCoreScaffolding.Succ n in
  bvMin var__1 u (bvXor var__1 u y)).

Inductive Stream (a : Type) : Type :=
| MkStream : forall (_1 : forall (_1 : Init.Datatypes.nat), a), Stream a
.

#[global] Instance Inhabited_Stream (a:Type) (Ha:Inhabited a) : Inhabited (Stream a) := MkInhabited (Stream a) (MkStream a (fun _ => inhabitant)).
Definition Stream__rec : forall (a : Type), forall (p : forall (_1 : Stream a), Type), forall (_1 : forall (f : forall (_1 : Init.Datatypes.nat), a), p (MkStream a f)), forall (str : Stream a), p str :=
  fun (a : Type) (p : forall (_1 : Stream a), Type) (f1 : forall (f : forall (_1 : Init.Datatypes.nat), a), p (MkStream a f)) (str : Stream a) => @SAWCorePrelude.Stream_rect a p f1 str.

Definition streamUpd : forall (a : Type), forall (_1 : Stream a), forall (_2 : Init.Datatypes.nat), forall (_3 : a), Stream a :=
  fun (a : Type) (strm : Stream a) (i : Init.Datatypes.nat) (y : a) => Stream__rec a (fun (strm' : Stream a) => Stream a) (fun (s : forall (_1 : Init.Datatypes.nat), a) => MkStream a (fun (j : Init.Datatypes.nat) => if SAWCoreScaffolding.equalNat i j then y else s j)) strm.

Definition bvStreamUpd : forall (a : Type), forall (w : Init.Datatypes.nat), forall (_1 : Stream a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_3 : a), Stream a :=
  fun (a : Type) (w : Init.Datatypes.nat) (xs : Stream a) (i : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) (y : a) => streamUpd a xs (SAWCoreVectorsAsCoqVectors.bvToNat w i) y.

Definition streamGet : forall (a : Type), forall (_1 : Stream a), forall (_2 : Init.Datatypes.nat), a :=
  fun (a : Type) (strm : Stream a) (i : Init.Datatypes.nat) => Stream__rec a (fun (strm' : Stream a) => a) (fun (s : forall (_1 : Init.Datatypes.nat), a) => s i) strm.

Definition streamConst : forall (a : Type), forall (_1 : a), Stream a :=
  fun (a : Type) (x : a) => MkStream a (fun (i : Init.Datatypes.nat) => x).

Definition streamMap : forall (a : Type), forall (b : Type), forall (_1 : forall (_1 : a), b), forall (_2 : Stream a), Stream b :=
  fun (a : Type) (b : Type) (f : forall (_1 : a), b) (xs : Stream a) => MkStream b (fun (i : Init.Datatypes.nat) => f (streamGet a xs i)).

Definition streamMap2 : forall (a : Type), forall (b : Type), forall (c : Type), forall (_1 : forall (_1 : a), forall (_2 : b), c), forall (_2 : Stream a), forall (_3 : Stream b), Stream c :=
  fun (a : Type) (b : Type) (c : Type) (f : forall (_1 : a), forall (_2 : b), c) (xs : Stream a) (ys : Stream b) => MkStream c (fun (i : Init.Datatypes.nat) => f (streamGet a xs i) (streamGet b ys i)).

Definition streamTake : forall (a : Type), forall (n : Init.Datatypes.nat), forall (_1 : Stream a), SAWCoreVectorsAsCoqVectors.Vec n a :=
  fun (a : Type) (n : Init.Datatypes.nat) (xs : Stream a) => SAWCoreVectorsAsCoqVectors.gen n a (fun (i : Init.Datatypes.nat) => streamGet a xs i).

Definition streamDrop : forall (a : Type), forall (n : Init.Datatypes.nat), forall (_1 : Stream a), Stream a :=
  fun (a : Type) (n : Init.Datatypes.nat) (xs : Stream a) => MkStream a (fun (i : Init.Datatypes.nat) => streamGet a xs (SAWCoreScaffolding.addNat n i)).

Definition streamAppend : forall (a : Type), forall (n : Init.Datatypes.nat), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_2 : Stream a), Stream a :=
  fun (a : Type) (n : Init.Datatypes.nat) (xs : SAWCoreVectorsAsCoqVectors.Vec n a) (ys : Stream a) => MkStream a (fun (i : Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.atWithDefault n a (streamGet a ys (SAWCoreScaffolding.subNat i n)) xs i).

Definition streamJoin : forall (a : Type), forall {Inh_a : SAWCoreScaffolding.Inhabited a}, forall (n : Init.Datatypes.nat), forall (_1 : Stream (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a)), Stream a :=
  fun (a : Type) (Inh_a : SAWCoreScaffolding.Inhabited a) (n : Init.Datatypes.nat) (s : Stream (SAWCoreVectorsAsCoqVectors.Vec (SAWCoreScaffolding.Succ n) a)) => MkStream a (fun (i : Init.Datatypes.nat) => let var__0   := SAWCoreScaffolding.Succ n in
  SAWCorePrelude.sawAt var__0 a (streamGet (SAWCoreVectorsAsCoqVectors.Vec var__0 a) s (divNat i var__0)) (modNat i var__0)).

Definition streamSplit : forall (a : Type), forall (n : Init.Datatypes.nat), forall (_1 : Stream a), Stream (SAWCoreVectorsAsCoqVectors.Vec n a) :=
  fun (a : Type) (n : Init.Datatypes.nat) (xs : Stream a) => MkStream (SAWCoreVectorsAsCoqVectors.Vec n a) (fun (i : Init.Datatypes.nat) => SAWCoreVectorsAsCoqVectors.gen n a (fun (j : Init.Datatypes.nat) => streamGet a xs (SAWCoreScaffolding.addNat (SAWCoreScaffolding.mulNat i n) j))).

Definition streamShiftL : forall (a : Type), forall (_1 : Stream a), forall (_2 : Init.Datatypes.nat), Stream a :=
  fun (a : Type) (xs : Stream a) (i : Init.Datatypes.nat) => streamDrop a i xs.

Definition streamShiftR : forall (a : Type), forall (_1 : a), forall (_2 : Stream a), forall (_3 : Init.Datatypes.nat), Stream a :=
  fun (a : Type) (z : a) (xs : Stream a) (i : Init.Datatypes.nat) => streamAppend a i (replicate i a z) xs.

(* "Prelude.streamScanl" was skipped *)

(* "Prelude.Integer" was skipped *)

(* "Prelude.intAdd" was skipped *)

(* "Prelude.intSub" was skipped *)

(* "Prelude.intMul" was skipped *)

(* "Prelude.intDiv" was skipped *)

(* "Prelude.intMod" was skipped *)

(* "Prelude.intMin" was skipped *)

(* "Prelude.intMax" was skipped *)

(* "Prelude.intNeg" was skipped *)

(* "Prelude.intAbs" was skipped *)

(* "Prelude.intEq" was skipped *)

(* "Prelude.intLe" was skipped *)

(* "Prelude.intLt" was skipped *)

(* "Prelude.intToNat" was skipped *)

(* "Prelude.natToInt" was skipped *)

(* "Prelude.intToBv" was skipped *)

(* "Prelude.bvToInt" was skipped *)

(* "Prelude.sbvToInt" was skipped *)

(* "Prelude.IntMod" was skipped *)

(* "Prelude.toIntMod" was skipped *)

(* "Prelude.fromIntMod" was skipped *)

(* "Prelude.intModEq" was skipped *)

(* "Prelude.intModAdd" was skipped *)

(* "Prelude.intModSub" was skipped *)

(* "Prelude.intModMul" was skipped *)

(* "Prelude.intModNeg" was skipped *)

Definition updNatFun : forall (a : Type), forall (_1 : forall (_1 : Init.Datatypes.nat), a), forall (_2 : Init.Datatypes.nat), forall (_3 : a), forall (_4 : Init.Datatypes.nat), a :=
  fun (a : Type) (f : forall (_1 : Init.Datatypes.nat), a) (i : Init.Datatypes.nat) (v : a) (x : Init.Datatypes.nat) => if SAWCoreScaffolding.equalNat i x then v else f x.

Definition updBvFun : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_3 : a), forall (_4 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), a :=
  fun (n : Init.Datatypes.nat) (a : Type) (f : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), a) (i : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (v : a) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => if bvEq n i x then v else f x.

(* "Prelude.Float" was skipped *)

(* "Prelude.mkFloat" was skipped *)

(* "Prelude.Double" was skipped *)

(* "Prelude.mkDouble" was skipped *)

(* Prelude.List was skipped *)

(* "Prelude.List__rec" was skipped *)

Definition unfoldList : forall (a : Type), forall (_1 : @Init.Datatypes.list a), Init.Datatypes.sum (unit : Type) (prod a (@Init.Datatypes.list a)) :=
  fun (a : Type) (l : @Init.Datatypes.list a) => let var__0   := @Init.Datatypes.list a in
  @Init.Datatypes.list_rect a (fun (_1 : var__0) => Init.Datatypes.sum (unit : Type) (prod a var__0)) (@Init.Datatypes.inl (unit : Type) (prod a var__0) tt) (fun (x : a) (l1 : var__0) (_1 : Init.Datatypes.sum (unit : Type) (prod a var__0)) => @Init.Datatypes.inr (unit : Type) (prod a var__0) (pair x l1)) l.

Definition foldList : forall (a : Type), forall (_1 : Init.Datatypes.sum (unit : Type) (prod a (@Init.Datatypes.list a))), @Init.Datatypes.list a :=
  fun (a : Type) => let var__0   := @Init.Datatypes.list a in
  let var__1   := prod a var__0 in
  either (unit : Type) var__1 var__0 (fun (_1 : unit : Type) => @Init.Datatypes.nil a) (fun (tup : var__1) => @Init.Datatypes.cons a (fst tup) (snd tup)).

Inductive ListSort : Type :=
| LS_Nil : ListSort
| LS_Cons : forall (_1 : Type), forall (_2 : ListSort), ListSort
.

Definition ListSort__rec : forall (P : forall (_1 : ListSort), Type), forall (_1 : P LS_Nil), forall (_2 : forall (A : Type), forall (l : ListSort), forall (_2 : P l), P (LS_Cons A l)), forall (l : ListSort), P l :=
  fun (P : forall (_1 : ListSort), Type) (f1 : P LS_Nil) (f2 : forall (A : Type), forall (l : ListSort), forall (_1 : P l), P (LS_Cons A l)) (l : ListSort) => @SAWCorePrelude.ListSort_rect P f1 f2 l.

Definition listSortGet : forall (_1 : ListSort), forall (_2 : Init.Datatypes.nat), Type :=
  ListSort__rec (fun (_1 : ListSort) => forall (_2 : Init.Datatypes.nat), Type) (fun (_1 : Init.Datatypes.nat) => @Init.Logic.eq Init.Datatypes.bool Init.Datatypes.true Init.Datatypes.false) (fun (A : Type) (_1 : ListSort) (rec : forall (_2 : Init.Datatypes.nat), Type) => Nat_cases Type A (fun (n : Init.Datatypes.nat) (_2 : Type) => rec n)).

Definition listSort_cases : forall (a : Type), forall (_1 : a), forall (_2 : forall (_2 : Type), forall (l : ListSort), forall (_3 : a), a), forall (_3 : ListSort), a :=
  fun (a : Type) (base : a) (f : forall (_1 : Type), forall (l : ListSort), forall (_2 : a), a) (ls : ListSort) => ListSort__rec (fun (_1 : ListSort) => a) base f ls.

Definition listSortDrop : forall (_1 : ListSort), forall (_2 : Init.Datatypes.nat), ListSort :=
  fun (ss : ListSort) (n : Init.Datatypes.nat) => SAWCoreScaffolding.Nat__rec (fun (_1 : Init.Datatypes.nat) => forall (_2 : ListSort), ListSort) (fun (l : ListSort) => l) (fun (_1 : Init.Datatypes.nat) (rec_n' : forall (_2 : ListSort), ListSort) (l : ListSort) => rec_n' (listSort_cases ListSort LS_Nil (fun (_2 : Type) (tail : ListSort) (_3 : ListSort) => tail) l)) n ss.

Definition listSort_length : forall (_1 : ListSort), Init.Datatypes.nat :=
  listSort_cases Init.Datatypes.nat SAWCoreScaffolding.Zero (fun (_1 : Type) (_2 : ListSort) (n : Init.Datatypes.nat) => SAWCoreScaffolding.Succ n).

Definition ifLSNil : forall (a : Type), forall (_1 : ListSort), forall (_2 : a), forall (_3 : a), a :=
  fun (a : Type) (l : ListSort) (x : a) (y : a) => ListSort__rec (fun (_1 : ListSort) => a) x (fun (_1 : Type) (_2 : ListSort) (_3 : a) => y) l.

Definition FalseProp : Prop :=
  @Init.Logic.eq Init.Datatypes.bool Init.Datatypes.true Init.Datatypes.false.

Definition efq : forall (a : Type), forall (_1 : FalseProp), a :=
  fun (a : Type) (contra : FalseProp) => let var__0   := if Init.Datatypes.true then unit : Type else a in
  SAWCoreScaffolding.coerce (unit : Type) a (trans Type (unit : Type) var__0 a (sym Type var__0 (unit : Type) (ite_true Type (unit : Type) a)) (trans Type var__0 (if Init.Datatypes.false then unit : Type else a) a (eq_cong Init.Datatypes.bool Init.Datatypes.true Init.Datatypes.false contra Type (fun (b : Init.Datatypes.bool) => if b then unit : Type else a)) (ite_false Type (unit : Type) a))) tt.

Definition Eithers : forall (_1 : ListSort), Type :=
  ListSort__rec (fun (_1 : ListSort) => Type) FalseProp (fun (tp : Type) (tail : ListSort) (rec : Type) => ifLSNil Type tail tp (Init.Datatypes.sum tp rec)).

Definition eithers1 : forall (tp : Type), forall (tps : ListSort), forall (a : Type), forall (_1 : Eithers (LS_Cons tp tps)), forall (_2 : forall (_2 : tp), a), forall (_3 : forall (_3 : Eithers tps), a), a :=
  fun (tp : Type) (tps : ListSort) (a : Type) => ListSort__rec (fun (tps1 : ListSort) => forall (_1 : Eithers (LS_Cons tp tps1)), forall (_2 : forall (_2 : tp), a), forall (_3 : forall (_3 : Eithers tps1), a), a) (fun (eiths : tp) (f : forall (_1 : tp), a) (_1 : forall (_1 : FalseProp), a) => f eiths) (fun (tp2 : Type) (tail : ListSort) (_1 : forall (_1 : Eithers (LS_Cons tp tail)), forall (_2 : forall (_2 : tp), a), forall (_3 : forall (_3 : Eithers tail), a), a) (eiths : Init.Datatypes.sum tp (Eithers (LS_Cons tp2 tail))) (f1 : forall (_2 : tp), a) (f2 : forall (_2 : Eithers (LS_Cons tp2 tail)), a) => either tp (Eithers (LS_Cons tp2 tail)) a f1 f2 eiths) tps.

Inductive FunsTo (a : Type) : Type :=
| FunsTo_Nil :  FunsTo a
| FunsTo_Cons : forall (tp : Type), forall (_1 : forall (_1 : tp), a), forall (_2 : FunsTo a), FunsTo a
.

Definition FunsTo__rec : forall (a : Type), forall (P : forall (_1 : FunsTo a), Type), forall (_1 : P (FunsTo_Nil a)), forall (_2 : forall (tp : Type), forall (f : forall (_2 : tp), a), forall (es : FunsTo a), forall (_2 : P es), P (FunsTo_Cons a tp f es)), forall (es : FunsTo a), P es :=
  fun (a : Type) (P : forall (_1 : FunsTo a), Type) (f1 : P (FunsTo_Nil a)) (f2 : forall (tp : Type), forall (f : forall (_1 : tp), a), forall (es : FunsTo a), forall (_1 : P es), P (FunsTo_Cons a tp f es)) (es : FunsTo a) => @SAWCorePrelude.FunsTo_rect a P f1 f2 es.

Definition FunsToIns : forall (a : Type), forall (_1 : FunsTo a), ListSort :=
  fun (a : Type) => FunsTo__rec a (fun (_1 : FunsTo a) => ListSort) LS_Nil (fun (tp : Type) (_1 : forall (_1 : tp), a) (_2 : FunsTo a) (rec : ListSort) => LS_Cons tp rec).

Definition eithers : forall (a : Type), forall (elims : FunsTo a), forall (_1 : Eithers (FunsToIns a elims)), a :=
  fun (a : Type) => FunsTo__rec a (fun (elims : FunsTo a) => forall (_1 : Eithers (FunsToIns a elims)), a) (fun (contra : FalseProp) => efq a contra) (fun (tp : Type) (f : forall (_1 : tp), a) (elims : FunsTo a) (rec : forall (_1 : Eithers (FunsToIns a elims)), a) (eiths : Eithers (LS_Cons tp (FunsToIns a elims))) => eithers1 tp (FunsToIns a elims) a eiths f rec).

Definition EithersV : forall (_1 : ListSort), Type :=
  ListSort__rec (fun (_1 : ListSort) => Type) Init.Datatypes.Empty_set (fun (tp : Type) (_1 : ListSort) (rec : Type) => Init.Datatypes.sum tp rec).

Definition eithersV : forall (a : Type), forall (es : FunsTo a), forall (_1 : EithersV (FunsToIns a es)), a :=
  fun (a : Type) => FunsTo__rec a (fun (es : FunsTo a) => forall (_1 : EithersV (FunsToIns a es)), a) (fun (v : Init.Datatypes.Empty_set) => elimVoid a v) (fun (tp : Type) (f : forall (_1 : tp), a) (es : FunsTo a) (rec : forall (_1 : EithersV (FunsToIns a es)), a) => either tp (EithersV (FunsToIns a es)) a f rec).

Definition arrowsType : forall (_1 : ListSort), forall (_2 : Type), Type :=
  fun (as1 : ListSort) (b : Type) => ListSort__rec (fun (_1 : ListSort) => Type) b (fun (a : Type) (_1 : ListSort) (rec : Type) => forall (_2 : a), rec) as1.

Definition arrowsSort : forall (_1 : ListSort), Type :=
  fun (as1 : ListSort) => @SAWCorePrelude.ListSort_rect (fun (_1 : ListSort) => Type) Type (fun (a : Type) (_1 : ListSort) (rec : Type) => forall (_2 : a), rec) as1.

(* "Prelude.unsafeAssertBVULt" was skipped *)

(* "Prelude.unsafeAssertBVULe" was skipped *)

Axiom bvEqToEq : forall (n : Init.Datatypes.nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : @Init.Logic.eq Init.Datatypes.bool (bvEq n v1 v2) Init.Datatypes.true), @Init.Logic.eq (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) v1 v2 .

Definition ifBvEqWithProof : forall (a : Type), forall (n : Init.Datatypes.nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : a), forall (_2 : forall (_2 : @Init.Logic.eq (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) v1 v2), a), a :=
  fun (a : Type) (n : Init.Datatypes.nat) (v1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (v2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (x : a) (f : forall (_1 : @Init.Logic.eq (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) v1 v2), a) => let var__0   := bvEq n v1 v2 in
  ifWithProof a var__0 x (fun (pf : @Init.Logic.eq Init.Datatypes.bool var__0 Init.Datatypes.true) => f (bvEqToEq n v1 v2 pf)).

Axiom bvEqToEqNat : forall (n : Init.Datatypes.nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : @Init.Logic.eq (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) v1 v2), eqNat (SAWCoreVectorsAsCoqVectors.bvToNat n v1) (SAWCoreVectorsAsCoqVectors.bvToNat n v2) .

Axiom bvultToIsLtNat : forall (n : Init.Datatypes.nat), forall (v1 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (v2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : @Init.Logic.eq Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.bvult n v1 v2) Init.Datatypes.true), SAWCoreScaffolding.IsLtNat (SAWCoreVectorsAsCoqVectors.bvToNat n v1) (SAWCoreVectorsAsCoqVectors.bvToNat n v2) .

(* "Prelude.genWithProof" was skipped *)

(* "Prelude.atWithProof" was skipped *)

Axiom updWithProof : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (i : Init.Datatypes.nat), forall (_2 : a), forall (_3 : SAWCoreScaffolding.IsLtNat i n), SAWCoreVectorsAsCoqVectors.Vec n a .

Axiom sliceWithProof : forall (a : Type), forall (n : Init.Datatypes.nat), forall (off : Init.Datatypes.nat), forall (len : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLeNat (SAWCoreScaffolding.addNat off len) n), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), SAWCoreVectorsAsCoqVectors.Vec len a .

Axiom updSliceWithProof : forall (a : Type), forall (n : Init.Datatypes.nat), forall (off : Init.Datatypes.nat), forall (len : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLeNat (SAWCoreScaffolding.addNat off len) n), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n a), forall (_3 : SAWCoreVectorsAsCoqVectors.Vec len a), SAWCoreVectorsAsCoqVectors.Vec n a .

Definition is_bvult : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Prop :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.bvult n x y) Init.Datatypes.true.

Definition is_bvule : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Prop :=
  fun (n : Init.Datatypes.nat) (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) => @Init.Logic.eq Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.bvule n x y) Init.Datatypes.true.

Axiom not_bvult_zero : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), @Init.Logic.eq Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.bvult n x (SAWCoreVectorsAsCoqVectors.bvNat n SAWCoreScaffolding.Zero)) Init.Datatypes.false .

Axiom trans_bvult_bvule : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (z : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : is_bvult n x y), forall (_2 : is_bvule n y z), is_bvult n x z .

Axiom bvult_sub_add_bvult : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (z : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : is_bvule n y z), forall (_2 : is_bvult n x (SAWCoreVectorsAsCoqVectors.bvSub n z y)), is_bvult n (SAWCoreVectorsAsCoqVectors.bvAdd n y x) z .

Axiom bvult_sum_bvult_sub : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (y : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (z : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_1 : is_bvult n x (SAWCoreVectorsAsCoqVectors.bvAdd n y z)), forall (_2 : @Init.Logic.eq Init.Datatypes.bool (SAWCoreVectorsAsCoqVectors.bvult n x y) Init.Datatypes.false), is_bvult n (SAWCoreVectorsAsCoqVectors.bvSub n x y) z .

Axiom IsLtNat_to_bvult : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (i : Init.Datatypes.nat), forall (_1 : SAWCoreScaffolding.IsLtNat i (SAWCoreVectorsAsCoqVectors.bvToNat n x)), is_bvult n (SAWCoreVectorsAsCoqVectors.bvNat n i) x .

Axiom bvult_to_IsLtNat : forall (n : Init.Datatypes.nat), forall (x : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (i : Init.Datatypes.nat), forall (_1 : is_bvult n (SAWCoreVectorsAsCoqVectors.bvNat n i) x), SAWCoreScaffolding.IsLtNat i (SAWCoreVectorsAsCoqVectors.bvToNat n x) .

Definition BV_complete_induction : forall (w : Init.Datatypes.nat), forall (p : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), Prop), forall (_1 : forall (x : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_1 : forall (y : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_1 : is_bvult w y x), p y), p x), forall (x : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), p x :=
  fun (w : Init.Datatypes.nat) (p : forall (_1 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), Prop) (f : forall (x : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_1 : forall (y : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_1 : is_bvult w y x), p y), p x) (x : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) => let var__0   := SAWCoreVectorsAsCoqVectors.bvToNat w x in
  Nat_complete_induction (fun (n : Init.Datatypes.nat) => forall (x1 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (_1 : SAWCoreScaffolding.IsLeNat (SAWCoreVectorsAsCoqVectors.bvToNat w x1) n), p x1) (fun (n : Init.Datatypes.nat) (Hind : forall (m : Init.Datatypes.nat), forall (Hm : SAWCoreScaffolding.IsLtNat m n), forall (y : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool), forall (Hy : SAWCoreScaffolding.IsLeNat (SAWCoreVectorsAsCoqVectors.bvToNat w y) m), p y) (x1 : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) (Hx : SAWCoreScaffolding.IsLeNat (SAWCoreVectorsAsCoqVectors.bvToNat w x1) n) => f x1 (fun (y : SAWCoreVectorsAsCoqVectors.Vec w Init.Datatypes.bool) (Hult : is_bvult w y x1) => let var__1   := SAWCoreVectorsAsCoqVectors.bvToNat w y in
  Hind var__1 (IsLeNat_transitive (SAWCoreScaffolding.Succ var__1) (SAWCoreVectorsAsCoqVectors.bvToNat w x1) n (bvultToIsLtNat w y x1 Hult) Hx) y (SAWCoreScaffolding.IsLeNat_base var__1))) var__0 x (SAWCoreScaffolding.IsLeNat_base var__0).

Axiom Array : forall (_1 : Type), forall (_2 : Type), Type .

Axiom arrayConstant : forall (a : Type), forall (b : Type), forall (_1 : b), Array a b .

Axiom arrayLookup : forall (a : Type), forall (b : Type), forall (_1 : Array a b), forall (_2 : a), b .

Axiom arrayUpdate : forall (a : Type), forall (b : Type), forall (_1 : Array a b), forall (_2 : a), forall (_3 : b), Array a b .

Axiom arrayCopy : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_3 : Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a), forall (_4 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_5 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a .

Axiom arraySet : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_3 : a), forall (_4 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a .

Axiom arrayRangeEq : forall (n : Init.Datatypes.nat), forall (a : Type), forall (_1 : Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a), forall (_2 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_3 : Array (SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool) a), forall (_4 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), forall (_5 : SAWCoreVectorsAsCoqVectors.Vec n Init.Datatypes.bool), Init.Datatypes.bool .

Axiom arrayEq : forall (a : Type), forall (b : Type), forall (_1 : Array a b), forall (_2 : Array a b), Init.Datatypes.bool .

(* "Prelude.bveq_sameL" was skipped *)

(* "Prelude.bveq_sameR" was skipped *)

(* "Prelude.bveq_same2" was skipped *)

(* "Prelude.ite_split_cong" was skipped *)

(* "Prelude.ite_join_cong" was skipped *)

(* "Prelude.map_map" was skipped *)

End SAWCorePrelude.

