

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Case study: Salsa20 &mdash; SAW Documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/sphinx_rtd_theme.css?v=3234e928" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/js/hoverxref.js"></script>
      <script src="../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../_static/js/micromodal.min.js"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/versions.js?v=302bdcf2"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A final word" href="a-final-word.html" />
    <link rel="prev" title="Static items" href="static-items.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SAW Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../llvm-java-verification-with-saw/index.html">LLVM/Java Verification with SAW</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Rust Verification with SAW</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="prerequisites.html">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="about-mir-json.html">About <code class="docutils literal notranslate"><span class="pre">mir-json</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="saw-basics.html">SAW basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference-types.html">Reference types</a></li>
<li class="toctree-l2"><a class="reference internal" href="compound-data-types.html">Compound data types</a></li>
<li class="toctree-l2"><a class="reference internal" href="overrides-and-compositional-verification.html">Overrides and compositional verification</a></li>
<li class="toctree-l2"><a class="reference internal" href="static-items.html">Static items</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Case study: Salsa20</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-salsa20-crate">The <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#salsa20-preliminaries">Salsa20 preliminaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-note-about-cryptographic-security">A note about cryptographic security</a></li>
<li class="toctree-l3"><a class="reference internal" href="#an-overview-of-the-salsa20-code">An overview of the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-salsa20">Building <code class="docutils literal notranslate"><span class="pre">salsa20</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-started-with-saw">Getting started with SAW</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-our-first-salsa20-function">Verifying our first <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-the-rounds-function">Verifying the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-the-counter-setup-function">Verifying the <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-the-apply-keystream-function-first-attempt">Verifying the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function (first attempt)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-the-new-raw-function">Verifying the <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-the-apply-keystream-function-second-attempt">Verifying the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function (second attempt)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="a-final-word.html">A final word</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../saw-user-manual/index.html">SAW User Manual</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SAW Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Rust Verification with SAW</a></li>
      <li class="breadcrumb-item active">Case study: Salsa20</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rust-verification-with-saw/case-study-salsa20.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="case-study-salsa20">
<h1>Case study: Salsa20<a class="headerlink" href="#case-study-salsa20" title="Link to this heading"></a></h1>
<p>If you’ve made it this far into the tutorial, congrats! You’ve now been exposed
to all of the SAW fundamentals that you need to verify Rust code found in the
wild. Of course, talking about verifying real-world code is one thing, but
actually <em>doing</em> the verification is another thing entirely. Making the jump
from the small examples to “industrial-strength” code can be intimidating.</p>
<p>To make this jump somewhat less frightening, the last part of this tutorial
will consist of a case study in using SAW to verify a non-trivial piece of Rust
code. In particular, we will be looking at a Rust implementation of the
<a class="reference external" href="https://en.wikipedia.org/wiki/Salsa20">Salsa20</a> stream cipher. We do not
assume any prior expertise in cryptography or stream ciphers in this tutorial,
so don’t worry if you are not familiar with Salsa20.</p>
<p>More than anything, this case study is meant to emphasize that verification is
an iterative process. It’s not uncommon to try something with SAW and encounter
an error message. That’s OK! We will explain what can go wrong when verifying
Salsa20 and how to recover from these mistakes. Later, if you encounter similar
issues when verifying your own code with SAW, the experience you have developed
when developing these proofs can inform you of possible ways to fix the issues.</p>
<section id="the-salsa20-crate">
<h2>The <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate<a class="headerlink" href="#the-salsa20-crate" title="Link to this heading"></a></h2>
<p>The code for this Salsa20 implementation we will be verifying can be found
under the
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20"><code class="docutils literal notranslate"><span class="pre">code/salsa20</span></code></a>
subdirectory. This code is adapted from version 0.3.0 of the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate,
which is a part of the
<a class="reference external" href="https://github.com/RustCrypto/stream-ciphers"><code class="docutils literal notranslate"><span class="pre">stream-ciphers</span></code></a> project. The
code implements Salsa20 as well as variants such as HSalsa20 and XSalsa20, but
we will only be focusing on the original Salsa20 cipher in this tutorial.</p>
<p>The parts of the crate that are relevant for our needs are mostly contained in
the
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/src/core.rs"><code class="docutils literal notranslate"><span class="pre">src/core.rs</span></code></a>
file, as well as some auxiliary definitions in the
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/src/rounds.rs"><code class="docutils literal notranslate"><span class="pre">src/rounds.rs</span></code></a>
and
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/src/lib.rs"><code class="docutils literal notranslate"><span class="pre">src/lib.rs</span></code></a>
files. You can take a look at these files if you’d like, but you don’t need to
understand everything in them just yet. We will introduce the relevant parts of
the code in the tutorial as they come up.</p>
</section>
<section id="salsa20-preliminaries">
<h2>Salsa20 preliminaries<a class="headerlink" href="#salsa20-preliminaries" title="Link to this heading"></a></h2>
<p>Salsa20 is a stream cipher, which is a cryptographic technique for encrypting
and decrypting messages. A stream cipher encrypts a message by combining it
with a <em>keystream</em> to produce a ciphertext (the encrypted message). Moreover,
the same keystream can then be combined with the ciphertext to decrypt it back
into the original message.</p>
<p>The original author of Salsa20 has published a specification for Salsa20
<a class="reference external" href="https://cr.yp.to/snuffle/spec.pdf">here</a>. This is a great starting point for a
formal verification project, as this gives us a high-level description of
Salsa20’s behavior that will guide us in proving the functional correctness of
the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate. When we say that <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> is functionally correct, we
really mean “proven correct with respect to the Salsa20 specification”.</p>
<p>The first step in our project would be to port the Salsa20 spec to Cryptol
code, as we will need to use this code when writing SAW proofs. The process of
transcribing an English-language specification to executable Cryptol code is
interesting in its own right, but it is not the primary focus of this tutorial.
As such, we will save you some time by providing a pre-baked Cryptol
implementation of the Salsa20 spec
<a class="reference external" href="https://github.com/GaloisInc/saw-script/blob/master/doc/rust-tutorial/code/salsa20/Salsa20.cry">here</a>.
(This implementation is
<a class="reference external" href="https://github.com/GaloisInc/cryptol-specs/blob/1366ccf71db9dca58b16ff04ca7d960a4fe20e34/Primitive/Symmetric/Cipher/Stream/Salsa20.cry">adapted</a>
from the <a class="reference external" href="https://github.com/GaloisInc/cryptol-specs"><code class="docutils literal notranslate"><span class="pre">cryptol-specs</span></code></a> repo.)</p>
<p>Writing the Cryptol version of the spec is only half the battle, however. We
still have to prove that the Rust implementation in the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate adheres
to the behavior prescribed by the spec, which is where SAW enters the picture.
As we will see shortly, the code in <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> is not a direct port of the
pseudocode shown in the Salsa20 spec, as it is somewhat more low-level. SAW’s
role is to provide us assurance that the behavior of the low-level Rust code
and the high-level Cryptol code coincide.</p>
</section>
<section id="a-note-about-cryptographic-security">
<h2>A note about cryptographic security<a class="headerlink" href="#a-note-about-cryptographic-security" title="Link to this heading"></a></h2>
<p>As noted in the previous section, our goal is to prove that the behavior of
<code class="docutils literal notranslate"><span class="pre">salsa20</span></code> functions is functionally correct. This property should <em>not</em> be
confused with cryptographic security. While functional correctness is an
important aspect of cryptographic security, a full cryptographic security audit
would encompass additional properties such as whether the code runs in constant
time on modern CPUs. As such, the SAW proofs we will write would not constitute
a full security audit (and indeed, the <a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/README.md"><code class="docutils literal notranslate"><span class="pre">salsa20</span></code>
<code class="docutils literal notranslate"><span class="pre">README</span></code></a>
states that the crate has never received such an audit).</p>
</section>
<section id="an-overview-of-the-salsa20-code">
<h2>An overview of the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> code<a class="headerlink" href="#an-overview-of-the-salsa20-code" title="Link to this heading"></a></h2>
<p>Before diving into proofs, it will be helpful to have a basic understanding of
the functions and data types used in the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate. Most of the
interesting code lives in
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/src/core.rs"><code class="docutils literal notranslate"><span class="pre">src/core.rs</span></code></a>.
At the top of this file, we have the <code class="docutils literal notranslate"><span class="pre">Core</span></code> struct:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Core</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span><span class="w"> </span><span class="nc">Rounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Internal state of the core function</span>
<span class="w">    </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="p">],</span>

<span class="w">    </span><span class="sd">/// Number of rounds to perform</span>
<span class="w">    </span><span class="n">rounds</span><span class="p">:</span><span class="w"> </span><span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s walk through this:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">state</span></code> field is an array that is <code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> elements long, where
<code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> is a commonly used alias for <code class="docutils literal notranslate"><span class="pre">16</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/// Number of 32-bit words in the Salsa20 state</span>
<span class="k">const</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">rounds</span></code> field is of type <code class="docutils literal notranslate"><span class="pre">PhantomData&lt;R&gt;</span></code>. If you haven’t seen it
before,
<a class="reference external" href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"><code class="docutils literal notranslate"><span class="pre">PhantomData&lt;R&gt;</span></code></a>
is a special type that tells the Rust compiler to pretend as though the
struct is storing something of type <code class="docutils literal notranslate"><span class="pre">R</span></code>, even though a <code class="docutils literal notranslate"><span class="pre">PhantomData</span></code> value
will not take up any space at runtime.</p></li>
</ul>
<p>The reason that <code class="docutils literal notranslate"><span class="pre">Core</span></code> needs a <code class="docutils literal notranslate"><span class="pre">PhantomData&lt;R&gt;</span></code> field is because <code class="docutils literal notranslate"><span class="pre">R</span></code>
implements the <code class="docutils literal notranslate"><span class="pre">Rounds</span></code> trait:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">//! Numbers of rounds allowed to be used with a Salsa20 family stream cipher</span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Rounds</span><span class="p">:</span><span class="w"> </span><span class="nb">Copy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">COUNT</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A core operation in Salsa20 is hashing its input through a series of
<em>rounds</em>. The <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> constant indicates how many rounds should be performed.
The Salsa20 spec assumes 20 rounds:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/// 20-rounds (Salsa20/20)</span>
<span class="cp">#[derive(Copy, Clone)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">R20</span><span class="p">;</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Rounds</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">R20</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">COUNT</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, there are also reduced-round variants that perform 8 and 12 rounds,
respectively:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/// 8-rounds (Salsa20/8)</span>
<span class="cp">#[derive(Copy, Clone)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">R8</span><span class="p">;</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Rounds</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">R8</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">COUNT</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="sd">/// 12-rounds (Salsa20/12)</span>
<span class="cp">#[derive(Copy, Clone)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">R12</span><span class="p">;</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Rounds</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">R12</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">COUNT</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each number of rounds has a corresponding struct whose names begins with the
letter <code class="docutils literal notranslate"><span class="pre">R</span></code>. For instance, a <code class="docutils literal notranslate"><span class="pre">Core&lt;R20&gt;</span></code> value represents a 20-round Salsa20
cipher. Here is the typical use case for a <code class="docutils literal notranslate"><span class="pre">Core</span></code> value:</p>
<ul>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Core</span></code> value is created using the <code class="docutils literal notranslate"><span class="pre">new</span></code> function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Key</span><span class="p">,</span><span class="w"> </span><span class="n">iv</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Nonce</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
<p>We’ll omit the implementation for now. This function takes a secret <code class="docutils literal notranslate"><span class="pre">Key</span></code>
value and a unique <code class="docutils literal notranslate"><span class="pre">Nonce</span></code> value and uses them to produce the initial <code class="docutils literal notranslate"><span class="pre">state</span></code>
in the <code class="docutils literal notranslate"><span class="pre">Core</span></code> value.</p>
</li>
<li><p>After creating a <code class="docutils literal notranslate"><span class="pre">Core</span></code> value, the <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> and <code class="docutils literal notranslate"><span class="pre">rounds</span></code> functions are
used to produce the Salsa20 keystream:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">counter_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">rounds</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
<p>We’ll have more to say about these functions later.</p>
</li>
<li><p>The <em>pièce de résistance</em> is the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function. This takes a
newly created <code class="docutils literal notranslate"><span class="pre">Core</span></code> value, produces its keystream, and applies it to a
message to produce the <code class="docutils literal notranslate"><span class="pre">output</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">apply_keystream</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
</li>
</ul>
<p>Our ultimate goal is to verify the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function, which is the
Rust equivalent of the Salsa20 encryption function described in the spec.</p>
</section>
<section id="building-salsa20">
<h2>Building <code class="docutils literal notranslate"><span class="pre">salsa20</span></code><a class="headerlink" href="#building-salsa20" title="Link to this heading"></a></h2>
<p>The next step is to build the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate. Unlike the examples we have seen
up to this point, which have been self-contained Rust files, <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> is a
<code class="docutils literal notranslate"><span class="pre">cargo</span></code>-based project. As such, we will need to build it using <code class="docutils literal notranslate"><span class="pre">cargo</span> <span class="pre">saw-build</span></code>, an extension to the <code class="docutils literal notranslate"><span class="pre">cargo</span></code> package manager that integrates with
<code class="docutils literal notranslate"><span class="pre">mir-json</span></code>. Before you proceed, make sure that you have defined the
<code class="docutils literal notranslate"><span class="pre">SAW_RUST_LIBRARY_PATH</span></code> environment variable as described in <a class="reference internal" href="about-mir-json.html#saw-rust-lib-path-env-var"><span class="std std-ref">this
section</span></a>.</p>
<p>To build the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate, perform the following steps:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>code/salsa20/
<span class="gp">$ </span>cargo<span class="w"> </span>saw-build
</pre></div>
</div>
<p>Near the end of the build output, you will see a line that looks like this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">linking 9 mir files into &lt;...&gt;/saw-script/doc/rust-tutorial/code/salsa20/target/x86_64-unknown-linux-gnu/debug/deps/salsa20-dd0d90f28492b9cb.linked-mir.json</span>
</pre></div>
</div>
<p>This is the location of the MIR JSON file that we will need to provide to SAW.
(When we tried it, the hash in the file name was <code class="docutils literal notranslate"><span class="pre">dd0d90f28492b9cb</span></code>, but it
could very well be different on your machine.) Due to how <code class="docutils literal notranslate"><span class="pre">cargo</span></code> works, the
location of this file is in a rather verbose, hard-to-remember location. For
this reason, we recommend copying this file to a different path, e.g.,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>&lt;...&gt;/saw-script/doc/rust-tutorial/code/salsa20/target/x86_64-unknown-linux-gnu/debug/deps/salsa20-dd0d90f28492b9cb.linked-mir.json<span class="w"> </span>code/salsa20/salsa20.linked-mir.json
</pre></div>
</div>
<p>As a safeguard, we have also checked in a compressed version of this MIR JSON
file as
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-verification-with-saw/code/salsa20/salsa20.linked-mir.json.gz"><code class="docutils literal notranslate"><span class="pre">code/salsa20/salsa/salsa20.linked-mir.json.gz</span></code></a>.
In a pinch, you can extract this archive to obtain a copy of the MIR JSON file,
which is approximately 4.6 megabytes when uncompressed.</p>
</section>
<section id="getting-started-with-saw">
<h2>Getting started with SAW<a class="headerlink" href="#getting-started-with-saw" title="Link to this heading"></a></h2>
<p>Now that we’ve built the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate, it’s time to start writing some
proofs! Let’s start a new <code class="docutils literal notranslate"><span class="pre">code/salsa20/salsa20.saw</span></code> file as fill it in with
the usual preamble:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">enable_experimental</span><span class="p">;</span>

<span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_load_module</span><span class="w"> </span><span class="s2">&quot;salsa20.linked-mir.json&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>We are also going to need to make use of the Cryptol implementation of the
Salsa20 spec, which is defined in
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/Salsa20.cry"><code class="docutils literal notranslate"><span class="pre">code/salsa20/Salsa20.cry</span></code></a>.
SAW allows you to import standalone Cryptol <code class="docutils literal notranslate"><span class="pre">.cry</span></code> files by using the <code class="docutils literal notranslate"><span class="pre">import</span></code>
command:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="s2">&quot;Salsa20.cry&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>As an aside, note that we have also checked in a
<a class="reference external" href="https://github.com/GaloisInc/saw-script/tree/master/doc/rust-tutorial/code/salsa20/salsa20-reference.saw"><code class="docutils literal notranslate"><span class="pre">code/salsa20/salsa20-reference.saw</span></code></a>,
which contains a complete SAW file. We encourage you <em>not</em> to look at this file
for now, since following along with the tutorial is meant to illustrate the
“a-ha moments” that one would have in the process of writing the proofs. In you
become stuck while following along and absolutely need a hint, however, then
this file can help you become unstuck.</p>
</section>
<section id="verifying-our-first-salsa20-function">
<h2>Verifying our first <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> function<a class="headerlink" href="#verifying-our-first-salsa20-function" title="Link to this heading"></a></h2>
<p>Now it’s time to start verifying some <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> code. But where do we start?
It’s tempting to start with <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>, which is our end goal. This is
likely going to be counter-productive, however, as <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> is a
large function with several moving parts. Throwing SAW at it immediately is
likely to cause it to spin forever without making any discernible progress.</p>
<p>For this reason, we will instead take the approach of working from the
bottom-up. That is, we will first verify the functions that <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>
transitively invokes, and then leverage compositional verification to verify a
proof of <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> using overrides. This approach naturally breaks up
the problem into smaller pieces that are easier to understand in isolation.</p>
<p>If we look at the implementation of <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>, we see that it invokes
the <code class="docutils literal notranslate"><span class="pre">round</span></code> function, which in turn invokes the <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">quarter_round</span><span class="p">(</span>
<span class="w">    </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">d</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="p">],</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">t</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>

<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">d</span><span class="p">]);</span>
<span class="w">    </span><span class="n">state</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">rotate_left</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>

<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
<span class="w">    </span><span class="n">state</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">rotate_left</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>

<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">[</span><span class="n">c</span><span class="p">].</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
<span class="w">    </span><span class="n">state</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">rotate_left</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>

<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">c</span><span class="p">]);</span>
<span class="w">    </span><span class="n">state</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">rotate_left</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> is built on top of the standard library functions
<a class="reference external" href="https://doc.rust-lang.org/std/primitive.usize.html#method.wrapping_add"><code class="docutils literal notranslate"><span class="pre">wrapping_add</span></code></a>
and
<a class="reference external" href="https://doc.rust-lang.org/std/primitive.usize.html#method.rotate_left"><code class="docutils literal notranslate"><span class="pre">rotate_left</span></code></a>,
so we have finally reached the bottom of the call stack. This makes
<code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> a good choice for the first function to verify.</p>
<p>The implementation of the Rust <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> function is quite similar to the
Cryptol <code class="docutils literal notranslate"><span class="pre">quarterround</span></code> function in <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">quarterround</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">quarterround</span><span class="w"> </span><span class="p">[</span><span class="n">y0</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="p">,</span><span class="w"> </span><span class="n">y3</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">z0</span><span class="p">,</span><span class="w"> </span><span class="n">z1</span><span class="p">,</span><span class="w"> </span><span class="n">z2</span><span class="p">,</span><span class="w"> </span><span class="n">z3</span><span class="p">]</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">z1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="n">y0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mh">0x7</span><span class="p">)</span>
<span class="w">    </span><span class="n">z2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="n">z1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mh">0x9</span><span class="p">)</span>
<span class="w">    </span><span class="n">z3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y3</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="n">z2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mh">0xd</span><span class="p">)</span>
<span class="w">    </span><span class="n">z0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">y0</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">((</span><span class="n">z3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mh">0x12</span><span class="p">)</span>
</pre></div>
</div>
<p>The Cryptol <code class="docutils literal notranslate"><span class="pre">quarterround</span></code> function doesn’t have anything like the <code class="docutils literal notranslate"><span class="pre">state</span></code>
argument in the Rust <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> function, but let’s not fret about that
too much yet. Our SAW spec is going to involve <code class="docutils literal notranslate"><span class="pre">quarterround</span></code> <em>somehow</em>—we just
have to figure out how to make it fit.</p>
<p>Let’s start filling out the SAW spec for <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">quarter_round_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
<p>We are going to need some fresh variables for the <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, and <code class="docutils literal notranslate"><span class="pre">d</span></code>
arguments:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;c&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;d&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
</pre></div>
</div>
<p>We will also need to allocate a reference for the <code class="docutils literal notranslate"><span class="pre">state</span></code> argument. The
reference’s underlying type is <code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> (<code class="docutils literal notranslate"><span class="pre">16</span></code>) elements long:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">state_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">state_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">state_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">state_arr</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, we will need to pass these arguments to the function:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">a</span>
<span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">b</span>
<span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">c</span>
<span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">d</span>
<span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="n">state_ref</span>
<span class="w">                   </span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>With that, we have a spec for <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code>! It’s not very interesting just
yet, as we don’t specify what <code class="docutils literal notranslate"><span class="pre">state_ref</span></code> should point to after the function
has returned. But that’s fine for now. When developing a SAW proof, it can be
helpful to first write out the “skeleton” of a function spec that only contains
the call to <code class="docutils literal notranslate"><span class="pre">mir_execute_func</span></code>, without any additional preconditions or
postconditions. We can add those later after ensuring that the skeleton works
as expected.</p>
<p>Let’s check our progress thus far by running this through SAW:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>saw<span class="w"> </span>salsa20.saw
<span class="go">...</span>
<span class="go">[23:16:05.080] Type errors:</span>
<span class="go">  salsa20.saw:12:39-12:68: Unbound variable: &quot;STATE_WORDS&quot; (salsa20.saw:12:49-12:60)</span>
<span class="go">Note that some built-in commands are available only after running</span>
<span class="go">either `enable_deprecated` or `enable_experimental`.</span>

<span class="go">  salsa20/salsa20.saw:11:31-11:60: Unbound variable: &quot;STATE_WORDS&quot; (salsa20.saw:11:41-11:52)</span>
<span class="go">Note that some built-in commands are available only after running</span>
<span class="go">either `enable_deprecated` or `enable_experimental`.</span>
</pre></div>
</div>
<p>We’ve already run into some type errors. Not too surprising, considering this
was our first attempt. The error message contains that <code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> is
unbound. This makes sense if you think about it, as <code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> is defined in
the Rust code, but not in the SAW file itself. Let’s fix that by adding this
line to <code class="docutils literal notranslate"><span class="pre">salsa20.saw</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</pre></div>
</div>
<p>That change fixes the type errors in <code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code>. Hooray! Let’s press
on.</p>
<p>Next, we need to add a call to <code class="docutils literal notranslate"><span class="pre">mir_verify</span></code>. In order to do this, we need to
know what the full identifier for the <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> function is. Because it
is defined in the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate and in the <code class="docutils literal notranslate"><span class="pre">core.rs</span></code> file, so we would expect
the identifier to be named <code class="docutils literal notranslate"><span class="pre">salsa20::core::quarter_round</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">quarter_round_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core::quarter_round&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">quarter_round_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>However, SAW disagrees:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[00:22:56.970] Stack trace:</span>
<span class="go">&quot;mir_verify&quot; (salsa20.saw:26:3-26:13)</span>
<span class="go">Couldn&#39;t find MIR function named: salsa20::core::quarter_round</span>
</pre></div>
</div>
<p>Ugh. This is a consequence of how <code class="docutils literal notranslate"><span class="pre">mir-json</span></code> disambiguates identifiers. Because
there is a separate <code class="docutils literal notranslate"><span class="pre">core</span></code> crate in the Rust standard libraries, <code class="docutils literal notranslate"><span class="pre">mir-json</span></code>
uses “<code class="docutils literal notranslate"><span class="pre">core#1</span></code>”, a distinct name, to refer to the <code class="docutils literal notranslate"><span class="pre">core.rs</span></code> file. You can see
this for yourself by digging around in the MIR JSON file, if you’d like. (In a
future version of SAW, one will be able to <a class="reference external" href="https://github.com/GaloisInc/saw-script/issues/1980">look this name
up</a> more easily.)</p>
<p>Once we change the identifier:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">quarter_round_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::quarter_round&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">quarter_round_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>We can run SAW once more. This time, SAW complains about a different thing:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[01:00:19.697] Verifying salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[01:00:19.714] Simulating salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[01:00:19.717] Checking proof obligations salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[01:00:19.739] Subgoal failed: salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>index<span class="w"> </span>out<span class="w"> </span>of<span class="w"> </span>bounds:<span class="w"> </span>the<span class="w"> </span>length<span class="w"> </span>is<span class="w"> </span>move<span class="w"> </span>_10<span class="w"> </span>but<span class="w"> </span>the<span class="w"> </span>index<span class="w"> </span>is<span class="w"> </span>_9
<span class="go">[01:00:19.739] SolverStats {solverStatsSolvers = fromList [&quot;SBV-&gt;Z3&quot;], solverStatsGoalSize = 53}</span>
<span class="go">[01:00:19.739] ----------Counterexample----------</span>
<span class="go">[01:00:19.739]   a: 2147483648</span>
</pre></div>
</div>
<p>Here, SAW complains that we have an <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">out</span> <span class="pre">of</span> <span class="pre">bounds</span></code>. Recall that we are
indexing into the <code class="docutils literal notranslate"><span class="pre">state</span></code> array, which is of length 16, using the
<code class="docutils literal notranslate"><span class="pre">a</span></code>/<code class="docutils literal notranslate"><span class="pre">b</span></code>/<code class="docutils literal notranslate"><span class="pre">c</span></code>/<code class="docutils literal notranslate"><span class="pre">d</span></code> arguments. Each of these arguments are of type <code class="docutils literal notranslate"><span class="pre">usize</span></code>, and
because we are declaring these to be symbolic, it is quite possible for each
argument to be 16 or greater, which would cause the index into <code class="docutils literal notranslate"><span class="pre">state</span></code> to be
out of bounds.</p>
<p>In practice, however, the only values of <code class="docutils literal notranslate"><span class="pre">a</span></code>/<code class="docutils literal notranslate"><span class="pre">b</span></code>/<code class="docutils literal notranslate"><span class="pre">c</span></code>/<code class="docutils literal notranslate"><span class="pre">d</span></code> that we will use are
less than 16. We can express this fact as a precondition:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_precond</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">`</span><span class="kt">STATE</span><span class="nf">_</span><span class="kt">WORDS</span><span class="w"> </span><span class="o">/</span><span class="nf">\</span>
<span class="w">                 </span><span class="nf">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">`</span><span class="kt">STATE</span><span class="nf">_</span><span class="kt">WORDS</span><span class="w"> </span><span class="o">/</span><span class="nf">\</span>
<span class="w">                 </span><span class="nf">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">`</span><span class="kt">STATE</span><span class="nf">_</span><span class="kt">WORDS</span><span class="w"> </span><span class="o">/</span><span class="nf">\</span>
<span class="w">                 </span><span class="nf">d</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">`</span><span class="kt">STATE</span><span class="nf">_</span><span class="kt">WORDS</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
</pre></div>
</div>
<p>That is enough to finally get SAW to verify this very stripped-down version of
<code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code>. Some good progress! But we aren’t done yet, as we don’t
yet say what happens to the value that <code class="docutils literal notranslate"><span class="pre">state</span></code> points to after the function
returns. This will be a requirement if we want to use <code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code> in
compositional verification (and we do want this), so we should address this
shortly.</p>
<p>Recall that unlike the Rust <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> function, the Cryptol
<code class="docutils literal notranslate"><span class="pre">quarterround</span></code> function doesn’t have a <code class="docutils literal notranslate"><span class="pre">state</span></code> argument. This is because the
Rust function does slightly more than what the Cryptol function does. The Rust
function will look up elements of the <code class="docutils literal notranslate"><span class="pre">state</span></code> array, use them to perform the
computations that the Cryptol function does, and then insert the new values
back into the <code class="docutils literal notranslate"><span class="pre">state</span></code> array. To put it another way: the Rust function can be
thought of as a wrapper around the Cryptol function that also performs an
in-place bulk update of the <code class="docutils literal notranslate"><span class="pre">state</span></code> array.</p>
<p>In Cryptol, one can look up elements of an array using the <code class="docutils literal notranslate"><span class="pre">(&#64;&#64;)</span></code> function,
and one can perform in-place array updates using the <code class="docutils literal notranslate"><span class="pre">updates</span></code> function.
This translates into a postcondition that looks like this:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">[</span><span class="nf">a</span><span class="p">,</span><span class="w"> </span><span class="nf">b</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">,</span><span class="w"> </span><span class="nf">d</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">state_arr&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">updates</span><span class="w"> </span><span class="nf">state_arr</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="p">(</span><span class="nf">quarterround</span><span class="w"> </span><span class="p">(</span><span class="nf">state_arr</span><span class="w"> </span><span class="o">@@</span><span class="w"> </span><span class="nf">indices</span><span class="p">))</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">state_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">state_arr&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>What does SAW think of this? Someone surprisingly, SAW finds a counterexample:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[01:43:30.065] Verifying salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[01:43:30.078] Simulating salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[01:43:30.084] Checking proof obligations salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[01:43:30.801] Subgoal failed: salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>Literal<span class="w"> </span>equality<span class="w"> </span>postcondition

<span class="go">[01:43:30.801] SolverStats {solverStatsSolvers = fromList [&quot;SBV-&gt;Z3&quot;], solverStatsGoalSize = 1999}</span>
<span class="go">[01:43:30.802] ----------Counterexample----------</span>
<span class="go">[01:43:30.802]   a: 13</span>
<span class="go">[01:43:30.802]   b: 3</span>
<span class="go">[01:43:30.802]   c: 0</span>
<span class="go">[01:43:30.802]   d: 0</span>
<span class="go">[01:43:30.802]   state: [3788509705, 0, 0, 3223325776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1074561051, 0, 0]</span>
</pre></div>
</div>
<p>Note that in this counterexample, the values of <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> are the same. In
the Rust version of the function, each element in <code class="docutils literal notranslate"><span class="pre">state</span></code> is updated
sequentially, so if two of the array indices are the same, then the value that
was updated with the first index will later be overwritten by the value at the
later index. In the Cryptol version of the function, however, all of the
positions in the array are updated simultaneously. This implicitly assumes that
all of the array indices are disjoint from each other, an assumption that we
are not encoding into <code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code>’s preconditions.</p>
<p>At this point, it can be helpful to observe <em>how</em> the <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> function
is used in practice. The call sites are found in the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">            </span><span class="c1">// column rounds</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// diagonal rounds</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we can see that the values of <code class="docutils literal notranslate"><span class="pre">a</span></code>/<code class="docutils literal notranslate"><span class="pre">b</span></code>/<code class="docutils literal notranslate"><span class="pre">c</span></code>/<code class="docutils literal notranslate"><span class="pre">d</span></code> will only ever be chosen
from a set of eight possible options. We can take advantage of this fact to
constrain the possible set of values for <code class="docutils literal notranslate"><span class="pre">a</span></code>/<code class="docutils literal notranslate"><span class="pre">b</span></code>/<code class="docutils literal notranslate"><span class="pre">c</span></code>/<code class="docutils literal notranslate"><span class="pre">d</span></code>. The latest iteration
of the <code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code> is now:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">quarter_round_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;c&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;d&quot;</span><span class="w"> </span><span class="n">mir_usize</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">[</span><span class="nf">a</span><span class="p">,</span><span class="w"> </span><span class="nf">b</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">,</span><span class="w"> </span><span class="nf">d</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="n">mir_precond</span><span class="w"> </span><span class="l">{{</span><span class="w">    </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span>
<span class="w">                 </span><span class="nf">\</span><span class="o">/</span><span class="w"> </span><span class="nf">indices</span><span class="w"> </span><span class="ow">==</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">]</span>
<span class="w">              </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="n">state_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">state_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">state_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">state_arr</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">indices</span></code> value is constrained (via a precondition) to be one of the set
of values that is chosen in the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function. (Note that <code class="docutils literal notranslate"><span class="pre">\/</span></code> is the
logical-or function in Cryptol.) Each of these are concrete values that are
less than <code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> (<code class="docutils literal notranslate"><span class="pre">16</span></code>), so we no longer need a precondition stating
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">`STATE_WORDS</span> <span class="pre">/\</span> <span class="pre">...</span></code>.</p></li>
<li><p>Because we now reference <code class="docutils literal notranslate"><span class="pre">indices</span></code> in the preconditions, we have moved its
definition up. (Previously, it was defined in the postconditions section.)</p></li>
</ul>
<p>With this in place, will SAW verify <code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code> now?</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[02:14:02.037] Verifying salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[02:14:02.051] Simulating salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[02:14:02.057] Checking proof obligations salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
<span class="gp">[02:14:18.616] Proof succeeded! salsa20/10e438b3::core#</span><span class="m">1</span><span class="o">[</span><span class="m">0</span><span class="o">]</span>::quarter_round<span class="o">[</span><span class="m">0</span><span class="o">]</span>
</pre></div>
</div>
<p>At long last, it succeeds. Hooray! SAW does have to think for a while, however,
as this proof takes about 17 seconds to complete. It would be unfortunate to
have to wait 17 seconds on every subsequent invocation of SAW, and since we
still have other functions to verify, this is a very real possibility. For this
reason, it can be helpful to temporarily turn this use of <code class="docutils literal notranslate"><span class="pre">mir_verify</span></code> into a
<code class="docutils literal notranslate"><span class="pre">mir_unsafe_assume_spec</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">quarter_round_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_unsafe_assume_spec</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::quarter_round&quot;</span><span class="w"> </span><span class="n">quarter_round_spec</span><span class="p">;</span>
<span class="w">  </span><span class="c c-Singleline">// Temporarily commented out to save time:</span>
<span class="w">  </span><span class="c c-Singleline">//</span>
<span class="w">  </span><span class="c c-Singleline">// mir_verify m &quot;salsa20::core#1::quarter_round&quot; [] false quarter_round_spec z3;</span>
</pre></div>
</div>
<p>Once we are done with the entire proof, we can come back and remove this use of
<code class="docutils literal notranslate"><span class="pre">mir_unsafe_assume_spec</span></code>, as we’re only using it as a time-saving measure.</p>
</section>
<section id="verifying-the-rounds-function">
<h2>Verifying the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function<a class="headerlink" href="#verifying-the-rounds-function" title="Link to this heading"></a></h2>
<p>Now that we’ve warmed up, let’s try verifying the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function, which is
where <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code> is invoked. Here is the full definition of <code class="docutils literal notranslate"><span class="pre">rounds</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">rounds</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">R</span><span class="p">::</span><span class="n">COUNT</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// column rounds</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// diagonal rounds</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">            </span><span class="n">quarter_round</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="o">*</span><span class="n">s0</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>First, <code class="docutils literal notranslate"><span class="pre">rounds</span></code> performs <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> rounds on the <code class="docutils literal notranslate"><span class="pre">state</span></code> argument. After this, it
takes each element of <code class="docutils literal notranslate"><span class="pre">self.state</span></code> and adds it to the corresponding element in
<code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<p>Linking back at the Salsa20 spec, we can see that the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function is
<em>almost</em> an implementation of the Salsa20(x) hash function. The only notable
difference is that while the Salsa20(x) hash function converts the results to
little-endian form, the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function does not. <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code> implements
this part of the spec here:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kt">Salsa20</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">Salsa20</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">littleendian_state_inverse</span><span class="w"> </span><span class="p">(</span><span class="kt">Salsa20_rounds</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">xw</span><span class="w"> </span><span class="n">xw</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">xw</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">littleendian_state</span><span class="w"> </span><span class="n">xs</span>

<span class="kt">Salsa20_rounds</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span>
<span class="kt">Salsa20_rounds</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">xw</span><span class="w"> </span><span class="n">xw&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">xw</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">zs</span><span class="o">@</span><span class="p">(</span><span class="n">count</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">zs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">xw&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">doubleround</span><span class="w"> </span><span class="n">zi</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">zi</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">zs</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">Salsa20</span></code> is the hash function, and <code class="docutils literal notranslate"><span class="pre">Salsa20_rounds</span></code> is the part of the
hash function that excludes the little-endian conversions. In other words,
<code class="docutils literal notranslate"><span class="pre">Salsa20_rounds</span></code> precisely captures the behavior of the Rust <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function.</p>
<p>One aspect of the <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function that will make verifying it slightly
different from verifying <code class="docutils literal notranslate"><span class="pre">quarter_rounds</span></code> is that <code class="docutils literal notranslate"><span class="pre">rounds</span></code> is defined in an
<code class="docutils literal notranslate"><span class="pre">impl</span></code> block for the <code class="docutils literal notranslate"><span class="pre">Core</span></code> struct. This means that the <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">self</span></code> argument in
<code class="docutils literal notranslate"><span class="pre">rounds</span></code> has the type <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">Core&lt;R&gt;</span></code>. As such, we will have to look up the
<code class="docutils literal notranslate"><span class="pre">Core</span></code> ADT in SAW using <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>.</p>
<p>This raises another question, however: when looking up <code class="docutils literal notranslate"><span class="pre">Core&lt;R&gt;</span></code>, what type
should we use to instantiate <code class="docutils literal notranslate"><span class="pre">R</span></code>? As noted above, our choices are <code class="docutils literal notranslate"><span class="pre">R8</span></code>, <code class="docutils literal notranslate"><span class="pre">R12</span></code>,
and <code class="docutils literal notranslate"><span class="pre">R20</span></code>, depending on how many rounds you want. For now, we’ll simply
hard-code it so that <code class="docutils literal notranslate"><span class="pre">R</span></code> is instantiated to be <code class="docutils literal notranslate"><span class="pre">R8</span></code>, but we will generalize
this a bit later.</p>
<p>Alright, enough chatter—time to start writing a proof. First, let’s look up the
<code class="docutils literal notranslate"><span class="pre">R8</span></code> ADT. This is defined in the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate in the <code class="docutils literal notranslate"><span class="pre">rounds.rs</span></code> file, so
its identifier becomes <code class="docutils literal notranslate"><span class="pre">salsa20::rounds::R8</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::rounds::R8&quot;</span><span class="w"> </span><span class="p">[];</span>
</pre></div>
</div>
<p>Next, we need to look up the <code class="docutils literal notranslate"><span class="pre">PhantomData&lt;R8&gt;</span></code> ADT, which is used in the
<code class="docutils literal notranslate"><span class="pre">rounds</span></code> field of the <code class="docutils literal notranslate"><span class="pre">Core&lt;R8&gt;</span></code> struct. This is defined in <code class="docutils literal notranslate"><span class="pre">core::marker</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;core::marker::PhantomData&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">r_adt</span><span class="p">];</span>
</pre></div>
</div>
<p>Finally, we must look up <code class="docutils literal notranslate"><span class="pre">Core&lt;R8&gt;</span></code> itself. Like <code class="docutils literal notranslate"><span class="pre">quarter_round</span></code>, the <code class="docutils literal notranslate"><span class="pre">Core</span></code>
struct is defined in <code class="docutils literal notranslate"><span class="pre">salsa20::core#1</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::Core&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">r_adt</span><span class="p">];</span>
</pre></div>
</div>
<p>Now that we have the necessary prerequisites, let’s write a spec for the
<code class="docutils literal notranslate"><span class="pre">rounds</span></code> function. First, we need to allocate a reference for the <code class="docutils literal notranslate"><span class="pre">self</span></code>
argument:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">rounds_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">self_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">core_adt</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we need to create symbolic values for the fields of the <code class="docutils literal notranslate"><span class="pre">Core</span></code> struct,
which <code class="docutils literal notranslate"><span class="pre">self_ref</span></code> will point to. The <code class="docutils literal notranslate"><span class="pre">self.state</span></code> field will be a fresh array,
and the <code class="docutils literal notranslate"><span class="pre">self.rounds</span></code> field will be a simple, empty struct value:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">self_state</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;self_state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="p">[];</span>
</pre></div>
</div>
<p>Finally, putting all of the <code class="docutils literal notranslate"><span class="pre">self</span></code> values together:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, we need a <code class="docutils literal notranslate"><span class="pre">state</span></code> argument (not to be confused with the <code class="docutils literal notranslate"><span class="pre">self.state</span></code>
field in <code class="docutils literal notranslate"><span class="pre">Core</span></code>). This is handled much the same as it was in
<code class="docutils literal notranslate"><span class="pre">quarter_round_spec</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">state_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">state_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">state_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">state_arr</span><span class="p">);</span>
</pre></div>
</div>
<p>Lastly, we cap it off with a call to <code class="docutils literal notranslate"><span class="pre">mir_execute_func</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">self_ref</span><span class="p">,</span><span class="w"> </span><span class="n">state_ref</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(Again, we’re missing some postconditions describing what <code class="docutils literal notranslate"><span class="pre">self_ref</span></code> and
<code class="docutils literal notranslate"><span class="pre">state_ref</span></code> point to after the function returns, but we’ll return to that in a
bit.)</p>
<p>If we run SAW at this point, we see that everything in <code class="docutils literal notranslate"><span class="pre">rounds_spec</span></code>
typechecks, so we’re off to a good start. Let’s keep going and add a
<code class="docutils literal notranslate"><span class="pre">mir_verify</span></code> call.</p>
<p>Here, we are faced with an interesting question: what is the identifier for
<code class="docutils literal notranslate"><span class="pre">rounds::&lt;R8&gt;</span></code>? The <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function is defined using generics, so we can’t
verify it directly—we must instead verify a particular instantiation of
<code class="docutils literal notranslate"><span class="pre">rounds</span></code>. At present, there isn’t a good way to look up what the identifiers
for instantiations of generic functions are (there <a class="reference external" href="https://github.com/GaloisInc/saw-script/issues/1980">will be in the
future</a>), but it turns out
that the identifier for <code class="docutils literal notranslate"><span class="pre">rounds::&lt;R8&gt;</span></code> is this:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">rounds_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::rounds::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">quarter_round_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">rounds_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that we are using <code class="docutils literal notranslate"><span class="pre">quarter_round_ov</span></code> as a compositional override. Once
again, SAW is happy with our work thus far:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[03:12:35.990] Proof succeeded! salsa20/10e438b3::core#1[0]::{impl#</span><span class="m">0</span><span class="o">}[</span><span class="m">0</span><span class="o">]</span>::rounds<span class="o">[</span><span class="m">0</span><span class="o">]</span>::_inst6e4a2d7250998ef7<span class="o">[</span><span class="m">0</span><span class="o">]</span>
</pre></div>
</div>
<p>Nice. Now let’s go back and fill in the missing postconditions in
<code class="docutils literal notranslate"><span class="pre">rounds_spec</span></code>. In particular, we must declare what happens to both <code class="docutils literal notranslate"><span class="pre">self_ref</span></code>
and <code class="docutils literal notranslate"><span class="pre">state_ref</span></code>. A closer examination of the code in the Rust <code class="docutils literal notranslate"><span class="pre">rounds</span></code> function
reveals that the <code class="docutils literal notranslate"><span class="pre">self</span></code> argument is never modified at all, so that part is
easy:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">state</span></code> argument, on the other hand, is modified in-place. This time, our
job is made easier by the fact that <code class="docutils literal notranslate"><span class="pre">Salsa20_rounds</span></code> implements <em>exactly</em> what
we need. Because we are instantiating <code class="docutils literal notranslate"><span class="pre">rounds</span></code> at type <code class="docutils literal notranslate"><span class="pre">R8</span></code>, we must explicitly
state that we are using 8 rounds:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">state_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_rounds</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nf">self_state</span><span class="w"> </span><span class="nf">state_arr</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
</pre></div>
</div>
<p>Once again, SAW is happy with our work. We’re on a roll!</p>
<p>Now let’s address the fact that we are hard-coding everything to <code class="docutils literal notranslate"><span class="pre">R8</span></code>, which is
somewhat uncomfortable. We can make things better by allowing the user to
specify the number of rounds. The first thing that we will need to change is
the <code class="docutils literal notranslate"><span class="pre">r_adt</span></code> definition, which is response for looking up <code class="docutils literal notranslate"><span class="pre">R8</span></code>. We want to turn
this into a function that, depending on the user input, will look up <code class="docutils literal notranslate"><span class="pre">R8</span></code>,
<code class="docutils literal notranslate"><span class="pre">R12</span></code>, or <code class="docutils literal notranslate"><span class="pre">R20</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="n">num_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">str_concat</span><span class="w"> </span><span class="s2">&quot;salsa20::rounds::R&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">show</span><span class="w"> </span><span class="n">num_rounds</span><span class="p">))</span><span class="w"> </span><span class="p">[];</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">str_concat</span></code> is a SAW function for concatenating strings together:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sawscript&gt; :type str_concat</span>
<span class="go">String -&gt; String -&gt; String</span>
</pre></div>
</div>
<p>We also want to parameterize <code class="docutils literal notranslate"><span class="pre">phantom_data_adt</span></code> and <code class="docutils literal notranslate"><span class="pre">core_adt</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;core::marker::PhantomData&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">r</span><span class="p">];</span>
<span class="kr">let</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::Core&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">r</span><span class="p">];</span>
</pre></div>
</div>
<p>Next, we need to parameterize <code class="docutils literal notranslate"><span class="pre">rounds_spec</span></code> by the number of rounds. This will
require changes in both the preconditions and postconditions. On the
preconditions side, we must pass the number of rounds to the relevant
functions:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">rounds_spec</span><span class="w"> </span><span class="n">num_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="n">num_rounds</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">  </span><span class="n">self_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="p">);</span>
<span class="w">  </span><span class="n">self_state</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;self_state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="p">(</span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
</pre></div>
</div>
<p>And on the postconditions side, we must pass the number of rounds to the
Cryptol <code class="docutils literal notranslate"><span class="pre">Salsa20_rounds</span></code> function:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">state_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_rounds</span><span class="w"> </span><span class="p">`</span><span class="nf">num_rounds</span><span class="w"> </span><span class="nf">self_state</span><span class="w"> </span><span class="nf">state_arr</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, we must adjust the call to <code class="docutils literal notranslate"><span class="pre">rounds_spec</span></code> in the context of
<code class="docutils literal notranslate"><span class="pre">mir_verify</span></code> so that we pick <code class="docutils literal notranslate"><span class="pre">8</span></code> as the number of rounds:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">rounds_8_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::rounds::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">quarter_round_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">rounds_spec</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>SAW is happy with this generalization. To demonstrate that we have generalized
things correctly, we can also verify the same function at <code class="docutils literal notranslate"><span class="pre">R20</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">R8</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">rounds_20_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::rounds::_instfa33e77d840484a0&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">quarter_round_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">rounds_spec</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>The only things that we had to change were the identifier and the argument to
<code class="docutils literal notranslate"><span class="pre">rounds_spec</span></code>. Not bad!</p>
</section>
<section id="verifying-the-counter-setup-function">
<h2>Verifying the <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> function<a class="headerlink" href="#verifying-the-counter-setup-function" title="Link to this heading"></a></h2>
<p>We’re very nearly at the point of being able to verify <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>.
Before we do, however, there is one more function that <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> calls,
which we ought to verify first: <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code>. Thankfully, the implementation
of <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> is short and sweet:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">counter_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff_ffff</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">counter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff_ffff</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>This updates the elements of the <code class="docutils literal notranslate"><span class="pre">state</span></code> array at indices <code class="docutils literal notranslate"><span class="pre">8</span></code> and <code class="docutils literal notranslate"><span class="pre">9</span></code> with the
lower 32 bits and the upper 32 bits of the <code class="docutils literal notranslate"><span class="pre">counter</span></code> argument, respecitvely.
At a first glance, there doesn’t appear to be any function in <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code>
that directly corresponds to what <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> does. This is a bit of a
head-scratcher, but the answer to this mystery will become more apparent as we
get further along in the proof.</p>
<p>For now, we should take matters into our own hands and write our own Cryptol
spec for <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code>. To do this, we will create a new Cryptol file named
<code class="docutils literal notranslate"><span class="pre">Salsa20Extras.cry</span></code>, which imports from <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span><span class="w"> </span><span class="nn">Salsa20Extras</span><span class="w"> </span><span class="kr">where</span>

<span class="kr">import</span><span class="w"> </span><span class="nn">Salsa20</span>
</pre></div>
</div>
<p>The Cryptol implementation of <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> will need arrays of length
<code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code>, so we shall define <code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> first:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">STATE_WORDS</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">16</span>
</pre></div>
</div>
<p>Note that we preceded this definition with the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword. In Cryptol,
sequence lengths are encoded at the type level, so if we want to use
<code class="docutils literal notranslate"><span class="pre">STATE_WORDS</span></code> at the type level, we must declare it as a <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<p>Finally, we can write a Cryptol version of <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> using our old friend
<code class="docutils literal notranslate"><span class="pre">updates</span></code> to perform a bulk sequence update:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">counter_setup</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="kt">STATE_WORDS</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">STATE_WORDS</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">counter_setup</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="n">updates</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">drop</span><span class="w"> </span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">counter</span></code> is a 64-bit word, but the elements of the <code class="docutils literal notranslate"><span class="pre">state</span></code> sequence
are 32-bit words. As a result, we have to explicitly truncate <code class="docutils literal notranslate"><span class="pre">counter</span></code> and
<code class="docutils literal notranslate"><span class="pre">counter</span> <span class="pre">&gt;&gt;</span> <span class="pre">32</span></code> to 32-bit words by using the <code class="docutils literal notranslate"><span class="pre">drop</span></code> function, which drops the
first 32 bits from each word.</p>
<p>Returning to <code class="docutils literal notranslate"><span class="pre">salsa20.saw</span></code>, we must now make use of our new Cryptol file by
<code class="docutils literal notranslate"><span class="pre">import</span></code>ing it at the top:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span><span class="w"> </span><span class="s2">&quot;Salsa20Extras.cry&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> Cryptol implementation in scope, we can now write
a spec for the Rust <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> function. There’s not too much to remark
on here, as the spec proves relatively straightforward to write:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">counter_setup_spec</span><span class="w"> </span><span class="n">num_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="n">num_rounds</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">  </span><span class="n">self_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="p">);</span>
<span class="w">  </span><span class="n">self_state</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;self_state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="p">(</span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val</span><span class="p">;</span>

<span class="w">  </span><span class="n">counter</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;counter&quot;</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">self_ref</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">counter</span><span class="p">];</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">counter_setup</span><span class="w"> </span><span class="nf">self_state</span><span class="w"> </span><span class="nf">counter</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val&#39;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can now verify <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> against <code class="docutils literal notranslate"><span class="pre">counter_setup_spec</span></code> at lengths <code class="docutils literal notranslate"><span class="pre">8</span></code>
and <code class="docutils literal notranslate"><span class="pre">20</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">counter_setup_8_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::counter_setup::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">counter_setup_spec</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="n">counter_setup_20_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::counter_setup::_instfa33e77d840484a0&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">counter_setup_spec</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>That wasn’t so bad. It’s a bit unsatisfying that we had to resort to writing a
Cryptol function not found in <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code>, but go along with this for now—it
will become apparent later why this needed to be done.</p>
</section>
<section id="verifying-the-apply-keystream-function-first-attempt">
<h2>Verifying the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function (first attempt)<a class="headerlink" href="#verifying-the-apply-keystream-function-first-attempt" title="Link to this heading"></a></h2>
<p>It’s time. Now that we’ve verified <code class="docutils literal notranslate"><span class="pre">rounds</span></code> and <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code>, it’s time to
tackle the topmost function in the call stack: <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">apply_keystream</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">counter</span><span class="p">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">debug_assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">);</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">counter_setup</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rounds</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">chunk</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">chunks_mut</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">chunk</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to_le_bytes</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>There aren’t <em>that</em> many lines of code in this function, but there is still
quite a bit going on. Let’s walk through <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> in more detail:</p>
<ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> argument represents the message to encrypt (or decrypt).
<code class="docutils literal notranslate"><span class="pre">output</span></code> is a slice of bytes, so in principle, <code class="docutils literal notranslate"><span class="pre">output</span></code> can have an arbitrary
length. That being said, the first line of <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>’s implementation
checks that <code class="docutils literal notranslate"><span class="pre">output</span></code>’s length is equal to <code class="docutils literal notranslate"><span class="pre">BLOCK_SIZE</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="fm">debug_assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">);</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">BLOCK_SIZE</span></code> is defined here:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/// Size of a Salsa20 block in bytes</span>
<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</pre></div>
</div>
<p>So in practice, <code class="docutils literal notranslate"><span class="pre">output</span></code> must have exactly 64 elements.</p>
</li>
<li><p>Next, <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> invokes the <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> and <code class="docutils literal notranslate"><span class="pre">rounds</span></code> functions
to set up the keystream (the local <code class="docutils literal notranslate"><span class="pre">state</span></code> variable).</p></li>
<li><p>Finally, <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> combines the keystream with <code class="docutils literal notranslate"><span class="pre">output</span></code>. It does
so by chunking <code class="docutils literal notranslate"><span class="pre">output</span></code> into a sequence of 4 bytes, and then it XOR’s the
value of each byte in-place with the corresponding byte from the keystream.
This performs little-endian conversions as necessary.</p></li>
</ol>
<p>The fact that we are XOR’ing bytes strongly suggests that this is an
implementation of the Salsa20 encryption function from the spec. There is an
important difference between how the Salsa20 spec defines the encryption
function versus how <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> defines it, however. In the Salsa20 spec,
encryption is a function of a key, nonce, and a message. <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>, on
the other hand, is a function of <code class="docutils literal notranslate"><span class="pre">self</span></code>’s internal state, a counter, and a
message. The two aren’t <em>quite</em> the same, which is makes it somewhat tricky to
describe one in terms of the other.</p>
<p><code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code> defines a straightforward Cryptol port of the Salsa20 encryption
function from the spec, named <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code>. Because it takes a key and a
nonce as an argument, it’s not immediately clear how we’d tie this back to
<code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>. But no matter: we can do what we did before and define our
own Cryptol version of <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> in <code class="docutils literal notranslate"><span class="pre">Salsa20Extras.cry</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">apply_keystream</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">STATE_WORDS</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">BLOCK_SIZE</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">BLOCK_SIZE</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">apply_keystream</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">state0</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">output</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">littleendian_state_inverse</span><span class="w"> </span><span class="n">state2</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">state1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">counter_setup</span><span class="w"> </span><span class="n">state0</span><span class="w"> </span><span class="n">counter</span>
<span class="w">    </span><span class="n">state2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Salsa20_rounds</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">state1</span><span class="w"> </span><span class="n">state1</span>
</pre></div>
</div>
<p>This implementation builds on top of the Cryptol <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> and
<code class="docutils literal notranslate"><span class="pre">Salsa20_rounds</span></code> functions, which we used as the reference implementations for
the Rust <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> and <code class="docutils literal notranslate"><span class="pre">rounds</span></code> functions, respectively. We also make
sure to define a <code class="docutils literal notranslate"><span class="pre">BLOCK_SIZE</span></code> type alias at the top of the file:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="w"> </span><span class="kt">BLOCK_SIZE</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">64</span>
</pre></div>
</div>
<p>Now let’s write a SAW spec for <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>. Once again, we will need to
reference <code class="docutils literal notranslate"><span class="pre">BLOCK_SIZE</span></code> when talking about the <code class="docutils literal notranslate"><span class="pre">output</span></code>-related parts of the
spec, so make sure to define <code class="docutils literal notranslate"><span class="pre">BLOCK_SIZE</span></code> at the top of the <code class="docutils literal notranslate"><span class="pre">.saw</span></code> file:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span>
</pre></div>
</div>
<p>First, we need to declare all of our arguments, which proceeds as you would
expect:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">apply_keystream_spec</span><span class="w"> </span><span class="n">num_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="n">num_rounds</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">  </span><span class="n">self_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="p">);</span>
<span class="w">  </span><span class="n">self_state</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;self_state&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">STATE_WORDS</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="p">(</span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val</span><span class="p">;</span>

<span class="w">  </span><span class="n">counter</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;counter&quot;</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">;</span>

<span class="w">  </span><span class="n">output_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;output_arr&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">output_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">output_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">output_arr</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_slice_value</span><span class="w"> </span><span class="n">output_ref</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">self_ref</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">];</span>
</pre></div>
</div>
<p>What about the postconditions? We have two mutable references to contend with:
<code class="docutils literal notranslate"><span class="pre">self_ref</span></code> and <code class="docutils literal notranslate"><span class="pre">output_ref</span></code>. The postcondition for <code class="docutils literal notranslate"><span class="pre">self_ref</span></code> is fairly
straightforward: the only time it is ever modified is when <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> is
called. This means that after the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function has returned,
<code class="docutils literal notranslate"><span class="pre">self_ref</span></code> will point to the results of calling the <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> Cryptol
function:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">counter_setup</span><span class="w"> </span><span class="nf">self_state</span><span class="w"> </span><span class="nf">counter</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">output_ref</span></code> is where the interesting work happenings. After the Rust
<code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function has returned, it will point to the results of
calling the Cryptol <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function that we just defined:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">output_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">apply_keystream</span><span class="w"> </span><span class="p">`</span><span class="nf">num_rounds</span><span class="w"> </span><span class="nf">self_state</span><span class="w"> </span><span class="nf">counter</span><span class="w"> </span><span class="nf">output_arr</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, we can put this all together and verify <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> against
<code class="docutils literal notranslate"><span class="pre">apply_keystream_spec</span></code> at lengths <code class="docutils literal notranslate"><span class="pre">8</span></code> and <code class="docutils literal notranslate"><span class="pre">20</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">apply_keystream_8_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::apply_keystream::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">counter_setup_8_spec_ov</span><span class="p">,</span><span class="w"> </span><span class="n">rounds_8_spec_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">apply_keystream_spec</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="n">apply_keystream_20_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::apply_keystream::_instfa33e77d840484a0&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">counter_setup_20_spec_ov</span><span class="p">,</span><span class="w"> </span><span class="n">rounds_20_spec_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">apply_keystream_spec</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>SAW will successfully verify these. We’ve achieved victory… or have we?
Recall that we had to tailor the Cryptol <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function to
specifically match the behavior of the corresponding Rust code. This makes the
proof somewhat underwhelming, since the low-level implementation is nearly
identical to the high-level spec.</p>
<p>A more impressive proof would require linking <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> to a Cryptol
function in the <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code> file, which was developed independently of the
Rust code. As we mentioned before, however, doing so will force us to reconcile
the differences in the sorts of arguments that each function takes, as
<code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> doesn’t take a key or nonce argument. Time to think for a
bit.</p>
</section>
<section id="verifying-the-new-raw-function">
<h2>Verifying the <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> function<a class="headerlink" href="#verifying-the-new-raw-function" title="Link to this heading"></a></h2>
<p>At this point, we should ask ourselves: <em>why</em> doesn’t <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> take a
key or nonce argument? The reason lies in the fact that the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate
implements Salsa20 in a stateful way. Specifically, the <code class="docutils literal notranslate"><span class="pre">Core</span></code> struct stores
internal state that is used to compute the keystream to apply when hashing. In
order to use this internal state, however, we must first initialize it. The
<code class="docutils literal notranslate"><span class="pre">new</span></code> function that is responsible for this initialization:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="sd">/// Initialize core function with the given key and IV</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Key</span><span class="p">,</span><span class="w"> </span><span class="n">iv</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Nonce</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="p">::</span><span class="n">new_raw</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">as_ref</span><span class="p">(),</span><span class="w"> </span><span class="n">iv</span><span class="p">.</span><span class="n">as_ref</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>Sure enough, this function takes a key and a nonce as an argument! This is a
critical point that we overlooked. When using the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> crate, you wouldn’t
use the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function in isolation. Instead, you would create an
initial <code class="docutils literal notranslate"><span class="pre">Core</span></code> value using <code class="docutils literal notranslate"><span class="pre">new</span></code>, and <em>then</em> you would invoke
<code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>. The Salsa20 spec effectively combines both of these
operations in is encryption function, whereas the <code class="docutils literal notranslate"><span class="pre">salsa20</span></code> splits these two
operations into separate functions altogether.</p>
<p>Strictly speaking, we don’t need to verify <code class="docutils literal notranslate"><span class="pre">new</span></code> in order to verify
<code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>, as the latter never invokes the former. Still, it will be a
useful exercise to verify <code class="docutils literal notranslate"><span class="pre">new</span></code>, as the insights we gain when doing so will
help us write a better version of <code class="docutils literal notranslate"><span class="pre">apply_keystream_spec</span></code>.</p>
<p>All that being said, we probably to verify <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> (a lower-level helper
function) rather than <code class="docutils literal notranslate"><span class="pre">new</span></code> itself. This is because the definitions of <code class="docutils literal notranslate"><span class="pre">Key</span></code>
and <code class="docutils literal notranslate"><span class="pre">Nonce</span></code> are somewhat involved. For instance, <code class="docutils literal notranslate"><span class="pre">Key</span></code> is defined as:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">Key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cipher</span><span class="p">::</span><span class="n">generic_array</span><span class="p">::</span><span class="n">GenericArray</span><span class="o">&lt;</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">U32</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference external" href="https://docs.rs/generic-array/latest/generic_array/struct.GenericArray.html"><code class="docutils literal notranslate"><span class="pre">GenericArray</span></code></a>
is a somewhat complicated abstraction. Luckily, we don’t really <em>need</em> to deal
with it, since <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> deals with simple array references rather than
<code class="docutils literal notranslate"><span class="pre">GenericArray</span></code>s:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="sd">/// Initialize core function with the given key and IV</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new_raw</span><span class="p">(</span><span class="n">key</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">32</span><span class="p">],</span><span class="w"> </span><span class="n">iv</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
</pre></div>
</div>
<p>The full implementation of <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> is rather long, so we won’t inline the
whole thing here. At a high level, it initializes the <code class="docutils literal notranslate"><span class="pre">state</span></code> array of a <code class="docutils literal notranslate"><span class="pre">Core</span></code>
value by populating each element of the array with various things. Some
elements of the array are populated with <code class="docutils literal notranslate"><span class="pre">key</span></code>, some parts are populated with
<code class="docutils literal notranslate"><span class="pre">iv</span></code> (i.e., the nonce), and other parts are populated with an array named
<code class="docutils literal notranslate"><span class="pre">CONSTANTS</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/// State initialization constant (&quot;expand 32-byte k&quot;)</span>
<span class="k">const</span><span class="w"> </span><span class="n">CONSTANTS</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mh">0x6170_7865</span><span class="p">,</span><span class="w"> </span><span class="mh">0x3320_646e</span><span class="p">,</span><span class="w"> </span><span class="mh">0x7962_2d32</span><span class="p">,</span><span class="w"> </span><span class="mh">0x6b20_6574</span><span class="p">];</span>
</pre></div>
</div>
<p>The comment about <code class="docutils literal notranslate"><span class="pre">&quot;expand</span> <span class="pre">32-byte</span> <span class="pre">k&quot;</span></code> is a strong hint that <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> is
implementing a portion of the Salsa20 expansion function from the spec. (No
really, the spec literally says to use the exact string <code class="docutils literal notranslate"><span class="pre">&quot;expand</span> <span class="pre">32-byte</span> <span class="pre">k&quot;</span></code>—look it up!) The <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code> Cryptol file has an implementation of this
portion of the expansion function, which is named <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kt">Salsa20_init</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">([</span><span class="mi">16</span><span class="o">*</span><span class="n">a</span><span class="p">][</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">Salsa20_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">split</span><span class="w"> </span><span class="s">&quot;expand 32-byte k&quot;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="p">[</span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">split</span><span class="w"> </span><span class="s">&quot;expand 16-byte k&quot;</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="p">(`</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">k0</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">s3</span>
<span class="w">                    </span><span class="kr">else</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">k0</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">k0</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">t3</span>
<span class="w">    </span><span class="p">[</span><span class="n">k0</span><span class="p">,</span><span class="w"> </span><span class="n">k1</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="nb">split</span><span class="p">(</span><span class="n">k</span><span class="o">#</span><span class="n">zero</span><span class="p">))</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">16</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that we were careful to say a <em>portion</em> of the Salsa20 expansion function.
There is also a Cryptol implementation of the full expansion function, named
<code class="docutils literal notranslate"><span class="pre">Salsa20_expansion</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kt">Salsa20_expansion</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">([</span><span class="mi">32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="o">*</span><span class="n">a</span><span class="p">][</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">Salsa20_expansion</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Salsa20</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="p">(</span><span class="kt">Salsa20_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>This calls <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code> followed by <code class="docutils literal notranslate"><span class="pre">Salsa20</span></code>, the latter of which performs
hashing. Importantly, <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> does <em>not</em> do any hashing on its own, just
initialization. For this reason, we want to use <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code> as the reference
implementation of <code class="docutils literal notranslate"><span class="pre">new_raw</span></code>, not <code class="docutils literal notranslate"><span class="pre">Salsa20_expansion</span></code>.</p>
<p>Alright, time to write a SAW spec. The first part of the spec is straightforward:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">new_raw_spec</span><span class="w"> </span><span class="n">num_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">key_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">key_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;key_arr&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">key_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">key_arr</span><span class="p">);</span>

<span class="w">  </span><span class="n">nonce_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">nonce_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;nonce&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">nonce_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">nonce_arr</span><span class="p">);</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">key_ref</span><span class="p">,</span><span class="w"> </span><span class="n">nonce_ref</span><span class="p">];</span>
</pre></div>
</div>
<p>As is usually the case, the postconditions are the tricky part. We know that
the behavior of <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> will roughly coincide with the <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code>
function, so let’s try that first:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="n">num_rounds</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_init</span><span class="p">(</span><span class="nf">key_arr</span><span class="p">,</span><span class="w"> </span><span class="nf">nonce_arr</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="p">(</span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="p">(</span><span class="n">core_adt</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_return</span><span class="w"> </span><span class="n">self_val</span><span class="p">;</span>
</pre></div>
</div>
<p>If we attempt to verify this using <code class="docutils literal notranslate"><span class="pre">mir_verify</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">new_raw_8_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::new_raw::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">new_raw_spec</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="n">new_raw_20_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::new_raw::_instfa33e77d840484a0&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">new_raw_spec</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>SAW complains thusly:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Cryptol error:</span>
<span class="go">[error] at salsa20.saw:109:45--109:54:</span>
<span class="go">  Type mismatch:</span>
<span class="go">    Expected type: 16</span>
<span class="go">    Inferred type: 8</span>
<span class="go">    Context: [ERROR] _</span>
<span class="go">    When checking type of 2nd tuple field</span>
</pre></div>
</div>
<p>Here, the 2nd tuple field is the <code class="docutils literal notranslate"><span class="pre">nonce_arr</span></code> in <code class="docutils literal notranslate"><span class="pre">Salsa20_init(key_arr,</span> <span class="pre">nonce_arr)</span></code>. And sure enough, <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code> expects the 2nd tuple field to be
a sequence of 16 elements, but <code class="docutils literal notranslate"><span class="pre">nonce_arr</span></code> only has 8 elements. Where do we get
the remaining 8 elements from?</p>
<p>The answer to this question can be found by looking at the implementation of
<code class="docutils literal notranslate"><span class="pre">new_raw</span></code> more closely. Let’s start at this code:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">chunk</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iv</span><span class="p">.</span><span class="n">chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="p">[</span><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">::</span><span class="n">from_le_bytes</span><span class="p">(</span><span class="n">chunk</span><span class="p">.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>
</pre></div>
</div>
<p>This will chunk up <code class="docutils literal notranslate"><span class="pre">iv</span></code> (the nonce) into two 4-byte chunks and copies them over
to the elements of <code class="docutils literal notranslate"><span class="pre">state</span></code> array at indices <code class="docutils literal notranslate"><span class="pre">6</span></code> and <code class="docutils literal notranslate"><span class="pre">7</span></code>. This is immediately
followed by two updates at indices <code class="docutils literal notranslate"><span class="pre">8</span></code> and <code class="docutils literal notranslate"><span class="pre">9</span></code>, which are updated to be <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="n">state</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">state</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>If you take the two 4-bytes chunks of <code class="docutils literal notranslate"><span class="pre">iv</span></code> and put two 4-byte <code class="docutils literal notranslate"><span class="pre">0</span></code> values after
them, then you would have a total of 16 bytes. This suggests that the nonce
value that <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code> expects is actually this:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">nonce_arr</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">zero</span> <span class="pre">:</span> <span class="pre">[8][8]</span></code> is a Cryptol expression that returns all zeroes, and
<code class="docutils literal notranslate"><span class="pre">(#)</span></code> is the Cryptol operator for concatenating two sequences together. Let’s
update <code class="docutils literal notranslate"><span class="pre">new_raw_spec</span></code> to reflect this:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_init</span><span class="p">(</span><span class="nf">key_arr</span><span class="p">,</span><span class="w"> </span><span class="nf">nonce_arr</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="nf">zero</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
</pre></div>
</div>
<p>This is closer to what we want, but not quite. SAW still complains:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">could not match specified value with actual value:</span>
<span class="go">  ...</span>
<span class="go">  type of actual value:    [u32; 16]</span>
<span class="go">  type of specified value: [u8; 64]</span>
</pre></div>
</div>
<p>This is because <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code> returns something of type <code class="docutils literal notranslate"><span class="pre">[64][8]</span></code>, which
corresponds to the Rust type <code class="docutils literal notranslate"><span class="pre">[u8;</span> <span class="pre">64]</span></code>. <code class="docutils literal notranslate"><span class="pre">self.state</span></code>, on the other hand, is of
type <code class="docutils literal notranslate"><span class="pre">[u32;</span> <span class="pre">16]</span></code>. These types are very close, as they both contain the same
number of bytes, but they are chunked up differently. Recall the code that
copies the nonce value over to <code class="docutils literal notranslate"><span class="pre">self.state</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">chunk</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iv</span><span class="p">.</span><span class="n">chunks</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">state</span><span class="p">[</span><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">::</span><span class="n">from_le_bytes</span><span class="p">(</span><span class="n">chunk</span><span class="p">.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span>
</pre></div>
</div>
<p>In order to resolve the type differences between <code class="docutils literal notranslate"><span class="pre">iv</span></code> and <code class="docutils literal notranslate"><span class="pre">state</span></code>, this code
needed to explicitly convert <code class="docutils literal notranslate"><span class="pre">iv</span></code> to little-endian form using the
<a class="reference external" href="https://doc.rust-lang.org/std/primitive.u32.html#method.from_le_bytes"><code class="docutils literal notranslate"><span class="pre">u32::from_le_bytes</span></code></a>
function. There is a similar Cryptol function in <code class="docutils literal notranslate"><span class="pre">Salsa20.cry</span></code> named
<code class="docutils literal notranslate"><span class="pre">littleendian_state</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">littleendian_state</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">littleendian_state</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">littleendian</span><span class="w"> </span><span class="n">xi</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">xi</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">split</span><span class="w"> </span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">[64][8]</span></code> is the Cryptol equivalent of <code class="docutils literal notranslate"><span class="pre">[u8;</span> <span class="pre">64]</span></code>, and <code class="docutils literal notranslate"><span class="pre">[16][32]</span></code> is
the Cryptol equivalent of <code class="docutils literal notranslate"><span class="pre">[u32;</span> <span class="pre">16]</span></code>. As such, this is exactly the function
that we need to resolve the differences in types:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">littleendian_state</span><span class="w"> </span><span class="p">(</span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_init</span><span class="p">(</span><span class="nf">key_arr</span><span class="p">,</span><span class="w"> </span><span class="nf">nonce_arr</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="nf">zero</span><span class="p">))</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
</pre></div>
</div>
<p>With that change, SAW is finally happy with <code class="docutils literal notranslate"><span class="pre">new_raw_spec</span></code> and successfully
verifies it.</p>
<p>There is an interesting connection between the <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> and <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code>
functions. Both functions perform in-place updates on <code class="docutils literal notranslate"><span class="pre">state</span></code> at indices <code class="docutils literal notranslate"><span class="pre">8</span></code>
and <code class="docutils literal notranslate"><span class="pre">9</span></code>. Whereas <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> always sets these elements of <code class="docutils literal notranslate"><span class="pre">state</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>,
<code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> will set them to the bits of the <code class="docutils literal notranslate"><span class="pre">counter</span></code> argument (after
converting <code class="docutils literal notranslate"><span class="pre">counter</span></code> to little-endian form). This means that if you invoke
<code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> right after <code class="docutils literal notranslate"><span class="pre">new_raw</span></code>, then <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> would overwrite the
<code class="docutils literal notranslate"><span class="pre">0</span></code> values with the <code class="docutils literal notranslate"><span class="pre">counter</span></code> argument. In order words, it would be tantamount
to initializing <code class="docutils literal notranslate"><span class="pre">state</span></code> like so:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">littleendian_state</span><span class="w"> </span><span class="p">(</span><span class="kt">Salsa20_init</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">nonce</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="n">littleendian_inverse</span><span class="w"> </span><span class="n">counter</span><span class="p">))</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">littleendian_inverse</span></code> (a sibling of <code class="docutils literal notranslate"><span class="pre">littleendian_state</span></code>) converts a
<code class="docutils literal notranslate"><span class="pre">[64]</span></code> value to a <code class="docutils literal notranslate"><span class="pre">[8][8]</span></code> one. This pattern is a curious one…</p>
</section>
<section id="verifying-the-apply-keystream-function-second-attempt">
<h2>Verifying the <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> function (second attempt)<a class="headerlink" href="#verifying-the-apply-keystream-function-second-attempt" title="Link to this heading"></a></h2>
<p>Let’s now return to the problem of linking <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> up to
<code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code>. In particular, let’s take a closer look at the definition of
<code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code> itself:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kt">Salsa20_encrypt</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="o">^^</span><span class="mi">70</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">([</span><span class="mi">32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="o">*</span><span class="n">a</span><span class="p">][</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">Salsa20_encrypt</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">salsa</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="p">(</span><span class="nb">join</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="kt">Salsa20_expansion</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">#</span><span class="p">(</span><span class="n">littleendian_inverse</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">])</span>
</pre></div>
</div>
<p>Does anything about this definition strike you as interesting? Take a look at
the <code class="docutils literal notranslate"><span class="pre">v#(littleendian_inverse</span> <span class="pre">i)</span></code> part—we <em>just</em> saw a use of
<code class="docutils literal notranslate"><span class="pre">littleendian_inverse</span></code> earlier in our discussion about initializing the
<code class="docutils literal notranslate"><span class="pre">state</span></code>! Moreover, <code class="docutils literal notranslate"><span class="pre">v</span></code> is the nonce argument, so it is becoming clearer that
<code class="docutils literal notranslate"><span class="pre">Sals20_encrypt</span></code> is creating an initial state is much the same way that
<code class="docutils literal notranslate"><span class="pre">new_raw</span></code> is.</p>
<p>A related question: what is the <code class="docutils literal notranslate"><span class="pre">i</span></code> value? The answer is somewhat technical:
the Salsa20 encryption function is designed to work with messages with
differing numbers of bytes (up to <code class="docutils literal notranslate"><span class="pre">2^^70</span></code> bytes, to be exact). Each 8-byte
chunk in the message will be encrypted with a slightly difference nonce. For
instance, the first 8-byte chunk’s nonce will have its lower 32 bits set to
<code class="docutils literal notranslate"><span class="pre">0</span></code>, the second 8-byte chunk’s nonce will have its lower 32 bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>,
and so on. In general, the <code class="docutils literal notranslate"><span class="pre">i</span></code>th 8-byte chunk’s nonce will have its lower 32
bits set to <code class="docutils literal notranslate"><span class="pre">i</span></code>, and this corresponds exactly to the <code class="docutils literal notranslate"><span class="pre">i</span></code> in the expression
<code class="docutils literal notranslate"><span class="pre">littleendian_inverse</span> <span class="pre">i</span></code>.</p>
<p>Note, however, that <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> only ever uses a message that consists of
exactly eight 8-byte chunks. This means that <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code> will only ever
invoke <code class="docutils literal notranslate"><span class="pre">Salsa20_expansion</span></code> once with a nonce value where the lower 32 bits are
set to <code class="docutils literal notranslate"><span class="pre">0</span></code>. That is, it will perform encryption with an initial state derived
from:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kt">Salsa20_init</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">#</span><span class="p">(</span><span class="n">littleendian_inverse</span><span class="w"> </span><span class="n">zero</span><span class="p">))</span>
</pre></div>
</div>
<p>Which can be further simplified to <code class="docutils literal notranslate"><span class="pre">Salsa20_init(k,</span> <span class="pre">v</span> <span class="pre">#</span> <span class="pre">zero)</span></code>. This is very
nearly what we want, as this gives us the behavior of the Rust <code class="docutils literal notranslate"><span class="pre">new_raw</span></code>
function. There’s just one problem though: it doesn’t take the behavior of
<code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> into account. How do we go from <code class="docutils literal notranslate"><span class="pre">zero</span></code> to <code class="docutils literal notranslate"><span class="pre">littleendian_inverse</span> <span class="pre">counter</span></code>?</p>
<p>While <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code> doesn’t take counters into account at all, it is not
too difficult to generalize <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code> in this way. There is a variant
of <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt</span></code> in the same file named <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt_with_offset</span></code>,
where the offset argument <code class="docutils literal notranslate"><span class="pre">o</span></code> serves the same role that <code class="docutils literal notranslate"><span class="pre">counter</span></code> does in
<code class="docutils literal notranslate"><span class="pre">counter_setup</span></code>:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="kt">Salsa20_encrypt_with_offset</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="o">^^</span><span class="mi">70</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span>
<span class="w">    </span><span class="p">([</span><span class="mi">32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">16</span><span class="o">*</span><span class="n">a</span><span class="p">][</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">8</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">Salsa20_encrypt_with_offset</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">o</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">c</span>
<span class="w">  </span><span class="kr">where</span>
<span class="w">    </span><span class="n">salsa</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="p">(</span><span class="nb">join</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="kt">Salsa20_expansion</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">#</span><span class="p">(</span><span class="n">littleendian_inverse</span><span class="w"> </span><span class="p">(</span><span class="n">o</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">])</span>
<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">salsa</span>
</pre></div>
</div>
<p>(Observe that <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt(count,</span> <span class="pre">k,</span> <span class="pre">v,</span> <span class="pre">m)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt_with_offset(count,</span> <span class="pre">k,</span> <span class="pre">v,</span> <span class="pre">0,</span> <span class="pre">m)</span></code>.)</p>
<p>At long last, we have discovered the connection between <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> and
the Salsa20 spec. If you assume that you invoke <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> beforehand, then the
behavior of <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code> corresponds exactly to that of
<code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt_with_offset</span></code>. This insight will inform us how to write an
alternative SAW spec for <code class="docutils literal notranslate"><span class="pre">apply_keystream</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span><span class="w"> </span><span class="n">apply_keystream_alt_spec</span><span class="w"> </span><span class="n">num_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">key</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;key&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">nonce</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;nonce&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">counter</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;counter&quot;</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">;</span>

<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r_adt</span><span class="w"> </span><span class="n">num_rounds</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">core_adt</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">  </span><span class="n">self_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_adt</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">littleendian_state</span><span class="w"> </span><span class="p">(</span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_init</span><span class="p">(</span><span class="nf">key</span><span class="p">,</span><span class="w"> </span><span class="nf">nonce</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="nf">littleendian_inverse</span><span class="w"> </span><span class="nf">counter</span><span class="p">))</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_rounds</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="p">(</span><span class="n">phantom_data_adt</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val</span><span class="p">;</span>
</pre></div>
</div>
<p>Observe the following differences between <code class="docutils literal notranslate"><span class="pre">apply_keystream_alt_spec</span></code> and our
earlier <code class="docutils literal notranslate"><span class="pre">apply_keystream_spec</span></code>:</p>
<ol class="arabic simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">apply_keystream_alt_spec</span></code>, we declare fresh <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">nonce</span></code> values,
which weren’t present at all in <code class="docutils literal notranslate"><span class="pre">apply_keystream_spec</span></code>.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">apply_keystream_alt_spec</span></code>, we no longer make <code class="docutils literal notranslate"><span class="pre">self_state</span></code> a fresh,
unconstrained value. Instead, we declare that it must be the result of
calling <code class="docutils literal notranslate"><span class="pre">Salsa20_init</span></code> on the <code class="docutils literal notranslate"><span class="pre">key</span></code>, <code class="docutils literal notranslate"><span class="pre">nonce</span></code>, and <code class="docutils literal notranslate"><span class="pre">counter</span></code> values. This
is the part that encodes the assumption that <code class="docutils literal notranslate"><span class="pre">new_raw</span></code> was invoked
beforehand.</p></li>
</ol>
<p>The parts of the spec relating to <code class="docutils literal notranslate"><span class="pre">output</span></code> remain unchanged:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">output_arr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;output_arr&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">output_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">mir_alloc_mut</span><span class="w"> </span><span class="p">(</span><span class="n">mir_array</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">output_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="n">output_arr</span><span class="p">);</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_slice_value</span><span class="w"> </span><span class="n">output_ref</span><span class="p">;</span>

<span class="w">  </span><span class="n">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">self_ref</span><span class="p">,</span><span class="w"> </span><span class="n">mir_term</span><span class="w"> </span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">];</span>
</pre></div>
</div>
<p>The postconditions are slightly different in <code class="docutils literal notranslate"><span class="pre">apply_keystream_alt_spec</span></code>. While
the parts relating to <code class="docutils literal notranslate"><span class="pre">self_ref</span></code> remain unchanged, we now have <code class="docutils literal notranslate"><span class="pre">output_ref</span></code>
point to the results of calling <code class="docutils literal notranslate"><span class="pre">Salsa20_encrypt_with_offset</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_state&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">counter_setup</span><span class="w"> </span><span class="nf">self_state</span><span class="w"> </span><span class="nf">counter</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">  </span><span class="kr">let</span><span class="w"> </span><span class="n">self_val&#39;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mir_struct_value</span><span class="w"> </span><span class="n">core_adt_inst</span><span class="w"> </span><span class="p">[</span><span class="n">mir_term</span><span class="w"> </span><span class="n">self_state&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">self_rounds</span><span class="p">];</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">self_ref</span><span class="w"> </span><span class="n">self_val&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="n">mir_points_to</span><span class="w"> </span><span class="n">output_ref</span><span class="w"> </span><span class="p">(</span><span class="n">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_encrypt_with_offset</span><span class="p">(`</span><span class="nf">num_rounds</span><span class="p">,</span><span class="w"> </span><span class="nf">key</span><span class="p">,</span><span class="w"> </span><span class="nf">nonce</span><span class="p">,</span><span class="w"> </span><span class="nf">counter</span><span class="p">,</span><span class="w"> </span><span class="nf">output_arr</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
</pre></div>
</div>
<p>Tying this all together, we call <code class="docutils literal notranslate"><span class="pre">mir_verify</span></code>, making sure to use compositional
overrides involving <code class="docutils literal notranslate"><span class="pre">counter_setup</span></code> and <code class="docutils literal notranslate"><span class="pre">rounds</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">apply_keystream_alt_8_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::apply_keystream::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">counter_setup_8_spec_ov</span><span class="p">,</span><span class="w"> </span><span class="n">rounds_8_spec_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">apply_keystream_alt_spec</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="n">apply_keystream_alt_20_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::apply_keystream::_instfa33e77d840484a0&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">counter_setup_20_spec_ov</span><span class="p">,</span><span class="w"> </span><span class="n">rounds_20_spec_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">apply_keystream_alt_spec</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>At long last, it is time to run SAW on this. When we do, we see this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[15:11:44.576] Checking proof obligations salsa20/10e438b3::core#1[0]::{impl#</span><span class="m">0</span><span class="o">}[</span><span class="m">0</span><span class="o">]</span>::apply_keystream<span class="o">[</span><span class="m">0</span><span class="o">]</span>::_inst6e4a2d7250998ef7<span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w"> </span>...
</pre></div>
</div>
<p>After this, SAW loops forever. Oh no! While somewhat disheartening, this is a
reality of SMT-based verification that we must content with. SMT solvers are
extremely powerful, but their performance can sometimes be unpredictable. The
task of verifying <code class="docutils literal notranslate"><span class="pre">apply_keystream_alt_spec</span></code> is <em>just</em> complicated enough that
Z3 cannot immediately figure out that the proof is valid, so it resorts to much
slower algorithms to solve proof goals.</p>
<p>We could try waiting for Z3 to complete, but we’d be waiting for a long time.
It’s not unheard of for SMT solvers to take many hours on especially hard
problems, but we don’t have that many hours to spare. We should try a slightly
different approach instead.</p>
<p>When confronted with an infinite loop in SAW, there isn’t a one-size-fits-all
solution that will cure the problem. Sometimes, it is worth stating your SAW
spec in a slightly different way such that the SMT solver can spot patterns
that it couldn’t before. Other times, it can be useful to try and break the
problem up into smaller functions and use compositional verification to handle
the more complicated subfunctions. As we mentioned before, the performance of
SMT solvers in unpredictable, and it’s not always obvious what the best
solution is.</p>
<p>In this example, however, the problem lies with Z3 itself. As it turns out,
Yices (a different SMT solver) <em>can</em> spot the patterns needed to prove
<code class="docutils literal notranslate"><span class="pre">apply_keystream_alt_spec</span></code> immediately. Fortunately, SAW includes support for
both Z3 and Yices. In order to switch from Z3 to Yices, swap out the <code class="docutils literal notranslate"><span class="pre">z3</span></code> proof
script with <code class="docutils literal notranslate"><span class="pre">yices</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">apply_keystream_alt_8_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::apply_keystream::_inst6e4a2d7250998ef7&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">counter_setup_8_spec_ov</span><span class="p">,</span><span class="w"> </span><span class="n">rounds_8_spec_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">apply_keystream_alt_spec</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="n">yices</span><span class="p">;</span>
<span class="n">apply_keystream_alt_20_spec_ov</span><span class="w"> </span><span class="ow">&lt;-</span>
<span class="w">  </span><span class="n">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;salsa20::core#1::{impl#0}::apply_keystream::_instfa33e77d840484a0&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">counter_setup_20_spec_ov</span><span class="p">,</span><span class="w"> </span><span class="n">rounds_20_spec_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">(</span><span class="n">apply_keystream_alt_spec</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="n">yices</span><span class="p">;</span>
</pre></div>
</div>
<p>After doing this, SAW is leverage Yices to solve the proof goals almost
immediately:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">[15:22:00.745] Proof succeeded! salsa20/10e438b3::core#1[0]::{impl#</span><span class="m">0</span><span class="o">}[</span><span class="m">0</span><span class="o">]</span>::apply_keystream<span class="o">[</span><span class="m">0</span><span class="o">]</span>::_instfa33e77d840484a0<span class="o">[</span><span class="m">0</span><span class="o">]</span>
</pre></div>
</div>
<p>And with that, we’re finally done! You’ve successfully completed a non-trivial
SAW exercise in writing some interesting proofs. Give yourself a well-deserved
pat on the back.</p>
<p>The process of developing these proofs was bumpy at times, but that is to be
expected. You very rarely get a proof correct on the very first try, and when
SAW doesn’t accept your proof, it is important to be able to figure out what
went wrong and how to fix it. This is a skill that takes some time to grow, but
with enough time and experience, you will be able to recognize common pitfalls.
This case study showed off some of these pitfalls, but there are likely others.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="static-items.html" class="btn btn-neutral float-left" title="Static items" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="a-final-word.html" class="btn btn-neutral float-right" title="A final word" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Galois, Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <!-- Adapted from: -->
<!-- https://github.com/brechtm/rinohtype/commit/1270802c4959eb4742c51d3307222930ac73a80c -->


  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Versions</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl id="docs-versions">
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>