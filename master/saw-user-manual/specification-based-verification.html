

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Specification-Based Verification &mdash; SAW Documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/sphinx_rtd_theme.css?v=3234e928" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/js/hoverxref.js"></script>
      <script src="../_static/js/tooltipster.bundle.min.js"></script>
      <script src="../_static/js/micromodal.min.js"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/versions.js?v=302bdcf2"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bisimulation Prover" href="bisimulation-prover.html" />
    <link rel="prev" title="The Term Type" href="the-term-type.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SAW Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../llvm-java-verification-with-saw/index.html">LLVM/Java Verification with SAW</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust-verification-with-saw/index.html">Rust Verification with SAW</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">SAW User Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="structure-of-sawscript.html">Structure of SAWScript</a></li>
<li class="toctree-l2"><a class="reference internal" href="invoking-saw.html">Invoking SAW</a></li>
<li class="toctree-l2"><a class="reference internal" href="cryptol-and-its-role-in-saw.html">Cryptol and its Role in SAW</a></li>
<li class="toctree-l2"><a class="reference internal" href="loading-code.html">Loading Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="analyzing-hardware-circuits-using-yosys.html">Analyzing Hardware Circuits using Yosys</a></li>
<li class="toctree-l2"><a class="reference internal" href="creating-symbolic-variables.html">Creating Symbolic Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="symbolic-execution.html">Symbolic Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="symbolic-termination.html">Symbolic Termination</a></li>
<li class="toctree-l2"><a class="reference internal" href="the-term-type.html">The Term Type</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Specification-Based Verification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#running-a-verification">Running a Verification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#running-a-mir-based-verification">Running a MIR-based verification</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structure-of-a-specification">Structure of a Specification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-fresh-variables">Creating Fresh Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-llvmvalue-jvmvalue-and-mirvalue-types">The LLVMValue, JVMValue, and MIRValue Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cryptol-type-correspondence">Cryptol type correspondence</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#executing">Executing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#return-values">Return Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-first-simple-example-revisited">A First Simple Example (Revisited)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compositional-verification">Compositional Verification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compositional-verification-and-mutable-allocations">Compositional Verification and Mutable Allocations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compositional-verification-and-mutable-global-variables">Compositional Verification and Mutable Global Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-heap-layout">Specifying Heap Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-heap-values">Specifying Heap Values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#llvm-heap-values">LLVM heap values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#jvm-heap-values">JVM heap values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mir-heap-values">MIR heap values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-compound-types">Working with Compound Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mir-slices">MIR slices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mir-vecs">MIR <code class="docutils literal notranslate"><span class="pre">Vec</span></code>s</a></li>
<li class="toctree-l4"><a class="reference internal" href="#finding-mir-algebraic-data-types">Finding MIR algebraic data types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bitfields">Bitfields</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#global-variables">Global variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#llvm-global-variables">LLVM global variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mir-static-items">MIR static items</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#preconditions-and-postconditions">Preconditions and Postconditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assuming-specifications">Assuming specifications</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-heap-based-example">A Heap-Based Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-ghost-state">Using Ghost State</a></li>
<li class="toctree-l3"><a class="reference internal" href="#an-extended-example">An Extended Example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#salsa20-overview">Salsa20 Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specifications">Specifications</a></li>
<li class="toctree-l4"><a class="reference internal" href="#verifying-everything">Verifying Everything</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#verifying-cryptol-ffi-functions">Verifying Cryptol FFI functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#polymorphism">Polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-types">Supported types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performing-the-verification">Performing the verification</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="bisimulation-prover.html">Bisimulation Prover</a></li>
<li class="toctree-l2"><a class="reference internal" href="transforming-term-values.html">Transforming Term Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="proofs-about-terms.html">Proofs about Terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="extraction-to-the-coq-theorem-prover.html">Extraction to the Coq theorem prover</a></li>
<li class="toctree-l2"><a class="reference internal" href="formal-deprecation-process.html">Formal Deprecation Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendices/index.html">Appendices</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SAW Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">SAW User Manual</a></li>
      <li class="breadcrumb-item active">Specification-Based Verification</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/saw-user-manual/specification-based-verification.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="specification-based-verification">
<h1>Specification-Based Verification<a class="headerlink" href="#specification-based-verification" title="Link to this heading"></a></h1>
<p>The built-in functions described so far work by extracting models of
code that can then be used for a variety of purposes, including proofs
about the properties of the code.</p>
<p>When the goal is to prove equivalence between some LLVM, Java, or MIR code and
a specification, however, a more declarative approach is sometimes
convenient. The following sections describe an approach that combines
model extraction and verification with respect to a specification. A
verified specification can then be used as input to future
verifications, allowing the proof process to be decomposed.</p>
<section id="running-a-verification">
<h2>Running a Verification<a class="headerlink" href="#running-a-verification" title="Link to this heading"></a></h2>
<p>Verification of LLVM is controlled by the <code class="docutils literal notranslate"><span class="pre">llvm_verify</span></code> command.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="nb">llvm_verify</span><span class="w"> </span><span class="p">:</span>
<span class="w">  </span><span class="kt">LLVMModule</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="p">[</span><span class="n">CrucibleMethodSpec</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">LLVMSetup</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">ProofScript</span><span class="w"> </span><span class="kt">SatResult</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">TopLevel</span><span class="w"> </span><span class="kt">CrucibleMethodSpec</span>
</pre></div>
</div>
<p>The first two arguments specify the module and function name to verify,
as with <code class="docutils literal notranslate"><span class="pre">llvm_verify</span></code>. The third argument specifies the list of
already-verified specifications to use for compositional verification
(described later; use <code class="docutils literal notranslate"><span class="pre">[]</span></code> for now). The fourth argument specifies
whether to do path satisfiability checking, and the fifth gives the
specification of the function to be verified. Finally, the last argument
gives the proof script to use for verification. The result is a proved
specification that can be used to simplify verification of functions
that call this one.</p>
<p>Similar commands are available for JVM programs:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="nb">jvm_verify</span><span class="w"> </span><span class="p">:</span>
<span class="w">  </span><span class="kt">JavaClass</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="p">[</span><span class="n">JVMMethodSpec</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">JVMSetup</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">ProofScript</span><span class="w"> </span><span class="kt">SatResult</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">TopLevel</span><span class="w"> </span><span class="kt">JVMMethodSpec</span>
</pre></div>
</div>
<p>And for MIR programs:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="nb">mir_verify</span><span class="w"> </span><span class="p">:</span>
<span class="w">  </span><span class="kt">MIRModule</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="p">[</span><span class="n">MIRSpec</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">Bool</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">MIRSetup</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">ProofScript</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ow">-&gt;</span>
<span class="w">  </span><span class="kt">TopLevel</span><span class="w"> </span><span class="kt">MIRSpec</span>
</pre></div>
</div>
<section id="running-a-mir-based-verification">
<h3>Running a MIR-based verification<a class="headerlink" href="#running-a-mir-based-verification" title="Link to this heading"></a></h3>
<p>(Note: API functions involving MIR verification require <code class="docutils literal notranslate"><span class="pre">enable_experimental</span></code>
in order to be used. As such, some parts of this API may change before being
finalized.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">String</span></code> supplied as an argument to <code class="docutils literal notranslate"><span class="pre">mir_verify</span></code> is expected to be a
function <em>identifier</em>. An identifier is expected adhere to one of the following
conventions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;crate</span> <span class="pre">name&gt;/&lt;disambiguator&gt;::&lt;function</span> <span class="pre">path&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;crate</span> <span class="pre">name&gt;::&lt;function</span> <span class="pre">path&gt;</span></code></p></li>
</ul>
<p>Where:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;crate</span> <span class="pre">name&gt;</span></code> is the name of the crate in which the function is defined. (If
you produced your MIR JSON file by compiling a single <code class="docutils literal notranslate"><span class="pre">.rs</span></code> file with
<code class="docutils literal notranslate"><span class="pre">saw-rustc</span></code>, then the crate name is the same as the name of the file, but
without the <code class="docutils literal notranslate"><span class="pre">.rs</span></code> file extension.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;disambiguator&gt;</span></code> is a hash of the crate and its dependencies. In extreme
cases, it is possible for two different crates to have identical crate names,
in which case the disambiguator must be used to distinguish between the two
crates. In the common case, however, most crate names will correspond to
exactly one disambiguator, and you are allowed to leave out the
<code class="docutils literal notranslate"><span class="pre">/&lt;disambiguator&gt;</span></code> part of the <code class="docutils literal notranslate"><span class="pre">String</span></code> in this case. If you supply an
identifier with an ambiguous crate name and omit the disambiguator, then SAW
will raise an error.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;function</span> <span class="pre">path&gt;</span></code> is the path to the function within the crate. Sometimes,
this is as simple as the function name itself. In other cases, a function
path may involve multiple <em>segments</em>, depending on the module hierarchy for
the program being verified. For instance, a <code class="docutils literal notranslate"><span class="pre">read</span></code> function located in
<code class="docutils literal notranslate"><span class="pre">core/src/ptr/mod.rs</span></code> will have the identifier:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>core::ptr::read
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">core</span></code> is the crate name and <code class="docutils literal notranslate"><span class="pre">ptr::read</span></code> is the function path, which
has two segments <code class="docutils literal notranslate"><span class="pre">ptr</span></code> and <code class="docutils literal notranslate"><span class="pre">read</span></code>. There are also some special forms of
segments that appear for functions defined in certain language constructs.
For instance, if a function is defined in an <code class="docutils literal notranslate"><span class="pre">impl</span></code> block, then it will have
<code class="docutils literal notranslate"><span class="pre">{impl}</span></code> as one of its segments, e.g.,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>core::ptr::const_ptr::{impl}::offset
</pre></div>
</div>
<p>If you are in doubt about what the full identifier for a given function is,
consult the MIR JSON file for your program.</p>
</li>
</ul>
<hr class="docutils" />
<p>Now we describe how to construct a value of type <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span> <span class="pre">()</span></code>, <code class="docutils literal notranslate"><span class="pre">JVMSetup</span> <span class="pre">()</span></code>,
or <code class="docutils literal notranslate"><span class="pre">MIRSetup</span> <span class="pre">()</span></code>.</p>
</section>
</section>
<section id="structure-of-a-specification">
<h2>Structure of a Specification<a class="headerlink" href="#structure-of-a-specification" title="Link to this heading"></a></h2>
<p>A specifications for Crucible consists of three logical components:</p>
<ul class="simple">
<li><p>A specification of the initial state before execution of the function.</p></li>
<li><p>A description of how to call the function within that state.</p></li>
<li><p>A specification of the expected final value of the program state.</p></li>
</ul>
<p>These three portions of the specification are written in sequence within a <code class="docutils literal notranslate"><span class="pre">do</span></code>
block of type <code class="docutils literal notranslate"><span class="pre">{LLVM,JVM,MIR}Setup</span></code>. The command <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_execute_func</span></code>
separates the specification of the initial state from the specification of the
final state, and specifies the arguments to the function in terms of the
initial state. Most of the commands available for state description will work
either before or after <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_execute_func</span></code>, though with slightly
different meaning, as described below.</p>
</section>
<section id="creating-fresh-variables">
<h2>Creating Fresh Variables<a class="headerlink" href="#creating-fresh-variables" title="Link to this heading"></a></h2>
<p>In any case where you want to prove a property of a function for an entire
class of inputs (perhaps all inputs) rather than concrete values, the initial
values of at least some elements of the program state must contain fresh
variables. These are created in a specification with the
<code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_fresh_var</span></code> commands rather than <code class="docutils literal notranslate"><span class="pre">fresh_symbolic</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_fresh_var</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">Term</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_fresh_var</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JavaType</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">Term</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">Term</span></code></p></li>
</ul>
<p>The first parameter to both functions is a name, used only for
presentation. It’s possible (though not recommended) to create multiple
variables with the same name, but SAW will distinguish between them
internally. The second parameter is the LLVM, Java, or MIR type of the
variable. The resulting <code class="docutils literal notranslate"><span class="pre">Term</span></code> can be used in various subsequent
commands.</p>
<p>Note that the second parameter to <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_fresh_var</span></code> must be a type
that has a counterpart in Cryptol. (For more information on this, refer to the
“Cryptol type correspondence” section.) If the type does not have a Cryptol
counterpart, the function will raise an error. If you do need to create a fresh
value of a type that cannot be represented in Cryptol, consider using a
function such as <code class="docutils literal notranslate"><span class="pre">llvm_fresh_expanded_val</span></code> (for LLVM verification) or
<code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> (for MIR verification).</p>
<p>LLVM types are built with this set of functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_int</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_alias</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_array</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_float</span> <span class="pre">:</span> <span class="pre">LLVMType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_double</span> <span class="pre">:</span> <span class="pre">LLVMType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_packed_struct</span> <span class="pre">:</span> <span class="pre">[LLVMType]</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_struct_type</span> <span class="pre">:</span> <span class="pre">[LLVMType]</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span></code></p></li>
</ul>
<p>Java types are built up using the following functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">java_bool</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_byte</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_char</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_short</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_int</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_long</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_float</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_double</span> <span class="pre">:</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_class</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JavaType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_array</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">JavaType</span> <span class="pre">-&gt;</span> <span class="pre">JavaType</span></code></p></li>
</ul>
<p>MIR types are built up using the following functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_adt</span> <span class="pre">:</span> <span class="pre">MIRAdt</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_array</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_bool</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_char</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i8</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i6</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i32</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i64</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i128</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_isize</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_f32</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_f64</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_lifetime</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_raw_ptr_const</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_raw_ptr_mut</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_ref</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_ref_mut</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_slice</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_str</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_tuple</span> <span class="pre">:</span> <span class="pre">[MIRType]</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_u8</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_u6</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_u32</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_u64</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_u128</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_usize</span> <span class="pre">:</span> <span class="pre">MIRType</span></code></p></li>
</ul>
<p>Most of these types are straightforward mappings to the standard LLVM
and Java types. The one key difference is that arrays must have a fixed,
concrete size. Therefore, all analysis results are valid only under the
assumption that any arrays have the specific size indicated, and may not
hold for other sizes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm_int</span></code> function takes an <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter indicating the variable’s bit
width. For example, the C <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code> and <code class="docutils literal notranslate"><span class="pre">int16_t</span></code> types correspond to
<code class="docutils literal notranslate"><span class="pre">llvm_int</span> <span class="pre">16</span></code>. The C <code class="docutils literal notranslate"><span class="pre">bool</span></code> type is slightly trickier. A bare <code class="docutils literal notranslate"><span class="pre">bool</span></code> type
typically corresponds to <code class="docutils literal notranslate"><span class="pre">llvm_int</span> <span class="pre">1</span></code>, but if a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is a member of a
composite type such as a pointer, array, or struct, then it corresponds to
<code class="docutils literal notranslate"><span class="pre">llvm_int</span> <span class="pre">8</span></code>. This is due to a peculiarity in the way Clang compiles <code class="docutils literal notranslate"><span class="pre">bool</span></code>
down to LLVM.  When in doubt about how a <code class="docutils literal notranslate"><span class="pre">bool</span></code> is represented, check the LLVM
bitcode by compiling your code with <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-S</span> <span class="pre">-emit-llvm</span></code>.</p>
<p>LLVM types can also be specified in LLVM syntax directly by using the
<code class="docutils literal notranslate"><span class="pre">llvm_type</span></code> function.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_type</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span></code></p></li>
</ul>
<p>For example, <code class="docutils literal notranslate"><span class="pre">llvm_type</span> <span class="pre">&quot;i32&quot;</span></code> yields the same result as <code class="docutils literal notranslate"><span class="pre">llvm_int</span> <span class="pre">32</span></code>.</p>
<p>The most common use for creating fresh variables is to state that a
particular function should have the specified behaviour for arbitrary
initial values of the variables in question. Sometimes, however, it can
be useful to specify that a function returns (or stores, more about this
later) an arbitrary value, without specifying what that value should be.
To express such a pattern, you can also run <code class="docutils literal notranslate"><span class="pre">llvm_fresh_var</span></code> from
the post state (i.e., after <code class="docutils literal notranslate"><span class="pre">llvm_execute_func</span></code>).</p>
</section>
<section id="the-llvmvalue-jvmvalue-and-mirvalue-types">
<h2>The LLVMValue, JVMValue, and MIRValue Types<a class="headerlink" href="#the-llvmvalue-jvmvalue-and-mirvalue-types" title="Link to this heading"></a></h2>
<p>Many specifications require reasoning about both pure values and about
the configuration of the heap.
The “setup value” types (<code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code>, <code class="docutils literal notranslate"><span class="pre">JVMValue</span></code>, and <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>)
correspond to
values that can occur during symbolic execution, which includes both
<code class="docutils literal notranslate"><span class="pre">Term</span></code> values, pointers, and composite types consisting of either of
these (both structures and arrays).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm_term</span></code>, <code class="docutils literal notranslate"><span class="pre">jvm_term</span></code>, and <code class="docutils literal notranslate"><span class="pre">mir_term</span></code> functions create a <code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code>,
<code class="docutils literal notranslate"><span class="pre">JVMValue</span></code>, or <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>, respectively, from a <code class="docutils literal notranslate"><span class="pre">Term</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_term</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_term</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_term</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>The value that these functions return will have an LLVM, JVM, or MIR type
corresponding to the Cryptol type of the <code class="docutils literal notranslate"><span class="pre">Term</span></code> argument. (For more information
on this, refer to the “Cryptol type correspondence” section.) If the type does
not have a Cryptol counterpart, the function will raise an error.</p>
<section id="cryptol-type-correspondence">
<h3>Cryptol type correspondence<a class="headerlink" href="#cryptol-type-correspondence" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_fresh_var</span></code> functions take an LLVM, JVM, or MIR type as an
argument and produces a <code class="docutils literal notranslate"><span class="pre">Term</span></code> variable of the corresponding Cryptol type as
output. Similarly, the <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_term</span></code> functions take a Cryptol <code class="docutils literal notranslate"><span class="pre">Term</span></code> as
input and produce a value of the corresponding LLVM, JVM, or MIR type as
output. This section describes precisely which types can be converted to
Cryptol types (and vice versa) in this way.</p>
<section id="llvm-verification">
<h4>LLVM verification<a class="headerlink" href="#llvm-verification" title="Link to this heading"></a></h4>
<p>The following LLVM types correspond to Cryptol types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_alias</span> <span class="pre">&lt;name&gt;</span></code>: Corresponds to the same Cryptol type as the type used
in the definition of <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_array</span> <span class="pre">&lt;n&gt;</span> <span class="pre">&lt;ty&gt;</span></code>: Corresponds to the Cryptol sequence <code class="docutils literal notranslate"><span class="pre">[&lt;n&gt;][&lt;cty&gt;]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">&lt;cty&gt;</span></code> is the Cryptol type corresponding to <code class="docutils literal notranslate"><span class="pre">&lt;ty&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_int</span> <span class="pre">&lt;n&gt;</span></code>: Corresponds to the Cryptol word <code class="docutils literal notranslate"><span class="pre">[&lt;n&gt;]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_struct_type</span> <span class="pre">[&lt;ty_1&gt;,</span> <span class="pre">...,</span> <span class="pre">&lt;ty_n&gt;]</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm_packed_struct</span> <span class="pre">[&lt;ty_1&gt;,</span> <span class="pre">...,</span> <span class="pre">&lt;ty_n&gt;]</span></code>:
Corresponds to the Cryptol tuple <code class="docutils literal notranslate"><span class="pre">(&lt;cty_1&gt;,</span> <span class="pre">...,</span> <span class="pre">&lt;cty_n&gt;)</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;cty_i&gt;</span></code>
is the Cryptol type corresponding to <code class="docutils literal notranslate"><span class="pre">&lt;ty_i&gt;</span></code> for each <code class="docutils literal notranslate"><span class="pre">i</span></code> ranging from <code class="docutils literal notranslate"><span class="pre">1</span></code>
to <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
</ul>
<p>The following LLVM types do <em>not</em> correspond to Cryptol types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_double</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_float</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_pointer</span></code></p></li>
</ul>
</section>
<section id="jvm-verification">
<h4>JVM verification<a class="headerlink" href="#jvm-verification" title="Link to this heading"></a></h4>
<p>The following Java types correspond to Cryptol types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">java_array</span> <span class="pre">&lt;n&gt;</span> <span class="pre">&lt;ty&gt;</span></code>: Corresponds to the Cryptol sequence <code class="docutils literal notranslate"><span class="pre">[&lt;n&gt;][&lt;cty&gt;]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">&lt;cty&gt;</span></code> is the Cryptol type corresponding to <code class="docutils literal notranslate"><span class="pre">&lt;ty&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_bool</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">Bit</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_byte</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[8]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_char</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[16]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_int</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[32]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_long</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[64]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_short</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[16]</span></code> type.</p></li>
</ul>
<p>The following Java types do <em>not</em> correspond to Cryptol types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">java_class</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_double</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">java_float</span></code></p></li>
</ul>
</section>
<section id="mir-verification">
<h4>MIR verification<a class="headerlink" href="#mir-verification" title="Link to this heading"></a></h4>
<p>The following MIR types correspond to Cryptol types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_array</span> <span class="pre">&lt;n&gt;</span> <span class="pre">&lt;ty&gt;</span></code>: Corresponds to the Cryptol sequence <code class="docutils literal notranslate"><span class="pre">[&lt;n&gt;][&lt;cty&gt;]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">&lt;cty&gt;</span></code> is the Cryptol type corresponding to <code class="docutils literal notranslate"><span class="pre">&lt;ty&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_bool</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">Bit</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_char</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[32]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i8</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_u8</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[8]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i16</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_u16</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[16]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i32</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_u32</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[32]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i64</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_u64</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[64]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_i128</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_u128</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[128]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_isize</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_usize</span></code>: Corresponds to the Cryptol <code class="docutils literal notranslate"><span class="pre">[64]</span></code> type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_tuple</span> <span class="pre">[&lt;ty_1&gt;,</span> <span class="pre">...,</span> <span class="pre">&lt;ty_n&gt;]</span></code>: Corresponds to the Cryptol tuple
<code class="docutils literal notranslate"><span class="pre">(&lt;cty_1&gt;,</span> <span class="pre">...,</span> <span class="pre">&lt;cty_n&gt;)</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;cty_i&gt;</span></code> is the Cryptol type corresponding
to <code class="docutils literal notranslate"><span class="pre">&lt;ty_i&gt;</span></code> for each <code class="docutils literal notranslate"><span class="pre">i</span></code> ranging from <code class="docutils literal notranslate"><span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
</ul>
<p>The following MIR types do <em>not</em> correspond to Cryptol types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_adt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_f32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_f64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_ref</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_ref_mut</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_raw_ptr_const</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_raw_ptr_mut</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_slice</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_str</span></code></p></li>
</ul>
</section>
</section>
</section>
<section id="executing">
<h2>Executing<a class="headerlink" href="#executing" title="Link to this heading"></a></h2>
<p>Once the initial state has been configured, the <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_execute_func</span></code>
command specifies the parameters of the function being analyzed in terms
of the state elements already configured.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_execute_func</span> <span class="pre">:</span> <span class="pre">[LLVMValue]</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_execute_func</span> <span class="pre">:</span> <span class="pre">[JVMValue]</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_execute_func</span> <span class="pre">:</span> <span class="pre">[MIRValue]</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
</ul>
</section>
<section id="return-values">
<h2>Return Values<a class="headerlink" href="#return-values" title="Link to this heading"></a></h2>
<p>To specify the value that should be returned by the function being
verified use the <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_return</span></code> command.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_return</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_return</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_return</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
</ul>
</section>
<section id="a-first-simple-example-revisited">
<h2>A First Simple Example (Revisited)<a class="headerlink" href="#a-first-simple-example-revisited" title="Link to this heading"></a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This section is under construction!</p>
<p>See <a class="reference internal" href="structure-of-sawscript.html#first-simple-example"><span class="std std-ref">the example’s introduction</span></a>.</p>
</div>
</section>
<section id="compositional-verification">
<span id="id1"></span><h2>Compositional Verification<a class="headerlink" href="#compositional-verification" title="Link to this heading"></a></h2>
<p>The primary advantage of the specification-based approach to
verification is that it allows for compositional reasoning. That is,
when proving properties of a given method or function, we can make use
of properties we have already proved about its callees rather than
analyzing them anew. This enables us to reason about much larger
and more complex systems than otherwise possible.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm_verify</span></code>, <code class="docutils literal notranslate"><span class="pre">jvm_verify</span></code>, and <code class="docutils literal notranslate"><span class="pre">mir_verify</span></code> functions return values of
type <code class="docutils literal notranslate"><span class="pre">CrucibleMethodSpec</span></code>, <code class="docutils literal notranslate"><span class="pre">JVMMethodSpec</span></code>, and <code class="docutils literal notranslate"><span class="pre">MIRMethodSpec</span></code>, respectively.
These values are opaque objects that internally contain both the information
provided in the associated <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span></code>, <code class="docutils literal notranslate"><span class="pre">JVMSetup</span></code>, or <code class="docutils literal notranslate"><span class="pre">MIRSetup</span></code> blocks,
respectively, and the results of the verification process.</p>
<p>Any of these <code class="docutils literal notranslate"><span class="pre">MethodSpec</span></code> objects can be passed in via the third
argument of the <code class="docutils literal notranslate"><span class="pre">..._verify</span></code> functions. For any function or method
specified by one of these parameters, the simulator will not follow
calls to the associated target. Instead, it will perform the following
steps:</p>
<ul class="simple">
<li><p>Check that all <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm_precond</span></code> statements
(or the corresponding JVM or MIR statements) in the specification are
satisfied.</p></li>
<li><p>Update the simulator state and optionally construct a return value as
described in the specification.</p></li>
</ul>
<p>More concretely, building on the previous example, say we have a
doubling function written in terms of <code class="docutils literal notranslate"><span class="pre">add</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">dbl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It has a similar specification to <code class="docutils literal notranslate"><span class="pre">add</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">dbl_setup</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>
<span class="w">    </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">x</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>And we can verify it using what we’ve already proved about <code class="docutils literal notranslate"><span class="pre">add</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;dbl&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">add_ms</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">dbl_setup</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case, doing the verification compositionally doesn’t save
computational effort, since the functions are so simple, but it
illustrates the approach.</p>
<section id="compositional-verification-and-mutable-allocations">
<h3>Compositional Verification and Mutable Allocations<a class="headerlink" href="#compositional-verification-and-mutable-allocations" title="Link to this heading"></a></h3>
<p>A common pitfall when using compositional verification is to reuse a
specification that underspecifies the value of a mutable allocation. In
general, doing so can lead to unsound verification, so SAW goes through great
lengths to check for this.</p>
<p>Here is an example of this pitfall in an LLVM verification. Given this C code:</p>
<div class="c docutils">
<p>void side_effect(uint32_t *a) {
*a = 0;
}</p>
<p>uint32_t foo(uint32_t x) {
uint32_t b = x;
side_effect(&amp;b);
return b;
}</p>
</div>
<p>And the following SAW specifications:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a_ptr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">  </span><span class="n">a_val</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;a_val&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">  </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">a_ptr</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">a_val</span><span class="p">);</span>

<span class="w">  </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">a_ptr</span><span class="p">];</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="w">  </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Should SAW be able to verify the <code class="docutils literal notranslate"><span class="pre">foo</span></code> function against <code class="docutils literal notranslate"><span class="pre">foo_spec</span></code> using
compositional verification? That is, should the following be expected to work?</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">side_effect_ov</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;side_effect&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">side_effect_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>A literal reading of <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> would suggest that the <code class="docutils literal notranslate"><span class="pre">side_effect</span></code>
function allocates <code class="docutils literal notranslate"><span class="pre">a_ptr</span></code> but then does nothing with it, implying that <code class="docutils literal notranslate"><span class="pre">foo</span></code>
returns its argument unchanged. This is incorrect, however, as the
<code class="docutils literal notranslate"><span class="pre">side_effect</span></code> function actually changes its argument to point to <code class="docutils literal notranslate"><span class="pre">0</span></code>, so the
<code class="docutils literal notranslate"><span class="pre">foo</span></code> function ought to return <code class="docutils literal notranslate"><span class="pre">0</span></code> as a result. SAW should not verify <code class="docutils literal notranslate"><span class="pre">foo</span></code>
against <code class="docutils literal notranslate"><span class="pre">foo_spec</span></code>, and indeed it does not.</p>
<p>The problem is that <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> underspecifies the value of <code class="docutils literal notranslate"><span class="pre">a_ptr</span></code> in
its postconditions, which can lead to the potential unsoundness seen above when
<code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> is used in compositional verification. To prevent this
source of unsoundness, SAW will <em>invalidate</em> the underlying memory of any
mutable pointers (i.e., those declared with <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code>, not
<code class="docutils literal notranslate"><span class="pre">llvm_alloc_global</span></code>) allocated in the preconditions of compositional override
that do not have a corresponding <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> statement in the
postconditions. Attempting to read from invalidated memory constitutes an
error, as can be seen in this portion of the error message when attempting to
verify <code class="docutils literal notranslate"><span class="pre">foo</span></code> against <code class="docutils literal notranslate"><span class="pre">foo_spec</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">invalidate (state of memory allocated in precondition (at side.saw:3:12) not described in postcondition)</span>
</pre></div>
</div>
<p>To fix this particular issue, add an <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> statement to
<code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a_ptr</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">  </span><span class="n">a_val</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;a_val&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">  </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">a_ptr</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">a_val</span><span class="p">);</span>

<span class="w">  </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">a_ptr</span><span class="p">];</span>

<span class="w">  </span><span class="c c-Singleline">// This is new</span>
<span class="w">  </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">a_ptr</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>After making this change, SAW will reject <code class="docutils literal notranslate"><span class="pre">foo_spec</span></code> for a different reason, as
it claims that <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns its argument unchanged when it actually returns
<code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Note that invalidating memory itself does not constitute an error, so if the
<code class="docutils literal notranslate"><span class="pre">foo</span></code> function never read the value of <code class="docutils literal notranslate"><span class="pre">b</span></code> after calling <code class="docutils literal notranslate"><span class="pre">side_effect(&amp;b)</span></code>,
then there would be no issue. It is only when a function attempts to <em>read</em>
from invalidated memory that an error is thrown. In general, it can be
difficult to predict when a function will or will not read from invalidated
memory, however. For this reason, it is recommended to always specify the
values of mutable allocations in the postconditions of your specs, as it can
avoid pitfalls like the one above.</p>
<p>The same pitfalls apply to compositional MIR verification, with a couple of key
differences. In MIR verification, mutable references are allocated using
<code class="docutils literal notranslate"><span class="pre">mir_alloc_mut</span></code>. Here is a Rust version of the pitfall program above:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">side_effect</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">side_effect</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">b</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a_ref</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_alloc_mut</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>
<span class="w">  </span><span class="n">a_val</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;a_val&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="n">a_ref</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="n">a_val</span><span class="p">);</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">a_ref</span><span class="p">];</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">x</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Just like above, if you attempted to prove <code class="docutils literal notranslate"><span class="pre">foo</span></code> against <code class="docutils literal notranslate"><span class="pre">foo_spec</span></code> using
compositional verification:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">side_effect_ov</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;test::side_effect&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="nb">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;test::foo&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">side_effect_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Then SAW would throw an error, as <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> underspecifies the value
of <code class="docutils literal notranslate"><span class="pre">a_ref</span></code> in its postconditions. <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> can similarly be repaired
by adding a <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code> statement involving <code class="docutils literal notranslate"><span class="pre">a_ref</span></code> in <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code>’s
postconditions.</p>
<p>MIR verification differs slightly from LLVM verification in how it catches
underspecified mutable allocations when using compositional overrides. The LLVM
memory model achieves this by invalidating the underlying memory in
underspecified allocations. The MIR memory model, on the other hand, does not
have a direct counterpart to memory invalidation. As a result, any MIR overrides
must specify the values of all mutable allocations in their postconditions,
<em>even if the function that calls the override never uses the allocations</em>.</p>
<p>To illustrate this point more finely, suppose that the <code class="docutils literal notranslate"><span class="pre">foo</span></code> function had
instead been defined like this:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">side_effect</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, it does not particularly matter what effects the <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> function
has on its argument, as <code class="docutils literal notranslate"><span class="pre">foo</span></code> will now return <code class="docutils literal notranslate"><span class="pre">42</span></code> regardless. Still, if you
attempt to prove <code class="docutils literal notranslate"><span class="pre">foo</span></code> by using <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> as a compositional override, then
it is strictly required that you specify the value of <code class="docutils literal notranslate"><span class="pre">side_effect</span></code>’s argument
in its postconditions, even though the answer that <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns is unaffected
by this. This is in contrast with LLVM verification, where one could get away
without specifying <code class="docutils literal notranslate"><span class="pre">side_effect</span></code>’s argument in this example, as the invalidated
memory in <code class="docutils literal notranslate"><span class="pre">b</span></code> would never be read.</p>
</section>
<section id="compositional-verification-and-mutable-global-variables">
<span id="id2"></span><h3>Compositional Verification and Mutable Global Variables<a class="headerlink" href="#compositional-verification-and-mutable-global-variables" title="Link to this heading"></a></h3>
<p>Just like with local mutable allocations (see the previous section),
specifications used in compositional overrides must specify the values of
mutable global variables in their postconditions. To illustrate this using LLVM
verification, here is a variant of the C program from the previous example that
uses a mutable global variable <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">side_effect</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">side_effect</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we attempted to verify <code class="docutils literal notranslate"><span class="pre">foo</span></code> against this <code class="docutils literal notranslate"><span class="pre">foo_spec</span></code> specification using
compositional verification:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">llvm_alloc_global</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_global</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">llvm_global_initializer</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[];</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">llvm_alloc_global</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_global</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">llvm_global_initializer</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="n">llvm_global_initializer</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">side_effect_ov</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;side_effect&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">side_effect_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Then SAW would reject it, as <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> does not specify what <code class="docutils literal notranslate"><span class="pre">a</span></code>’s
value should be in its postconditions. Just as with local mutable allocations,
SAW will invalidate the underlying memory in <code class="docutils literal notranslate"><span class="pre">a</span></code>, and subsequently reading from
<code class="docutils literal notranslate"><span class="pre">a</span></code> in the <code class="docutils literal notranslate"><span class="pre">foo</span></code> function will throw an error. The solution is to add an
<code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> statement in the postconditions that declares that <code class="docutils literal notranslate"><span class="pre">a</span></code>’s value
is set to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The same concerns apply to MIR verification, where mutable global variables are
referred to as <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">mut</span></code> items. (See the <a class="reference internal" href="#mir-static-items">MIR static
items</a> section for more information). Here is a Rust version
of the program above:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">side_effect</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">side_effect</span><span class="p">();</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_static</span><span class="w"> </span><span class="s2">&quot;test::A&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mir_static_initializer</span><span class="w"> </span><span class="s2">&quot;test::A&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[];</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_static</span><span class="w"> </span><span class="s2">&quot;test::A&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mir_static_initializer</span><span class="w"> </span><span class="s2">&quot;test::A&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="n">mir_static_initializer</span><span class="w"> </span><span class="s2">&quot;test::A&quot;</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">side_effect_ov</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;side_effect&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">side_effect_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
<span class="nb">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">side_effect_ov</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">foo_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>Just as above, we can repair this by adding a <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code> statement in
<code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code>’s postconditions that specifies that <code class="docutils literal notranslate"><span class="pre">A</span></code> is set to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Recall from the previous section that MIR verification is stricter than LLVM
verification when it comes to specifying mutable allocations in the
postconditions of compositional overrides. This is especially true for mutable
static items. In MIR verification, any compositional overrides must specify the
values of all mutable static items in the entire program in their
postconditions, <em>even if the function that calls the override never uses the
static items</em>. For example, if the <code class="docutils literal notranslate"><span class="pre">foo</span></code> function were instead defined like
this:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">side_effect</span><span class="p">();</span>
<span class="w">    </span><span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then it is still required for <code class="docutils literal notranslate"><span class="pre">side_effect_spec</span></code> to specify what <code class="docutils literal notranslate"><span class="pre">A</span></code>’s value
will be in its postconditions, despite the fact that this has no effect on the
value that <code class="docutils literal notranslate"><span class="pre">foo</span></code> will return.</p>
</section>
</section>
<section id="specifying-heap-layout">
<h2>Specifying Heap Layout<a class="headerlink" href="#specifying-heap-layout" title="Link to this heading"></a></h2>
<p>Most functions that operate on pointers expect that certain pointers
point to allocated memory before they are called. The <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code>
command allows you to specify that a function expects a particular
pointer to refer to an allocated region appropriate for a specific type.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_alloc</span> <span class="pre">:</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>This command returns a <code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code> consisting of a pointer to the
allocated space, which can be used wherever a pointer-valued
<code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code> can be used.</p>
<p>In the initial state, <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code> specifies that the function
expects a pointer to allocated space to exist. In the final state, it
specifies that the function itself performs an allocation.</p>
<p>In LLVM, it’s also possible to construct fresh pointers that do not
point to allocated memory (which can be useful for functions that
manipulate pointers but not the values they point to):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_fresh_pointer</span> <span class="pre">:</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>The NULL pointer is called <code class="docutils literal notranslate"><span class="pre">llvm_null</span></code> in LLVM and <code class="docutils literal notranslate"><span class="pre">jvm_null</span></code> in
JVM:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_null</span> <span class="pre">:</span> <span class="pre">LLVMValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_null</span> <span class="pre">:</span> <span class="pre">JVMValue</span></code></p></li>
</ul>
<p>One final, slightly more obscure command is the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_alloc_readonly</span> <span class="pre">:</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>This works like <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code> except that writes to the space
allocated are forbidden. This can be useful for specifying that a
function should take as an argument a pointer to allocated space that it
will not modify. Unlike <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code>, regions allocated with
<code class="docutils literal notranslate"><span class="pre">llvm_alloc_readonly</span></code> are allowed to alias other read-only regions.</p>
<p>When using the experimental Java implementation, separate functions
exist for specifying that arrays or objects are allocated:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_alloc_array</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">JavaType</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">JVMValue</span></code> specifies an
array of the given concrete size, with elements of the given type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_alloc_object</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">JVMValue</span></code> specifies an object
of the given class name.</p></li>
</ul>
<p>The experimental MIR implementation also has a <code class="docutils literal notranslate"><span class="pre">mir_alloc</span></code> function, which
behaves similarly to <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code>. <code class="docutils literal notranslate"><span class="pre">mir_alloc</span></code> creates an immutable reference,
but there is also a <code class="docutils literal notranslate"><span class="pre">mir_alloc_mut</span></code> function for creating a mutable reference:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_alloc</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_alloc_mut</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>MIR tracks whether references are mutable or immutable at the type level, so it
is important to use the right allocation command for a given reference type.</p>
<p>In addition, MIR also has immutable and mutable raw pointers, written in Rust as
<code class="docutils literal notranslate"><span class="pre">*const</span> <span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">*mut</span> <span class="pre">T</span></code> respectively. As far as SAW is concerned, they behave
similarly to references, and they can be created with <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_const</span></code>
and <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_mut</span></code> respectively.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_const</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_mut</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>In low-level Rust code, it is possible to get a raw pointer into an allocation
of multiple values, do pointer arithmetic on it, and then read from or write to
various values within the allocation. The <code class="docutils literal notranslate"><span class="pre">crucible-mir</span></code> memory model keeps
track of these allocation sizes to check the validity of these pointer
operations. <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_const</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_mut</span></code> create
single-value allocations which don’t allow for pointer arithmetic. To model
pointers which point to allocations containing multiple values, there are the
<code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_const_multi</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_mut_multi</span></code> commands:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_const_multi</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_mut_multi</span> <span class="pre">:</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Int</span></code> argument specifies how many values of the given type there are (<em>not</em>
the size in bytes). If <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_{const,mut}_multi</span> <span class="pre">n</span></code> is used in the
pre-state section of a specification (before <code class="docutils literal notranslate"><span class="pre">mir_execute_func</span></code>), it will create
an allocation of <code class="docutils literal notranslate"><span class="pre">n</span></code> values, with the pointer pointing to the first value in
that allocation. However, if used in the post-state section (after
<code class="docutils literal notranslate"><span class="pre">mir_execute_func</span></code>), the raw pointer <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code> is able to be matched against a
raw pointer into a larger allocation produced by the function. The only
requirement is that the pointer points to a contiguous sequence of <code class="docutils literal notranslate"><span class="pre">n</span></code> values
within some allocation; the allocation is allowed to contain more values before
or after those <code class="docutils literal notranslate"><span class="pre">n</span></code> values.</p>
</section>
<section id="specifying-heap-values">
<h2>Specifying Heap Values<a class="headerlink" href="#specifying-heap-values" title="Link to this heading"></a></h2>
<p>Pointers returned by <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code>, <code class="docutils literal notranslate"><span class="pre">jvm_alloc_{array,object}</span></code>, or
<code class="docutils literal notranslate"><span class="pre">mir_alloc{,_mut,_ptr_const,_ptr_mut}</span></code> don’t initially point to anything. So if
you pass such a pointer directly into a function that tried to dereference it,
symbolic execution will fail with a message about an invalid load. For some
functions, such as those that are intended to initialize data structures
(writing to the memory pointed to, but never reading from it), this sort of
uninitialized memory is appropriate. In most cases, however, it’s more useful to
state that a pointer points to some specific (usually symbolic) value, which you
can do with the <em>points-to</em> family of commands.</p>
<section id="llvm-heap-values">
<h3>LLVM heap values<a class="headerlink" href="#llvm-heap-values" title="Link to this heading"></a></h3>
<p>LLVM verification primarily uses the <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> command:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_points_to</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code>
takes two <code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code> arguments, the first of which must be a pointer,
and states that the memory specified by that pointer should contain the
value given in the second argument (which may be any type of
<code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code>).</p></li>
</ul>
<p>When used in the final state, <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> specifies that the
given pointer <em>should</em> point to the given value when the function
finishes.</p>
<p>Occasionally, because C programs frequently reinterpret memory of one
type as another through casts, it can be useful to specify that a
pointer points to a value that does not agree with its static type.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_points_to_untyped</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code> works like <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> but omits type
checking. Rather than omitting type checking across the board, we
introduced this additional function to make it clear when a type
reinterpretation is intentional. As an alternative, one
may instead use <code class="docutils literal notranslate"><span class="pre">llvm_cast_pointer</span></code> to line up the static types.</p></li>
</ul>
</section>
<section id="jvm-heap-values">
<h3>JVM heap values<a class="headerlink" href="#jvm-heap-values" title="Link to this heading"></a></h3>
<p>JVM verification has two categories of commands for specifying heap values.
One category consists of the <code class="docutils literal notranslate"><span class="pre">jvm_*_is</span></code> commands, which allow users to directly
specify what value a heap object points to. There are specific commands for
each type of JVM heap object:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_array_is</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code> declares that an array (the
first argument) contains a sequence of values (the second argument).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_elem_is</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code> declares that an
array (the first argument) has an element at the given index (the second
argument) containing the given value (the third argument).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_field_is</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code> declares that
an object (the first argument) has a field (the second argument) containing
the given value (the third argument).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_static_field_is</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code> declares that a
named static field (the first argument) contains the given value (the second
argument). By default, the field name is assumed to belong to the same class
as the method being specified. Static fields belonging to other classes can
be selected using the <code class="docutils literal notranslate"><span class="pre">&lt;classname&gt;.&lt;fieldname&gt;</span></code> syntax in the first argument.</p></li>
</ul>
<p>Another category consists of the <code class="docutils literal notranslate"><span class="pre">jvm_modifies_*</span></code> commands. Like the <code class="docutils literal notranslate"><span class="pre">jvm_*_is</span></code>
commands, these specify that a JVM heap object points to valid memory, but
unlike the <code class="docutils literal notranslate"><span class="pre">jvm_*_is</span></code> commands, they leave the exact value being pointed to as
unspecified. These are useful for writing partial specifications for methods
that modify some heap value, but without saying anything specific about the new
value.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_modifies_array</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_modifies_elem</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_modifies_field</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_modifies_static_field</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
</ul>
</section>
<section id="mir-heap-values">
<h3>MIR heap values<a class="headerlink" href="#mir-heap-values" title="Link to this heading"></a></h3>
<p>MIR verification primarily uses the <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code> command:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_points_to</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code> takes two <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>
arguments, the first of which must be a reference or raw pointer, and states
that the memory specified by that reference or raw pointer should contain the
value given in the second argument (which may be any type of <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>).</p></li>
</ul>
<p>As a convenience, SAW also provides:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_ref_of</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_ref_of_mut</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>which combine <code class="docutils literal notranslate"><span class="pre">mir_alloc</span></code>/<code class="docutils literal notranslate"><span class="pre">mir_alloc_mut</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code> into a single
operation.</p>
<p>Some low-level Rust code involves casting raw pointers, resulting in raw
pointers which point to values of a different type than what the raw pointer’s
static type claims. This can be modeled in SAW using the <code class="docutils literal notranslate"><span class="pre">mir_cast_raw_ptr</span></code>
command:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_cast_raw_ptr</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code> takes a raw pointer and a
type, and returns a raw pointer to the same memory location and with the same
mutability as the given pointer, but with the given type as the static pointee
type instead.</p></li>
</ul>
<p>Unlike in the LLVM backend, this does <em>not</em> allow for reinterpretation of
memory. If a raw pointer points to an allocation that is actually of type <code class="docutils literal notranslate"><span class="pre">T</span></code>,
the pointer can be cast and passed around and stored as a pointer to another
type, but it must be casted back to <code class="docutils literal notranslate"><span class="pre">*T</span></code> when it is actually dereferenced.
Accordingly, SAW enforces that <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code> can only be used on a non-casted
pointer, so that the value in the second argument matches the type passed to the
<code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr</span></code> that created the raw pointer in the first argument.
<code class="docutils literal notranslate"><span class="pre">mir_cast_raw_ptr</span></code> can be used, though, whenever some Rust signature is
expecting a pointer whose static pointee type does not match its “true” type at
runtime.</p>
<p>For raw pointers to contiguous sequences of multiple values, created by
<code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_const_multi</span></code> and <code class="docutils literal notranslate"><span class="pre">mir_alloc_raw_ptr_mut_multi</span></code>, the
<code class="docutils literal notranslate"><span class="pre">mir_points_to_multi</span></code> command can be used to specify the multiple values.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_points_to_multi</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
</ul>
<p>The second argument must have a MIR array type, and it specifies the sequence of
pointed-to values as a MIR array. Specifically, if the first argument is a raw
pointer to a contiguous sequence of <code class="docutils literal notranslate"><span class="pre">n</span></code> values of type <code class="docutils literal notranslate"><span class="pre">ty</span></code>, the second argument
must have the MIR type <code class="docutils literal notranslate"><span class="pre">mir_array</span> <span class="pre">m</span> <span class="pre">ty</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>. Note that the second
argument need not be constructed with <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code>; it can also be derived
from a fresh variable or a Cryptol sequence expression. Also note that the
pointed-to values are not (necessarily) the contents of an array in the actual
MIR semantics; their corresponding <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code>s are just represented as an array
in SAWScript specs, for ease of conversion from Cryptol sequences.</p>
</section>
</section>
<section id="working-with-compound-types">
<h2>Working with Compound Types<a class="headerlink" href="#working-with-compound-types" title="Link to this heading"></a></h2>
<p>The commands mentioned so far give us no way to specify the values of
compound types (arrays or <code class="docutils literal notranslate"><span class="pre">struct</span></code>s). Compound values can be dealt with
either piecewise or in their entirety.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_elem</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code> yields a pointer to
an internal element of a compound value. For arrays, the <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter
is the array index. For <code class="docutils literal notranslate"><span class="pre">struct</span></code> values, it is the field index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_field</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code> yields a pointer
to a particular named <code class="docutils literal notranslate"><span class="pre">struct</span></code> field, if debugging information is
available in the bitcode.</p></li>
</ul>
<p>Either of these functions can be used with <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> to
specify the value of a particular array element or <code class="docutils literal notranslate"><span class="pre">struct</span></code> field.
Sometimes, however, it is more convenient to specify all array elements
or field values at once. The <code class="docutils literal notranslate"><span class="pre">llvm_array_value</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm_struct_value</span></code>
functions construct compound values from lists of element values.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_array_value</span> <span class="pre">:</span> <span class="pre">[LLVMValue]</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_struct_value</span> <span class="pre">:</span> <span class="pre">[LLVMValue]</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>To specify an array or struct in which each element or field is
symbolic, it would be possible, but tedious, to use a large combination
of <code class="docutils literal notranslate"><span class="pre">llvm_fresh_var</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm_elem</span></code> or <code class="docutils literal notranslate"><span class="pre">llvm_field</span></code> commands.
However, the following function can simplify the common case
where you want every element or field to have a fresh value.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_fresh_expanded_val</span> <span class="pre">:</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm_struct_value</span></code> function normally creates a <code class="docutils literal notranslate"><span class="pre">struct</span></code> whose layout
obeys the alignment rules of the platform specified in the LLVM file
being analyzed. Structs in LLVM can explicitly be “packed”, however, so
that every field immediately follows the previous in memory. The
following command will create values of such types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_packed_struct_value</span> <span class="pre">:</span> <span class="pre">[LLVMValue]</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>C programs will sometimes make use of pointer casting to implement
various kinds of polymorphic behaviors, either via direct pointer
casts, or by using <code class="docutils literal notranslate"><span class="pre">union</span></code> types to codify the pattern. To reason
about such cases, the following operation is useful.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_cast_pointer</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>This function function casts the type of the input value (which must be a
pointer) so that it points to values of the given type.  This mainly
affects the results of subsequent <code class="docutils literal notranslate"><span class="pre">llvm_field</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm_elem</span></code> calls,
and any eventual <code class="docutils literal notranslate"><span class="pre">points_to</span></code> statements that the resulting pointer
flows into.  This is especially useful for dealing with C <code class="docutils literal notranslate"><span class="pre">union</span></code>
types, as the type information provided by LLVM is imprecise in these
cases.</p>
<p>We can automate the process of applying pointer casts if we have debug
information avaliable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_union</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>Given a pointer setup value, this attempts to select the named union
branch and cast the type of the pointer. For this to work, debug
symbols must be included; moreover, the process of correlating LLVM
type information with information contained in debug symbols is a bit
heuristic. If <code class="docutils literal notranslate"><span class="pre">llvm_union</span></code> cannot figure out how to cast a pointer,
one can fall back on the more manual <code class="docutils literal notranslate"><span class="pre">llvm_cast_pointer</span></code> instead.</p>
<p>In the experimental Java verification implementation, the following
functions can be used to state the equivalent of a combination of
<code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> and either <code class="docutils literal notranslate"><span class="pre">llvm_elem</span></code> or <code class="docutils literal notranslate"><span class="pre">llvm_field</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_elem_is</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code> specifies
the value of an array element.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_field_is</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code>
specifies the name of an object field.</p></li>
</ul>
<p>In the experimental MIR verification implementation, the following functions
construct compound values:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_array_value</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">[MIRValue]</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code> constructs an array
of the given type whose elements consist of the given values. Supplying the
element type is necessary to support length-0 arrays.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_enum_value</span> <span class="pre">:</span> <span class="pre">MIRAdt</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">[MIRValue]</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code> constructs an
enum using a particular enum variant. The <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> arguments determines what
enum type to create, the <code class="docutils literal notranslate"><span class="pre">String</span></code> value determines the name of the variant to
use, and the <code class="docutils literal notranslate"><span class="pre">[MIRValue]</span></code> list are the values to use as elements in the
variant.</p>
<p>See the “Finding MIR algebraic data types” section (as well as the “Enums”
subsection) for more information on how to compute a <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> value to pass
to <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: see the “MIR slices” section below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: see the
“MIR slices” section below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: see the “MIR slices” section
below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_str_slice_range_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: see the
“MIR slices” section below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_struct_value</span> <span class="pre">:</span> <span class="pre">MIRAdt</span> <span class="pre">-&gt;</span> <span class="pre">[MIRValue]</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code> construct a struct
with the given list of values as elements. The <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> argument determines
what struct type to create.</p>
<p>See the “Finding MIR algebraic data types” section for more information on how
to compute a <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> value to pass to <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_tuple_value</span> <span class="pre">:</span> <span class="pre">[MIRValue]</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code> construct a tuple with the given
list of values as elements.</p></li>
</ul>
<p>To specify a compound value in which each element or field is symbolic, it
would be possible, but tedious, to use a large number of <code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code>
invocations in conjunction with the commands above. However, the following
function can simplify the common case where you want every element or field to
have a fresh value:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">String</span></code> argument denotes a prefix to use when generating the names of
fresh symbolic variables. The <code class="docutils literal notranslate"><span class="pre">MIRType</span></code> can be any type, with the exception of
reference types (or compound types that contain references as elements or
fields), which are not currently supported.</p>
<p>The following functions extract components of compound MIR values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_elem_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code> takes an array value and an
index, and returns the value in the array at that index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_elem_ref</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code> takes a reference (or raw
pointer) to an array, and an index, and returns a reference (resp. raw
pointer) to the element in the array at that index.</p></li>
</ul>
<p>Note that unlike <code class="docutils literal notranslate"><span class="pre">llvm_elem</span></code>, <code class="docutils literal notranslate"><span class="pre">mir_elem_ref</span></code> cannot be used to specify the value
of a specific index of an array reference without the whole array reference
already being initialized.</p>
<section id="mir-slices">
<h3>MIR slices<a class="headerlink" href="#mir-slices" title="Link to this heading"></a></h3>
<p>Slices are a unique form of compound type that is currently only used during
MIR verification. Unlike other forms of compound values, such as arrays, it is
not possible to directly construct a slice. Instead, one must take a slice of
an existing reference value that points to the thing being sliced.</p>
<p>SAW currently supports taking slices of arrays and strings.</p>
<section id="array-slices">
<h4>Array slices<a class="headerlink" href="#array-slices" title="Link to this heading"></a></h4>
<p>The following commands are used to construct slices of arrays:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: the SAWScript expression
<code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">base</span></code> is equivalent to the Rust expression <code class="docutils literal notranslate"><span class="pre">&amp;base[..]</span></code>,
i.e., a slice of the entirety of <code class="docutils literal notranslate"><span class="pre">base</span></code>. <code class="docutils literal notranslate"><span class="pre">base</span></code> must be a reference to an
array value (<code class="docutils literal notranslate"><span class="pre">&amp;[T;</span> <span class="pre">N]</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[T;</span> <span class="pre">N]</span></code>), not an array itself. The type of
<code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">base</span></code> will be <code class="docutils literal notranslate"><span class="pre">&amp;[T]</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is an immutable reference)
or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[T]</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is a mutable reference).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: the SAWScript
expression <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span> <span class="pre">base</span> <span class="pre">start</span> <span class="pre">end</span></code> is equivalent to the Rust
expression <code class="docutils literal notranslate"><span class="pre">&amp;base[start..end]</span></code>, i.e., a slice over a part of <code class="docutils literal notranslate"><span class="pre">base</span></code> which
ranges from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code>. <code class="docutils literal notranslate"><span class="pre">base</span></code> must be a reference to an array value
(<code class="docutils literal notranslate"><span class="pre">&amp;[T;</span> <span class="pre">N]</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[T;</span> <span class="pre">N]</span></code>), not an array itself. The type of
<code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">base</span></code> will be <code class="docutils literal notranslate"><span class="pre">&amp;[T]</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is an immutable reference)
or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[T]</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is a mutable reference).</p>
<p><code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> are assumed to be zero-indexed. <code class="docutils literal notranslate"><span class="pre">start</span></code> must not exceed
<code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">end</span></code> must not exceed the length of the array that <code class="docutils literal notranslate"><span class="pre">base</span></code> points
to.</p>
</li>
</ul>
<p>As an example of how to use these functions, consider this Rust function, which
accepts an arbitrary slice as an argument:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u32</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can write a specification that passes a slice to the array <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5]</span></code>
as an argument to <code class="docutils literal notranslate"><span class="pre">f</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">f_spec_1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_slice_value</span><span class="w"> </span><span class="n">a</span><span class="p">];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Alternatively, we can write a specification that passes a part of this array
over the range <code class="docutils literal notranslate"><span class="pre">[1..3]</span></code>, i.e., ranging from second element to the fourth.
Because this is a half-open range, the resulting slice has length 2:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">f_spec_2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">);</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_slice_range_value</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that we are passing <em>references</em> of arrays to <code class="docutils literal notranslate"><span class="pre">mir_slice_value</span></code> and
<code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span></code>. It would be an error to pass a bare array to these
functions, so the following specification would be invalid:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">f_fail_spec_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_slice_value</span><span class="w"> </span><span class="n">arr</span><span class="p">];</span><span class="w"> </span><span class="c c-Singleline">// BAD: `arr` is not a reference</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that The <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span></code> function must accept bare <code class="docutils literal notranslate"><span class="pre">Int</span></code> arguments
to specify the lower and upper bounds of the range. A consequence of this
design is that it is not possible to create a slice with a symbolic length. If
this limitation prevents you from using SAW, please file an issue <a class="reference external" href="https://github.com/GaloisInc/saw-script/issues">on
GitHub</a>.</p>
</section>
<section id="string-slices">
<h4>String slices<a class="headerlink" href="#string-slices" title="Link to this heading"></a></h4>
<p>In addition to slices of arrays (i.e., of type <code class="docutils literal notranslate"><span class="pre">&amp;[T]</span></code>), SAW also supports
slices of strings (i.e., of type <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code>) through the following commands:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: the SAWScript expression
<code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span> <span class="pre">base</span></code> is equivalent to the Rust expression <code class="docutils literal notranslate"><span class="pre">&amp;base[..]</span></code>,
i.e., a slice of the entirety of <code class="docutils literal notranslate"><span class="pre">base</span></code>. <code class="docutils literal notranslate"><span class="pre">base</span></code> must be a reference to an
array of bytes (<code class="docutils literal notranslate"><span class="pre">&amp;[u8;</span> <span class="pre">N]</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[u8;</span> <span class="pre">N]</span></code>), not an array itself. The type
of <code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span> <span class="pre">base</span></code> will be <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is an immutable
reference) or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">str</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is a mutable reference).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_str_slice_range_value</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>: the
SAWScript expression <code class="docutils literal notranslate"><span class="pre">mir_slice_range_value</span> <span class="pre">base</span> <span class="pre">start</span> <span class="pre">end</span></code> is equivalent to
the Rust expression <code class="docutils literal notranslate"><span class="pre">&amp;base[start..end]</span></code>, i.e., a slice over a part of <code class="docutils literal notranslate"><span class="pre">base</span></code>
which ranges from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code>. <code class="docutils literal notranslate"><span class="pre">base</span></code> must be a reference to an array of
bytes (<code class="docutils literal notranslate"><span class="pre">&amp;[u8;</span> <span class="pre">N]</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[u8;</span> <span class="pre">N]</span></code>), not an array itself. The type of
<code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">base</span></code> will be <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is an immutable reference)
or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">str</span></code> (if <code class="docutils literal notranslate"><span class="pre">base</span></code> is a mutable reference).</p>
<p><code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> are assumed to be zero-indexed. <code class="docutils literal notranslate"><span class="pre">start</span></code> must not exceed
<code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">end</span></code> must not exceed the length of the array that <code class="docutils literal notranslate"><span class="pre">base</span></code> points
to.</p>
</li>
</ul>
<p>One unusual requirement about <code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span></code> and
<code class="docutils literal notranslate"><span class="pre">mir_str_slice_range_value</span></code> is that they require the argument to be of type
<code class="docutils literal notranslate"><span class="pre">&amp;[u8;</span> <span class="pre">N]</span></code>, i.e., a reference to an array of bytes. This is an artifact of the
way that strings are encoded in Cryptol. The following Cryptol expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;123&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code></p></li>
</ul>
<p>Have the following types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[1][8]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[3][8]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[11][8]</span></code></p></li>
</ul>
<p>This is because Cryptol strings are syntactic shorthand for sequences of bytes.
The following Cryptol expressions are wholly equivalent:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[0x41]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[0x31,</span> <span class="pre">0x32,</span> <span class="pre">0x33]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[0x48,</span> <span class="pre">0x65,</span> <span class="pre">0x6c,</span> <span class="pre">0x6c,</span> <span class="pre">0x6f,</span> <span class="pre">0x20,</span> <span class="pre">0x57,</span> <span class="pre">0x6f,</span> <span class="pre">0x72,</span> <span class="pre">0x6c,</span> <span class="pre">0x64]</span></code></p></li>
</ul>
<p>These represent the strings in the extended ASCII character encoding. The
Cryptol sequence type <code class="docutils literal notranslate"><span class="pre">[N][8]</span></code> is equivalent to the Rust type <code class="docutils literal notranslate"><span class="pre">[u8;</span> <span class="pre">N]</span></code>, so the
requirement to have something of type <code class="docutils literal notranslate"><span class="pre">&amp;[u8;</span> <span class="pre">N]</span></code> as an argument reflects this
design choice.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span> <span class="pre">&lt;u8_array_ref&gt;</span></code> is <em>not</em> the same thing as
<code class="docutils literal notranslate"><span class="pre">mir_slice_value</span> <span class="pre">&lt;u8_array_ref&gt;</span></code>, as the two commands represent different types
of Rust values. While both commands take a <code class="docutils literal notranslate"><span class="pre">&lt;u8_array_ref&gt;</span></code> as an argument,
<code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span></code> will return a value of Rust type <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> (or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">str</span></code>),
whereas <code class="docutils literal notranslate"><span class="pre">mir_slice_value</span></code> will return a value of Rust type <code class="docutils literal notranslate"><span class="pre">&amp;[u8]</span></code> (or <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">[u8]</span></code>). These Rust types are checked when you pass these values as arguments to
Rust functions (using <code class="docutils literal notranslate"><span class="pre">mir_execute_func</span></code>) or when you return these values
(using <code class="docutils literal notranslate"><span class="pre">mir_return</span></code>), and it is an error to supply a <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> value in a place
where a <code class="docutils literal notranslate"><span class="pre">&amp;[u8]</span></code> value is expected (and vice versa).</p>
<p>As an example of how to write specifications involving string slices,
consider this Rust function:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">my_len</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can use <code class="docutils literal notranslate"><span class="pre">mir_str_slice_value</span></code> to write a specification for <code class="docutils literal notranslate"><span class="pre">my_len</span></code> when it
is given the string <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code> as an argument:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">my_len_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">s</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_array</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">mir_u8</span><span class="p">);</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="s">&quot;</span><span class="nf">hello</span><span class="s">&quot;</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">mir_str_slice_value</span><span class="w"> </span><span class="n">s</span><span class="p">];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Currently, Cryptol only supports characters that can be encoded in a single
byte. As a result, it is not currently possible to take slices of strings with
certain characters. For example, the string <code class="docutils literal notranslate"><span class="pre">&quot;roșu&quot;</span></code> cannot be used as a
Cryptol expression, as the character <code class="docutils literal notranslate"><span class="pre">'ș'</span></code> would require 10 bits to represent
instead of 8. The alternative is to use UTF-8 to encode such characters. For
instance, the UTF-8 encoding of the string <code class="docutils literal notranslate"><span class="pre">&quot;roșu&quot;</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;ro\200\153u&quot;</span></code>, where
<code class="docutils literal notranslate"><span class="pre">&quot;\200\153&quot;</span></code> is a sequence of two bytes that represents the <code class="docutils literal notranslate"><span class="pre">'ș'</span></code> character.</p>
<p>SAW makes no attempt to ensure that string slices over a particular range
aligns with UTF-8 character boundaries. For example, the following Rust code
would panic:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rosu</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;roșu&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rosu</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">thread &#39;main&#39; panicked at &#39;byte index 3 is not a char boundary; it is inside &#39;ș&#39; (bytes 2..4) of `roșu`&#39;</span>
</pre></div>
</div>
<p>On the other hand, SAW will allow you define a slice of the form
<code class="docutils literal notranslate"><span class="pre">mir_str_slice_range</span> <span class="pre">r</span> <span class="pre">0</span> <span class="pre">3</span></code>, where <code class="docutils literal notranslate"><span class="pre">r</span></code> is a reference to <code class="docutils literal notranslate"><span class="pre">&quot;ro\200\153u&quot;</span></code>. It is
the responsibility of the SAW user to ensure that <code class="docutils literal notranslate"><span class="pre">mir_str_slice_range</span></code> indices
align with character boundaries.</p>
</section>
</section>
<section id="mir-vecs">
<h3>MIR <code class="docutils literal notranslate"><span class="pre">Vec</span></code>s<a class="headerlink" href="#mir-vecs" title="Link to this heading"></a></h3>
<p><a class="reference external" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code class="docutils literal notranslate"><span class="pre">Vec</span></code></a> is a commonly used
data type in the Rust standard library. <code class="docutils literal notranslate"><span class="pre">Vec</span></code> values can be created from array
values in MIR specifications with the following command:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_vec_of</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">String</span></code> argument is used as a prefix for naming the internal symbolic
variables created as part of the <code class="docutils literal notranslate"><span class="pre">Vec</span></code> struct (think of it just as a name you
give to the <code class="docutils literal notranslate"><span class="pre">Vec</span></code> variable). The <code class="docutils literal notranslate"><span class="pre">MIRType</span></code> argument is the element type of the
<code class="docutils literal notranslate"><span class="pre">Vec</span></code>. The <code class="docutils literal notranslate"><span class="pre">MIRValue</span></code> argument is the contents of the <code class="docutils literal notranslate"><span class="pre">Vec</span></code>, which must be a MIR
array value whose element type matches the <code class="docutils literal notranslate"><span class="pre">MIRType</span></code> argument. Note that this
could either be created with <code class="docutils literal notranslate"><span class="pre">mir_array_value</span></code> or obtained from a <code class="docutils literal notranslate"><span class="pre">Term</span></code> like a
fresh variable or a Cryptol sequence expression.</p>
<p><code class="docutils literal notranslate"><span class="pre">Vec</span></code> is just a regular struct and not a special language construct, so
technically you could write specifications for <code class="docutils literal notranslate"><span class="pre">Vec</span></code>s just using the primitive
MIR specification commands (in fact, this is what <code class="docutils literal notranslate"><span class="pre">mir_vec_of</span></code> does internally).
However, you would need to explicitly specify all the internal details and
invariants of <code class="docutils literal notranslate"><span class="pre">Vec</span></code>, and that can get quite messy. Therefore, this command
exists for convenience reasons.</p>
</section>
<section id="finding-mir-algebraic-data-types">
<h3>Finding MIR algebraic data types<a class="headerlink" href="#finding-mir-algebraic-data-types" title="Link to this heading"></a></h3>
<p>We collectively refer to MIR <code class="docutils literal notranslate"><span class="pre">struct</span></code>s and <code class="docutils literal notranslate"><span class="pre">enum</span></code>s together as <em>algebraic data
types</em>, or ADTs for short. ADTs have identifiers to tell them apart, and a
single ADT declaration can give rise to multiple identifiers depending on how
the declaration is used. For example:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">B</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u16</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">g</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">        </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This program as a single <code class="docutils literal notranslate"><span class="pre">struct</span></code> declaration <code class="docutils literal notranslate"><span class="pre">S</span></code>, which is used in the
functions <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">S</span></code>’s declaration is <em>polymorphic</em>, as it uses
type parameters, but the uses of <code class="docutils literal notranslate"><span class="pre">S</span></code> in <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> are <em>monomorphic</em>, as <code class="docutils literal notranslate"><span class="pre">S</span></code>’s
type parameters are fully instantiated. Each unique, monomorphic instantiation
of an ADT gives rise to its own identifier. In the example above, this might
mean that the following identifiers are created when this code is compiled with
<code class="docutils literal notranslate"><span class="pre">mir-json</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">S&lt;u8,</span> <span class="pre">u16&gt;</span></code> gives rise to <code class="docutils literal notranslate"><span class="pre">example/abcd123::S::_adt456</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S&lt;u32,</span> <span class="pre">u64&gt;</span></code> gives rise to <code class="docutils literal notranslate"><span class="pre">example/abcd123::S::_adt789</span></code></p></li>
</ul>
<p>The suffix <code class="docutils literal notranslate"><span class="pre">_adt&lt;number&gt;</span></code> is autogenerated by <code class="docutils literal notranslate"><span class="pre">mir-json</span></code> and is typically
difficult for humans to guess. For this reason, we offer a command to look up
an ADT more easily:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_find_adt</span> <span class="pre">:</span> <span class="pre">MIRModule</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">[MIRType]</span> <span class="pre">-&gt;</span> <span class="pre">MIRAdt</span></code> consults the
given <code class="docutils literal notranslate"><span class="pre">MIRModule</span></code> to find an algebraic data type (<code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code>). It uses the given
<code class="docutils literal notranslate"><span class="pre">String</span></code> as an identifier and the given MIRTypes as the types to instantiate
the type parameters of the ADT. If such a <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> cannot be found in the
<code class="docutils literal notranslate"><span class="pre">MIRModule</span></code>, this will raise an error.</p></li>
</ul>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">String</span></code> argument to <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> does not need to include the
<code class="docutils literal notranslate"><span class="pre">_adt&lt;num&gt;</span></code> suffix, as <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> will discover this for you. The <code class="docutils literal notranslate"><span class="pre">String</span></code>
is expected to adhere to the identifier conventions described in the “Running a
MIR-based verification” section. For instance, the following two lines will
look up <code class="docutils literal notranslate"><span class="pre">S&lt;u8,</span> <span class="pre">u16&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">S&lt;u32,</span> <span class="pre">u64&gt;</span></code> from the example above as <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code>s:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_load_module</span><span class="w"> </span><span class="s2">&quot;example.linked-mir.json&quot;</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">s_8_16</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="nb">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;example::S&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_u8</span><span class="p">,</span><span class="w">  </span><span class="n">mir_u16</span><span class="p">];</span>
<span class="kd">let</span><span class="w"> </span><span class="n">s_32_64</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;example::S&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_u32</span><span class="p">,</span><span class="w"> </span><span class="n">mir_u64</span><span class="p">];</span>
</pre></div>
</div>
<p>See also the <a class="reference internal" href="#const-generics"><span class="xref myst">const generics</span></a> section for more details on how
to look up <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code>s that use const generics.</p>
<p>Note that there is also a command to look up ADTs by their full, <em>mangled</em>
identifiers that include the <code class="docutils literal notranslate"><span class="pre">_adt&lt;num&gt;</span></code> suffix:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_find_mangled_adt</span> <span class="pre">:</span> <span class="pre">MIRModule</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRAdt</span></code></p></li>
</ul>
<p>Note that unlike <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>, <code class="docutils literal notranslate"><span class="pre">mir_find_mangled_adt</span></code> lacks <code class="docutils literal notranslate"><span class="pre">[MirType]</span></code>
arguments, as the type information is already encoded into the mangled
identifier.</p>
<p>It is recommended to use <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> over <code class="docutils literal notranslate"><span class="pre">mir_find_mangled_adt</span></code> whenever
possible, as mangled identifiers can change easily when recompiling Rust code.
<code class="docutils literal notranslate"><span class="pre">mir_find_mangled_adt</span></code> is generally only needed to work around limitations in
what <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> can look up.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">mir_adt</span></code> command (for constructing a struct type), <code class="docutils literal notranslate"><span class="pre">mir_struct_value</span></code> (for
constructing a struct value), and <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code> (for constructing an enum
value) commands in turn take a <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> as an argument.</p>
<section id="enums">
<h4>Enums<a class="headerlink" href="#enums" title="Link to this heading"></a></h4>
<p>In addition to taking a <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> as an argument, <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code> also takes a
<code class="docutils literal notranslate"><span class="pre">String</span></code> representing the name of the variant to construct. The variant name
should be a short name such as <code class="docutils literal notranslate"><span class="pre">&quot;None&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;Some&quot;</span></code>, and not a full identifier
such as <code class="docutils literal notranslate"><span class="pre">&quot;core::option::Option::None&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;core::option::Option::Some&quot;</span></code>. This
is because the <code class="docutils literal notranslate"><span class="pre">MIRAdt</span></code> already contains the full identifiers for all of an
enum’s variants, so SAW will use this information to look up a variant’s
identifier from a short name. Here is an example of using <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code> in
practice:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">n</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">None</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">s</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_load_module</span><span class="w"> </span><span class="s2">&quot;example.linked-mir.json&quot;</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">option_u32</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;core::option::Option&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_u32</span><span class="p">];</span>

<span class="kd">let</span><span class="w"> </span><span class="n">n_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_enum_value</span><span class="w"> </span><span class="n">option_u32</span><span class="w"> </span><span class="s2">&quot;None&quot;</span><span class="w"> </span><span class="p">[]);</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">s_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_fresh_var</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="n">mir_u32</span><span class="p">;</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_enum_value</span><span class="w"> </span><span class="n">option_u32</span><span class="w"> </span><span class="s2">&quot;Some&quot;</span><span class="w"> </span><span class="p">[</span><span class="nb">mir_term</span><span class="w"> </span><span class="n">x</span><span class="p">]);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">mir_enum_value</span></code> can only be used to construct a specific variant. If
you need to construct a symbolic enum value that can range over many potential
variants, use <code class="docutils literal notranslate"><span class="pre">mir_fresh_expanded_value</span></code> instead.</p>
</section>
<section id="lifetimes">
<h4>Lifetimes<a class="headerlink" href="#lifetimes" title="Link to this heading"></a></h4>
<p>Rust ADTs can have both type parameters as well as <em>lifetime</em> parameters. The
following Rust code declares a lifetime parameter <code class="docutils literal notranslate"><span class="pre">'a</span></code> on the struct <code class="docutils literal notranslate"><span class="pre">S</span></code>, as
well on the function <code class="docutils literal notranslate"><span class="pre">f</span></code> that computes an <code class="docutils literal notranslate"><span class="pre">S</span></code> value:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">mir-json</span></code> compiles a piece of Rust code that contains lifetime
parameters, it will instantiate all of the lifetime parameters with a
placeholder MIR type that is simply called <code class="docutils literal notranslate"><span class="pre">lifetime</span></code>. This is important to
keep in mind when looking up ADTs with <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>, as you will also need to
indicate to SAW that the lifetime parameter is instantiated with <code class="docutils literal notranslate"><span class="pre">lifetime</span></code>. In
order to do so, use <code class="docutils literal notranslate"><span class="pre">mir_lifetime</span></code>. For example, here is how to look up <code class="docutils literal notranslate"><span class="pre">S</span></code>
with <code class="docutils literal notranslate"><span class="pre">'a</span></code> instantiated to <code class="docutils literal notranslate"><span class="pre">lifetime</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">s_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;example::S&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_lifetime</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that this part of SAW’s design is subject to change in the future.
Ideally, users would not have to care about lifetimes at all at the MIR level;
see <a class="reference external" href="https://github.com/GaloisInc/mir-json/issues/58">this issue</a> for further
discussion on this point. If that issue is fixed, then we will likely remove
<code class="docutils literal notranslate"><span class="pre">mir_lifetime</span></code>, as it will no longer be necessary.</p>
</section>
<section id="const-generics">
<h4>Const generics<a class="headerlink" href="#const-generics" title="Link to this heading"></a></h4>
<p>Rust ADTs can have <em>const generic</em> parameters that allow the ADT to be generic
over constant values.
For instance, the following Rust code declares a const generic parameter <code class="docutils literal notranslate"><span class="pre">N</span></code>
on the struct <code class="docutils literal notranslate"><span class="pre">S</span></code>, as well as on the functions <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> that compute <code class="docutils literal notranslate"><span class="pre">S</span></code>
values:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">N</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">N</span><span class="p">]</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">S</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">y</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Like with other forms of Rust generics, instantiating <code class="docutils literal notranslate"><span class="pre">S</span></code> with different
constants will give rise to different identifiers in the compiled MIR code.
SAW provides a <code class="docutils literal notranslate"><span class="pre">mir_const</span></code> function for specifying the values of constants
used to instantiate const generic parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_const</span> <span class="pre">:</span> <span class="pre">MIRType</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">MIRType</span></code></p></li>
</ul>
<p>For instance, if order to look up <code class="docutils literal notranslate"><span class="pre">S&lt;1&gt;</span></code>, use <code class="docutils literal notranslate"><span class="pre">mir_const</span></code> in conjunction with
<code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code> like so:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">s_adt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">mir_find_adt</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;example::S&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">mir_const</span><span class="w"> </span><span class="n">mir_usize</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">]</span>
</pre></div>
</div>
<p>Unlike other forms of <code class="docutils literal notranslate"><span class="pre">MIRType</span></code>s, the type returned by <code class="docutils literal notranslate"><span class="pre">mir_const</span></code> is not a
type that you can create values with.
For instance, calling <code class="docutils literal notranslate"><span class="pre">mir_alloc</span></code> or <code class="docutils literal notranslate"><span class="pre">mir_fresh_var</span></code> at a type returned by
<code class="docutils literal notranslate"><span class="pre">mir_const</span></code> will raise an error.
<code class="docutils literal notranslate"><span class="pre">mir_const</span></code> is only useful for looking up ADTs via <code class="docutils literal notranslate"><span class="pre">mir_find_adt</span></code>.</p>
<p>At present, <code class="docutils literal notranslate"><span class="pre">mir_const</span></code> only supports looking up constant values with the types
listed
<a class="reference external" href="https://doc.rust-lang.org/1.86.0/reference/items/generics.html#r-items.generics.const.allowed-types">here</a>
in the Rust Reference.
Specifically, the <code class="docutils literal notranslate"><span class="pre">MIRType</span></code> argument must be one of the following, subject to
the following restrictions:</p>
<ul class="simple">
<li><p>A primitive integer type, i.e., <code class="docutils literal notranslate"><span class="pre">mir_u{8,16,32,64,128,size}</span></code> or
<code class="docutils literal notranslate"><span class="pre">mir_i{8,16,32,64,128,size}</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Term</span></code> argument must be a bitvector of the corresponding size.
For instance, if the <code class="docutils literal notranslate"><span class="pre">MIRType</span></code> is <code class="docutils literal notranslate"><span class="pre">mir_u8</span></code>, then the <code class="docutils literal notranslate"><span class="pre">Term</span></code> must be a
bitvector of type <code class="docutils literal notranslate"><span class="pre">[8]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_bool</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Term</span></code> argument must be of type <code class="docutils literal notranslate"><span class="pre">Bit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_char</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Term</span></code> argument must be of type <code class="docutils literal notranslate"><span class="pre">[32]</span></code>.</p></li>
</ul>
</section>
</section>
<section id="bitfields">
<h3>Bitfields<a class="headerlink" href="#bitfields" title="Link to this heading"></a></h3>
<p>SAW has experimental support for specifying <code class="docutils literal notranslate"><span class="pre">struct</span></code>s with bitfields, such as
in the following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Normally, a <code class="docutils literal notranslate"><span class="pre">struct</span></code> with two <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> fields would have an overall size of
two bytes. However, because the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> fields are declared with bitfield
syntax, they are instead packed together into a single byte.</p>
<p>Because bitfields have somewhat unusual memory representations in LLVM, some
special care is required to write SAW specifications involving bitfields. For
this reason, there is a dedicated <code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span></code> function for this
purpose:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
</ul>
<p>The type of <code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span></code> is similar that of <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code>,
except that it takes the name of a field within a bitfield as an additional
argument. For example, here is how to assert that the <code class="docutils literal notranslate"><span class="pre">y</span></code> field in the <code class="docutils literal notranslate"><span class="pre">struct</span></code>
example above should be <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">ss</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_alias</span><span class="w"> </span><span class="s2">&quot;struct.s&quot;</span><span class="p">);</span>
<span class="n">llvm_points_to_bitfield</span><span class="w"> </span><span class="n">ss</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the type of the right-hand side value (<code class="docutils literal notranslate"><span class="pre">0</span></code>, in this example) must
be a bitvector whose length is equal to the size of the field within the
bitfield. In this example, the <code class="docutils literal notranslate"><span class="pre">y</span></code> field was declared as <code class="docutils literal notranslate"><span class="pre">y:1</span></code>, so <code class="docutils literal notranslate"><span class="pre">y</span></code>’s value
must be of type <code class="docutils literal notranslate"><span class="pre">[1]</span></code>.</p>
<p>Note that the following specification is <em>not</em> equivalent to the one above:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">ss</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_alias</span><span class="w"> </span><span class="s2">&quot;struct.s&quot;</span><span class="p">);</span>
<span class="nb">llvm_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_field</span><span class="w"> </span><span class="n">ss</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> works quite differently from <code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span></code> under
the hood, so using <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code> on bitfields will almost certainly not work
as expected.</p>
<p>In order to use <code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span></code>, one must also use the
<code class="docutils literal notranslate"><span class="pre">enable_lax_loads_and_stores</span></code> command:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">enable_lax_loads_and_stores:</span> <span class="pre">TopLevel</span> <span class="pre">()</span></code></p></li>
</ul>
<p>Both <code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span></code> and <code class="docutils literal notranslate"><span class="pre">enable_lax_loads_and_stores</span></code> are
experimental commands, so these also require using <code class="docutils literal notranslate"><span class="pre">enable_experimental</span></code> before
they can be used.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">enable_lax_loads_and_stores</span></code> command relaxes some
of SAW’s assumptions about uninitialized memory, which is necessary to make
<code class="docutils literal notranslate"><span class="pre">llvm_points_to_bitfield</span></code> work under the hood. For example, reading from
uninitialized memory normally results in an error in SAW, but with
<code class="docutils literal notranslate"><span class="pre">enable_lax_loads_and_stores</span></code>, such a read will instead return a symbolic
value. At present, <code class="docutils literal notranslate"><span class="pre">enable_lax_loads_and_stores</span></code> only works with What4-based
tactics (e.g., <code class="docutils literal notranslate"><span class="pre">w4_unint_z3</span></code>); using it with SBV-based tactics
(e.g., <code class="docutils literal notranslate"><span class="pre">sbv_unint_z3</span></code>) will result in an error.</p>
<p>Note that SAW relies on LLVM debug metadata in order to determine which struct
fields reside within a bitfield. As a result, you must pass <code class="docutils literal notranslate"><span class="pre">-g</span></code> to <code class="docutils literal notranslate"><span class="pre">clang</span></code> when
compiling code involving bitfields in order for SAW to be able to reason about
them.</p>
</section>
</section>
<section id="global-variables">
<h2>Global variables<a class="headerlink" href="#global-variables" title="Link to this heading"></a></h2>
<p>SAW supports verifying LLVM and MIR specifications involving global variables.</p>
<section id="llvm-global-variables">
<h3>LLVM global variables<a class="headerlink" href="#llvm-global-variables" title="Link to this heading"></a></h3>
<p>Mutable global variables that are accessed in a function must first be allocated
by calling <code class="docutils literal notranslate"><span class="pre">llvm_alloc_global</span></code> on the name of the global.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_alloc_global</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
</ul>
<p>This ensures that all global variables that might influence the function are
accounted for explicitly in the specification: if <code class="docutils literal notranslate"><span class="pre">llvm_alloc_global</span></code> is
used in the precondition, there must be a corresponding <code class="docutils literal notranslate"><span class="pre">llvm_points_to</span></code>
in the postcondition describing the new state of that global. Otherwise, a
specification might not fully capture the behavior of the function, potentially
leading to unsoundness in the presence of compositional verification. (For more
details on this point, see the <a class="reference internal" href="#compositional-verification-and-mutable-global-variables">Compositional Verification and Mutable Global
Variables</a> section.)</p>
<p>Immutable (i.e. <code class="docutils literal notranslate"><span class="pre">const</span></code>) global variables are allocated implicitly, and do not
require a call to <code class="docutils literal notranslate"><span class="pre">llvm_alloc_global</span></code>.</p>
<p>Pointers to global variables or functions can be accessed with
<code class="docutils literal notranslate"><span class="pre">llvm_global</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_global</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code></p></li>
</ul>
<p>Like the pointers returned by <code class="docutils literal notranslate"><span class="pre">llvm_alloc</span></code>, however, these aren’t
initialized at the beginning of symbolic – setting global variables may
be unsound in the presence of <a class="reference internal" href="#compositional-verification">compositional
verification</a>.</p>
<p>To understand the issues surrounding global variables, consider the following C
code:</p>
<!-- This matches intTests/test0036_globals/test-signed.c -->
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One might initially write the following specifications for <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code>:</p>
<!-- This matches intTests/test0036_globals/test-signed-fail.saw -->
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_load_module</span><span class="w"> </span><span class="s2">&quot;./test.bc&quot;</span><span class="p">;</span>

<span class="n">f_spec</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;f&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">y</span><span class="p">];</span>
<span class="w">    </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">})</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>

<span class="n">g_spec</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">llvm_llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;g&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;z&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">z</span><span class="p">];</span>
<span class="w">    </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">z</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">})</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>
</pre></div>
</div>
<p>If globals were always initialized at the beginning of verification,
both of these specs would be provable. However, the results wouldn’t
truly be compositional. For instance, it’s not the case that <code class="docutils literal notranslate"><span class="pre">f(g(z))</span> <span class="pre">==</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">3</span></code> for all <code class="docutils literal notranslate"><span class="pre">z</span></code>, because both <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> modify the global variable
<code class="docutils literal notranslate"><span class="pre">x</span></code> in a way that crosses function boundaries.</p>
<p>To deal with this, we can use the following function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_global_initializer</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span></code> returns the value
of the constant global initializer for the named global variable.</p></li>
</ul>
<p>Given this function, the specifications for <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> can make this
reliance on the initial value of <code class="docutils literal notranslate"><span class="pre">x</span></code> explicit:</p>
<!-- This matches intTests/test0036_globals/test-signed.saw -->
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_load_module</span><span class="w"> </span><span class="s2">&quot;./test.bc&quot;</span><span class="p">;</span>


<span class="kd">let</span><span class="w"> </span><span class="n">init_global</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">llvm_alloc_global</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">  </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_global</span><span class="w"> </span><span class="n">name</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="n">llvm_global_initializer</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">f_spec</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;f&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="n">init_global</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">llvm_precond</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="o">^^</span><span class="mi">31</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">y</span><span class="p">];</span>
<span class="w">    </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">y</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">})</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>
</pre></div>
</div>
<p>which initializes <code class="docutils literal notranslate"><span class="pre">x</span></code> to whatever it is initialized to in the C code at
the beginning of verification. This specification is now safe for
compositional verification: SAW won’t use the specification <code class="docutils literal notranslate"><span class="pre">f_spec</span></code>
unless it can determine that <code class="docutils literal notranslate"><span class="pre">x</span></code> still has its initial value at the
point of a call to <code class="docutils literal notranslate"><span class="pre">f</span></code>. This specification also constrains <code class="docutils literal notranslate"><span class="pre">y</span></code> to prevent
signed integer overflow resulting from the <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> expression in <code class="docutils literal notranslate"><span class="pre">f</span></code>,
which is undefined behavior in C.</p>
</section>
<section id="mir-static-items">
<span id="id3"></span><h3>MIR static items<a class="headerlink" href="#mir-static-items" title="Link to this heading"></a></h3>
<p>Rust’s static items are the MIR version of global variables. A reference to a
static item can be accessed with the <code class="docutils literal notranslate"><span class="pre">mir_static</span></code> function. This function takes
a <code class="docutils literal notranslate"><span class="pre">String</span></code> representing a static item’s identifier, and this identifier is
expected to adhere to the naming conventions outlined in the “Running a
MIR-based verification” section:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_static</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code></p></li>
</ul>
<p>References to static values can be initialized with the <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code>
command, just like with other forms of references. Immutable static items
(e.g., <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">X:</span> <span class="pre">u8</span> <span class="pre">=</span> <span class="pre">42</span></code>) are initialized implicitly in every SAW
specification, so there is no need for users to do so manually. Mutable static
items (e.g., <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">mut</span> <span class="pre">Y:</span> <span class="pre">u8</span> <span class="pre">=</span> <span class="pre">27</span></code>), on the other hand, are <em>not</em> initialized
implicitly, and users must explicitly pick a value to initialize them with.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">mir_static_initializer</span></code> function can be used to access the initial value
of a static item in a MIR program. Like with <code class="docutils literal notranslate"><span class="pre">mir_static</span></code>, the <code class="docutils literal notranslate"><span class="pre">String</span></code>
supplied as an argument must be a valid identifier:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mir_static_initializer</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span></code>.</p></li>
</ul>
<p>As an example of how to use these functions, here is a Rust program involving
static items:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// statics.rs</span>
<span class="k">static</span><span class="w">     </span><span class="n">S1</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">S2</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Reading a mutable static item requires an `unsafe` block due to</span>
<span class="w">    </span><span class="c1">// concurrency-related concerns. We are only concerned about the behavior</span>
<span class="w">    </span><span class="c1">// of this program in a single-threaded context, so this is fine.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">S1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can write a specification for <code class="docutils literal notranslate"><span class="pre">f</span></code> like so:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="c c-Singleline">// statics.saw</span>
<span class="n">enable_experimental</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">f_spec</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nb">mir_points_to</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_static</span><span class="w"> </span><span class="s2">&quot;statics::S2&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">mir_static_initializer</span><span class="w"> </span><span class="s2">&quot;statics::S2&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="c c-Singleline">// Note that we do not initialize S1, as immutable static items are implicitly</span>
<span class="w">  </span><span class="c c-Singleline">// initialized in every specification.</span>

<span class="w">  </span><span class="nb">mir_execute_func</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="nb">mir_return</span><span class="w"> </span><span class="p">(</span><span class="nb">mir_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">m</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">mir_load_module</span><span class="w"> </span><span class="s2">&quot;statics.linked-mir.json&quot;</span><span class="p">;</span>

<span class="nb">mir_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;statics::f&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">f_spec</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>In order to use a specification involving mutable static items for
compositional verification, it is required to specify the value of all mutable
static items using the <code class="docutils literal notranslate"><span class="pre">mir_points_to</span></code> command in the specification’s
postconditions. For more details on this point, see the <a class="reference internal" href="#compositional-verification-and-mutable-global-variables">Compositional
Verification and Mutable Global
Variables</a> section.</p>
</section>
</section>
<section id="preconditions-and-postconditions">
<h2>Preconditions and Postconditions<a class="headerlink" href="#preconditions-and-postconditions" title="Link to this heading"></a></h2>
<p>Sometimes a function is only well-defined under certain conditions, or
sometimes you may be interested in certain initial conditions that give
rise to specific final conditions. For these cases, you can specify an
arbitrary predicate as a precondition or post-condition, using any
values in scope at the time.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_precond</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_postcond</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_assert</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_precond</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_postcond</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_assert</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_precond</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_postcond</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_assert</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
</ul>
<p>These commands take <code class="docutils literal notranslate"><span class="pre">Term</span></code> arguments, and therefore cannot describe the values
of pointers. The “assert” variants will work in either pre- or post-conditions,
and are useful when defining helper functions that, e.g., provide datastructure
invariants that make sense in both phases.  The <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_equal</span></code> commands
state that two values should be equal, and can be used in either the initial or
the final state.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_equal</span> <span class="pre">:</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMValue</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_equal</span> <span class="pre">:</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMValue</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_equal</span> <span class="pre">:</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRValue</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span></code></p></li>
</ul>
<p>The use of <code class="docutils literal notranslate"><span class="pre">{llvm,jvm,mir}_equal</span></code> can also sometimes lead to more efficient
symbolic execution when the predicate of interest is an equality.</p>
</section>
<section id="assuming-specifications">
<h2>Assuming specifications<a class="headerlink" href="#assuming-specifications" title="Link to this heading"></a></h2>
<p>Normally, a <code class="docutils literal notranslate"><span class="pre">MethodSpec</span></code> is the result of both simulation and proof of
the target code. However, in some cases, it can be useful to use a
<code class="docutils literal notranslate"><span class="pre">MethodSpec</span></code> to specify some code that either doesn’t exist or is hard
to prove. The previously-mentioned <a class="reference internal" href="proofs-about-terms.html#finishing-proofs-without-external-solvers"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">assume_unsat</span></code>
tactic</span></a> omits proof but does not prevent
simulation of the function. To skip simulation altogether, one can use
one of the following commands:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_unsafe_assume_spec</span> <span class="pre">:</span> <span class="pre">LLVMModule</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">TopLevel</span> <span class="pre">CrucibleMethodSpec</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_unsafe_assume_spec</span> <span class="pre">:</span> <span class="pre">JavaClass</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">TopLevel</span> <span class="pre">JVMMethodSpec</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_unsafe_assume_spec</span> <span class="pre">:</span> <span class="pre">MIRModule</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">TopLevel</span> <span class="pre">MIRSpec</span></code></p></li>
</ul>
</section>
<section id="a-heap-based-example">
<h2>A Heap-Based Example<a class="headerlink" href="#a-heap-based-example" title="Link to this heading"></a></h2>
<p>To tie all of the command descriptions from the previous sections
together, consider the case of verifying the correctness of a C program
that computes the dot product of two vectors, where the length and value
of each vector are encapsulated together in a <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</p>
<p>The dot product can be concisely specified in Cryptol as follows:</p>
<div class="highlight-cryptol notranslate"><div class="highlight"><pre><span></span><span class="nf">dotprod</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="kr">fin</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kr">fin</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">dotprod</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">(</span><span class="n">zip</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>To implement this in C, let’s first consider the type of vectors:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">elts</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">vec_t</span><span class="p">;</span>
</pre></div>
</div>
<p>This struct contains a pointer to an array of 32-bit elements, and a
32-bit value indicating how many elements that array has.</p>
<p>We can compute the dot product of two of these vectors with the
following C code (which uses the size of the shorter vector if they
differ in size).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">dotprod_struct</span><span class="p">(</span><span class="n">vec_t</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">vec_t</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIN</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="o">-&gt;</span><span class="n">elts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">elts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The entirety of this implementation can be found in the
<code class="docutils literal notranslate"><span class="pre">examples/llvm/dotprod_struct.c</span></code> file in the <code class="docutils literal notranslate"><span class="pre">saw-script</span></code> repository.</p>
<p>To verify this program in SAW, it will be convenient to define a couple
of utility functions (which are generally useful for many
heap-manipulating programs). First, combining allocation and
initialization to a specific value can make many scripts more concise:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">alloc_init</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="nb">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This creates a pointer <code class="docutils literal notranslate"><span class="pre">p</span></code> pointing to enough space to store type <code class="docutils literal notranslate"><span class="pre">ty</span></code>,
and then indicates that the pointer points to value <code class="docutils literal notranslate"><span class="pre">v</span></code> (which should be
of that same type).</p>
<p>A common case for allocation and initialization together is when the
initial value should be entirely symbolic.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">alloc_init</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="nb">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This function returns the pointer just allocated along with the fresh
symbolic value it points to.</p>
<p>Given these two utility functions, the <code class="docutils literal notranslate"><span class="pre">dotprod_struct</span></code> function can be
specified as follows:</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">dotprod_spec</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nt</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">`</span><span class="nf">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">    </span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="n">xsp</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;xs&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">));</span>
<span class="w">    </span><span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="w"> </span><span class="n">ysp</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;ys&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">));</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">xval</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">llvm_struct_value</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">xsp</span><span class="p">,</span><span class="w"> </span><span class="n">nt</span><span class="w"> </span><span class="p">];</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">yval</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nb">llvm_struct_value</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">ysp</span><span class="p">,</span><span class="w"> </span><span class="n">nt</span><span class="w"> </span><span class="p">];</span>
<span class="w">    </span><span class="n">xp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">alloc_init</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_alias</span><span class="w"> </span><span class="s2">&quot;struct.vec_t&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">xval</span><span class="p">;</span>
<span class="w">    </span><span class="n">yp</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">alloc_init</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_alias</span><span class="w"> </span><span class="s2">&quot;struct.vec_t&quot;</span><span class="p">)</span><span class="w"> </span><span class="n">yval</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">xp</span><span class="p">,</span><span class="w"> </span><span class="n">yp</span><span class="p">];</span>
<span class="w">    </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">dotprod</span><span class="w"> </span><span class="nf">xs</span><span class="w"> </span><span class="nf">ys</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Any instantiation of this specification is for a specific vector length
<code class="docutils literal notranslate"><span class="pre">n</span></code>, and assumes that both input vectors have that length. That length
<code class="docutils literal notranslate"><span class="pre">n</span></code> automatically becomes a type variable in the subsequent Cryptol
expressions, and the backtick operator is used to reify that type as a
bit vector of length 32.</p>
<p>The entire script can be found in the <code class="docutils literal notranslate"><span class="pre">dotprod_struct-crucible.saw</span></code> file
alongside <code class="docutils literal notranslate"><span class="pre">dotprod_struct.c</span></code>.</p>
<p>Running this script results in the following:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Loading file &quot;dotprod_struct.saw&quot;</span>
<span class="go">Proof succeeded! dotprod_struct</span>
<span class="go">Registering override for `dotprod_struct`</span>
<span class="go">  variant `dotprod_struct`</span>
<span class="go">Symbolic simulation completed with side conditions.</span>
<span class="go">Proof succeeded! dotprod_wrap</span>
</pre></div>
</div>
</section>
<section id="using-ghost-state">
<h2>Using Ghost State<a class="headerlink" href="#using-ghost-state" title="Link to this heading"></a></h2>
<p>In some cases, information relevant to verification is not directly
present in the concrete state of the program being verified. This can
happen for at least two reasons:</p>
<ul class="simple">
<li><p>When providing specifications for external functions, for which source
code is not present. The external code may read and write global state
that is not directly accessible from the code being verified.</p></li>
<li><p>When the abstract specification of the program naturally uses a
different representation for some data than the concrete
implementation in the code being verified does.</p></li>
</ul>
<p>One solution to these problems is the use of <em>ghost</em> state. This can be
thought of as additional global state that is visible only to the
verifier. Ghost state with a given name can be declared at the top level
with the following function:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">declare_ghost_state</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">TopLevel</span> <span class="pre">Ghost</span></code></p></li>
</ul>
<p>Ghost state variables do not initially have any particluar type, and can
store data of any type. Given an existing ghost variable the following
functions can be used to specify its value:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_ghost_value</span> <span class="pre">:</span> <span class="pre">Ghost</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">jvm_ghost_value</span>&#160; <span class="pre">:</span> <span class="pre">Ghost</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">JVMSetup</span>&#160; <span class="pre">()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mir_ghost_value</span>&#160; <span class="pre">:</span> <span class="pre">Ghost</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">MIRSetup</span>&#160; <span class="pre">()</span></code></p></li>
</ul>
<p>These can be used in either the pre state or the post state, to specify the
value of ghost state either before or after the execution of the function,
respectively.</p>
</section>
<section id="an-extended-example">
<h2>An Extended Example<a class="headerlink" href="#an-extended-example" title="Link to this heading"></a></h2>
<p>To tie together many of the concepts in this manual, we now present a
non-trivial verification task in its entirety. All of the code for this example
can be found in the <code class="docutils literal notranslate"><span class="pre">examples/salsa20</span></code> directory of
<a class="reference external" href="https://github.com/GaloisInc/saw-script">the SAWScript repository</a>.</p>
<section id="salsa20-overview">
<h3>Salsa20 Overview<a class="headerlink" href="#salsa20-overview" title="Link to this heading"></a></h3>
<p>Salsa20 is a stream cipher developed in 2005 by Daniel J. Bernstein, built on a
pseudorandom function utilizing add-rotate-XOR (ARX) operations on 32-bit
words<a class="footnote-reference brackets" href="#id5" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>. Bernstein himself has provided several public domain
implementations of the cipher, optimized for common machine architectures.
For the mathematically inclined, his specification for the cipher can be
found <a class="reference external" href="http://cr.yp.to/snuffle/spec.pdf">here</a>.</p>
<p>The repository referenced above contains three implementations of the Salsa20
cipher: A reference Cryptol implementation (which we take as correct in this
example), and two C implementations, one of which is from Bernstein himself.
For this example, we focus on the second of these C
implementations, which more closely matches the Cryptol implementation. Full
verification of Bernstein’s implementation is available in
<code class="docutils literal notranslate"><span class="pre">examples/salsa20/djb</span></code>, for the interested. The code for this verification task
can be found in the files named according to the pattern
<code class="docutils literal notranslate"><span class="pre">examples/salsa20/(s|S)alsa20.*</span></code>.</p>
</section>
<section id="specifications">
<h3>Specifications<a class="headerlink" href="#specifications" title="Link to this heading"></a></h3>
<p>We now take on the actual verification task. This will be done in two stages:
We first define some useful utility functions for constructing common patterns
in the specifications for this type of program (i.e. one where the arguments to
functions are modified in-place.) We then demonstrate how one might construct a
specification for each of the functions in the Salsa20 implementation described
above.</p>
<section id="utility-functions">
<h4>Utility Functions<a class="headerlink" href="#utility-functions" title="Link to this heading"></a></h4>
<p>We first define the function
<code class="docutils literal notranslate"><span class="pre">alloc_init</span> <span class="pre">:</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">LLVMValue</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">alloc_init</span> <span class="pre">ty</span> <span class="pre">v</span></code> returns a <code class="docutils literal notranslate"><span class="pre">LLVMValue</span></code> consisting of a pointer to memory
allocated and initialized to a value <code class="docutils literal notranslate"><span class="pre">v</span></code> of type <code class="docutils literal notranslate"><span class="pre">ty</span></code>. <code class="docutils literal notranslate"><span class="pre">alloc_init_readonly</span></code>
does the same, except the memory allocated cannot be written to.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="s2">&quot;Salsa20.cry&quot;</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">alloc_init</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="nb">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">alloc_init_readonly</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc_readonly</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="nb">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We now define
<code class="docutils literal notranslate"><span class="pre">ptr_to_fresh</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">(Term,</span> <span class="pre">LLVMValue)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ptr_to_fresh</span> <span class="pre">n</span> <span class="pre">ty</span></code> returns a pair <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">p)</span></code> consisting of a fresh symbolic
variable <code class="docutils literal notranslate"><span class="pre">x</span></code> of type <code class="docutils literal notranslate"><span class="pre">ty</span></code> and a pointer <code class="docutils literal notranslate"><span class="pre">p</span></code> to it. <code class="docutils literal notranslate"><span class="pre">n</span></code> specifies the
name that SAW should use when printing <code class="docutils literal notranslate"><span class="pre">x</span></code>. <code class="docutils literal notranslate"><span class="pre">ptr_to_fresh_readonly</span></code> does the
same, but returns a pointer to space that cannot be written to.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">alloc_init</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="nb">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">let</span><span class="w"> </span><span class="n">ptr_to_fresh_readonly</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">alloc_init_readonly</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="nb">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Finally, we define
<code class="docutils literal notranslate"><span class="pre">oneptr_update_func</span> <span class="pre">:</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">LLVMType</span> <span class="pre">-&gt;</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">oneptr_update_func</span> <span class="pre">n</span> <span class="pre">ty</span> <span class="pre">f</span></code> specifies the behavior of a function that takes
a single pointer (with a printable name given by <code class="docutils literal notranslate"><span class="pre">n</span></code>) to memory containing a
value of type <code class="docutils literal notranslate"><span class="pre">ty</span></code> and mutates the contents of that memory. The specification
asserts that the contents of this memory after execution are equal to the value
given by the application of <code class="docutils literal notranslate"><span class="pre">f</span></code> to the value in that memory before execution.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">oneptr_update_func</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">ty</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">f</span><span class="w"> </span><span class="nf">x</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="the-quarterround-operation">
<h4>The <code class="docutils literal notranslate"><span class="pre">quarterround</span></code> operation<a class="headerlink" href="#the-quarterround-operation" title="Link to this heading"></a></h4>
<p>The C function we wish to verify has type
<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">s20_quarterround(uint32_t</span> <span class="pre">*y0,</span> <span class="pre">uint32_t</span> <span class="pre">*y1,</span> <span class="pre">uint32_t</span> <span class="pre">*y2,</span> <span class="pre">uint32_t</span> <span class="pre">*y3)</span></code>.</p>
<p>The function’s specification generates four symbolic variables and pointers to
them in the precondition/setup stage. The pointers are passed to the function
during symbolic execution via <code class="docutils literal notranslate"><span class="pre">llvm_execute_func</span></code>. Finally, in the
postcondition/return stage, the expected values are computed using the trusted
Cryptol implementation and it is asserted that the pointers do in fact point to
these expected values.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">quarterround_setup</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">LLVMSetup</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">y0</span><span class="p">,</span><span class="w"> </span><span class="n">p0</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;y0&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">y1</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;y1&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">y2</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;y2&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="n">y3</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;y3&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">];</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">quarterround</span><span class="w"> </span><span class="p">[</span><span class="nf">y</span><span class="mi">0</span><span class="p">,</span><span class="nf">y</span><span class="mi">1</span><span class="p">,</span><span class="nf">y</span><span class="mi">2</span><span class="p">,</span><span class="nf">y</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span><span class="w"> </span><span class="c c-Singleline">// from Salsa20.cry</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">zs</span><span class="o">@</span><span class="mi">0</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">zs</span><span class="o">@</span><span class="mi">1</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">zs</span><span class="o">@</span><span class="mi">2</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">zs</span><span class="o">@</span><span class="mi">3</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="simple-updating-functions">
<h4>Simple Updating Functions<a class="headerlink" href="#simple-updating-functions" title="Link to this heading"></a></h4>
<p>The following functions can all have their specifications given by the utility
function <code class="docutils literal notranslate"><span class="pre">oneptr_update_func</span></code> implemented above, so there isn’t much to say
about them.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">rowround_setup</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">oneptr_update_func</span><span class="w"> </span><span class="s2">&quot;y&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">rowround</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">columnround_setup</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">oneptr_update_func</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">columnround</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">doubleround_setup</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">oneptr_update_func</span><span class="w"> </span><span class="s2">&quot;x&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">doubleround</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">salsa20_setup</span><span class="w"> </span><span class="ow">=</span>
<span class="w">    </span><span class="n">oneptr_update_func</span><span class="w"> </span><span class="s2">&quot;seq&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="bit-key-expansion">
<h4>32-Bit Key Expansion<a class="headerlink" href="#bit-key-expansion" title="Link to this heading"></a></h4>
<p>The next function of substantial behavior that we wish to verify has the
following prototype:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">s20_expand32</span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">k</span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">n</span><span class="p">[</span><span class="k">static</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">keystream</span><span class="p">[</span><span class="k">static</span><span class="w"> </span><span class="mi">64</span><span class="p">]</span>
<span class="w">                 </span><span class="p">)</span>
</pre></div>
</div>
<p>This function’s specification follows a similar pattern to that of
<code class="docutils literal notranslate"><span class="pre">s20_quarterround</span></code>, though for extra assurance we can make sure that the
function does not write to the memory pointed to by <code class="docutils literal notranslate"><span class="pre">k</span></code> or <code class="docutils literal notranslate"><span class="pre">n</span></code> using the
utility <code class="docutils literal notranslate"><span class="pre">ptr_to_fresh_readonly</span></code>, as this function should only modify
<code class="docutils literal notranslate"><span class="pre">keystream</span></code>. Besides this, we see the call to the trusted Cryptol
implementation specialized to <code class="docutils literal notranslate"><span class="pre">a=2</span></code>, which does 32-bit key expansion (since the
Cryptol implementation can also specialize to <code class="docutils literal notranslate"><span class="pre">a=1</span></code> for 16-bit keys). This
specification can easily be changed to work with 16-bit keys.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">salsa20_expansion_32</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">pk</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh_readonly</span><span class="w"> </span><span class="s2">&quot;k&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>
<span class="w">    </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">pn</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh_readonly</span><span class="w"> </span><span class="s2">&quot;n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>

<span class="w">    </span><span class="n">pks</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_alloc</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>

<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="n">pk</span><span class="p">,</span><span class="w"> </span><span class="n">pn</span><span class="p">,</span><span class="w"> </span><span class="n">pks</span><span class="p">];</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rks</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_expansion</span><span class="p">`{</span><span class="nf">a</span><span class="ow">=</span><span class="mi">2</span><span class="p">}(</span><span class="nf">k</span><span class="p">,</span><span class="w"> </span><span class="nf">n</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">pks</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">rks</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="bit-key-encryption">
<h4>32-bit Key Encryption<a class="headerlink" href="#bit-key-encryption" title="Link to this heading"></a></h4>
<p>Finally, we write a specification for the encryption function itself, which has
type</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">s20_status_t</span><span class="w"> </span><span class="n">s20_crypt32</span><span class="p">(</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">key</span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">nonce</span><span class="p">[</span><span class="k">static</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">si</span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buflen</span>
<span class="w">                             </span><span class="p">)</span>
</pre></div>
</div>
<p>As before, we can ensure this function does not modify the memory pointed to by
<code class="docutils literal notranslate"><span class="pre">key</span></code> or <code class="docutils literal notranslate"><span class="pre">nonce</span></code>. We take <code class="docutils literal notranslate"><span class="pre">si</span></code>, the stream index, to be 0. The specification is
parameterized on a number <code class="docutils literal notranslate"><span class="pre">n</span></code>, which corresponds to <code class="docutils literal notranslate"><span class="pre">buflen</span></code>. Finally, to deal
with the fact that this function returns a status code, we simply specify that
we expect a success (status code 0) as the return value in the postcondition
stage of the specification.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">s20_encrypt32</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">pkey</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh_readonly</span><span class="w"> </span><span class="s2">&quot;key&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>
<span class="w">    </span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">pv</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh_readonly</span><span class="w"> </span><span class="s2">&quot;nonce&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>
<span class="w">    </span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">pm</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">ptr_to_fresh</span><span class="w"> </span><span class="s2">&quot;buf&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_array</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span>

<span class="w">    </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">pkey</span>
<span class="w">                      </span><span class="p">,</span><span class="w"> </span><span class="n">pv</span>
<span class="w">                      </span><span class="p">,</span><span class="w"> </span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span>
<span class="w">                      </span><span class="p">,</span><span class="w"> </span><span class="n">pm</span>
<span class="w">                      </span><span class="p">,</span><span class="w"> </span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="p">`</span><span class="nf">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span>
<span class="w">                      </span><span class="p">];</span>

<span class="w">    </span><span class="nb">llvm_points_to</span><span class="w"> </span><span class="n">pm</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="kt">S</span><span class="nf">alsa</span><span class="mi">20</span><span class="nf">_encrypt</span><span class="w"> </span><span class="p">(</span><span class="nf">key</span><span class="p">,</span><span class="w"> </span><span class="nf">v</span><span class="p">,</span><span class="w"> </span><span class="nf">m</span><span class="p">)</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="w">    </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="verifying-everything">
<h3>Verifying Everything<a class="headerlink" href="#verifying-everything" title="Link to this heading"></a></h3>
<p>Finally, we can verify all of the functions. Notice the use of compositional
verification and that path satisfiability checking is enabled for those
functions with loops not bounded by explicit constants. Notice that we prove
the top-level function for several sizes; this is due to the limitation that
SAW can only operate on finite programs (while Salsa20 can operate on any input
size.)</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">TopLevel</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">m</span><span class="w">      </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_load_module</span><span class="w"> </span><span class="s2">&quot;salsa20.bc&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">qr</span><span class="w">     </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_quarterround&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w">      </span><span class="kc">false</span><span class="w"> </span><span class="n">quarterround_setup</span><span class="w">   </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">rr</span><span class="w">     </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_rowround&quot;</span><span class="w">     </span><span class="p">[</span><span class="n">qr</span><span class="p">]</span><span class="w">    </span><span class="kc">false</span><span class="w"> </span><span class="n">rowround_setup</span><span class="w">       </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">cr</span><span class="w">     </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_columnround&quot;</span><span class="w">  </span><span class="p">[</span><span class="n">qr</span><span class="p">]</span><span class="w">    </span><span class="kc">false</span><span class="w"> </span><span class="n">columnround_setup</span><span class="w">    </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">dr</span><span class="w">     </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_doubleround&quot;</span><span class="w">  </span><span class="p">[</span><span class="n">cr</span><span class="p">,</span><span class="n">rr</span><span class="p">]</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">doubleround_setup</span><span class="w">    </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">s20</span><span class="w">    </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_hash&quot;</span><span class="w">         </span><span class="p">[</span><span class="n">dr</span><span class="p">]</span><span class="w">    </span><span class="kc">false</span><span class="w"> </span><span class="n">salsa20_setup</span><span class="w">        </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">s20e32</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_expand32&quot;</span><span class="w">     </span><span class="p">[</span><span class="n">s20</span><span class="p">]</span><span class="w">   </span><span class="kc">true</span><span class="w">  </span><span class="n">salsa20_expansion_32</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">s20encrypt_63</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_crypt32&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">s20e32</span><span class="p">]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="n">s20_encrypt32</span><span class="w"> </span><span class="mi">63</span><span class="p">)</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">s20encrypt_64</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_crypt32&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">s20e32</span><span class="p">]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="n">s20_encrypt32</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>
<span class="w">    </span><span class="n">s20encrypt_65</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="s2">&quot;s20_crypt32&quot;</span><span class="w"> </span><span class="p">[</span><span class="n">s20e32</span><span class="p">]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="n">s20_encrypt32</span><span class="w"> </span><span class="mi">65</span><span class="p">)</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span>

<span class="w">    </span><span class="nb">print</span><span class="w"> </span><span class="s2">&quot;Done!&quot;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="verifying-cryptol-ffi-functions">
<h2>Verifying Cryptol FFI functions<a class="headerlink" href="#verifying-cryptol-ffi-functions" title="Link to this heading"></a></h2>
<p>SAW has special support for verifying the correctness of Cryptol’s
<a class="reference external" href="https://galoisinc.github.io/cryptol/master/FFI.html"><code class="docutils literal notranslate"><span class="pre">foreign</span></code>
functions</a>,
implemented in a language such as C which compiles to LLVM, provided
that there exists a <a class="reference external" href="https://galoisinc.github.io/cryptol/master/FFI.html#cryptol-implementation-of-foreign-functions">reference Cryptol
implementation</a>
of the function as well. Since the way in which <code class="docutils literal notranslate"><span class="pre">foreign</span></code> functions are
called is precisely specified by the Cryptol FFI, SAW is able to
generate a <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span> <span class="pre">()</span></code> spec directly from the type of a Cryptol
<code class="docutils literal notranslate"><span class="pre">foreign</span></code> function. This is done with the <code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span></code> command,
which is experimental and requires <code class="docutils literal notranslate"><span class="pre">enable_experimental;</span></code> to be run
beforehand.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span> <span class="pre">:</span> <span class="pre">Term</span> <span class="pre">-&gt;</span> <span class="pre">LLVMSetup</span> <span class="pre">()</span></code></p></li>
</ul>
<p>For instance, for the simple imported Cryptol foreign function <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">add</span> <span class="pre">:</span> <span class="pre">[32]</span> <span class="pre">-&gt;</span> <span class="pre">[32]</span> <span class="pre">-&gt;</span> <span class="pre">[32]</span></code> we can obtain a <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span></code> spec simply by
writing</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">add_setup</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">llvm_ffi_setup</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">add</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
</pre></div>
</div>
<p>which behind the scenes expands to something like</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">add_setup</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">in0</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;in0&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">  </span><span class="n">in1</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_fresh_var</span><span class="w"> </span><span class="s2">&quot;in1&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_int</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="w">  </span><span class="nb">llvm_execute_func</span><span class="w"> </span><span class="p">[</span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">in0</span><span class="p">,</span><span class="w"> </span><span class="nb">llvm_term</span><span class="w"> </span><span class="n">in1</span><span class="p">];</span>
<span class="w">  </span><span class="nb">llvm_return</span><span class="w"> </span><span class="p">(</span><span class="nb">llvm_term</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">add</span><span class="w"> </span><span class="nf">in</span><span class="mi">0</span><span class="w"> </span><span class="nf">in</span><span class="mi">1</span><span class="w"> </span><span class="l">}}</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="polymorphism">
<h3>Polymorphism<a class="headerlink" href="#polymorphism" title="Link to this heading"></a></h3>
<p>In general, Cryptol <code class="docutils literal notranslate"><span class="pre">foreign</span></code> functions can be polymorphic, with type
parameters of kind <code class="docutils literal notranslate"><span class="pre">#</span></code>, representing e.g. the sizes of input sequences.
However, any individual <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span> <span class="pre">()</span></code> spec only specifies the behavior
of the LLVM function on inputs of concrete sizes. We handle this by
allowing the argument term of <code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span></code> to contain any necessary
type arguments in addition to the Cryptol function name, so that the
resulting term is monomorphic. The user can then define a parameterized
specification simply as a SAWScript function in the usual way. For
example, for a function <code class="docutils literal notranslate"><span class="pre">foreign</span> <span class="pre">f</span> <span class="pre">:</span> <span class="pre">{n,</span> <span class="pre">m}</span> <span class="pre">(fin</span> <span class="pre">n,</span> <span class="pre">fin</span> <span class="pre">m)</span> <span class="pre">=&gt;</span> <span class="pre">[n][32]</span> <span class="pre">-&gt;</span> <span class="pre">[m][32]</span></code>, we can obtain a parameterized <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span></code> spec by</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">f_setup</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Int</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">llvm_ffi_setup</span><span class="w"> </span><span class="l">{{</span><span class="w"> </span><span class="nf">f</span><span class="p">`{</span><span class="nf">n</span><span class="p">,</span><span class="w"> </span><span class="nf">m</span><span class="p">}</span><span class="w"> </span><span class="l">}}</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">Term</span></code> parameter that <code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span></code> takes is restricted
syntactically to the format described above (<code class="docutils literal notranslate"><span class="pre">{{</span> <span class="pre">fun`{tyArg0,</span> <span class="pre">tyArg1,</span> <span class="pre">...,</span> <span class="pre">tyArgN}</span> <span class="pre">}}</span></code>), and cannot be any arbitrary term.</p>
</section>
<section id="supported-types">
<h3>Supported types<a class="headerlink" href="#supported-types" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span></code> supports all Cryptol types that are supported by the
Cryptol FFI, with the exception of <code class="docutils literal notranslate"><span class="pre">Integer</span></code>, <code class="docutils literal notranslate"><span class="pre">Rational</span></code>, <code class="docutils literal notranslate"><span class="pre">Z</span></code>, and
<code class="docutils literal notranslate"><span class="pre">Float</span></code>. <code class="docutils literal notranslate"><span class="pre">Integer</span></code>, <code class="docutils literal notranslate"><span class="pre">Rational</span></code>, and <code class="docutils literal notranslate"><span class="pre">Z</span></code> are not supported since they are
translated to <code class="docutils literal notranslate"><span class="pre">gmp</span></code> arbitrary-precision types which are hard for SAW to
handle without additional overrides. There is no fundamental obstacle to
supporting <code class="docutils literal notranslate"><span class="pre">Float</span></code>, and in fact <code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span></code> itself does work with
Cryptol floating point types, but the underlying functions such as
<code class="docutils literal notranslate"><span class="pre">llvm_fresh_var</span></code> do not, so until that is implemented <code class="docutils literal notranslate"><span class="pre">llvm_ffi_setup</span></code>
can generate a spec involving floating point types but it cannot
actually be run.</p>
<p>Note also that for the time being only the <code class="docutils literal notranslate"><span class="pre">c</span></code> calling convention is
supported.
Support for the recently-added <code class="docutils literal notranslate"><span class="pre">abstract</span></code> calling convention has not
been written yet.
See <a class="reference external" href="https://github.com/GaloisInc/saw-script/issues/2546">issue #2546</a>.</p>
</section>
<section id="performing-the-verification">
<h3>Performing the verification<a class="headerlink" href="#performing-the-verification" title="Link to this heading"></a></h3>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">LLVMSetup</span> <span class="pre">()</span></code> spec can be used with the existing
<code class="docutils literal notranslate"><span class="pre">llvm_verify</span></code> function to perform the actual verification. And the
<code class="docutils literal notranslate"><span class="pre">LLVMSpec</span></code> output from that can be used as an override as usual for
further compositional verification.</p>
<div class="highlight-sawscript notranslate"><div class="highlight"><pre><span></span><span class="n">f_ov</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="nb">llvm_verify</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="s2">&quot;f&quot;</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">(</span><span class="n">f_setup</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="n">z3</span><span class="p">;</span>
</pre></div>
</div>
<p>As with the Cryptol FFI itself, SAW does not manage the compilation of
the C source implementations of <code class="docutils literal notranslate"><span class="pre">foreign</span></code> functions to LLVM bitcode. For
the verification to be meaningful, is expected that the LLVM module
passed to <code class="docutils literal notranslate"><span class="pre">llvm_verify</span></code> matches the compiled dynamic library actually
used with the Cryptol interpreter. Alternatively, on x86_64 Linux, SAW
can perform verification directly on the <code class="docutils literal notranslate"><span class="pre">.so</span></code> ELF file with the
experimental <code class="docutils literal notranslate"><span class="pre">llvm_verify_x86</span></code> command.</p>
</section>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Salsa20">https://en.wikipedia.org/wiki/Salsa20</a></p>
</aside>
</aside>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="the-term-type.html" class="btn btn-neutral float-left" title="The Term Type" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bisimulation-prover.html" class="btn btn-neutral float-right" title="Bisimulation Prover" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Galois, Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <!-- Adapted from: -->
<!-- https://github.com/brechtm/rinohtype/commit/1270802c4959eb4742c51d3307222930ac73a80c -->


  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Versions</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl id="docs-versions">
      </dl>
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>