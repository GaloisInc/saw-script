{- |
Module      : CryptolSAWCore.Simpset
Copyright   : Galois, Inc. 2018
License     : BSD3
Maintainer  : huffman@galois.com
Stability   : experimental
Portability : non-portable (language extensions)
-}

{-# LANGUAGE OverloadedStrings #-}

module CryptolSAWCore.Simpset
  ( mkCryptolSimpset
  ) where

import SAWCore.Conversion (natConversions)
import SAWCore.Module (moduleDefs, Def(..))
import SAWCore.Name
import SAWCore.Rewriter
import SAWCore.SharedTerm

-- | Build a 'Simpset' with rewrite rules that can simplify terms
-- generated by the Cryptol-to-SAWCore translator, reducing them to
-- more basic operations and types from the SAWCore prelude.
--
-- The Cryptol translator generates coercions for non-trivial type
-- equalities proved by the Cryptol typechecker.
-- We include rewrite rules that can simplify them away after types
-- are instantiated and the coercions become trivial.

mkCryptolSimpset :: SharedContext -> IO (Simpset a)
mkCryptolSimpset sc =
  do m <- scFindModule sc cryptolModuleName
     scSimpset sc (cryptolDefs m) idents natConversions
  where
    cryptolDefs m = filter (not . excluded) $ moduleDefs m
    excluded d =
      case nameInfo (defName d) of
        ModuleIdentifier ident -> ident `elem` excludedNames
        ImportedName{} -> True
    idents = ["Prelude.coerce_same", "Prelude.unsafeCoerce_same"]

cryptolModuleName :: ModuleName
cryptolModuleName = mkModuleName ["Cryptol"]

excludedNames :: [Ident]
excludedNames =
  map (mkIdent cryptolModuleName)
  [ "fix"
  , "pair_cong"
  , "seq_cong"
  , "pair_cong1"
  , "pair_cong2"
  , "seq_cong1"
  , "fun_cong"
  , "seq_TCNum"
  , "seq_TCInf"
  , "PLiteral"
  , "PLogic"
  , "PRing"
  , "PIntegral"
  , "PField"
  , "PRound"
  , "PEq"
  , "PCmp"
  , "PSignedCmp"
  , "ecEq"
  ]
