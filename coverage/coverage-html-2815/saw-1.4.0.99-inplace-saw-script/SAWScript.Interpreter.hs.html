<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Interpreter
<span class="lineno">    3 </span>Description : Interpreter for SAW-Script files and statements.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    9 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   10 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   11 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   12 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   13 </span>{-# LANGUAGE NondecreasingIndentation #-}
<span class="lineno">   14 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   15 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   16 </span>-- See Note [-Wincomplete-uni-patterns and irrefutable patterns] in
<span class="lineno">   17 </span>-- SAWScript.Typechecker
<span class="lineno">   18 </span>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>module SAWScript.Interpreter
<span class="lineno">   21 </span>  ( interpretTopStmt
<span class="lineno">   22 </span>  , processFile
<span class="lineno">   23 </span>  , buildTopLevelEnv
<span class="lineno">   24 </span>  )
<span class="lineno">   25 </span>  where
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>import qualified Control.Exception as X
<span class="lineno">   28 </span>import Control.Monad (unless, when)
<span class="lineno">   29 </span>import Control.Monad.IO.Class (liftIO)
<span class="lineno">   30 </span>import Control.Monad.Reader (ask)
<span class="lineno">   31 </span>import Control.Monad.State (gets, get, put)
<span class="lineno">   32 </span>import qualified Data.ByteString as BS
<span class="lineno">   33 </span>import Data.Maybe (fromMaybe, mapMaybe)
<span class="lineno">   34 </span>import Data.List (genericLength)
<span class="lineno">   35 </span>import qualified Data.Map as Map
<span class="lineno">   36 </span>import Data.Map ( Map )
<span class="lineno">   37 </span>import Data.Sequence (Seq( (:|&gt;) ))
<span class="lineno">   38 </span>import qualified Data.Sequence as Seq (empty)
<span class="lineno">   39 </span>import qualified Data.Set as Set
<span class="lineno">   40 </span>import qualified Data.Text as Text
<span class="lineno">   41 </span>import Data.Text (Text)
<span class="lineno">   42 </span>import qualified Data.Text.IO as TextIO
<span class="lineno">   43 </span>import System.Directory (getCurrentDirectory, setCurrentDirectory)
<span class="lineno">   44 </span>import System.FilePath (takeDirectory)
<span class="lineno">   45 </span>import System.Environment (lookupEnv)
<span class="lineno">   46 </span>import System.Process (readProcess)
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>import Data.Parameterized.Some
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>import qualified Data.AIG.CompactGraph as AIG
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>import qualified Text.LLVM.AST as LLVM (Type)
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>import qualified Lang.JVM.Codebase as JSS
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import qualified Cryptol.TypeCheck.AST as Cryptol
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>import qualified Lang.Crucible.JVM as CJ
<span class="lineno">   59 </span>import Lang.Crucible.LLVM.ArraySizeProfile (FunctionProfile)
<span class="lineno">   60 </span>import Mir.Intrinsics (MIR)
<span class="lineno">   61 </span>import qualified Mir.Generator as MIR (RustModule)
<span class="lineno">   62 </span>import qualified Mir.Mir as MIR
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>import qualified SAWSupport.ScopedMap as ScopedMap
<span class="lineno">   65 </span>--import SAWSupport.ScopedMap (ScopedMap)
<span class="lineno">   66 </span>import qualified SAWSupport.Pretty as PPS (MemoStyle(..), Opts(..), defaultOpts, pShow, pShowText)
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>import SAWCore.FiniteValue (FirstOrderValue(..))
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>--import SAWCentral.Trace (Trace)
<span class="lineno">   73 </span>import qualified SAWCentral.Trace as Trace
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>import qualified SAWCentral.AST as SS
<span class="lineno">   76 </span>import qualified SAWCentral.Position as SS
<span class="lineno">   77 </span>import SAWCentral.AST (Import(..), PrimitiveLifecycle(..), defaultAvailable)
<span class="lineno">   78 </span>import SAWCentral.Bisimulation
<span class="lineno">   79 </span>import SAWCentral.Builtins
<span class="lineno">   80 </span>import SAWCentral.Exceptions (failTypecheck)
<span class="lineno">   81 </span>import qualified SAWScript.Loader as Loader
<span class="lineno">   82 </span>import SAWCentral.JavaExpr
<span class="lineno">   83 </span>import SAWCentral.LLVMBuiltins
<span class="lineno">   84 </span>import SAWCentral.Options
<span class="lineno">   85 </span>import SAWScript.Typechecker (checkStmt, typesMatch)
<span class="lineno">   86 </span>import SAWScript.Panic (panic)
<span class="lineno">   87 </span>import SAWCentral.TopLevel
<span class="lineno">   88 </span>import SAWCentral.Utils
<span class="lineno">   89 </span>import SAWCentral.Value
<span class="lineno">   90 </span>import SAWScript.ValueOps
<span class="lineno">   91 </span>import SAWCentral.SolverCache
<span class="lineno">   92 </span>import SAWCentral.SolverVersions
<span class="lineno">   93 </span>import SAWCentral.Proof (ProofResult(..), Theorem, emptyTheoremDB)
<span class="lineno">   94 </span>import SAWCentral.Prover.Rewrite(basic_ss)
<span class="lineno">   95 </span>import SAWCentral.Prover.Exporter
<span class="lineno">   96 </span>import SAWCentral.Yosys -- XXX remove in favor of the following later
<span class="lineno">   97 </span>import qualified SAWCentral.Yosys as Yo (YosysIR)
<span class="lineno">   98 </span>import qualified SAWCentral.Yosys.State as Yo (YosysSequential)
<span class="lineno">   99 </span>import qualified SAWCentral.Yosys.Theorem as Yo (YosysImport, YosysTheorem)
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>import SAWCore.Module (emptyModule)
<span class="lineno">  102 </span>import SAWCore.Name (mkModuleName)
<span class="lineno">  103 </span>import SAWCore.Prim (rethrowEvalError)
<span class="lineno">  104 </span>import SAWCore.Rewriter (emptySimpset)
<span class="lineno">  105 </span>import SAWCore.SharedTerm
<span class="lineno">  106 </span>import SAWCore.Term.Raw (closedTerm)
<span class="lineno">  107 </span>import qualified CryptolSAWCore.CryptolEnv as CEnv
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>import qualified CryptolSAWCore.Prelude as CryptolSAW
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- Crucible
<span class="lineno">  112 </span>import qualified SAWCentral.Crucible.Common as CC
<span class="lineno">  113 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as CMS
<span class="lineno">  114 </span>import qualified SAWCentral.Crucible.JVM.BuiltinsJVM as CJ
<span class="lineno">  115 </span>import           SAWCentral.Crucible.LLVM.Builtins
<span class="lineno">  116 </span>import           SAWCentral.Crucible.JVM.Builtins
<span class="lineno">  117 </span>import           SAWCentral.Crucible.MIR.Builtins
<span class="lineno">  118 </span>import           SAWCentral.Crucible.LLVM.X86
<span class="lineno">  119 </span>import           SAWCentral.Crucible.LLVM.Boilerplate
<span class="lineno">  120 </span>import           SAWCentral.Crucible.LLVM.Skeleton (ModuleSkeleton, FunctionSkeleton)
<span class="lineno">  121 </span>import           SAWCentral.Crucible.LLVM.Skeleton.Builtins
<span class="lineno">  122 </span>import           SAWCentral.Crucible.LLVM.FFI
<span class="lineno">  123 </span>import qualified SAWCentral.Crucible.LLVM.MethodSpecIR as CIR
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>-- Cryptol
<span class="lineno">  126 </span>import qualified Cryptol.Eval as V (PPOpts(..))
<span class="lineno">  127 </span>import qualified Cryptol.Backend.Monad as V (runEval)
<span class="lineno">  128 </span>import qualified Cryptol.Eval.Value as V (defaultPPOpts, ppValue)
<span class="lineno">  129 </span>import qualified Cryptol.Eval.Concrete as V (Concrete(..))
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>import qualified Prettyprinter as PP (pretty)
<span class="lineno">  132 </span>import qualified Prettyprinter.Render.Text as PP (putDoc)
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>import SAWScript.AutoMatch
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>------------------------------------------------------------
<span class="lineno">  141 </span>-- Support
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- This is used to reject top-level execution of polymorphic
<span class="lineno">  144 </span>-- expressions. Assumes we aren't inside an uninstantiated forall
<span class="lineno">  145 </span>-- quantifier. Also assumes the typechecker has already approved the
<span class="lineno">  146 </span>-- type. This means we know it doesn't contain unbound named type
<span class="lineno">  147 </span>-- variables. Fail if we encounter a unification var.
<span class="lineno">  148 </span>--
<span class="lineno">  149 </span>-- XXX: this serves little purpose. A polymorphic expression must
<span class="lineno">  150 </span>-- either be a partially applied (or unapplied) polymorphic function,
<span class="lineno">  151 </span>-- in which case we aren't going to actually execute anything anyway,
<span class="lineno">  152 </span>-- or be fully applied but have a polymorphic return type, and the
<span class="lineno">  153 </span>-- only such functions we can have are those that don't return (like
<span class="lineno">  154 </span>-- &quot;fail&quot;) so we don't actually care what they produce. So this code
<span class="lineno">  155 </span>-- and the check that calls it should probably be removed.
<span class="lineno">  156 </span>--
<span class="lineno">  157 </span>-- XXX: also, this is here transiently so that the rejection continues
<span class="lineno">  158 </span>-- to work while the interaction between the interpreter and the
<span class="lineno">  159 </span>-- typechecker is rationalized. In the long run, the rejection should
<span class="lineno">  160 </span>-- really belong only to the repl for repl purposes and the
<span class="lineno">  161 </span>-- polymorphism check should be part of the currently nonexistent
<span class="lineno">  162 </span>-- incremental interface to the typechecker. Alternatively, if there
<span class="lineno">  163 </span>-- are cases that really require rejection of polymorphic expressions
<span class="lineno">  164 </span>-- at the top level, they also require rejection of polymorphic
<span class="lineno">  165 </span>-- expressions in nested do-blocks that aren't inside functions, and
<span class="lineno">  166 </span>-- it can and should all happen inside the typechecker.
<span class="lineno">  167 </span>isPolymorphic :: SS.Type -&gt; Bool
<span class="lineno">  168 </span><span class="decl"><span class="istickedoff">isPolymorphic ty0 = case ty0 of</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">SS.TyCon _pos _tycon args -&gt; any isPolymorphic args</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">SS.TyRecord _pos fields -&gt; <span class="nottickedoff">any isPolymorphic fields</span></span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">SS.TyVar _pos _a -&gt; False</span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">SS.TyUnifyVar _pos _ix -&gt; True</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- Get the type of an AST element. For now, only patterns because that's
<span class="lineno">  175 </span>-- what we're using.
<span class="lineno">  176 </span>--
<span class="lineno">  177 </span>-- Assumes we have been through the typechecker and the types are filled in.
<span class="lineno">  178 </span>--
<span class="lineno">  179 </span>-- XXX: this should be a typeclass function with instances for all the AST
<span class="lineno">  180 </span>-- types.
<span class="lineno">  181 </span>--
<span class="lineno">  182 </span>-- XXX: also it should be moved to ASTUtil once we have such a place.
<span class="lineno">  183 </span>getType :: SS.Pattern -&gt; SS.Type
<span class="lineno">  184 </span><span class="decl"><span class="istickedoff">getType pat = case pat of</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos ~(Just t) -&gt; t</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _allpos _xpos _x ~(Just t) -&gt; t</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple tuplepos pats -&gt;</span>
<span class="lineno">  188 </span><span class="spaces">        </span><span class="istickedoff">SS.TyCon <span class="nottickedoff">tuplepos</span> (SS.TupleCon <span class="nottickedoff">(genericLength pats)</span>) (map getType pats)</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- Convert some text to an InputText for cryptol-saw-core.
<span class="lineno">  191 </span>toInputText :: SS.Pos -&gt; Text -&gt; CEnv.InputText
<span class="lineno">  192 </span><span class="decl"><span class="istickedoff">toInputText pos0 txt =</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">CEnv.InputText {</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpText = txt,</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpFile = file,</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpLine = ln,</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">CEnv.inpCol  = col + 2 -- for dropped }}</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff">}</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="istickedoff">(file, ln, col) = extract pos0</span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">extract pos = case pos of</span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="istickedoff">SS.Range f sl sc _ _ -&gt; (f,sl, sc)</span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">SS.FileOnlyPos f -&gt; <span class="nottickedoff">(f, 1, 1)</span></span>
<span class="lineno">  204 </span><span class="spaces">      </span><span class="istickedoff">SS.FileAndFunctionPos f _ -&gt; <span class="nottickedoff">(f, 1, 1)</span></span>
<span class="lineno">  205 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInferred _ pos' -&gt; <span class="nottickedoff">extract pos'</span></span>
<span class="lineno">  206 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInternal s -&gt; <span class="nottickedoff">(s,1,1)</span></span>
<span class="lineno">  207 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInsideBuiltin -&gt; <span class="nottickedoff">(&quot;(builtin)&quot;, 1, 1)</span></span>
<span class="lineno">  208 </span><span class="spaces">      </span><span class="istickedoff">SS.PosREPL       -&gt; <span class="nottickedoff">(&quot;&lt;interactive&gt;&quot;, 1, 1)</span></span>
<span class="lineno">  209 </span><span class="spaces">      </span><span class="istickedoff">SS.Unknown       -&gt; <span class="nottickedoff">(&quot;Unknown&quot;, 1, 1)</span></span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | &quot;Position of last reference&quot; for values that haven't been
<span class="lineno">  212 </span>--   referenced.
<span class="lineno">  213 </span>--
<span class="lineno">  214 </span>--   Used in toValue so it'll appear in the builtin table. However,
<span class="lineno">  215 </span>--   it should always be replaced when the value is retrieved and
<span class="lineno">  216 </span>--   before it's returned out or passed on by the interpreter for
<span class="lineno">  217 </span>--   execution. So users should never see it.
<span class="lineno">  218 </span>--
<span class="lineno">  219 </span>--   FUTURE: might make sense to set this to a panic.
<span class="lineno">  220 </span>atRestPos :: SS.Pos
<span class="lineno">  221 </span><span class="decl"><span class="nottickedoff">atRestPos = SS.PosInternal &quot;&lt;&lt;position of value at rest; shouldn't be seen&gt;&gt;&quot;</span></span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>-- | Update the position in a plain monadic value.
<span class="lineno">  224 </span>injectPositionIntoMonadicValue :: SS.Pos -&gt; Value -&gt; Value
<span class="lineno">  225 </span><span class="decl"><span class="istickedoff">injectPositionIntoMonadicValue pos v = case v of</span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="istickedoff">VTopLevel _oldpos chain f -&gt; VTopLevel pos chain f</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">VProofScript _oldpos chain f -&gt; VProofScript pos chain f</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">VLLVMCrucibleSetup _oldpos chain f -&gt; VLLVMCrucibleSetup pos chain f</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">VJVMSetup _oldpos chain f -&gt; VJVMSetup pos chain f</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">VMIRSetup _oldpos chain f -&gt; VMIRSetup pos chain f</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; v</span></span>
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>-- | Insert an entry in a plain monadic value's RefChain.
<span class="lineno">  234 </span>insertRefChain :: SS.Pos -&gt; SS.Name -&gt; Value -&gt; Value
<span class="lineno">  235 </span><span class="decl"><span class="istickedoff">insertRefChain pos name v =</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="istickedoff">let insert chain = (pos, name) : chain in</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">VDo chain env body -&gt; VDo (insert chain) env body</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">VBindOnce bindpos chain v1 v2 -&gt; VBindOnce bindpos (insert chain) v1 v2</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">VTopLevel vpos chain f -&gt; VTopLevel <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">VProofScript vpos chain f -&gt; VProofScript <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">VLLVMCrucibleSetup vpos chain f -&gt; VLLVMCrucibleSetup <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">VJVMSetup vpos chain f -&gt; VJVMSetup <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">VMIRSetup vpos chain f -&gt; VMIRSetup <span class="nottickedoff">vpos</span> (insert chain) f</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; v</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>-- | Merge an ancestor RefChain (e.g. from a generating do block) into
<span class="lineno">  248 </span>--   a downstream one.
<span class="lineno">  249 </span>propagateRefChain :: RefChain -&gt; Value -&gt; Value
<span class="lineno">  250 </span><span class="decl"><span class="istickedoff">propagateRefChain chain1 v =</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">let insert chain2 =</span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">-- concatenate the chain (older goes at the end)</span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">chain2 ++ chain1</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">VDo chain2 env body -&gt; <span class="nottickedoff">VDo (insert chain2) env body</span></span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">VBindOnce pos chain2 v1 v2 -&gt; <span class="nottickedoff">VBindOnce pos (insert chain2) v1 v2</span></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">VTopLevel pos chain2 f -&gt; VTopLevel <span class="nottickedoff">pos</span> (insert chain2) f</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">VProofScript pos chain2 f -&gt; VProofScript <span class="nottickedoff">pos</span> (insert chain2) f</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">VLLVMCrucibleSetup pos chain2 f -&gt; VLLVMCrucibleSetup pos (insert chain2) f</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">VJVMSetup pos chain2 f -&gt; VJVMSetup pos (insert chain2) f</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">VMIRSetup pos chain2 f -&gt; VMIRSetup pos (insert chain2) f</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">v</span></span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>------------------------------------------------------------
<span class="lineno">  267 </span>-- Environment updates
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>-- The second argument (the schema, aka type) is Nothing in most
<span class="lineno">  270 </span>-- cases, but for Decls is taken from the Decl. This will always be
<span class="lineno">  271 </span>-- Just s for Decls that have been typechecked, which are the only
<span class="lineno">  272 </span>-- ones we should be handling here.
<span class="lineno">  273 </span>--
<span class="lineno">  274 </span>-- Meanwhile the Maybe Type field of PVar is also always Just ty for
<span class="lineno">  275 </span>-- patterns that have been typechecked, and the typechecker will have
<span class="lineno">  276 </span>-- established that the type of the pattern matches the type of the
<span class="lineno">  277 </span>-- Decl if there is one.
<span class="lineno">  278 </span>--
<span class="lineno">  279 </span>-- So we should be able to remove the schema argument (and with it the
<span class="lineno">  280 </span>-- mess for dividing up a passed-in tuple), but for the moment I'm
<span class="lineno">  281 </span>-- unwilling to in case there's something weird going on somewhere.
<span class="lineno">  282 </span>-- For the time being we'll just panic if the pattern type is missing
<span class="lineno">  283 </span>-- and use it to fill in the schema if there isn't a schema passed
<span class="lineno">  284 </span>-- down. We could also assert that the schema type and the pattern
<span class="lineno">  285 </span>-- type actually match, but it's intentionally difficult to do that
<span class="lineno">  286 </span>-- outside the typechecker and not really worthwhile.
<span class="lineno">  287 </span>--
<span class="lineno">  288 </span>-- XXX: at some point clean this up further.
<span class="lineno">  289 </span>--
<span class="lineno">  290 </span>-- Update: there _is_ something weird going on. The typechecker wasn't
<span class="lineno">  291 </span>-- updating the types in patterns after doing its generalize step, so
<span class="lineno">  292 </span>-- for polymorphic bindings the types in patterns weren't usable. But
<span class="lineno">  293 </span>-- even after fixing that, using the types in the patterns produces
<span class="lineno">  294 </span>-- the wrong results -- they are not the same tyvars as the ones that
<span class="lineno">  295 </span>-- appear in the the schema. There's still something going on in
<span class="lineno">  296 </span>-- there that I don't understand.
<span class="lineno">  297 </span>--
<span class="lineno">  298 </span>bindPattern :: SS.Rebindable -&gt; SS.Pattern -&gt; Maybe SS.Schema -&gt; Value -&gt; TopLevel ()
<span class="lineno">  299 </span><span class="decl"><span class="istickedoff">bindPattern rb pat ms v =</span>
<span class="lineno">  300 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos _ -&gt;</span>
<span class="lineno">  302 </span><span class="spaces">      </span><span class="istickedoff">pure <span class="nottickedoff">()</span></span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar allpos _xpos _x Nothing -&gt;</span>
<span class="lineno">  304 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPattern&quot; [</span></span>
<span class="lineno">  305 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Found pattern with no type in it&quot;,</span></span>
<span class="lineno">  306 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Source position: &quot; &lt;&gt; Text.pack (show allpos),</span></span>
<span class="lineno">  307 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Pattern: &quot; &lt;&gt; Text.pack (show pat)</span></span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _allpos xpos x (Just ty) -&gt;</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">let s = fromMaybe <span class="nottickedoff">(SS.tMono ty)</span> ms in</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="istickedoff">extendEnv xpos x rb s <span class="nottickedoff">Nothing</span> v</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple _pos ps -&gt;</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">case v of</span>
<span class="lineno">  314 </span><span class="spaces">        </span><span class="istickedoff">VTuple vs -&gt; do</span>
<span class="lineno">  315 </span><span class="spaces">            </span><span class="istickedoff">let mss = case ms of</span>
<span class="lineno">  316 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  317 </span><span class="spaces">                        </span><span class="istickedoff">repeat <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  318 </span><span class="spaces">                    </span><span class="istickedoff">Just (SS.Forall ks (SS.TyCon _ (SS.TupleCon _) ts)) -&gt;</span>
<span class="lineno">  319 </span><span class="spaces">                        </span><span class="istickedoff">[ Just (SS.Forall ks t) | t &lt;- ts ]</span>
<span class="lineno">  320 </span><span class="spaces">                    </span><span class="istickedoff">Just t -&gt;</span>
<span class="lineno">  321 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPattern&quot; [</span></span>
<span class="lineno">  322 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple type, got &quot; &lt;&gt; Text.pack (show t)</span></span>
<span class="lineno">  323 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  324 </span><span class="spaces">            </span><span class="istickedoff">sequence_ $ zipWith3 (bindPattern rb) ps mss vs</span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  327 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple value; got &quot; &lt;&gt; Text.pack (show v)</span></span>
<span class="lineno">  328 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>------------------------------------------------------------
<span class="lineno">  332 </span>-- InterpreterMonad
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>-- Monad class to allow the interpreter to run in the Haskell
<span class="lineno">  335 </span>-- projection of the five SAWScript monads.
<span class="lineno">  336 </span>--
<span class="lineno">  337 </span>-- Note that `getMonadContext` is only used when interpreting at the
<span class="lineno">  338 </span>-- syntactic top level and thus only applies to the `TopLevel` and
<span class="lineno">  339 </span>-- `ProofScript` monads. In fact, it used to be that if anything other
<span class="lineno">  340 </span>-- than one of those was passed down into the typechecker from where
<span class="lineno">  341 </span>-- `getMonadContext` is called, it would panic. Therefore, it's ok for
<span class="lineno">  342 </span>-- `getMonadContext` itself to panic for the three Setup cases
<span class="lineno">  343 </span>-- instead.
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>class (Monad m, MonadFail m) =&gt; InterpreterMonad m where
<span class="lineno">  346 </span>  liftTopLevel :: TopLevel a -&gt; m a
<span class="lineno">  347 </span>  actionFromValue :: FromValue a =&gt; FromValueHow -&gt; Value -&gt; m a
<span class="lineno">  348 </span>  mkValue :: SS.Pos -&gt; RefChain -&gt; m Value -&gt; Value
<span class="lineno">  349 </span>  getMonadContext :: m SS.Context
<span class="lineno">  350 </span>  pushScopeAny :: m ()
<span class="lineno">  351 </span>  popScopeAny :: m ()
<span class="lineno">  352 </span>  withEnvironAny :: Environ -&gt; m a -&gt; m a
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>instance InterpreterMonad TopLevel where
<span class="lineno">  355 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = m</span></span>
<span class="lineno">  356 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  357 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VTopLevel <span class="nottickedoff">pos</span> chain m</span></span>
<span class="lineno">  358 </span>  <span class="decl"><span class="istickedoff">getMonadContext = return SS.TopLevel</span></span>
<span class="lineno">  359 </span>  <span class="decl"><span class="istickedoff">pushScopeAny = pushScope</span></span>
<span class="lineno">  360 </span>  <span class="decl"><span class="istickedoff">popScopeAny = popScope</span></span>
<span class="lineno">  361 </span>  <span class="decl"><span class="istickedoff">withEnvironAny = withEnviron</span></span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>instance InterpreterMonad ProofScript where
<span class="lineno">  364 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = scriptTopLevel m</span></span>
<span class="lineno">  365 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  366 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VProofScript <span class="nottickedoff">pos</span> chain m</span></span>
<span class="lineno">  367 </span>  <span class="decl"><span class="istickedoff">getMonadContext = return SS.ProofScript</span></span>
<span class="lineno">  368 </span>  <span class="decl"><span class="istickedoff">pushScopeAny = scriptTopLevel pushScope</span></span>
<span class="lineno">  369 </span>  <span class="decl"><span class="istickedoff">popScopeAny = scriptTopLevel popScope</span></span>
<span class="lineno">  370 </span>  <span class="decl"><span class="istickedoff">withEnvironAny = withEnvironProofScript</span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>instance InterpreterMonad LLVMCrucibleSetupM where
<span class="lineno">  373 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = llvmTopLevel m</span></span>
<span class="lineno">  374 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  375 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VLLVMCrucibleSetup pos chain m</span></span>
<span class="lineno">  376 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = panic &quot;getMonadContext&quot; [&quot;Called in LLVMSetup&quot;]</span></span>
<span class="lineno">  377 </span>  <span class="decl"><span class="istickedoff">pushScopeAny = llvmTopLevel pushScope</span></span>
<span class="lineno">  378 </span>  <span class="decl"><span class="istickedoff">popScopeAny = llvmTopLevel popScope</span></span>
<span class="lineno">  379 </span>  <span class="decl"><span class="istickedoff">withEnvironAny = withEnvironLLVM</span></span>
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>instance InterpreterMonad JVMSetupM where
<span class="lineno">  382 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = jvmTopLevel m</span></span>
<span class="lineno">  383 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  384 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VJVMSetup pos chain m</span></span>
<span class="lineno">  385 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = panic &quot;getMonadContext&quot; [&quot;Called in JVMSetup&quot;]</span></span>
<span class="lineno">  386 </span>  <span class="decl"><span class="istickedoff">pushScopeAny = jvmTopLevel pushScope</span></span>
<span class="lineno">  387 </span>  <span class="decl"><span class="istickedoff">popScopeAny = jvmTopLevel popScope</span></span>
<span class="lineno">  388 </span>  <span class="decl"><span class="istickedoff">withEnvironAny = withEnvironJVM</span></span>
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>instance InterpreterMonad MIRSetupM where
<span class="lineno">  391 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = mirTopLevel m</span></span>
<span class="lineno">  392 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  393 </span>  <span class="decl"><span class="istickedoff">mkValue pos chain m = VMIRSetup pos chain m</span></span>
<span class="lineno">  394 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = panic &quot;getMonadContext&quot; [&quot;Called in MIRSetup&quot;]</span></span>
<span class="lineno">  395 </span>  <span class="decl"><span class="istickedoff">pushScopeAny = mirTopLevel pushScope</span></span>
<span class="lineno">  396 </span>  <span class="decl"><span class="istickedoff">popScopeAny = mirTopLevel popScope</span></span>
<span class="lineno">  397 </span>  <span class="decl"><span class="istickedoff">withEnvironAny = withEnvironMIR</span></span>
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>------------------------------------------------------------
<span class="lineno">  401 </span>-- Typechecker
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>-- Process a typechecker result.
<span class="lineno">  404 </span>-- Wraps the typechecker in the stuff needed to print its warnings and errors.
<span class="lineno">  405 </span>--
<span class="lineno">  406 </span>-- XXX: this code should probably live inside the typechecker.
<span class="lineno">  407 </span>--
<span class="lineno">  408 </span>-- Usage is processTypeCheck $ checkStmt ...
<span class="lineno">  409 </span>type MsgList = [(SS.Pos, String)]
<span class="lineno">  410 </span>processTypeCheck :: InterpreterMonad m =&gt; (Either MsgList a, MsgList) -&gt; m a
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">processTypeCheck (errs_or_output, warns) =</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="istickedoff">let issueWarning (pos, msg) =</span>
<span class="lineno">  414 </span><span class="spaces">          </span><span class="istickedoff">-- XXX the print functions should be what knows how to show positions...</span>
<span class="lineno">  415 </span><span class="spaces">          </span><span class="istickedoff">printOutLnTop Warn (show pos ++ &quot;: Warning: &quot; ++ msg)</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">mapM_ issueWarning warns</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="istickedoff">either failTypecheck return errs_or_output</span></span>
<span class="lineno">  418 </span>
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>------------------------------------------------------------
<span class="lineno">  421 </span>-- Interpreter core
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>-- | Apply an argument value to a function value.
<span class="lineno">  424 </span>--   v1 must have type a -&gt; b; v2 must have type a.
<span class="lineno">  425 </span>--   The first (position) argument is the position where the
<span class="lineno">  426 </span>--   application happens.
<span class="lineno">  427 </span>--   The second (Text) argument is printed as part of the panic if v1
<span class="lineno">  428 </span>--   turns out not to be a function value.
<span class="lineno">  429 </span>applyValue :: SS.Pos -&gt; Text -&gt; Value -&gt; Value -&gt; TopLevel Value
<span class="lineno">  430 </span><span class="decl"><span class="istickedoff">applyValue pos v1info v1 v2 =</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="istickedoff">let enter name = pushTraceFrame pos name</span>
<span class="lineno">  432 </span><span class="spaces">      </span><span class="istickedoff">leave = popTraceFrame</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">case v1 of</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">VLambda env mname pat e -&gt; do</span>
<span class="lineno">  436 </span><span class="spaces">        </span><span class="istickedoff">let name = fromMaybe &quot;(lambda)&quot; mname</span>
<span class="lineno">  437 </span><span class="spaces">        </span><span class="istickedoff">enter name</span>
<span class="lineno">  438 </span><span class="spaces">        </span><span class="istickedoff">r &lt;- withEnviron env $ do</span>
<span class="lineno">  439 </span><span class="spaces">            </span><span class="istickedoff">pushScope</span>
<span class="lineno">  440 </span><span class="spaces">            </span><span class="istickedoff">bindPattern SS.ReadOnlyVar pat <span class="nottickedoff">Nothing</span> v2</span>
<span class="lineno">  441 </span><span class="spaces">            </span><span class="istickedoff">r' &lt;- interpretExpr e</span>
<span class="lineno">  442 </span><span class="spaces">            </span><span class="istickedoff">popScope</span>
<span class="lineno">  443 </span><span class="spaces">            </span><span class="istickedoff">return r'</span>
<span class="lineno">  444 </span><span class="spaces">        </span><span class="istickedoff">leave</span>
<span class="lineno">  445 </span><span class="spaces">        </span><span class="istickedoff">return $ insertRefChain pos name r</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">VBuiltin name args wf -&gt; case wf of</span>
<span class="lineno">  447 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg f -&gt; do</span>
<span class="lineno">  448 </span><span class="spaces">            </span><span class="istickedoff">setPosition <span class="nottickedoff">pos</span></span>
<span class="lineno">  449 </span><span class="spaces">            </span><span class="istickedoff">enter name</span>
<span class="lineno">  450 </span><span class="spaces">            </span><span class="istickedoff">r &lt;- f v2</span>
<span class="lineno">  451 </span><span class="spaces">            </span><span class="istickedoff">leave</span>
<span class="lineno">  452 </span><span class="spaces">            </span><span class="istickedoff">return $ insertRefChain pos name r</span>
<span class="lineno">  453 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs f -&gt;</span>
<span class="lineno">  454 </span><span class="spaces">            </span><span class="istickedoff">-- f will still be partially applied after this, so it</span>
<span class="lineno">  455 </span><span class="spaces">            </span><span class="istickedoff">-- won't do anything and there's no need to enter/leave.</span>
<span class="lineno">  456 </span><span class="spaces">            </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">(args :|&gt; v2)</span> &lt;$&gt; f v2</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  458 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;applyValue&quot; [</span></span>
<span class="lineno">  459 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Called object is not a function&quot;,</span></span>
<span class="lineno">  460 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Call site: &quot; &lt;&gt; Text.pack (show pos),</span></span>
<span class="lineno">  461 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Value found: &quot; &lt;&gt; Text.pack (show v1),</span></span>
<span class="lineno">  462 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">v1info</span></span>
<span class="lineno">  463 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>-- Eval an expression.
<span class="lineno">  466 </span>--
<span class="lineno">  467 </span>-- This executes purely: when we see a do-block, return it as a value.
<span class="lineno">  468 </span>-- If the caller is executing in a monad, it'll intercept that and
<span class="lineno">  469 </span>-- eval it.
<span class="lineno">  470 </span>--
<span class="lineno">  471 </span>-- This code lives in the interpreter monad anyway for two reasons:
<span class="lineno">  472 </span>-- first, properly, because it needs (readonly) access to the Cryptol
<span class="lineno">  473 </span>-- environment. This could conceivably just be passed in instead.
<span class="lineno">  474 </span>--
<span class="lineno">  475 </span>-- Second, improperly, a randomly-chosen selection of SAWScript
<span class="lineno">  476 </span>-- builtins are pure in SAWScript but not in Haskell; these execute
<span class="lineno">  477 </span>-- in TopLevel when the last argument is applied by applyValue, and
<span class="lineno">  478 </span>-- that happens inside here.
<span class="lineno">  479 </span>--
<span class="lineno">  480 </span>interpretExpr :: SS.Expr -&gt; TopLevel Value
<span class="lineno">  481 </span><span class="decl"><span class="istickedoff">interpretExpr expr =</span>
<span class="lineno">  482 </span><span class="spaces">    </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span> in</span>
<span class="lineno">  483 </span><span class="spaces">    </span><span class="istickedoff">case expr of</span>
<span class="lineno">  484 </span><span class="spaces">      </span><span class="istickedoff">SS.Bool _ b -&gt;</span>
<span class="lineno">  485 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ VBool b</span></span>
<span class="lineno">  486 </span><span class="spaces">      </span><span class="istickedoff">SS.String _ s -&gt;</span>
<span class="lineno">  487 </span><span class="spaces">          </span><span class="istickedoff">return $ VString s</span>
<span class="lineno">  488 </span><span class="spaces">      </span><span class="istickedoff">SS.Int _ z -&gt;</span>
<span class="lineno">  489 </span><span class="spaces">          </span><span class="istickedoff">return $ VInteger z</span>
<span class="lineno">  490 </span><span class="spaces">      </span><span class="istickedoff">SS.Code pos str -&gt; do</span>
<span class="lineno">  491 </span><span class="spaces">          </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  492 </span><span class="spaces">          </span><span class="istickedoff">cenv &lt;- getCryptolEnv</span>
<span class="lineno">  493 </span><span class="spaces">          </span><span class="istickedoff">--io $ putStrLn $ &quot;Parsing code: &quot; ++ show str</span>
<span class="lineno">  494 </span><span class="spaces">          </span><span class="istickedoff">--showCryptolEnv' cenv</span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="istickedoff">let str' = toInputText pos str</span>
<span class="lineno">  496 </span><span class="spaces">          </span><span class="istickedoff">t &lt;- io $ CEnv.parseTypedTerm sc cenv str'</span>
<span class="lineno">  497 </span><span class="spaces">          </span><span class="istickedoff">return (VTerm t)</span>
<span class="lineno">  498 </span><span class="spaces">      </span><span class="istickedoff">SS.CType pos str -&gt; do</span>
<span class="lineno">  499 </span><span class="spaces">          </span><span class="istickedoff">cenv &lt;- getCryptolEnv</span>
<span class="lineno">  500 </span><span class="spaces">          </span><span class="istickedoff">let str' = toInputText pos str</span>
<span class="lineno">  501 </span><span class="spaces">          </span><span class="istickedoff">s &lt;- io $ CEnv.parseSchema cenv str'</span>
<span class="lineno">  502 </span><span class="spaces">          </span><span class="istickedoff">return (VType s)</span>
<span class="lineno">  503 </span><span class="spaces">      </span><span class="istickedoff">SS.Array _pos es -&gt;</span>
<span class="lineno">  504 </span><span class="spaces">          </span><span class="istickedoff">VArray &lt;$&gt; traverse interpretExpr es</span>
<span class="lineno">  505 </span><span class="spaces">      </span><span class="istickedoff">SS.Block _pos stmts -&gt; do</span>
<span class="lineno">  506 </span><span class="spaces">          </span><span class="istickedoff">env &lt;- gets rwEnviron</span>
<span class="lineno">  507 </span><span class="spaces">          </span><span class="istickedoff">return $ VDo [] env stmts</span>
<span class="lineno">  508 </span><span class="spaces">      </span><span class="istickedoff">SS.Tuple _pos es -&gt;</span>
<span class="lineno">  509 </span><span class="spaces">          </span><span class="istickedoff">VTuple &lt;$&gt; traverse interpretExpr es</span>
<span class="lineno">  510 </span><span class="spaces">      </span><span class="istickedoff">SS.Record _pos bs -&gt;</span>
<span class="lineno">  511 </span><span class="spaces">          </span><span class="istickedoff">VRecord &lt;$&gt; traverse interpretExpr bs</span>
<span class="lineno">  512 </span><span class="spaces">      </span><span class="istickedoff">SS.Index pos e1 e2 -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  513 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">a &lt;- interpretExpr e1</span></span>
<span class="lineno">  514 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">i &lt;- interpretExpr e2</span></span>
<span class="lineno">  515 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return (indexValue pos a i)</span></span>
<span class="lineno">  516 </span><span class="spaces">      </span><span class="istickedoff">SS.Lookup pos e n -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  517 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">a &lt;- interpretExpr e</span></span>
<span class="lineno">  518 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return (lookupValue pos a n)</span></span>
<span class="lineno">  519 </span><span class="spaces">      </span><span class="istickedoff">SS.TLookup pos e i -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  520 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">a &lt;- interpretExpr e</span></span>
<span class="lineno">  521 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return (tupleLookupValue pos a i)</span></span>
<span class="lineno">  522 </span><span class="spaces">      </span><span class="istickedoff">SS.Var pos x -&gt; do</span>
<span class="lineno">  523 </span><span class="spaces">          </span><span class="istickedoff">avail &lt;- gets rwPrimsAvail</span>
<span class="lineno">  524 </span><span class="spaces">          </span><span class="istickedoff">Environ varenv _tyenv _cryenv &lt;- gets rwEnviron</span>
<span class="lineno">  525 </span><span class="spaces">          </span><span class="istickedoff">rbenv &lt;- gets rwRebindables</span>
<span class="lineno">  526 </span><span class="spaces">          </span><span class="istickedoff">let info = case ScopedMap.lookup x varenv of</span>
<span class="lineno">  527 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  528 </span><span class="spaces">                      </span><span class="istickedoff">-- Try the rebindable environment</span>
<span class="lineno">  529 </span><span class="spaces">                      </span><span class="istickedoff">case Map.lookup x rbenv of</span>
<span class="lineno">  530 </span><span class="spaces">                          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  531 </span><span class="spaces">                          </span><span class="istickedoff">Just (_defpos, _ty, v) -&gt; Just (Current, v)</span>
<span class="lineno">  532 </span><span class="spaces">                  </span><span class="istickedoff">Just (_defpos, lc, _ty, v, _doc) -&gt; Just (lc, v)</span>
<span class="lineno">  533 </span><span class="spaces">          </span><span class="istickedoff">case info of</span>
<span class="lineno">  534 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  535 </span><span class="spaces">                  </span><span class="istickedoff">-- This should be rejected by the typechecker; panic</span>
<span class="lineno">  536 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretExpr&quot; [</span></span>
<span class="lineno">  537 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;Read of unknown variable &quot; &lt;&gt; x</span></span>
<span class="lineno">  538 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  539 </span><span class="spaces">              </span><span class="istickedoff">Just (lc, v)</span>
<span class="lineno">  540 </span><span class="spaces">                </span><span class="istickedoff">| <span class="tickonlytrue">Set.member lc avail</span> -&gt; do</span>
<span class="lineno">  541 </span><span class="spaces">                      </span><span class="istickedoff">let v' = injectPositionIntoMonadicValue <span class="nottickedoff">pos</span> v</span>
<span class="lineno">  542 </span><span class="spaces">                          </span><span class="istickedoff">v'' = insertRefChain pos x v'</span>
<span class="lineno">  543 </span><span class="spaces">                      </span><span class="istickedoff">return v''</span>
<span class="lineno">  544 </span><span class="spaces">                </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno">  545 </span><span class="spaces">                      </span><span class="istickedoff">-- This case is also rejected by the typechecker</span>
<span class="lineno">  546 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretExpr&quot; [</span></span>
<span class="lineno">  547 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot;Read of inaccessible variable &quot; &lt;&gt; x</span></span>
<span class="lineno">  548 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  549 </span><span class="spaces">      </span><span class="istickedoff">SS.Lambda _pos mname pat e -&gt; do</span>
<span class="lineno">  550 </span><span class="spaces">          </span><span class="istickedoff">env &lt;- gets rwEnviron</span>
<span class="lineno">  551 </span><span class="spaces">          </span><span class="istickedoff">return $ VLambda env mname pat e</span>
<span class="lineno">  552 </span><span class="spaces">      </span><span class="istickedoff">SS.Application pos e1 e2 -&gt; do</span>
<span class="lineno">  553 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">v1info = &quot;Expression: &quot; &lt;&gt; PPS.pShowText e1</span></span>
<span class="lineno">  554 </span><span class="spaces">          </span><span class="istickedoff">v1 &lt;- interpretExpr e1</span>
<span class="lineno">  555 </span><span class="spaces">          </span><span class="istickedoff">v2 &lt;- interpretExpr e2</span>
<span class="lineno">  556 </span><span class="spaces">          </span><span class="istickedoff">let v2' = injectPositionIntoMonadicValue (SS.getPos e2) v2</span>
<span class="lineno">  557 </span><span class="spaces">          </span><span class="istickedoff">applyValue pos <span class="nottickedoff">v1info</span> v1 v2'</span>
<span class="lineno">  558 </span><span class="spaces">      </span><span class="istickedoff">SS.Let _ dg e -&gt; do</span>
<span class="lineno">  559 </span><span class="spaces">          </span><span class="istickedoff">pushScope</span>
<span class="lineno">  560 </span><span class="spaces">          </span><span class="istickedoff">interpretDeclGroup SS.ReadOnlyVar dg</span>
<span class="lineno">  561 </span><span class="spaces">          </span><span class="istickedoff">v &lt;- interpretExpr e</span>
<span class="lineno">  562 </span><span class="spaces">          </span><span class="istickedoff">popScope</span>
<span class="lineno">  563 </span><span class="spaces">          </span><span class="istickedoff">return v</span>
<span class="lineno">  564 </span><span class="spaces">      </span><span class="istickedoff">SS.TSig _ e _ -&gt;</span>
<span class="lineno">  565 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">interpretExpr e</span></span>
<span class="lineno">  566 </span><span class="spaces">      </span><span class="istickedoff">SS.IfThenElse pos e1 e2 e3 -&gt; do</span>
<span class="lineno">  567 </span><span class="spaces">          </span><span class="istickedoff">v1 &lt;- interpretExpr e1</span>
<span class="lineno">  568 </span><span class="spaces">          </span><span class="istickedoff">case v1 of</span>
<span class="lineno">  569 </span><span class="spaces">            </span><span class="istickedoff">VBool b -&gt;</span>
<span class="lineno">  570 </span><span class="spaces">              </span><span class="istickedoff">interpretExpr (if b then e2 else e3)</span>
<span class="lineno">  571 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  572 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretExpr&quot; [</span></span>
<span class="lineno">  573 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Ill-typed value in if-expression (should be Bool)&quot;,</span></span>
<span class="lineno">  574 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Source position: &quot; &lt;&gt; Text.pack (show pos),</span></span>
<span class="lineno">  575 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Value found: &quot; &lt;&gt; Text.pack (show v1),</span></span>
<span class="lineno">  576 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Expression: &quot; &lt;&gt; PPS.pShowText e1</span></span>
<span class="lineno">  577 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>-- Eval a &quot;decl group&quot;, which is a let-binding or group of mutually
<span class="lineno">  580 </span>-- recursive let-bindings.
<span class="lineno">  581 </span>--
<span class="lineno">  582 </span>-- The bodies are interpreted purely.
<span class="lineno">  583 </span>interpretDeclGroup :: SS.Rebindable -&gt; SS.DeclGroup -&gt; TopLevel ()
<span class="lineno">  584 </span><span class="decl"><span class="istickedoff">interpretDeclGroup rebindable dg = case dg of</span>
<span class="lineno">  585 </span><span class="spaces">    </span><span class="istickedoff">SS.NonRecursive (SS.Decl _ pat mt expr) -&gt; do</span>
<span class="lineno">  586 </span><span class="spaces">        </span><span class="istickedoff">v &lt;- interpretExpr expr</span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="istickedoff">bindPattern rebindable pat mt v</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">SS.Recursive ds -&gt; do</span>
<span class="lineno">  589 </span><span class="spaces">        </span><span class="istickedoff">let</span>
<span class="lineno">  590 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  591 </span><span class="spaces">            </span><span class="istickedoff">-- Get a value for the body of one of the declarations.</span>
<span class="lineno">  592 </span><span class="spaces">            </span><span class="istickedoff">-- Recursive declaration sets are only allowed to contain</span>
<span class="lineno">  593 </span><span class="spaces">            </span><span class="istickedoff">-- functions; panic if we get anything else.</span>
<span class="lineno">  594 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno">  595 </span><span class="spaces">            </span><span class="istickedoff">-- We return a function taking an environment because we</span>
<span class="lineno">  596 </span><span class="spaces">            </span><span class="istickedoff">-- need to close in the environment containing _all_ the</span>
<span class="lineno">  597 </span><span class="spaces">            </span><span class="istickedoff">-- declarations _into_ all the declarations, which is a</span>
<span class="lineno">  598 </span><span class="spaces">            </span><span class="istickedoff">-- circular knot that can only be constructed in very</span>
<span class="lineno">  599 </span><span class="spaces">            </span><span class="istickedoff">-- specific ways.</span>
<span class="lineno">  600 </span><span class="spaces">            </span><span class="istickedoff">extractFunction x e0 = case e0 of</span>
<span class="lineno">  601 </span><span class="spaces">                </span><span class="istickedoff">SS.Lambda _ mname pat e1 -&gt;</span>
<span class="lineno">  602 </span><span class="spaces">                    </span><span class="istickedoff">\env -&gt; VLambda env <span class="nottickedoff">mname</span> pat e1</span>
<span class="lineno">  603 </span><span class="spaces">                </span><span class="istickedoff">SS.TSig _ e1 _ -&gt;</span>
<span class="lineno">  604 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">extractFunction x e1</span></span>
<span class="lineno">  605 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  606 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretDeclGroup&quot; [</span></span>
<span class="lineno">  607 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Found non-function in a recursive declaration group&quot;,</span></span>
<span class="lineno">  608 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Name: &quot; &lt;&gt; x,</span></span>
<span class="lineno">  609 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Expression found: &quot; &lt;&gt; PPS.pShowText e0</span></span>
<span class="lineno">  610 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  611 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  612 </span><span class="spaces">            </span><span class="istickedoff">-- Get the type (scheme) for one of the declarations.</span>
<span class="lineno">  613 </span><span class="spaces">            </span><span class="istickedoff">extractType x mty = case mty of</span>
<span class="lineno">  614 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  615 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretDeclGroup&quot; [</span></span>
<span class="lineno">  616 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Found declaration with no type in a recursive decl group&quot;,</span></span>
<span class="lineno">  617 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Variable: &quot; &lt;&gt; x</span></span>
<span class="lineno">  618 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  619 </span><span class="spaces">                </span><span class="istickedoff">Just ty -&gt; ty</span>
<span class="lineno">  620 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  621 </span><span class="spaces">            </span><span class="istickedoff">-- Get the name for one of the declarations.</span>
<span class="lineno">  622 </span><span class="spaces">            </span><span class="istickedoff">-- Recursive declaration sets are only allowed to contain</span>
<span class="lineno">  623 </span><span class="spaces">            </span><span class="istickedoff">-- functions, so the pattern cannot be a tuple.</span>
<span class="lineno">  624 </span><span class="spaces">            </span><span class="istickedoff">extractName pat = case pat of</span>
<span class="lineno">  625 </span><span class="spaces">                </span><span class="istickedoff">SS.PWild _ _ -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  626 </span><span class="spaces">                </span><span class="istickedoff">SS.PVar _ xpos x _mty -&gt; Just (<span class="nottickedoff">xpos</span>, x)</span>
<span class="lineno">  627 </span><span class="spaces">                </span><span class="istickedoff">SS.PTuple{} -&gt;</span>
<span class="lineno">  628 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;interpretDeclGroup&quot; [</span></span>
<span class="lineno">  629 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Found tuple pattern in a recursive declaration group&quot;,</span></span>
<span class="lineno">  630 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Pattern: &quot; &lt;&gt; Text.pack (show (PP.pretty pat))</span></span>
<span class="lineno">  631 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  632 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  633 </span><span class="spaces">            </span><span class="istickedoff">-- Get all the info for a decl.</span>
<span class="lineno">  634 </span><span class="spaces">            </span><span class="istickedoff">extractBoth (SS.Decl _ pat mty e) =</span>
<span class="lineno">  635 </span><span class="spaces">                </span><span class="istickedoff">case extractName pat of</span>
<span class="lineno">  636 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  637 </span><span class="spaces">                    </span><span class="istickedoff">Just (xpos, x) -&gt;</span>
<span class="lineno">  638 </span><span class="spaces">                        </span><span class="istickedoff">let ty = extractType <span class="nottickedoff">x</span> mty</span>
<span class="lineno">  639 </span><span class="spaces">                            </span><span class="istickedoff">fv = extractFunction <span class="nottickedoff">x</span> e</span>
<span class="lineno">  640 </span><span class="spaces">                        </span><span class="istickedoff">in</span>
<span class="lineno">  641 </span><span class="spaces">                        </span><span class="istickedoff">Just (<span class="nottickedoff">xpos</span>, x, rebindable, ty, <span class="nottickedoff">Nothing</span>, fv)</span>
<span class="lineno">  642 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  643 </span><span class="spaces">            </span><span class="istickedoff">-- Extract all the info for all decls.</span>
<span class="lineno">  644 </span><span class="spaces">            </span><span class="istickedoff">ds' = mapMaybe extractBoth ds</span>
<span class="lineno">  645 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  646 </span><span class="spaces">        </span><span class="istickedoff">-- Now add all the declarations.</span>
<span class="lineno">  647 </span><span class="spaces">        </span><span class="istickedoff">--</span>
<span class="lineno">  648 </span><span class="spaces">        </span><span class="istickedoff">-- Note that the lambdas in all the declarations need the final</span>
<span class="lineno">  649 </span><span class="spaces">        </span><span class="istickedoff">-- resulting environment that contains all the declarations,</span>
<span class="lineno">  650 </span><span class="spaces">        </span><span class="istickedoff">-- which is something of a headache to arrange in Haskell.</span>
<span class="lineno">  651 </span><span class="spaces">        </span><span class="istickedoff">extendEnvMulti ds'</span></span>
<span class="lineno">  652 </span>
<span class="lineno">  653 </span>-- Bind a monadic value into the monadic execution sequence.
<span class="lineno">  654 </span>--
<span class="lineno">  655 </span>-- Takes a monadic value that might be a VDo, VBindOnce, VReturn, or
<span class="lineno">  656 </span>-- plain monadic value, run it through the interpreter as necessary to
<span class="lineno">  657 </span>-- get a plain monadic value, then bind it in Haskell to get a result.
<span class="lineno">  658 </span>-- Returns the resulting Value. Runs in any interpreter monad.
<span class="lineno">  659 </span>--
<span class="lineno">  660 </span>-- Even though this is called from multiple places, in each case it's
<span class="lineno">  661 </span>-- the interpreter doing a SAWScript-level bind so we are always
<span class="lineno">  662 </span>-- coming from the interpreter.
<span class="lineno">  663 </span>--
<span class="lineno">  664 </span>-- There are three steps:
<span class="lineno">  665 </span>--    - Run it in the interpreter with interpretMonadAction, in case
<span class="lineno">  666 </span>--      it's a do-block. (plainVal should then always be a plain
<span class="lineno">  667 </span>--      monadic value with a Haskell monadic action in it.)
<span class="lineno">  668 </span>--    - Update the value metadata. (Specifically: insert the bind
<span class="lineno">  669 </span>--      position into the plain monadic value we get back from the
<span class="lineno">  670 </span>--      interpreter, as its position of last reference.)
<span class="lineno">  671 </span>--    - Fetch the Haskell-level monadic action with fromValue and bind
<span class="lineno">  672 </span>--      that in Haskell to execute it.
<span class="lineno">  673 </span>--
<span class="lineno">  674 </span>-- Note that calling interpretMonadAction here is necessary for the
<span class="lineno">  675 </span>-- moment (even though it's also called from fromValue /
<span class="lineno">  676 </span>-- actionFromValue) because we need the result to do the position
<span class="lineno">  677 </span>-- update.
<span class="lineno">  678 </span>--
<span class="lineno">  679 </span>bindMonadAction :: forall m. InterpreterMonad m =&gt; SS.Pos -&gt; Value -&gt; m Value
<span class="lineno">  680 </span><span class="decl"><span class="istickedoff">bindMonadAction pos baseVal = do</span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="istickedoff">plainVal &lt;- interpretMonadAction FromInterpreter baseVal</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="istickedoff">let plainVal' = injectPositionIntoMonadicValue pos plainVal</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff">result &lt;- actionFromValue FromInterpreter plainVal'</span>
<span class="lineno">  684 </span><span class="spaces">    </span><span class="istickedoff">return result</span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>-- Execute a monad action. This happens in any of the interpreter
<span class="lineno">  687 </span>-- monads.
<span class="lineno">  688 </span>interpretMonadAction :: forall m. InterpreterMonad m =&gt; FromValueHow -&gt; Value -&gt; m Value
<span class="lineno">  689 </span><span class="decl"><span class="istickedoff">interpretMonadAction fromHow v = case v of</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="istickedoff">VReturn pos chain v' -&gt; do</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="istickedoff">-- VReturn ... v' -&gt; VProofScript ... (return v')</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">-- (or whichever value for whichever monad)</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff">let v'' :: m Value = return v'</span>
<span class="lineno">  694 </span><span class="spaces">    </span><span class="istickedoff">return $ mkValue <span class="nottickedoff">pos</span> chain v''</span>
<span class="lineno">  695 </span><span class="spaces">  </span><span class="istickedoff">VDo chain env body -&gt; do</span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  697 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  698 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  699 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; pushTraceFrame SS.PosInsideBuiltin &quot;(callback)&quot;</span>
<span class="lineno">  700 </span><span class="spaces">      </span><span class="istickedoff">pushTraceFrames chain</span>
<span class="lineno">  701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  702 </span><span class="spaces">    </span><span class="istickedoff">r &lt;- withEnvironAny env $ do</span>
<span class="lineno">  703 </span><span class="spaces">        </span><span class="istickedoff">pushScopeAny</span>
<span class="lineno">  704 </span><span class="spaces">        </span><span class="istickedoff">r' &lt;- interpretDoStmts body</span>
<span class="lineno">  705 </span><span class="spaces">        </span><span class="istickedoff">popScopeAny</span>
<span class="lineno">  706 </span><span class="spaces">        </span><span class="istickedoff">return r'</span>
<span class="lineno">  707 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  708 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  709 </span><span class="spaces">      </span><span class="istickedoff">popTraceFrames chain</span>
<span class="lineno">  710 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  711 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  712 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; popTraceFrame</span>
<span class="lineno">  713 </span><span class="spaces">    </span><span class="istickedoff">return $ propagateRefChain chain r</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff">VBindOnce pos chain baseVal1 val2 -&gt; do</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">-- baseVal1 is a monadic value of the same class as returned by</span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">-- interpretExpr (that is, it might be a VDo or a VBindOnce).</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">-- Bind it.</span>
<span class="lineno">  718 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="istickedoff">-- Note that even if the _bind_ is triggered with FromArgument,</span>
<span class="lineno">  720 </span><span class="spaces">    </span><span class="istickedoff">-- the contents are executed right here from the interpreter.</span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  722 </span><span class="spaces">    </span><span class="istickedoff">-- Wrap the execution (of the whole sequence of binds) in the frames</span>
<span class="lineno">  723 </span><span class="spaces">    </span><span class="istickedoff">-- from the RefChain the same way as a do-block.</span>
<span class="lineno">  724 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  725 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  726 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  727 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; <span class="nottickedoff">pushTraceFrame SS.PosInsideBuiltin &quot;(callback)&quot;</span></span>
<span class="lineno">  728 </span><span class="spaces">      </span><span class="istickedoff">pushTraceFrames chain</span>
<span class="lineno">  729 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  730 </span><span class="spaces">    </span><span class="istickedoff">result1 &lt;- bindMonadAction pos baseVal1</span>
<span class="lineno">  731 </span><span class="spaces">    </span><span class="istickedoff">-- val2 is a lambda or equivalent that expects the result as an</span>
<span class="lineno">  732 </span><span class="spaces">    </span><span class="istickedoff">-- argument (the traditional &gt;&gt;= form of monad bind)</span>
<span class="lineno">  733 </span><span class="spaces">    </span><span class="istickedoff">result2 &lt;- liftTopLevel $ applyValue pos <span class="nottickedoff">&quot;Value in a VBindOnce&quot;</span> val2 result1</span>
<span class="lineno">  734 </span><span class="spaces">    </span><span class="istickedoff">result3 &lt;- interpretMonadAction FromInterpreter result2</span>
<span class="lineno">  735 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  736 </span><span class="spaces">    </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  737 </span><span class="spaces">      </span><span class="istickedoff">popTraceFrames chain</span>
<span class="lineno">  738 </span><span class="spaces">      </span><span class="istickedoff">case fromHow of</span>
<span class="lineno">  739 </span><span class="spaces">          </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  740 </span><span class="spaces">          </span><span class="istickedoff">FromArgument -&gt; <span class="nottickedoff">popTraceFrame</span></span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">-- Handle the RefChain the same way as a do-block. Note that with</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">-- luck we don't have to worry about unwanted additional RefChain</span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="istickedoff">-- entries in the second and subsequent VBindOnce values in a</span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="istickedoff">-- sequence of them; they should never have the opportunity to</span>
<span class="lineno">  745 </span><span class="spaces">    </span><span class="istickedoff">-- grow their own references. If we had an explicit bind operator</span>
<span class="lineno">  746 </span><span class="spaces">    </span><span class="istickedoff">-- in the language, that might be a problem, but we don't and we</span>
<span class="lineno">  747 </span><span class="spaces">    </span><span class="istickedoff">-- aren't getting one. So the only bind sequences we have are</span>
<span class="lineno">  748 </span><span class="spaces">    </span><span class="istickedoff">-- canned. (And in particular there's only one, in the &quot;for&quot;</span>
<span class="lineno">  749 </span><span class="spaces">    </span><span class="istickedoff">-- builtin.)</span>
<span class="lineno">  750 </span><span class="spaces">    </span><span class="istickedoff">return $ propagateRefChain chain result3</span>
<span class="lineno">  751 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; pure v</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>-- Eval a statement from a do-block. This happens in some monad; we
<span class="lineno">  755 </span>-- only come here once the monad action is executed. Therefore, we can
<span class="lineno">  756 </span>-- execute binds: if we get a do-block back, execute it recursively.
<span class="lineno">  757 </span>-- (Such a do-block must be in the same monad in order to be well
<span class="lineno">  758 </span>-- typed.)
<span class="lineno">  759 </span>--
<span class="lineno">  760 </span>-- In let-bindings the RHS is evaluated purely.
<span class="lineno">  761 </span>--
<span class="lineno">  762 </span>-- Returns the updated local environment.
<span class="lineno">  763 </span>-- (XXX: should that be stored into the monad context or not? Apparently
<span class="lineno">  764 </span>-- not, currently.)
<span class="lineno">  765 </span>--
<span class="lineno">  766 </span>interpretDoStmt :: forall m. InterpreterMonad m =&gt; SS.Stmt -&gt; m ()
<span class="lineno">  767 </span><span class="decl"><span class="istickedoff">interpretDoStmt stmt =</span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span> in</span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="istickedoff">-- XXX are the uses of push/popPosition here suitable? not super clear</span>
<span class="lineno">  770 </span><span class="spaces">    </span><span class="istickedoff">case stmt of</span>
<span class="lineno">  771 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtBind pos pat e -&gt; do</span>
<span class="lineno">  772 </span><span class="spaces">          </span><span class="istickedoff">-- Execute the expression purely first. (&quot;purely&quot;)</span>
<span class="lineno">  773 </span><span class="spaces">          </span><span class="istickedoff">baseVal :: Value &lt;- liftTopLevel $ interpretExpr e</span>
<span class="lineno">  774 </span><span class="spaces">          </span><span class="istickedoff">-- Now bind the resulting value to execute it.</span>
<span class="lineno">  775 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  776 </span><span class="spaces">          </span><span class="istickedoff">-- No trace frames here because the logic is inside</span>
<span class="lineno">  777 </span><span class="spaces">          </span><span class="istickedoff">-- interpretMonadAction and fromValue (for the interpreter</span>
<span class="lineno">  778 </span><span class="spaces">          </span><span class="istickedoff">-- and Haskell-level execution respectively).</span>
<span class="lineno">  779 </span><span class="spaces">          </span><span class="istickedoff">result :: Value &lt;- bindMonadAction pos baseVal</span>
<span class="lineno">  780 </span><span class="spaces">          </span><span class="istickedoff">-- Bind (in the name-binding, not monad-binding sense) the</span>
<span class="lineno">  781 </span><span class="spaces">          </span><span class="istickedoff">-- result to the pattern.</span>
<span class="lineno">  782 </span><span class="spaces">          </span><span class="istickedoff">liftTopLevel $ bindPattern SS.ReadOnlyVar pat Nothing result</span>
<span class="lineno">  783 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtLet _pos rebindable dg -&gt; do</span>
<span class="lineno">  784 </span><span class="spaces">          </span><span class="istickedoff">-- Process the declarations</span>
<span class="lineno">  785 </span><span class="spaces">          </span><span class="istickedoff">liftTopLevel $ interpretDeclGroup rebindable dg</span>
<span class="lineno">  786 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtCode _ spos str -&gt; do</span>
<span class="lineno">  787 </span><span class="spaces">          </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  788 </span><span class="spaces">            </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  789 </span><span class="spaces">            </span><span class="istickedoff">ce &lt;- getCryptolEnv</span>
<span class="lineno">  790 </span><span class="spaces">            </span><span class="istickedoff">let str' = toInputText spos str</span>
<span class="lineno">  791 </span><span class="spaces">            </span><span class="istickedoff">ce' &lt;- io $ CEnv.parseDecls sc ce str'</span>
<span class="lineno">  792 </span><span class="spaces">            </span><span class="istickedoff">setCryptolEnv ce'</span>
<span class="lineno">  793 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtImport _ _ -&gt;</span>
<span class="lineno">  794 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail &quot;block-level import unimplemented&quot;</span></span>
<span class="lineno">  795 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtTypedef _ _ name ty -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  796 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $ addTypedef name ty</span></span></span>
<span class="lineno">  797 </span>
<span class="lineno">  798 </span>-- Eval some statements from a do-block.
<span class="lineno">  799 </span>--
<span class="lineno">  800 </span>-- The last statement is special because it produces the value of the
<span class="lineno">  801 </span>-- do-block; it is just an expression and not a statement, and appears
<span class="lineno">  802 </span>-- as a bind of _. The typechecker enforces that we won't see a block
<span class="lineno">  803 </span>-- with something else at the end.
<span class="lineno">  804 </span>--
<span class="lineno">  805 </span>-- FUTURE: after fixing the environment handling this should be able
<span class="lineno">  806 </span>-- to just use mapM on the statements and not need to nest the last
<span class="lineno">  807 </span>-- expression inside recursing on the statements.
<span class="lineno">  808 </span>--
<span class="lineno">  809 </span>interpretDoStmts :: forall m. InterpreterMonad m =&gt; ([SS.Stmt], SS.Expr) -&gt; m Value
<span class="lineno">  810 </span><span class="decl"><span class="istickedoff">interpretDoStmts (stmts, lastexpr) =</span>
<span class="lineno">  811 </span><span class="spaces">    </span><span class="istickedoff">case stmts of</span>
<span class="lineno">  812 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; do</span>
<span class="lineno">  813 </span><span class="spaces">          </span><span class="istickedoff">-- The position for the bind we're about to do will be the</span>
<span class="lineno">  814 </span><span class="spaces">          </span><span class="istickedoff">-- source position of the expression.</span>
<span class="lineno">  815 </span><span class="spaces">          </span><span class="istickedoff">let pos = SS.getPos lastexpr</span>
<span class="lineno">  816 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  817 </span><span class="spaces">          </span><span class="istickedoff">-- Execute the expression purely first.</span>
<span class="lineno">  818 </span><span class="spaces">          </span><span class="istickedoff">baseVal :: Value &lt;- liftTopLevel $ interpretExpr lastexpr</span>
<span class="lineno">  819 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  820 </span><span class="spaces">          </span><span class="istickedoff">-- Now (monad-)bind the resulting value and execute it.</span>
<span class="lineno">  821 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  822 </span><span class="spaces">          </span><span class="istickedoff">-- If we got a do-block or similar back, execute it now.</span>
<span class="lineno">  823 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  824 </span><span class="spaces">          </span><span class="istickedoff">-- In principle we should return the plain monadic value as</span>
<span class="lineno">  825 </span><span class="spaces">          </span><span class="istickedoff">-- the result of the block and let the caller execute</span>
<span class="lineno">  826 </span><span class="spaces">          </span><span class="istickedoff">-- it. Instead, bind it now and construct a return of the</span>
<span class="lineno">  827 </span><span class="spaces">          </span><span class="istickedoff">-- result. (As in: replace &quot;do { ...; e; }&quot; with &quot;do { ...;</span>
<span class="lineno">  828 </span><span class="spaces">          </span><span class="istickedoff">-- r &lt;- e; return r; }&quot;.) In the common case where the last</span>
<span class="lineno">  829 </span><span class="spaces">          </span><span class="istickedoff">-- expression is just a return, this has no effect, and</span>
<span class="lineno">  830 </span><span class="spaces">          </span><span class="istickedoff">-- these are semantically equivalent; but if it actually</span>
<span class="lineno">  831 </span><span class="spaces">          </span><span class="istickedoff">-- does something, letting the caller execute it is akin to</span>
<span class="lineno">  832 </span><span class="spaces">          </span><span class="istickedoff">-- tail-call optimization and breaks stack traces.</span>
<span class="lineno">  833 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  834 </span><span class="spaces">          </span><span class="istickedoff">-- FUTURE: do this transform on the AST upstream before</span>
<span class="lineno">  835 </span><span class="spaces">          </span><span class="istickedoff">-- executing; that can more readily avoid doing the</span>
<span class="lineno">  836 </span><span class="spaces">          </span><span class="istickedoff">-- transform if the last expression is already a return.</span>
<span class="lineno">  837 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  838 </span><span class="spaces">          </span><span class="istickedoff">-- No trace frames here because the logic is inside</span>
<span class="lineno">  839 </span><span class="spaces">          </span><span class="istickedoff">-- interpretMonadAction and fromValue (for the interpreter</span>
<span class="lineno">  840 </span><span class="spaces">          </span><span class="istickedoff">-- and Haskell-level execution respectively).</span>
<span class="lineno">  841 </span><span class="spaces">          </span><span class="istickedoff">--</span>
<span class="lineno">  842 </span><span class="spaces">          </span><span class="istickedoff">result :: Value &lt;- bindMonadAction pos baseVal</span>
<span class="lineno">  843 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  844 </span><span class="spaces">          </span><span class="istickedoff">-- Don't return a VReturn here, because there isn't</span>
<span class="lineno">  845 </span><span class="spaces">          </span><span class="istickedoff">-- necessarily a following call to interpretMonadAction to</span>
<span class="lineno">  846 </span><span class="spaces">          </span><span class="istickedoff">-- unfold it. Instead, produce the unfolded form directly.</span>
<span class="lineno">  847 </span><span class="spaces">          </span><span class="istickedoff">-- Which requires some gyrations to feed the monad type in.</span>
<span class="lineno">  848 </span><span class="spaces">          </span><span class="istickedoff">let result' :: m Value = return result</span>
<span class="lineno">  849 </span><span class="spaces">          </span><span class="istickedoff">return $ mkValue pos [] result'</span>
<span class="lineno">  850 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  851 </span><span class="spaces">      </span><span class="istickedoff">stmt : more -&gt; do</span>
<span class="lineno">  852 </span><span class="spaces">          </span><span class="istickedoff">-- Execute the expression and update the environment</span>
<span class="lineno">  853 </span><span class="spaces">          </span><span class="istickedoff">interpretDoStmt stmt</span>
<span class="lineno">  854 </span><span class="spaces">          </span><span class="istickedoff">-- Run the rest of the block with the updated environment</span>
<span class="lineno">  855 </span><span class="spaces">          </span><span class="istickedoff">v &lt;- interpretDoStmts (more, lastexpr)</span>
<span class="lineno">  856 </span><span class="spaces">          </span><span class="istickedoff">return v</span></span>
<span class="lineno">  857 </span>
<span class="lineno">  858 </span>-- Execute a top-level bind.
<span class="lineno">  859 </span>processStmtBind ::
<span class="lineno">  860 </span>  InterpreterMonad m =&gt;
<span class="lineno">  861 </span>  Bool -&gt;
<span class="lineno">  862 </span>  SS.Pos -&gt;
<span class="lineno">  863 </span>  SS.Pattern -&gt;
<span class="lineno">  864 </span>  SS.Expr -&gt;
<span class="lineno">  865 </span>  m ()
<span class="lineno">  866 </span><span class="decl"><span class="istickedoff">processStmtBind printBinds pos pat expr = do</span>
<span class="lineno">  867 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  868 </span><span class="spaces">  </span><span class="istickedoff">-- Eval the expression</span>
<span class="lineno">  869 </span><span class="spaces">  </span><span class="istickedoff">baseVal &lt;- liftTopLevel $ interpretExpr expr</span>
<span class="lineno">  870 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="istickedoff">-- Fetch the type from updated pattern, since the typechecker will</span>
<span class="lineno">  872 </span><span class="spaces">  </span><span class="istickedoff">-- have filled it in there.</span>
<span class="lineno">  873 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  874 </span><span class="spaces">  </span><span class="istickedoff">-- Note that this type won't include the current monad type, because</span>
<span class="lineno">  875 </span><span class="spaces">  </span><span class="istickedoff">-- it's the type of the value that the pattern on the left of &lt;- is</span>
<span class="lineno">  876 </span><span class="spaces">  </span><span class="istickedoff">-- trying to bind.</span>
<span class="lineno">  877 </span><span class="spaces">  </span><span class="istickedoff">let ty = getType pat</span>
<span class="lineno">  878 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  879 </span><span class="spaces">  </span><span class="istickedoff">-- Reject polymorphic values. XXX: as noted above this should either</span>
<span class="lineno">  880 </span><span class="spaces">  </span><span class="istickedoff">-- be inside the typechecker or restricted to the repl.</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">when (isPolymorphic ty) $ fail $ &quot;Not a monomorphic type: &quot; ++ PPS.pShow ty</span>
<span class="lineno">  882 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="istickedoff">-- Now bind the resulting value using bindMonadAction.</span>
<span class="lineno">  884 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">-- No trace frames here because the logic is inside</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">-- interpretMonadAction and fromValue (for the interpreter and</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">-- Haskell-level execution respectively).</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- bindMonadAction pos baseVal</span>
<span class="lineno">  890 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  891 </span><span class="spaces">  </span><span class="istickedoff">--io $ putStrLn $ &quot;Top-level bind: &quot; ++ show mx</span>
<span class="lineno">  892 </span><span class="spaces">  </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  893 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="istickedoff">-- When in the repl, print the result.</span>
<span class="lineno">  895 </span><span class="spaces">  </span><span class="istickedoff">when printBinds $ do</span>
<span class="lineno">  896 </span><span class="spaces">    </span><span class="istickedoff">opts &lt;- liftTopLevel $ gets <span class="nottickedoff">rwPPOpts</span></span>
<span class="lineno">  897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  898 </span><span class="spaces">    </span><span class="istickedoff">-- Extract the variable, if any, from the pattern. If there isn't</span>
<span class="lineno">  899 </span><span class="spaces">    </span><span class="istickedoff">-- any single variable use &quot;it&quot;.</span>
<span class="lineno">  900 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">name = case pat of</span></span>
<span class="lineno">  901 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PWild _patpos _t -&gt; &quot;it&quot;</span></span>
<span class="lineno">  902 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PVar _patpos _xpos x _t -&gt; x</span></span>
<span class="lineno">  903 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PTuple _patpos _pats -&gt; &quot;it&quot;</span></span>
<span class="lineno">  904 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  905 </span><span class="spaces">    </span><span class="istickedoff">-- Print non-unit result if it was not bound to a variable</span>
<span class="lineno">  906 </span><span class="spaces">    </span><span class="istickedoff">case pat of</span>
<span class="lineno">  907 </span><span class="spaces">      </span><span class="istickedoff">SS.PWild _ _ | <span class="tickonlyfalse">not (isVUnit result)</span> -&gt;</span>
<span class="lineno">  908 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $</span></span>
<span class="lineno">  909 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span></span>
<span class="lineno">  910 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">printOutLnTop Info (showsPrecValue opts nenv 0 result &quot;&quot;)</span></span>
<span class="lineno">  911 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  912 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  913 </span><span class="spaces">    </span><span class="istickedoff">-- Print function type if result was a function</span>
<span class="lineno">  914 </span><span class="spaces">    </span><span class="istickedoff">case ty of</span>
<span class="lineno">  915 </span><span class="spaces">      </span><span class="istickedoff">SS.TyCon _ SS.FunCon _ -&gt;</span>
<span class="lineno">  916 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $ printOutLnTop Info $ Text.unpack $ name &lt;&gt; &quot; : &quot; &lt;&gt; PPS.pShowText ty</span></span>
<span class="lineno">  917 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  918 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  919 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ bindPattern SS.ReadOnlyVar pat (Just (SS.tMono ty)) result</span></span>
<span class="lineno">  920 </span>
<span class="lineno">  921 </span>-- | Interpret a top-level statement in an interpreter monad (any of the SAWScript monads)
<span class="lineno">  922 </span>--   This duplicates the logic in interpretDoStmt for no particularly good reason.
<span class="lineno">  923 </span>interpretTopStmt :: InterpreterMonad m =&gt;
<span class="lineno">  924 </span>  Bool {-^ whether to print non-unit result values -} -&gt;
<span class="lineno">  925 </span>  SS.Stmt -&gt;
<span class="lineno">  926 </span>  m ()
<span class="lineno">  927 </span><span class="decl"><span class="istickedoff">interpretTopStmt printBinds stmt = do</span>
<span class="lineno">  928 </span><span class="spaces">  </span><span class="istickedoff">let ?fileReader = BS.readFile</span>
<span class="lineno">  929 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  930 </span><span class="spaces">  </span><span class="istickedoff">avail &lt;- liftTopLevel $ gets rwPrimsAvail</span>
<span class="lineno">  931 </span><span class="spaces">  </span><span class="istickedoff">ctx &lt;- getMonadContext</span>
<span class="lineno">  932 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  933 </span><span class="spaces">  </span><span class="istickedoff">stmt' &lt;- do</span>
<span class="lineno">  934 </span><span class="spaces">      </span><span class="istickedoff">-- XXX this is not the right way to do this</span>
<span class="lineno">  935 </span><span class="spaces">      </span><span class="istickedoff">--    - shouldn't have to flatten the environments</span>
<span class="lineno">  936 </span><span class="spaces">      </span><span class="istickedoff">--    - shouldn't be typechecking one statement at a time regardless</span>
<span class="lineno">  937 </span><span class="spaces">      </span><span class="istickedoff">Environ varenv tyenv _cryenvs &lt;- liftTopLevel $ gets rwEnviron</span>
<span class="lineno">  938 </span><span class="spaces">      </span><span class="istickedoff">rbenv &lt;- liftTopLevel $ gets rwRebindables</span>
<span class="lineno">  939 </span><span class="spaces">      </span><span class="istickedoff">let varenv' = Map.map (\(pos, lc, ty, _v, _doc) -&gt; (pos, lc, SS.ReadOnlyVar, ty)) $ ScopedMap.flatten varenv</span>
<span class="lineno">  940 </span><span class="spaces">          </span><span class="istickedoff">rbenv' = Map.map (\(pos, ty, _v) -&gt; (pos, SS.Current, SS.RebindableVar, ty)) rbenv</span>
<span class="lineno">  941 </span><span class="spaces">          </span><span class="istickedoff">-- If anything appears in both, favor the real environment</span>
<span class="lineno">  942 </span><span class="spaces">          </span><span class="istickedoff">varenv'' = Map.union varenv' rbenv'</span>
<span class="lineno">  943 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  944 </span><span class="spaces">      </span><span class="istickedoff">let tyenv' = ScopedMap.flatten tyenv</span>
<span class="lineno">  945 </span><span class="spaces">      </span><span class="istickedoff">processTypeCheck $ checkStmt avail varenv'' tyenv' ctx stmt</span>
<span class="lineno">  946 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="istickedoff">case stmt' of</span>
<span class="lineno">  948 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  949 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtBind pos pat expr -&gt; do</span>
<span class="lineno">  950 </span><span class="spaces">      </span><span class="istickedoff">-- Note that while liftTopLevel $ processStmtBind will typecheck,</span>
<span class="lineno">  951 </span><span class="spaces">      </span><span class="istickedoff">-- that runs it in TopLevel and not the current monad, which might</span>
<span class="lineno">  952 </span><span class="spaces">      </span><span class="istickedoff">-- be ProofScript, and then things come unstuck. See #2494.</span>
<span class="lineno">  953 </span><span class="spaces">      </span><span class="istickedoff">processStmtBind printBinds pos pat expr</span>
<span class="lineno">  954 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  955 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtLet _pos rebindable dg -&gt;</span>
<span class="lineno">  956 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ interpretDeclGroup rebindable dg</span>
<span class="lineno">  957 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  958 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtCode _ spos str -&gt;</span>
<span class="lineno">  959 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  960 </span><span class="spaces">         </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  961 </span><span class="spaces">         </span><span class="istickedoff">cenv &lt;- getCryptolEnv</span>
<span class="lineno">  962 </span><span class="spaces">         </span><span class="istickedoff">--io $ putStrLn $ &quot;Processing toplevel code: &quot; ++ show str</span>
<span class="lineno">  963 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  964 </span><span class="spaces">         </span><span class="istickedoff">cenv' &lt;- io $ CEnv.parseDecls sc cenv $ toInputText spos str</span>
<span class="lineno">  965 </span><span class="spaces">         </span><span class="istickedoff">setCryptolEnv cenv'</span>
<span class="lineno">  966 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  967 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  968 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtImport _ imp -&gt;</span>
<span class="lineno">  969 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  970 </span><span class="spaces">         </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  971 </span><span class="spaces">         </span><span class="istickedoff">cenv &lt;- getCryptolEnv</span>
<span class="lineno">  972 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  973 </span><span class="spaces">         </span><span class="istickedoff">let mLoc = iModule imp</span>
<span class="lineno">  974 </span><span class="spaces">             </span><span class="istickedoff">qual = iAs imp</span>
<span class="lineno">  975 </span><span class="spaces">             </span><span class="istickedoff">spec = iSpec imp</span>
<span class="lineno">  976 </span><span class="spaces">         </span><span class="istickedoff">cenv' &lt;- io $ CEnv.importCryptolModule sc cenv mLoc qual CEnv.PublicAndPrivate spec</span>
<span class="lineno">  977 </span><span class="spaces">         </span><span class="istickedoff">setCryptolEnv cenv'</span>
<span class="lineno">  978 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  979 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  980 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtTypedef _ _ name ty -&gt;</span>
<span class="lineno">  981 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ addTypedef name ty</span></span>
<span class="lineno">  982 </span>
<span class="lineno">  983 </span>-- Hook for AutoMatch
<span class="lineno">  984 </span>stmtInterpreter :: StmtInterpreter
<span class="lineno">  985 </span><span class="decl"><span class="nottickedoff">stmtInterpreter ro rw stmts =</span>
<span class="lineno">  986 </span><span class="spaces">  </span><span class="nottickedoff">-- What AutoMatch provides is supposed to be a full script for the</span>
<span class="lineno">  987 </span><span class="spaces">  </span><span class="nottickedoff">-- syntactic top level, not a do-block. Run it with interpretTopStmt</span>
<span class="lineno">  988 </span><span class="spaces">  </span><span class="nottickedoff">-- so as to (a) get the right behavior (as long as interpretTopStmt</span>
<span class="lineno">  989 </span><span class="spaces">  </span><span class="nottickedoff">-- and interpretDoStmt are different, which they are) and (b) avoid</span>
<span class="lineno">  990 </span><span class="spaces">  </span><span class="nottickedoff">-- needing to provide a block result value.</span>
<span class="lineno">  991 </span><span class="spaces">  </span><span class="nottickedoff">--</span>
<span class="lineno">  992 </span><span class="spaces">  </span><span class="nottickedoff">-- XXX what scope should this use? Prior to #2720 it substituted an</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="nottickedoff">-- empty &quot;local environment&quot; for the current &quot;local environment&quot;,</span>
<span class="lineno">  994 </span><span class="spaces">  </span><span class="nottickedoff">-- which would have dropped an ill-specified part of the namespace.</span>
<span class="lineno">  995 </span><span class="spaces">  </span><span class="nottickedoff">-- That wasn't particularly sensible and probably wasn't correct,</span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="nottickedoff">-- but we could reasonably here want either the current environment</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="nottickedoff">-- or a copy of the environment captured when we start AutoMatch,</span>
<span class="lineno">  998 </span><span class="spaces">  </span><span class="nottickedoff">-- and it's not obvious which. For the moment, we'll use the current</span>
<span class="lineno">  999 </span><span class="spaces">  </span><span class="nottickedoff">-- environment because that doesn't require any fiddling.</span>
<span class="lineno"> 1000 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; runTopLevel (mapM_ (interpretTopStmt False) stmts) ro rw</span></span>
<span class="lineno"> 1001 </span>
<span class="lineno"> 1002 </span>interpretFile :: FilePath -&gt; Bool {- ^ run main? -} -&gt; TopLevel ()
<span class="lineno"> 1003 </span><span class="decl"><span class="istickedoff">interpretFile file runMain =</span>
<span class="lineno"> 1004 </span><span class="spaces">  </span><span class="istickedoff">bracketTopLevel (io getCurrentDirectory) (io . setCurrentDirectory) (const interp)</span>
<span class="lineno"> 1005 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1006 </span><span class="spaces">    </span><span class="istickedoff">interp = do</span>
<span class="lineno"> 1007 </span><span class="spaces">      </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1008 </span><span class="spaces">      </span><span class="istickedoff">errs_or_stmts &lt;- io $ Loader.findAndLoadFileUnchecked opts file</span>
<span class="lineno"> 1009 </span><span class="spaces">      </span><span class="istickedoff">stmts &lt;- do</span>
<span class="lineno"> 1010 </span><span class="spaces">        </span><span class="istickedoff">case errs_or_stmts of</span>
<span class="lineno"> 1011 </span><span class="spaces">          </span><span class="istickedoff">Left errs -&gt; do</span>
<span class="lineno"> 1012 </span><span class="spaces">            </span><span class="istickedoff">-- Don't use Text.unlines here; it inserts a newline at</span>
<span class="lineno"> 1013 </span><span class="spaces">            </span><span class="istickedoff">-- the end and that produces extra blank lines in the</span>
<span class="lineno"> 1014 </span><span class="spaces">            </span><span class="istickedoff">-- output.</span>
<span class="lineno"> 1015 </span><span class="spaces">            </span><span class="istickedoff">throwTopLevel $ Text.unpack $ Text.intercalate &quot;\n&quot; errs</span>
<span class="lineno"> 1016 </span><span class="spaces">          </span><span class="istickedoff">Right stmts -&gt; pure stmts</span>
<span class="lineno"> 1017 </span><span class="spaces">      </span><span class="istickedoff">io $ setCurrentDirectory (takeDirectory file)</span>
<span class="lineno"> 1018 </span><span class="spaces">      </span><span class="istickedoff">mapM_ stmtWithPrint stmts</span>
<span class="lineno"> 1019 </span><span class="spaces">      </span><span class="istickedoff">when runMain interpretMain</span>
<span class="lineno"> 1020 </span><span class="spaces">      </span><span class="istickedoff">writeVerificationSummary</span>
<span class="lineno"> 1021 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1022 </span><span class="spaces">    </span><span class="istickedoff">stmtWithPrint s = do</span>
<span class="lineno"> 1023 </span><span class="spaces">      </span><span class="istickedoff">let <span class="nottickedoff">withPos str =</span></span>
<span class="lineno"> 1024 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">unlines $ (&quot;[output] at &quot; ++ show (SS.getPos s) ++ &quot;: &quot;) :</span></span>
<span class="lineno"> 1025 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">map (\l -&gt; &quot;\t&quot;  ++ l) (lines str)</span></span>
<span class="lineno"> 1026 </span><span class="spaces">      </span><span class="istickedoff">showLoc &lt;- printShowPos &lt;$&gt; getOptions</span>
<span class="lineno"> 1027 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">showLoc</span> then</span>
<span class="lineno"> 1028 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let wrapPrint oldFn = \lvl str -&gt; oldFn lvl (withPos str)</span></span>
<span class="lineno"> 1029 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">withPrint opts = opts { printOutFn = wrapPrint (printOutFn opts) }</span></span>
<span class="lineno"> 1030 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in</span></span>
<span class="lineno"> 1031 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">withOptions withPrint (interpretTopStmt False s)</span></span>
<span class="lineno"> 1032 </span><span class="spaces">      </span><span class="istickedoff">else</span>
<span class="lineno"> 1033 </span><span class="spaces">        </span><span class="istickedoff">interpretTopStmt False s</span></span>
<span class="lineno"> 1034 </span>
<span class="lineno"> 1035 </span>-- | Evaluate the value called 'main' from the current environment.
<span class="lineno"> 1036 </span>interpretMain :: TopLevel ()
<span class="lineno"> 1037 </span><span class="decl"><span class="istickedoff">interpretMain = do</span>
<span class="lineno"> 1038 </span><span class="spaces">  </span><span class="istickedoff">avail &lt;- gets rwPrimsAvail</span>
<span class="lineno"> 1039 </span><span class="spaces">  </span><span class="istickedoff">Environ varenv tyenv _cryenv &lt;- gets rwEnviron</span>
<span class="lineno"> 1040 </span><span class="spaces">  </span><span class="istickedoff">rbenv &lt;- gets rwRebindables</span>
<span class="lineno"> 1041 </span><span class="spaces">  </span><span class="istickedoff">let pos = SS.PosInternal &quot;entry&quot;</span>
<span class="lineno"> 1042 </span><span class="spaces">      </span><span class="istickedoff">-- We need the type to be &quot;TopLevel a&quot;, not just &quot;TopLevel ()&quot;.</span>
<span class="lineno"> 1043 </span><span class="spaces">      </span><span class="istickedoff">-- There are several (old) tests in the test suite whose main</span>
<span class="lineno"> 1044 </span><span class="spaces">      </span><span class="istickedoff">-- returns something, e.g. several are TopLevel Theorem because</span>
<span class="lineno"> 1045 </span><span class="spaces">      </span><span class="istickedoff">-- they call prove_print or prove_sat or whatever and don't</span>
<span class="lineno"> 1046 </span><span class="spaces">      </span><span class="istickedoff">-- explicitly throw away the result.</span>
<span class="lineno"> 1047 </span><span class="spaces">      </span><span class="istickedoff">tyRet = SS.TyVar <span class="nottickedoff">pos</span> &quot;a&quot;</span>
<span class="lineno"> 1048 </span><span class="spaces">      </span><span class="istickedoff">tyMonadic = SS.tBlock <span class="nottickedoff">pos</span> (SS.tContext <span class="nottickedoff">pos</span> SS.TopLevel) tyRet</span>
<span class="lineno"> 1049 </span><span class="spaces">      </span><span class="istickedoff">tyExpected = SS.Forall [(<span class="nottickedoff">pos</span>, &quot;a&quot;)] tyMonadic</span>
<span class="lineno"> 1050 </span><span class="spaces">  </span><span class="istickedoff">let main = case ScopedMap.lookup &quot;main&quot; varenv of</span>
<span class="lineno"> 1051 </span><span class="spaces">          </span><span class="istickedoff">Just (_defpos, lc, tyFound, v, _doc) -&gt; Just (lc, tyFound, v)</span>
<span class="lineno"> 1052 </span><span class="spaces">          </span><span class="istickedoff">-- Having main be rebindable doesn't make much sense, but</span>
<span class="lineno"> 1053 </span><span class="spaces">          </span><span class="istickedoff">-- it's easier to have this code than to spend time</span>
<span class="lineno"> 1054 </span><span class="spaces">          </span><span class="istickedoff">-- explaining that it's not allowed.</span>
<span class="lineno"> 1055 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; case Map.lookup &quot;main&quot; rbenv of</span>
<span class="lineno"> 1056 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; Nothing</span>
<span class="lineno"> 1057 </span><span class="spaces">              </span><span class="istickedoff">Just (_defpos, tyFound, v) -&gt; <span class="nottickedoff">Just (Current, tyFound, v)</span></span>
<span class="lineno"> 1058 </span><span class="spaces">  </span><span class="istickedoff">case main of</span>
<span class="lineno"> 1059 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1060 </span><span class="spaces">      </span><span class="istickedoff">-- Don't fail or complain if there's no main.</span>
<span class="lineno"> 1061 </span><span class="spaces">      </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1062 </span><span class="spaces">    </span><span class="istickedoff">Just (Current, tyFound, v) -&gt; case tyFound of</span>
<span class="lineno"> 1063 </span><span class="spaces">        </span><span class="istickedoff">SS.Forall _ (SS.TyCon _ SS.BlockCon [_, _]) -&gt;</span>
<span class="lineno"> 1064 </span><span class="spaces">            </span><span class="istickedoff">-- XXX shouldn't have to do this</span>
<span class="lineno"> 1065 </span><span class="spaces">            </span><span class="istickedoff">let tyenv' = ScopedMap.flatten tyenv in</span>
<span class="lineno"> 1066 </span><span class="spaces">            </span><span class="istickedoff">-- It looks like a monadic value, so check more carefully.</span>
<span class="lineno"> 1067 </span><span class="spaces">            </span><span class="istickedoff">case typesMatch avail tyenv' tyFound tyExpected of</span>
<span class="lineno"> 1068 </span><span class="spaces">              </span><span class="istickedoff">False -&gt;</span>
<span class="lineno"> 1069 </span><span class="spaces">                  </span><span class="istickedoff">-- While we accept any TopLevel a, don't encourage people</span>
<span class="lineno"> 1070 </span><span class="spaces">                  </span><span class="istickedoff">-- to do that.</span>
<span class="lineno"> 1071 </span><span class="spaces">                  </span><span class="istickedoff">fail &quot;There is a 'main' defined but its type is not TopLevel ()&quot;</span>
<span class="lineno"> 1072 </span><span class="spaces">              </span><span class="istickedoff">True -&gt; do</span>
<span class="lineno"> 1073 </span><span class="spaces">                  </span><span class="istickedoff">let v' = injectPositionIntoMonadicValue <span class="nottickedoff">pos</span> v</span>
<span class="lineno"> 1074 </span><span class="spaces">                      </span><span class="istickedoff">v'' = insertRefChain pos &quot;main&quot; v'</span>
<span class="lineno"> 1075 </span><span class="spaces">                  </span><span class="istickedoff">fromValue FromInterpreter v''</span>
<span class="lineno"> 1076 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1077 </span><span class="spaces">            </span><span class="istickedoff">-- If the type is something entirely random, like a Term or a</span>
<span class="lineno"> 1078 </span><span class="spaces">            </span><span class="istickedoff">-- String or something, just ignore it.</span>
<span class="lineno"> 1079 </span><span class="spaces">            </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1080 </span><span class="spaces">    </span><span class="istickedoff">Just (lc, _ty, _v) -&gt;</span>
<span class="lineno"> 1081 </span><span class="spaces">      </span><span class="istickedoff">-- There is no way for things other than primitives to get marked</span>
<span class="lineno"> 1082 </span><span class="spaces">      </span><span class="istickedoff">-- experimental or deprecated, so this isn't possible. If we allow</span>
<span class="lineno"> 1083 </span><span class="spaces">      </span><span class="istickedoff">-- users to deprecate their own functions in the future, change</span>
<span class="lineno"> 1084 </span><span class="spaces">      </span><span class="istickedoff">-- this message to an actual error that says something snarky :-)</span>
<span class="lineno"> 1085 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;Interpreter&quot; [</span></span>
<span class="lineno"> 1086 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected lifecycle state &quot; &lt;&gt; Text.pack (show lc) &lt;&gt; &quot; for main&quot;</span></span>
<span class="lineno"> 1087 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1088 </span>
<span class="lineno"> 1089 </span>
<span class="lineno"> 1090 </span>buildTopLevelEnv :: Options
<span class="lineno"> 1091 </span>                 -&gt; [Text]
<span class="lineno"> 1092 </span>                 -&gt; TopLevelShellHook
<span class="lineno"> 1093 </span>                 -&gt; ProofScriptShellHook
<span class="lineno"> 1094 </span>                 -&gt; IO (TopLevelRO, TopLevelRW)
<span class="lineno"> 1095 </span><span class="decl"><span class="istickedoff">buildTopLevelEnv opts scriptArgv tlhook pshook = do</span>
<span class="lineno"> 1096 </span><span class="spaces">       </span><span class="istickedoff">let proxy = AIGProxy <span class="nottickedoff">AIG.compactProxy</span></span>
<span class="lineno"> 1097 </span><span class="spaces">       </span><span class="istickedoff">let mn = mkModuleName [&quot;SAWScript&quot;]</span>
<span class="lineno"> 1098 </span><span class="spaces">       </span><span class="istickedoff">sc &lt;- mkSharedContext</span>
<span class="lineno"> 1099 </span><span class="spaces">       </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span></span>
<span class="lineno"> 1100 </span><span class="spaces">       </span><span class="istickedoff">CryptolSAW.scLoadPreludeModule sc</span>
<span class="lineno"> 1101 </span><span class="spaces">       </span><span class="istickedoff">CryptolSAW.scLoadCryptolModule sc</span>
<span class="lineno"> 1102 </span><span class="spaces">       </span><span class="istickedoff">scLoadModule sc (emptyModule mn)</span>
<span class="lineno"> 1103 </span><span class="spaces">       </span><span class="istickedoff">ss &lt;- basic_ss sc</span>
<span class="lineno"> 1104 </span><span class="spaces">       </span><span class="istickedoff">currDir &lt;- getCurrentDirectory</span>
<span class="lineno"> 1105 </span><span class="spaces">       </span><span class="istickedoff">mb_cache &lt;- lookupEnv &quot;SAW_SOLVER_CACHE_PATH&quot; &gt;&gt;= \case</span>
<span class="lineno"> 1106 </span><span class="spaces">         </span><span class="istickedoff">Just path | <span class="tickonlytrue">not (null path)</span> -&gt; Just &lt;$&gt; lazyOpenSolverCache path</span>
<span class="lineno"> 1107 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 1108 </span><span class="spaces">       </span><span class="istickedoff">Crucible.withHandleAllocator $ \halloc -&gt; do</span>
<span class="lineno"> 1109 </span><span class="spaces">       </span><span class="istickedoff">let ro0 = TopLevelRO</span>
<span class="lineno"> 1110 </span><span class="spaces">                   </span><span class="istickedoff">{ roOptions = opts</span>
<span class="lineno"> 1111 </span><span class="spaces">                   </span><span class="istickedoff">, roArgv = scriptArgv</span>
<span class="lineno"> 1112 </span><span class="spaces">                   </span><span class="istickedoff">, roHandleAlloc = halloc</span>
<span class="lineno"> 1113 </span><span class="spaces">                   </span><span class="istickedoff">, roProxy = proxy</span>
<span class="lineno"> 1114 </span><span class="spaces">                   </span><span class="istickedoff">, roInitWorkDir = <span class="nottickedoff">currDir</span></span>
<span class="lineno"> 1115 </span><span class="spaces">                   </span><span class="istickedoff">, roBasicSS = ss</span>
<span class="lineno"> 1116 </span><span class="spaces">                   </span><span class="istickedoff">, roSubshell = tlhook</span>
<span class="lineno"> 1117 </span><span class="spaces">                   </span><span class="istickedoff">, roProofSubshell = pshook</span>
<span class="lineno"> 1118 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 1119 </span><span class="spaces">       </span><span class="istickedoff">let bic = BuiltinContext {</span>
<span class="lineno"> 1120 </span><span class="spaces">                   </span><span class="istickedoff">biSharedContext = sc</span>
<span class="lineno"> 1121 </span><span class="spaces">                 </span><span class="istickedoff">, biBasicSS = ss</span>
<span class="lineno"> 1122 </span><span class="spaces">                 </span><span class="istickedoff">}</span>
<span class="lineno"> 1123 </span><span class="spaces">       </span><span class="istickedoff">ce0 &lt;- CEnv.initCryptolEnv sc</span>
<span class="lineno"> 1124 </span><span class="spaces">       </span><span class="istickedoff">let cryenv0 = CryptolEnvStack ce0 []</span>
<span class="lineno"> 1125 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1126 </span><span class="spaces">       </span><span class="istickedoff">jvmTrans &lt;- CJ.mkInitialJVMContext <span class="nottickedoff">halloc</span></span>
<span class="lineno"> 1127 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1128 </span><span class="spaces">       </span><span class="istickedoff">let rw0 = TopLevelRW</span>
<span class="lineno"> 1129 </span><span class="spaces">                   </span><span class="istickedoff">{ rwEnviron = primEnviron opts bic cryenv0</span>
<span class="lineno"> 1130 </span><span class="spaces">                   </span><span class="istickedoff">, rwRebindables = Map.empty</span>
<span class="lineno"> 1131 </span><span class="spaces">                   </span><span class="istickedoff">, rwPosition = <span class="nottickedoff">SS.Unknown</span></span>
<span class="lineno"> 1132 </span><span class="spaces">                   </span><span class="istickedoff">, rwStackTrace = Trace.empty</span>
<span class="lineno"> 1133 </span><span class="spaces">                   </span><span class="istickedoff">, rwProofs     = []</span>
<span class="lineno"> 1134 </span><span class="spaces">                   </span><span class="istickedoff">, rwPPOpts     = PPS.defaultOpts</span>
<span class="lineno"> 1135 </span><span class="spaces">                   </span><span class="istickedoff">, rwSharedContext = sc</span>
<span class="lineno"> 1136 </span><span class="spaces">                   </span><span class="istickedoff">, rwSolverCache = mb_cache</span>
<span class="lineno"> 1137 </span><span class="spaces">                   </span><span class="istickedoff">, rwTheoremDB = emptyTheoremDB</span>
<span class="lineno"> 1138 </span><span class="spaces">                   </span><span class="istickedoff">, rwJVMTrans   = jvmTrans</span>
<span class="lineno"> 1139 </span><span class="spaces">                   </span><span class="istickedoff">, rwPrimsAvail = defaultAvailable</span>
<span class="lineno"> 1140 </span><span class="spaces">                   </span><span class="istickedoff">, rwSMTArrayMemoryModel = False</span>
<span class="lineno"> 1141 </span><span class="spaces">                   </span><span class="istickedoff">, rwCrucibleAssertThenAssume = False</span>
<span class="lineno"> 1142 </span><span class="spaces">                   </span><span class="istickedoff">, rwProfilingFile = Nothing</span>
<span class="lineno"> 1143 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxArith = False</span>
<span class="lineno"> 1144 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxPointerOrdering = False</span>
<span class="lineno"> 1145 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxLoadsAndStores = False</span>
<span class="lineno"> 1146 </span><span class="spaces">                   </span><span class="istickedoff">, rwDebugIntrinsics = True</span>
<span class="lineno"> 1147 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4HashConsing = False</span>
<span class="lineno"> 1148 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4HashConsingX86 = False</span>
<span class="lineno"> 1149 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4Eval = False</span>
<span class="lineno"> 1150 </span><span class="spaces">                   </span><span class="istickedoff">, rwPreservedRegs = []</span>
<span class="lineno"> 1151 </span><span class="spaces">                   </span><span class="istickedoff">, rwStackBaseAlign = defaultStackBaseAlign</span>
<span class="lineno"> 1152 </span><span class="spaces">                   </span><span class="istickedoff">, rwAllocSymInitCheck = True</span>
<span class="lineno"> 1153 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4PushMuxOps = False</span>
<span class="lineno"> 1154 </span><span class="spaces">                   </span><span class="istickedoff">, rwNoSatisfyingWriteFreshConstant = True</span>
<span class="lineno"> 1155 </span><span class="spaces">                   </span><span class="istickedoff">, rwCrucibleTimeout = CC.defaultSAWCoreBackendTimeout</span>
<span class="lineno"> 1156 </span><span class="spaces">                   </span><span class="istickedoff">, rwPathSatSolver = CC.PathSat_Z3</span>
<span class="lineno"> 1157 </span><span class="spaces">                   </span><span class="istickedoff">, rwSkipSafetyProofs = False</span>
<span class="lineno"> 1158 </span><span class="spaces">                   </span><span class="istickedoff">, rwSingleOverrideSpecialCase = False</span>
<span class="lineno"> 1159 </span><span class="spaces">                   </span><span class="istickedoff">, rwSequentGoals = False</span>
<span class="lineno"> 1160 </span><span class="spaces">                   </span><span class="istickedoff">, rwJavaCodebase = JavaUninitialized</span>
<span class="lineno"> 1161 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 1162 </span><span class="spaces">       </span><span class="istickedoff">return (ro0, rw0)</span></span>
<span class="lineno"> 1163 </span>
<span class="lineno"> 1164 </span>processFile ::
<span class="lineno"> 1165 </span>  Options -&gt;
<span class="lineno"> 1166 </span>  FilePath -&gt;
<span class="lineno"> 1167 </span>  [Text] -&gt;
<span class="lineno"> 1168 </span>  TopLevelShellHook -&gt;
<span class="lineno"> 1169 </span>  ProofScriptShellHook -&gt;
<span class="lineno"> 1170 </span>  IO ()
<span class="lineno"> 1171 </span><span class="decl"><span class="istickedoff">processFile opts file scriptArgv tlhook pshook = do</span>
<span class="lineno"> 1172 </span><span class="spaces">  </span><span class="istickedoff">(ro, rw) &lt;- buildTopLevelEnv opts scriptArgv tlhook pshook</span>
<span class="lineno"> 1173 </span><span class="spaces">  </span><span class="istickedoff">_ &lt;- runTopLevel (interpretFile file True) ro rw</span>
<span class="lineno"> 1174 </span><span class="spaces">            </span><span class="istickedoff">`X.catch` (handleException opts)</span>
<span class="lineno"> 1175 </span><span class="spaces">  </span><span class="istickedoff">return <span class="nottickedoff">()</span></span></span>
<span class="lineno"> 1176 </span>
<span class="lineno"> 1177 </span>
<span class="lineno"> 1178 </span>------------------------------------------------------------
<span class="lineno"> 1179 </span>-- IsValue and FromValue
<span class="lineno"> 1180 </span>
<span class="lineno"> 1181 </span>-- | Class for injecting Haskell values into SAWScript values. This
<span class="lineno"> 1182 </span>--   is straightforward for scalars. For functions, it gets a bit
<span class="lineno"> 1183 </span>--   wibbly.
<span class="lineno"> 1184 </span>--
<span class="lineno"> 1185 </span>--   First, some history. Until July 2025 there was a relatively
<span class="lineno"> 1186 </span>--   straightforward IsValue instance for (a -&gt; b) that matched any
<span class="lineno"> 1187 </span>--   argument type a that supported FromValue, and any result type
<span class="lineno"> 1188 </span>--   supporting IsValue, including functions. Thus, because Haskell
<span class="lineno"> 1189 </span>--   functions are curried, functions of more than one argument would
<span class="lineno"> 1190 </span>--   generate a Value that took one argument and produced a result
<span class="lineno"> 1191 </span>--   recursively using the IsValue instance for the rest of the
<span class="lineno"> 1192 </span>--   function. This produced a chain of Values, each being a closure
<span class="lineno"> 1193 </span>--   of type Value -&gt; TopLevel Value, and the interpreter could call
<span class="lineno"> 1194 </span>--   them by applying argument Values one at a time.
<span class="lineno"> 1195 </span>--
<span class="lineno"> 1196 </span>--   This is fine as long as you're ok with blindly applying arguments
<span class="lineno"> 1197 </span>--   until you get something else back, which is fine as long as all
<span class="lineno"> 1198 </span>--   the interpreter does is execute. However, there are some other
<span class="lineno"> 1199 </span>--   things we'd like to have: correct stack traces require knowing
<span class="lineno"> 1200 </span>--   the name of the function being called at the application of the
<span class="lineno"> 1201 </span>--   last argument. Nice stack traces also involve having the
<span class="lineno"> 1202 </span>--   arguments to the function at that point. Furthermore, if all you
<span class="lineno"> 1203 </span>--   have in the Value is a closure, and someone wants to print it for
<span class="lineno"> 1204 </span>--   debugging, all you can print is &quot;&lt;&lt;closure&gt;&gt;&quot; or &quot;&lt;&lt;function&gt;&gt;&quot;
<span class="lineno"> 1205 </span>--   or similar. It would be much nicer to at least be able to print
<span class="lineno"> 1206 </span>--   the name of the builtin hiding in the closure.
<span class="lineno"> 1207 </span>--
<span class="lineno"> 1208 </span>--   For all of these things, one wants additional info in the Value
<span class="lineno"> 1209 </span>--   besides just the closure, and critically, that info needs to be
<span class="lineno"> 1210 </span>--   carried over when an argument is applied. It is really ugly to do
<span class="lineno"> 1211 </span>--   that if you just have a closure that returns an arbitrary Value;
<span class="lineno"> 1212 </span>--   you have to apply the argument, unwrap the result and then try to
<span class="lineno"> 1213 </span>--   guess if you just applied the last argument and got a return
<span class="lineno"> 1214 </span>--   value (which might also be a lambda from somewhere else) or you
<span class="lineno"> 1215 </span>--   didn't and you should cary the metadata over. That really won't
<span class="lineno"> 1216 </span>--   do.
<span class="lineno"> 1217 </span>--
<span class="lineno"> 1218 </span>--   Therefore, in July 2025, we added another type BuiltinWrapper to
<span class="lineno"> 1219 </span>--   hold the closure chain. There are two cases of BuiltinWrapper,
<span class="lineno"> 1220 </span>--   one where you apply the last arg and get a Value back, and one
<span class="lineno"> 1221 </span>--   where you apply something less than the last arg and get a new
<span class="lineno"> 1222 </span>--   BuiltinWrapper back. Therefore, when applying an argument to a
<span class="lineno"> 1223 </span>--   value holding a builtin function, you can branch on the cases,
<span class="lineno"> 1224 </span>--   and if what you have is still a partly applied builtin, you can
<span class="lineno"> 1225 </span>--   carry over the metadata and update it accordingly. Furthermore,
<span class="lineno"> 1226 </span>--   for the purposes of managing the stack trace, you can know when
<span class="lineno"> 1227 </span>--   you're applying the last argument, because that's the time when
<span class="lineno"> 1228 </span>--   you need to add a frame to the trace.
<span class="lineno"> 1229 </span>--
<span class="lineno"> 1230 </span>--   In this environment, IsValue for a function must generate a chain
<span class="lineno"> 1231 </span>--   of BuiltinWrappers rather than a chain of Values. This turns out
<span class="lineno"> 1232 </span>--   to be problematic. A tidy way to do it would be to have a
<span class="lineno"> 1233 </span>--   separate IsFuncValue class that recursively collects that chain,
<span class="lineno"> 1234 </span>--   then have a single flat IsValue instance for functions that
<span class="lineno"> 1235 </span>--   splices it in. Or, alternatively, make IsFuncValue and
<span class="lineno"> 1236 </span>--   IsBaseValue classes, and then an umbrella IsValue class that
<span class="lineno"> 1237 </span>--   pulls them both in. None of this works. You can't have instances
<span class="lineno"> 1238 </span>--   of the form &quot;instance IsBaseValue a =&gt; IsValue a&quot;; Haskell treats
<span class="lineno"> 1239 </span>--   this as one instance for all types a, rather than as a derivation
<span class="lineno"> 1240 </span>--   rule to generate an instance for any type a that matches the
<span class="lineno"> 1241 </span>--   constraints.
<span class="lineno"> 1242 </span>--
<span class="lineno"> 1243 </span>--   Instead, we keep a single `IsValue` class and instead add more
<span class="lineno"> 1244 </span>--   members to it.
<span class="lineno"> 1245 </span>--
<span class="lineno"> 1246 </span>--   The `toValue` member produces a Value; this is the external entry
<span class="lineno"> 1247 </span>--   point, so it gets called on scalars and all full complete
<span class="lineno"> 1248 </span>--   function types in the builtins table.
<span class="lineno"> 1249 </span>--
<span class="lineno"> 1250 </span>--   The `isFunction` member returns a boolean indicating whether the
<span class="lineno"> 1251 </span>--   value type we're handling is a function. This function requires a
<span class="lineno"> 1252 </span>--   value of the appropriate type in order to allow the typeclass to
<span class="lineno"> 1253 </span>--   match, but doesn't use it. The class provides a default
<span class="lineno"> 1254 </span>--   implementation of False, which is overridden explicitly only in
<span class="lineno"> 1255 </span>--   the instance for functions.
<span class="lineno"> 1256 </span>--
<span class="lineno"> 1257 </span>--   The `toWrapper` member produces a `BuiltinWrapper`. The instance
<span class="lineno"> 1258 </span>--   for functions uses this to recurse and produce the chain of
<span class="lineno"> 1259 </span>--   `BuiltinWrapper` values containing closures. It uses
<span class="lineno"> 1260 </span>--   `isBaseValue` on the function return type to check whether it's
<span class="lineno"> 1261 </span>--   on the last argument or not, and constructs the wrapper
<span class="lineno"> 1262 </span>--   accordingly. A default implementation that panics is provided;
<span class="lineno"> 1263 </span>--   only the function instance overrides that.
<span class="lineno"> 1264 </span>--
<span class="lineno"> 1265 </span>--   Be careful: there's a possible hole in this logic, which is that
<span class="lineno"> 1266 </span>--   we treat Value itself as a non-function value. There needs to be
<span class="lineno"> 1267 </span>--   an IsValue instance for Value, because there are a number of
<span class="lineno"> 1268 </span>--   builtins whose Haskell type involves Value, generally in order to
<span class="lineno"> 1269 </span>--   be polymorphic at the SAWScript level. Any builtin that _returns_
<span class="lineno"> 1270 </span>--   Value (arguments use FromValue and are safe from these concerns),
<span class="lineno"> 1271 </span>--   and want that Value to wrap a Haskell function, need to cons up
<span class="lineno"> 1272 </span>--   the proper BuiltinWrapper chain by hand. A few examples exist.
<span class="lineno"> 1273 </span>--
<span class="lineno"> 1274 </span>--   (Also note that it must work this way; we _cannot_ examine the
<span class="lineno"> 1275 </span>--   argument to `isFunction` because the `toWrapper` logic for
<span class="lineno"> 1276 </span>--   functions must decide which case it's looking at without calling
<span class="lineno"> 1277 </span>--   its function to get a value of the proper type and there isn't
<span class="lineno"> 1278 </span>--   any other concrete one to use.)
<span class="lineno"> 1279 </span>--
<span class="lineno"> 1280 </span>--   There is no FromValue instance for functions. If we want to have
<span class="lineno"> 1281 </span>--   builtins taking callback arguments, we'll need to do something
<span class="lineno"> 1282 </span>--   about that, and it'll probably get complicated. (Currently
<span class="lineno"> 1283 </span>--   everything that looks like a callback is a monadic action taking
<span class="lineno"> 1284 </span>--   no arguments.)
<span class="lineno"> 1285 </span>--
<span class="lineno"> 1286 </span>--   Note if working on this code that any change to the logic that
<span class="lineno"> 1287 </span>--   involves additional annotations or explicitly distinguishing
<span class="lineno"> 1288 </span>--   functions from scalars will require touching ~every entry in the
<span class="lineno"> 1289 </span>--   builtins table, and there are a _lot_ of builtins.
<span class="lineno"> 1290 </span>--
<span class="lineno"> 1291 </span>--   Also be aware that there are a handful of builtins that _execute_
<span class="lineno"> 1292 </span>--   in TopLevel when applied, rather than returning a SAWScript
<span class="lineno"> 1293 </span>--   TopLevel action.  As things stand these _must_ circumvent this
<span class="lineno"> 1294 </span>--   logic and not use toValue directly; there is no way to get the
<span class="lineno"> 1295 </span>--   function values generated herein to behave that way, because
<span class="lineno"> 1296 </span>--   there's no difference in the types to work from.
<span class="lineno"> 1297 </span>--
<span class="lineno"> 1298 </span>class IsValue a where
<span class="lineno"> 1299 </span>    toValue :: Text -&gt; a -&gt; Value
<span class="lineno"> 1300 </span>    -- these will be overridden on the function instance
<span class="lineno"> 1301 </span>    isFunction :: a -&gt; Bool
<span class="lineno"> 1302 </span>    <span class="decl"><span class="istickedoff">isFunction _ = False</span></span>
<span class="lineno"> 1303 </span>    toWrapper :: Text -&gt; a -&gt; BuiltinWrapper
<span class="lineno"> 1304 </span>    <span class="decl"><span class="nottickedoff">toWrapper _ _ = panic &quot;toWrapper&quot; [&quot;Invalid call on base value&quot;]</span></span>
<span class="lineno"> 1305 </span>
<span class="lineno"> 1306 </span>-- | Flag to indicate where/how fromValue was triggered.
<span class="lineno"> 1307 </span>--   (Could be just a Bool, but having it be its own thing increases
<span class="lineno"> 1308 </span>--   legibility and this whole set of arrangements is delicate.)
<span class="lineno"> 1309 </span>data FromValueHow = FromInterpreter | FromArgument
<span class="lineno"> 1310 </span>
<span class="lineno"> 1311 </span>class FromValue a where
<span class="lineno"> 1312 </span>    fromValue :: FromValueHow -&gt; Value -&gt; a
<span class="lineno"> 1313 </span>
<span class="lineno"> 1314 </span>instance (FromValue a, IsValue b) =&gt; IsValue (a -&gt; b) where
<span class="lineno"> 1315 </span>    <span class="decl"><span class="istickedoff">toValue name f = VBuiltin name <span class="nottickedoff">Seq.empty</span> $ toWrapper <span class="nottickedoff">name</span> f</span></span>
<span class="lineno"> 1316 </span>    <span class="decl"><span class="istickedoff">isFunction _ = True</span></span>
<span class="lineno"> 1317 </span>    <span class="decl"><span class="istickedoff">toWrapper name f =</span>
<span class="lineno"> 1318 </span><span class="spaces">        </span><span class="istickedoff">-- | isFunction needs a value of type b, which we don't have,</span>
<span class="lineno"> 1319 </span><span class="spaces">        </span><span class="istickedoff">--   but doesn't look at it, so we can use a placeholder, and</span>
<span class="lineno"> 1320 </span><span class="spaces">        </span><span class="istickedoff">--   it's ok for it to be a bomb.</span>
<span class="lineno"> 1321 </span><span class="spaces">        </span><span class="istickedoff">let hook :: b = <span class="nottickedoff">panic &quot;toWrapper&quot; [&quot;isFunction must have used its argument&quot;]</span> in</span>
<span class="lineno"> 1322 </span><span class="spaces">        </span><span class="istickedoff">if isFunction <span class="nottickedoff">hook</span> then</span>
<span class="lineno"> 1323 </span><span class="spaces">          </span><span class="istickedoff">let f' v = return $ toWrapper <span class="nottickedoff">name</span> (f (fromValue FromArgument v)) in</span>
<span class="lineno"> 1324 </span><span class="spaces">          </span><span class="istickedoff">ManyMoreArgs f'</span>
<span class="lineno"> 1325 </span><span class="spaces">        </span><span class="istickedoff">else</span>
<span class="lineno"> 1326 </span><span class="spaces">          </span><span class="istickedoff">let f' v = return $ toValue <span class="nottickedoff">name</span> (f (fromValue FromArgument v)) in</span>
<span class="lineno"> 1327 </span><span class="spaces">          </span><span class="istickedoff">OneMoreArg f'</span></span>
<span class="lineno"> 1328 </span>
<span class="lineno"> 1329 </span>instance FromValue Value where
<span class="lineno"> 1330 </span>    <span class="decl"><span class="istickedoff">fromValue _ x = x</span></span>
<span class="lineno"> 1331 </span>
<span class="lineno"> 1332 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Value</span></span></span></span> where
<span class="lineno"> 1333 </span>    <span class="decl"><span class="istickedoff">toValue _name x = x</span></span>
<span class="lineno"> 1334 </span>
<span class="lineno"> 1335 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue ()</span></span></span></span> where
<span class="lineno"> 1336 </span>    <span class="decl"><span class="istickedoff">toValue _name _ = VTuple []</span></span>
<span class="lineno"> 1337 </span>
<span class="lineno"> 1338 </span>instance FromValue () where
<span class="lineno"> 1339 </span>    <span class="decl"><span class="istickedoff">fromValue _ _ = ()</span></span>
<span class="lineno"> 1340 </span>
<span class="lineno"> 1341 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(IsValue a, IsValue b) =&gt; IsValue (a, b)</span></span></span></span> where
<span class="lineno"> 1342 </span>    <span class="decl"><span class="nottickedoff">toValue name (x, y) = VTuple [toValue name x, toValue name y]</span></span>
<span class="lineno"> 1343 </span>
<span class="lineno"> 1344 </span>instance (FromValue a, FromValue b) =&gt; FromValue (a, b) where
<span class="lineno"> 1345 </span>    <span class="decl"><span class="nottickedoff">fromValue how (VTuple [x, y]) = (fromValue how x, fromValue how y)</span>
<span class="lineno"> 1346 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue (,)&quot;</span></span>
<span class="lineno"> 1347 </span>
<span class="lineno"> 1348 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(IsValue a, IsValue b, IsValue c) =&gt; IsValue (a, b, c)</span></span></span></span> where
<span class="lineno"> 1349 </span>    <span class="decl"><span class="nottickedoff">toValue name (x, y, z) = VTuple [toValue name x, toValue name y, toValue name z]</span></span>
<span class="lineno"> 1350 </span>
<span class="lineno"> 1351 </span>instance (FromValue a, FromValue b, FromValue c) =&gt; FromValue (a, b, c) where
<span class="lineno"> 1352 </span>    <span class="decl"><span class="nottickedoff">fromValue how (VTuple [x, y, z]) = (fromValue how x, fromValue how y, fromValue how z)</span>
<span class="lineno"> 1353 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue (,,)&quot;</span></span>
<span class="lineno"> 1354 </span>
<span class="lineno"> 1355 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue [a]</span></span></span></span> where
<span class="lineno"> 1356 </span>    <span class="decl"><span class="istickedoff">toValue name xs = VArray (map (toValue <span class="nottickedoff">name</span>) xs)</span></span>
<span class="lineno"> 1357 </span>
<span class="lineno"> 1358 </span>
<span class="lineno"> 1359 </span>instance FromValue a =&gt; FromValue [a] where
<span class="lineno"> 1360 </span>    <span class="decl"><span class="istickedoff">fromValue how (VArray xs) = map (fromValue <span class="nottickedoff">how</span>) xs</span>
<span class="lineno"> 1361 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue []&quot;</span></span></span>
<span class="lineno"> 1362 </span>
<span class="lineno"> 1363 </span>
<span class="lineno"> 1364 </span>-- | Common logic for the FromValue instances for plain monadic values.
<span class="lineno"> 1365 </span>--   Runs in any interpreter monad.
<span class="lineno"> 1366 </span>--
<span class="lineno"> 1367 </span>--   Note: this won't actually run until the result action is bound into
<span class="lineno"> 1368 </span>--   the execution sequence somewhere (downstream from fromValue).
<span class="lineno"> 1369 </span>preparePlainMonadicAction ::
<span class="lineno"> 1370 </span>  forall m a. InterpreterMonad m =&gt; FromValueHow -&gt; SS.Pos -&gt; RefChain -&gt; m a -&gt; m a
<span class="lineno"> 1371 </span><span class="decl"><span class="istickedoff">preparePlainMonadicAction how pos chain action = do</span>
<span class="lineno"> 1372 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno"> 1373 </span><span class="spaces">    </span><span class="istickedoff">setPosition pos</span>
<span class="lineno"> 1374 </span><span class="spaces">    </span><span class="istickedoff">case how of</span>
<span class="lineno"> 1375 </span><span class="spaces">        </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1376 </span><span class="spaces">        </span><span class="istickedoff">FromArgument -&gt; pushTraceFrame SS.PosInsideBuiltin &quot;(callback)&quot;</span>
<span class="lineno"> 1377 </span><span class="spaces">    </span><span class="istickedoff">pushTraceFrames chain</span>
<span class="lineno"> 1378 </span><span class="spaces">  </span><span class="istickedoff">ret &lt;- action</span>
<span class="lineno"> 1379 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno"> 1380 </span><span class="spaces">    </span><span class="istickedoff">popTraceFrames chain</span>
<span class="lineno"> 1381 </span><span class="spaces">    </span><span class="istickedoff">case how of</span>
<span class="lineno"> 1382 </span><span class="spaces">        </span><span class="istickedoff">FromInterpreter -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1383 </span><span class="spaces">        </span><span class="istickedoff">FromArgument -&gt; popTraceFrame</span>
<span class="lineno"> 1384 </span><span class="spaces">  </span><span class="istickedoff">return ret</span></span>
<span class="lineno"> 1385 </span>
<span class="lineno"> 1386 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (IO a)</span></span></span></span> where
<span class="lineno"> 1387 </span>    <span class="decl"><span class="istickedoff">toValue name action = toValue <span class="nottickedoff">name</span> (io action)</span></span>
<span class="lineno"> 1388 </span>
<span class="lineno"> 1389 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (TopLevel a)</span></span></span></span> where
<span class="lineno"> 1390 </span>    <span class="decl"><span class="istickedoff">toValue name action =</span>
<span class="lineno"> 1391 </span><span class="spaces">      </span><span class="istickedoff">VTopLevel <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) action)</span></span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>instance FromValue a =&gt; FromValue (TopLevel a) where
<span class="lineno"> 1394 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1395 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1396 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1397 </span><span class="spaces">        </span><span class="istickedoff">VTopLevel pos chain action -&gt;</span>
<span class="lineno"> 1398 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1399 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1400 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (TopLevel)&quot; [</span></span>
<span class="lineno"> 1401 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1402 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1403 </span>
<span class="lineno"> 1404 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (ProofScript a)</span></span></span></span> where
<span class="lineno"> 1405 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1406 </span><span class="spaces">      </span><span class="istickedoff">VProofScript <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1407 </span>
<span class="lineno"> 1408 </span>instance FromValue a =&gt; FromValue (ProofScript a) where
<span class="lineno"> 1409 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1410 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1411 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1412 </span><span class="spaces">        </span><span class="istickedoff">VProofScript pos chain action -&gt;</span>
<span class="lineno"> 1413 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1414 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1415 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (ProofScript)&quot; [</span></span>
<span class="lineno"> 1416 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1417 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1418 </span>
<span class="lineno"> 1419 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (LLVMCrucibleSetupM a)</span></span></span></span> where
<span class="lineno"> 1420 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1421 </span><span class="spaces">      </span><span class="istickedoff">VLLVMCrucibleSetup <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1422 </span>
<span class="lineno"> 1423 </span>instance FromValue a =&gt; FromValue (LLVMCrucibleSetupM a) where
<span class="lineno"> 1424 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1425 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1426 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1427 </span><span class="spaces">        </span><span class="istickedoff">VLLVMCrucibleSetup pos chain action -&gt;</span>
<span class="lineno"> 1428 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1429 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1430 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (LLVMSetup)&quot; [</span></span>
<span class="lineno"> 1431 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1432 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1433 </span>
<span class="lineno"> 1434 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (JVMSetupM a)</span></span></span></span> where
<span class="lineno"> 1435 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1436 </span><span class="spaces">      </span><span class="istickedoff">VJVMSetup <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1437 </span>
<span class="lineno"> 1438 </span>instance FromValue a =&gt; FromValue (JVMSetupM a) where
<span class="lineno"> 1439 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1440 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1441 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1442 </span><span class="spaces">        </span><span class="istickedoff">VJVMSetup pos chain action -&gt;</span>
<span class="lineno"> 1443 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1444 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1445 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (JVMSetup)&quot; [</span></span>
<span class="lineno"> 1446 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1447 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1448 </span>
<span class="lineno"> 1449 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue a =&gt; IsValue (MIRSetupM a)</span></span></span></span> where
<span class="lineno"> 1450 </span>    <span class="decl"><span class="istickedoff">toValue name m =</span>
<span class="lineno"> 1451 </span><span class="spaces">      </span><span class="istickedoff">VMIRSetup <span class="nottickedoff">atRestPos</span> [] (fmap (toValue <span class="nottickedoff">name</span>) m)</span></span>
<span class="lineno"> 1452 </span>
<span class="lineno"> 1453 </span>instance FromValue a =&gt; FromValue (MIRSetupM a) where
<span class="lineno"> 1454 </span>    <span class="decl"><span class="istickedoff">fromValue how v = do</span>
<span class="lineno"> 1455 </span><span class="spaces">      </span><span class="istickedoff">v' &lt;- interpretMonadAction how v</span>
<span class="lineno"> 1456 </span><span class="spaces">      </span><span class="istickedoff">case v' of</span>
<span class="lineno"> 1457 </span><span class="spaces">        </span><span class="istickedoff">VMIRSetup pos chain action -&gt;</span>
<span class="lineno"> 1458 </span><span class="spaces">          </span><span class="istickedoff">fromValue <span class="nottickedoff">how</span> &lt;$&gt; preparePlainMonadicAction how pos chain action</span>
<span class="lineno"> 1459 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1460 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;fromValue (MIRSetup)&quot; [</span></span>
<span class="lineno"> 1461 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid/ill-typed value: &quot; &lt;&gt; Text.pack (show v')</span></span>
<span class="lineno"> 1462 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1463 </span>
<span class="lineno"> 1464 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue (CIR.AllLLVM CMS.SetupValue)</span></span></span></span> where
<span class="lineno"> 1465 </span>  <span class="decl"><span class="istickedoff">toValue _name v = VLLVMCrucibleSetupValue v</span></span>
<span class="lineno"> 1466 </span>
<span class="lineno"> 1467 </span>instance FromValue (CIR.AllLLVM CMS.SetupValue) where
<span class="lineno"> 1468 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VLLVMCrucibleSetupValue v) = v</span>
<span class="lineno"> 1469 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Crucible.SetupValue&quot;</span></span></span>
<span class="lineno"> 1470 </span>
<span class="lineno"> 1471 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.SetupValue CJ.JVM)</span></span></span></span> where
<span class="lineno"> 1472 </span>  <span class="decl"><span class="istickedoff">toValue _name v = VJVMSetupValue v</span></span>
<span class="lineno"> 1473 </span>
<span class="lineno"> 1474 </span>instance FromValue (CMS.SetupValue CJ.JVM) where
<span class="lineno"> 1475 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VJVMSetupValue v) = v</span>
<span class="lineno"> 1476 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Crucible.SetupValue&quot;</span></span></span>
<span class="lineno"> 1477 </span>
<span class="lineno"> 1478 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.SetupValue MIR)</span></span></span></span> where
<span class="lineno"> 1479 </span>  <span class="decl"><span class="istickedoff">toValue _name v = VMIRSetupValue v</span></span>
<span class="lineno"> 1480 </span>
<span class="lineno"> 1481 </span>instance FromValue (CMS.SetupValue MIR) where
<span class="lineno"> 1482 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VMIRSetupValue v) = v</span>
<span class="lineno"> 1483 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Crucible.SetupValue&quot;</span></span></span>
<span class="lineno"> 1484 </span>
<span class="lineno"> 1485 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SAW_CFG</span></span></span></span> where
<span class="lineno"> 1486 </span>    <span class="decl"><span class="nottickedoff">toValue _name t = VCFG t</span></span>
<span class="lineno"> 1487 </span>
<span class="lineno"> 1488 </span>instance FromValue SAW_CFG where
<span class="lineno"> 1489 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VCFG t) = t</span>
<span class="lineno"> 1490 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue CFG&quot;</span></span>
<span class="lineno"> 1491 </span>
<span class="lineno"> 1492 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CIR.SomeLLVM CMS.ProvedSpec)</span></span></span></span> where
<span class="lineno"> 1493 </span>    <span class="decl"><span class="istickedoff">toValue _name mir = VLLVMCrucibleMethodSpec mir</span></span>
<span class="lineno"> 1494 </span>
<span class="lineno"> 1495 </span>instance FromValue (CIR.SomeLLVM CMS.ProvedSpec) where
<span class="lineno"> 1496 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VLLVMCrucibleMethodSpec mir) = mir</span>
<span class="lineno"> 1497 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue ProvedSpec LLVM&quot;</span></span></span>
<span class="lineno"> 1498 </span>
<span class="lineno"> 1499 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.ProvedSpec CJ.JVM)</span></span></span></span> where
<span class="lineno"> 1500 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VJVMMethodSpec t</span></span>
<span class="lineno"> 1501 </span>
<span class="lineno"> 1502 </span>instance FromValue (CMS.ProvedSpec CJ.JVM) where
<span class="lineno"> 1503 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VJVMMethodSpec t) = t</span>
<span class="lineno"> 1504 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue ProvedSpec JVM&quot;</span></span></span>
<span class="lineno"> 1505 </span>
<span class="lineno"> 1506 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CMS.ProvedSpec MIR)</span></span></span></span> where
<span class="lineno"> 1507 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VMIRMethodSpec t</span></span>
<span class="lineno"> 1508 </span>
<span class="lineno"> 1509 </span>instance FromValue (CMS.ProvedSpec MIR) where
<span class="lineno"> 1510 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRMethodSpec t) = t</span>
<span class="lineno"> 1511 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue ProvedSpec MIR&quot;</span></span></span>
<span class="lineno"> 1512 </span>
<span class="lineno"> 1513 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue ModuleSkeleton</span></span></span></span> where
<span class="lineno"> 1514 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMModuleSkeleton s</span></span>
<span class="lineno"> 1515 </span>
<span class="lineno"> 1516 </span>instance FromValue ModuleSkeleton where
<span class="lineno"> 1517 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMModuleSkeleton s) = s</span>
<span class="lineno"> 1518 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue ModuleSkeleton&quot;</span></span>
<span class="lineno"> 1519 </span>
<span class="lineno"> 1520 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue FunctionSkeleton</span></span></span></span> where
<span class="lineno"> 1521 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMFunctionSkeleton s</span></span>
<span class="lineno"> 1522 </span>
<span class="lineno"> 1523 </span>instance FromValue FunctionSkeleton where
<span class="lineno"> 1524 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMFunctionSkeleton s) = s</span>
<span class="lineno"> 1525 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue FunctionSkeleton&quot;</span></span>
<span class="lineno"> 1526 </span>
<span class="lineno"> 1527 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SkeletonState</span></span></span></span> where
<span class="lineno"> 1528 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMSkeletonState s</span></span>
<span class="lineno"> 1529 </span>
<span class="lineno"> 1530 </span>instance FromValue SkeletonState where
<span class="lineno"> 1531 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMSkeletonState s) = s</span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue SkeletonState&quot;</span></span>
<span class="lineno"> 1533 </span>
<span class="lineno"> 1534 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue FunctionProfile</span></span></span></span> where
<span class="lineno"> 1535 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VLLVMFunctionProfile s</span></span>
<span class="lineno"> 1536 </span>
<span class="lineno"> 1537 </span>instance FromValue FunctionProfile where
<span class="lineno"> 1538 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VLLVMFunctionProfile s) = s</span>
<span class="lineno"> 1539 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue FunctionProfile&quot;</span></span>
<span class="lineno"> 1540 </span>
<span class="lineno"> 1541 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (AIGNetwork)</span></span></span></span> where
<span class="lineno"> 1542 </span>    <span class="decl"><span class="nottickedoff">toValue _name t = VAIG t</span></span>
<span class="lineno"> 1543 </span>
<span class="lineno"> 1544 </span>instance FromValue (AIGNetwork) where
<span class="lineno"> 1545 </span>    <span class="decl"><span class="nottickedoff">fromValue _ (VAIG t) = t</span>
<span class="lineno"> 1546 </span><span class="spaces">    </span><span class="nottickedoff">fromValue _ _ = error &quot;fromValue AIGNetwork&quot;</span></span>
<span class="lineno"> 1547 </span>
<span class="lineno"> 1548 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue TypedTerm</span></span></span></span> where
<span class="lineno"> 1549 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VTerm t</span></span>
<span class="lineno"> 1550 </span>
<span class="lineno"> 1551 </span>instance FromValue TypedTerm where
<span class="lineno"> 1552 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VTerm t) = t</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue TypedTerm&quot;</span></span></span>
<span class="lineno"> 1554 </span>
<span class="lineno"> 1555 </span>instance FromValue Term where
<span class="lineno"> 1556 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VTerm t) = ttTerm t</span>
<span class="lineno"> 1557 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue SharedTerm&quot;</span></span></span>
<span class="lineno"> 1558 </span>
<span class="lineno"> 1559 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Cryptol.Schema</span></span></span></span> where
<span class="lineno"> 1560 </span>    <span class="decl"><span class="nottickedoff">toValue _name s = VType s</span></span>
<span class="lineno"> 1561 </span>
<span class="lineno"> 1562 </span>instance FromValue Cryptol.Schema where
<span class="lineno"> 1563 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VType s) = s</span>
<span class="lineno"> 1564 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Schema&quot;</span></span></span>
<span class="lineno"> 1565 </span>
<span class="lineno"> 1566 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Text</span></span></span></span> where
<span class="lineno"> 1567 </span>    <span class="decl"><span class="istickedoff">toValue _name n = VString n</span></span>
<span class="lineno"> 1568 </span>
<span class="lineno"> 1569 </span>instance FromValue Text where
<span class="lineno"> 1570 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VString n) = n</span>
<span class="lineno"> 1571 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Text&quot;</span></span></span>
<span class="lineno"> 1572 </span>
<span class="lineno"> 1573 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Integer</span></span></span></span> where
<span class="lineno"> 1574 </span>    <span class="decl"><span class="istickedoff">toValue _name n = VInteger n</span></span>
<span class="lineno"> 1575 </span>
<span class="lineno"> 1576 </span>instance FromValue Integer where
<span class="lineno"> 1577 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VInteger n) = n</span>
<span class="lineno"> 1578 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Integer&quot;</span></span></span>
<span class="lineno"> 1579 </span>
<span class="lineno"> 1580 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Int</span></span></span></span> where
<span class="lineno"> 1581 </span>    <span class="decl"><span class="istickedoff">toValue _name n = VInteger (toInteger n)</span></span>
<span class="lineno"> 1582 </span>
<span class="lineno"> 1583 </span>instance FromValue Int where
<span class="lineno"> 1584 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VInteger n)</span>
<span class="lineno"> 1585 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">toInteger (minBound :: Int) &lt;= n &amp;&amp;</span></span>
<span class="lineno"> 1586 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue">toInteger (maxBound :: Int) &gt;= n</span> = fromIntegral n</span>
<span class="lineno"> 1587 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">error $ &quot;fromValue Int: out of range: &quot; ++ show n</span></span>
<span class="lineno"> 1588 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Int&quot;</span></span></span>
<span class="lineno"> 1589 </span>
<span class="lineno"> 1590 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue Bool</span></span></span></span> where
<span class="lineno"> 1591 </span>    <span class="decl"><span class="istickedoff">toValue _name b = VBool b</span></span>
<span class="lineno"> 1592 </span>
<span class="lineno"> 1593 </span>instance FromValue Bool where
<span class="lineno"> 1594 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VBool b) = b</span>
<span class="lineno"> 1595 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Bool&quot;</span></span></span>
<span class="lineno"> 1596 </span>
<span class="lineno"> 1597 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SAWSimpset</span></span></span></span> where
<span class="lineno"> 1598 </span>    <span class="decl"><span class="istickedoff">toValue _name ss = VSimpset ss</span></span>
<span class="lineno"> 1599 </span>
<span class="lineno"> 1600 </span>instance FromValue SAWSimpset where
<span class="lineno"> 1601 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VSimpset ss) = ss</span>
<span class="lineno"> 1602 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Simpset&quot;</span></span></span>
<span class="lineno"> 1603 </span>
<span class="lineno"> 1604 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Theorem</span></span></span></span> where
<span class="lineno"> 1605 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VTheorem t</span></span>
<span class="lineno"> 1606 </span>
<span class="lineno"> 1607 </span>instance FromValue Theorem where
<span class="lineno"> 1608 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VTheorem t) = t</span>
<span class="lineno"> 1609 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Theorem&quot;</span></span></span>
<span class="lineno"> 1610 </span>
<span class="lineno"> 1611 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue BisimTheorem</span></span></span></span> where
<span class="lineno"> 1612 </span>    <span class="decl"><span class="istickedoff">toValue _name = VBisimTheorem</span></span>
<span class="lineno"> 1613 </span>
<span class="lineno"> 1614 </span>instance FromValue BisimTheorem where
<span class="lineno"> 1615 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VBisimTheorem t) = t</span>
<span class="lineno"> 1616 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue BisimTheorem&quot;</span></span></span>
<span class="lineno"> 1617 </span>
<span class="lineno"> 1618 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue JavaType</span></span></span></span> where
<span class="lineno"> 1619 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VJavaType t</span></span>
<span class="lineno"> 1620 </span>
<span class="lineno"> 1621 </span>instance FromValue JavaType where
<span class="lineno"> 1622 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VJavaType t) = t</span>
<span class="lineno"> 1623 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue JavaType&quot;</span></span></span>
<span class="lineno"> 1624 </span>
<span class="lineno"> 1625 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue LLVM.Type</span></span></span></span> where
<span class="lineno"> 1626 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VLLVMType t</span></span>
<span class="lineno"> 1627 </span>
<span class="lineno"> 1628 </span>instance FromValue LLVM.Type where
<span class="lineno"> 1629 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VLLVMType t) = t</span>
<span class="lineno"> 1630 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue LLVMType&quot;</span></span></span>
<span class="lineno"> 1631 </span>
<span class="lineno"> 1632 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">IsValue MIR.Ty</span></span></span></span> where
<span class="lineno"> 1633 </span>    <span class="decl"><span class="istickedoff">toValue _name t = VMIRType t</span></span>
<span class="lineno"> 1634 </span>
<span class="lineno"> 1635 </span>instance FromValue MIR.Ty where
<span class="lineno"> 1636 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRType t) = t</span>
<span class="lineno"> 1637 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue MIRType&quot;</span></span></span>
<span class="lineno"> 1638 </span>
<span class="lineno"> 1639 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue CEnv.ExtCryptolModule</span></span></span></span> where
<span class="lineno"> 1640 </span>    <span class="decl"><span class="istickedoff">toValue _name m = VCryptolModule m</span></span>
<span class="lineno"> 1641 </span>
<span class="lineno"> 1642 </span>instance FromValue CEnv.ExtCryptolModule where
<span class="lineno"> 1643 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VCryptolModule m) = m</span>
<span class="lineno"> 1644 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue CryptolModule&quot;</span></span></span>
<span class="lineno"> 1645 </span>
<span class="lineno"> 1646 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue JSS.Class</span></span></span></span> where
<span class="lineno"> 1647 </span>    <span class="decl"><span class="istickedoff">toValue _name c = VJavaClass c</span></span>
<span class="lineno"> 1648 </span>
<span class="lineno"> 1649 </span>instance FromValue JSS.Class where
<span class="lineno"> 1650 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VJavaClass c) = c</span>
<span class="lineno"> 1651 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue JavaClass&quot;</span></span></span>
<span class="lineno"> 1652 </span>
<span class="lineno"> 1653 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (Some CIR.LLVMModule)</span></span></span></span> where
<span class="lineno"> 1654 </span>    <span class="decl"><span class="istickedoff">toValue _name m = VLLVMModule m</span></span>
<span class="lineno"> 1655 </span>
<span class="lineno"> 1656 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue (CIR.LLVMModule arch)</span></span></span></span> where
<span class="lineno"> 1657 </span>    <span class="decl"><span class="nottickedoff">toValue _name m = VLLVMModule (Some m)</span></span>
<span class="lineno"> 1658 </span>
<span class="lineno"> 1659 </span>instance FromValue (Some CIR.LLVMModule) where
<span class="lineno"> 1660 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VLLVMModule m) = m</span>
<span class="lineno"> 1661 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue LLVMModule&quot;</span></span></span>
<span class="lineno"> 1662 </span>
<span class="lineno"> 1663 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue MIR.RustModule</span></span></span></span> where
<span class="lineno"> 1664 </span>    <span class="decl"><span class="istickedoff">toValue _name m = VMIRModule m</span></span>
<span class="lineno"> 1665 </span>
<span class="lineno"> 1666 </span>instance FromValue MIR.RustModule where
<span class="lineno"> 1667 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRModule m) = m</span>
<span class="lineno"> 1668 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue RustModule&quot;</span></span></span>
<span class="lineno"> 1669 </span>
<span class="lineno"> 1670 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue MIR.Adt</span></span></span></span> where
<span class="lineno"> 1671 </span>    <span class="decl"><span class="istickedoff">toValue _name adt = VMIRAdt adt</span></span>
<span class="lineno"> 1672 </span>
<span class="lineno"> 1673 </span>instance FromValue MIR.Adt where
<span class="lineno"> 1674 </span>    <span class="decl"><span class="istickedoff">fromValue _ (VMIRAdt adt) = adt</span>
<span class="lineno"> 1675 </span><span class="spaces">    </span><span class="istickedoff">fromValue _ _ = <span class="nottickedoff">error &quot;fromValue Adt&quot;</span></span></span>
<span class="lineno"> 1676 </span>
<span class="lineno"> 1677 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue ProofResult</span></span></span></span> where
<span class="lineno"> 1678 </span>   <span class="decl"><span class="istickedoff">toValue _name r = VProofResult r</span></span>
<span class="lineno"> 1679 </span>
<span class="lineno"> 1680 </span>instance FromValue ProofResult where
<span class="lineno"> 1681 </span>   <span class="decl"><span class="istickedoff">fromValue _ (VProofResult r) = r</span>
<span class="lineno"> 1682 </span><span class="spaces">   </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error $ &quot;fromValue ProofResult: &quot; ++ show v</span></span></span>
<span class="lineno"> 1683 </span>
<span class="lineno"> 1684 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue SatResult</span></span></span></span> where
<span class="lineno"> 1685 </span>   <span class="decl"><span class="istickedoff">toValue _name r = VSatResult r</span></span>
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>instance FromValue SatResult where
<span class="lineno"> 1688 </span>   <span class="decl"><span class="istickedoff">fromValue _ (VSatResult r) = r</span>
<span class="lineno"> 1689 </span><span class="spaces">   </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error $ &quot;fromValue SatResult: &quot; ++ show v</span></span></span>
<span class="lineno"> 1690 </span>
<span class="lineno"> 1691 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue CMS.GhostGlobal</span></span></span></span> where
<span class="lineno"> 1692 </span>  <span class="decl"><span class="nottickedoff">toValue _name x = VGhostVar x</span></span>
<span class="lineno"> 1693 </span>
<span class="lineno"> 1694 </span>instance FromValue CMS.GhostGlobal where
<span class="lineno"> 1695 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VGhostVar r) = r</span>
<span class="lineno"> 1696 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error (&quot;fromValue GlobalVar: &quot; ++ show v)</span></span></span>
<span class="lineno"> 1697 </span>
<span class="lineno"> 1698 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysIR</span></span></span></span> where
<span class="lineno"> 1699 </span>  <span class="decl"><span class="nottickedoff">toValue _name ym = VYosysModule ym</span></span>
<span class="lineno"> 1700 </span>
<span class="lineno"> 1701 </span>instance FromValue Yo.YosysIR where
<span class="lineno"> 1702 </span>  <span class="decl"><span class="nottickedoff">fromValue _ (VYosysModule ir) = ir</span>
<span class="lineno"> 1703 </span><span class="spaces">  </span><span class="nottickedoff">fromValue _ v = error (&quot;fromValue YosysIR: &quot; ++ show v)</span></span>
<span class="lineno"> 1704 </span>
<span class="lineno"> 1705 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysImport</span></span></span></span> where
<span class="lineno"> 1706 </span>  <span class="decl"><span class="nottickedoff">toValue _name yi = VYosysImport yi</span></span>
<span class="lineno"> 1707 </span>
<span class="lineno"> 1708 </span>instance FromValue Yo.YosysImport where
<span class="lineno"> 1709 </span>  <span class="decl"><span class="nottickedoff">fromValue _ (VYosysImport i) = i</span>
<span class="lineno"> 1710 </span><span class="spaces">  </span><span class="nottickedoff">fromValue _ v = error (&quot;fromValue YosysImport: &quot; ++ show v)</span></span>
<span class="lineno"> 1711 </span>
<span class="lineno"> 1712 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysSequential</span></span></span></span> where
<span class="lineno"> 1713 </span>  <span class="decl"><span class="istickedoff">toValue _name ysq = VYosysSequential ysq</span></span>
<span class="lineno"> 1714 </span>
<span class="lineno"> 1715 </span>instance FromValue Yo.YosysSequential where
<span class="lineno"> 1716 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VYosysSequential s) = s</span>
<span class="lineno"> 1717 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error (&quot;fromValue YosysSequential: &quot; ++ show v)</span></span></span>
<span class="lineno"> 1718 </span>
<span class="lineno"> 1719 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">IsValue Yo.YosysTheorem</span></span></span></span> where
<span class="lineno"> 1720 </span>  <span class="decl"><span class="istickedoff">toValue _name yt = VYosysTheorem yt</span></span>
<span class="lineno"> 1721 </span>
<span class="lineno"> 1722 </span>instance FromValue Yo.YosysTheorem where
<span class="lineno"> 1723 </span>  <span class="decl"><span class="istickedoff">fromValue _ (VYosysTheorem thm) = thm</span>
<span class="lineno"> 1724 </span><span class="spaces">  </span><span class="istickedoff">fromValue _ v = <span class="nottickedoff">error (&quot;fromValue YosysTheorem: &quot; ++ show v)</span></span></span>
<span class="lineno"> 1725 </span>
<span class="lineno"> 1726 </span>
<span class="lineno"> 1727 </span>------------------------------------------------------------
<span class="lineno"> 1728 </span>-- Primitives
<span class="lineno"> 1729 </span>
<span class="lineno"> 1730 </span>add_primitives :: PrimitiveLifecycle -&gt; BuiltinContext -&gt; Options -&gt; TopLevel ()
<span class="lineno"> 1731 </span><span class="decl"><span class="istickedoff">add_primitives lc _bic _opts = do</span>
<span class="lineno"> 1732 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1733 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw {</span>
<span class="lineno"> 1734 </span><span class="spaces">    </span><span class="istickedoff">rwPrimsAvail = Set.insert lc (rwPrimsAvail rw)</span>
<span class="lineno"> 1735 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1736 </span>
<span class="lineno"> 1737 </span>-- The subshell command.
<span class="lineno"> 1738 </span>--
<span class="lineno"> 1739 </span>-- The SubshellHook is an IO action that takes interpreter state and
<span class="lineno"> 1740 </span>-- runs the REPL. (Because it recurses back into the repl, it has to
<span class="lineno"> 1741 </span>-- be passed down to us as a closure; it's stored in TopLevelRO while
<span class="lineno"> 1742 </span>-- we execute.)
<span class="lineno"> 1743 </span>--
<span class="lineno"> 1744 </span>-- This function is bound into the interpreter with `pureVal`, which
<span class="lineno"> 1745 </span>-- means the returned TopLevel action gets wrapped in a `Value` and is
<span class="lineno"> 1746 </span>-- not bound into the Haskell-level monad sequencing until the
<span class="lineno"> 1747 </span>-- interpreter unwraps it. (That happens when the value is monad-bound
<span class="lineno"> 1748 </span>-- in SAWScript and not, in particular, just when the () is applied to
<span class="lineno"> 1749 </span>-- the SAWScript name &quot;subshell&quot;.)
<span class="lineno"> 1750 </span>--
<span class="lineno"> 1751 </span>-- This should prevent former weirdnesses like x not appearing in the
<span class="lineno"> 1752 </span>-- subshell context in:
<span class="lineno"> 1753 </span>--
<span class="lineno"> 1754 </span>--    do { let s = subshell (); let x = 3; s; return (); };
<span class="lineno"> 1755 </span>--
<span class="lineno"> 1756 </span>-- because the TopLevelRW got fetched at the wrong point.
<span class="lineno"> 1757 </span>--
<span class="lineno"> 1758 </span>-- But note that because the SAWScript interpreter is very fragile it
<span class="lineno"> 1759 </span>-- is very easy for these things to regress.
<span class="lineno"> 1760 </span>--
<span class="lineno"> 1761 </span>toplevelSubshell :: () -&gt; TopLevel Value
<span class="lineno"> 1762 </span><span class="decl"><span class="istickedoff">toplevelSubshell () = do</span>
<span class="lineno"> 1763 </span><span class="spaces">    </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1764 </span><span class="spaces">    </span><span class="istickedoff">ro &lt;- ask</span>
<span class="lineno"> 1765 </span><span class="spaces">    </span><span class="istickedoff">rw &lt;- get</span>
<span class="lineno"> 1766 </span><span class="spaces">    </span><span class="istickedoff">let hook = roSubshell ro</span>
<span class="lineno"> 1767 </span><span class="spaces">    </span><span class="istickedoff">rw' &lt;- liftIO $ hook ro rw</span>
<span class="lineno"> 1768 </span><span class="spaces">    </span><span class="istickedoff">put rw'</span>
<span class="lineno"> 1769 </span><span class="spaces">    </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1770 </span><span class="spaces">    </span><span class="istickedoff">return $ <span class="nottickedoff">toValue &quot;subshell&quot; ()</span></span></span>
<span class="lineno"> 1771 </span>
<span class="lineno"> 1772 </span>-- The proof_subshell command.
<span class="lineno"> 1773 </span>--
<span class="lineno"> 1774 </span>-- Much the same as an ordinary subshell, except it runs in the
<span class="lineno"> 1775 </span>-- ProofScript monad and handles the additional ProofScript state.
<span class="lineno"> 1776 </span>--
<span class="lineno"> 1777 </span>proofScriptSubshell :: () -&gt; ProofScript Value
<span class="lineno"> 1778 </span><span class="decl"><span class="istickedoff">proofScriptSubshell () = do</span>
<span class="lineno"> 1779 </span><span class="spaces">    </span><span class="istickedoff">(ro, rw) &lt;- scriptTopLevel $ do</span>
<span class="lineno"> 1780 </span><span class="spaces">        </span><span class="istickedoff">pushScope</span>
<span class="lineno"> 1781 </span><span class="spaces">        </span><span class="istickedoff">ro_ &lt;- ask</span>
<span class="lineno"> 1782 </span><span class="spaces">        </span><span class="istickedoff">rw_ &lt;- get</span>
<span class="lineno"> 1783 </span><span class="spaces">        </span><span class="istickedoff">return (ro_, rw_)</span>
<span class="lineno"> 1784 </span><span class="spaces">    </span><span class="istickedoff">pst &lt;- get</span>
<span class="lineno"> 1785 </span><span class="spaces">    </span><span class="istickedoff">let hook = roProofSubshell ro</span>
<span class="lineno"> 1786 </span><span class="spaces">    </span><span class="istickedoff">(rw', pst') &lt;- liftIO $ hook ro rw pst</span>
<span class="lineno"> 1787 </span><span class="spaces">    </span><span class="istickedoff">put pst'</span>
<span class="lineno"> 1788 </span><span class="spaces">    </span><span class="istickedoff">scriptTopLevel $ do</span>
<span class="lineno"> 1789 </span><span class="spaces">        </span><span class="istickedoff">put rw'</span>
<span class="lineno"> 1790 </span><span class="spaces">        </span><span class="istickedoff">popScope</span>
<span class="lineno"> 1791 </span><span class="spaces">    </span><span class="istickedoff">return $ <span class="nottickedoff">toValue &quot;proof_subshell&quot; ()</span></span></span>
<span class="lineno"> 1792 </span>
<span class="lineno"> 1793 </span>-- The &quot;for&quot; builtin.
<span class="lineno"> 1794 </span>--
<span class="lineno"> 1795 </span>-- XXX: this is the only thing in the tree that uses VBindOnce.
<span class="lineno"> 1796 </span>-- Unfortunately, for the time being it needs to be this way:
<span class="lineno"> 1797 </span>--    - as a builtin it can only operate in Value;
<span class="lineno"> 1798 </span>--    - VDo contains abstract syntax;
<span class="lineno"> 1799 </span>--    - there is no way to lift an arbitrary Value into the abstract
<span class="lineno"> 1800 </span>--      syntax, and there won't be anytime soon, because there's
<span class="lineno"> 1801 </span>--      already enough of a tangle with Value and the interpreter
<span class="lineno"> 1802 </span>--      state without also including the entire abstract syntax in
<span class="lineno"> 1803 </span>--      the yarn ball;
<span class="lineno"> 1804 </span>--    - it needs to be able to do SAWScript-level binds and those
<span class="lineno"> 1805 </span>--      are the only ways.
<span class="lineno"> 1806 </span>--
<span class="lineno"> 1807 </span>-- Probably the best long-term solution is to move the implementation
<span class="lineno"> 1808 </span>-- into the SAWScript prelude, once we have one (see #253; that
<span class="lineno"> 1809 </span>-- issue's been open a long time), since the only thing stopping that
<span class="lineno"> 1810 </span>-- is having a place to put the code.
<span class="lineno"> 1811 </span>--
<span class="lineno"> 1812 </span>-- Failing that, at some point the SAWScript interpreter will
<span class="lineno"> 1813 </span>-- hopefully have been cleaned up to the point where there's a Value
<span class="lineno"> 1814 </span>-- case in the abstract syntax, which there properly speaking should
<span class="lineno"> 1815 </span>-- be anyway, at which point this can be rewritten with VDo.
<span class="lineno"> 1816 </span>--
<span class="lineno"> 1817 </span>-- Failing _that_, it's probably possible to open-code the bind here
<span class="lineno"> 1818 </span>-- in terms of calling pieces of the interpreter directly, but that's
<span class="lineno"> 1819 </span>-- likely to be quite messy.
<span class="lineno"> 1820 </span>--
<span class="lineno"> 1821 </span>forValue :: [Value] -&gt; Value -&gt; TopLevel Value
<span class="lineno"> 1822 </span><span class="decl"><span class="istickedoff">forValue [] _ = return $ VReturn <span class="nottickedoff">atRestPos</span> [] (VArray [])</span>
<span class="lineno"> 1823 </span><span class="spaces"></span><span class="istickedoff">forValue (x : xs) f = do</span>
<span class="lineno"> 1824 </span><span class="spaces">   </span><span class="istickedoff">let pos = SS.PosInsideBuiltin</span>
<span class="lineno"> 1825 </span><span class="spaces">   </span><span class="istickedoff">m1 &lt;- applyValue pos <span class="nottickedoff">&quot;(value was in a \&quot;for\&quot;)&quot;</span> f x</span>
<span class="lineno"> 1826 </span><span class="spaces">   </span><span class="istickedoff">m2 &lt;- forValue xs f</span>
<span class="lineno"> 1827 </span><span class="spaces">   </span><span class="istickedoff">return $ VBindOnce pos [] m1 $ VBuiltin &quot;for&quot; <span class="nottickedoff">Seq.empty</span> $ OneMoreArg $ \v1 -&gt;</span>
<span class="lineno"> 1828 </span><span class="spaces">     </span><span class="istickedoff">return $ VBindOnce <span class="nottickedoff">pos</span> [] m2 $ VBuiltin <span class="nottickedoff">&quot;for&quot;</span> <span class="nottickedoff">Seq.empty</span> $ OneMoreArg $ \v2 -&gt;</span>
<span class="lineno"> 1829 </span><span class="spaces">       </span><span class="istickedoff">return $ VReturn <span class="nottickedoff">atRestPos</span> [] (VArray (v1 : fromValue <span class="nottickedoff">FromArgument</span> v2))</span></span>
<span class="lineno"> 1830 </span>
<span class="lineno"> 1831 </span>caseProofResultPrim ::
<span class="lineno"> 1832 </span>  ProofResult -&gt;
<span class="lineno"> 1833 </span>  Value {- ^ valid case -} -&gt;
<span class="lineno"> 1834 </span>  Value {- ^ invalid/unknown case -} -&gt;
<span class="lineno"> 1835 </span>  TopLevel Value
<span class="lineno"> 1836 </span><span class="decl"><span class="istickedoff">caseProofResultPrim pr vValid vInvalid = do</span>
<span class="lineno"> 1837 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">infoValid = &quot;(value was the valid case of caseProofResult)&quot;</span></span>
<span class="lineno"> 1838 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">infoInvalid = &quot;(value was the invalid case of caseProofResult)&quot;</span></span>
<span class="lineno"> 1839 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1840 </span><span class="spaces">  </span><span class="istickedoff">-- This is a builtin; we can use the posted global position</span>
<span class="lineno"> 1841 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno"> 1842 </span><span class="spaces">  </span><span class="istickedoff">case pr of</span>
<span class="lineno"> 1843 </span><span class="spaces">    </span><span class="istickedoff">ValidProof _ thm -&gt;</span>
<span class="lineno"> 1844 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">infoValid</span> vValid (VTheorem thm)</span>
<span class="lineno"> 1845 </span><span class="spaces">    </span><span class="istickedoff">InvalidProof _ pairs _pst -&gt; do</span>
<span class="lineno"> 1846 </span><span class="spaces">      </span><span class="istickedoff">let fov = FOVTuple (map snd pairs)</span>
<span class="lineno"> 1847 </span><span class="spaces">      </span><span class="istickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc fov</span>
<span class="lineno"> 1848 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">infoInvalid</span> vInvalid (VTerm tt)</span>
<span class="lineno"> 1849 </span><span class="spaces">    </span><span class="istickedoff">UnfinishedProof _ -&gt; do</span>
<span class="lineno"> 1850 </span><span class="spaces">      </span><span class="istickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc (FOVTuple [])</span>
<span class="lineno"> 1851 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">infoInvalid</span> vInvalid (VTerm tt)</span></span>
<span class="lineno"> 1852 </span>
<span class="lineno"> 1853 </span>caseSatResultPrim ::
<span class="lineno"> 1854 </span>  SatResult -&gt;
<span class="lineno"> 1855 </span>  Value {- ^ unsat case -} -&gt;
<span class="lineno"> 1856 </span>  Value {- ^ sat/unknown case -} -&gt;
<span class="lineno"> 1857 </span>  TopLevel Value
<span class="lineno"> 1858 </span><span class="decl"><span class="istickedoff">caseSatResultPrim sr vUnsat vSat = do</span>
<span class="lineno"> 1859 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">info = &quot;(value was the sat case of caseSatResult)&quot;</span></span>
<span class="lineno"> 1860 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1861 </span><span class="spaces">  </span><span class="istickedoff">-- This is a builtin; we can use the posted global position</span>
<span class="lineno"> 1862 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno"> 1863 </span><span class="spaces">  </span><span class="istickedoff">case sr of</span>
<span class="lineno"> 1864 </span><span class="spaces">    </span><span class="istickedoff">Unsat _ -&gt; return vUnsat</span>
<span class="lineno"> 1865 </span><span class="spaces">    </span><span class="istickedoff">Sat _ pairs -&gt; do</span>
<span class="lineno"> 1866 </span><span class="spaces">      </span><span class="istickedoff">let fov = FOVTuple (map snd pairs)</span>
<span class="lineno"> 1867 </span><span class="spaces">      </span><span class="istickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc fov</span>
<span class="lineno"> 1868 </span><span class="spaces">      </span><span class="istickedoff">applyValue <span class="nottickedoff">pos</span> <span class="nottickedoff">info</span> vSat (VTerm tt)</span>
<span class="lineno"> 1869 </span><span class="spaces">    </span><span class="istickedoff">SatUnknown -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 1870 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let fov = FOVTuple []</span></span>
<span class="lineno"> 1871 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">tt &lt;- io $ typedTermOfFirstOrderValue sc fov</span></span>
<span class="lineno"> 1872 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">applyValue pos info vSat (VTerm tt)</span></span></span>
<span class="lineno"> 1873 </span>
<span class="lineno"> 1874 </span>print_stack :: TopLevel ()
<span class="lineno"> 1875 </span><span class="decl"><span class="istickedoff">print_stack = do</span>
<span class="lineno"> 1876 </span><span class="spaces">  </span><span class="istickedoff">-- We are inside a builtin here, namely print_stack.</span>
<span class="lineno"> 1877 </span><span class="spaces">  </span><span class="istickedoff">let pos = SS.PosInsideBuiltin</span>
<span class="lineno"> 1878 </span><span class="spaces">  </span><span class="istickedoff">trace &lt;- getStackTrace</span>
<span class="lineno"> 1879 </span><span class="spaces">  </span><span class="istickedoff">let trace' = Trace.ppTrace trace pos</span>
<span class="lineno"> 1880 </span><span class="spaces">  </span><span class="istickedoff">io $ TextIO.putStrLn &quot;Stack trace:&quot;</span>
<span class="lineno"> 1881 </span><span class="spaces">  </span><span class="istickedoff">io $ TextIO.putStrLn trace'</span></span>
<span class="lineno"> 1882 </span>
<span class="lineno"> 1883 </span>proof_stack :: ProofScript ()
<span class="lineno"> 1884 </span><span class="decl"><span class="istickedoff">proof_stack = scriptTopLevel print_stack</span></span>
<span class="lineno"> 1885 </span>
<span class="lineno"> 1886 </span>llvm_stack :: LLVMCrucibleSetupM ()
<span class="lineno"> 1887 </span><span class="decl"><span class="istickedoff">llvm_stack = llvmTopLevel print_stack</span></span>
<span class="lineno"> 1888 </span>
<span class="lineno"> 1889 </span>jvm_stack :: JVMSetupM ()
<span class="lineno"> 1890 </span><span class="decl"><span class="nottickedoff">jvm_stack = jvmTopLevel print_stack</span></span>
<span class="lineno"> 1891 </span>
<span class="lineno"> 1892 </span>mir_stack :: MIRSetupM ()
<span class="lineno"> 1893 </span><span class="decl"><span class="nottickedoff">mir_stack = mirTopLevel print_stack</span></span>
<span class="lineno"> 1894 </span>
<span class="lineno"> 1895 </span>enable_safety_proofs :: TopLevel ()
<span class="lineno"> 1896 </span><span class="decl"><span class="nottickedoff">enable_safety_proofs = do</span>
<span class="lineno"> 1897 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1898 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSkipSafetyProofs = False }</span></span>
<span class="lineno"> 1899 </span>
<span class="lineno"> 1900 </span>disable_safety_proofs :: TopLevel ()
<span class="lineno"> 1901 </span><span class="decl"><span class="nottickedoff">disable_safety_proofs = do</span>
<span class="lineno"> 1902 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1903 </span><span class="spaces">  </span><span class="nottickedoff">io $ printOutLn opts Warn &quot;Safety proofs disabled! This is unsound!&quot;</span>
<span class="lineno"> 1904 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1905 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSkipSafetyProofs = True }</span></span>
<span class="lineno"> 1906 </span>
<span class="lineno"> 1907 </span>enable_sequent_goals :: TopLevel ()
<span class="lineno"> 1908 </span><span class="decl"><span class="nottickedoff">enable_sequent_goals = do</span>
<span class="lineno"> 1909 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1910 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSequentGoals = True }</span></span>
<span class="lineno"> 1911 </span>
<span class="lineno"> 1912 </span>disable_sequent_goals :: TopLevel ()
<span class="lineno"> 1913 </span><span class="decl"><span class="nottickedoff">disable_sequent_goals = do</span>
<span class="lineno"> 1914 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1915 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSequentGoals = False }</span></span>
<span class="lineno"> 1916 </span>
<span class="lineno"> 1917 </span>enable_smt_array_memory_model :: TopLevel ()
<span class="lineno"> 1918 </span><span class="decl"><span class="istickedoff">enable_smt_array_memory_model = do</span>
<span class="lineno"> 1919 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1920 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwSMTArrayMemoryModel = True }</span></span>
<span class="lineno"> 1921 </span>
<span class="lineno"> 1922 </span>disable_smt_array_memory_model :: TopLevel ()
<span class="lineno"> 1923 </span><span class="decl"><span class="nottickedoff">disable_smt_array_memory_model = do</span>
<span class="lineno"> 1924 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1925 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSMTArrayMemoryModel = False }</span></span>
<span class="lineno"> 1926 </span>
<span class="lineno"> 1927 </span>enable_crucible_assert_then_assume :: TopLevel ()
<span class="lineno"> 1928 </span><span class="decl"><span class="istickedoff">enable_crucible_assert_then_assume = do</span>
<span class="lineno"> 1929 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1930 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwCrucibleAssertThenAssume = True }</span></span>
<span class="lineno"> 1931 </span>
<span class="lineno"> 1932 </span>disable_crucible_assert_then_assume :: TopLevel ()
<span class="lineno"> 1933 </span><span class="decl"><span class="istickedoff">disable_crucible_assert_then_assume = do</span>
<span class="lineno"> 1934 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1935 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwCrucibleAssertThenAssume = False }</span></span>
<span class="lineno"> 1936 </span>
<span class="lineno"> 1937 </span>enable_single_override_special_case :: TopLevel ()
<span class="lineno"> 1938 </span><span class="decl"><span class="nottickedoff">enable_single_override_special_case = do</span>
<span class="lineno"> 1939 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1940 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSingleOverrideSpecialCase = True }</span></span>
<span class="lineno"> 1941 </span>
<span class="lineno"> 1942 </span>disable_single_override_special_case :: TopLevel ()
<span class="lineno"> 1943 </span><span class="decl"><span class="nottickedoff">disable_single_override_special_case = do</span>
<span class="lineno"> 1944 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1945 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSingleOverrideSpecialCase = False }</span></span>
<span class="lineno"> 1946 </span>
<span class="lineno"> 1947 </span>
<span class="lineno"> 1948 </span>enable_crucible_profiling :: Text -&gt; TopLevel ()
<span class="lineno"> 1949 </span><span class="decl"><span class="istickedoff">enable_crucible_profiling f = do</span>
<span class="lineno"> 1950 </span><span class="spaces">  </span><span class="istickedoff">let f' :: FilePath = Text.unpack f</span>
<span class="lineno"> 1951 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1952 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwProfilingFile = Just f' }</span></span>
<span class="lineno"> 1953 </span>
<span class="lineno"> 1954 </span>disable_crucible_profiling :: TopLevel ()
<span class="lineno"> 1955 </span><span class="decl"><span class="istickedoff">disable_crucible_profiling = do</span>
<span class="lineno"> 1956 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1957 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwProfilingFile = <span class="nottickedoff">Nothing</span> }</span></span>
<span class="lineno"> 1958 </span>
<span class="lineno"> 1959 </span>enable_lax_arithmetic :: TopLevel ()
<span class="lineno"> 1960 </span><span class="decl"><span class="nottickedoff">enable_lax_arithmetic = do</span>
<span class="lineno"> 1961 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1962 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxArith = True }</span></span>
<span class="lineno"> 1963 </span>
<span class="lineno"> 1964 </span>disable_lax_arithmetic :: TopLevel ()
<span class="lineno"> 1965 </span><span class="decl"><span class="nottickedoff">disable_lax_arithmetic = do</span>
<span class="lineno"> 1966 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1967 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxArith = False }</span></span>
<span class="lineno"> 1968 </span>
<span class="lineno"> 1969 </span>enable_lax_pointer_ordering :: TopLevel ()
<span class="lineno"> 1970 </span><span class="decl"><span class="istickedoff">enable_lax_pointer_ordering = do</span>
<span class="lineno"> 1971 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1972 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwLaxPointerOrdering = True }</span></span>
<span class="lineno"> 1973 </span>
<span class="lineno"> 1974 </span>disable_lax_pointer_ordering :: TopLevel ()
<span class="lineno"> 1975 </span><span class="decl"><span class="nottickedoff">disable_lax_pointer_ordering = do</span>
<span class="lineno"> 1976 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1977 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxPointerOrdering = False }</span></span>
<span class="lineno"> 1978 </span>
<span class="lineno"> 1979 </span>enable_lax_loads_and_stores :: TopLevel ()
<span class="lineno"> 1980 </span><span class="decl"><span class="istickedoff">enable_lax_loads_and_stores = do</span>
<span class="lineno"> 1981 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1982 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwLaxLoadsAndStores = True }</span></span>
<span class="lineno"> 1983 </span>
<span class="lineno"> 1984 </span>disable_lax_loads_and_stores :: TopLevel ()
<span class="lineno"> 1985 </span><span class="decl"><span class="nottickedoff">disable_lax_loads_and_stores = do</span>
<span class="lineno"> 1986 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1987 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxLoadsAndStores = False }</span></span>
<span class="lineno"> 1988 </span>
<span class="lineno"> 1989 </span>set_solver_cache_path :: Text -&gt; TopLevel ()
<span class="lineno"> 1990 </span><span class="decl"><span class="istickedoff">set_solver_cache_path pathtxt = do</span>
<span class="lineno"> 1991 </span><span class="spaces">  </span><span class="istickedoff">let path :: FilePath = Text.unpack pathtxt</span>
<span class="lineno"> 1992 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 1993 </span><span class="spaces">  </span><span class="istickedoff">case rwSolverCache rw of</span>
<span class="lineno"> 1994 </span><span class="spaces">    </span><span class="istickedoff">Just _ -&gt; onSolverCache (setSolverCachePath path)</span>
<span class="lineno"> 1995 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do cache &lt;- io $ openSolverCache path</span></span>
<span class="lineno"> 1996 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">putTopLevelRW rw { rwSolverCache = Just cache }</span></span></span>
<span class="lineno"> 1997 </span>
<span class="lineno"> 1998 </span>set_solver_cache_timeout :: Int -&gt; TopLevel ()
<span class="lineno"> 1999 </span><span class="decl"><span class="istickedoff">set_solver_cache_timeout tout =</span>
<span class="lineno"> 2000 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (setSolverCacheTimeout tout)</span></span>
<span class="lineno"> 2001 </span>
<span class="lineno"> 2002 </span>clean_mismatched_versions_solver_cache :: TopLevel ()
<span class="lineno"> 2003 </span><span class="decl"><span class="istickedoff">clean_mismatched_versions_solver_cache = do</span>
<span class="lineno"> 2004 </span><span class="spaces">  </span><span class="istickedoff">vs &lt;- io $ getSolverBackendVersions allBackends</span>
<span class="lineno"> 2005 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (cleanMismatchedVersionsSolverCache vs)</span></span>
<span class="lineno"> 2006 </span>
<span class="lineno"> 2007 </span>test_solver_cache_stats :: Integer -&gt; Integer -&gt; Integer -&gt; Integer -&gt;
<span class="lineno"> 2008 </span>                           Integer -&gt; TopLevel ()
<span class="lineno"> 2009 </span><span class="decl"><span class="istickedoff">test_solver_cache_stats sz ls ls_f is is_f =</span>
<span class="lineno"> 2010 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (testSolverCacheStats sz ls ls_f is is_f)</span></span>
<span class="lineno"> 2011 </span>
<span class="lineno"> 2012 </span>enable_debug_intrinsics :: TopLevel ()
<span class="lineno"> 2013 </span><span class="decl"><span class="nottickedoff">enable_debug_intrinsics = do</span>
<span class="lineno"> 2014 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2015 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwDebugIntrinsics = True }</span></span>
<span class="lineno"> 2016 </span>
<span class="lineno"> 2017 </span>disable_debug_intrinsics :: TopLevel ()
<span class="lineno"> 2018 </span><span class="decl"><span class="nottickedoff">disable_debug_intrinsics = do</span>
<span class="lineno"> 2019 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2020 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwDebugIntrinsics = False }</span></span>
<span class="lineno"> 2021 </span>
<span class="lineno"> 2022 </span>enable_what4_hash_consing :: TopLevel ()
<span class="lineno"> 2023 </span><span class="decl"><span class="nottickedoff">enable_what4_hash_consing = do</span>
<span class="lineno"> 2024 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2025 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsing = True }</span></span>
<span class="lineno"> 2026 </span>
<span class="lineno"> 2027 </span>disable_what4_hash_consing :: TopLevel ()
<span class="lineno"> 2028 </span><span class="decl"><span class="nottickedoff">disable_what4_hash_consing = do</span>
<span class="lineno"> 2029 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2030 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsing = False }</span></span>
<span class="lineno"> 2031 </span>
<span class="lineno"> 2032 </span>enable_x86_what4_hash_consing :: TopLevel ()
<span class="lineno"> 2033 </span><span class="decl"><span class="nottickedoff">enable_x86_what4_hash_consing = do</span>
<span class="lineno"> 2034 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2035 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsingX86 = True }</span></span>
<span class="lineno"> 2036 </span>
<span class="lineno"> 2037 </span>disable_x86_what4_hash_consing :: TopLevel ()
<span class="lineno"> 2038 </span><span class="decl"><span class="nottickedoff">disable_x86_what4_hash_consing = do</span>
<span class="lineno"> 2039 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2040 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsingX86 = False }</span></span>
<span class="lineno"> 2041 </span>
<span class="lineno"> 2042 </span>enable_what4_eval :: TopLevel ()
<span class="lineno"> 2043 </span><span class="decl"><span class="istickedoff">enable_what4_eval = do</span>
<span class="lineno"> 2044 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2045 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwWhat4Eval = True }</span></span>
<span class="lineno"> 2046 </span>
<span class="lineno"> 2047 </span>disable_what4_eval :: TopLevel ()
<span class="lineno"> 2048 </span><span class="decl"><span class="nottickedoff">disable_what4_eval = do</span>
<span class="lineno"> 2049 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2050 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4Eval = False }</span></span>
<span class="lineno"> 2051 </span>
<span class="lineno"> 2052 </span>add_x86_preserved_reg :: Text -&gt; TopLevel ()
<span class="lineno"> 2053 </span><span class="decl"><span class="istickedoff">add_x86_preserved_reg r = do</span>
<span class="lineno"> 2054 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2055 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPreservedRegs = r:rwPreservedRegs rw }</span></span>
<span class="lineno"> 2056 </span>
<span class="lineno"> 2057 </span>default_x86_preserved_reg :: TopLevel ()
<span class="lineno"> 2058 </span><span class="decl"><span class="istickedoff">default_x86_preserved_reg = do</span>
<span class="lineno"> 2059 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2060 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPreservedRegs = <span class="nottickedoff">mempty</span> }</span></span>
<span class="lineno"> 2061 </span>
<span class="lineno"> 2062 </span>set_x86_stack_base_align :: Integer -&gt; TopLevel ()
<span class="lineno"> 2063 </span><span class="decl"><span class="nottickedoff">set_x86_stack_base_align a = do</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2065 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwStackBaseAlign = a }</span></span>
<span class="lineno"> 2066 </span>
<span class="lineno"> 2067 </span>default_x86_stack_base_align :: TopLevel ()
<span class="lineno"> 2068 </span><span class="decl"><span class="nottickedoff">default_x86_stack_base_align = do</span>
<span class="lineno"> 2069 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2070 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwStackBaseAlign = defaultStackBaseAlign }</span></span>
<span class="lineno"> 2071 </span>
<span class="lineno"> 2072 </span>enable_alloc_sym_init_check :: TopLevel ()
<span class="lineno"> 2073 </span><span class="decl"><span class="istickedoff">enable_alloc_sym_init_check = do</span>
<span class="lineno"> 2074 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2075 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwAllocSymInitCheck = True }</span></span>
<span class="lineno"> 2076 </span>
<span class="lineno"> 2077 </span>disable_alloc_sym_init_check :: TopLevel ()
<span class="lineno"> 2078 </span><span class="decl"><span class="istickedoff">disable_alloc_sym_init_check = do</span>
<span class="lineno"> 2079 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2080 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwAllocSymInitCheck = False }</span></span>
<span class="lineno"> 2081 </span>
<span class="lineno"> 2082 </span>enable_no_satisfying_write_fresh_constant :: TopLevel ()
<span class="lineno"> 2083 </span><span class="decl"><span class="nottickedoff">enable_no_satisfying_write_fresh_constant = do</span>
<span class="lineno"> 2084 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2085 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwNoSatisfyingWriteFreshConstant = True }</span></span>
<span class="lineno"> 2086 </span>
<span class="lineno"> 2087 </span>disable_no_satisfying_write_fresh_constant :: TopLevel ()
<span class="lineno"> 2088 </span><span class="decl"><span class="nottickedoff">disable_no_satisfying_write_fresh_constant = do</span>
<span class="lineno"> 2089 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2090 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwNoSatisfyingWriteFreshConstant = False }</span></span>
<span class="lineno"> 2091 </span>
<span class="lineno"> 2092 </span>enable_what4_push_mux_ops :: TopLevel ()
<span class="lineno"> 2093 </span><span class="decl"><span class="nottickedoff">enable_what4_push_mux_ops = do</span>
<span class="lineno"> 2094 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2095 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4PushMuxOps = True }</span></span>
<span class="lineno"> 2096 </span>
<span class="lineno"> 2097 </span>disable_what4_push_mux_ops :: TopLevel ()
<span class="lineno"> 2098 </span><span class="decl"><span class="nottickedoff">disable_what4_push_mux_ops = do</span>
<span class="lineno"> 2099 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2100 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4PushMuxOps = False }</span></span>
<span class="lineno"> 2101 </span>
<span class="lineno"> 2102 </span>set_crucible_timeout :: Integer -&gt; TopLevel ()
<span class="lineno"> 2103 </span><span class="decl"><span class="nottickedoff">set_crucible_timeout t = do</span>
<span class="lineno"> 2104 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2105 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwCrucibleTimeout = t }</span></span>
<span class="lineno"> 2106 </span>
<span class="lineno"> 2107 </span>include_value :: Text -&gt; TopLevel ()
<span class="lineno"> 2108 </span><span class="decl"><span class="istickedoff">include_value file = do</span>
<span class="lineno"> 2109 </span><span class="spaces">  </span><span class="istickedoff">let file' :: FilePath = Text.unpack file</span>
<span class="lineno"> 2110 </span><span class="spaces">  </span><span class="istickedoff">interpretFile file' False</span></span>
<span class="lineno"> 2111 </span>
<span class="lineno"> 2112 </span>set_ascii :: Bool -&gt; TopLevel ()
<span class="lineno"> 2113 </span><span class="decl"><span class="nottickedoff">set_ascii b = do</span>
<span class="lineno"> 2114 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2115 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppUseAscii = b } }</span></span>
<span class="lineno"> 2116 </span>
<span class="lineno"> 2117 </span>set_base :: Int -&gt; TopLevel ()
<span class="lineno"> 2118 </span><span class="decl"><span class="istickedoff">set_base b = do</span>
<span class="lineno"> 2119 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2120 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppBase = b } }</span></span>
<span class="lineno"> 2121 </span>
<span class="lineno"> 2122 </span>set_color :: Bool -&gt; TopLevel ()
<span class="lineno"> 2123 </span><span class="decl"><span class="nottickedoff">set_color b = do</span>
<span class="lineno"> 2124 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2125 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 2126 </span><span class="spaces">  </span><span class="nottickedoff">-- Keep color disabled if `--no-color` command-line option is present</span>
<span class="lineno"> 2127 </span><span class="spaces">  </span><span class="nottickedoff">let b' = b &amp;&amp; useColor opts</span>
<span class="lineno"> 2128 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppColor = b' } }</span></span>
<span class="lineno"> 2129 </span>
<span class="lineno"> 2130 </span>set_min_sharing :: Int -&gt; TopLevel ()
<span class="lineno"> 2131 </span><span class="decl"><span class="nottickedoff">set_min_sharing b = do</span>
<span class="lineno"> 2132 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2133 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMinSharing = b } }</span></span>
<span class="lineno"> 2134 </span>
<span class="lineno"> 2135 </span>-- | 'set_memoization_hash i' changes the memoization strategy for terms:
<span class="lineno"> 2136 </span>-- memoization identifiers will include the first 'i' digits of the hash of the
<span class="lineno"> 2137 </span>-- term they memoize. This is useful to help keep memoization identifiers of the
<span class="lineno"> 2138 </span>-- same term as constant as possible across different executions of a proof
<span class="lineno"> 2139 </span>-- script over the course of its development.
<span class="lineno"> 2140 </span>set_memoization_hash :: Int -&gt; TopLevel ()
<span class="lineno"> 2141 </span><span class="decl"><span class="nottickedoff">set_memoization_hash i = do</span>
<span class="lineno"> 2142 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2143 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.Hash i } }</span></span>
<span class="lineno"> 2144 </span>
<span class="lineno"> 2145 </span>-- | 'set_memoization_hash_incremental i' changes the memoization strategy for
<span class="lineno"> 2146 </span>-- terms: memoization identifiers will include the first 'i' digits of the hash
<span class="lineno"> 2147 </span>-- of the term they memoize, as well as the value of a global counter that
<span class="lineno"> 2148 </span>-- increments each time a term is memoized. This is useful to help keep
<span class="lineno"> 2149 </span>-- memoization identifiers of the same term as constant as possible across
<span class="lineno"> 2150 </span>-- different executions of a proof script over the course of its development, as
<span class="lineno"> 2151 </span>-- well as to freshen memoization identifiers in the unlikely case of term hash
<span class="lineno"> 2152 </span>-- collisions.
<span class="lineno"> 2153 </span>set_memoization_hash_incremental :: Int -&gt; TopLevel ()
<span class="lineno"> 2154 </span><span class="decl"><span class="nottickedoff">set_memoization_hash_incremental i = do</span>
<span class="lineno"> 2155 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2156 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.HashIncremental i } }</span></span>
<span class="lineno"> 2157 </span>
<span class="lineno"> 2158 </span>-- | `set_memoization_incremental` changes the memoization strategy for terms:
<span class="lineno"> 2159 </span>-- memoization identifiers will only include the value of a global counter that
<span class="lineno"> 2160 </span>-- increments each time a term is memoized.
<span class="lineno"> 2161 </span>set_memoization_incremental :: TopLevel ()
<span class="lineno"> 2162 </span><span class="decl"><span class="nottickedoff">set_memoization_incremental = do</span>
<span class="lineno"> 2163 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2164 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.Incremental } }</span></span>
<span class="lineno"> 2165 </span>
<span class="lineno"> 2166 </span>print_value :: Value -&gt; TopLevel ()
<span class="lineno"> 2167 </span><span class="decl"><span class="istickedoff">print_value (VString s) = printOutLnTop Info (Text.unpack s)</span>
<span class="lineno"> 2168 </span><span class="spaces"></span><span class="istickedoff">print_value (VTerm t) = do</span>
<span class="lineno"> 2169 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2170 </span><span class="spaces">  </span><span class="istickedoff">cenv &lt;- getCryptolEnv</span>
<span class="lineno"> 2171 </span><span class="spaces">  </span><span class="istickedoff">let cfg = CEnv.meSolverConfig (CEnv.eModuleEnv cenv)</span>
<span class="lineno"> 2172 </span><span class="spaces">  </span><span class="istickedoff">unless (closedTerm (ttTerm t)) $</span>
<span class="lineno"> 2173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail &quot;term contains symbolic variables&quot;</span></span>
<span class="lineno"> 2174 </span><span class="spaces">  </span><span class="istickedoff">sawopts &lt;- getOptions</span>
<span class="lineno"> 2175 </span><span class="spaces">  </span><span class="istickedoff">t' &lt;- io $ defaultTypedTerm sawopts sc cfg t</span>
<span class="lineno"> 2176 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno"> 2177 </span><span class="spaces">  </span><span class="istickedoff">let opts' = V.defaultPPOpts { V.useAscii = PPS.ppUseAscii opts</span>
<span class="lineno"> 2178 </span><span class="spaces">                              </span><span class="istickedoff">, V.useBase = PPS.ppBase opts</span>
<span class="lineno"> 2179 </span><span class="spaces">                              </span><span class="istickedoff">}</span>
<span class="lineno"> 2180 </span><span class="spaces">  </span><span class="istickedoff">evaled_t &lt;- io $ evaluateTypedTerm sc t'</span>
<span class="lineno"> 2181 </span><span class="spaces">  </span><span class="istickedoff">doc &lt;- io $ V.runEval <span class="nottickedoff">mempty</span> (V.ppValue <span class="nottickedoff">V.Concrete</span> opts' evaled_t)</span>
<span class="lineno"> 2182 </span><span class="spaces">  </span><span class="istickedoff">sawOpts &lt;- getOptions</span>
<span class="lineno"> 2183 </span><span class="spaces">  </span><span class="istickedoff">io (rethrowEvalError $ printOutLn sawOpts Info $ show $ doc)</span>
<span class="lineno"> 2184 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2185 </span><span class="spaces"></span><span class="istickedoff">print_value v = do</span>
<span class="lineno"> 2186 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno"> 2187 </span><span class="spaces">  </span><span class="istickedoff">nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span>
<span class="lineno"> 2188 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info (showsPrecValue opts nenv <span class="nottickedoff">0</span> v &quot;&quot;)</span></span>
<span class="lineno"> 2189 </span>
<span class="lineno"> 2190 </span>dump_file_AST :: BuiltinContext -&gt; Options -&gt; Text -&gt; IO ()
<span class="lineno"> 2191 </span><span class="decl"><span class="istickedoff">dump_file_AST _bic opts filetxt = do</span>
<span class="lineno"> 2192 </span><span class="spaces">    </span><span class="istickedoff">let file = Text.unpack filetxt</span>
<span class="lineno"> 2193 </span><span class="spaces">    </span><span class="istickedoff">errs_or_stmts &lt;- Loader.findAndLoadFileUnchecked opts file</span>
<span class="lineno"> 2194 </span><span class="spaces">    </span><span class="istickedoff">case errs_or_stmts of</span>
<span class="lineno"> 2195 </span><span class="spaces">        </span><span class="istickedoff">Left errs -&gt;</span>
<span class="lineno"> 2196 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">X.throwIO $ userError $ Text.unpack $ Text.unlines errs</span></span>
<span class="lineno"> 2197 </span><span class="spaces">        </span><span class="istickedoff">Right stmts -&gt;</span>
<span class="lineno"> 2198 </span><span class="spaces">            </span><span class="istickedoff">mapM_ print stmts</span></span>
<span class="lineno"> 2199 </span>
<span class="lineno"> 2200 </span>parser_printer_roundtrip :: BuiltinContext -&gt; Options -&gt; Text -&gt; IO ()
<span class="lineno"> 2201 </span><span class="decl"><span class="istickedoff">parser_printer_roundtrip _bic opts filetxt = do</span>
<span class="lineno"> 2202 </span><span class="spaces">    </span><span class="istickedoff">let file = Text.unpack filetxt</span>
<span class="lineno"> 2203 </span><span class="spaces">    </span><span class="istickedoff">errs_or_stmts &lt;- Loader.findAndLoadFileUnchecked opts file</span>
<span class="lineno"> 2204 </span><span class="spaces">    </span><span class="istickedoff">case errs_or_stmts of</span>
<span class="lineno"> 2205 </span><span class="spaces">        </span><span class="istickedoff">Left errs -&gt;</span>
<span class="lineno"> 2206 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">X.throwIO $ userError $ Text.unpack $ Text.unlines errs</span></span>
<span class="lineno"> 2207 </span><span class="spaces">        </span><span class="istickedoff">Right stmts -&gt;</span>
<span class="lineno"> 2208 </span><span class="spaces">            </span><span class="istickedoff">PP.putDoc $ SS.prettyWholeModule stmts</span></span>
<span class="lineno"> 2209 </span>
<span class="lineno"> 2210 </span>exec :: Text -&gt; [Text] -&gt; Text -&gt; IO Text
<span class="lineno"> 2211 </span><span class="decl"><span class="istickedoff">exec name args input = do</span>
<span class="lineno"> 2212 </span><span class="spaces">  </span><span class="istickedoff">let name' = Text.unpack name</span>
<span class="lineno"> 2213 </span><span class="spaces">      </span><span class="istickedoff">args' = map Text.unpack args</span>
<span class="lineno"> 2214 </span><span class="spaces">      </span><span class="istickedoff">input' = Text.unpack input</span>
<span class="lineno"> 2215 </span><span class="spaces">  </span><span class="istickedoff">output &lt;- readProcess name' args' input'</span>
<span class="lineno"> 2216 </span><span class="spaces">  </span><span class="istickedoff">return $ Text.pack output</span></span>
<span class="lineno"> 2217 </span>
<span class="lineno"> 2218 </span>------------------------------------------------------------
<span class="lineno"> 2219 </span>-- Filename wrappers
<span class="lineno"> 2220 </span>
<span class="lineno"> 2221 </span>-- The interpreter deals only in Text, and FilePath is actually String.
<span class="lineno"> 2222 </span>-- Rather than push Text through the various backend places (which gets
<span class="lineno"> 2223 </span>-- messy) we'll unpack Text to FilePath up front. Or at least until the
<span class="lineno"> 2224 </span>-- stdlib comes up with a Text-based interface for filenames.
<span class="lineno"> 2225 </span>
<span class="lineno"> 2226 </span>-- | Wrapper for writeAIGviaVerilog because the interpreter deals only in
<span class="lineno"> 2227 </span>--   Text and FilePath is actually String.
<span class="lineno"> 2228 </span>doWriteAIGviaVerilog :: Text -&gt; Term -&gt; TopLevel ()
<span class="lineno"> 2229 </span><span class="decl"><span class="nottickedoff">doWriteAIGviaVerilog filetext e =</span>
<span class="lineno"> 2230 </span><span class="spaces">  </span><span class="nottickedoff">let file :: FilePath = Text.unpack filetext in</span>
<span class="lineno"> 2231 </span><span class="spaces">  </span><span class="nottickedoff">writeAIGviaVerilog file e</span></span>
<span class="lineno"> 2232 </span>
<span class="lineno"> 2233 </span>do_offline_aig :: Text -&gt; ProofScript ()
<span class="lineno"> 2234 </span><span class="decl"><span class="nottickedoff">do_offline_aig file =</span>
<span class="lineno"> 2235 </span><span class="spaces">  </span><span class="nottickedoff">offline_aig (Text.unpack file)</span></span>
<span class="lineno"> 2236 </span>
<span class="lineno"> 2237 </span>do_offline_aig_external :: Text -&gt; ProofScript ()
<span class="lineno"> 2238 </span><span class="decl"><span class="nottickedoff">do_offline_aig_external file =</span>
<span class="lineno"> 2239 </span><span class="spaces">  </span><span class="nottickedoff">offline_aig_external (Text.unpack file)</span></span>
<span class="lineno"> 2240 </span>
<span class="lineno"> 2241 </span>do_write_cnf :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2242 </span><span class="decl"><span class="istickedoff">do_write_cnf f tt =</span>
<span class="lineno"> 2243 </span><span class="spaces">  </span><span class="istickedoff">write_cnf (Text.unpack f) tt</span></span>
<span class="lineno"> 2244 </span>
<span class="lineno"> 2245 </span>do_write_cnf_external :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2246 </span><span class="decl"><span class="nottickedoff">do_write_cnf_external f tt =</span>
<span class="lineno"> 2247 </span><span class="spaces">  </span><span class="nottickedoff">write_cnf_external (Text.unpack f) tt</span></span>
<span class="lineno"> 2248 </span>
<span class="lineno"> 2249 </span>do_write_smtlib2 :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2250 </span><span class="decl"><span class="istickedoff">do_write_smtlib2 f tt =</span>
<span class="lineno"> 2251 </span><span class="spaces">  </span><span class="istickedoff">write_smtlib2 (Text.unpack f) tt</span></span>
<span class="lineno"> 2252 </span>
<span class="lineno"> 2253 </span>do_write_smtlib2_w4 :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2254 </span><span class="decl"><span class="nottickedoff">do_write_smtlib2_w4 f tt =</span>
<span class="lineno"> 2255 </span><span class="spaces">  </span><span class="nottickedoff">write_smtlib2_w4 (Text.unpack f) tt</span></span>
<span class="lineno"> 2256 </span>
<span class="lineno"> 2257 </span>do_write_core :: Text -&gt; Term -&gt; TopLevel ()
<span class="lineno"> 2258 </span><span class="decl"><span class="istickedoff">do_write_core f t =</span>
<span class="lineno"> 2259 </span><span class="spaces">  </span><span class="istickedoff">writeCore (Text.unpack f) t</span></span>
<span class="lineno"> 2260 </span>
<span class="lineno"> 2261 </span>do_write_verilog :: SharedContext -&gt; Text -&gt; Term -&gt; IO ()
<span class="lineno"> 2262 </span><span class="decl"><span class="nottickedoff">do_write_verilog sc f t =</span>
<span class="lineno"> 2263 </span><span class="spaces">  </span><span class="nottickedoff">writeVerilog sc (Text.unpack f) t</span></span>
<span class="lineno"> 2264 </span>
<span class="lineno"> 2265 </span>do_write_coq_term :: Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; Text -&gt; Term -&gt; TopLevel ()
<span class="lineno"> 2266 </span><span class="decl"><span class="nottickedoff">do_write_coq_term name notations skips path t =</span>
<span class="lineno"> 2267 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqTerm name notations skips (Text.unpack path) t</span></span>
<span class="lineno"> 2268 </span>
<span class="lineno"> 2269 </span>do_write_coq_cryptol_module :: Text -&gt; Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; TopLevel ()
<span class="lineno"> 2270 </span><span class="decl"><span class="nottickedoff">do_write_coq_cryptol_module infile outfile notations skips =</span>
<span class="lineno"> 2271 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqCryptolModule (Text.unpack infile) (Text.unpack outfile) notations skips</span></span>
<span class="lineno"> 2272 </span>
<span class="lineno"> 2273 </span>do_write_coq_sawcore_prelude :: Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; IO ()
<span class="lineno"> 2274 </span><span class="decl"><span class="nottickedoff">do_write_coq_sawcore_prelude outfile notations skips =</span>
<span class="lineno"> 2275 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqSAWCorePrelude (Text.unpack outfile) notations skips</span></span>
<span class="lineno"> 2276 </span>
<span class="lineno"> 2277 </span>do_write_coq_cryptol_primitives_for_sawcore :: Text -&gt; [(Text, Text)] -&gt; [Text] -&gt; IO ()
<span class="lineno"> 2278 </span><span class="decl"><span class="nottickedoff">do_write_coq_cryptol_primitives_for_sawcore cryfile notations skips =</span>
<span class="lineno"> 2279 </span><span class="spaces">  </span><span class="nottickedoff">let cryfile' = Text.unpack cryfile</span>
<span class="lineno"> 2280 </span><span class="spaces">  </span><span class="nottickedoff">in</span>
<span class="lineno"> 2281 </span><span class="spaces">  </span><span class="nottickedoff">writeCoqCryptolPrimitivesForSAWCore cryfile' notations skips</span></span>
<span class="lineno"> 2282 </span>
<span class="lineno"> 2283 </span>do_offline_coq :: Text -&gt; ProofScript ()
<span class="lineno"> 2284 </span><span class="decl"><span class="nottickedoff">do_offline_coq f =</span>
<span class="lineno"> 2285 </span><span class="spaces">  </span><span class="nottickedoff">offline_coq (Text.unpack f)</span></span>
<span class="lineno"> 2286 </span>
<span class="lineno"> 2287 </span>do_auto_match :: Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 2288 </span><span class="decl"><span class="nottickedoff">do_auto_match f1 f2 =</span>
<span class="lineno"> 2289 </span><span class="spaces">  </span><span class="nottickedoff">autoMatch stmtInterpreter (Text.unpack f1) (Text.unpack f2)</span></span>
<span class="lineno"> 2290 </span>
<span class="lineno"> 2291 </span>do_write_goal :: Text -&gt; ProofScript ()
<span class="lineno"> 2292 </span><span class="decl"><span class="nottickedoff">do_write_goal f =</span>
<span class="lineno"> 2293 </span><span class="spaces">  </span><span class="nottickedoff">write_goal (Text.unpack f)</span></span>
<span class="lineno"> 2294 </span>
<span class="lineno"> 2295 </span>do_offline_w4_unint_bitwuzla :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2296 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_bitwuzla unints path =</span>
<span class="lineno"> 2297 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_bitwuzla unints (Text.unpack path)</span></span>
<span class="lineno"> 2298 </span>
<span class="lineno"> 2299 </span>do_offline_w4_unint_z3 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2300 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_z3 unints path =</span>
<span class="lineno"> 2301 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_z3 unints (Text.unpack path)</span></span>
<span class="lineno"> 2302 </span>
<span class="lineno"> 2303 </span>do_offline_w4_unint_cvc4 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2304 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_cvc4 unints path =</span>
<span class="lineno"> 2305 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_cvc4 unints (Text.unpack path)</span></span>
<span class="lineno"> 2306 </span>
<span class="lineno"> 2307 </span>do_offline_w4_unint_cvc5 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2308 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_cvc5 unints path =</span>
<span class="lineno"> 2309 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_cvc5 unints (Text.unpack path)</span></span>
<span class="lineno"> 2310 </span>
<span class="lineno"> 2311 </span>do_offline_w4_unint_yices :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2312 </span><span class="decl"><span class="nottickedoff">do_offline_w4_unint_yices unints path =</span>
<span class="lineno"> 2313 </span><span class="spaces">  </span><span class="nottickedoff">offline_w4_unint_yices unints (Text.unpack path)</span></span>
<span class="lineno"> 2314 </span>
<span class="lineno"> 2315 </span>do_cryptol_load :: (FilePath -&gt; IO BS.ByteString) -&gt; Text -&gt; TopLevel CEnv.ExtCryptolModule
<span class="lineno"> 2316 </span><span class="decl"><span class="istickedoff">do_cryptol_load loader path =</span>
<span class="lineno"> 2317 </span><span class="spaces">  </span><span class="istickedoff">cryptol_load loader (Text.unpack path)</span></span>
<span class="lineno"> 2318 </span>
<span class="lineno"> 2319 </span>do_offline_cnf :: Text -&gt; ProofScript ()
<span class="lineno"> 2320 </span><span class="decl"><span class="istickedoff">do_offline_cnf path =</span>
<span class="lineno"> 2321 </span><span class="spaces">  </span><span class="istickedoff">offline_cnf (Text.unpack path)</span></span>
<span class="lineno"> 2322 </span>
<span class="lineno"> 2323 </span>do_offline_cnf_external :: Text -&gt; ProofScript ()
<span class="lineno"> 2324 </span><span class="decl"><span class="nottickedoff">do_offline_cnf_external path =</span>
<span class="lineno"> 2325 </span><span class="spaces">  </span><span class="nottickedoff">offline_cnf_external (Text.unpack path)</span></span>
<span class="lineno"> 2326 </span>
<span class="lineno"> 2327 </span>do_offline_extcore :: Text -&gt; ProofScript ()
<span class="lineno"> 2328 </span><span class="decl"><span class="nottickedoff">do_offline_extcore path =</span>
<span class="lineno"> 2329 </span><span class="spaces">  </span><span class="nottickedoff">offline_extcore (Text.unpack path)</span></span>
<span class="lineno"> 2330 </span>
<span class="lineno"> 2331 </span>do_offline_smtlib2 :: Text -&gt; ProofScript ()
<span class="lineno"> 2332 </span><span class="decl"><span class="istickedoff">do_offline_smtlib2 path =</span>
<span class="lineno"> 2333 </span><span class="spaces">  </span><span class="istickedoff">offline_smtlib2 (Text.unpack path)</span></span>
<span class="lineno"> 2334 </span>
<span class="lineno"> 2335 </span>do_w4_offline_smtlib2 :: Text -&gt; ProofScript ()
<span class="lineno"> 2336 </span><span class="decl"><span class="nottickedoff">do_w4_offline_smtlib2 path =</span>
<span class="lineno"> 2337 </span><span class="spaces">  </span><span class="nottickedoff">w4_offline_smtlib2 (Text.unpack path)</span></span>
<span class="lineno"> 2338 </span>
<span class="lineno"> 2339 </span>do_offline_unint_smtlib2 :: [Text] -&gt; Text -&gt; ProofScript ()
<span class="lineno"> 2340 </span><span class="decl"><span class="nottickedoff">do_offline_unint_smtlib2 unints path =</span>
<span class="lineno"> 2341 </span><span class="spaces">  </span><span class="nottickedoff">offline_unint_smtlib2 unints (Text.unpack path)</span></span>
<span class="lineno"> 2342 </span>
<span class="lineno"> 2343 </span>do_offline_verilog :: Text -&gt; ProofScript ()
<span class="lineno"> 2344 </span><span class="decl"><span class="nottickedoff">do_offline_verilog path =</span>
<span class="lineno"> 2345 </span><span class="spaces">  </span><span class="nottickedoff">offline_verilog (Text.unpack path)</span></span>
<span class="lineno"> 2346 </span>
<span class="lineno"> 2347 </span>do_cryptol_add_path :: Text -&gt; TopLevel ()
<span class="lineno"> 2348 </span><span class="decl"><span class="nottickedoff">do_cryptol_add_path path =</span>
<span class="lineno"> 2349 </span><span class="spaces">  </span><span class="nottickedoff">cryptol_add_path (Text.unpack path)</span></span>
<span class="lineno"> 2350 </span>
<span class="lineno"> 2351 </span>do_llvm_load_module :: Text -&gt; TopLevel (Some CIR.LLVMModule)
<span class="lineno"> 2352 </span><span class="decl"><span class="istickedoff">do_llvm_load_module path =</span>
<span class="lineno"> 2353 </span><span class="spaces">  </span><span class="istickedoff">llvm_load_module (Text.unpack path)</span></span>
<span class="lineno"> 2354 </span>
<span class="lineno"> 2355 </span>do_llvm_boilerplate :: Text -&gt; ModuleSkeleton -&gt; Bool -&gt; TopLevel ()
<span class="lineno"> 2356 </span><span class="decl"><span class="nottickedoff">do_llvm_boilerplate path mskel builtins =</span>
<span class="lineno"> 2357 </span><span class="spaces">  </span><span class="nottickedoff">llvm_boilerplate (Text.unpack path) mskel builtins</span></span>
<span class="lineno"> 2358 </span>
<span class="lineno"> 2359 </span>do_llvm_verify_x86 ::
<span class="lineno"> 2360 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt;
<span class="lineno"> 2361 </span>    LLVMCrucibleSetupM () -&gt; ProofScript () -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2362 </span><span class="decl"><span class="istickedoff">do_llvm_verify_x86 llvm path nm globsyms checkSat spec ps =</span>
<span class="lineno"> 2363 </span><span class="spaces">  </span><span class="istickedoff">llvm_verify_x86 llvm (Text.unpack path) nm globsyms checkSat spec ps</span></span>
<span class="lineno"> 2364 </span>
<span class="lineno"> 2365 </span>do_llvm_verify_fixpoint_x86 ::
<span class="lineno"> 2366 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt; TypedTerm -&gt;
<span class="lineno"> 2367 </span>    LLVMCrucibleSetupM () -&gt; ProofScript () -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2368 </span><span class="decl"><span class="nottickedoff">do_llvm_verify_fixpoint_x86 llvm path nm globsyms checkSat tt spec ps =</span>
<span class="lineno"> 2369 </span><span class="spaces">  </span><span class="nottickedoff">llvm_verify_fixpoint_x86 llvm (Text.unpack path) nm globsyms checkSat tt spec ps</span></span>
<span class="lineno"> 2370 </span>
<span class="lineno"> 2371 </span>do_llvm_verify_fixpoint_chc_x86 ::
<span class="lineno"> 2372 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt; TypedTerm -&gt;
<span class="lineno"> 2373 </span>  LLVMCrucibleSetupM () -&gt; ProofScript ()  -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2374 </span><span class="decl"><span class="nottickedoff">do_llvm_verify_fixpoint_chc_x86 llvm path nm globsyms checkSat tt spec ps =</span>
<span class="lineno"> 2375 </span><span class="spaces">  </span><span class="nottickedoff">llvm_verify_fixpoint_chc_x86 llvm (Text.unpack path) nm globsyms checkSat tt spec ps</span></span>
<span class="lineno"> 2376 </span>
<span class="lineno"> 2377 </span>do_llvm_verify_x86_with_invariant ::
<span class="lineno"> 2378 </span>  Some CIR.LLVMModule -&gt; Text -&gt; Text -&gt; [(Text, Integer)] -&gt; Bool -&gt;
<span class="lineno"> 2379 </span>  (Text, Integer, TypedTerm)  -&gt;
<span class="lineno"> 2380 </span>  LLVMCrucibleSetupM () -&gt; ProofScript () -&gt; TopLevel (CIR.SomeLLVM CMS.ProvedSpec)
<span class="lineno"> 2381 </span><span class="decl"><span class="nottickedoff">do_llvm_verify_x86_with_invariant llvm path nm globsyms checkSat info spec ps =</span>
<span class="lineno"> 2382 </span><span class="spaces">  </span><span class="nottickedoff">llvm_verify_x86_with_invariant llvm (Text.unpack path) nm globsyms checkSat info spec ps</span></span>
<span class="lineno"> 2383 </span>
<span class="lineno"> 2384 </span>do_mir_load_module :: Text -&gt; TopLevel MIR.RustModule
<span class="lineno"> 2385 </span><span class="decl"><span class="istickedoff">do_mir_load_module file =</span>
<span class="lineno"> 2386 </span><span class="spaces">  </span><span class="istickedoff">mir_load_module (Text.unpack file)</span></span>
<span class="lineno"> 2387 </span>
<span class="lineno"> 2388 </span>do_yosys_import :: Text -&gt; TopLevel TypedTerm
<span class="lineno"> 2389 </span><span class="decl"><span class="istickedoff">do_yosys_import path =</span>
<span class="lineno"> 2390 </span><span class="spaces">  </span><span class="istickedoff">yosys_import (Text.unpack path)</span></span>
<span class="lineno"> 2391 </span>
<span class="lineno"> 2392 </span>do_yosys_import_sequential :: Text -&gt; Text -&gt; TopLevel Yo.YosysSequential
<span class="lineno"> 2393 </span><span class="decl"><span class="istickedoff">do_yosys_import_sequential nm path =</span>
<span class="lineno"> 2394 </span><span class="spaces">  </span><span class="istickedoff">yosys_import_sequential nm (Text.unpack path)</span></span>
<span class="lineno"> 2395 </span>
<span class="lineno"> 2396 </span>do_yosys_verify_sequential_sally :: Yo.YosysSequential -&gt; Text -&gt; TypedTerm -&gt; [Text] -&gt; TopLevel ()
<span class="lineno"> 2397 </span><span class="decl"><span class="istickedoff">do_yosys_verify_sequential_sally s path q fixed =</span>
<span class="lineno"> 2398 </span><span class="spaces">  </span><span class="istickedoff">yosys_verify_sequential_sally s (Text.unpack path) q fixed</span></span>
<span class="lineno"> 2399 </span>
<span class="lineno"> 2400 </span>do_load_sawcore_from_file :: BuiltinContext -&gt; Options -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 2401 </span><span class="decl"><span class="istickedoff">do_load_sawcore_from_file _ _ mod_filename =</span>
<span class="lineno"> 2402 </span><span class="spaces">  </span><span class="istickedoff">load_sawcore_from_file (Text.unpack mod_filename)</span></span>
<span class="lineno"> 2403 </span>
<span class="lineno"> 2404 </span>do_summarize_verification_json :: Text -&gt; TopLevel ()
<span class="lineno"> 2405 </span><span class="decl"><span class="nottickedoff">do_summarize_verification_json fpath =</span>
<span class="lineno"> 2406 </span><span class="spaces">  </span><span class="nottickedoff">summarize_verification_json (Text.unpack fpath)</span></span>
<span class="lineno"> 2407 </span>
<span class="lineno"> 2408 </span>
<span class="lineno"> 2409 </span>------------------------------------------------------------
<span class="lineno"> 2410 </span>-- Primitive tables
<span class="lineno"> 2411 </span>
<span class="lineno"> 2412 </span>data PrimType
<span class="lineno"> 2413 </span>  = PrimType
<span class="lineno"> 2414 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">primTypeType</span></span></span> :: SS.NamedType
<span class="lineno"> 2415 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primTypeLife</span></span></span> :: PrimitiveLifecycle
<span class="lineno"> 2416 </span>    -- FUTURE: add doc strings for these?
<span class="lineno"> 2417 </span>    }
<span class="lineno"> 2418 </span>
<span class="lineno"> 2419 </span>data Primitive
<span class="lineno"> 2420 </span>  = Primitive
<span class="lineno"> 2421 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveType</span></span></span> :: SS.Schema
<span class="lineno"> 2422 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveLife</span></span></span> :: PrimitiveLifecycle
<span class="lineno"> 2423 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">primitiveDoc</span></span></span>  :: [Text]
<span class="lineno"> 2424 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveFn</span></span></span>   :: Options -&gt; BuiltinContext -&gt; Value
<span class="lineno"> 2425 </span>    }
<span class="lineno"> 2426 </span>
<span class="lineno"> 2427 </span>-- | Primitive types, that is, builtin types used by the primitives.
<span class="lineno"> 2428 </span>--
<span class="lineno"> 2429 </span>-- This excludes certain types that are built in more deeply and
<span class="lineno"> 2430 </span>-- appear as entries in @TyCon in AST.hs. Note that those are also
<span class="lineno"> 2431 </span>-- handled as reserved words in the lexer and parser. XXX: and there's
<span class="lineno"> 2432 </span>-- no particular system to which are there and which are here; some of
<span class="lineno"> 2433 </span>-- the ones there have no special syntax or semantics and should
<span class="lineno"> 2434 </span>-- probably be moved here at some point.
<span class="lineno"> 2435 </span>primTypes :: Map SS.Name PrimType
<span class="lineno"> 2436 </span><span class="decl"><span class="istickedoff">primTypes = foldl doadd Map.empty</span>
<span class="lineno"> 2437 </span><span class="spaces">  </span><span class="istickedoff">[ abstype &quot;BisimTheorem&quot; Experimental</span>
<span class="lineno"> 2438 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;CryptolModule&quot; Current</span>
<span class="lineno"> 2439 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;FunctionProfile&quot; Experimental</span>
<span class="lineno"> 2440 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;FunctionSkeleton&quot; Experimental</span>
<span class="lineno"> 2441 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Ghost&quot; Current</span>
<span class="lineno"> 2442 </span><span class="spaces">  </span><span class="istickedoff">, abstype' SS.kindStarToStar &quot;JVMSetup&quot; Current</span>
<span class="lineno"> 2443 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JVMValue&quot; Current</span>
<span class="lineno"> 2444 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JavaClass&quot; Current</span>
<span class="lineno"> 2445 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JavaType&quot; Current</span>
<span class="lineno"> 2446 </span><span class="spaces">  </span><span class="istickedoff">, abstype' SS.kindStarToStar &quot;LLVMSetup&quot; Current</span>
<span class="lineno"> 2447 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMModule&quot; Current</span>
<span class="lineno"> 2448 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMType&quot; Current</span>
<span class="lineno"> 2449 </span><span class="spaces">  </span><span class="istickedoff">, abstype' SS.kindStarToStar &quot;MIRSetup&quot; Current</span>
<span class="lineno"> 2450 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRAdt&quot; Experimental</span>
<span class="lineno"> 2451 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRModule&quot; Experimental</span>
<span class="lineno"> 2452 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRType&quot; Experimental</span>
<span class="lineno"> 2453 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRValue&quot; Experimental</span>
<span class="lineno"> 2454 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;ModuleSkeleton&quot; Experimental</span>
<span class="lineno"> 2455 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;ProofResult&quot; Current</span>
<span class="lineno"> 2456 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SatResult&quot; Current</span>
<span class="lineno"> 2457 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMValue&quot; Current</span>
<span class="lineno"> 2458 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Simpset&quot; Current</span>
<span class="lineno"> 2459 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SkeletonState&quot; Experimental</span>
<span class="lineno"> 2460 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Theorem&quot; Current</span>
<span class="lineno"> 2461 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;YosysSequential&quot; Experimental</span>
<span class="lineno"> 2462 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;YosysTheorem&quot; Experimental</span>
<span class="lineno"> 2463 </span><span class="spaces">  </span><span class="istickedoff">, conctype &quot;SetupValue&quot; &quot;LLVMValue&quot; Current</span>
<span class="lineno"> 2464 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;__DEPRECATED__&quot; HideDeprecated</span>
<span class="lineno"> 2465 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 2466 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2467 </span><span class="spaces">    </span><span class="istickedoff">-- Thread the map through as we add entries so we can</span>
<span class="lineno"> 2468 </span><span class="spaces">    </span><span class="istickedoff">-- use it to check the right hand side of any typedefs.</span>
<span class="lineno"> 2469 </span><span class="spaces">    </span><span class="istickedoff">doadd ::</span>
<span class="lineno"> 2470 </span><span class="spaces">        </span><span class="istickedoff">Map SS.Name PrimType -&gt;</span>
<span class="lineno"> 2471 </span><span class="spaces">        </span><span class="istickedoff">(Map SS.Name PrimType -&gt; (SS.Name, PrimType)) -&gt;</span>
<span class="lineno"> 2472 </span><span class="spaces">        </span><span class="istickedoff">Map SS.Name PrimType</span>
<span class="lineno"> 2473 </span><span class="spaces">    </span><span class="istickedoff">doadd tyenv constructor =</span>
<span class="lineno"> 2474 </span><span class="spaces">        </span><span class="istickedoff">let (name, entry) = constructor tyenv in</span>
<span class="lineno"> 2475 </span><span class="spaces">        </span><span class="istickedoff">Map.insert name entry tyenv</span>
<span class="lineno"> 2476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2477 </span><span class="spaces">    </span><span class="istickedoff">-- abstract type of arbitrary kind</span>
<span class="lineno"> 2478 </span><span class="spaces">    </span><span class="istickedoff">abstype' ::</span>
<span class="lineno"> 2479 </span><span class="spaces">        </span><span class="istickedoff">SS.Kind -&gt; Text -&gt; PrimitiveLifecycle -&gt; Map SS.Name PrimType -&gt;</span>
<span class="lineno"> 2480 </span><span class="spaces">        </span><span class="istickedoff">(SS.Name, PrimType)</span>
<span class="lineno"> 2481 </span><span class="spaces">    </span><span class="istickedoff">abstype' kind name lc _tyenv = (name, info)</span>
<span class="lineno"> 2482 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 2483 </span><span class="spaces">        </span><span class="istickedoff">info = PrimType</span>
<span class="lineno"> 2484 </span><span class="spaces">          </span><span class="istickedoff">{ primTypeType = SS.AbstractType kind</span>
<span class="lineno"> 2485 </span><span class="spaces">          </span><span class="istickedoff">, primTypeLife = lc</span>
<span class="lineno"> 2486 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno"> 2487 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2488 </span><span class="spaces">    </span><span class="istickedoff">-- abstract type of kind *</span>
<span class="lineno"> 2489 </span><span class="spaces">    </span><span class="istickedoff">abstype :: Text -&gt; PrimitiveLifecycle -&gt; Map SS.Name PrimType -&gt; (SS.Name, PrimType)</span>
<span class="lineno"> 2490 </span><span class="spaces">    </span><span class="istickedoff">abstype name lc tyenv = abstype' SS.kindStar name lc <span class="nottickedoff">tyenv</span></span>
<span class="lineno"> 2491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2492 </span><span class="spaces">    </span><span class="istickedoff">-- concrete type (not currently used)</span>
<span class="lineno"> 2493 </span><span class="spaces">    </span><span class="istickedoff">conctype ::</span>
<span class="lineno"> 2494 </span><span class="spaces">        </span><span class="istickedoff">Text -&gt; Text -&gt; PrimitiveLifecycle -&gt; Map SS.Name PrimType -&gt;</span>
<span class="lineno"> 2495 </span><span class="spaces">        </span><span class="istickedoff">(SS.Name, PrimType)</span>
<span class="lineno"> 2496 </span><span class="spaces">    </span><span class="istickedoff">conctype name tystr lc tyenv = (name, info)</span>
<span class="lineno"> 2497 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 2498 </span><span class="spaces">        </span><span class="istickedoff">info = PrimType</span>
<span class="lineno"> 2499 </span><span class="spaces">          </span><span class="istickedoff">{ primTypeType = SS.ConcreteType ty</span>
<span class="lineno"> 2500 </span><span class="spaces">          </span><span class="istickedoff">, primTypeLife = <span class="nottickedoff">lc</span></span>
<span class="lineno"> 2501 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno"> 2502 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">fakeFileName = Text.unpack $ &quot;&lt;definition of builtin type &quot; &lt;&gt; name &lt;&gt; &quot;&gt;&quot;</span></span>
<span class="lineno"> 2503 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2504 </span><span class="spaces">        </span><span class="istickedoff">-- We need a Map Name (PrimitiveLifecycle, NamedType) to feed</span>
<span class="lineno"> 2505 </span><span class="spaces">        </span><span class="istickedoff">-- to readSchemaPure. Construct one from the Map Name PrimType</span>
<span class="lineno"> 2506 </span><span class="spaces">        </span><span class="istickedoff">-- that we've got. FUTURE: there are too many isomorphic types</span>
<span class="lineno"> 2507 </span><span class="spaces">        </span><span class="istickedoff">-- floating around in the builtins handling (not just here)</span>
<span class="lineno"> 2508 </span><span class="spaces">        </span><span class="istickedoff">-- and they should all be simplified away.</span>
<span class="lineno"> 2509 </span><span class="spaces">        </span><span class="istickedoff">tyenv' = Map.map (\pt -&gt; (primTypeLife pt, primTypeType pt)) tyenv</span>
<span class="lineno"> 2510 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2511 </span><span class="spaces">        </span><span class="istickedoff">ty = case Loader.readSchemaPure <span class="nottickedoff">fakeFileName</span> lc tyenv' tystr of</span>
<span class="lineno"> 2512 </span><span class="spaces">            </span><span class="istickedoff">SS.Forall [] ty' -&gt;</span>
<span class="lineno"> 2513 </span><span class="spaces">                </span><span class="istickedoff">ty'</span>
<span class="lineno"> 2514 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 2515 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;primTypes&quot; [</span></span>
<span class="lineno"> 2516 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Builtin typedef &quot; &lt;&gt; name &lt;&gt; &quot; not monomorphic&quot;</span></span>
<span class="lineno"> 2517 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 2518 </span>
<span class="lineno"> 2519 </span>--
<span class="lineno"> 2520 </span>-- Note: the help/doc strings for the primitives should be
<span class="lineno"> 2521 </span>-- formatted to be no more than 64 characters wide. The following
<span class="lineno"> 2522 </span>-- ruler can be used when editing:
<span class="lineno"> 2523 </span>--     ****************************************************************
<span class="lineno"> 2524 </span>--
<span class="lineno"> 2525 </span>
<span class="lineno"> 2526 </span>primitives :: Map SS.Name Primitive
<span class="lineno"> 2527 </span><span class="decl"><span class="istickedoff">primitives = Map.fromList $</span>
<span class="lineno"> 2528 </span><span class="spaces">  </span><span class="istickedoff">[</span>
<span class="lineno"> 2529 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2530 </span><span class="spaces">    </span><span class="istickedoff">-- Constants</span>
<span class="lineno"> 2531 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2532 </span><span class="spaces">    </span><span class="istickedoff">prim &quot;true&quot;                &quot;Bool&quot;</span>
<span class="lineno"> 2533 </span><span class="spaces">    </span><span class="istickedoff">(pureVal True)</span>
<span class="lineno"> 2534 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A boolean value.&quot; ]</span></span>
<span class="lineno"> 2536 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2537 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;false&quot;               &quot;Bool&quot;</span>
<span class="lineno"> 2538 </span><span class="spaces">    </span><span class="istickedoff">(pureVal False)</span>
<span class="lineno"> 2539 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2540 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A boolean value.&quot; ]</span></span>
<span class="lineno"> 2541 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2542 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2543 </span><span class="spaces">    </span><span class="istickedoff">-- Language-level operators</span>
<span class="lineno"> 2544 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2545 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;return&quot;              &quot;{m, a} a -&gt; m a&quot;</span>
<span class="lineno"> 2546 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (\v -&gt; VReturn <span class="nottickedoff">atRestPos</span> [] v))</span>
<span class="lineno"> 2547 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a monadic action that produces a pure value. The code&quot;</span></span>
<span class="lineno"> 2549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   x &lt;- return e;&quot;</span></span>
<span class="lineno"> 2550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will result in the same value being bound to 'x' as the code&quot;</span></span>
<span class="lineno"> 2551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   let x = e;&quot;</span></span>
<span class="lineno"> 2552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;would. Works in any of the SAWScript monads.&quot;</span></span>
<span class="lineno"> 2553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: not a control-flow operator.&quot;</span></span>
<span class="lineno"> 2554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2555 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2556 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;include&quot;             &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2557 </span><span class="spaces">    </span><span class="istickedoff">(pureVal include_value)</span>
<span class="lineno"> 2558 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load and execute the given SAWScript file.&quot; ]</span></span>
<span class="lineno"> 2560 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2561 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;undefined&quot;           &quot;{a} a&quot;</span>
<span class="lineno"> 2562 </span><span class="spaces">    </span><span class="istickedoff">-- In order to work as expected this has to be &quot;error&quot; in place of</span>
<span class="lineno"> 2563 </span><span class="spaces">    </span><span class="istickedoff">-- a Value and not a Value (of whatever kind) wrapping &quot;error&quot;. So</span>
<span class="lineno"> 2564 </span><span class="spaces">    </span><span class="istickedoff">-- there must be no toValue and none of the pureVal/funVal/etc.</span>
<span class="lineno"> 2565 </span><span class="spaces">    </span><span class="istickedoff">-- ops are suitable.</span>
<span class="lineno"> 2566 </span><span class="spaces">    </span><span class="istickedoff">(\_ _ _ -&gt; error &quot;interpret: undefined&quot;)</span>
<span class="lineno"> 2567 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An undefined value. Evaluating 'undefined' makes the program&quot;</span></span>
<span class="lineno"> 2569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;crash. Because it does not actually produce a value, it can have&quot;</span></span>
<span class="lineno"> 2570 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;any type.&quot;</span></span>
<span class="lineno"> 2571 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2572 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2573 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fail&quot; &quot;{a} String -&gt; TopLevel a&quot;</span>
<span class="lineno"> 2574 </span><span class="spaces">    </span><span class="istickedoff">(pureVal failPrim)</span>
<span class="lineno"> 2575 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Fail in the TopLevel monad. This produces the same kind of&quot;</span></span>
<span class="lineno"> 2577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;failure as arbitrary other errors during SAWScript execution.&quot;</span></span>
<span class="lineno"> 2578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Failure in SAWScript is essentially like throwing an exception,&quot;</span></span>
<span class="lineno"> 2580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;but there are limited facilities for dealing with the results.&quot;</span></span>
<span class="lineno"> 2581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;See 'fails'.&quot;</span></span>
<span class="lineno"> 2582 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2583 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2584 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fails&quot;               &quot;{a} TopLevel a -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2585 </span><span class="spaces">    </span><span class="istickedoff">(pureVal failsPrim)</span>
<span class="lineno"> 2586 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2587 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given inner action and convert failure into success.&quot;</span></span>
<span class="lineno"> 2588 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fail if the inner action does NOT raise an exception. This is&quot;</span></span>
<span class="lineno"> 2589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;primarily used for testing, to check that expected failures&quot;</span></span>
<span class="lineno"> 2590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;actually occur.&quot;</span></span>
<span class="lineno"> 2591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: the argument is a monadic action and 'fails' can trap only&quot;</span></span>
<span class="lineno"> 2593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;failures that occur while executing that action. To catch a&quot;</span></span>
<span class="lineno"> 2594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;failure that occurs in non-monadic code, the non-monadic code&quot;</span></span>
<span class="lineno"> 2595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must be wrapped in a do-block. Otherwise it will be evaluated&quot;</span></span>
<span class="lineno"> 2596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the result passed to 'fails' as its argument, so the failure&quot;</span></span>
<span class="lineno"> 2597 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will happen before 'fails' runs. For example,&quot;</span></span>
<span class="lineno"> 2598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   fails (return (nth [] 1))&quot;</span></span>
<span class="lineno"> 2599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;does not trap the out of bounds error, but&quot;</span></span>
<span class="lineno"> 2600 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   fails (do { return (nth [] 1); })&quot;</span></span>
<span class="lineno"> 2601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;does.&quot;</span></span>
<span class="lineno"> 2602 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2603 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2604 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;env&quot;                 &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal envCmd)</span></span>
<span class="lineno"> 2606 </span><span class="spaces">    </span><span class="istickedoff">WarnDeprecated</span>
<span class="lineno"> 2607 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print all SAWScript values in scope.&quot;</span></span>
<span class="lineno"> 2608 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Deprecated; use the :env REPL command instead.&quot;</span></span>
<span class="lineno"> 2609 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be hidden by default in SAW 1.5.&quot;</span></span>
<span class="lineno"> 2611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2612 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2613 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show&quot;                &quot;{a} a -&gt; String&quot;</span>
<span class="lineno"> 2614 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 showPrim)</span>
<span class="lineno"> 2615 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2616 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert the value of the given expression to a string.&quot; ]</span></span>
<span class="lineno"> 2617 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2618 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print&quot;               &quot;{a} a -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2619 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_value)</span>
<span class="lineno"> 2620 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the value of the given expression.&quot; ]</span></span>
<span class="lineno"> 2622 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2623 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;type&quot;                &quot;Term -&gt; Type&quot;</span>
<span class="lineno"> 2624 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 term_type)</span></span>
<span class="lineno"> 2625 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the type of the given term.&quot; ]</span></span>
<span class="lineno"> 2627 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2628 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_type&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2629 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_type)</span>
<span class="lineno"> 2630 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the SAWCore-level type of the given term.&quot;</span></span>
<span class="lineno"> 2632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'print_type t' is thus not equivalent to 'print (type t)'.&quot;</span></span>
<span class="lineno"> 2633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2634 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2635 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;caseSatResult&quot;       &quot;{b} SatResult -&gt; b -&gt; (Term -&gt; b) -&gt; b&quot;</span>
<span class="lineno"> 2636 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 caseSatResultPrim)</span>
<span class="lineno"> 2637 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Branch on the result of SAT solving.&quot;</span></span>
<span class="lineno"> 2639 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2640 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Usage: caseSatResult &lt;unsat-code&gt; &lt;sat-code&gt;&quot;</span></span>
<span class="lineno"> 2641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2642 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For example, given&quot;</span></span>
<span class="lineno"> 2643 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   let notsat = print \&quot;unsat\&quot;;&quot;</span></span>
<span class="lineno"> 2644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   let issat model = do { print \&quot;sat\&quot;; print model; };&quot;</span></span>
<span class="lineno"> 2645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;running&quot;</span></span>
<span class="lineno"> 2646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   r &lt;- sat abc {{ False }}&quot;</span></span>
<span class="lineno"> 2647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   caseSatResult r notsat issat&quot;</span></span>
<span class="lineno"> 2648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will print 'unsat'. Conversely, running&quot;</span></span>
<span class="lineno"> 2649 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   r &lt;- sat abc {{ \\(x : [4]) -&gt; x == 3 }}&quot;</span></span>
<span class="lineno"> 2650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   caseSatResult r notsat issat&quot;</span></span>
<span class="lineno"> 2651 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will print 'sat' and '3'.&quot;</span></span>
<span class="lineno"> 2652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The model value passed to the &lt;sat-code&gt; is a Term containing&quot;</span></span>
<span class="lineno"> 2654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the satisfying assignment of variables returned by the solver;&quot;</span></span>
<span class="lineno"> 2655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it will be a tuple if the formula being checked has more than&quot;</span></span>
<span class="lineno"> 2656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;one input argument. It will be '()' if the solver gave up and&quot;</span></span>
<span class="lineno"> 2657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned 'unknown'.&quot;</span></span>
<span class="lineno"> 2658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2659 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;See 'sat'.&quot;</span></span>
<span class="lineno"> 2660 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2661 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2662 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;caseProofResult&quot;</span>
<span class="lineno"> 2663 </span><span class="spaces">    </span><span class="istickedoff">&quot;{b} ProofResult -&gt; (Theorem -&gt; b) -&gt; (Term -&gt; b) -&gt; b&quot;</span>
<span class="lineno"> 2664 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 caseProofResultPrim)</span>
<span class="lineno"> 2665 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2666 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Branch on the result of proving.&quot;</span></span>
<span class="lineno"> 2667 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Usage: caseProofResult &lt;result&gt; &lt;true-code&gt; &lt;false-code&gt;&quot;</span></span>
<span class="lineno"> 2669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For example, given&quot;</span></span>
<span class="lineno"> 2671 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   let yup thm = do { print \&quot;Proved!\&quot;; print thm; };&quot;</span></span>
<span class="lineno"> 2672 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   let nope cex = do { print \&quot;Counterexample:\&quot;; print cex; };&quot;</span></span>
<span class="lineno"> 2673 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;running&quot;</span></span>
<span class="lineno"> 2674 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   r &lt;- prove abc {{ True }}&quot;</span></span>
<span class="lineno"> 2675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   caseProofResult r yup nope&quot;</span></span>
<span class="lineno"> 2676 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will print 'Proved!' and 'Theorem (EqTrue True)'. Running&quot;</span></span>
<span class="lineno"> 2677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   r &lt;- prove z3 {{ \\(x : [8]) -&gt; (x &lt; 2) || (x &gt; 2) }}&quot;</span></span>
<span class="lineno"> 2678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   caseProofResult r yup nope&quot;</span></span>
<span class="lineno"> 2679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will print 'Counterexample:' and '2'.&quot;</span></span>
<span class="lineno"> 2680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2681 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The 'Theorem' passed to the &lt;true-code&gt; is the SAWScript object&quot;</span></span>
<span class="lineno"> 2682 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;representing the proved theorem, which can then be used in other&quot;</span></span>
<span class="lineno"> 2683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proofs. The 'Term' passed to the &lt;false-code&gt; is the&quot;</span></span>
<span class="lineno"> 2684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;counterexample produced by the solver or proof script. It will&quot;</span></span>
<span class="lineno"> 2685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be a tuple if the proposition has more than one input argument.&quot;</span></span>
<span class="lineno"> 2686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;It will be '()' if the proof failed without generating an&quot;</span></span>
<span class="lineno"> 2687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;explicit counterexample.&quot;</span></span>
<span class="lineno"> 2688 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2689 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;See 'prove'.&quot;</span></span>
<span class="lineno"> 2690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2691 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2692 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_experimental&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2693 </span><span class="spaces">    </span><span class="istickedoff">(bicVal (add_primitives Experimental))</span>
<span class="lineno"> 2694 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the use of experimental commands.&quot; ]</span></span>
<span class="lineno"> 2696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2697 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_deprecated&quot;   &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal (add_primitives HideDeprecated))</span></span>
<span class="lineno"> 2699 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the use of deprecated commands. When commands are first&quot;</span></span>
<span class="lineno"> 2701 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;deprecated they generate warnings. At a later stage they become&quot;</span></span>
<span class="lineno"> 2702 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invisible unless explicitly enabled with this command. The next&quot;</span></span>
<span class="lineno"> 2703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;stage is to remove them entirely. Therefore, the use of this&quot;</span></span>
<span class="lineno"> 2704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;command should always be considered a temporary stopgap until&quot;</span></span>
<span class="lineno"> 2705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;your scripts can be updated.&quot;</span></span>
<span class="lineno"> 2706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2707 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2708 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;subshell&quot;            &quot;() -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2709 </span><span class="spaces">    </span><span class="istickedoff">(pureVal toplevelSubshell)</span>
<span class="lineno"> 2710 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Open an interactive subshell instance nested inside the context&quot;</span></span>
<span class="lineno"> 2712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where 'subshell' was called. The resulting REPL is always&quot;</span></span>
<span class="lineno"> 2713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;interactive on the terminal regardless of whether the parent&quot;</span></span>
<span class="lineno"> 2714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;context was interactive or not.&quot;</span></span>
<span class="lineno"> 2715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Type end-of-file (usually Ctrl-D) or ':q' into your terminal to&quot;</span></span>
<span class="lineno"> 2717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exit the subshell and resume the prior execution.&quot;</span></span>
<span class="lineno"> 2718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that altering any file or files SAW is executing from while&quot;</span></span>
<span class="lineno"> 2720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the subshell will not change the copy SAW has loaded into&quot;</span></span>
<span class="lineno"> 2721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;memory.&quot;</span></span>
<span class="lineno"> 2722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2723 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2724 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_subshell&quot;      &quot;() -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2725 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proofScriptSubshell)</span>
<span class="lineno"> 2726 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Open an interactive subshell instance nested inside the context&quot;</span></span>
<span class="lineno"> 2728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where 'proof_subshell' was called. The resulting REPL is always&quot;</span></span>
<span class="lineno"> 2729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;interactive on the terminal regardless of whether the parent&quot;</span></span>
<span class="lineno"> 2730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;context was interactive or not.&quot;</span></span>
<span class="lineno"> 2731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The subshell runs in proof mode in the 'ProofScript' monad.&quot;</span></span>
<span class="lineno"> 2733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In proof mode, the command prompt changes to 'proof (n)', where&quot;</span></span>
<span class="lineno"> 2735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the 'n' is the number of proof goals remaining.&quot;</span></span>
<span class="lineno"> 2736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'proof_subshell' gives a basic interactive proof environment. It&quot;</span></span>
<span class="lineno"> 2738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allows the user to manually execute proof tactics and examine&quot;</span></span>
<span class="lineno"> 2739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;their effects. Use 'print_goal' to show the current goal. When&quot;</span></span>
<span class="lineno"> 2740 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;one goal is completed, the environment automatically switches to&quot;</span></span>
<span class="lineno"> 2741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the next one. The proof is done when all goals have been proved&quot;</span></span>
<span class="lineno"> 2742 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the number shown in the prompt is 0.&quot;</span></span>
<span class="lineno"> 2743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use :search ProofScript to list the supported proof tactics.&quot;</span></span>
<span class="lineno"> 2745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;It is possible to use 'proof_checkpoint' to save and restore the&quot;</span></span>
<span class="lineno"> 2747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof state and thereby gain a limited ability to undo or back&quot;</span></span>
<span class="lineno"> 2748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;up. Be warned, however, that as of the current writing the&quot;</span></span>
<span class="lineno"> 2749 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;checkpoint facility doesn't work reliably and isn't recommended.&quot;</span></span>
<span class="lineno"> 2750 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2751 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Type end-of-file (usually Ctrl-D) or ':q' into your terminal to&quot;</span></span>
<span class="lineno"> 2752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exit the proof subshell and resume execution.&quot;</span></span>
<span class="lineno"> 2753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2754 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2755 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;dump_file_AST&quot;       &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2756 </span><span class="spaces">    </span><span class="istickedoff">(bicVal dump_file_AST)</span>
<span class="lineno"> 2757 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a SAWScript file and dump an ugly representation of the&quot;</span></span>
<span class="lineno"> 2759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;abstract syntax.&quot;</span></span>
<span class="lineno"> 2760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2761 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2762 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parser_printer_roundtrip&quot;       &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2763 </span><span class="spaces">    </span><span class="istickedoff">(bicVal parser_printer_roundtrip)</span>
<span class="lineno"> 2764 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a SAWScript file and transform the results back to the&quot;</span></span>
<span class="lineno"> 2766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAWScript concrete syntax.&quot;</span></span>
<span class="lineno"> 2767 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2768 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2769 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;run&quot;                 &quot;{a} TopLevel a -&gt; a&quot;</span>
<span class="lineno"> 2770 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (id :: TopLevel Value -&gt; TopLevel Value))</span>
<span class="lineno"> 2771 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a monadic TopLevel computation to produce a value.&quot;</span></span>
<span class="lineno"> 2773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Comparable to 'unsafePerformIO' in Haskell, except somewhat&quot;</span></span>
<span class="lineno"> 2775 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;safer: SAWScript is eagerly evaluated, so the point where 'run'&quot;</span></span>
<span class="lineno"> 2776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;executes is well defined. The ordering of the target action&quot;</span></span>
<span class="lineno"> 2777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;relative to the enclosing TopLevel bound action chain is&quot;</span></span>
<span class="lineno"> 2778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;unspecified but never incoherent.&quot;</span></span>
<span class="lineno"> 2779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2780 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2781 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;checkpoint&quot;          &quot;TopLevel (() -&gt; TopLevel ())&quot;</span>
<span class="lineno"> 2782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal checkpoint)</span></span>
<span class="lineno"> 2783 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Capture the current state of the SAW interpreter, and return a&quot;</span></span>
<span class="lineno"> 2785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;TopLevel monadic action that, if invoked, will reset the state&quot;</span></span>
<span class="lineno"> 2786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the interpreter back to to what it was when 'checkpoint' was&quot;</span></span>
<span class="lineno"> 2787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invoked.&quot;</span></span>
<span class="lineno"> 2788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOTE that this facility is highly experimental and is not&quot;</span></span>
<span class="lineno"> 2790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;particularly reliable. It is intended only for proof development&quot;</span></span>
<span class="lineno"> 2791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where it can speed up the process of experimenting with mid-&quot;</span></span>
<span class="lineno"> 2792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof changes. Finalized proofs should not use this feature.&quot;</span></span>
<span class="lineno"> 2793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2794 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2795 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_checkpoint&quot;      &quot;ProofScript (() -&gt; ProofScript ())&quot;</span>
<span class="lineno"> 2796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proof_checkpoint)</span></span>
<span class="lineno"> 2797 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Capture the current state of the SAW interpreter, and return a&quot;</span></span>
<span class="lineno"> 2799 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;ProofScript monadic action that, if invoked, will reset the&quot;</span></span>
<span class="lineno"> 2800 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof state back to to what it was when 'proof_checkpoint' was&quot;</span></span>
<span class="lineno"> 2801 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invoked.&quot;</span></span>
<span class="lineno"> 2802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOTE that this facility is highly experimental and may not&quot;</span></span>
<span class="lineno"> 2804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;particularly reliable. It is intended only for proof development&quot;</span></span>
<span class="lineno"> 2805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where it can speed up the process of experimenting with mid-&quot;</span></span>
<span class="lineno"> 2806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof changes. Finalized proofs should not use this feature.&quot;</span></span>
<span class="lineno"> 2807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2808 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2809 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2810 </span><span class="spaces">    </span><span class="istickedoff">-- Test/debug widgets</span>
<span class="lineno"> 2811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2812 </span><span class="spaces">    </span><span class="istickedoff">-- In principle we could have one monad-polymorphic builtin, but</span>
<span class="lineno"> 2813 </span><span class="spaces">    </span><span class="istickedoff">-- monad-polymorphic builtins don't currently work.</span>
<span class="lineno"> 2814 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 2815 </span><span class="spaces">    </span><span class="istickedoff">-- FUTURE: because these are only intended for use by the test</span>
<span class="lineno"> 2816 </span><span class="spaces">    </span><span class="istickedoff">-- suite, it might make sense to add a different category for that</span>
<span class="lineno"> 2817 </span><span class="spaces">    </span><span class="istickedoff">-- instead of Experimental, to make it extra clear that third</span>
<span class="lineno"> 2818 </span><span class="spaces">    </span><span class="istickedoff">-- parties shouldn't use these.</span>
<span class="lineno"> 2819 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_stack&quot;         &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2820 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_stack)</span>
<span class="lineno"> 2821 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the SAWScript interpreter's current stack trace, for testing.&quot; ]</span></span>
<span class="lineno"> 2823 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_stack&quot;         &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2824 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proof_stack)</span>
<span class="lineno"> 2825 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2826 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;ProofScript version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2827 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_stack&quot;          &quot;LLVMSetup ()&quot;</span>
<span class="lineno"> 2828 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_stack)</span>
<span class="lineno"> 2829 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;LLVMSetup version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2831 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_stack&quot;           &quot;JVMSetup ()&quot;</span>
<span class="lineno"> 2832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_stack)</span></span>
<span class="lineno"> 2833 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2834 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;JVMSetup version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2835 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_stack&quot;           &quot;MIRSetup ()&quot;</span>
<span class="lineno"> 2836 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_stack)</span></span>
<span class="lineno"> 2837 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;MIRSetup version of print_stack.&quot; ]</span></span>
<span class="lineno"> 2839 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2840 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2841 </span><span class="spaces">    </span><span class="istickedoff">-- List operations</span>
<span class="lineno"> 2842 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2843 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;null&quot;                &quot;{a} [a] -&gt; Bool&quot;</span>
<span class="lineno"> 2844 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (null :: [Value] -&gt; Bool))</span>
<span class="lineno"> 2845 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Test whether a list is empty.&quot; ]</span></span>
<span class="lineno"> 2847 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2848 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;head&quot;                &quot;{a} [a] -&gt; a&quot;</span>
<span class="lineno"> 2849 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (headPrim :: [Value] -&gt; TopLevel Value))</span>
<span class="lineno"> 2850 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the first element from the list.&quot; ]</span></span>
<span class="lineno"> 2852 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2853 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;tail&quot;                &quot;{a} [a] -&gt; [a]&quot;</span>
<span class="lineno"> 2854 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (tailPrim :: [Value] -&gt; TopLevel [Value]))</span>
<span class="lineno"> 2855 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Drop the first element from a list.&quot; ]</span></span>
<span class="lineno"> 2857 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2858 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;length&quot;              &quot;{a} [a] -&gt; Int&quot;</span>
<span class="lineno"> 2859 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (length :: [Value] -&gt; Int))</span>
<span class="lineno"> 2860 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Compute the length of a list.&quot; ]</span></span>
<span class="lineno"> 2862 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2863 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;concat&quot;              &quot;{a} [a] -&gt; [a] -&gt; [a]&quot;</span>
<span class="lineno"> 2864 </span><span class="spaces">    </span><span class="istickedoff">(pureVal ((++) :: [Value] -&gt; [Value] -&gt; [Value]))</span>
<span class="lineno"> 2865 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate two lists to yield a third.&quot; ]</span></span>
<span class="lineno"> 2867 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2868 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;nth&quot;                 &quot;{a} [a] -&gt; Int -&gt; a&quot;</span>
<span class="lineno"> 2869 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 (nthPrim :: [Value] -&gt; Int -&gt; TopLevel Value))</span>
<span class="lineno"> 2870 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Look up the value at the given list position.&quot; ]</span></span>
<span class="lineno"> 2872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2873 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;for&quot;                 &quot;{m, a, b} [a] -&gt; (a -&gt; m b) -&gt; m [b]&quot;</span>
<span class="lineno"> 2874 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 forValue)</span>
<span class="lineno"> 2875 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given monadic action in left-to-right order to a list&quot;</span></span>
<span class="lineno"> 2877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values. Collect the results and return them as another list.&quot;</span></span>
<span class="lineno"> 2878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2879 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2880 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2881 </span><span class="spaces">    </span><span class="istickedoff">-- String operations</span>
<span class="lineno"> 2882 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2883 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;str_concat&quot;          &quot;String -&gt; String -&gt; String&quot;</span>
<span class="lineno"> 2884 </span><span class="spaces">    </span><span class="istickedoff">(pureVal ((&lt;&gt;) :: Text -&gt; Text -&gt; Text))</span>
<span class="lineno"> 2885 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate two strings to yield a third.&quot; ]</span></span>
<span class="lineno"> 2887 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2888 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;str_concats&quot;          &quot;[String] -&gt; String&quot;</span>
<span class="lineno"> 2889 </span><span class="spaces">    </span><span class="istickedoff">(pureVal Text.concat)</span>
<span class="lineno"> 2890 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate a list of strings together to yield a single string.&quot; ]</span></span>
<span class="lineno"> 2892 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2893 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2894 </span><span class="spaces">    </span><span class="istickedoff">-- File operations</span>
<span class="lineno"> 2895 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2896 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_bytes&quot;          &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 2897 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readBytes)</span>
<span class="lineno"> 2898 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2899 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read a file, treating it as binary, and return the contents as a&quot;</span></span>
<span class="lineno"> 2900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term value of type [n][8].&quot;</span></span>
<span class="lineno"> 2901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2902 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2903 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2904 </span><span class="spaces">    </span><span class="istickedoff">-- Miscellaneous operations</span>
<span class="lineno"> 2905 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2906 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_opt&quot;            &quot;Int -&gt; String&quot;</span>
<span class="lineno"> 2907 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 get_opt)</span>
<span class="lineno"> 2908 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the nth argument to the current script as a String. Script&quot;</span></span>
<span class="lineno"> 2910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;arguments are collected from the SAW command line after the name&quot;</span></span>
<span class="lineno"> 2911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the script being run. Argument 0 is the script name. The list&quot;</span></span>
<span class="lineno"> 2912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is empty when no script was loaded, e.g. when interactive.&quot;</span></span>
<span class="lineno"> 2913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2914 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2915 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_nopts&quot;          &quot;() -&gt; Int&quot;</span>
<span class="lineno"> 2916 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 get_nopts)</span>
<span class="lineno"> 2917 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the number of arguments to the current script. Since the 0th&quot;</span></span>
<span class="lineno"> 2919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument is the script name, the count will normally be at least&quot;</span></span>
<span class="lineno"> 2920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. If no script was loaded, the count will be 0.&quot;</span></span>
<span class="lineno"> 2921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2923 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_env&quot;            &quot;String -&gt; String&quot;</span>
<span class="lineno"> 2924 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 get_env)</span>
<span class="lineno"> 2925 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get an environment variable (from the process environment) as a&quot;</span></span>
<span class="lineno"> 2927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;string.&quot;</span></span>
<span class="lineno"> 2928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2929 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2930 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;exit&quot;                &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2931 </span><span class="spaces">    </span><span class="istickedoff">(pureVal exitPrim)</span>
<span class="lineno"> 2932 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Exit SAWScript, returning the supplied exit code to the parent&quot;</span></span>
<span class="lineno"> 2934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;process.&quot;</span></span>
<span class="lineno"> 2935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2936 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2937 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;exec&quot;               &quot;String -&gt; [String] -&gt; String -&gt; TopLevel String&quot;</span>
<span class="lineno"> 2938 </span><span class="spaces">    </span><span class="istickedoff">(pureVal exec)</span>
<span class="lineno"> 2939 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2940 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Execute an external process with the given executable name&quot;</span></span>
<span class="lineno"> 2941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument list, and standard input. Collects and returns the&quot;</span></span>
<span class="lineno"> 2942 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;standard output produced by the process.&quot;</span></span>
<span class="lineno"> 2943 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2944 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2945 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;time&quot;                &quot;{a} TopLevel a -&gt; TopLevel a&quot;</span>
<span class="lineno"> 2946 </span><span class="spaces">    </span><span class="istickedoff">(pureVal timePrim)</span>
<span class="lineno"> 2947 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the CPU time used by the given TopLevel command.&quot; ]</span></span>
<span class="lineno"> 2949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2950 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;with_time&quot;           &quot;{a} TopLevel a -&gt; TopLevel (Int, a)&quot;</span>
<span class="lineno"> 2951 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal withTimePrim)</span></span>
<span class="lineno"> 2952 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given TopLevel command. Return the elapsed time in&quot;</span></span>
<span class="lineno"> 2954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;milliseconds along with the command's own result.&quot;</span></span>
<span class="lineno"> 2955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2956 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2957 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 2958 </span><span class="spaces">    </span><span class="istickedoff">-- Boolean/flag settings</span>
<span class="lineno"> 2959 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2960 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_smt_array_memory_model&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2961 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_smt_array_memory_model)</span>
<span class="lineno"> 2962 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the SMT array memory model.&quot; ]</span></span>
<span class="lineno"> 2964 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2965 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_smt_array_memory_model&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_smt_array_memory_model)</span></span>
<span class="lineno"> 2967 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable the SMT array memory model.&quot; ]</span></span>
<span class="lineno"> 2969 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2970 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_sequent_goals&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_sequent_goals)</span></span>
<span class="lineno"> 2972 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When verifying proof obligations arising from 'llvm_verify' and&quot;</span></span>
<span class="lineno"> 2974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;similar commands, generate sequents (that is, multiple separate&quot;</span></span>
<span class="lineno"> 2975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goals) for the resulting proof obligations instead of a single&quot;</span></span>
<span class="lineno"> 2976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;overarching goal.&quot;</span></span>
<span class="lineno"> 2977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2978 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2979 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_sequent_goals&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_sequent_goals)</span></span>
<span class="lineno"> 2981 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2982 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Restore the default behavior, which is to generate single&quot;</span></span>
<span class="lineno"> 2983 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;boolean goals for proof obligations arising from verification&quot;</span></span>
<span class="lineno"> 2984 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;commands.&quot;</span></span>
<span class="lineno"> 2985 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2987 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_safety_proofs&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_safety_proofs)</span></span>
<span class="lineno"> 2989 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Restore the default state, where safety obligations encountered&quot;</span></span>
<span class="lineno"> 2991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;during symbolic execution are proved normally.&quot;</span></span>
<span class="lineno"> 2992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2993 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2994 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_safety_proofs&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 2995 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_safety_proofs)</span></span>
<span class="lineno"> 2996 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable checking of safety obligations encountered during&quot;</span></span>
<span class="lineno"> 2998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic execution. This is unsound! However, it can be useful&quot;</span></span>
<span class="lineno"> 2999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;during initial proof construction to focus only on the stated&quot;</span></span>
<span class="lineno"> 3000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;correctness specifications.&quot;</span></span>
<span class="lineno"> 3001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3002 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3003 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_single_override_special_case&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3004 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_single_override_special_case)</span></span>
<span class="lineno"> 3005 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable special-case handling when there is exactly one override&quot;</span></span>
<span class="lineno"> 3007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that appies at a given call site after structural matching.&quot;</span></span>
<span class="lineno"> 3008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This special case handling asserts the override preconditions as&quot;</span></span>
<span class="lineno"> 3009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;separate proof goals, instead of combining them into one. In&quot;</span></span>
<span class="lineno"> 3010 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;general, this may produce more, but simpler, goals than when&quot;</span></span>
<span class="lineno"> 3011 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;disabled.&quot;</span></span>
<span class="lineno"> 3012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3013 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3014 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_single_override_special_case&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3015 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_single_override_special_case)</span></span>
<span class="lineno"> 3016 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable special case handling for single overrides.&quot;</span></span>
<span class="lineno"> 3018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is the default behavior.&quot;</span></span>
<span class="lineno"> 3019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3021 </span><span class="spaces"> </span><span class="istickedoff">, prim &quot;enable_crucible_assert_then_assume&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3022 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_crucible_assert_then_assume)</span>
<span class="lineno"> 3023 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume predicate after asserting it during Crucible symbolic&quot;</span></span>
<span class="lineno"> 3025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution.&quot;</span></span>
<span class="lineno"> 3026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3027 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3028 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_crucible_assert_then_assume&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3029 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_crucible_assert_then_assume)</span>
<span class="lineno"> 3030 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Do not assume predicate after asserting it during Crucible&quot;</span></span>
<span class="lineno"> 3032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic execution.&quot;</span></span>
<span class="lineno"> 3033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3035 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_arithmetic&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_lax_arithmetic)</span></span>
<span class="lineno"> 3037 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3038 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable lax rules for arithmetic overflow in Crucible.&quot; ]</span></span>
<span class="lineno"> 3039 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3040 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_arithmetic&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_arithmetic)</span></span>
<span class="lineno"> 3042 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3043 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable lax rules for arithmetic overflow in Crucible.&quot; ]</span></span>
<span class="lineno"> 3044 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3045 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_pointer_ordering&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3046 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_lax_pointer_ordering)</span>
<span class="lineno"> 3047 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable lax rules for pointer ordering comparisons in Crucible.&quot; ]</span></span>
<span class="lineno"> 3049 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3050 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_pointer_ordering&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3051 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_pointer_ordering)</span></span>
<span class="lineno"> 3052 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3053 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable lax rules for pointer ordering comparisons in Crucible.&quot; ]</span></span>
<span class="lineno"> 3054 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3055 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_loads_and_stores&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3056 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_lax_loads_and_stores)</span>
<span class="lineno"> 3057 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3058 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable relaxed validity checking for memory loads and stores in&quot;</span></span>
<span class="lineno"> 3059 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Crucible.&quot;</span></span>
<span class="lineno"> 3060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3061 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3062 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_loads_and_stores&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3063 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_loads_and_stores)</span></span>
<span class="lineno"> 3064 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable relaxed validity checking for memory loads and stores in&quot;</span></span>
<span class="lineno"> 3066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Crucible.&quot;</span></span>
<span class="lineno"> 3067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3068 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3069 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_debug_intrinsics&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3070 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_debug_intrinsics)</span></span>
<span class="lineno"> 3071 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable translating statements using certain llvm.dbg intrinsic&quot;</span></span>
<span class="lineno"> 3073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;functions in Crucible.&quot;</span></span>
<span class="lineno"> 3074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3075 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3076 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_debug_intrinsics&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3077 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_debug_intrinsics)</span></span>
<span class="lineno"> 3078 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable translating statements using certain llvm.dbg intrinsic&quot;</span></span>
<span class="lineno"> 3080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;functions in Crucible.&quot;</span></span>
<span class="lineno"> 3081 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3082 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3083 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_what4_hash_consing)</span></span>
<span class="lineno"> 3085 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable hash-consing for What4 expressions.&quot; ]</span></span>
<span class="lineno"> 3087 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3088 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_hash_consing)</span></span>
<span class="lineno"> 3090 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3091 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable hash-consing for What4 expressions.&quot; ]</span></span>
<span class="lineno"> 3092 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3093 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_eval&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3094 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_what4_eval)</span>
<span class="lineno"> 3095 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable What4 translation for SAWCore expressions during Crucible&quot;</span></span>
<span class="lineno"> 3097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic execution.&quot;</span></span>
<span class="lineno"> 3098 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3099 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3100 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_eval&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3101 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_eval)</span></span>
<span class="lineno"> 3102 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3103 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable What4 translation for SAWCore expressions during&quot;</span></span>
<span class="lineno"> 3104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Crucible symbolic execution.&quot;</span></span>
<span class="lineno"> 3105 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3106 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3107 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_alloc_sym_init_check&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3108 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_alloc_sym_init_check)</span>
<span class="lineno"> 3109 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3110 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the allocation initialization check associated with&quot;</span></span>
<span class="lineno"> 3111 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_alloc_sym_init' during override application.&quot;</span></span>
<span class="lineno"> 3112 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3113 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3114 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_alloc_sym_init_check&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3115 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_alloc_sym_init_check)</span>
<span class="lineno"> 3116 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable the allocation initialization check associated with&quot;</span></span>
<span class="lineno"> 3118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'alloc_sym_init' during override application.&quot;</span></span>
<span class="lineno"> 3119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3120 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Disabling this check allows an override to apply when the memory&quot;</span></span>
<span class="lineno"> 3121 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;region specified by the 'alloc_sym_init' command in the override&quot;</span></span>
<span class="lineno"> 3122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification is not written to in the calling context. This&quot;</span></span>
<span class="lineno"> 3123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;implicitly assumes that there is some unspecified byte at any&quot;</span></span>
<span class="lineno"> 3124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;valid memory address.&quot;</span></span>
<span class="lineno"> 3125 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3126 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3127 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_no_satisfying_write_fresh_constant&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_no_satisfying_write_fresh_constant)</span></span>
<span class="lineno"> 3129 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When simulating LLVM code that performs an invalid write, make a&quot;</span></span>
<span class="lineno"> 3131 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fresh constant as a proof obligation. This constant will always&quot;</span></span>
<span class="lineno"> 3132 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fail, but it will also not be constant-folded away.&quot;</span></span>
<span class="lineno"> 3133 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3134 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3135 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_no_satisfying_write_fresh_constant&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_no_satisfying_write_fresh_constant)</span></span>
<span class="lineno"> 3137 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3138 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When simulating LLVM code that performs an invalid write, return&quot;</span></span>
<span class="lineno"> 3139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'false' as a proof obligation.&quot;</span></span>
<span class="lineno"> 3140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3141 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3142 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_push_mux_ops&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3143 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_what4_push_mux_ops)</span></span>
<span class="lineno"> 3144 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Push certain What4 operations (e.g., 'zext') down to the&quot;</span></span>
<span class="lineno"> 3146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;branches of 'ite' expressions as much as possible. In some (but&quot;</span></span>
<span class="lineno"> 3147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not all) circumstances, this can result in operations that are&quot;</span></span>
<span class="lineno"> 3148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;easier for SMT solvers to reason about.&quot;</span></span>
<span class="lineno"> 3149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3150 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3151 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_push_mux_ops&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3152 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_push_mux_ops)</span></span>
<span class="lineno"> 3153 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Do not push certain What4 operations (e.g., 'zext') down to the&quot;</span></span>
<span class="lineno"> 3155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;branches of 'ite' expressions as much as possible.&quot;</span></span>
<span class="lineno"> 3156 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3157 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3158 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_crucible_profiling&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3159 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_crucible_profiling)</span>
<span class="lineno"> 3160 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3161 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record profiling information from symbolic execution and solver&quot;</span></span>
<span class="lineno"> 3162 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invocation to the given directory.&quot;</span></span>
<span class="lineno"> 3163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3164 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3165 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_crucible_profiling&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3166 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_crucible_profiling)</span>
<span class="lineno"> 3167 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[&quot;Stop recording profiling information.&quot;]</span></span>
<span class="lineno"> 3169 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3170 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3171 </span><span class="spaces">    </span><span class="istickedoff">-- Other settings</span>
<span class="lineno"> 3172 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3173 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_timeout&quot;         &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_timeout)</span></span>
<span class="lineno"> 3175 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the timeout, in milliseconds, for any automated prover that&quot;</span></span>
<span class="lineno"> 3177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;appears at the end of this proof script. For now provers that&quot;</span></span>
<span class="lineno"> 3178 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;don't support timeouts just ignore the setting.&quot;</span></span>
<span class="lineno"> 3179 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3180 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3181 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_crucible_timeout&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_crucible_timeout)</span></span>
<span class="lineno"> 3183 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3184 </span><span class="spaces">    </span><span class="istickedoff">-- XXX this is ignored by JVM/MIR verification; see #2803</span>
<span class="lineno"> 3185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the timeout for the SMT solver during the LLVM and x86&quot;</span></span>
<span class="lineno"> 3186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Crucible symbolic execution, in milliseconds. The default is&quot;</span></span>
<span class="lineno"> 3187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;10000 (10 seconds). Set it to 0 to disable the timeout.&quot;</span></span>
<span class="lineno"> 3188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This setting is used for path-satisfiability checks and&quot;</span></span>
<span class="lineno"> 3190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiability checks when applying overrides.&quot;</span></span>
<span class="lineno"> 3191 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3192 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3193 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_path_sat_solver&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_path_sat_solver)</span></span>
<span class="lineno"> 3195 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the path satisfiablity solver to use. Currently accepted&quot;</span></span>
<span class="lineno"> 3197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values are 'z3' and 'yices'.&quot;</span></span>
<span class="lineno"> 3198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3199 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3200 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_ascii&quot;           &quot;Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_ascii)</span></span>
<span class="lineno"> 3202 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Select whether to pretty-print arrays of 8-bit numbers as ASCII&quot;</span></span>
<span class="lineno"> 3204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;strings.&quot;</span></span>
<span class="lineno"> 3205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3206 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3207 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_base&quot;            &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3208 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_base)</span>
<span class="lineno"> 3209 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the number base for pretty-printing numeric literals.&quot;</span></span>
<span class="lineno"> 3211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Permissible values include 2, 8, 10, and 16.&quot;</span></span>
<span class="lineno"> 3212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3213 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3214 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_color&quot;           &quot;Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_color)</span></span>
<span class="lineno"> 3216 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Select whether to pretty-print SAWCore terms using color.&quot; ]</span></span>
<span class="lineno"> 3218 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3219 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_min_sharing&quot;     &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_min_sharing)</span></span>
<span class="lineno"> 3221 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the number times a subterm must be shared for it to be&quot;</span></span>
<span class="lineno"> 3223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;let-bound in SAWCore printer output.&quot;</span></span>
<span class="lineno"> 3224 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3225 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3226 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_hash&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_hash)</span></span>
<span class="lineno"> 3228 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;'set_memoization_hash i' changes the memoization strategy for&quot;</span></span>
<span class="lineno"> 3230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;terms: memoization identifiers will include the first 'i' digits&quot;</span></span>
<span class="lineno"> 3231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the hash of the term they memoize. This is useful to help&quot;</span></span>
<span class="lineno"> 3232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;keep memoization identifiers of the same term as constant as&quot;</span></span>
<span class="lineno"> 3233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;possible across different executions of a proof script over the&quot;</span></span>
<span class="lineno"> 3234 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;course of its development.&quot;</span></span>
<span class="lineno"> 3235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3236 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3237 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_hash_incremental&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_hash_incremental)</span></span>
<span class="lineno"> 3239 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;'set_memoization_hash_incremental i' changes the memoization&quot;</span></span>
<span class="lineno"> 3241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;strategy for terms: memoization identifiers will include the&quot;</span></span>
<span class="lineno"> 3242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first 'i' digits of the hash of the term they memoize, as well&quot;</span></span>
<span class="lineno"> 3243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the value of a global counter that increments each time a&quot;</span></span>
<span class="lineno"> 3244 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term is memoized. This is useful to help keep memoization&quot;</span></span>
<span class="lineno"> 3245 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;identifiers of the same term as constant as possible across&quot;</span></span>
<span class="lineno"> 3246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;different executions of a proof script over the course of its&quot;</span></span>
<span class="lineno"> 3247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;development, as well as to freshen memoization identifiers in&quot;</span></span>
<span class="lineno"> 3248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the unlikely case of term hash collisions.&quot;</span></span>
<span class="lineno"> 3249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3250 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3251 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_incremental&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3252 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_incremental)</span></span>
<span class="lineno"> 3253 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3254 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;'set_memoization_incremental' changes the memoization strategy&quot;</span></span>
<span class="lineno"> 3255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for terms: memoization identifiers will only include the value&quot;</span></span>
<span class="lineno"> 3256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of a global counter that increments each time a term is&quot;</span></span>
<span class="lineno"> 3257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;memoized. This is the default.&quot;</span></span>
<span class="lineno"> 3258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3259 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3260 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3261 </span><span class="spaces">    </span><span class="istickedoff">-- Solver cache</span>
<span class="lineno"> 3262 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3263 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_solver_cache_path&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3264 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_solver_cache_path)</span>
<span class="lineno"> 3265 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a solver result cache at the given path, add all results&quot;</span></span>
<span class="lineno"> 3267 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the current solver result cache (if any), then use the newly&quot;</span></span>
<span class="lineno"> 3268 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;created cache as the solver result cache going forward. Note&quot;</span></span>
<span class="lineno"> 3269 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that if the SAW_SOLVER_CACHE_PATH environment variable was set&quot;</span></span>
<span class="lineno"> 3270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;at startup but no solver caching has actually been done yet, the&quot;</span></span>
<span class="lineno"> 3271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the value of the environment variable will be ignored.&quot;</span></span>
<span class="lineno"> 3272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3273 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3274 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_solver_cache_timeout&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3275 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_solver_cache_timeout)</span>
<span class="lineno"> 3276 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the solver result cache's timeout (in microseconds) to use&quot;</span></span>
<span class="lineno"> 3278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for database lookups and inserts. The default timeout is&quot;</span></span>
<span class="lineno"> 3279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2,000,000 microseconds (2 seconds).&quot;</span></span>
<span class="lineno"> 3280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3281 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3282 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;clean_mismatched_versions_solver_cache&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3283 </span><span class="spaces">    </span><span class="istickedoff">(pureVal clean_mismatched_versions_solver_cache)</span>
<span class="lineno"> 3284 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all entries in the solver result cache which were created&quot;</span></span>
<span class="lineno"> 3286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using solver backend versions which do not match the versions in&quot;</span></span>
<span class="lineno"> 3287 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the current environment.&quot;</span></span>
<span class="lineno"> 3288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3289 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3290 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_solver_cache&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (onSolverCache . printSolverCacheByHex))</span></span>
<span class="lineno"> 3292 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print all entries in the solver result cache whose SHA256 hash&quot;</span></span>
<span class="lineno"> 3294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;keys start with the given hex string. Providing an empty string&quot;</span></span>
<span class="lineno"> 3295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;results in all entries in the cache being printed.&quot;</span></span>
<span class="lineno"> 3296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3298 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_solver_cache_stats&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (onSolverCache printSolverCacheStats))</span></span>
<span class="lineno"> 3300 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print out statistics about how the solver cache has been used&quot;</span></span>
<span class="lineno"> 3302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so far in this session, namely:&quot;</span></span>
<span class="lineno"> 3303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   0. Where the cache is stored&quot;</span></span>
<span class="lineno"> 3304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   1. How many entries are in the cache&quot;</span></span>
<span class="lineno"> 3305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   2. How many insertions into the cache have been made&quot;</span></span>
<span class="lineno"> 3306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   3. How many failed insertion attempts have been made&quot;</span></span>
<span class="lineno"> 3307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   4. How times cached results have been used&quot;</span></span>
<span class="lineno"> 3308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   5. How many failed attempted usages have occurred.&quot;</span></span>
<span class="lineno"> 3309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3310 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3311 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;test_solver_cache_stats&quot; &quot;Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3312 </span><span class="spaces">    </span><span class="istickedoff">(pureVal test_solver_cache_stats)</span>
<span class="lineno"> 3313 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Test whether the values of the statistics printed out by&quot;</span></span>
<span class="lineno"> 3315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'print_solver_cache_stats' are equal to those given, failing if&quot;</span></span>
<span class="lineno"> 3316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this does not hold. Specifically, the arguments represent:&quot;</span></span>
<span class="lineno"> 3317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   1. How many entries are in the cache&quot;</span></span>
<span class="lineno"> 3318 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   2. How many insertions into the cache have been made&quot;</span></span>
<span class="lineno"> 3319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   3. How many failed insertion attempts have been made&quot;</span></span>
<span class="lineno"> 3320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   4. How times cached results have been used&quot;</span></span>
<span class="lineno"> 3321 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   5. How many failed attempted usages have occurred&quot;</span></span>
<span class="lineno"> 3322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3324 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3325 </span><span class="spaces">    </span><span class="istickedoff">-- SAWCore inspection</span>
<span class="lineno"> 3326 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3327 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show_term&quot;           &quot;Term -&gt; String&quot;</span>
<span class="lineno"> 3328 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 show_term)</span>
<span class="lineno"> 3329 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax, yielding a&quot;</span></span>
<span class="lineno"> 3331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;String.&quot;</span></span>
<span class="lineno"> 3332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3333 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3334 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_size&quot;           &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 3335 </span><span class="spaces">    </span><span class="istickedoff">(pureVal scSharedSize)</span>
<span class="lineno"> 3336 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the size of the given term in the number of DAG nodes.&quot; ]</span></span>
<span class="lineno"> 3338 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3339 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_tree_size&quot;      &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 3340 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal scTreeSize)</span></span>
<span class="lineno"> 3341 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the size of the given term in the number of nodes it&quot;</span></span>
<span class="lineno"> 3343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;would have if treated as a tree instead of a DAG.&quot;</span></span>
<span class="lineno"> 3344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3345 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3346 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_theories&quot; &quot;[String] -&gt; Term -&gt; [String]&quot;</span>
<span class="lineno"> 3347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_theories)</span></span>
<span class="lineno"> 3348 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3349 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term of type 'Bool', compute the SMT theories required&quot;</span></span>
<span class="lineno"> 3350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to reason about this term. The functions (if any) given in the&quot;</span></span>
<span class="lineno"> 3351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument will be treated as uninterpreted.&quot;</span></span>
<span class="lineno"> 3352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3353 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If the returned list is empty, the given term represents a&quot;</span></span>
<span class="lineno"> 3354 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;problem that can be solved purely by boolean SAT reasoning.&quot;</span></span>
<span class="lineno"> 3355 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3356 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: the given term will be simplified using the What4 backend&quot;</span></span>
<span class="lineno"> 3357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before inspection.. For simple problems, this may simplify away&quot;</span></span>
<span class="lineno"> 3358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;some aspects of the problem altogether and may result in fewer&quot;</span></span>
<span class="lineno"> 3359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;theories in the output than one might expect.&quot;</span></span>
<span class="lineno"> 3360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3361 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3362 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;is_convertible&quot;  &quot;Term -&gt; Term -&gt; TopLevel Bool&quot;</span>
<span class="lineno"> 3363 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal isConvertiblePrim)</span></span>
<span class="lineno"> 3364 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true iff the two terms are convertible.&quot; ]</span></span>
<span class="lineno"> 3366 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3367 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_convertible&quot;  &quot;Term -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal checkConvertiblePrim)</span></span>
<span class="lineno"> 3369 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3370 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Check if two terms are convertible and print the result.&quot; ]</span></span>
<span class="lineno"> 3371 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3372 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_term&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3373 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_term)</span>
<span class="lineno"> 3374 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax.&quot; ]</span></span>
<span class="lineno"> 3376 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3377 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_term_depth&quot;    &quot;Int -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_term_depth)</span></span>
<span class="lineno"> 3379 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax up to a given&quot;</span></span>
<span class="lineno"> 3381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;depth.&quot;</span></span>
<span class="lineno"> 3382 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3383 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3384 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_term&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3385 </span><span class="spaces">    </span><span class="istickedoff">(pureVal check_term)</span>
<span class="lineno"> 3386 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type-check the given term, printing an error message if&quot;</span></span>
<span class="lineno"> 3388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;ill-typed. Also see 'check_goal'.&quot;</span></span>
<span class="lineno"> 3389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3390 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3391 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3392 </span><span class="spaces">    </span><span class="istickedoff">-- SAWCore term construction</span>
<span class="lineno"> 3393 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3394 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fresh_symbolic&quot;      &quot;String -&gt; Type -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3395 </span><span class="spaces">    </span><span class="istickedoff">(pureVal freshSymbolicPrim)</span>
<span class="lineno"> 3396 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3397 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given type. The name&quot;</span></span>
<span class="lineno"> 3398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(first argument) is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 3399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3400 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3401 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;abstract_symbolic&quot;   &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3402 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 abstractSymbolicPrim)</span>
<span class="lineno"> 3403 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a term containing symbolic variables of the form returned&quot;</span></span>
<span class="lineno"> 3405 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by 'fresh_symbolic' and return a new lambda term in which those&quot;</span></span>
<span class="lineno"> 3406 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables have been replaced by parameter references.&quot;</span></span>
<span class="lineno"> 3407 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3408 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3409 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;lambda&quot;              &quot;Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3410 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 lambda)</span>
<span class="lineno"> 3411 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a 'fresh_symbolic' variable and another term containing&quot;</span></span>
<span class="lineno"> 3413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that variable, and return a new lambda abstraction over that&quot;</span></span>
<span class="lineno"> 3414 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable.&quot;</span></span>
<span class="lineno"> 3415 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3416 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3417 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;lambdas&quot;             &quot;[Term] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3418 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 lambdas)</span>
<span class="lineno"> 3419 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3420 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a list of 'fresh_symbolic' variables and another Term&quot;</span></span>
<span class="lineno"> 3421 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;containing those variables, and return a new lambda abstraction&quot;</span></span>
<span class="lineno"> 3422 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;over all the variables in the list.&quot;</span></span>
<span class="lineno"> 3423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3425 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;generalize_term&quot;   &quot;[Term] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3426 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 generalize_term)</span></span>
<span class="lineno"> 3427 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3428 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a list of 'fresh_symbolic' variables and another term&quot;</span></span>
<span class="lineno"> 3429 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;containing those variables, and return a new Pi generalization&quot;</span></span>
<span class="lineno"> 3430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;over all the variables in the list.&quot;</span></span>
<span class="lineno"> 3431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3433 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;int_to_term&quot;      &quot;Int -&gt; Term&quot;</span>
<span class="lineno"> 3434 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 int_to_term)</span></span>
<span class="lineno"> 3435 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3436 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a concrete integer value into an integer term.&quot; ]</span></span>
<span class="lineno"> 3437 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3438 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;nat_to_term&quot;      &quot;Int -&gt; Term&quot;</span>
<span class="lineno"> 3439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 nat_to_term)</span></span>
<span class="lineno"> 3440 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a non-negative integer value into a natural number term.&quot; ]</span></span>
<span class="lineno"> 3442 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3443 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;size_to_term&quot;      &quot;Type -&gt; Term&quot;</span>
<span class="lineno"> 3444 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 size_to_term)</span></span>
<span class="lineno"> 3445 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3446 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a Cryptol size type into a Term representation.&quot; ]</span></span>
<span class="lineno"> 3447 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3448 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_apply&quot;          &quot;Term -&gt; [Term] -&gt; Term&quot;</span>
<span class="lineno"> 3449 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_apply)</span></span>
<span class="lineno"> 3450 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Build a term application node that applies the first term (which&quot;</span></span>
<span class="lineno"> 3452 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must be a function) to the given list of arguments.&quot;</span></span>
<span class="lineno"> 3453 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3454 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3455 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;implies_term&quot;      &quot;Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 implies_term)</span></span>
<span class="lineno"> 3457 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given two terms 'e1' and 'e2' of underlying type 'Prop',&quot;</span></span>
<span class="lineno"> 3459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;construct the SAWCore implication e1 ==&gt; e2.&quot;</span></span>
<span class="lineno"> 3460 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3461 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3462 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3463 </span><span class="spaces">    </span><span class="istickedoff">-- SAWCore term manipulation</span>
<span class="lineno"> 3464 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3465 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;define&quot;              &quot;String -&gt; Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3466 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal definePrim)</span></span>
<span class="lineno"> 3467 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3468 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Wrap a term with a name that allows its body to be hidden or&quot;</span></span>
<span class="lineno"> 3469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;revealed. This can allow any sub-term to be treated as an&quot;</span></span>
<span class="lineno"> 3470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted function during proofs.&quot;</span></span>
<span class="lineno"> 3471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3473 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfold_term&quot;         &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3474 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 unfold_term)</span>
<span class="lineno"> 3475 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the definitions of the specified constants in the given&quot;</span></span>
<span class="lineno"> 3477 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term. Also see 'unfolding'.&quot;</span></span>
<span class="lineno"> 3478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3479 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3480 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;replace&quot;             &quot;Term -&gt; Term -&gt; Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal replacePrim)</span></span>
<span class="lineno"> 3482 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3483 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;'replace x y z' rewrites occurences of term x into y inside the&quot;</span></span>
<span class="lineno"> 3484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term z. x and y must be closed terms.&quot;</span></span>
<span class="lineno"> 3485 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3486 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3487 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;rewrite&quot;             &quot;Simpset -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3488 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 rewritePrim)</span>
<span class="lineno"> 3489 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Rewrite a term using a set of simplification rules.&quot;</span></span>
<span class="lineno"> 3491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Returns the rewritten term.&quot;</span></span>
<span class="lineno"> 3492 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3493 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3494 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_term&quot;      &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3495 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 normalize_term)</span>
<span class="lineno"> 3496 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the given term by performing evaluation in SAWCore.&quot;</span></span>
<span class="lineno"> 3498 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Also see 'goal_normalize'.&quot;</span></span>
<span class="lineno"> 3499 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3500 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3501 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_term_opaque&quot; &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 normalize_term_opaque)</span></span>
<span class="lineno"> 3503 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the given term by performing evaluation in SAWCore.&quot;</span></span>
<span class="lineno"> 3505 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The named values in the first argument will be treated opaquely&quot;</span></span>
<span class="lineno"> 3506 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and not unfolded during evaluation.&quot;</span></span>
<span class="lineno"> 3507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3508 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3509 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_eval&quot;           &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (term_eval []))</span></span>
<span class="lineno"> 3511 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the term to a first-order combination of primitives.&quot; ]</span></span>
<span class="lineno"> 3513 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3514 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_eval_unint&quot;     &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 3515 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_eval)</span></span>
<span class="lineno"> 3516 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3517 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the term to a first-order combination of primitives.&quot;</span></span>
<span class="lineno"> 3518 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Leave the given names, as defined with 'define', uninterpreted.&quot; ]</span></span>
<span class="lineno"> 3519 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3520 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_term&quot; &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3521 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 default_typed_term)</span></span>
<span class="lineno"> 3522 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply Cryptol defaulting rules to the given term.&quot; ]</span></span>
<span class="lineno"> 3524 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3525 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;hoist_ifs&quot;            &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal hoistIfsPrim)</span></span>
<span class="lineno"> 3527 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Hoist all if-then-else expressions as high as possible.&quot; ]</span></span>
<span class="lineno"> 3529 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3530 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;beta_reduce_term&quot;    &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 3531 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 beta_reduce_term)</span>
<span class="lineno"> 3532 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Reduce the given term to beta-normal form.&quot; ]</span></span>
<span class="lineno"> 3534 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3535 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;congruence_for&quot; &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3536 </span><span class="spaces">    </span><span class="istickedoff">(pureVal congruence_for)</span>
<span class="lineno"> 3537 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term representing a (nondependent) function, attempt&quot;</span></span>
<span class="lineno"> 3539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to automatically construct the statement of a congruence lemma&quot;</span></span>
<span class="lineno"> 3540 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for the function.&quot;</span></span>
<span class="lineno"> 3541 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3542 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3543 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3544 </span><span class="spaces">    </span><span class="istickedoff">-- SAWCore file and text operations</span>
<span class="lineno"> 3545 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3546 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parse_core&quot;         &quot;String -&gt; Term&quot;</span>
<span class="lineno"> 3547 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 parse_core)</span>
<span class="lineno"> 3548 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Term from a String in SAWCore syntax.&quot; ]</span></span>
<span class="lineno"> 3550 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3551 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parse_core_mod&quot;      &quot;String -&gt; String -&gt; Term&quot;</span>
<span class="lineno"> 3552 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 parse_core_mod)</span>
<span class="lineno"> 3553 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Term from the second supplied String in SAWCore syntax,&quot;</span></span>
<span class="lineno"> 3555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;relative to the module specified by the first String.&quot;</span></span>
<span class="lineno"> 3556 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3557 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3558 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;load_sawcore_from_file&quot;</span>
<span class="lineno"> 3559 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3560 </span><span class="spaces">    </span><span class="istickedoff">(bicVal do_load_sawcore_from_file)</span>
<span class="lineno"> 3561 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a SAW core module from a file, using the concrete syntax&quot;</span></span>
<span class="lineno"> 3563 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parser.&quot;</span></span>
<span class="lineno"> 3564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3565 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3566 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_core&quot;           &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3567 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readCore)</span>
<span class="lineno"> 3568 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read a term from a file in the SAWCore external format.&quot; ]</span></span>
<span class="lineno"> 3570 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3571 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_core&quot;          &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3572 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_write_core)</span>
<span class="lineno"> 3573 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in SAWCore external format.&quot; ]</span></span>
<span class="lineno"> 3575 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3576 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_extcore&quot;     &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_extcore)</span></span>
<span class="lineno"> 3578 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SAWCore format.&quot; ]</span></span>
<span class="lineno"> 3580 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3581 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3582 </span><span class="spaces">    </span><span class="istickedoff">-- Theorems and theorem statements</span>
<span class="lineno"> 3583 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3584 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;qc_print&quot;            &quot;Int -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal' quickCheckPrintPrim)</span></span>
<span class="lineno"> 3586 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3587 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quick-check a term by applying it to a sequence of random inputs&quot;</span></span>
<span class="lineno"> 3588 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and print the results. The 'Int' arg specifies how many tests to&quot;</span></span>
<span class="lineno"> 3589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;run.&quot;</span></span>
<span class="lineno"> 3590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3591 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3592 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sat&quot;                 &quot;ProofScript () -&gt; Term -&gt; TopLevel SatResult&quot;</span>
<span class="lineno"> 3593 </span><span class="spaces">    </span><span class="istickedoff">(pureVal satPrim)</span>
<span class="lineno"> 3594 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiable (evaluates to true for some input). Returns a result&quot;</span></span>
<span class="lineno"> 3597 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of type 'SatResult' that can be inspected with 'caseSatResult'.&quot;</span></span>
<span class="lineno"> 3598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;It either carries a satisfying assignment or indicates&quot;</span></span>
<span class="lineno"> 3599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;unsatisfiability.&quot;</span></span>
<span class="lineno"> 3600 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3601 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3602 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sat_print&quot;           &quot;ProofScript () -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3603 </span><span class="spaces">    </span><span class="istickedoff">(pureVal satPrintPrim)</span>
<span class="lineno"> 3604 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3606 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiable (true for any input). Returns nothing if successful,&quot;</span></span>
<span class="lineno"> 3607 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and fails if unsuccessful.&quot;</span></span>
<span class="lineno"> 3608 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3610 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sharpSAT&quot;  &quot;Term -&gt; TopLevel Int&quot;</span>
<span class="lineno"> 3611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal sharpSAT)</span></span>
<span class="lineno"> 3612 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the sharpSAT solver to count the number of solutions to the&quot;</span></span>
<span class="lineno"> 3614 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CNF representation of the given Term.&quot;</span></span>
<span class="lineno"> 3615 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3616 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3617 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove&quot;               &quot;ProofScript () -&gt; Term -&gt; TopLevel ProofResult&quot;</span>
<span class="lineno"> 3618 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePrim)</span>
<span class="lineno"> 3619 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;valid (true for all inputs). Returns a ProofResult value that&quot;</span></span>
<span class="lineno"> 3622 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;can be inspected with 'caseProofResult'. It carries either a&quot;</span></span>
<span class="lineno"> 3623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proved 'Theorem' or a counterexample.&quot;</span></span>
<span class="lineno"> 3624 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3625 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3626 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_print&quot;         &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3627 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePrintPrim)</span>
<span class="lineno"> 3628 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3629 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;valid (true for all inputs). Returns a Theorem if successful,&quot;</span></span>
<span class="lineno"> 3631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and fails if unsuccessful.&quot;</span></span>
<span class="lineno"> 3632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3633 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3634 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_extcore&quot;         &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3635 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePropPrim)</span>
<span class="lineno"> 3636 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term&quot;</span></span>
<span class="lineno"> 3638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;representing a proposition is valid. This is useful for proving&quot;</span></span>
<span class="lineno"> 3639 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goals obtained with 'offline_extcore' or 'parse_core'. Returns a&quot;</span></span>
<span class="lineno"> 3640 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Theorem if successful, and fails if unsuccessful.&quot;</span></span>
<span class="lineno"> 3641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3642 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3643 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_core&quot;         &quot;ProofScript () -&gt; String -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3644 </span><span class="spaces">    </span><span class="istickedoff">(pureVal prove_core)</span>
<span class="lineno"> 3645 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 3647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;valid (true for all inputs). The term is specified as a String&quot;</span></span>
<span class="lineno"> 3648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;containing SAWCore concrete syntax. Returns a Theorem if&quot;</span></span>
<span class="lineno"> 3649 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;successful, and fails if unsuccessful.&quot;</span></span>
<span class="lineno"> 3650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3651 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3652 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;core_axiom&quot;         &quot;String -&gt; Theorem&quot;</span>
<span class="lineno"> 3653 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 core_axiom)</span>
<span class="lineno"> 3654 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare the given core expression as an axiomatic rewrite rule.&quot;</span></span>
<span class="lineno"> 3656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The input string contains a proof goal in SAWCore concrete&quot;</span></span>
<span class="lineno"> 3657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;syntax. The return value is a Theorem that may be added to a&quot;</span></span>
<span class="lineno"> 3658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Simpset.&quot;</span></span>
<span class="lineno"> 3659 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3660 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3661 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;core_thm&quot;           &quot;String -&gt; Theorem&quot;</span>
<span class="lineno"> 3662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 core_thm)</span></span>
<span class="lineno"> 3663 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a theorem from the type of the given core expression.&quot; ]</span></span>
<span class="lineno"> 3665 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3666 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;specialize_theorem&quot; &quot;Theorem -&gt; [Term] -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3667 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal specialize_theorem)</span></span>
<span class="lineno"> 3668 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specialize a theorem by instantiating universal quantifiers with&quot;</span></span>
<span class="lineno"> 3670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given list of terms.&quot;</span></span>
<span class="lineno"> 3671 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3672 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3673 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_by_bv_induction&quot;  &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3674 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveByBVInduction)</span></span>
<span class="lineno"> 3675 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3676 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Attempt to prove a fact by induction on the less-than order on&quot;</span></span>
<span class="lineno"> 3677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bitvectors. The given term is expected to be a function of one&quot;</span></span>
<span class="lineno"> 3678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or more arguments which returns a tuple containing two values:&quot;</span></span>
<span class="lineno"> 3679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first, a bitvector expression (which will be the expression we&quot;</span></span>
<span class="lineno"> 3680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;perform induction on), and second, a boolean value defining the&quot;</span></span>
<span class="lineno"> 3681 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;theorem to prove.&quot;</span></span>
<span class="lineno"> 3682 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will attempt to prove the theorem expressed in the&quot;</span></span>
<span class="lineno"> 3684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second element of the tuple by induction. The goal presented to&quot;</span></span>
<span class="lineno"> 3685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the user-provided tactic will ask to prove the stated goal and&quot;</span></span>
<span class="lineno"> 3686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will be provided with an induction hypothesis which states that&quot;</span></span>
<span class="lineno"> 3687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the goal holds for all values of the variables where the&quot;</span></span>
<span class="lineno"> 3688 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;expression given in the first element of the tuple has&quot;</span></span>
<span class="lineno"> 3689 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; decreased.&quot;</span></span>
<span class="lineno"> 3690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3691 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3692 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_bisim&quot;         (&quot;ProofScript () -&gt; [BisimTheorem] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 3693 </span><span class="spaces">                                </span><span class="istickedoff">&quot;Term -&gt; Term -&gt; Term -&gt; Term -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 3694 </span><span class="spaces">                                </span><span class="istickedoff">&quot;TopLevel BisimTheorem&quot;)</span>
<span class="lineno"> 3695 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBisimulation)</span>
<span class="lineno"> 3696 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use bisimulation to prove that two terms simulate each other.&quot;</span></span>
<span class="lineno"> 3698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The command takes the following arguments: &quot;</span></span>
<span class="lineno"> 3699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   1. The proof strategy to use&quot;</span></span>
<span class="lineno"> 3700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   2. A list of already proven bisimulation theorems&quot;</span></span>
<span class="lineno"> 3701 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   3. A state relation 'srel : lhsState -&gt; rhsState -&gt; Bit'&quot;</span></span>
<span class="lineno"> 3702 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   4. An output relation&quot;</span></span>
<span class="lineno"> 3703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      'orel : (lhsState, output) -&gt; (rhsState, output) -&gt; Bit'&quot;</span></span>
<span class="lineno"> 3704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   5. A term 'lhs : (lhsState, input) -&gt; (lhsState, output)'&quot;</span></span>
<span class="lineno"> 3705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   6. A term 'rhs : (rhsState, input) -&gt; (rhsState, output)'&quot;</span></span>
<span class="lineno"> 3706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and considers 'lhs' and 'rhs' bisimilar when the following two&quot;</span></span>
<span class="lineno"> 3707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;theorems hold:&quot;</span></span>
<span class="lineno"> 3708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   * OUTPUT RELATION THEOREM:&quot;</span></span>
<span class="lineno"> 3709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      forall s1 s2 in.&quot;</span></span>
<span class="lineno"> 3710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      srel s1 s2 -&gt; orel (lhs (s1, in)) (rhs (s2, in))&quot;</span></span>
<span class="lineno"> 3711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   * STATE RELATION THEOREM:&quot;</span></span>
<span class="lineno"> 3712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      forall s1 s2 out1 out2.&quot;</span></span>
<span class="lineno"> 3713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      orel (s1, out1) (s2, out2) -&gt; srel s1 s2&quot;</span></span>
<span class="lineno"> 3714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LIMITATIONS: For now, the prove_bisim command has a couple&quot;</span></span>
<span class="lineno"> 3716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;limitations:&quot;</span></span>
<span class="lineno"> 3717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   * 'lhs' and 'rhs' (arguments 5 and 6) must be named&quot;</span></span>
<span class="lineno"> 3718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     functions.&quot;</span></span>
<span class="lineno"> 3719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   * Each subterm present in the list of bisimulation theorems&quot;</span></span>
<span class="lineno"> 3720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     already proven (argument 2) may be invoked at most once in&quot;</span></span>
<span class="lineno"> 3721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     'lhs' or 'rhs'.&quot;</span></span>
<span class="lineno"> 3722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3723 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3724 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3725 </span><span class="spaces">    </span><span class="istickedoff">-- Proof inspection / reporting</span>
<span class="lineno"> 3726 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3727 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;summarize_verification&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3728 </span><span class="spaces">    </span><span class="istickedoff">(pureVal summarize_verification)</span>
<span class="lineno"> 3729 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print a human-readable summary of all verifications performed so&quot;</span></span>
<span class="lineno"> 3731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;far.&quot;</span></span>
<span class="lineno"> 3732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3733 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3734 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;summarize_verification_json&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_summarize_verification_json)</span></span>
<span class="lineno"> 3736 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print a JSON summary of all verifications performed so far into&quot;</span></span>
<span class="lineno"> 3738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the named file.&quot;</span></span>
<span class="lineno"> 3739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3740 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3741 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3742 </span><span class="spaces">    </span><span class="istickedoff">-- Simplification sets</span>
<span class="lineno"> 3743 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3744 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;empty_ss&quot;            &quot;Simpset&quot;</span>
<span class="lineno"> 3745 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (emptySimpset :: SAWSimpset))</span>
<span class="lineno"> 3746 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The empty simplification rule set, containing no rules.&quot; ]</span></span>
<span class="lineno"> 3748 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3749 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp&quot;             &quot;Theorem -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3750 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addsimp)</span>
<span class="lineno"> 3751 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved equality theorem to a simplification rule set,&quot;</span></span>
<span class="lineno"> 3753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and return a new set.&quot;</span></span>
<span class="lineno"> 3754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3755 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3756 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp_shallow&quot;    &quot;Theorem -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimp_shallow)</span></span>
<span class="lineno"> 3758 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved equality theorem to a simplification rule set.&quot;</span></span>
<span class="lineno"> 3760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The rule is treated as a 'shallow' rewrite, which means that&quot;</span></span>
<span class="lineno"> 3761 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;further rewrite rules will not be applied to the result if this&quot;</span></span>
<span class="lineno"> 3762 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;rule fires. Returns a new set.n&quot;</span></span>
<span class="lineno"> 3763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3764 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3765 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimps&quot;            &quot;[Theorem] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3766 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addsimps)</span>
<span class="lineno"> 3767 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3768 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add multiple proved equality theorems to a simplification rule&quot;</span></span>
<span class="lineno"> 3769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;set. Returns a new set.&quot;</span></span>
<span class="lineno"> 3770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3771 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3772 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp'&quot;            &quot;Term -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimp')</span></span>
<span class="lineno"> 3774 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 3775 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add an arbitrary equality term to a simplification rule set.&quot;</span></span>
<span class="lineno"> 3776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Deprecated; use 'admit' or 'core_axiom' and 'addsimp' instead.&quot;</span></span>
<span class="lineno"> 3777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be removed in SAW 1.5.&quot;</span></span>
<span class="lineno"> 3779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3780 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3781 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimps'&quot;           &quot;[Term] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimps')</span></span>
<span class="lineno"> 3783 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 3784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add multiple arbitrary equality terms to a simplification rule&quot;</span></span>
<span class="lineno"> 3785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;set. Deprecated; use 'admit' or 'core_axiom' and 'addsimps'&quot;</span></span>
<span class="lineno"> 3786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;instead.&quot;</span></span>
<span class="lineno"> 3787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be removed in SAW 1.5.&quot;</span></span>
<span class="lineno"> 3789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3790 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3791 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;basic_ss&quot;            &quot;Simpset&quot;</span>
<span class="lineno"> 3792 </span><span class="spaces">    </span><span class="istickedoff">(bicVal $ \bic _ -&gt; toValue <span class="nottickedoff">&quot;basic_ss&quot;</span> $ biBasicSS bic)</span>
<span class="lineno"> 3793 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A basic rewriting simplification set containing some boolean&quot;</span></span>
<span class="lineno"> 3795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;identities and conversions relating to bitvectors, natural&quot;</span></span>
<span class="lineno"> 3796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;numbers, and vectors.&quot;</span></span>
<span class="lineno"> 3797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3799 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_ss&quot;          &quot;() -&gt; Simpset&quot;</span>
<span class="lineno"> 3800 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (\ () -&gt; cryptolSimpset))</span>
<span class="lineno"> 3801 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A set of simplification rules that will expand definitions from&quot;</span></span>
<span class="lineno"> 3803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the Cryptol import module.&quot;</span></span>
<span class="lineno"> 3804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3805 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3806 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_prelude_eqs&quot;     &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3807 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addPreludeEqs)</span>
<span class="lineno"> 3808 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named equality rules from the Prelude module to a&quot;</span></span>
<span class="lineno"> 3810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set, and return a new set.&quot;</span></span>
<span class="lineno"> 3811 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3812 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3813 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_cryptol_eqs&quot;     &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addCryptolEqs)</span></span>
<span class="lineno"> 3815 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named equality rules from the Cryptol import module to a&quot;</span></span>
<span class="lineno"> 3817 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set, and return a new set.&quot;</span></span>
<span class="lineno"> 3818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3819 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3820 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_prelude_defs&quot;    &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 add_prelude_defs)</span></span>
<span class="lineno"> 3822 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named definitions from the Prelude module to a&quot;</span></span>
<span class="lineno"> 3824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set, and return a new set.&quot;</span></span>
<span class="lineno"> 3825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3827 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_cryptol_defs&quot;    &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 3828 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 add_cryptol_defs)</span>
<span class="lineno"> 3829 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named definitions from the Cryptol import module to a&quot;</span></span>
<span class="lineno"> 3831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set, and return a new set.&quot;</span></span>
<span class="lineno"> 3832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3833 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3834 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3835 </span><span class="spaces">    </span><span class="istickedoff">-- Inspection proof tactics</span>
<span class="lineno"> 3836 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3837 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num&quot; &quot;ProofScript Int&quot;</span>
<span class="lineno"> 3838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_num)</span></span>
<span class="lineno"> 3839 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3840 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns the number of the current proof goal.&quot; ]</span></span>
<span class="lineno"> 3841 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3842 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3843 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_goal)</span>
<span class="lineno"> 3844 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to&quot;</span></span>
<span class="lineno"> 3846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove.&quot;</span></span>
<span class="lineno"> 3847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3848 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3849 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_inline&quot;   &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_goal_inline)</span></span>
<span class="lineno"> 3851 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to&quot;</span></span>
<span class="lineno"> 3853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove, without generating 'let' bindings for the provided&quot;</span></span>
<span class="lineno"> 3854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;indices. For example, 'print_goal_inline [1,9,3]' will print the&quot;</span></span>
<span class="lineno"> 3855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goal without inlining the variables that would otherwise be&quot;</span></span>
<span class="lineno"> 3856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;abstracted as 'x@1', 'x@9', and 'x@3'. These indices are&quot;</span></span>
<span class="lineno"> 3857 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;assigned deterministically for any given goal, but are not&quot;</span></span>
<span class="lineno"> 3858 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;persistent across goals. Therefore, such, this command should be&quot;</span></span>
<span class="lineno"> 3859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;used primarily for proof debugging.&quot;</span></span>
<span class="lineno"> 3860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: incompatible with non-incremental memoization strategies -&quot;</span></span>
<span class="lineno"> 3862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;see 'set_memoization_incremental' and&quot;</span></span>
<span class="lineno"> 3863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'set_memoization_hash_incremental'.&quot;</span></span>
<span class="lineno"> 3864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3865 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3866 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_depth&quot;    &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_goal_depth)</span></span>
<span class="lineno"> 3868 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to&quot;</span></span>
<span class="lineno"> 3870 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove, limited to a maximum depth.&quot;</span></span>
<span class="lineno"> 3871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3873 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_size&quot;     &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal printGoalSize)</span></span>
<span class="lineno"> 3875 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the size of the goal in terms of both the number of DAG&quot;</span></span>
<span class="lineno"> 3877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nodes and the number of nodes it would have if represented as a&quot;</span></span>
<span class="lineno"> 3878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;tree.&quot;</span></span>
<span class="lineno"> 3879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3880 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3881 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_goal&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_goal)</span></span>
<span class="lineno"> 3883 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal that a proof script is attempting to&quot;</span></span>
<span class="lineno"> 3885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove into the named file.&quot;</span></span>
<span class="lineno"> 3886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3887 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3888 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_summary&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3889 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_goal_summary)</span>
<span class="lineno"> 3890 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the number and description of the goal that a proof script&quot;</span></span>
<span class="lineno"> 3892 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is attempting to prove.&quot;</span></span>
<span class="lineno"> 3893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3894 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3895 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_consts&quot;   &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal printGoalConsts)</span></span>
<span class="lineno"> 3897 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3898 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the list of unfoldable constants in the current proof&quot;</span></span>
<span class="lineno"> 3899 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goal.&quot;</span></span>
<span class="lineno"> 3900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3901 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3902 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3903 </span><span class="spaces">    </span><span class="istickedoff">(pureVal check_goal)</span>
<span class="lineno"> 3904 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type-check the current proof goal, printing an error message if&quot;</span></span>
<span class="lineno"> 3906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;ill-typed. Also see 'check_term'.&quot;</span></span>
<span class="lineno"> 3907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3908 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3909 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3910 </span><span class="spaces">    </span><span class="istickedoff">-- Decomposition-related proof tactics</span>
<span class="lineno"> 3911 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3912 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;split_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal split_goal)</span></span>
<span class="lineno"> 3914 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Split a goal of the form 'Prelude.and prop1 prop2' into two&quot;</span></span>
<span class="lineno"> 3916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;separate goals 'prop1' and 'prop2'.&quot;</span></span>
<span class="lineno"> 3917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3918 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3919 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_cut&quot; &quot;Term -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_cut)</span></span>
<span class="lineno"> 3921 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3922 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term provided by the user (which must be a boolean&quot;</span></span>
<span class="lineno"> 3923 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;expression or a Prop) the current goal is split into two&quot;</span></span>
<span class="lineno"> 3924 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;subgoals. In the first subgoal, the given proposition is assumed&quot;</span></span>
<span class="lineno"> 3925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as a new hypothesis. In the second subgoal, the given&quot;</span></span>
<span class="lineno"> 3926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proposition is a new focused, conclusion. This implements the&quot;</span></span>
<span class="lineno"> 3927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;usual cut rule of sequent calculus.&quot;</span></span>
<span class="lineno"> 3928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3929 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3930 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3931 </span><span class="spaces">    </span><span class="istickedoff">-- Evaluation-related proof tactics</span>
<span class="lineno"> 3932 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3933 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfolding&quot;           &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3934 </span><span class="spaces">    </span><span class="istickedoff">(pureVal unfoldGoal)</span>
<span class="lineno"> 3935 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3936 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the named subterm(s) within the current goal.&quot;</span></span>
<span class="lineno"> 3937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Also see 'unfold_term'.&quot;</span></span>
<span class="lineno"> 3938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3939 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3940 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfolding_fix_once&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3941 </span><span class="spaces">    </span><span class="istickedoff">(pureVal unfoldFixOnceGoal)</span>
<span class="lineno"> 3942 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3943 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the named recursive constants once within the current&quot;</span></span>
<span class="lineno"> 3944 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goal. Like 'unfolding', except that the recursive constants are&quot;</span></span>
<span class="lineno"> 3945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;unfolded only once, avoiding possible infinite evaluation.&quot;</span></span>
<span class="lineno"> 3946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3947 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3948 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;simplify&quot;            &quot;Simpset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3949 </span><span class="spaces">    </span><span class="istickedoff">(pureVal simplifyGoal)</span>
<span class="lineno"> 3950 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3951 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given simplification rule set to the current goal.&quot; ]</span></span>
<span class="lineno"> 3952 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3953 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;simplify_local&quot;       &quot;[Int] -&gt; Simpset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal simplifyGoalWithLocals)</span></span>
<span class="lineno"> 3955 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given simplification rule set to the current goal.&quot;</span></span>
<span class="lineno"> 3957 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Also, use the given numbered hypotheses as rewrites.&quot;</span></span>
<span class="lineno"> 3958 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3959 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3960 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_normalize&quot;  &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3961 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_normalize)</span>
<span class="lineno"> 3962 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the current proof goal by performing evaluation in&quot;</span></span>
<span class="lineno"> 3964 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAWCore. The currently-focused term will be evaluated. If the&quot;</span></span>
<span class="lineno"> 3965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;sequent is unfocused, all terms will be evaluated. The names&quot;</span></span>
<span class="lineno"> 3966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given in the argument will be treated as uninterpreted.&quot;</span></span>
<span class="lineno"> 3967 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Also see 'normalize_term'.&quot;</span></span>
<span class="lineno"> 3968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3969 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3970 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_eval&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3971 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (goal_eval []))</span>
<span class="lineno"> 3972 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the proof goal to a first-order combination of&quot;</span></span>
<span class="lineno"> 3974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;primitives.&quot;</span></span>
<span class="lineno"> 3975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3976 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3977 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_eval_unint&quot;     &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 3978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_eval)</span></span>
<span class="lineno"> 3979 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the proof goal to a first-order combination of&quot;</span></span>
<span class="lineno"> 3981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;primitives. Leave the given list of names uninterpreted.&quot;</span></span>
<span class="lineno"> 3982 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3983 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3984 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 3985 </span><span class="spaces">    </span><span class="istickedoff">-- Rewriting-related proof tactics</span>
<span class="lineno"> 3986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3987 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;hoist_ifs_in_goal&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3988 </span><span class="spaces">    </span><span class="istickedoff">(pureVal hoistIfsInGoalPrim)</span>
<span class="lineno"> 3989 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Hoist ifs in the current proof goal.&quot; ]</span></span>
<span class="lineno"> 3991 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3992 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;beta_reduce_goal&quot;    &quot;ProofScript ()&quot;</span>
<span class="lineno"> 3993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal beta_reduce_goal)</span></span>
<span class="lineno"> 3994 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3995 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Reduce the current goal to beta-normal form.&quot; ]</span></span>
<span class="lineno"> 3996 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3997 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro&quot;          &quot;String -&gt; ProofScript Term&quot;</span>
<span class="lineno"> 3998 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_intro)</span>
<span class="lineno"> 3999 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Introduce a quantified variable in the current proof goal,&quot;</span></span>
<span class="lineno"> 4001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returning the variable as a Term.&quot;</span></span>
<span class="lineno"> 4002 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4003 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4004 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_sequent&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal normalize_sequent)</span></span>
<span class="lineno"> 4006 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the current goal sequent by applying reversable&quot;</span></span>
<span class="lineno"> 4008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;sequent calculus rules. The resulting sequent will be unfocused.&quot;</span></span>
<span class="lineno"> 4009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4010 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4011 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4012 </span><span class="spaces">    </span><span class="istickedoff">-- Premise-related proof tactics</span>
<span class="lineno"> 4013 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4014 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;retain_hyps&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4015 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal retain_hyps)</span></span>
<span class="lineno"> 4016 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all hypotheses from the current sequent other than the&quot;</span></span>
<span class="lineno"> 4018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; ones listed.&quot;</span></span>
<span class="lineno"> 4019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4021 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;delete_hyps&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4022 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal delete_hyps)</span></span>
<span class="lineno"> 4023 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove the numbered hypotheses from the current sequent.&quot; ]</span></span>
<span class="lineno"> 4025 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4026 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro_hyp&quot;      &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4027 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_intro_hyp)</span></span>
<span class="lineno"> 4028 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4029 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion that represents an implication,&quot;</span></span>
<span class="lineno"> 4030 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplify the conclusion by removing the implication and&quot;</span></span>
<span class="lineno"> 4031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;introducing a new sequent hypothesis instead.&quot;</span></span>
<span class="lineno"> 4032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4033 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4034 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro_hyps&quot;     &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_intro_hyps)</span></span>
<span class="lineno"> 4036 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion that represents an implication,&quot;</span></span>
<span class="lineno"> 4038 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplify the conclusion by removing the implication and&quot;</span></span>
<span class="lineno"> 4039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;introducing a new sequent hypothesis instead. The argument gives&quot;</span></span>
<span class="lineno"> 4040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;how many hypotheses to introduce.&quot;</span></span>
<span class="lineno"> 4041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4042 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4043 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_revert_hyp&quot;     &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4044 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_revert_hyp)</span></span>
<span class="lineno"> 4045 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4046 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion, weaken the focused conclusion&quot;</span></span>
<span class="lineno"> 4047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by introducing an implication using the numbered sequent&quot;</span></span>
<span class="lineno"> 4048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hypothesis. This is essentially the reverse of&quot;</span></span>
<span class="lineno"> 4049 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'goal_intro_hyp'.&quot;</span></span>
<span class="lineno"> 4050 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4051 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4052 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_insert&quot;         &quot;Theorem -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4053 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_insert)</span>
<span class="lineno"> 4054 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Insert a Theorem as a new hypothesis in the current proof goal.&quot;</span></span>
<span class="lineno"> 4056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4057 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4058 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_insert_and_specialize&quot;  &quot;Theorem -&gt; [Term] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4059 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_insert_and_specialize)</span></span>
<span class="lineno"> 4060 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Insert a Theorem as a new hypothesis in the current proof goal,&quot;</span></span>
<span class="lineno"> 4062 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;after specializing some of its universal quantifiers using the&quot;</span></span>
<span class="lineno"> 4063 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given terms.&quot;</span></span>
<span class="lineno"> 4064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4065 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4066 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_specialize_hyp&quot; &quot;[Term] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_specialize_hyp)</span></span>
<span class="lineno"> 4068 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4069 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specialize the focused local hypothesis by supplying the values&quot;</span></span>
<span class="lineno"> 4070 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for universal quantifiers. A new specialized hypothesis will be&quot;</span></span>
<span class="lineno"> 4071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;added to the sequent.&quot;</span></span>
<span class="lineno"> 4072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4073 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4074 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_apply_hyp&quot;      &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4075 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_apply_hyp)</span></span>
<span class="lineno"> 4076 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4077 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the numbered local hypothesis to the focused conclusion.&quot; ]</span></span>
<span class="lineno"> 4078 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4079 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_apply&quot;          &quot;Theorem -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4080 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_apply)</span>
<span class="lineno"> 4081 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4082 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply an introduction rule to the current goal. Depending on the&quot;</span></span>
<span class="lineno"> 4083 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;rule, this will result in zero or more new subgoals.&quot;</span></span>
<span class="lineno"> 4084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4085 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4086 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4087 </span><span class="spaces">    </span><span class="istickedoff">-- Automation-related proof tactics</span>
<span class="lineno"> 4088 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4089 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_when&quot;           &quot;String -&gt; ProofScript () -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_when)</span></span>
<span class="lineno"> 4091 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4092 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given proof script only when the goal name contains the&quot;</span></span>
<span class="lineno"> 4093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given string.&quot;</span></span>
<span class="lineno"> 4094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4095 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4096 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num_when&quot;       &quot;Int -&gt; ProofScript () -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_num_when)</span></span>
<span class="lineno"> 4098 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4099 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given proof script only when the goal number is the&quot;</span></span>
<span class="lineno"> 4100 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given number.&quot;</span></span>
<span class="lineno"> 4101 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4102 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4103 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num_ite&quot;       (&quot;{a} Int -&gt; ProofScript a -&gt; ProofScript a&quot; &lt;&gt;</span>
<span class="lineno"> 4104 </span><span class="spaces">                               </span><span class="istickedoff">&quot;-&gt; ProofScript a&quot;)</span>
<span class="lineno"> 4105 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_num_ite)</span>
<span class="lineno"> 4106 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;If the goal number is the given number, runs the first script.&quot;</span></span>
<span class="lineno"> 4108 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Otherwise runs the second script.&quot;</span></span>
<span class="lineno"> 4109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4110 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4111 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_has_tags&quot;      &quot;[String] -&gt; ProofScript Bool&quot;</span>
<span class="lineno"> 4112 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_has_tags)</span>
<span class="lineno"> 4113 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true if the current goal is tagged with all the tags&quot;</span></span>
<span class="lineno"> 4115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the given list. This function returns true for all goals&quot;</span></span>
<span class="lineno"> 4116 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when given an empty list. Tags may be added to goals using&quot;</span></span>
<span class="lineno"> 4117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_setup_with_tag' and similar operations in the&quot;</span></span>
<span class="lineno"> 4118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification setup phase.&quot;</span></span>
<span class="lineno"> 4119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4120 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4121 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_has_some_tag&quot;  &quot;[String] -&gt; ProofScript Bool&quot;</span>
<span class="lineno"> 4122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_has_some_tag)</span></span>
<span class="lineno"> 4123 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true if the current goal is tagged with any the tags&quot;</span></span>
<span class="lineno"> 4125 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the given list. This function returns false for all goals&quot;</span></span>
<span class="lineno"> 4126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when given an empty list. Tags may be added to goals using&quot;</span></span>
<span class="lineno"> 4127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_setup_with_tag' and similar operations in the&quot;</span></span>
<span class="lineno"> 4128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification setup phase.&quot;</span></span>
<span class="lineno"> 4129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4131 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4132 </span><span class="spaces">    </span><span class="istickedoff">-- Focus-related proof tactics</span>
<span class="lineno"> 4133 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4134 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfocus&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal unfocus)</span></span>
<span class="lineno"> 4136 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove any sequent focus point.&quot; ]</span></span>
<span class="lineno"> 4138 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4139 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;focus_concl&quot;      &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal focus_concl)</span></span>
<span class="lineno"> 4141 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Focus on the numbered conclusion within a sequent. This will&quot;</span></span>
<span class="lineno"> 4143 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fail if there are not enough conclusions.&quot;</span></span>
<span class="lineno"> 4144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4145 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4146 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;focus_hyp&quot;       &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal focus_hyp)</span></span>
<span class="lineno"> 4148 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Focus on the numbered hypothesis with a sequent.  This will fail&quot;</span></span>
<span class="lineno"> 4150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if there are not enough hypotheses.&quot;</span></span>
<span class="lineno"> 4151 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4152 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4153 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_focus&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_focus)</span></span>
<span class="lineno"> 4155 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4156 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print just the focused part of the current goal. Prints a&quot;</span></span>
<span class="lineno"> 4157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;message without failing if there is no current focus.&quot;</span></span>
<span class="lineno"> 4158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4159 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4160 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4161 </span><span class="spaces">    </span><span class="istickedoff">-- Miscellaneous proof tactics</span>
<span class="lineno"> 4162 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4163 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;quickcheck&quot;          &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4164 </span><span class="spaces">    </span><span class="istickedoff">(scVal quickcheckGoal)</span>
<span class="lineno"> 4165 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quick-check the current goal by applying it to a sequence of&quot;</span></span>
<span class="lineno"> 4167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;random inputs. Fail the proof script if the goal returns 'False'&quot;</span></span>
<span class="lineno"> 4168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for any of these inputs.&quot;</span></span>
<span class="lineno"> 4169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4170 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4171 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;trivial&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4172 </span><span class="spaces">    </span><span class="istickedoff">(pureVal trivial)</span>
<span class="lineno"> 4173 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Succeeds if the goal is trivial. This tactic recognizes goals&quot;</span></span>
<span class="lineno"> 4175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that are instances of reflexivity, possibly with quantified&quot;</span></span>
<span class="lineno"> 4176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables. In particular, it will prove goals of the form&quot;</span></span>
<span class="lineno"> 4177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'EqTrue x' when 'x' reduces to the constant value 'True'.&quot;</span></span>
<span class="lineno"> 4178 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4179 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4180 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_exact&quot;          &quot;Term -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_exact)</span></span>
<span class="lineno"> 4182 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal by giving an explicit proof term. This&quot;</span></span>
<span class="lineno"> 4184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will succeed if the type of the given term matches the current&quot;</span></span>
<span class="lineno"> 4185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goal.&quot;</span></span>
<span class="lineno"> 4186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4187 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4188 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;assume_valid&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4189 </span><span class="spaces">    </span><span class="istickedoff">(pureVal assumeValid)</span>
<span class="lineno"> 4190 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4191 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume the current goal is valid, completing the proof.&quot;</span></span>
<span class="lineno"> 4192 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will eventually be removed. Use 'admit' instead.&quot;</span></span>
<span class="lineno"> 4193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4194 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4195 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;assume_unsat&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4196 </span><span class="spaces">    </span><span class="istickedoff">(pureVal assumeUnsat)</span>
<span class="lineno"> 4197 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume the current goal is unsatisfiable, completing the proof.&quot;</span></span>
<span class="lineno"> 4199 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will eventually be removed. Use 'admit' instead.&quot;</span></span>
<span class="lineno"> 4200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4201 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4202 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;admit&quot;               &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4203 </span><span class="spaces">    </span><span class="istickedoff">(pureVal admitProof)</span>
<span class="lineno"> 4204 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Admit the current goal, completing the proof by assumption.&quot;</span></span>
<span class="lineno"> 4206 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The string argument should give an explanation of the decision&quot;</span></span>
<span class="lineno"> 4207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to admit this goal.&quot;</span></span>
<span class="lineno"> 4208 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4209 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4210 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;retain_concl&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal retain_concl)</span></span>
<span class="lineno"> 4212 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all conclusions from the current sequent other than the&quot;</span></span>
<span class="lineno"> 4214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; ones listed.&quot;</span></span>
<span class="lineno"> 4215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4216 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4217 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;delete_concl&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4218 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal delete_concl)</span></span>
<span class="lineno"> 4219 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove the numbered conclusions from the current sequent.&quot; ]</span></span>
<span class="lineno"> 4221 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4222 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4223 </span><span class="spaces">    </span><span class="istickedoff">-- Solvers</span>
<span class="lineno"> 4224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4225 </span><span class="spaces">    </span><span class="istickedoff">-- abc</span>
<span class="lineno"> 4226 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4227 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;abc&quot;                 &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4228 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_abc_aiger)</span>
<span class="lineno"> 4229 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4231 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4232 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_abc&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveABC_SBV)</span></span>
<span class="lineno"> 4234 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4236 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4237 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_aiger&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_abc_aiger)</span></span>
<span class="lineno"> 4239 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 4241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with AIGER as an interchange format, generated&quot;</span></span>
<span class="lineno"> 4242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 4243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4244 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4245 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_smtlib2&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_abc_smtlib2)</span></span>
<span class="lineno"> 4247 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 4249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with SMT-Lib2 as an interchange format, generated&quot;</span></span>
<span class="lineno"> 4250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 4251 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4252 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4253 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_verilog&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4254 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_abc_verilog)</span>
<span class="lineno"> 4255 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 4257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with Verilog as an interchange format, generated&quot;</span></span>
<span class="lineno"> 4258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 4259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4260 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4261 </span><span class="spaces">    </span><span class="istickedoff">-- bitwuzla</span>
<span class="lineno"> 4262 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4263 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;bitwuzla&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4264 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBitwuzla)</span>
<span class="lineno"> 4265 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4268 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4269 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintBitwuzla)</span></span>
<span class="lineno"> 4270 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal. Leave&quot;</span></span>
<span class="lineno"> 4272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4274 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4275 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_bitwuzla&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4276 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBitwuzla)</span>
<span class="lineno"> 4277 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4279 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4280 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintBitwuzla)</span></span>
<span class="lineno"> 4282 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4283 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal. Leave&quot;</span></span>
<span class="lineno"> 4284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4286 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4287 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4288 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_bitwuzla)</span>
<span class="lineno"> 4289 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Bitwuzla backend). Leave the&quot;</span></span>
<span class="lineno"> 4291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4293 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4294 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_bitwuzla&quot; &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_bitwuzla)</span></span>
<span class="lineno"> 4296 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4297 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Bitwuzla&quot;</span></span>
<span class="lineno"> 4298 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;backend) in SMT-Lib2 format. Leave the given list of names as&quot;</span></span>
<span class="lineno"> 4299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted.&quot;</span></span>
<span class="lineno"> 4300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4301 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4302 </span><span class="spaces">    </span><span class="istickedoff">-- boolector</span>
<span class="lineno"> 4303 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4304 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;boolector&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveBoolector)</span></span>
<span class="lineno"> 4306 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Boolector theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4308 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4309 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_boolector&quot;       &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4310 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveBoolector)</span></span>
<span class="lineno"> 4311 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4312 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Boolector theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4313 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4314 </span><span class="spaces">    </span><span class="istickedoff">-- cvc4/5</span>
<span class="lineno"> 4315 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4316 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cvc4&quot;                &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4317 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveCVC4)</span>
<span class="lineno"> 4318 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4320 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4321 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cvc5&quot;                &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC5)</span></span>
<span class="lineno"> 4323 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4326 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_cvc4&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC4)</span></span>
<span class="lineno"> 4328 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4329 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 4330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4332 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4333 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_cvc5&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC5)</span></span>
<span class="lineno"> 4335 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 4337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4338 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4340 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_cvc4&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC4)</span></span>
<span class="lineno"> 4342 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4344 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4345 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_cvc5&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC5)</span></span>
<span class="lineno"> 4347 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4349 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4350 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_cvc4&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC4)</span></span>
<span class="lineno"> 4352 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4353 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 4354 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4355 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4356 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4357 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_cvc5&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC5)</span></span>
<span class="lineno"> 4359 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 4361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4363 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4364 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_cvc4&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_unint_cvc4)</span></span>
<span class="lineno"> 4366 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (CVC4 backend). Leave the&quot;</span></span>
<span class="lineno"> 4368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4369 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4370 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4371 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_cvc5&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4372 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_cvc5)</span>
<span class="lineno"> 4373 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (CVC5 backend). Leave the&quot;</span></span>
<span class="lineno"> 4375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4376 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4377 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4378 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_cvc4&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_cvc4)</span></span>
<span class="lineno"> 4380 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (CVC4&quot;</span></span>
<span class="lineno"> 4382 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;backend) in SMT-Lib2 format. Leave the given list of names&quot;</span></span>
<span class="lineno"> 4383 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted.&quot;</span></span>
<span class="lineno"> 4384 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4385 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4386 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_cvc5&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_cvc5)</span></span>
<span class="lineno"> 4388 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (CVC5&quot;</span></span>
<span class="lineno"> 4390 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;backend) in SMT-Lib2 format. Leave the given list of names&quot;</span></span>
<span class="lineno"> 4391 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted.&quot;</span></span>
<span class="lineno"> 4392 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4393 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4394 </span><span class="spaces">    </span><span class="istickedoff">-- mathsat</span>
<span class="lineno"> 4395 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4396 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mathsat&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4397 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveMathSAT)</span></span>
<span class="lineno"> 4398 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the MathSAT theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4400 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4401 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_mathsat&quot;         &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4402 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveMathSAT)</span></span>
<span class="lineno"> 4403 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the MathSAT theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4405 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4406 </span><span class="spaces">    </span><span class="istickedoff">-- rme</span>
<span class="lineno"> 4407 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4408 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;rme&quot;                 &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4409 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveRME)</span>
<span class="lineno"> 4410 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal by expansion to Reed-Muller Normal Form.&quot; ]</span></span>
<span class="lineno"> 4412 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4413 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_rme&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4414 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_rme)</span>
<span class="lineno"> 4415 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4416 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (RME backend). Leave the&quot;</span></span>
<span class="lineno"> 4417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4419 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4420 </span><span class="spaces">    </span><span class="istickedoff">-- yices</span>
<span class="lineno"> 4421 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4422 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yices&quot;               &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4423 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveYices)</span>
<span class="lineno"> 4424 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4425 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4426 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4427 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_yices&quot;           &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4428 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintYices)</span>
<span class="lineno"> 4429 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal. Leave&quot;</span></span>
<span class="lineno"> 4431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4432 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4433 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4434 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_yices&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4435 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveYices)</span></span>
<span class="lineno"> 4436 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4437 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4438 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4439 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_yices&quot;       &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4440 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintYices)</span></span>
<span class="lineno"> 4441 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal. Leave&quot;</span></span>
<span class="lineno"> 4443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4444 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4445 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4446 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_yices&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4447 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_yices)</span>
<span class="lineno"> 4448 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4449 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Yices backend). Leave the&quot;</span></span>
<span class="lineno"> 4450 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 4451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4452 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4453 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_yices&quot; &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_yices)</span></span>
<span class="lineno"> 4455 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Yices&quot;</span></span>
<span class="lineno"> 4457 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;backend) in SMT-Lib2 format. Leave the given list of names&quot;</span></span>
<span class="lineno"> 4458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted.&quot;</span></span>
<span class="lineno"> 4459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4461 </span><span class="spaces">    </span><span class="istickedoff">-- z3</span>
<span class="lineno"> 4462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4463 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;z3&quot;                  &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4464 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveZ3)</span>
<span class="lineno"> 4465 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4466 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4467 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4468 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_z3&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4469 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintZ3)</span>
<span class="lineno"> 4470 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 4472 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names uninterpreted.&quot;</span></span>
<span class="lineno"> 4473 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4474 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4475 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_z3&quot;              &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4476 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveZ3)</span>
<span class="lineno"> 4477 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 4479 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4480 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_z3&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4481 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintZ3)</span>
<span class="lineno"> 4482 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4483 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 4484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names uninterpreted.&quot;</span></span>
<span class="lineno"> 4485 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4486 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4487 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4&quot;                  &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4488 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_z3)</span>
<span class="lineno"> 4489 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend).&quot; ]</span></span>
<span class="lineno"> 4491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4492 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_z3&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4493 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_z3)</span>
<span class="lineno"> 4494 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend). Leave the given&quot;</span></span>
<span class="lineno"> 4496 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;list of names uninterpreted.&quot;</span></span>
<span class="lineno"> 4497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4498 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4499 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_z3_using&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4500 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_z3_using)</span>
<span class="lineno"> 4501 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend) using the given&quot;</span></span>
<span class="lineno"> 4503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Z3 tactic. Leave the given list of names uninterpreted.&quot;</span></span>
<span class="lineno"> 4504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4506 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_z3&quot;    &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_w4_unint_z3)</span></span>
<span class="lineno"> 4508 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Z3&quot;</span></span>
<span class="lineno"> 4510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;backend) in SMT-Lib2 format. Leave the given list of names&quot;</span></span>
<span class="lineno"> 4511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted.&quot;</span></span>
<span class="lineno"> 4512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4513 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4514 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4515 </span><span class="spaces">    </span><span class="istickedoff">-- And-inverter graphs (AIGs)</span>
<span class="lineno"> 4516 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4517 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;load_aig&quot;            &quot;String -&gt; TopLevel AIG&quot;</span>
<span class="lineno"> 4518 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal loadAIGPrim)</span></span>
<span class="lineno"> 4519 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4520 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an AIG file in binary AIGER format, yielding an AIG value.&quot; ]</span></span>
<span class="lineno"> 4521 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4522 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_aig&quot;            &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4523 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readAIGPrim)</span>
<span class="lineno"> 4524 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an AIG file in AIGER format and translate to a term.&quot; ]</span></span>
<span class="lineno"> 4526 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4527 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;save_aig&quot;            &quot;String -&gt; AIG -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal saveAIGPrim)</span></span>
<span class="lineno"> 4529 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write an AIG to a file in binary AIGER format.&quot; ]</span></span>
<span class="lineno"> 4531 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4532 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;save_aig_as_cnf&quot;     &quot;String -&gt; AIG -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal saveAIGasCNFPrim)</span></span>
<span class="lineno"> 4534 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write an AIG representing a boolean function to a file in DIMACS&quot;</span></span>
<span class="lineno"> 4536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CNF format.&quot;</span></span>
<span class="lineno"> 4537 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4538 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4539 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_aig&quot;           &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4540 </span><span class="spaces">    </span><span class="istickedoff">(pureVal writeAIGPrim)</span>
<span class="lineno"> 4541 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4542 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 4543 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 4544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits.&quot;</span></span>
<span class="lineno"> 4545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4546 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4547 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_aig_external&quot;  &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal doWriteAIGviaVerilog)</span></span>
<span class="lineno"> 4549 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 4551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 4552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits. Uses ABC to convert an&quot;</span></span>
<span class="lineno"> 4553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 4554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4555 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4556 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_saig&quot;          &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4557 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeSAIGPrim)</span></span>
<span class="lineno"> 4558 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 4560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 4561 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits. The type must be of the form&quot;</span></span>
<span class="lineno"> 4562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'(i, s) -&gt; (o, s)' and is interpreted as an&quot;</span></span>
<span class="lineno"> 4563 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'[|i| + |s|] -&gt; [|o| + |s|]' AIG with '|s|' latches.&quot;</span></span>
<span class="lineno"> 4564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Arguments:&quot;</span></span>
<span class="lineno"> 4566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   file to write : String&quot;</span></span>
<span class="lineno"> 4567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   function to translate to sequential AIG : Term&quot;</span></span>
<span class="lineno"> 4568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4569 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4570 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_saig'&quot;         &quot;String -&gt; Term -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4571 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeSAIGComputedPrim)</span></span>
<span class="lineno"> 4572 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 4574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 4575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits, '[m] -&gt; [n]'. The int argument,&quot;</span></span>
<span class="lineno"> 4576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'k', must be at most 'min {m, n}', and specifies that the *last*&quot;</span></span>
<span class="lineno"> 4577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'k' input and output bits are joined as latches.&quot;</span></span>
<span class="lineno"> 4578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Arguments:&quot;</span></span>
<span class="lineno"> 4580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   file to write : String&quot;</span></span>
<span class="lineno"> 4581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   function to translate to sequential AIG : Term&quot;</span></span>
<span class="lineno"> 4582 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   number of latches : Int&quot;</span></span>
<span class="lineno"> 4583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4584 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4585 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;bitblast&quot;            &quot;Term -&gt; TopLevel AIG&quot;</span>
<span class="lineno"> 4586 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal bbPrim)</span></span>
<span class="lineno"> 4587 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4588 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a term into an AIG.  The term must be representable as&quot;</span></span>
<span class="lineno"> 4589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a function from a finite number of bits to a finite number of&quot;</span></span>
<span class="lineno"> 4590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits.&quot;</span></span>
<span class="lineno"> 4591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4592 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4593 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;dsec_print&quot;                &quot;Term -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal dsecPrint)</span></span>
<span class="lineno"> 4595 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use ABC's 'dsec' command to compare two terms as SAIGs.&quot;</span></span>
<span class="lineno"> 4597 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The terms must have a type as described in ':help write_saig',&quot;</span></span>
<span class="lineno"> 4599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;i.e. of the form '(i, s) -&gt; (o, s)'. Note that nothing is&quot;</span></span>
<span class="lineno"> 4600 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned: you must read the output to see what happened.&quot;</span></span>
<span class="lineno"> 4601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4602 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;You must have an 'abc' executable on your PATH to use this&quot;</span></span>
<span class="lineno"> 4603 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;command.&quot;</span></span>
<span class="lineno"> 4604 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4605 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4606 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;external_aig_solver&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4607 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (satExternal False))</span></span>
<span class="lineno"> 4608 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4609 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use an external SAT solver supporting AIG to prove the current&quot;</span></span>
<span class="lineno"> 4610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goal. The first argument is the executable name of the solver,&quot;</span></span>
<span class="lineno"> 4611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the second is the list of arguments to pass to the solver.&quot;</span></span>
<span class="lineno"> 4612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The string '%f' anywhere in the argument list will be replaced&quot;</span></span>
<span class="lineno"> 4613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the name of the temporary file holding the AIG version of&quot;</span></span>
<span class="lineno"> 4614 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the formula.&quot;</span></span>
<span class="lineno"> 4615 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4616 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4617 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_aig&quot;         &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4618 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_aig)</span></span>
<span class="lineno"> 4619 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in AIGER format.&quot; ]</span></span>
<span class="lineno"> 4621 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4622 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_aig_external&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_aig_external)</span></span>
<span class="lineno"> 4624 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in AIGER format.&quot;</span></span>
<span class="lineno"> 4626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Uses ABC and an intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 4627 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4628 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4629 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4630 </span><span class="spaces">    </span><span class="istickedoff">-- CNF</span>
<span class="lineno"> 4631 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4632 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;approxmc&quot;  &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal approxmc)</span></span>
<span class="lineno"> 4634 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the approxmc solver to approximate the number of solutions&quot;</span></span>
<span class="lineno"> 4636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to the CNF representation of the given Term.&quot;</span></span>
<span class="lineno"> 4637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4638 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4639 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_cnf&quot;           &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4640 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_write_cnf)</span>
<span class="lineno"> 4641 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4642 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in CNF format.&quot; ]</span></span>
<span class="lineno"> 4643 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4644 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_cnf_external&quot;  &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_cnf_external)</span></span>
<span class="lineno"> 4646 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in CNF format.&quot; ]</span></span>
<span class="lineno"> 4648 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4649 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_cnf&quot;         &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4650 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_offline_cnf)</span>
<span class="lineno"> 4651 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in CNF format.&quot; ]</span></span>
<span class="lineno"> 4653 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4654 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_cnf_external&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_cnf_external)</span></span>
<span class="lineno"> 4656 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in CNF format.&quot;</span></span>
<span class="lineno"> 4658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Uses ABC and an intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 4659 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4660 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4661 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;external_cnf_solver&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (satExternal True))</span></span>
<span class="lineno"> 4663 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use an external SAT solver supporting CNF to prove the current&quot;</span></span>
<span class="lineno"> 4665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;goal. The first argument is the executable name of the solver,&quot;</span></span>
<span class="lineno"> 4666 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the second is the list of arguments to pass to the solver.&quot;</span></span>
<span class="lineno"> 4667 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The string '%f' anywhere in the argument list will be replaced&quot;</span></span>
<span class="lineno"> 4668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the name of the temporary file holding the CNF version of&quot;</span></span>
<span class="lineno"> 4669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the formula.&quot;</span></span>
<span class="lineno"> 4670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4672 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4673 </span><span class="spaces">    </span><span class="istickedoff">-- Cryptol</span>
<span class="lineno"> 4674 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4675 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_bool&quot;           &quot;Term -&gt; Bool&quot;</span>
<span class="lineno"> 4676 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_bool)</span>
<span class="lineno"> 4677 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type Bit to either 'true' or 'false'.&quot;</span></span>
<span class="lineno"> 4679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4681 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_int&quot;           &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 4682 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_int)</span>
<span class="lineno"> 4683 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type [n] (a bitvector) and convert to&quot;</span></span>
<span class="lineno"> 4685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a SAWScript 'Int'.&quot;</span></span>
<span class="lineno"> 4686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4687 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4688 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_size&quot;          &quot;Type -&gt; Int&quot;</span>
<span class="lineno"> 4689 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_size)</span>
<span class="lineno"> 4690 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4691 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a Cryptol size type to a SAWScript Int.&quot; ]</span></span>
<span class="lineno"> 4692 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4693 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_list&quot;           &quot;Term -&gt; [Term]&quot;</span>
<span class="lineno"> 4694 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_list)</span>
<span class="lineno"> 4695 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type [n]a to a list of terms.&quot; ]</span></span>
<span class="lineno"> 4697 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4698 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;list_term&quot;           &quot;[Term] -&gt; Term&quot;</span>
<span class="lineno"> 4699 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 list_term)</span>
<span class="lineno"> 4700 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4701 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Make a Cryptol term of type [n]a from a list of terms of type a.&quot;</span></span>
<span class="lineno"> 4702 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'list_term' is the inverse of 'eval_list'.&quot;</span></span>
<span class="lineno"> 4703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4704 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4705 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_load&quot;        &quot;String -&gt; TopLevel CryptolModule&quot;</span>
<span class="lineno"> 4706 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (do_cryptol_load BS.readFile))</span>
<span class="lineno"> 4707 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load the given file as a Cryptol module.&quot; ]</span></span>
<span class="lineno"> 4709 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4710 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_extract&quot;     &quot;CryptolModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4711 </span><span class="spaces">    </span><span class="istickedoff">(pureVal cryptol_extract)</span>
<span class="lineno"> 4712 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a single definition from a Cryptol module and translate it&quot;</span></span>
<span class="lineno"> 4714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;into a 'Term'.&quot;</span></span>
<span class="lineno"> 4715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4716 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4717 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_prims&quot;       &quot;() -&gt; CryptolModule&quot;</span>
<span class="lineno"> 4718 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (\ () -&gt; cryptol_prims))</span>
<span class="lineno"> 4719 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a Cryptol module containing extra primitive operations,&quot;</span></span>
<span class="lineno"> 4721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;including array updates, truncate/extend, and signed&quot;</span></span>
<span class="lineno"> 4722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;comparisons.&quot;</span></span>
<span class="lineno"> 4723 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4724 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4725 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_path&quot;    &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_cryptol_add_path)</span></span>
<span class="lineno"> 4727 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a directory to the Cryptol search path. The Cryptol file&quot;</span></span>
<span class="lineno"> 4729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loader will look in this directory when following 'import'&quot;</span></span>
<span class="lineno"> 4730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements in Cryptol source files.&quot;</span></span>
<span class="lineno"> 4731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4732 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4733 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_prim&quot;    &quot;String -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_prim)</span></span>
<span class="lineno"> 4735 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;cryptol_add_prim &lt;mod&gt; &lt;name&gt; &lt;term&gt; trm sets the translation of&quot;</span></span>
<span class="lineno"> 4737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol primitive &lt;name&gt; in module &lt;mod&gt; to &lt;term&gt;.&quot;</span></span>
<span class="lineno"> 4738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4739 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4740 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_prim_type&quot;    &quot;String -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_prim_type)</span></span>
<span class="lineno"> 4742 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;cryptol_add_prim_type &lt;mod&gt; &lt;name&gt; &lt;type&gt; sets the translation&quot;</span></span>
<span class="lineno"> 4744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of Cryptol primitive type &lt;name&gt; in module &lt;mod&gt; to &lt;type&gt;.&quot;</span></span>
<span class="lineno"> 4745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4746 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4747 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4748 </span><span class="spaces">    </span><span class="istickedoff">-- Verilog</span>
<span class="lineno"> 4749 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4750 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_verilog&quot;       &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4751 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal do_write_verilog)</span></span>
<span class="lineno"> 4752 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in Verilog format.&quot; ]</span></span>
<span class="lineno"> 4754 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4755 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_verilog&quot;        &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_verilog)</span></span>
<span class="lineno"> 4757 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in Verilog format.&quot; ]</span></span>
<span class="lineno"> 4759 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4760 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4761 </span><span class="spaces">    </span><span class="istickedoff">-- Yosys</span>
<span class="lineno"> 4762 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4763 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_import&quot;  &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4764 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_yosys_import)</span>
<span class="lineno"> 4765 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Produces a Term given the path to a JSON file produced by the&quot;</span></span>
<span class="lineno"> 4767 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Yosys 'write_json' command. The resulting term is a Cryptol&quot;</span></span>
<span class="lineno"> 4768 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;record, where each field corresponds to one HDL module exported&quot;</span></span>
<span class="lineno"> 4769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by Yosys. Each HDL module is in turn represented by a function&quot;</span></span>
<span class="lineno"> 4770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;from a record of input port values to a record of output port&quot;</span></span>
<span class="lineno"> 4771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values.&quot;</span></span>
<span class="lineno"> 4772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4774 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_verify&quot;  (&quot;Term -&gt; [Term] -&gt; Term -&gt; [YosysTheorem] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 4775 </span><span class="spaces">                          </span><span class="istickedoff">&quot;ProofScript () -&gt; TopLevel YosysTheorem&quot;)</span>
<span class="lineno"> 4776 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_verify)</span>
<span class="lineno"> 4777 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Proves equality between a combinational HDL module and a&quot;</span></span>
<span class="lineno"> 4779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification.&quot;</span></span>
<span class="lineno"> 4780 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the HDL module - given a record m from&quot;</span></span>
<span class="lineno"> 4782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;yosys_import, this will typically look something like '{{ m.foo&quot;</span></span>
<span class="lineno"> 4783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;}}'. The second parameter is a list of preconditions for the&quot;</span></span>
<span class="lineno"> 4784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;equality. The third parameter is the specification, a term of&quot;</span></span>
<span class="lineno"> 4785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the same type as the HDL module, which will typically be some&quot;</span></span>
<span class="lineno"> 4786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol function or another HDL module.  The fourth parameter is&quot;</span></span>
<span class="lineno"> 4787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a list of overrides, which witness the results of previous&quot;</span></span>
<span class="lineno"> 4788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;yosys_verify proofs. These overrides can be used to simplify&quot;</span></span>
<span class="lineno"> 4789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;terms by replacing use sites of submodules with their&quot;</span></span>
<span class="lineno"> 4790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications.&quot;</span></span>
<span class="lineno"> 4791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that terms derived from HDL modules are first class, and&quot;</span></span>
<span class="lineno"> 4793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;are not restricted to yosys_verify: they may also be used with&quot;</span></span>
<span class="lineno"> 4794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW's typical Term infrastructure like 'sat', 'prove_print',&quot;</span></span>
<span class="lineno"> 4795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term rewriting, etc. yosys_verify simply provides a convenient&quot;</span></span>
<span class="lineno"> 4796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and familiar interface, similar to llvm_verify or jvm_verify.&quot;</span></span>
<span class="lineno"> 4797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4799 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_import_sequential&quot;  (&quot;String -&gt; String -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 4800 </span><span class="spaces">                                     </span><span class="istickedoff">&quot;TopLevel YosysSequential&quot;)</span>
<span class="lineno"> 4801 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_yosys_import_sequential)</span>
<span class="lineno"> 4802 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Imports a sequential HDL module.&quot;</span></span>
<span class="lineno"> 4804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the module name; the second is the path&quot;</span></span>
<span class="lineno"> 4806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to the Yosys JSON file. The resulting value is an opaque&quot;</span></span>
<span class="lineno"> 4807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;representation of the sequential circuit that can be extracted&quot;</span></span>
<span class="lineno"> 4808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to a Term or sent to solvers in various ways.&quot;</span></span>
<span class="lineno"> 4809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW expects the sequential module to exist entirely within a&quot;</span></span>
<span class="lineno"> 4811 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;single Yosys module - the Yosys 'flatten' command will collapse&quot;</span></span>
<span class="lineno"> 4812 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the module hierarchy into a single module. The only supported&quot;</span></span>
<span class="lineno"> 4813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;sequential element is the basic $dff cell. Memory cells and more&quot;</span></span>
<span class="lineno"> 4814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;complex flip-flops can be translated into $dff using the&quot;</span></span>
<span class="lineno"> 4815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'memory' and 'dffunmap' Yosys commands.&quot;</span></span>
<span class="lineno"> 4816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4817 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4818 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential&quot;  &quot;YosysSequential -&gt; Int -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4819 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_extract_sequential)</span>
<span class="lineno"> 4820 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extracts a term from the given sequential module with the state&quot;</span></span>
<span class="lineno"> 4822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;eliminated by iterating the term over the given concrete number&quot;</span></span>
<span class="lineno"> 4823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of cycles.&quot;</span></span>
<span class="lineno"> 4824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting term has no state field in the inputs or outputs,&quot;</span></span>
<span class="lineno"> 4826 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and each input and output field is replaced with an array of&quot;</span></span>
<span class="lineno"> 4827 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that field's type (array length being the number of cycles).&quot;</span></span>
<span class="lineno"> 4828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This term can be used like a normal SAW term -- it may be &quot;</span></span>
<span class="lineno"> 4829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;embedded in Cryptol expressions, used in 'prove' and 'sat',&quot;</span></span>
<span class="lineno"> 4830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;etc.&quot;</span></span>
<span class="lineno"> 4831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4832 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4833 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential_with_state&quot;</span>
<span class="lineno"> 4834 </span><span class="spaces">    </span><span class="istickedoff">&quot;YosysSequential -&gt; Int -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4835 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal yosys_extract_sequential_with_state)</span></span>
<span class="lineno"> 4836 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4837 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like yosys_extract_sequential, but the resulting term has an&quot;</span></span>
<span class="lineno"> 4838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;additional parameter to specify the initial state.&quot;</span></span>
<span class="lineno"> 4839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4840 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4841 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential_raw&quot;  &quot;YosysSequential -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4842 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_extract_sequential_raw)</span>
<span class="lineno"> 4843 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extracts a term from the given sequential module.&quot;</span></span>
<span class="lineno"> 4845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This term has explicit fields for the state of the circuit in&quot;</span></span>
<span class="lineno"> 4846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the input and output record types.&quot;</span></span>
<span class="lineno"> 4847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4848 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4849 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_verify_sequential_offline_sally&quot;</span>
<span class="lineno"> 4850 </span><span class="spaces">    </span><span class="istickedoff">&quot;YosysSequential -&gt; String -&gt; Term -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4851 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_yosys_verify_sequential_sally)</span>
<span class="lineno"> 4852 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Export a query over the given sequential module to an input file&quot;</span></span>
<span class="lineno"> 4854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for the Sally model checker.&quot;</span></span>
<span class="lineno"> 4855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The first parameter is the sequential module.&quot;</span></span>
<span class="lineno"> 4857 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The second parameter is the path to write the resulting Sally&quot;</span></span>
<span class="lineno"> 4858 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   input.&quot;</span></span>
<span class="lineno"> 4859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The third parameter is the query, which should be a boolean&quot;</span></span>
<span class="lineno"> 4860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   function of three parameters: an 8-bit cycle counter, a&quot;</span></span>
<span class="lineno"> 4861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   record of 'fixed' inputs, and a record of circuit outputs.&quot;</span></span>
<span class="lineno"> 4862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The fourth parameter is a list of strings specifying certain&quot;</span></span>
<span class="lineno"> 4863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   circuit inputs as fixed - these inputs are assumed to remain&quot;</span></span>
<span class="lineno"> 4864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   unchanged across cycles, and are therefore accesible from the&quot;</span></span>
<span class="lineno"> 4865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   query function.&quot;</span></span>
<span class="lineno"> 4866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4867 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4868 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4869 </span><span class="spaces">    </span><span class="istickedoff">-- Rocq / Coq export</span>
<span class="lineno"> 4870 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4871 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_term&quot; (&quot;String -&gt; [(String, String)] -&gt; [String] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 4872 </span><span class="spaces">                           </span><span class="istickedoff">&quot;String -&gt; Term -&gt; TopLevel ()&quot;)</span>
<span class="lineno"> 4873 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_term)</span></span>
<span class="lineno"> 4874 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4875 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in Gallina syntax for Coq.&quot;</span></span>
<span class="lineno"> 4876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The first argument is the name to use in a Definition.&quot;</span></span>
<span class="lineno"> 4877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The second argument is a list of pairs of notation&quot;</span></span>
<span class="lineno"> 4878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   substitutions: the operator on the left will be replaced with&quot;</span></span>
<span class="lineno"> 4879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   the identifier on the right, as we do not support notations&quot;</span></span>
<span class="lineno"> 4880 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   on the Coq side.&quot;</span></span>
<span class="lineno"> 4881 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The third argument is a list of identifiers to skip&quot;</span></span>
<span class="lineno"> 4882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   translating.&quot;</span></span>
<span class="lineno"> 4883 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The fourth argument is the name of the file to output into;&quot;</span></span>
<span class="lineno"> 4884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 4885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The fifth argument is the term to export.&quot;</span></span>
<span class="lineno"> 4886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4887 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4888 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_module&quot; (&quot;String -&gt; String -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 4889 </span><span class="spaces">                                     </span><span class="istickedoff">&quot;[(String, String)] -&gt; [String] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 4890 </span><span class="spaces">                                     </span><span class="istickedoff">&quot;TopLevel ()&quot;)</span>
<span class="lineno"> 4891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_cryptol_module)</span></span>
<span class="lineno"> 4892 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a Cryptol module in Gallina syntax&quot;</span></span>
<span class="lineno"> 4894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for Coq.&quot;</span></span>
<span class="lineno"> 4895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The first argument is the file containing the module to&quot;</span></span>
<span class="lineno"> 4896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   export.&quot;</span></span>
<span class="lineno"> 4897 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The second argument is the name of the file to output into;&quot;</span></span>
<span class="lineno"> 4898 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 4899 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The third argument is a list of pairs of notation&quot;</span></span>
<span class="lineno"> 4900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   substitutions: the operator on the left will be replaced with&quot;</span></span>
<span class="lineno"> 4901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   the identifier on the right, as we do not support notations&quot;</span></span>
<span class="lineno"> 4902 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   on the Coq side.&quot;</span></span>
<span class="lineno"> 4903 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The fourth argument is a list of identifiers to skip&quot;</span></span>
<span class="lineno"> 4904 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   translating.&quot;</span></span>
<span class="lineno"> 4905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4906 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4907 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_sawcore_prelude&quot; (&quot;String -&gt; [(String, String)] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 4908 </span><span class="spaces">                                      </span><span class="istickedoff">&quot;[String] -&gt; TopLevel ()&quot;)</span>
<span class="lineno"> 4909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_sawcore_prelude)</span></span>
<span class="lineno"> 4910 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of the SAWCore prelude in Gallina&quot;</span></span>
<span class="lineno"> 4912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;syntax for Coq.&quot;</span></span>
<span class="lineno"> 4913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The first argument is the name of the file to output into;&quot;</span></span>
<span class="lineno"> 4914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 4915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The second argument is a list of pairs of notation&quot;</span></span>
<span class="lineno"> 4916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   substitutions: the operator on the left will be replaced&quot;</span></span>
<span class="lineno"> 4917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   with the identifier on the right, as we do not support&quot;</span></span>
<span class="lineno"> 4918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   notations on the Coq side.&quot;</span></span>
<span class="lineno"> 4919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The third argument is a list of identifiers to skip&quot;</span></span>
<span class="lineno"> 4920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   translating.&quot;</span></span>
<span class="lineno"> 4921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4923 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_primitives_for_sawcore&quot;</span>
<span class="lineno"> 4924 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_coq_cryptol_primitives_for_sawcore)</span></span>
<span class="lineno"> 4926 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of cryptol-saw-core's Cryptol.sawcore&quot;</span></span>
<span class="lineno"> 4928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in Gallina syntax for Coq.&quot;</span></span>
<span class="lineno"> 4929 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The first argument is the name of the output file for&quot;</span></span>
<span class="lineno"> 4930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   translating Cryptol.sawcore. Use an empty string to output to&quot;</span></span>
<span class="lineno"> 4931 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   standard output.&quot;</span></span>
<span class="lineno"> 4932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The second argument is a list of pairs of notation&quot;</span></span>
<span class="lineno"> 4933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   substitutions: the operator on the left will be replaced&quot;</span></span>
<span class="lineno"> 4934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   with the identifier on the right, as we do not support&quot;</span></span>
<span class="lineno"> 4935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   notations on the Coq side.&quot;</span></span>
<span class="lineno"> 4936 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - The third argument is a list of identifiers to skip&quot;</span></span>
<span class="lineno"> 4937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   translating.&quot;</span></span>
<span class="lineno"> 4938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4939 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4940 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_coq&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_coq)</span></span>
<span class="lineno"> 4942 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4943 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of the current goal in Gallina syntax&quot;</span></span>
<span class="lineno"> 4944 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(for Coq). The argument is a prefix to use for file names.&quot;</span></span>
<span class="lineno"> 4945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4946 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4947 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4948 </span><span class="spaces">    </span><span class="istickedoff">-- Additional output forms</span>
<span class="lineno"> 4949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4950 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_smtlib2&quot;       &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4951 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_write_smtlib2)</span>
<span class="lineno"> 4952 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in SMT-Lib version 2&quot;</span></span>
<span class="lineno"> 4954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;format.&quot;</span></span>
<span class="lineno"> 4955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4956 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4957 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_smtlib2_w4&quot;    &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4958 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_write_smtlib2_w4)</span></span>
<span class="lineno"> 4959 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4960 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in SMT-Lib version 2&quot;</span></span>
<span class="lineno"> 4961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;format, using the What4 backend instead of the SBV backend.&quot;</span></span>
<span class="lineno"> 4962 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4963 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4964 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_smtlib2&quot;     &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4965 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_offline_smtlib2)</span>
<span class="lineno"> 4966 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4967 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format.&quot; ]</span></span>
<span class="lineno"> 4968 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4969 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_offline_smtlib2&quot;  &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_w4_offline_smtlib2)</span></span>
<span class="lineno"> 4971 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format.&quot; ]</span></span>
<span class="lineno"> 4973 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4974 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_unint_smtlib2&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_offline_unint_smtlib2)</span></span>
<span class="lineno"> 4976 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format,&quot;</span></span>
<span class="lineno"> 4978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;leaving the listed functions uninterpreted.&quot;</span></span>
<span class="lineno"> 4979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4980 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4981 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;codegen&quot;         &quot;String -&gt; [String] -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4982 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal codegenSBV)</span></span>
<span class="lineno"> 4983 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4984 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate straight-line C code for the given term using SBV.&quot;</span></span>
<span class="lineno"> 4985 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - First argument is a directory name (\&quot;\&quot; for stdout) for&quot;</span></span>
<span class="lineno"> 4987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   the generated files.&quot;</span></span>
<span class="lineno"> 4988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - Second argument is the list of function names to leave&quot;</span></span>
<span class="lineno"> 4989 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   uninterpreted.&quot;</span></span>
<span class="lineno"> 4990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - Third argument is the C function name.&quot;</span></span>
<span class="lineno"> 4991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; - Fourth argument is the term to generate code for. It must be&quot;</span></span>
<span class="lineno"> 4992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   a first-order function whose arguments and result are all of&quot;</span></span>
<span class="lineno"> 4993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   type Bit, [8], [16], [32], or [64].&quot;</span></span>
<span class="lineno"> 4994 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4995 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4996 </span><span class="spaces">  </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 4997 </span><span class="spaces">  </span><span class="istickedoff">-- Crucible ghost state</span>
<span class="lineno"> 4998 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4999 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;declare_ghost_state&quot;</span>
<span class="lineno"> 5000 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 5001 </span><span class="spaces">    </span><span class="istickedoff">(pureVal declare_ghost_state)</span>
<span class="lineno"> 5002 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5003 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates a unique ghost variable.&quot; ]</span></span>
<span class="lineno"> 5004 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5005 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_declare_ghost_state&quot;</span>
<span class="lineno"> 5006 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 5007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal declare_ghost_state)</span></span>
<span class="lineno"> 5008 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'declare_ghost_state'.&quot; ]</span></span>
<span class="lineno"> 5010 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_declare_ghost_state&quot;</span>
<span class="lineno"> 5011 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 5012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal declare_ghost_state)</span></span>
<span class="lineno"> 5013 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5014 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'declare_ghost_state'.&quot; ]</span></span>
<span class="lineno"> 5015 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5016 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_ghost_value&quot;</span>
<span class="lineno"> 5017 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5018 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_ghost_value)</span>
<span class="lineno"> 5019 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5020 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 5021 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;</span></span>
<span class="lineno"> 5022 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5023 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_ghost_value&quot;</span>
<span class="lineno"> 5024 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_ghost_value)</span></span>
<span class="lineno"> 5026 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5027 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_ghost_value'.&quot;]</span></span>
<span class="lineno"> 5028 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5029 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_ghost_value&quot;</span>
<span class="lineno"> 5030 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 5031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_ghost_value)</span></span>
<span class="lineno"> 5032 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 5034 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;</span></span>
<span class="lineno"> 5035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5036 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5037 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ghost_value&quot;</span>
<span class="lineno"> 5038 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 5039 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ghost_value)</span>
<span class="lineno"> 5040 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 5042 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;</span></span>
<span class="lineno"> 5043 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5044 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5045 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5046 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM types</span>
<span class="lineno"> 5047 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5048 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_type&quot;           &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 5049 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 llvm_type)</span>
<span class="lineno"> 5050 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5051 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse the given string as LLVM type syntax.&quot; ]</span></span>
<span class="lineno"> 5052 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5053 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_int&quot;            &quot;Int -&gt; LLVMType&quot;</span>
<span class="lineno"> 5054 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_int)</span>
<span class="lineno"> 5055 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of LLVM integers, of the given bit width.&quot; ]</span></span>
<span class="lineno"> 5057 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5058 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_float&quot;          &quot;LLVMType&quot;</span>
<span class="lineno"> 5059 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_float)</span></span>
<span class="lineno"> 5060 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of single-precision floating point numbers in LLVM.&quot; ]</span></span>
<span class="lineno"> 5062 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5063 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_double&quot;         &quot;LLVMType&quot;</span>
<span class="lineno"> 5064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_double)</span></span>
<span class="lineno"> 5065 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of double-precision floating point numbers in LLVM.&quot; ]</span></span>
<span class="lineno"> 5067 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5068 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array&quot;          &quot;Int -&gt; LLVMType -&gt; LLVMType&quot;</span>
<span class="lineno"> 5069 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_array)</span>
<span class="lineno"> 5070 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of LLVM arrays with the given number of elements of the&quot;</span></span>
<span class="lineno"> 5072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type.&quot;</span></span>
<span class="lineno"> 5073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5074 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5075 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alias&quot;          &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 5076 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alias)</span>
<span class="lineno"> 5077 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM alias for the given name. This is often used&quot;</span></span>
<span class="lineno"> 5079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to alias a struct type.&quot;</span></span>
<span class="lineno"> 5080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5081 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5082 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct&quot;         &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 5083 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alias)</span></span>
<span class="lineno"> 5084 </span><span class="spaces">    </span><span class="istickedoff">WarnDeprecated</span>
<span class="lineno"> 5085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alias'.&quot;</span></span>
<span class="lineno"> 5086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If you are trying to create a struct type from its contents, you&quot;</span></span>
<span class="lineno"> 5087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;want llvm_struct_type.&quot;</span></span>
<span class="lineno"> 5088 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be hidden by default in SAW 1.5.&quot;</span></span>
<span class="lineno"> 5090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5091 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5092 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct_type&quot;</span>
<span class="lineno"> 5093 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMType] -&gt; LLVMType&quot;</span>
<span class="lineno"> 5094 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_struct_type)</span>
<span class="lineno"> 5095 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM struct with elements of the given types.&quot; ]</span></span>
<span class="lineno"> 5097 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5098 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_packed_struct_type&quot;</span>
<span class="lineno"> 5099 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMType] -&gt; LLVMType&quot;</span>
<span class="lineno"> 5100 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_packed_struct_type)</span>
<span class="lineno"> 5101 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of a packed LLVM struct with elements of the given&quot;</span></span>
<span class="lineno"> 5103 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;types.&quot;</span></span>
<span class="lineno"> 5104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5105 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5106 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_pointer&quot;        &quot;LLVMType -&gt; LLVMType&quot;</span>
<span class="lineno"> 5107 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_pointer)</span>
<span class="lineno"> 5108 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM pointer that points to the given type.&quot; ]</span></span>
<span class="lineno"> 5110 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5111 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5112 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM values and terms</span>
<span class="lineno"> 5113 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5114 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_null&quot;</span>
<span class="lineno"> 5115 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue&quot;</span>
<span class="lineno"> 5116 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupNull)</span>
<span class="lineno"> 5117 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An LLVMValue representing a null pointer value.&quot; ]</span></span>
<span class="lineno"> 5119 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_null&quot;</span>
<span class="lineno"> 5120 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue&quot;</span>
<span class="lineno"> 5121 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupNull)</span></span>
<span class="lineno"> 5122 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_null'.&quot; ]</span></span>
<span class="lineno"> 5124 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5125 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_term&quot;</span>
<span class="lineno"> 5126 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5127 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupTerm)</span>
<span class="lineno"> 5128 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct an 'LLVMValue' from a 'Term'.&quot; ]</span></span>
<span class="lineno"> 5130 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_term&quot;</span>
<span class="lineno"> 5131 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5132 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupTerm)</span>
<span class="lineno"> 5133 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5134 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_term'.&quot; ]</span></span>
<span class="lineno"> 5135 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5136 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array_value&quot;</span>
<span class="lineno"> 5137 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMValue] -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5138 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupArray)</span>
<span class="lineno"> 5139 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create an LLVMValue representing an array, with the given list&quot;</span></span>
<span class="lineno"> 5141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values as elements. The list must be non-empty.&quot;</span></span>
<span class="lineno"> 5142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5143 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_array&quot;</span>
<span class="lineno"> 5144 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMValue] -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupArray)</span></span>
<span class="lineno"> 5146 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_array_value'.&quot; ]</span></span>
<span class="lineno"> 5148 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5149 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_elem&quot;</span>
<span class="lineno"> 5150 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue -&gt; Int -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5151 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupElem)</span>
<span class="lineno"> 5152 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5153 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn an LLVMValue representing a struct or array pointer into&quot;</span></span>
<span class="lineno"> 5154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to an element of the struct or array by field index.&quot;</span></span>
<span class="lineno"> 5155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5156 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_elem&quot;</span>
<span class="lineno"> 5157 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue -&gt; Int -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupElem)</span></span>
<span class="lineno"> 5159 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5160 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_elem'.&quot; ]</span></span>
<span class="lineno"> 5161 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5162 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct_value&quot;</span>
<span class="lineno"> 5163 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMValue] -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5164 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CIR.anySetupStruct False))</span>
<span class="lineno"> 5165 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create an LLVMValue representing a struct, with the given list&quot;</span></span>
<span class="lineno"> 5167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values as elements.&quot;</span></span>
<span class="lineno"> 5168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5169 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_struct&quot;</span>
<span class="lineno"> 5170 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMValue] -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5171 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (CIR.anySetupStruct False))</span></span>
<span class="lineno"> 5172 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_struct_value'.&quot; ]</span></span>
<span class="lineno"> 5174 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5175 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_packed_struct_value&quot;</span>
<span class="lineno"> 5176 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMValue] -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5177 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CIR.anySetupStruct True))</span>
<span class="lineno"> 5178 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5179 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create an LLVMValue representing a packed struct, with the given&quot;</span></span>
<span class="lineno"> 5180 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;list of values as elements.&quot;</span></span>
<span class="lineno"> 5181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5182 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_packed_struct&quot;</span>
<span class="lineno"> 5183 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMValue] -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (CIR.anySetupStruct True))</span></span>
<span class="lineno"> 5185 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_packed_struct_value'.&quot; ]</span></span>
<span class="lineno"> 5187 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5188 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_field&quot;</span>
<span class="lineno"> 5189 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue -&gt; String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5190 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupField)</span>
<span class="lineno"> 5191 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5192 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn an LLVMValue representing a struct pointer into a pointer&quot;</span></span>
<span class="lineno"> 5193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to an element of the struct by field name. Requires debug&quot;</span></span>
<span class="lineno"> 5194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to resolve struct field names.&quot;</span></span>
<span class="lineno"> 5195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5196 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_field&quot;</span>
<span class="lineno"> 5197 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue -&gt; String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupField)</span></span>
<span class="lineno"> 5199 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_field'.&quot; ]</span></span>
<span class="lineno"> 5201 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5202 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_union&quot;</span>
<span class="lineno"> 5203 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMValue -&gt; String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5204 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupUnion)</span>
<span class="lineno"> 5205 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5206 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn an LLVMValue representing a union pointer into a pointer to&quot;</span></span>
<span class="lineno"> 5207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;one of the branches of the union by field name. Requires debug&quot;</span></span>
<span class="lineno"> 5208 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbols to resolve union field names.&quot;</span></span>
<span class="lineno"> 5209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5210 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5211 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_global&quot;</span>
<span class="lineno"> 5212 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5213 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupGlobal)</span>
<span class="lineno"> 5214 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return an LLVMValue representing a pointer to the named global.&quot;</span></span>
<span class="lineno"> 5216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The String may be either the name of a global value or a&quot;</span></span>
<span class="lineno"> 5217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function name.&quot;</span></span>
<span class="lineno"> 5218 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5219 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_global&quot;</span>
<span class="lineno"> 5220 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5221 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupGlobal)</span></span>
<span class="lineno"> 5222 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_global'.&quot; ]</span></span>
<span class="lineno"> 5224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5225 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_global_initializer&quot;</span>
<span class="lineno"> 5226 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5227 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupGlobalInitializer)</span>
<span class="lineno"> 5228 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return an LLVMValue representing the value of the initializer of&quot;</span></span>
<span class="lineno"> 5230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a named global. The String should be the name of a global value.&quot;</span></span>
<span class="lineno"> 5231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5232 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_global_initializer&quot;</span>
<span class="lineno"> 5233 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5234 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupGlobalInitializer)</span></span>
<span class="lineno"> 5235 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_global_initializer'.&quot; ]</span></span>
<span class="lineno"> 5237 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5238 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_cast_pointer&quot; &quot;LLVMValue -&gt; LLVMType -&gt; LLVMValue&quot;</span>
<span class="lineno"> 5239 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_cast_pointer)</span>
<span class="lineno"> 5240 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Cast the type of the given LLVM value, which must be a pointer.&quot;</span></span>
<span class="lineno"> 5242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting value will be a pointer to the same location,&quot;</span></span>
<span class="lineno"> 5243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;treated as a pointer to the provided type.&quot;</span></span>
<span class="lineno"> 5244 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5245 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5246 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_setup_val_to_term&quot;</span>
<span class="lineno"> 5247 </span><span class="spaces">    </span><span class="istickedoff">&quot; LLVMValue -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 5248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal crucible_setup_val_to_typed_term)</span></span>
<span class="lineno"> 5249 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 5250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert from a setup value to a typed term. This can only be&quot;</span></span>
<span class="lineno"> 5251 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;done for a subset of setup values. Fails if a setup value is a&quot;</span></span>
<span class="lineno"> 5252 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;global, variable, or null.&quot;</span></span>
<span class="lineno"> 5253 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5254 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected to be removed in SAW 1.5.&quot;</span></span>
<span class="lineno"> 5255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5256 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5257 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5258 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM fresh values</span>
<span class="lineno"> 5259 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5260 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_var&quot; &quot;String -&gt; LLVMType -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 5261 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_var)</span>
<span class="lineno"> 5262 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable for use within an LLVM&quot;</span></span>
<span class="lineno"> 5264 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification. The name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 5265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5266 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_var&quot; &quot;String -&gt; LLVMType -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 5267 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_var)</span>
<span class="lineno"> 5268 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5269 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_fresh_var'.&quot; ]</span></span>
<span class="lineno"> 5270 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5271 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 5272 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_cryptol_var)</span>
<span class="lineno"> 5273 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5274 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given Cryptol type for&quot;</span></span>
<span class="lineno"> 5275 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use within a Crucible specification. The given name is used only&quot;</span></span>
<span class="lineno"> 5276 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for pretty-printing. Unlike 'llvm_fresh_var', this can be used&quot;</span></span>
<span class="lineno"> 5277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when there isn't an appropriate LLVM type, such as for the&quot;</span></span>
<span class="lineno"> 5278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol Array type.&quot;</span></span>
<span class="lineno"> 5279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5280 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 5281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_cryptol_var)</span></span>
<span class="lineno"> 5282 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5283 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_fresh_cryptol_var'.&quot; ]</span></span>
<span class="lineno"> 5284 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5285 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_pointer&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5286 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_pointer)</span>
<span class="lineno"> 5287 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh pointer value for use in an LLVM specification.&quot;</span></span>
<span class="lineno"> 5289 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This works like 'llvm_alloc' except that the pointer is not&quot;</span></span>
<span class="lineno"> 5290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;required to point to allocated memory.&quot;</span></span>
<span class="lineno"> 5291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5292 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_pointer&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_pointer)</span></span>
<span class="lineno"> 5294 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_fresh_pointer'.&quot; ]</span></span>
<span class="lineno"> 5296 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5297 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_expanded_val&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5298 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_expanded_val)</span>
<span class="lineno"> 5299 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a compound type entirely populated with fresh symbolic&quot;</span></span>
<span class="lineno"> 5301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables. Equivalent to allocating a new struct or array of the&quot;</span></span>
<span class="lineno"> 5302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type and explicitly setting each field or element to&quot;</span></span>
<span class="lineno"> 5303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;contain a fresh symbolic variable.&quot;</span></span>
<span class="lineno"> 5304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5305 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_expanded_val&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_expanded_val)</span></span>
<span class="lineno"> 5307 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_fresh_expanded_val'.&quot; ]</span></span>
<span class="lineno"> 5309 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5310 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5311 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM allocation</span>
<span class="lineno"> 5312 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5313 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5314 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc)</span>
<span class="lineno"> 5315 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an object of the given type should be allocated in&quot;</span></span>
<span class="lineno"> 5317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an LLVM specification. Before 'llvm_execute_func', this states&quot;</span></span>
<span class="lineno"> 5318 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that the function expects the object to be allocated before it&quot;</span></span>
<span class="lineno"> 5319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;runs. After 'llvm_execute_func', it states that the function&quot;</span></span>
<span class="lineno"> 5320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 5321 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5322 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5323 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc)</span></span>
<span class="lineno"> 5324 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5325 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alloc'.&quot; ]</span></span>
<span class="lineno"> 5326 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5327 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5328 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_aligned)</span></span>
<span class="lineno"> 5329 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a memory region of the given type should be&quot;</span></span>
<span class="lineno"> 5331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in an LLVM specification, and also specify that the&quot;</span></span>
<span class="lineno"> 5332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;start of the region should be aligned to a multiple of the&quot;</span></span>
<span class="lineno"> 5333 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified number of bytes (which must be a power of 2).&quot;</span></span>
<span class="lineno"> 5334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5335 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_aligned)</span></span>
<span class="lineno"> 5337 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5338 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alloc_aligned'.&quot; ]</span></span>
<span class="lineno"> 5339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5340 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_readonly&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5341 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_readonly)</span>
<span class="lineno"> 5342 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a read-only memory region of the given type should&quot;</span></span>
<span class="lineno"> 5344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be allocated in an LLVM specification. The function must not&quot;</span></span>
<span class="lineno"> 5345 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;attempt to write to this memory region. Unlike 'llvm_alloc',&quot;</span></span>
<span class="lineno"> 5346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;regions allocated with 'llvm_alloc_readonly' are allowed to&quot;</span></span>
<span class="lineno"> 5347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;alias other read-only regions.&quot;</span></span>
<span class="lineno"> 5348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5349 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_readonly&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly)</span></span>
<span class="lineno"> 5351 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alloc_readonly'.&quot; ]</span></span>
<span class="lineno"> 5353 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5354 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_readonly_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5355 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly_aligned)</span></span>
<span class="lineno"> 5356 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a read-only memory region of the given type should&quot;</span></span>
<span class="lineno"> 5358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be allocated in an LLVM specification, and also specify that the&quot;</span></span>
<span class="lineno"> 5359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;start of the region should be aligned to a multiple of the&quot;</span></span>
<span class="lineno"> 5360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified number of bytes (which must be a power of 2). The&quot;</span></span>
<span class="lineno"> 5361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function must not attempt to write to this memory region. Unlike&quot;</span></span>
<span class="lineno"> 5362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_alloc' and 'llvm_alloc_aligned', regions allocated with&quot;</span></span>
<span class="lineno"> 5363 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_alloc_readonly_aligned' are allowed to alias other&quot;</span></span>
<span class="lineno"> 5364 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;read-only regions.&quot;</span></span>
<span class="lineno"> 5365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5366 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_readonly_aligned&quot; (&quot;Int -&gt; LLVMType -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5367 </span><span class="spaces">                                            </span><span class="istickedoff">&quot;LLVMSetup LLVMValue&quot;)</span>
<span class="lineno"> 5368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly_aligned)</span></span>
<span class="lineno"> 5369 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5370 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alloc_readonly_aligned'.&quot; ]</span></span>
<span class="lineno"> 5371 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5372 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_with_size&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5373 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_with_size)</span>
<span class="lineno"> 5374 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like 'llvm_alloc', but with a user-specified size (given in&quot;</span></span>
<span class="lineno"> 5376 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bytes). The specified size must be greater than the size of the&quot;</span></span>
<span class="lineno"> 5377 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM type.&quot;</span></span>
<span class="lineno"> 5378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5379 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5380 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_with_size&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_with_size)</span></span>
<span class="lineno"> 5382 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5383 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alloc_with_size'.&quot; ]</span></span>
<span class="lineno"> 5384 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5385 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_sym_init&quot; &quot;LLVMType -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5386 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_sym_init)</span>
<span class="lineno"> 5387 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like 'llvm_alloc', but assume that the allocation is initialized&quot;</span></span>
<span class="lineno"> 5389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with symbolic bytes.&quot;</span></span>
<span class="lineno"> 5390 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5391 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5392 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_symbolic_alloc&quot; &quot;Bool -&gt; Int -&gt; Term -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5393 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_symbolic_alloc)</span>
<span class="lineno"> 5394 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like 'llvm_alloc', but with a (symbolic) size instead of an LLVM&quot;</span></span>
<span class="lineno"> 5396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type. The first argument specifies whether the allocation is&quot;</span></span>
<span class="lineno"> 5397 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;read-only. The second argument specifies the alignment in bytes&quot;</span></span>
<span class="lineno"> 5398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(which must be a power of 2). The third argument specifies the&quot;</span></span>
<span class="lineno"> 5399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;size in bytes.&quot;</span></span>
<span class="lineno"> 5400 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5401 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_symbolic_alloc&quot; &quot;Bool -&gt; Int -&gt; Term -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 5402 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_symbolic_alloc)</span></span>
<span class="lineno"> 5403 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_symbolic_alloc'.&quot; ]</span></span>
<span class="lineno"> 5405 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5406 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_global&quot; &quot;String -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5407 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_global)</span>
<span class="lineno"> 5408 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5409 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that memory for the named global should be allocated in&quot;</span></span>
<span class="lineno"> 5410 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an LLVM specification. This is done implicitly for immutable&quot;</span></span>
<span class="lineno"> 5411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;globals. A pointer to the allocated memory may be obtained using&quot;</span></span>
<span class="lineno"> 5412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_global'.&quot;</span></span>
<span class="lineno"> 5413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5414 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_global&quot; &quot;String -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5415 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_global)</span></span>
<span class="lineno"> 5416 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_alloc_global'.&quot; ]</span></span>
<span class="lineno"> 5418 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5419 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5420 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM assertions</span>
<span class="lineno"> 5421 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5422 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_precond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5423 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_precond)</span>
<span class="lineno"> 5424 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5425 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition of the&quot;</span></span>
<span class="lineno"> 5426 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the function being verified.&quot;</span></span>
<span class="lineno"> 5427 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5428 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_precond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5429 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_precond)</span>
<span class="lineno"> 5430 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_precond'.&quot; ]</span></span>
<span class="lineno"> 5432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5433 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_postcond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5434 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_postcond)</span>
<span class="lineno"> 5435 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5436 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of the&quot;</span></span>
<span class="lineno"> 5437 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the function being verified.&quot;</span></span>
<span class="lineno"> 5438 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5439 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_postcond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5440 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_postcond)</span>
<span class="lineno"> 5441 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_postcond'.&quot; ]</span></span>
<span class="lineno"> 5443 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5444 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_assert&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5445 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_assert)</span>
<span class="lineno"> 5446 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5447 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold. Acts as 'llvm_precond'&quot;</span></span>
<span class="lineno"> 5448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or 'llvm_postcond' depending on where it appears, that is,&quot;</span></span>
<span class="lineno"> 5449 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before or after 'llvm_execute_func'.&quot;</span></span>
<span class="lineno"> 5450 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5451 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5452 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_equal&quot; &quot;LLVMValue -&gt; LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5453 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_equal)</span>
<span class="lineno"> 5454 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5455 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two LLVM values should be equal. Can be used as&quot;</span></span>
<span class="lineno"> 5456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;either a pre-condition or a post-condition. It is semantically&quot;</span></span>
<span class="lineno"> 5457 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;equivalent to an 'llvm_precond' or 'llvm_postcond' statement&quot;</span></span>
<span class="lineno"> 5458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that is an equality, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 5459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5460 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_equal&quot; &quot;LLVMValue -&gt; LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5461 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_equal)</span></span>
<span class="lineno"> 5462 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5463 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_equal'.&quot; ]</span></span>
<span class="lineno"> 5464 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5465 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to&quot; &quot;LLVMValue -&gt; LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5466 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to True))</span>
<span class="lineno"> 5467 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5468 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer&quot;</span></span>
<span class="lineno"> 5469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(first argument) contains the given value (second argument).&quot;</span></span>
<span class="lineno"> 5470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'llvm_execute_func') this&quot;</span></span>
<span class="lineno"> 5472 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 5473 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'llvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 5474 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies an assertion about the final memory state after&quot;</span></span>
<span class="lineno"> 5475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;running the function.&quot;</span></span>
<span class="lineno"> 5476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5477 </span><span class="spaces">    </span><span class="istickedoff">, prim &quot;crucible_points_to&quot; &quot;LLVMValue -&gt; LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_points_to True))</span></span>
<span class="lineno"> 5479 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_points_to'.&quot; ]</span></span>
<span class="lineno"> 5481 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5482 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to&quot; (&quot;Term -&gt; LLVMValue -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5483 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;LLVMSetup ()&quot;)</span>
<span class="lineno"> 5484 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_conditional_points_to True))</span>
<span class="lineno"> 5485 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5486 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by a pointer (second&quot;</span></span>
<span class="lineno"> 5487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains a  value (third argument), but only when a&quot;</span></span>
<span class="lineno"> 5488 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;condition (first argument) holds.&quot;</span></span>
<span class="lineno"> 5489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'llvm_execute_func') this&quot;</span></span>
<span class="lineno"> 5491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 5492 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'llvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 5493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies an assertion about the final memory state after&quot;</span></span>
<span class="lineno"> 5494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;running the function.&quot;</span></span>
<span class="lineno"> 5495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5496 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_conditional_points_to&quot; (&quot;Term -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5497 </span><span class="spaces">                                           </span><span class="istickedoff">&quot;LLVMValue -&gt; LLVMSetup ()&quot;)</span>
<span class="lineno"> 5498 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to True))</span></span>
<span class="lineno"> 5499 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5500 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_conditional_points_to'.&quot; ]</span></span>
<span class="lineno"> 5501 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5502 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_at_type&quot; (&quot;LLVMValue -&gt; LLVMType -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5503 </span><span class="spaces">                                   </span><span class="istickedoff">&quot;LLVMSetup ()&quot;)</span>
<span class="lineno"> 5504 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_points_to_at_type)</span>
<span class="lineno"> 5505 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5506 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of 'llvm_points_to' that casts the pointer to another&quot;</span></span>
<span class="lineno"> 5507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type. This may be useful, for example, when reading or writing a&quot;</span></span>
<span class="lineno"> 5508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prefix of a larger array.&quot;</span></span>
<span class="lineno"> 5509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5510 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5511 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to_at_type&quot; (&quot;Term -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5512 </span><span class="spaces">                                               </span><span class="istickedoff">&quot;LLVMType -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5513 </span><span class="spaces">                                               </span><span class="istickedoff">&quot;LLVMSetup ()&quot;)</span>
<span class="lineno"> 5514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_conditional_points_to_at_type)</span></span>
<span class="lineno"> 5515 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5516 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of 'llvm_conditional_points_to' that casts the pointer&quot;</span></span>
<span class="lineno"> 5517 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to another type. This may be useful, for example, when reading&quot;</span></span>
<span class="lineno"> 5518 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or writing a prefix of a larger array.&quot;</span></span>
<span class="lineno"> 5519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5520 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5521 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_untyped&quot; &quot;LLVMValue -&gt; LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5522 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to False))</span>
<span class="lineno"> 5523 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5524 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of 'llvm_points_to' that does not check for&quot;</span></span>
<span class="lineno"> 5525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;compatibility between the pointer type and the value type. This&quot;</span></span>
<span class="lineno"> 5526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;may be useful, for example, when reading or writing a prefix of&quot;</span></span>
<span class="lineno"> 5527 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a larger array.&quot;</span></span>
<span class="lineno"> 5528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5529 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_points_to_untyped&quot; &quot;LLVMValue -&gt; LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_points_to False))</span></span>
<span class="lineno"> 5531 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_points_to'.&quot; ]</span></span>
<span class="lineno"> 5533 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5534 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to_untyped&quot; (&quot;Term -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5535 </span><span class="spaces">                                               </span><span class="istickedoff">&quot;LLVMValue -&gt; LLVMSetup ()&quot;)</span>
<span class="lineno"> 5536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to False))</span></span>
<span class="lineno"> 5537 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of 'llvm_conditional_points_to' that does not check&quot;</span></span>
<span class="lineno"> 5539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for compatibility between the pointer type and the value type.&quot;</span></span>
<span class="lineno"> 5540 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This may, for example, be useful when reading or writing a&quot;</span></span>
<span class="lineno"> 5541 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prefix of larger array.&quot;</span></span>
<span class="lineno"> 5542 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5543 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_conditional_points_to_untyped&quot; (&quot;Term -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5544 </span><span class="spaces">                                                   </span><span class="istickedoff">&quot;LLVMValue -&gt; LLVMSetup ()&quot;)</span>
<span class="lineno"> 5545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to False))</span></span>
<span class="lineno"> 5546 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5547 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_conditional_points_to'.&quot; ]</span></span>
<span class="lineno"> 5548 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5549 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_array_prefix&quot; (&quot;LLVMValue -&gt; Term -&gt; Term -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5550 </span><span class="spaces">                                        </span><span class="istickedoff">&quot;LLVMSetup ()&quot;)</span>
<span class="lineno"> 5551 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_points_to_array_prefix)</span>
<span class="lineno"> 5552 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by a pointer (first&quot;</span></span>
<span class="lineno"> 5554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the prefix of an array (second argument)&quot;</span></span>
<span class="lineno"> 5555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;whose size is given by the third argument.&quot;</span></span>
<span class="lineno"> 5556 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5557 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'llvm_execute_func') this&quot;</span></span>
<span class="lineno"> 5558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 5559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'llvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 5560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies an assertion about the final memory state after&quot;</span></span>
<span class="lineno"> 5561 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;running the function.&quot;</span></span>
<span class="lineno"> 5562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5563 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_points_to_array_prefix&quot; (&quot;LLVMValue -&gt; Term -&gt; Term -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5564 </span><span class="spaces">                                            </span><span class="istickedoff">&quot;LLVMSetup ()&quot;)</span>
<span class="lineno"> 5565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_points_to_array_prefix)</span></span>
<span class="lineno"> 5566 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_points_to_array_prefix'.&quot; ]</span></span>
<span class="lineno"> 5568 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5569 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_bitfield&quot; (&quot;LLVMValue -&gt; String -&gt; LLVMValue -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5570 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;LLVMSetup ()&quot;)</span>
<span class="lineno"> 5571 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to_bitfield))</span>
<span class="lineno"> 5572 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of 'llvm_points_to' that is meant to be used on struct&quot;</span></span>
<span class="lineno"> 5574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fields that reside within bitfields. Use&quot;</span></span>
<span class="lineno"> 5575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   llvm_points_to_bitfield &lt;ptr&gt; &lt;field&gt; &lt;struct-val&gt;&quot;</span></span>
<span class="lineno"> 5576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;instead of&quot;</span></span>
<span class="lineno"> 5577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   llvm_points_to (llvm_field &lt;ptr&gt; &lt;field&gt;) &lt;struct-val&gt;,&quot;</span></span>
<span class="lineno"> 5578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the latter will not behave as one would expect for technical&quot;</span></span>
<span class="lineno"> 5579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;reasons.&quot;</span></span>
<span class="lineno"> 5580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command should only be used in combination with&quot;</span></span>
<span class="lineno"> 5582 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'enable_lax_loads_and_stores', as the memory model relaxations&quot;</span></span>
<span class="lineno"> 5583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;controlled by that option are crucial to how&quot;</span></span>
<span class="lineno"> 5584 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_points_to_bitfield' operates.&quot;</span></span>
<span class="lineno"> 5585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5587 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_execute_func&quot; &quot;[LLVMValue] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5588 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_execute_func)</span>
<span class="lineno"> 5589 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the&quot;</span></span>
<span class="lineno"> 5591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 5592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 5593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The 'llvm_execute_func' command also serves to separate the&quot;</span></span>
<span class="lineno"> 5594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-state section of the spec (before it) from the post-state&quot;</span></span>
<span class="lineno"> 5595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after it). The effects of some LLVMSetup commands&quot;</span></span>
<span class="lineno"> 5596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 5597 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 5598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Every LLVM specification must use this command to call its&quot;</span></span>
<span class="lineno"> 5600 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 5601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5602 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_execute_func&quot; &quot;[LLVMValue] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5603 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_execute_func)</span></span>
<span class="lineno"> 5604 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_execute_func'.&quot; ]</span></span>
<span class="lineno"> 5606 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5607 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_return&quot; &quot;LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5608 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_return)</span>
<span class="lineno"> 5609 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the function. An&quot;</span></span>
<span class="lineno"> 5611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;llvm_return statement is required if and only if the function&quot;</span></span>
<span class="lineno"> 5612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-void return type.&quot;</span></span>
<span class="lineno"> 5613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5614 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_return&quot; &quot;LLVMValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5615 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_return)</span>
<span class="lineno"> 5616 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5617 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_return'.&quot; ]</span></span>
<span class="lineno"> 5618 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5619 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5620 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM modules</span>
<span class="lineno"> 5621 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5622 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_load_module&quot;    &quot;String -&gt; TopLevel LLVMModule&quot;</span>
<span class="lineno"> 5623 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_llvm_load_module)</span>
<span class="lineno"> 5624 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load an LLVM bitcode file and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 5626 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5627 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_sizeof&quot;         &quot;LLVMModule -&gt; LLVMType -&gt; Int&quot;</span>
<span class="lineno"> 5628 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 llvm_sizeof)</span>
<span class="lineno"> 5629 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;In the context of the given LLVM module, compute the size of the&quot;</span></span>
<span class="lineno"> 5631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given LLVM type in bytes. The module determines details of&quot;</span></span>
<span class="lineno"> 5632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;struct layout and the meaning of type aliases.&quot;</span></span>
<span class="lineno"> 5633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5634 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5635 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_cfg&quot;     &quot;LLVMModule -&gt; String -&gt; TopLevel CFG&quot;</span>
<span class="lineno"> 5636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_cfg)</span></span>
<span class="lineno"> 5637 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a function from the given LLVM module into a Crucible CFG.&quot; ]</span></span>
<span class="lineno"> 5639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5640 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show_cfg&quot;          &quot;CFG -&gt; String&quot;</span>
<span class="lineno"> 5641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal show_cfg)</span></span>
<span class="lineno"> 5642 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5643 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print a Crucible control-flow graph.&quot; ]</span></span>
<span class="lineno"> 5644 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5645 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5646 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM verification</span>
<span class="lineno"> 5647 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5648 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_ffi_setup&quot;  &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5649 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_ffi_setup)</span>
<span class="lineno"> 5650 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5651 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate a LLVMSetup spec that can be used to verify that the&quot;</span></span>
<span class="lineno"> 5652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given monomorphic Cryptol term, consisting of a Cryptol foreign&quot;</span></span>
<span class="lineno"> 5653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function fully applied to any type arguments, has a correct&quot;</span></span>
<span class="lineno"> 5654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;foreign (LLVM) implementation with respect to its Cryptol&quot;</span></span>
<span class="lineno"> 5655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;implementation.&quot;</span></span>
<span class="lineno"> 5656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5657 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5658 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_extract&quot;  &quot;LLVMModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 5659 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_extract)</span>
<span class="lineno"> 5660 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5661 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function directly to a Term. The parameters of&quot;</span></span>
<span class="lineno"> 5662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the Term will be the parameters of the LLVM function, and the&quot;</span></span>
<span class="lineno"> 5663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return value will be the return value of the function. Only&quot;</span></span>
<span class="lineno"> 5664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;functions with scalar argument and return types are currently&quot;</span></span>
<span class="lineno"> 5665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allowed. Use 'llvm_compositional_extract' for more flexibility.&quot;</span></span>
<span class="lineno"> 5666 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5667 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_extract&quot;  &quot;LLVMModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 5668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_extract)</span></span>
<span class="lineno"> 5669 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_extract'.&quot; ]</span></span>
<span class="lineno"> 5671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5672 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_compositional_extract&quot;</span>
<span class="lineno"> 5673 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5674 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5675 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_compositional_extract)</span>
<span class="lineno"> 5676 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function directly to a Term. The parameters of&quot;</span></span>
<span class="lineno"> 5678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the Term are the input parameters of the LLVM function: the&quot;</span></span>
<span class="lineno"> 5679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameters passed by value (in the order given by&quot;</span></span>
<span class="lineno"> 5680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_execute_func'), then the parameters passed by reference&quot;</span></span>
<span class="lineno"> 5681 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(in the order given by 'llvm_points_to'). The Term is the tuple&quot;</span></span>
<span class="lineno"> 5682 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;consisting of the output parameters of the LLVM function: the&quot;</span></span>
<span class="lineno"> 5683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return parameter, then the parameters passed by reference (in&quot;</span></span>
<span class="lineno"> 5684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the order given by 'llvm_points_to').&quot;</span></span>
<span class="lineno"> 5685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The arguments are:&quot;</span></span>
<span class="lineno"> 5687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   1. &lt;mod&gt;: The LLVM module containing the function to extract.&quot;</span></span>
<span class="lineno"> 5688 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   2. &lt;fn&gt;: The name of the function to extract.&quot;</span></span>
<span class="lineno"> 5689 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   3. &lt;term-name&gt;: The name of the Term to generate.&quot;</span></span>
<span class="lineno"> 5690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   4. &lt;ovs&gt;: A list of overrides to use in the proof that the&quot;</span></span>
<span class="lineno"> 5691 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      extracted function satisifies &lt;spec&gt;.&quot;</span></span>
<span class="lineno"> 5692 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   5. &lt;check-path-sat&gt;: Whether to perform path satisfiability&quot;</span></span>
<span class="lineno"> 5693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;       checks.&quot;</span></span>
<span class="lineno"> 5694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   6. &lt;spec&gt;: SAW specification for the extracted function.&quot;</span></span>
<span class="lineno"> 5695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   7. &lt;proof&gt;: Proof script to use when verifying that the&quot;</span></span>
<span class="lineno"> 5696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;      extracted function satisfies &lt;spec&gt;.&quot;</span></span>
<span class="lineno"> 5697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For more flexibility, see 'llvm_verify'.&quot;</span></span>
<span class="lineno"> 5699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5700 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_compositional_extract&quot;</span>
<span class="lineno"> 5701 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5702 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_compositional_extract)</span></span>
<span class="lineno"> 5704 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_compositional_extract'.&quot; ]</span></span>
<span class="lineno"> 5706 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5707 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify&quot;</span>
<span class="lineno"> 5708 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5709 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5710 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_verify)</span>
<span class="lineno"> 5711 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the LLVM function named by the second parameter in the&quot;</span></span>
<span class="lineno"> 5713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;module specified by the first. The third parameter lists the&quot;</span></span>
<span class="lineno"> 5714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVMSpec values returned by previous calls to use as overrides.&quot;</span></span>
<span class="lineno"> 5715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth (Bool) parameter enables or disables path &quot;</span></span>
<span class="lineno"> 5716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiability checking. The fifth describes how to set up the&quot;</span></span>
<span class="lineno"> 5717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic execution engine before verification. And the last&quot;</span></span>
<span class="lineno"> 5718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 5719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 5720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5721 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_verify&quot;</span>
<span class="lineno"> 5722 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5723 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify)</span></span>
<span class="lineno"> 5725 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_verify'.&quot; ]</span></span>
<span class="lineno"> 5727 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5728 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_refine_spec&quot;</span>
<span class="lineno"> 5729 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5730 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5731 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_refine_spec)</span>
<span class="lineno"> 5732 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify that a given specification for a function is a refinement&quot;</span></span>
<span class="lineno"> 5734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of one or more specifications already proved for a function.&quot;</span></span>
<span class="lineno"> 5735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This can be useful for situations where it is advantageous to&quot;</span></span>
<span class="lineno"> 5736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;logically restate the specification in some way, or where a more&quot;</span></span>
<span class="lineno"> 5737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;general specification can be constructed from a collection of&quot;</span></span>
<span class="lineno"> 5738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;individual special cases.&quot;</span></span>
<span class="lineno"> 5739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5740 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5741 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 5742 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; LLVMSetup () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5743 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_unsafe_assume_spec)</span>
<span class="lineno"> 5744 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return an LLVMSpec corresponding to an LLVMSetup block, as would&quot;</span></span>
<span class="lineno"> 5746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be returned by 'crucible_llvm_verify' but without performing&quot;</span></span>
<span class="lineno"> 5747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;any verification.&quot;</span></span>
<span class="lineno"> 5748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5749 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 5750 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; LLVMSetup () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 5751 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_unsafe_assume_spec)</span></span>
<span class="lineno"> 5752 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_unsafe_assume_spec'.&quot; ]</span></span>
<span class="lineno"> 5754 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5755 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array_size_profile&quot;</span>
<span class="lineno"> 5756 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5757 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; TopLevel [(String, [FunctionProfile])]&quot;)</span>
<span class="lineno"> 5758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal $ llvm_array_size_profile assumeUnsat)</span></span>
<span class="lineno"> 5759 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Symbolically execute the function named by the second parameter&quot;</span></span>
<span class="lineno"> 5761 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the module specified by the first. The fourth parameter may&quot;</span></span>
<span class="lineno"> 5762 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be used to specify arguments. Returns profiles specifying the&quot;</span></span>
<span class="lineno"> 5763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;sizes of buffers referred to by pointer arguments for the&quot;</span></span>
<span class="lineno"> 5764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function and all other functions it calls (recursively), to be&quot;</span></span>
<span class="lineno"> 5765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed to 'llvm_boilerplate'.&quot;</span></span>
<span class="lineno"> 5766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5767 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_array_size_profile&quot;</span>
<span class="lineno"> 5768 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5769 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; TopLevel [(String, [FunctionProfile])]&quot;)</span>
<span class="lineno"> 5770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal $ llvm_array_size_profile assumeUnsat)</span></span>
<span class="lineno"> 5771 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_array_size_profile'.&quot; ]</span></span>
<span class="lineno"> 5773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5774 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_spec_solvers&quot;  &quot;LLVMSpec -&gt; [String]&quot;</span>
<span class="lineno"> 5775 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_solvers)</span></span>
<span class="lineno"> 5776 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extract a list of all the solvers used when verifying the given&quot;</span></span>
<span class="lineno"> 5778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method spec.&quot;</span></span>
<span class="lineno"> 5779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5780 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_spec_solvers&quot;  &quot;LLVMSpec -&gt; [String]&quot;</span>
<span class="lineno"> 5781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_solvers)</span></span>
<span class="lineno"> 5782 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_spec_solvers'.&quot; ]</span></span>
<span class="lineno"> 5784 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5785 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_spec_size&quot;  &quot;LLVMSpec -&gt; Int&quot;</span>
<span class="lineno"> 5786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_size)</span></span>
<span class="lineno"> 5787 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a count of the combined size of all verification goals&quot;</span></span>
<span class="lineno"> 5789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proved as part of the given method spec.&quot;</span></span>
<span class="lineno"> 5790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5791 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_spec_size&quot;  &quot;LLVMSpec -&gt; Int&quot;</span>
<span class="lineno"> 5792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_spec_size)</span></span>
<span class="lineno"> 5793 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_spec_size'.&quot; ]</span></span>
<span class="lineno"> 5795 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5796 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5797 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM x86 verification</span>
<span class="lineno"> 5798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5799 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_x86&quot;</span>
<span class="lineno"> 5800 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5801 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5802 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_llvm_verify_x86)</span>
<span class="lineno"> 5803 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify an x86 function from an ELF file for use as an override&quot;</span></span>
<span class="lineno"> 5805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in an LLVM verification. The first argument specifies the LLVM&quot;</span></span>
<span class="lineno"> 5806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;module containing the _caller_. The second and third specify the&quot;</span></span>
<span class="lineno"> 5807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;ELF file name and symbol name of the function to be verified.&quot;</span></span>
<span class="lineno"> 5808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth specifies the names and sizes (in bytes) of global&quot;</span></span>
<span class="lineno"> 5809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables to initialize, and the fifth whether to perform path&quot;</span></span>
<span class="lineno"> 5810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiability checking. The last argument is the LLVM&quot;</span></span>
<span class="lineno"> 5811 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification of the calling context against which to verify&quot;</span></span>
<span class="lineno"> 5812 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function. Returns a method spec that can be used as an&quot;</span></span>
<span class="lineno"> 5813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;override when verifying other LLVM functions.&quot;</span></span>
<span class="lineno"> 5814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5815 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_verify_x86&quot;</span>
<span class="lineno"> 5816 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5817 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_x86)</span></span>
<span class="lineno"> 5819 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'llvm_verify_x86'.&quot; ]</span></span>
<span class="lineno"> 5821 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5822 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_fixpoint_x86&quot;</span>
<span class="lineno"> 5823 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; Term -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5824 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_fixpoint_x86)</span></span>
<span class="lineno"> 5826 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5827 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can&quot;</span></span>
<span class="lineno"> 5828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove some properties involving simple loops with the help of a&quot;</span></span>
<span class="lineno"> 5829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;user-provided term that describes how the live variables in the&quot;</span></span>
<span class="lineno"> 5830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 5831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5832 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5833 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_fixpoint_chc_x86&quot;</span>
<span class="lineno"> 5834 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5835 </span><span class="spaces">     </span><span class="istickedoff">&quot;Bool -&gt; Term -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5836 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_fixpoint_chc_x86)</span></span>
<span class="lineno"> 5837 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can&quot;</span></span>
<span class="lineno"> 5839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove some properties involving simple loops with the help of a&quot;</span></span>
<span class="lineno"> 5840 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;user-provided term that describes how the live variables in the&quot;</span></span>
<span class="lineno"> 5841 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 5842 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This differs from 'llvm_verify_fixpoint_x86' in that it&quot;</span></span>
<span class="lineno"> 5844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;leverages Z3's constrained horn-clause (CHC) functionality to&quot;</span></span>
<span class="lineno"> 5845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;synthesize some of the loop's properties.&quot;</span></span>
<span class="lineno"> 5846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5847 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5848 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_x86_with_invariant&quot;</span>
<span class="lineno"> 5849 </span><span class="spaces">    </span><span class="istickedoff">(&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5850 </span><span class="spaces">     </span><span class="istickedoff">&quot;Bool -&gt; (String, Int, Term) -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5851 </span><span class="spaces">     </span><span class="istickedoff">&quot;LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;)</span>
<span class="lineno"> 5852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_verify_x86_with_invariant)</span></span>
<span class="lineno"> 5853 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can&quot;</span></span>
<span class="lineno"> 5855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove some properties involving simple loops with the help of a&quot;</span></span>
<span class="lineno"> 5856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;user-provided term that describes how the live variables in the&quot;</span></span>
<span class="lineno"> 5857 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 5858 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The loop invariant is provided by the tuple argument, which&quot;</span></span>
<span class="lineno"> 5860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;indicates what symbol the loop appears in (which might differ&quot;</span></span>
<span class="lineno"> 5861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;from the function the specification is for), which loop within&quot;</span></span>
<span class="lineno"> 5862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that function to reason about (starts counting from 0), and a&quot;</span></span>
<span class="lineno"> 5863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term that desribes the loop invariant itself. For success, the&quot;</span></span>
<span class="lineno"> 5864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loop in question must have a single entry-point, must have a&quot;</span></span>
<span class="lineno"> 5865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;single back-edge, and must have a constant memory footprint.&quot;</span></span>
<span class="lineno"> 5866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The SAWCore type expected of the loop invariant will depend on&quot;</span></span>
<span class="lineno"> 5868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the results of an analysis done on the indicated loop, which&quot;</span></span>
<span class="lineno"> 5869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;attempts to discover all the loop-carried dependencies. The&quot;</span></span>
<span class="lineno"> 5870 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;result of this analysis will be packaged into a tuple, and any&quot;</span></span>
<span class="lineno"> 5871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;relevant top-level specification variables will be found. The&quot;</span></span>
<span class="lineno"> 5872 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected type of the loop invariant will then be a function&quot;</span></span>
<span class="lineno"> 5873 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;over all the implicit variables found, and two tuples consisting&quot;</span></span>
<span class="lineno"> 5874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the initial values of the loop-carried dependencies, and the&quot;</span></span>
<span class="lineno"> 5875 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current value of the loop-carried dependencies. The function&quot;</span></span>
<span class="lineno"> 5876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should return Bool. Some trial-and-error will generally be&quot;</span></span>
<span class="lineno"> 5877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;required to match the results of the analysis with a suitable&quot;</span></span>
<span class="lineno"> 5878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 5879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5880 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;As part of the verification process, the loop invariant will be&quot;</span></span>
<span class="lineno"> 5881 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;used in several ways. First, a proof obligation will be issued&quot;</span></span>
<span class="lineno"> 5882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;upon first entry to the loop, establishing the loop invariant&quot;</span></span>
<span class="lineno"> 5883 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;holds at the beginning of the loop. Second, the loop invariant&quot;</span></span>
<span class="lineno"> 5884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is used when starting execution from the loop head to make a&quot;</span></span>
<span class="lineno"> 5885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;generic assumption that the invariant holds. Finally, the&quot;</span></span>
<span class="lineno"> 5886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invariant is used when execution once again reaches the loop&quot;</span></span>
<span class="lineno"> 5887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;head to assert that the invariant holds inductively across the&quot;</span></span>
<span class="lineno"> 5888 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the loop body. The produced proof obligations will&quot;</span></span>
<span class="lineno"> 5889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be tagged with either the tag 'initial loop invariant' or&quot;</span></span>
<span class="lineno"> 5890 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'inductive loop invariant'.&quot;</span></span>
<span class="lineno"> 5891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 5892 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Provided all the generated verification conditions are&quot;</span></span>
<span class="lineno"> 5893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;discharged, this results in a partial correctness proof for&quot;</span></span>
<span class="lineno"> 5894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the indicated function. Note that this procedure does not&quot;</span></span>
<span class="lineno"> 5895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prove termination.&quot;</span></span>
<span class="lineno"> 5896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5898 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5899 </span><span class="spaces">    </span><span class="istickedoff">-- x86 verification settings</span>
<span class="lineno"> 5900 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5901 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_x86_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5902 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_x86_what4_hash_consing)</span></span>
<span class="lineno"> 5903 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5904 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable hash-consing for What4 expressions during x86&quot;</span></span>
<span class="lineno"> 5905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification.&quot;</span></span>
<span class="lineno"> 5906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5907 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5908 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_x86_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_x86_what4_hash_consing)</span></span>
<span class="lineno"> 5910 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable hash-consing for What4 expressions during x86&quot;</span></span>
<span class="lineno"> 5912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification.&quot;</span></span>
<span class="lineno"> 5913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5914 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5915 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_x86_preserved_reg&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5916 </span><span class="spaces">    </span><span class="istickedoff">(pureVal add_x86_preserved_reg)</span>
<span class="lineno"> 5917 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Treat the given register as callee-saved during x86&quot;</span></span>
<span class="lineno"> 5919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification.&quot;</span></span>
<span class="lineno"> 5920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5921 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5922 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_x86_preserved_reg&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5923 </span><span class="spaces">    </span><span class="istickedoff">(pureVal default_x86_preserved_reg)</span>
<span class="lineno"> 5924 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the default set of callee-saved registers during x86&quot;</span></span>
<span class="lineno"> 5926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification.&quot;</span></span>
<span class="lineno"> 5927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5928 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5929 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_x86_stack_base_align&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_x86_stack_base_align)</span></span>
<span class="lineno"> 5931 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the alignment of the stack allocation base to 2^n during x86&quot;</span></span>
<span class="lineno"> 5933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification.&quot;</span></span>
<span class="lineno"> 5934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5935 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5936 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_x86_stack_base_align&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal default_x86_stack_base_align)</span></span>
<span class="lineno"> 5938 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5939 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the default stack allocation base alignment during x86&quot;</span></span>
<span class="lineno"> 5940 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification.&quot;</span></span>
<span class="lineno"> 5941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5942 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5943 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 5944 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM skeletons</span>
<span class="lineno"> 5945 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5946 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;module_skeleton&quot; &quot;LLVMModule -&gt; TopLevel ModuleSkeleton&quot;</span>
<span class="lineno"> 5947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal module_skeleton)</span></span>
<span class="lineno"> 5948 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5949 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a handle to an LLVM module, return a skeleton for that&quot;</span></span>
<span class="lineno"> 5950 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;module.&quot;</span></span>
<span class="lineno"> 5951 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5952 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5953 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;function_skeleton&quot; (&quot;ModuleSkeleton -&gt; String -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5954 </span><span class="spaces">                              </span><span class="istickedoff">&quot;TopLevel FunctionSkeleton&quot;)</span>
<span class="lineno"> 5955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal function_skeleton)</span></span>
<span class="lineno"> 5956 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5957 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a module skeleton and a function name, return the&quot;</span></span>
<span class="lineno"> 5958 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;corresponding function skeleton.&quot;</span></span>
<span class="lineno"> 5959 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5960 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5961 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_resize_arg_index&quot; (&quot;FunctionSkeleton -&gt; Int -&gt; Int -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5962 </span><span class="spaces">                                      </span><span class="istickedoff">&quot;Bool -&gt; TopLevel FunctionSkeleton&quot;)</span>
<span class="lineno"> 5963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_resize_arg_index)</span></span>
<span class="lineno"> 5964 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a function skeleton, argument index, array length, and&quot;</span></span>
<span class="lineno"> 5966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;whether or not that argument is initialized, return a new&quot;</span></span>
<span class="lineno"> 5967 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function skeleton where the assumed length/initialization of the&quot;</span></span>
<span class="lineno"> 5968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given argument is updated.&quot;</span></span>
<span class="lineno"> 5969 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5970 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5971 </span><span class="spaces"> </span><span class="istickedoff">, prim &quot;skeleton_resize_arg&quot; (&quot;FunctionSkeleton -&gt; String -&gt; Int -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5972 </span><span class="spaces">                               </span><span class="istickedoff">&quot;Bool -&gt; TopLevel FunctionSkeleton&quot;)</span>
<span class="lineno"> 5973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_resize_arg)</span></span>
<span class="lineno"> 5974 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a function skeleton, argument name, array length, and&quot;</span></span>
<span class="lineno"> 5976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;whether or not that argument is initialized, return a new&quot;</span></span>
<span class="lineno"> 5977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function skeleton where the assumed length/initialization of the&quot;</span></span>
<span class="lineno"> 5978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given argument is updated.&quot;</span></span>
<span class="lineno"> 5979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5980 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5981 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_guess_arg_sizes&quot; (&quot;ModuleSkeleton -&gt; LLVMModule -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5982 </span><span class="spaces">                                     </span><span class="istickedoff">&quot;[(String, [FunctionProfile])] -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 5983 </span><span class="spaces">                                     </span><span class="istickedoff">&quot;TopLevel ModuleSkeleton&quot;)</span>
<span class="lineno"> 5984 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_guess_arg_sizes)</span></span>
<span class="lineno"> 5985 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Update the sizes of all arguments of the given module skeleton&quot;</span></span>
<span class="lineno"> 5987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using data obtained from 'crucible_llvm_array_size_profile'.&quot;</span></span>
<span class="lineno"> 5988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5989 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5990 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_globals_pre&quot; &quot;ModuleSkeleton -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_globals_pre)</span></span>
<span class="lineno"> 5992 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocate and initialize mutable globals from the given module&quot;</span></span>
<span class="lineno"> 5994 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;skeleton.&quot;</span></span>
<span class="lineno"> 5995 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5996 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5997 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_globals_post&quot; &quot;ModuleSkeleton -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 5998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_globals_post)</span></span>
<span class="lineno"> 5999 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assert that all mutable globals from the given module skeleton&quot;</span></span>
<span class="lineno"> 6001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;are unchanged.&quot;</span></span>
<span class="lineno"> 6002 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6003 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6004 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_prestate&quot; &quot;FunctionSkeleton -&gt; LLVMSetup SkeletonState&quot;</span>
<span class="lineno"> 6005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_prestate)</span></span>
<span class="lineno"> 6006 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocate and initialize the arguments of the given function&quot;</span></span>
<span class="lineno"> 6008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;skeleton. Return a 'SkeletonState' from which those arguments can&quot;</span></span>
<span class="lineno"> 6009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be retrieved, so that preconditions can be imposed.&quot;</span></span>
<span class="lineno"> 6010 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6011 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6012 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_poststate&quot;</span>
<span class="lineno"> 6013 </span><span class="spaces">    </span><span class="istickedoff">&quot;FunctionSkeleton -&gt; SkeletonState -&gt; LLVMSetup SkeletonState&quot;</span>
<span class="lineno"> 6014 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_poststate)</span></span>
<span class="lineno"> 6015 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6016 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assert that pointer arguments of the given function skeleton remain&quot;</span></span>
<span class="lineno"> 6017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialized. Return a 'SkeletonState' from which those arguments can&quot;</span></span>
<span class="lineno"> 6018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be retrieved, so that postconditions can be imposed.&quot;</span></span>
<span class="lineno"> 6019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6020 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6021 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_index&quot; &quot;SkeletonState -&gt; Int -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 6022 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_index)</span></span>
<span class="lineno"> 6023 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument value at the given index from the given&quot;</span></span>
<span class="lineno"> 6025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'SkeletonState'.&quot;</span></span>
<span class="lineno"> 6026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6027 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6028 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg&quot; &quot;SkeletonState -&gt; String -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 6029 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg)</span></span>
<span class="lineno"> 6030 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument value of the given name from the given&quot;</span></span>
<span class="lineno"> 6032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'SkeletonState'.&quot;</span></span>
<span class="lineno"> 6033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6035 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_index_pointer&quot; (&quot;SkeletonState -&gt; Int -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 6036 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;LLVMSetup LLVMValue&quot;)</span>
<span class="lineno"> 6037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_index_pointer)</span></span>
<span class="lineno"> 6038 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument pointer at the given index from the given&quot;</span></span>
<span class="lineno"> 6040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'SkeletonState'. Fails if the specified argument is not a&quot;</span></span>
<span class="lineno"> 6041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pointer.&quot;</span></span>
<span class="lineno"> 6042 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6043 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6044 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_pointer&quot; &quot;SkeletonState -&gt; String -&gt; LLVMSetup LLVMValue&quot;</span>
<span class="lineno"> 6045 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_pointer)</span></span>
<span class="lineno"> 6046 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument pointer of the given name from the given&quot;</span></span>
<span class="lineno"> 6048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'SkeletonState'. Fails if the specified argument is not a&quot;</span></span>
<span class="lineno"> 6049 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pointer.&quot;</span></span>
<span class="lineno"> 6050 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6051 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6052 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_exec&quot; &quot;SkeletonState -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 6053 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_exec)</span></span>
<span class="lineno"> 6054 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Wrapper around 'llvm_execute_func' that passes the arguments&quot;</span></span>
<span class="lineno"> 6056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialized in 'skeleton_prestate'.&quot;</span></span>
<span class="lineno"> 6057 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6058 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6059 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_boilerplate&quot; &quot;String -&gt; ModuleSkeleton -&gt; Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 6060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_llvm_boilerplate)</span></span>
<span class="lineno"> 6061 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6062 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate boilerplate for the definitions in the given LLVM&quot;</span></span>
<span class="lineno"> 6063 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;module skeleton. Output is written to the path passed as the&quot;</span></span>
<span class="lineno"> 6064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument. The third argument controls whether skeleton&quot;</span></span>
<span class="lineno"> 6065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;builtins are emitted.&quot;</span></span>
<span class="lineno"> 6066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6067 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6068 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6069 </span><span class="spaces">    </span><span class="istickedoff">-- Java types</span>
<span class="lineno"> 6070 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6071 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_bool&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 6072 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaBoolean)</span>
<span class="lineno"> 6073 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of booleans.&quot; ]</span></span>
<span class="lineno"> 6075 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6076 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_byte&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 6077 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaByte)</span>
<span class="lineno"> 6078 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of bytes.&quot; ]</span></span>
<span class="lineno"> 6080 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6081 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_char&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 6082 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaChar)</span>
<span class="lineno"> 6083 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of characters.&quot; ]</span></span>
<span class="lineno"> 6085 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6086 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_short&quot;          &quot;JavaType&quot;</span>
<span class="lineno"> 6087 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaShort)</span>
<span class="lineno"> 6088 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of short integers.&quot; ]</span></span>
<span class="lineno"> 6090 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6091 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_int&quot;            &quot;JavaType&quot;</span>
<span class="lineno"> 6092 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaInt)</span>
<span class="lineno"> 6093 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The standard Java integer type.&quot; ]</span></span>
<span class="lineno"> 6095 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6096 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_long&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 6097 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaLong)</span>
<span class="lineno"> 6098 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6099 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of long integers.&quot; ]</span></span>
<span class="lineno"> 6100 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6101 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_float&quot;          &quot;JavaType&quot;</span>
<span class="lineno"> 6102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaFloat)</span></span>
<span class="lineno"> 6103 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of single-precision floating point values.&quot; ]</span></span>
<span class="lineno"> 6105 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6106 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_double&quot;         &quot;JavaType&quot;</span>
<span class="lineno"> 6107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaDouble)</span></span>
<span class="lineno"> 6108 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of double-precision floating point values.&quot; ]</span></span>
<span class="lineno"> 6110 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6111 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_array&quot;          &quot;Int -&gt; JavaType -&gt; JavaType&quot;</span>
<span class="lineno"> 6112 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaArray)</span>
<span class="lineno"> 6113 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of arrays of a fixed number of elements of the&quot;</span></span>
<span class="lineno"> 6115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given element type.&quot;</span></span>
<span class="lineno"> 6116 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6117 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6118 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_class&quot;          &quot;String -&gt; JavaType&quot;</span>
<span class="lineno"> 6119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaClass)</span></span>
<span class="lineno"> 6120 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6121 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type corresponding to the named class.&quot; ]</span></span>
<span class="lineno"> 6122 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6123 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6124 </span><span class="spaces">    </span><span class="istickedoff">-- Java values / terms</span>
<span class="lineno"> 6125 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6126 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_null&quot;</span>
<span class="lineno"> 6127 </span><span class="spaces">    </span><span class="istickedoff">&quot;JVMValue&quot;</span>
<span class="lineno"> 6128 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupNull <span class="nottickedoff">()</span> :: CMS.SetupValue CJ.JVM))</span>
<span class="lineno"> 6129 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A JVMValue representing a null pointer value.&quot; ]</span></span>
<span class="lineno"> 6131 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6132 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_term&quot;</span>
<span class="lineno"> 6133 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; JVMValue&quot;</span>
<span class="lineno"> 6134 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTerm :: TypedTerm -&gt; CMS.SetupValue CJ.JVM))</span>
<span class="lineno"> 6135 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a 'JVMValue' from a 'Term'.&quot; ]</span></span>
<span class="lineno"> 6137 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6138 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6139 </span><span class="spaces">    </span><span class="istickedoff">-- Java fresh values</span>
<span class="lineno"> 6140 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6141 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_fresh_var&quot; &quot;String -&gt; JavaType -&gt; JVMSetup Term&quot;</span>
<span class="lineno"> 6142 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_fresh_var)</span>
<span class="lineno"> 6143 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh variable for use within a JVM specification. The&quot;</span></span>
<span class="lineno"> 6145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 6146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6147 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6148 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6149 </span><span class="spaces">    </span><span class="istickedoff">-- Java allocation</span>
<span class="lineno"> 6150 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6151 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_alloc_object&quot; &quot;String -&gt; JVMSetup JVMValue&quot;</span>
<span class="lineno"> 6152 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_alloc_object)</span>
<span class="lineno"> 6153 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an instance of the given class should be allocated&quot;</span></span>
<span class="lineno"> 6155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a JVM specification. Before 'jvm_execute_func', this states&quot;</span></span>
<span class="lineno"> 6156 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that the method expects the object to be allocated before it&quot;</span></span>
<span class="lineno"> 6157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;runs. After 'jvm_execute_func', it states that the method being&quot;</span></span>
<span class="lineno"> 6158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6160 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6161 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_alloc_array&quot; &quot;Int -&gt; JavaType -&gt; JVMSetup JVMValue&quot;</span>
<span class="lineno"> 6162 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_alloc_array)</span>
<span class="lineno"> 6163 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6164 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an array of the given size and element type should&quot;</span></span>
<span class="lineno"> 6165 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be allocated in a JVM specification. Before 'jvm_execute_func',&quot;</span></span>
<span class="lineno"> 6166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this states that the method expects the array to be allocated&quot;</span></span>
<span class="lineno"> 6167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'jvm_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6170 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6171 </span><span class="spaces">    </span><span class="istickedoff">-- TODO: jvm_alloc_multiarray</span>
<span class="lineno"> 6172 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6173 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6174 </span><span class="spaces">    </span><span class="istickedoff">-- Java assertions</span>
<span class="lineno"> 6175 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6176 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_precond&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6177 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_precond)</span>
<span class="lineno"> 6178 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6179 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition for the&quot;</span></span>
<span class="lineno"> 6180 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the method being verified.&quot;</span></span>
<span class="lineno"> 6181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6182 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6183 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_postcond&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_postcond)</span></span>
<span class="lineno"> 6185 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of the&quot;</span></span>
<span class="lineno"> 6187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the method being verified.&quot;</span></span>
<span class="lineno"> 6188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6189 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6190 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_assert&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6191 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_assert)</span>
<span class="lineno"> 6192 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as 'jvm_precond'&quot;</span></span>
<span class="lineno"> 6194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or 'jvm_postcond' depending on where it appears, that is, before&quot;</span></span>
<span class="lineno"> 6195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or after 'jvm_execute_func'.&quot;</span></span>
<span class="lineno"> 6196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6198 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_equal&quot; &quot;JVMValue -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6199 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_equal)</span>
<span class="lineno"> 6200 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two JVM values should be equal. Can be used as either&quot;</span></span>
<span class="lineno"> 6202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pre-condition or a post-condition. It is semantically&quot;</span></span>
<span class="lineno"> 6203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;equivalent to a 'jvm_precond' or 'jvm_postcond' statement that&quot;</span></span>
<span class="lineno"> 6204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is an equality predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 6205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6206 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6207 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_field&quot; &quot;JVMValue -&gt; String -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6208 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_field)</span>
<span class="lineno"> 6209 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated object (first argument) has a field&quot;</span></span>
<span class="lineno"> 6211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing an unspecified value.&quot;</span></span>
<span class="lineno"> 6212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 6214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 6215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the field, but says nothing&quot;</span></span>
<span class="lineno"> 6216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the new value.&quot;</span></span>
<span class="lineno"> 6217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6218 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6219 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_static_field&quot; &quot;String -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6220 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_static_field)</span>
<span class="lineno"> 6221 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the named static field contains an unspecified&quot;</span></span>
<span class="lineno"> 6223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value.&quot;</span></span>
<span class="lineno"> 6224 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6225 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 6226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), it&quot;</span></span>
<span class="lineno"> 6227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the static field, but says&quot;</span></span>
<span class="lineno"> 6228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 6229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6231 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_elem&quot; &quot;JVMValue -&gt; Int -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6232 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_elem)</span>
<span class="lineno"> 6233 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6234 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array (first argument) has an element&quot;</span></span>
<span class="lineno"> 6235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing an unspecified value.&quot;</span></span>
<span class="lineno"> 6236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 6238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), it&quot;</span></span>
<span class="lineno"> 6239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the array element, but says&quot;</span></span>
<span class="lineno"> 6240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 6241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6242 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6243 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_array&quot; &quot;JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6244 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_array)</span>
<span class="lineno"> 6245 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array's elements contain unspecified&quot;</span></span>
<span class="lineno"> 6247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values.&quot;</span></span>
<span class="lineno"> 6248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 6250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), it&quot;</span></span>
<span class="lineno"> 6251 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the array elements, but says&quot;</span></span>
<span class="lineno"> 6252 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new values.&quot;</span></span>
<span class="lineno"> 6253 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6254 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6255 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_field_is&quot; &quot;JVMValue -&gt; String -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6256 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_field_is)</span>
<span class="lineno"> 6257 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated object (first argument) has a field&quot;</span></span>
<span class="lineno"> 6259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing the given value (third argument).&quot;</span></span>
<span class="lineno"> 6260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'jvm_execute_func') this&quot;</span></span>
<span class="lineno"> 6262 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 6263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 6264 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;asserts the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 6265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6266 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6267 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_static_field_is&quot; &quot;String -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6268 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_static_field_is)</span>
<span class="lineno"> 6269 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the named static field contains the given value.&quot;</span></span>
<span class="lineno"> 6271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;By default the field name is assumed to belong to the same class&quot;</span></span>
<span class="lineno"> 6272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the method being specified. Static fields belonging to other&quot;</span></span>
<span class="lineno"> 6273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;classes can be selected using the \&quot;&lt;classname&gt;.&lt;fieldname&gt;\&quot;&quot;</span></span>
<span class="lineno"> 6274 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;syntax in the string argument.&quot;</span></span>
<span class="lineno"> 6275 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6276 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'jvm_execute_func') this&quot;</span></span>
<span class="lineno"> 6277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 6278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 6279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;asserts the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 6280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6281 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6282 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_elem_is&quot; &quot;JVMValue -&gt; Int -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6283 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_elem_is)</span>
<span class="lineno"> 6284 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array (first argument) has an element&quot;</span></span>
<span class="lineno"> 6286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing the given value (third argument).&quot;</span></span>
<span class="lineno"> 6287 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'jvm_execute_func') this&quot;</span></span>
<span class="lineno"> 6289 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 6290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 6291 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;asserts the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 6292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6293 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6294 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_array_is&quot; &quot;JVMValue -&gt; Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6295 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_array_is)</span>
<span class="lineno"> 6296 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6297 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array reference (first argument)&quot;</span></span>
<span class="lineno"> 6298 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;contains the given sequence of values (second argument).&quot;</span></span>
<span class="lineno"> 6299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'jvm_execute_func') this&quot;</span></span>
<span class="lineno"> 6301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 6302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'jvm_execute_func'), this&quot;</span></span>
<span class="lineno"> 6303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;asserts the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 6304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6305 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6306 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_execute_func&quot; &quot;[JVMValue] -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6307 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_execute_func)</span>
<span class="lineno"> 6308 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the method.&quot;</span></span>
<span class="lineno"> 6310 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 6311 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The 'jvm_execute_func' command also serves to separate the pre-&quot;</span></span>
<span class="lineno"> 6312 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;state section of the spec (before it) from the post-state&quot;</span></span>
<span class="lineno"> 6313 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after it). The effects of some JVMSetup statements&quot;</span></span>
<span class="lineno"> 6314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 6315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 6316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Every JVM specification must use this command to call its&quot;</span></span>
<span class="lineno"> 6318 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 6319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6320 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6321 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_return&quot; &quot;JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 6322 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_return)</span>
<span class="lineno"> 6323 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the method. A&quot;</span></span>
<span class="lineno"> 6325 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'jvm_return' command is required if and only if the method has&quot;</span></span>
<span class="lineno"> 6326 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a non-void return type.&quot;</span></span>
<span class="lineno"> 6327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6328 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6329 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6330 </span><span class="spaces">    </span><span class="istickedoff">-- Java class files / modules</span>
<span class="lineno"> 6331 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6332 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_load_class&quot;     &quot;String -&gt; TopLevel JavaClass&quot;</span>
<span class="lineno"> 6333 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CJ.loadJavaClass)</span>
<span class="lineno"> 6334 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load the named Java class and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 6336 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6337 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6338 </span><span class="spaces">    </span><span class="istickedoff">-- Java verification</span>
<span class="lineno"> 6339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6340 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_extract&quot;  &quot;JavaClass -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6341 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CJ.jvm_extract)</span>
<span class="lineno"> 6342 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a Java method directly to a Term. The parameters of&quot;</span></span>
<span class="lineno"> 6344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the Term will be the parameters of the Java method, and the&quot;</span></span>
<span class="lineno"> 6345 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return value will be the return value of the method. Only&quot;</span></span>
<span class="lineno"> 6346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;methods with scalar argument and return types are currently&quot;</span></span>
<span class="lineno"> 6347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;supported.&quot;</span></span>
<span class="lineno"> 6348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6349 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_java_extract&quot;  &quot;JavaClass -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CJ.jvm_extract)</span></span>
<span class="lineno"> 6351 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for 'jvm_extract'.&quot; ]</span></span>
<span class="lineno"> 6353 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6354 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_verify&quot;</span>
<span class="lineno"> 6355 </span><span class="spaces">    </span><span class="istickedoff">(&quot;JavaClass -&gt; String -&gt; [JVMSpec] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 6356 </span><span class="spaces">     </span><span class="istickedoff">&quot;JVMSetup () -&gt; ProofScript () -&gt; TopLevel JVMSpec&quot;)</span>
<span class="lineno"> 6357 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_verify)</span>
<span class="lineno"> 6358 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the JVM method named by the second parameter in the class&quot;</span></span>
<span class="lineno"> 6360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the JVMSpec&quot;</span></span>
<span class="lineno"> 6361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values returned by previous calls to use as overrides. The&quot;</span></span>
<span class="lineno"> 6362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fourth (Bool) parameter enables or disables path satisfiability&quot;</span></span>
<span class="lineno"> 6363 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;checking. The fifth describes how to set up the symbolic&quot;</span></span>
<span class="lineno"> 6364 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution engine before verification. And the last gives the&quot;</span></span>
<span class="lineno"> 6365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 6366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 6367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6369 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 6370 </span><span class="spaces">    </span><span class="istickedoff">&quot;JavaClass -&gt; String -&gt; JVMSetup () -&gt; TopLevel JVMSpec&quot;</span>
<span class="lineno"> 6371 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_unsafe_assume_spec)</span>
<span class="lineno"> 6372 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 6373 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a JVMSpec corresponding to a JVMSetup block, as would be&quot;</span></span>
<span class="lineno"> 6374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by jvm_verify but without performing any verification.&quot;</span></span>
<span class="lineno"> 6375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6376 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6377 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6378 </span><span class="spaces">    </span><span class="istickedoff">-- MIR types</span>
<span class="lineno"> 6379 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6380 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_bool&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6381 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_bool)</span>
<span class="lineno"> 6382 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6383 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR booleans.&quot; ]</span></span>
<span class="lineno"> 6384 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6385 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_char&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6386 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_char)</span>
<span class="lineno"> 6387 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR characters.&quot; ]</span></span>
<span class="lineno"> 6389 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6390 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i8&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6391 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i8)</span>
<span class="lineno"> 6392 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6393 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 8-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6394 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6395 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i16&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6396 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i16)</span>
<span class="lineno"> 6397 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 16-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6399 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6400 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6401 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i32)</span>
<span class="lineno"> 6402 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6403 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 32-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6404 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6405 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6406 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i64)</span>
<span class="lineno"> 6407 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6408 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 64-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6409 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6410 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i128&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6411 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i128)</span>
<span class="lineno"> 6412 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 128-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 6414 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6415 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_isize&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6416 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_isize)</span>
<span class="lineno"> 6417 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR pointer-sized signed integers.&quot; ]</span></span>
<span class="lineno"> 6419 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6420 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u8&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6421 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u8)</span>
<span class="lineno"> 6422 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 8-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6425 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u16&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6426 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u16)</span>
<span class="lineno"> 6427 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6428 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 16-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6429 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6430 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6431 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u32)</span>
<span class="lineno"> 6432 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6433 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 32-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6434 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6435 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6436 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u64)</span>
<span class="lineno"> 6437 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6438 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 64-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6439 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6440 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u128&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6441 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u128)</span>
<span class="lineno"> 6442 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 128-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6444 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6445 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_usize&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6446 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_usize)</span>
<span class="lineno"> 6447 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR pointer-sized unsigned integers.&quot; ]</span></span>
<span class="lineno"> 6449 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6450 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_f32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_f32)</span></span>
<span class="lineno"> 6452 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6453 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR single-precision floating-point values.&quot; ]</span></span>
<span class="lineno"> 6454 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6455 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_f64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_f64)</span></span>
<span class="lineno"> 6457 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR double-precision floating-point values.&quot; ]</span></span>
<span class="lineno"> 6459 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6460 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_tuple&quot; &quot;[MIRType] -&gt; MIRType&quot;</span>
<span class="lineno"> 6461 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_tuple)</span>
<span class="lineno"> 6462 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6463 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR tuples of the given types.&quot; ]</span></span>
<span class="lineno"> 6464 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6465 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_adt&quot; &quot;MIRAdt -&gt; MIRType&quot;</span>
<span class="lineno"> 6466 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_adt)</span>
<span class="lineno"> 6467 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6468 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of a MIR algebraic data type (ADT), i.e., a struct or&quot;</span></span>
<span class="lineno"> 6469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;enum, corresponding to the given MIRAdt. Use the 'mir_find_adt'&quot;</span></span>
<span class="lineno"> 6470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;command to retrieve a MIRAdt value.&quot;</span></span>
<span class="lineno"> 6471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6473 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6474 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref)</span>
<span class="lineno"> 6475 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR immutable references.&quot; ]</span></span>
<span class="lineno"> 6477 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6478 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_mut&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6479 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_mut)</span>
<span class="lineno"> 6480 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR mutable references.&quot; ]</span></span>
<span class="lineno"> 6482 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6483 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_raw_ptr_const&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_raw_ptr_const)</span></span>
<span class="lineno"> 6485 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6486 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR immutable raw pointers.&quot; ]</span></span>
<span class="lineno"> 6487 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6488 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_raw_ptr_mut&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_raw_ptr_mut)</span></span>
<span class="lineno"> 6490 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR mutable raw pointers.&quot; ]</span></span>
<span class="lineno"> 6492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6493 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_array&quot; &quot;Int -&gt; MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6494 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_array)</span>
<span class="lineno"> 6495 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6496 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR arrays with the given number of elements of the&quot;</span></span>
<span class="lineno"> 6497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type.&quot;</span></span>
<span class="lineno"> 6498 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6499 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6500 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6501 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice)</span>
<span class="lineno"> 6502 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR slices, i.e., dynamically sized views into a&quot;</span></span>
<span class="lineno"> 6504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;contiguous sequence of the given type. Currently, SAW can only&quot;</span></span>
<span class="lineno"> 6505 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;handle references to slices (&amp;[T]).&quot;</span></span>
<span class="lineno"> 6506 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6507 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6508 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6509 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str)</span>
<span class="lineno"> 6510 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR strings, which are a particular kind of slice.&quot;</span></span>
<span class="lineno"> 6512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Currently, SAW can only handle references to strings (&amp;str).&quot;</span></span>
<span class="lineno"> 6513 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6514 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6515 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_const&quot; &quot;MIRType -&gt; Term -&gt; MIRType&quot;</span>
<span class="lineno"> 6516 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 mir_const)</span>
<span class="lineno"> 6517 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6518 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A constant value used to instantiate a const generic parameter.&quot;</span></span>
<span class="lineno"> 6519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is intended to be used in conjunction with 'mir_find_adt'&quot;</span></span>
<span class="lineno"> 6520 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to look up instantiations of const generic ADTs. This is never&quot;</span></span>
<span class="lineno"> 6521 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;used to represent the type of a value in its own right, so using&quot;</span></span>
<span class="lineno"> 6522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this in conjunction with 'mir_alloc', 'mir_fresh_var', etc. will&quot;</span></span>
<span class="lineno"> 6523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;raise an error.&quot;</span></span>
<span class="lineno"> 6524 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The MIRType argument represents the type of the constant, and&quot;</span></span>
<span class="lineno"> 6526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the Term argument represents the value of the constant. At&quot;</span></span>
<span class="lineno"> 6527 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;present, only a subset of MIR primitive types are supported in&quot;</span></span>
<span class="lineno"> 6528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'mir_const'. See the SAW manual for a more detailed description&quot;</span></span>
<span class="lineno"> 6529 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of which types are supported, along with restrictions on what&quot;</span></span>
<span class="lineno"> 6530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;forms the Terms can have.&quot;</span></span>
<span class="lineno"> 6531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6532 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6533 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_lifetime&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 6534 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_lifetime)</span>
<span class="lineno"> 6535 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR lifetimes.&quot; ]</span></span>
<span class="lineno"> 6537 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6538 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_find_adt&quot; &quot;MIRModule -&gt; String -&gt; [MIRType] -&gt; MIRAdt&quot;</span>
<span class="lineno"> 6539 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_find_adt)</span>
<span class="lineno"> 6540 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6541 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Consult the given MIRModule to find an algebraic data type&quot;</span></span>
<span class="lineno"> 6542 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(MIRAdt) with the given String as an identifier and the given&quot;</span></span>
<span class="lineno"> 6543 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;MIRTypes as the types used to instantiate the type parameters.&quot;</span></span>
<span class="lineno"> 6544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fails if such a MIRAdt cannot be found in the MIRModule.&quot;</span></span>
<span class="lineno"> 6545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6546 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6547 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_find_mangled_adt&quot; &quot;MIRModule -&gt; String -&gt; MIRAdt&quot;</span>
<span class="lineno"> 6548 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 mir_find_mangled_adt)</span>
<span class="lineno"> 6549 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Consult the given MIRModule to find an algebraic data type&quot;</span></span>
<span class="lineno"> 6551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(MIRAdt) with the given String as a mangled identifier. A&quot;</span></span>
<span class="lineno"> 6552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mangled identifier is one referring to an ADT that is already&quot;</span></span>
<span class="lineno"> 6553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;instantiated with its type arguments (so foo::Bar::_adt123456789&quot;</span></span>
<span class="lineno"> 6554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is a mangled identifier, but foo::Bar is not). Fails if such a&quot;</span></span>
<span class="lineno"> 6555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;MIRAdt cannot be found in the MIRModule.&quot;</span></span>
<span class="lineno"> 6556 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6557 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Due to the fact that mangled identifiers can change easily when&quot;</span></span>
<span class="lineno"> 6558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;recompiling Rust code, this function's use is discouraged in&quot;</span></span>
<span class="lineno"> 6559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;favor of using 'mir_find_adt' whenever possible.&quot;</span></span>
<span class="lineno"> 6560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6561 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6562 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_vec&quot; &quot;MIRModule -&gt; MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 6563 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 mir_vec)</span>
<span class="lineno"> 6564 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR vectors, i.e., Vec&lt;T&gt; (for some type T).&quot;</span></span>
<span class="lineno"> 6566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This requires looking up Vec-related relevant identifiers&quot;</span></span>
<span class="lineno"> 6567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the supplied MIRModule.&quot;</span></span>
<span class="lineno"> 6568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6569 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6570 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6571 </span><span class="spaces">    </span><span class="istickedoff">-- MIR values / terms</span>
<span class="lineno"> 6572 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6573 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_find_name&quot; &quot;MIRModule -&gt; String -&gt; [MIRType] -&gt; String&quot;</span>
<span class="lineno"> 6574 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_find_name)</span>
<span class="lineno"> 6575 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Consult the given MIRModule to find an instantiation of a&quot;</span></span>
<span class="lineno"> 6577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function with the given String as an identifier and the given&quot;</span></span>
<span class="lineno"> 6578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;MIRTypes as the types used to instantiate the type parameters.&quot;</span></span>
<span class="lineno"> 6579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fails if such an instantiation cannot be found in the MIRModule.&quot;</span></span>
<span class="lineno"> 6580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6581 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6582 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_term&quot;</span>
<span class="lineno"> 6583 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; MIRValue&quot;</span>
<span class="lineno"> 6584 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTerm :: TypedTerm -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6585 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6586 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a 'MIRValue' from a 'Term'.&quot; ]</span></span>
<span class="lineno"> 6587 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6588 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_enum_value&quot; &quot;MIRAdt -&gt; String -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 6589 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_enum_value)</span>
<span class="lineno"> 6590 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a variant of a MIR enum with the&quot;</span></span>
<span class="lineno"> 6592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of values as elements. The MIRAdt argument determines&quot;</span></span>
<span class="lineno"> 6593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;what enum type to create; use 'mir_find_adt' to retrieve a&quot;</span></span>
<span class="lineno"> 6594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;MIRAdt value. The String argument represents the variant name.&quot;</span></span>
<span class="lineno"> 6595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6596 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6597 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_tuple_value&quot; &quot;[MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 6598 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTuple () :: [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6599 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6600 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a MIR tuple with the given list&quot;</span></span>
<span class="lineno"> 6601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values as elements.&quot;</span></span>
<span class="lineno"> 6602 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6603 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6604 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_array_value&quot; &quot;MIRType -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 6605 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupArray :: MIR.Ty -&gt; [CMS.SetupValue MIR] -&gt;</span>
<span class="lineno"> 6606 </span><span class="spaces">              </span><span class="istickedoff">CMS.SetupValue MIR))</span>
<span class="lineno"> 6607 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6608 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing an array of the given type, with&quot;</span></span>
<span class="lineno"> 6609 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given list of values as elements.&quot;</span></span>
<span class="lineno"> 6610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6611 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6612 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_elem_value&quot; &quot;MIRValue -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 6613 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_elem_value)</span>
<span class="lineno"> 6614 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6615 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a MIR array value and an index, return the MIR value in&quot;</span></span>
<span class="lineno"> 6616 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the array at that index.&quot;</span></span>
<span class="lineno"> 6617 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6618 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6619 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_elem_ref&quot; &quot;MIRValue -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 6620 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_elem_ref)</span>
<span class="lineno"> 6621 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6622 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a reference (or raw pointer) to a MIR array, and an index,&quot;</span></span>
<span class="lineno"> 6623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return a reference (resp. raw pointer) to the element in that&quot;</span></span>
<span class="lineno"> 6624 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;array at that index.&quot;</span></span>
<span class="lineno"> 6625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: If the given reference (or raw pointer) has been created&quot;</span></span>
<span class="lineno"> 6627 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with 'mir_alloc' or 'mir_alloc_raw_ptr', the whole reference&quot;</span></span>
<span class="lineno"> 6628 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(resp. raw pointer) must be initialized with 'mir_points_to'&quot;</span></span>
<span class="lineno"> 6629 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before 'mir_elem_ref' can be used on it.&quot;</span></span>
<span class="lineno"> 6630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6631 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6632 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice_value&quot; &quot;MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 6633 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice_value)</span>
<span class="lineno"> 6634 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;[T]. The&quot;</span></span>
<span class="lineno"> 6636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument must be a reference to an array value, whose overall&quot;</span></span>
<span class="lineno"> 6637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type must be &amp;[T; N] for some length N.&quot;</span></span>
<span class="lineno"> 6638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6640 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice_range_value&quot; &quot;MIRValue -&gt; Int -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 6641 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice_range_value)</span>
<span class="lineno"> 6642 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6643 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;[T] over a given&quot;</span></span>
<span class="lineno"> 6644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;range. The first argument must be a reference to an array value,&quot;</span></span>
<span class="lineno"> 6645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;whose overall type must be &amp;[T; N] for some length N. The second&quot;</span></span>
<span class="lineno"> 6646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and third arguments represent the start and end of the range.&quot;</span></span>
<span class="lineno"> 6647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The start must not exceed the end, and the end must not exceed N.&quot;</span></span>
<span class="lineno"> 6648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6649 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6650 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str_slice_value&quot; &quot;MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 6651 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str_slice_value)</span>
<span class="lineno"> 6652 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;str. The&quot;</span></span>
<span class="lineno"> 6654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument must be a reference to an array value, whose overall&quot;</span></span>
<span class="lineno"> 6655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type must be &amp;[u8; N] for some length N. This array is expected&quot;</span></span>
<span class="lineno"> 6656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to be a UTF-8-encoded sequence of bytes.&quot;</span></span>
<span class="lineno"> 6657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6658 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6659 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str_slice_range_value&quot; &quot;MIRValue -&gt; Int -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 6660 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str_slice_range_value)</span>
<span class="lineno"> 6661 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;str over a given&quot;</span></span>
<span class="lineno"> 6663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;range. The first argument must be a reference to an array value,&quot;</span></span>
<span class="lineno"> 6664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;whose overall type must be &amp;[u8; N] for some length N. This&quot;</span></span>
<span class="lineno"> 6665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;array is expected to be a UTF-8-encoded sequence of bytes. The&quot;</span></span>
<span class="lineno"> 6666 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second and third arguments represent the start and end of the&quot;</span></span>
<span class="lineno"> 6667 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;range. The start must not exceed the end, and the end must not&quot;</span></span>
<span class="lineno"> 6668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exceed N.&quot;</span></span>
<span class="lineno"> 6669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6670 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6671 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_struct_value&quot; &quot;MIRAdt -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 6672 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupStruct :: MIR.Adt -&gt; [CMS.SetupValue MIR] -&gt;</span>
<span class="lineno"> 6673 </span><span class="spaces">              </span><span class="istickedoff">CMS.SetupValue MIR))</span>
<span class="lineno"> 6674 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a MIR struct with the given list&quot;</span></span>
<span class="lineno"> 6676 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values as elements. The MIRAdt argument determines what&quot;</span></span>
<span class="lineno"> 6677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;struct type to create; use 'mir_find_adt' to retrieve a MIRAdt&quot;</span></span>
<span class="lineno"> 6678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value.&quot;</span></span>
<span class="lineno"> 6679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6681 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_mux_values&quot; &quot;Term -&gt; MIRValue -&gt; MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 6682 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_mux_values)</span>
<span class="lineno"> 6683 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Multiplex two MIRValues based on whether a (possibly symbolic)&quot;</span></span>
<span class="lineno"> 6685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term predicate holds or not. The Term argument must have the&quot;</span></span>
<span class="lineno"> 6686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol type Bit, and the two MIRValue arguments must have the&quot;</span></span>
<span class="lineno"> 6687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;same type.&quot;</span></span>
<span class="lineno"> 6688 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6689 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6690 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_static&quot;</span>
<span class="lineno"> 6691 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRValue&quot;</span>
<span class="lineno"> 6692 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupGlobal () :: Text -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6693 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRValue representing a reference to the named static.&quot;</span></span>
<span class="lineno"> 6695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The String should be the name of a static value.&quot;</span></span>
<span class="lineno"> 6696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6697 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6698 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_static_initializer&quot;</span>
<span class="lineno"> 6699 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRValue&quot;</span>
<span class="lineno"> 6700 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupGlobalInitializer () :: Text -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 6701 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6702 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRValue representing the value of the initializer of a&quot;</span></span>
<span class="lineno"> 6703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;named static. The String should be the name of a static value.&quot;</span></span>
<span class="lineno"> 6704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6705 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6706 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_cast_raw_ptr&quot; &quot;MIRValue -&gt; MIRType -&gt; MIRValue&quot;</span>
<span class="lineno"> 6707 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_cast_raw_ptr)</span>
<span class="lineno"> 6708 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a raw pointer, return a raw pointer to the same memory&quot;</span></span>
<span class="lineno"> 6710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;location and with the same mutability, but with the given type&quot;</span></span>
<span class="lineno"> 6711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the pointee type instead.&quot;</span></span>
<span class="lineno"> 6712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that this only changes the pointee type as statically&quot;</span></span>
<span class="lineno"> 6714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;tracked by SAW. It does not allow you to reinterpret the value&quot;</span></span>
<span class="lineno"> 6715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pointed to as a type other than what it was originally allocated&quot;</span></span>
<span class="lineno"> 6716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as with 'mir_alloc_raw_ptr'. Therefore, it cannot be used in the&quot;</span></span>
<span class="lineno"> 6717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument to 'mir_points_to'.&quot;</span></span>
<span class="lineno"> 6718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6719 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6720 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6721 </span><span class="spaces">    </span><span class="istickedoff">-- MIR fresh values</span>
<span class="lineno"> 6722 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6723 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; MIRSetup Term&quot;</span>
<span class="lineno"> 6724 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_cryptol_var)</span>
<span class="lineno"> 6725 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given Cryptol type for&quot;</span></span>
<span class="lineno"> 6727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use within a MIR specification. The given name is used only for&quot;</span></span>
<span class="lineno"> 6728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pretty-printing. Unlike 'mir_fresh_var', this can be used when&quot;</span></span>
<span class="lineno"> 6729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;there isn't an appropriate MIR type, such as the Cryptol Array&quot;</span></span>
<span class="lineno"> 6730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type.&quot;</span></span>
<span class="lineno"> 6731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6732 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6733 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_expanded_value&quot; &quot;String -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6734 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_expanded_value)</span>
<span class="lineno"> 6735 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6736 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIR value entirely populated with fresh symbolic&quot;</span></span>
<span class="lineno"> 6737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables. For compound types such as structs and arrays, this&quot;</span></span>
<span class="lineno"> 6738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will explicitly set each field or element to contain a fresh&quot;</span></span>
<span class="lineno"> 6739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic variable. The String argument is used as a prefix in&quot;</span></span>
<span class="lineno"> 6740 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;each of the symbolic variables.&quot;</span></span>
<span class="lineno"> 6741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6742 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6743 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_var&quot; &quot;String -&gt; MIRType -&gt; MIRSetup Term&quot;</span>
<span class="lineno"> 6744 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_var)</span>
<span class="lineno"> 6745 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable for use within a MIR&quot;</span></span>
<span class="lineno"> 6747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification. The name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 6748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6749 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6750 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6751 </span><span class="spaces">    </span><span class="istickedoff">-- MIR allocation</span>
<span class="lineno"> 6752 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6753 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6754 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc)</span>
<span class="lineno"> 6755 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable reference to the given type should be&quot;</span></span>
<span class="lineno"> 6757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in a MIR specification. Before 'mir_execute_func',&quot;</span></span>
<span class="lineno"> 6758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this states that the function expects the object to be allocated&quot;</span></span>
<span class="lineno"> 6759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'mir_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6761 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6762 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will raise an error if a 'mir_slice' or 'mir_str'&quot;</span></span>
<span class="lineno"> 6763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type is passed as an argument. To create a slice reference, use&quot;</span></span>
<span class="lineno"> 6764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the 'mir_slice_value' or 'mir_slice_range_value' functions&quot;</span></span>
<span class="lineno"> 6765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;instead.&quot;</span></span>
<span class="lineno"> 6766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6767 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6768 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_mut&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6769 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_mut)</span>
<span class="lineno"> 6770 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a mutable reference to the given type should be&quot;</span></span>
<span class="lineno"> 6772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in a MIR specification. Before 'mir_execute_func',&quot;</span></span>
<span class="lineno"> 6773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this states that the function expects the object to be allocated&quot;</span></span>
<span class="lineno"> 6774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'mir_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6775 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will raise an error if a 'mir_slice' or 'mir_str'&quot;</span></span>
<span class="lineno"> 6778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type is passed as an argument. To create a slice reference, use&quot;</span></span>
<span class="lineno"> 6779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the 'mir_slice_value' or 'mir_slice_range_value' functions&quot;</span></span>
<span class="lineno"> 6780 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;instead.&quot;</span></span>
<span class="lineno"> 6781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6782 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6783 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_const&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6784 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_raw_ptr_const)</span>
<span class="lineno"> 6785 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable raw pointer to the given type should&quot;</span></span>
<span class="lineno"> 6787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be allocated in a MIR specification. Before 'mir_execute_func',&quot;</span></span>
<span class="lineno"> 6788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this states that the function expects the object to be allocated&quot;</span></span>
<span class="lineno"> 6789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'mir_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6792 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6793 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_const_multi&quot; &quot;Int -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6794 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_raw_ptr_const_multi)</span>
<span class="lineno"> 6795 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable raw pointer to a contiguous sequence&quot;</span></span>
<span class="lineno"> 6797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values should be allocated in a MIR specification. The first&quot;</span></span>
<span class="lineno"> 6798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument specifies the number of values and the second argument&quot;</span></span>
<span class="lineno"> 6799 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies a type for the values. Before 'mir_execute_func', this&quot;</span></span>
<span class="lineno"> 6800 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the function expects the memory to be allocated&quot;</span></span>
<span class="lineno"> 6801 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'mir_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6804 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6805 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_mut&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6806 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_raw_ptr_mut)</span>
<span class="lineno"> 6807 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a mutable raw pointer to the given type should be&quot;</span></span>
<span class="lineno"> 6809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in a MIR specification. Before 'mir_execute_func',&quot;</span></span>
<span class="lineno"> 6810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this states that the function expects the object to be allocated&quot;</span></span>
<span class="lineno"> 6811 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'mir_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6812 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6814 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6815 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_raw_ptr_mut_multi&quot; &quot;Int -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_alloc_raw_ptr_mut_multi)</span></span>
<span class="lineno"> 6817 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a mutable raw pointer to a contiguous sequence of&quot;</span></span>
<span class="lineno"> 6819 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values should be allocated in a MIR specification. The first&quot;</span></span>
<span class="lineno"> 6820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument specifies the number of values and the second argument&quot;</span></span>
<span class="lineno"> 6821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies a type for the values. Before 'mir_execute_func', this&quot;</span></span>
<span class="lineno"> 6822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the function expects the memory to be allocated&quot;</span></span>
<span class="lineno"> 6823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before it runs. After 'mir_execute_func', it states that the&quot;</span></span>
<span class="lineno"> 6824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 6825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6827 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_of&quot; &quot;MIRValue -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6828 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_of)</span>
<span class="lineno"> 6829 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates an immutable reference and initializes it to point to&quot;</span></span>
<span class="lineno"> 6831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given MIRValue.&quot;</span></span>
<span class="lineno"> 6832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6833 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6834 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_of_mut&quot; &quot;MIRValue -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6835 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_of_mut)</span>
<span class="lineno"> 6836 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6837 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates a mutable reference and initializes it to point to the&quot;</span></span>
<span class="lineno"> 6838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given MIRValue.&quot;</span></span>
<span class="lineno"> 6839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6840 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6841 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_vec_of&quot;</span>
<span class="lineno"> 6842 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRType -&gt; MIRValue -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 6843 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_vec_of)</span>
<span class="lineno"> 6844 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIR 'Vec' value. The String argument is used as a&quot;</span></span>
<span class="lineno"> 6846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;prefix for naming the internal symbolic variables created as&quot;</span></span>
<span class="lineno"> 6847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;part of the 'Vec' struct. The MIRType argument is the element&quot;</span></span>
<span class="lineno"> 6848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type of the 'Vec'. The MIRValue argument gives the contents of&quot;</span></span>
<span class="lineno"> 6849 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the 'Vec', which must be a MIR array value whose element type&quot;</span></span>
<span class="lineno"> 6850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;matches the MIRType argument.&quot;</span></span>
<span class="lineno"> 6851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6852 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6853 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6854 </span><span class="spaces">    </span><span class="istickedoff">-- MIR assertions</span>
<span class="lineno"> 6855 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6856 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_postcond&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6857 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_postcond)</span>
<span class="lineno"> 6858 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition for the&quot;</span></span>
<span class="lineno"> 6860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the method being verified.&quot;</span></span>
<span class="lineno"> 6861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6862 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6863 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_precond&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6864 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_precond)</span>
<span class="lineno"> 6865 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on the&quot;</span></span>
<span class="lineno"> 6867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution of the method being verified.&quot;</span></span>
<span class="lineno"> 6868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6869 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6870 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_assert&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6871 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_assert)</span>
<span class="lineno"> 6872 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6873 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as 'mir_precond'&quot;</span></span>
<span class="lineno"> 6874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or 'mir_postcond' depending on whether it appears before or&quot;</span></span>
<span class="lineno"> 6875 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;after 'mir_execute_func'.&quot;</span></span>
<span class="lineno"> 6876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6877 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6878 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_equal&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6879 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_equal)</span>
<span class="lineno"> 6880 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6881 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two MIR values should be equal. Can be used as either&quot;</span></span>
<span class="lineno"> 6882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pre-condition or a post-condition. It is semantically&quot;</span></span>
<span class="lineno"> 6883 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;equivalent to a 'mir_precond' or 'mir_postcond' statement that&quot;</span></span>
<span class="lineno"> 6884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is an equality predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 6885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6886 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6887 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_points_to&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6888 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_points_to)</span>
<span class="lineno"> 6889 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6890 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given&quot;</span></span>
<span class="lineno"> 6891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;reference or raw pointer (first argument) contains the given&quot;</span></span>
<span class="lineno"> 6892 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value (second argument).&quot;</span></span>
<span class="lineno"> 6893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'mir_execute_func') this&quot;</span></span>
<span class="lineno"> 6895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 6896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'mir_execute_func'), this&quot;</span></span>
<span class="lineno"> 6897 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;asserts the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 6898 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6899 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6900 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_points_to_multi&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6901 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_points_to_multi)</span>
<span class="lineno"> 6902 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6903 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given raw&quot;</span></span>
<span class="lineno"> 6904 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pointer (first argument) contains the given contiguous sequence&quot;</span></span>
<span class="lineno"> 6905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of values (second argument, which must have MIR array type). If&quot;</span></span>
<span class="lineno"> 6906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the sequence has more than one element, then the raw pointer&quot;</span></span>
<span class="lineno"> 6907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must be allocated with 'mir_alloc_raw_ptr_{const,mut}_multi'&quot;</span></span>
<span class="lineno"> 6908 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with at least as many elements as in the sequence.&quot;</span></span>
<span class="lineno"> 6909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that this is different from a raw pointer pointing to an&quot;</span></span>
<span class="lineno"> 6911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;array of multiple values using 'mir_alloc_raw_ptr_{const,mut}'&quot;</span></span>
<span class="lineno"> 6912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and 'mir_points_to' commands. Here, the pointee type of the&quot;</span></span>
<span class="lineno"> 6913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pointer is the type of each individual element, not an array&quot;</span></span>
<span class="lineno"> 6914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type.&quot;</span></span>
<span class="lineno"> 6915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before 'mir_execute_func') this&quot;</span></span>
<span class="lineno"> 6917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the initial memory layout before function execution.&quot;</span></span>
<span class="lineno"> 6918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after 'mir_execute_func'), this&quot;</span></span>
<span class="lineno"> 6919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;asserts the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 6920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6921 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6922 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_execute_func&quot; &quot;[MIRValue] -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6923 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_execute_func)</span>
<span class="lineno"> 6924 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the method.&quot;</span></span>
<span class="lineno"> 6926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 6927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The mir_execute_func statement also serves to separate the pre-&quot;</span></span>
<span class="lineno"> 6928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;state section of the spec (before it) from the post-state&quot;</span></span>
<span class="lineno"> 6929 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after it). The effects of some MIRSetup statements&quot;</span></span>
<span class="lineno"> 6930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 6931 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 6932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 6933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Every MIR specification must use this command to call its&quot;</span></span>
<span class="lineno"> 6934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 6935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6936 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6937 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_return&quot; &quot;MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 6938 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_return)</span>
<span class="lineno"> 6939 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6940 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the method. A&quot;</span></span>
<span class="lineno"> 6941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mir_return statement is required if and only if the method has&quot;</span></span>
<span class="lineno"> 6942 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a non-() return type.&quot;</span></span>
<span class="lineno"> 6943 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6944 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6945 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6946 </span><span class="spaces">    </span><span class="istickedoff">-- MIR modules</span>
<span class="lineno"> 6947 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6948 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_load_module&quot; &quot;String -&gt; TopLevel MIRModule&quot;</span>
<span class="lineno"> 6949 </span><span class="spaces">    </span><span class="istickedoff">(pureVal do_mir_load_module)</span>
<span class="lineno"> 6950 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6951 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a MIR JSON file and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 6952 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6953 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6954 </span><span class="spaces">    </span><span class="istickedoff">-- MIR verification</span>
<span class="lineno"> 6955 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6956 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_extract&quot; &quot;MIRModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 6957 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_extract)</span>
<span class="lineno"> 6958 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6959 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a MIR function directly to a Term. The parameters of&quot;</span></span>
<span class="lineno"> 6960 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the Term will be the parameters of the MIR function, and the&quot;</span></span>
<span class="lineno"> 6961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return value will be the return value of the function. Only&quot;</span></span>
<span class="lineno"> 6962 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;functions with the following argument and return types are&quot;</span></span>
<span class="lineno"> 6963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;currently supported: primitive integer types (e.g., u8 or i8),&quot;</span></span>
<span class="lineno"> 6964 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bool, char, arrays, and tuples.&quot;</span></span>
<span class="lineno"> 6965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6966 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6967 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_verify&quot;</span>
<span class="lineno"> 6968 </span><span class="spaces">    </span><span class="istickedoff">(&quot;MIRModule -&gt; String -&gt; [MIRSpec] -&gt; Bool -&gt; &quot; &lt;&gt;</span>
<span class="lineno"> 6969 </span><span class="spaces">     </span><span class="istickedoff">&quot;MIRSetup () -&gt; ProofScript () -&gt; TopLevel MIRSpec&quot;)</span>
<span class="lineno"> 6970 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_verify)</span>
<span class="lineno"> 6971 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the MIR function named by the second parameter in the&quot;</span></span>
<span class="lineno"> 6973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;module specified by the first. The third parameter lists the&quot;</span></span>
<span class="lineno"> 6974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;MIRSpec values returned by previous calls to use as overrides.&quot;</span></span>
<span class="lineno"> 6975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth (Bool) parameter enables or disables path&quot;</span></span>
<span class="lineno"> 6976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiability checking. The fifth describes how to set up the&quot;</span></span>
<span class="lineno"> 6977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic execution engine before verification. And the last&quot;</span></span>
<span class="lineno"> 6978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 6979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 6980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6981 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6982 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_unsafe_assume_spec&quot;</span>
<span class="lineno"> 6983 </span><span class="spaces">    </span><span class="istickedoff">&quot;MIRModule -&gt; String -&gt; MIRSetup () -&gt; TopLevel MIRSpec&quot;</span>
<span class="lineno"> 6984 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_unsafe_assume_spec)</span>
<span class="lineno"> 6985 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRSpec corresponding to a MIRSetup block, as would be&quot;</span></span>
<span class="lineno"> 6987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by mir_verify but without performing any verification.&quot;</span></span>
<span class="lineno"> 6988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 6989 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6990 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 6991 </span><span class="spaces">    </span><span class="istickedoff">-- Additional Crucible-related bits</span>
<span class="lineno"> 6992 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 6993 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_setup_with_tag&quot; &quot;String -&gt; LLVMSetup () -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 6994 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_setup_with_tag)</span>
<span class="lineno"> 6995 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 6996 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All conditions (e.g., from points-to or assert statements)&quot;</span></span>
<span class="lineno"> 6997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;executed in the scope of the given setup block will have the&quot;</span></span>
<span class="lineno"> 6998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument string attached as a tag that can later be&quot;</span></span>
<span class="lineno"> 6999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;filtered by proof tactics.&quot;</span></span>
<span class="lineno"> 7000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 7001 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7002 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_setup_with_tag&quot; &quot;String -&gt; JVMSetup () -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 7003 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_setup_with_tag)</span></span>
<span class="lineno"> 7004 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 7005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All conditions (e.g., from points-to or assert statements)&quot;</span></span>
<span class="lineno"> 7006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;executed in the scope of the given setup block will have the&quot;</span></span>
<span class="lineno"> 7007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument string attached as a tag that can later be&quot;</span></span>
<span class="lineno"> 7008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;filtered by proof tactics.&quot;</span></span>
<span class="lineno"> 7009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 7010 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7011 </span><span class="spaces">  </span><span class="istickedoff">] ++</span>
<span class="lineno"> 7012 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">unint_help =</span></span>
<span class="lineno"> 7013 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Keep the given Cryptol/SAWCore names opaque during symbolic&quot;</span></span>
<span class="lineno"> 7014 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;simulation. The command should be used before symbolic execution&quot;</span></span>
<span class="lineno"> 7015 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;begins (i.e., in the pre-condition of the specification). This&quot;</span></span>
<span class="lineno"> 7016 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;command does not affect the ProofScript---to keep names opaque&quot;</span></span>
<span class="lineno"> 7017 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;while discharging goals, you still need to provide them as&quot;</span></span>
<span class="lineno"> 7018 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;explicit arguments to the relevant proof tactics.&quot;</span></span>
<span class="lineno"> 7019 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 7020 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno"> 7021 </span><span class="spaces">  </span><span class="istickedoff">[ prim &quot;llvm_unint&quot; &quot;[String] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 7022 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_unint) Current <span class="nottickedoff">unint_help</span></span>
<span class="lineno"> 7023 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7024 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_unint&quot; &quot;[String] -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 7025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_unint)</span> Current <span class="nottickedoff">unint_help</span></span>
<span class="lineno"> 7026 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7027 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_unint&quot; &quot;[String] -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 7028 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_unint)</span> Current <span class="nottickedoff">unint_help</span></span>
<span class="lineno"> 7029 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 7030 </span><span class="spaces">  </span><span class="istickedoff">++</span>
<span class="lineno"> 7031 </span><span class="spaces">  </span><span class="istickedoff">[</span>
<span class="lineno"> 7032 </span><span class="spaces">    </span><span class="istickedoff">------------------------------------------------------------</span>
<span class="lineno"> 7033 </span><span class="spaces">    </span><span class="istickedoff">-- Other miscellaneous features</span>
<span class="lineno"> 7034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7035 </span><span class="spaces">    </span><span class="istickedoff">prim &quot;auto_match&quot; &quot;String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 7036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal do_auto_match)</span></span>
<span class="lineno"> 7037 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 7038 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Interactively decides how to align two modules of potentially&quot;</span></span>
<span class="lineno"> 7039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;heterogeneous language and prints the result.&quot;</span></span>
<span class="lineno"> 7040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 7041 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 7042 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7043 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 7044 </span><span class="spaces">    </span><span class="istickedoff">prim :: Text -&gt; Text -&gt; (Text -&gt; Options -&gt; BuiltinContext -&gt; Value) -&gt; PrimitiveLifecycle -&gt; [Text]</span>
<span class="lineno"> 7045 </span><span class="spaces">         </span><span class="istickedoff">-&gt; (SS.Name, Primitive)</span>
<span class="lineno"> 7046 </span><span class="spaces">    </span><span class="istickedoff">prim name ty fn lc doc = (name, Primitive</span>
<span class="lineno"> 7047 </span><span class="spaces">                                     </span><span class="istickedoff">{ primitiveType = ty'</span>
<span class="lineno"> 7048 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveDoc  = <span class="nottickedoff">doc</span></span>
<span class="lineno"> 7049 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveFn   = fn name</span>
<span class="lineno"> 7050 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveLife = lc</span>
<span class="lineno"> 7051 </span><span class="spaces">                                     </span><span class="istickedoff">})</span>
<span class="lineno"> 7052 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 7053 </span><span class="spaces">        </span><span class="istickedoff">-- Beware: errors in the type will only be detected when the</span>
<span class="lineno"> 7054 </span><span class="spaces">        </span><span class="istickedoff">-- type is actually looked at by something, like :env, :t,</span>
<span class="lineno"> 7055 </span><span class="spaces">        </span><span class="istickedoff">-- :search, or a direct use of the builtin.</span>
<span class="lineno"> 7056 </span><span class="spaces">        </span><span class="istickedoff">ty' = Loader.readSchemaPure fakeFileName lc primNamedTypeEnv ty</span>
<span class="lineno"> 7057 </span><span class="spaces">        </span><span class="istickedoff">fakeFileName = Text.unpack $ &quot;&lt;type of &quot; &lt;&gt; name &lt;&gt; &quot;&gt;&quot;</span>
<span class="lineno"> 7058 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7059 </span><span class="spaces">    </span><span class="istickedoff">pureVal :: forall t. IsValue t =&gt; t -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7060 </span><span class="spaces">    </span><span class="istickedoff">pureVal x name _ _ = toValue name x</span>
<span class="lineno"> 7061 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7062 </span><span class="spaces">    </span><span class="istickedoff">-- pureVal can be used for anything with an IsValue instance,</span>
<span class="lineno"> 7063 </span><span class="spaces">    </span><span class="istickedoff">-- including functions. However, functions in TopLevel need to use</span>
<span class="lineno"> 7064 </span><span class="spaces">    </span><span class="istickedoff">-- funVal* instead; the IsValue instances capture incorrectly and</span>
<span class="lineno"> 7065 </span><span class="spaces">    </span><span class="istickedoff">-- you get a function that returns a VTopLevel instead of executing</span>
<span class="lineno"> 7066 </span><span class="spaces">    </span><span class="istickedoff">-- in TopLevel. (There isn't a special-case IsValue instance for</span>
<span class="lineno"> 7067 </span><span class="spaces">    </span><span class="istickedoff">-- a -&gt; TopLevel t, because that would require overlapping instances;</span>
<span class="lineno"> 7068 </span><span class="spaces">    </span><span class="istickedoff">-- but there is an IsValue instance for TopLevel t by itself (that</span>
<span class="lineno"> 7069 </span><span class="spaces">    </span><span class="istickedoff">-- produces VTopLevel) so use of pureVal matches that and the</span>
<span class="lineno"> 7070 </span><span class="spaces">    </span><span class="istickedoff">-- generic IsValue instance for a -&gt; t.)</span>
<span class="lineno"> 7071 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno"> 7072 </span><span class="spaces">    </span><span class="istickedoff">-- XXX: rename these to e.g. monadVal1/2/3 so this is clearer?</span>
<span class="lineno"> 7073 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7074 </span><span class="spaces">    </span><span class="istickedoff">funVal1 :: forall a t. (FromValue a, IsValue t) =&gt; (a -&gt; TopLevel t)</span>
<span class="lineno"> 7075 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7076 </span><span class="spaces">    </span><span class="istickedoff">funVal1 f name _ _ =</span>
<span class="lineno"> 7077 </span><span class="spaces">      </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">Seq.empty</span> $</span>
<span class="lineno"> 7078 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg $ \a -&gt;</span>
<span class="lineno"> 7079 </span><span class="spaces">          </span><span class="istickedoff">toValue <span class="nottickedoff">name</span> &lt;$&gt; f (fromValue FromArgument a)</span>
<span class="lineno"> 7080 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7081 </span><span class="spaces">    </span><span class="istickedoff">funVal2 :: forall a b t. (FromValue a, FromValue b, IsValue t) =&gt; (a -&gt; b -&gt; TopLevel t)</span>
<span class="lineno"> 7082 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7083 </span><span class="spaces">    </span><span class="istickedoff">funVal2 f name _ _ =</span>
<span class="lineno"> 7084 </span><span class="spaces">      </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">Seq.empty</span> $</span>
<span class="lineno"> 7085 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs $ \a -&gt; return $</span>
<span class="lineno"> 7086 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg $ \b -&gt;</span>
<span class="lineno"> 7087 </span><span class="spaces">          </span><span class="istickedoff">toValue <span class="nottickedoff">name</span> &lt;$&gt; f (fromValue <span class="nottickedoff">FromArgument</span> a) (fromValue <span class="nottickedoff">FromArgument</span> b)</span>
<span class="lineno"> 7088 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7089 </span><span class="spaces">    </span><span class="istickedoff">funVal3 :: forall a b c t. (FromValue a, FromValue b, FromValue c, IsValue t) =&gt; (a -&gt; b -&gt; c -&gt; TopLevel t)</span>
<span class="lineno"> 7090 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7091 </span><span class="spaces">    </span><span class="istickedoff">funVal3 f name _ _ =</span>
<span class="lineno"> 7092 </span><span class="spaces">      </span><span class="istickedoff">VBuiltin name <span class="nottickedoff">Seq.empty</span> $</span>
<span class="lineno"> 7093 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs $ \a -&gt; return $</span>
<span class="lineno"> 7094 </span><span class="spaces">        </span><span class="istickedoff">ManyMoreArgs $ \b -&gt; return $</span>
<span class="lineno"> 7095 </span><span class="spaces">        </span><span class="istickedoff">OneMoreArg $ \c -&gt;</span>
<span class="lineno"> 7096 </span><span class="spaces">          </span><span class="istickedoff">toValue <span class="nottickedoff">name</span> &lt;$&gt; f (fromValue <span class="nottickedoff">FromArgument</span> a) (fromValue <span class="nottickedoff">FromArgument</span> b) (fromValue <span class="nottickedoff">FromArgument</span> c)</span>
<span class="lineno"> 7097 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7098 </span><span class="spaces">    </span><span class="istickedoff">scVal :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 7099 </span><span class="spaces">             </span><span class="istickedoff">(SharedContext -&gt; t) -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7100 </span><span class="spaces">    </span><span class="istickedoff">scVal f name _ bic = toValue <span class="nottickedoff">name</span> (f (biSharedContext bic))</span>
<span class="lineno"> 7101 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7102 </span><span class="spaces">    </span><span class="istickedoff">scVal' :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 7103 </span><span class="spaces">             </span><span class="istickedoff">(SharedContext -&gt; Options -&gt; t) -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">scVal' f name opts bic = toValue name (f (biSharedContext bic) opts)</span></span>
<span class="lineno"> 7105 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7106 </span><span class="spaces">    </span><span class="istickedoff">bicVal :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 7107 </span><span class="spaces">              </span><span class="istickedoff">(BuiltinContext -&gt; Options -&gt; t) -&gt; Text -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 7108 </span><span class="spaces">    </span><span class="istickedoff">bicVal f name opts bic = toValue name (f bic opts)</span></span>
<span class="lineno"> 7109 </span>
<span class="lineno"> 7110 </span>
<span class="lineno"> 7111 </span>
<span class="lineno"> 7112 </span>-- FUTURE: extract here is now functionally a nop, so if things don't
<span class="lineno"> 7113 </span>-- change going forward we should consider simplifying so primTypes
<span class="lineno"> 7114 </span>-- uses the same type as the interpreter environment this function
<span class="lineno"> 7115 </span>-- seeds, instead of its own.
<span class="lineno"> 7116 </span>primNamedTypeEnv :: Map SS.Name (PrimitiveLifecycle, SS.NamedType)
<span class="lineno"> 7117 </span><span class="decl"><span class="istickedoff">primNamedTypeEnv = fmap extract primTypes</span>
<span class="lineno"> 7118 </span><span class="spaces">   </span><span class="istickedoff">where extract pt = (primTypeLife pt, primTypeType pt)</span></span>
<span class="lineno"> 7119 </span>
<span class="lineno"> 7120 </span>-- | Initial value environment for the interpreter.
<span class="lineno"> 7121 </span>--
<span class="lineno"> 7122 </span>--   Contains the lifecycle state, the type, the value, and the
<span class="lineno"> 7123 </span>--   documentation for each builtin.
<span class="lineno"> 7124 </span>--
<span class="lineno"> 7125 </span>--   Note: all builtins have documentation; the environment type
<span class="lineno"> 7126 </span>--   includes a Maybe for the documentation so it can also be used for
<span class="lineno"> 7127 </span>--   user definitions.
<span class="lineno"> 7128 </span>--
<span class="lineno"> 7129 </span>--   FUTURE: extract here is now functionally a nop, so we should
<span class="lineno"> 7130 </span>--   consider simplifying so `primitives` uses the same type as the
<span class="lineno"> 7131 </span>--   interpreter environment this function seeds, instead of its own.
<span class="lineno"> 7132 </span>--
<span class="lineno"> 7133 </span>primValueEnv ::
<span class="lineno"> 7134 </span>   Options -&gt;
<span class="lineno"> 7135 </span>   BuiltinContext -&gt;
<span class="lineno"> 7136 </span>   Map SS.Name (SS.Pos, PrimitiveLifecycle, SS.Schema, Value, Maybe [Text])
<span class="lineno"> 7137 </span><span class="decl"><span class="istickedoff">primValueEnv opts bic = Map.mapWithKey extract primitives</span>
<span class="lineno"> 7138 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 7139 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">header = [</span></span>
<span class="lineno"> 7140 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Description&quot;,</span></span>
<span class="lineno"> 7141 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;-----------&quot;,</span></span>
<span class="lineno"> 7142 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 7143 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 7144 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">tag p = case primitiveLife p of</span></span>
<span class="lineno"> 7145 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Current -&gt; []</span></span>
<span class="lineno"> 7146 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">WarnDeprecated -&gt; [&quot;DEPRECATED AND WILL WARN&quot;, &quot;&quot;]</span></span>
<span class="lineno"> 7147 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">HideDeprecated -&gt; [&quot;DEPRECATED AND UNAVAILABLE BY DEFAULT&quot;, &quot;&quot;]</span></span>
<span class="lineno"> 7148 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Experimental -&gt; [&quot;EXPERIMENTAL&quot;, &quot;&quot;]</span></span>
<span class="lineno"> 7149 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">name n p = [</span></span>
<span class="lineno"> 7150 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;    &quot; &lt;&gt; n &lt;&gt; &quot; : &quot; &lt;&gt; PPS.pShowText (primitiveType p),</span></span>
<span class="lineno"> 7151 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 7152 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 7153 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">doc n p =</span></span>
<span class="lineno"> 7154 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">header &lt;&gt; tag p &lt;&gt; name n p &lt;&gt; primitiveDoc p</span></span>
<span class="lineno"> 7155 </span><span class="spaces">      </span><span class="istickedoff">extract n p =</span>
<span class="lineno"> 7156 </span><span class="spaces">          </span><span class="istickedoff">let pos = SS.PosInternal &quot;&lt;&lt;builtin&gt;&gt;&quot; in</span>
<span class="lineno"> 7157 </span><span class="spaces">          </span><span class="istickedoff">(pos, primitiveLife p, primitiveType p,</span>
<span class="lineno"> 7158 </span><span class="spaces">           </span><span class="istickedoff">(primitiveFn p) opts bic, <span class="nottickedoff">Just $ doc n p</span>)</span></span>
<span class="lineno"> 7159 </span>
<span class="lineno"> 7160 </span>primEnviron :: Options -&gt; BuiltinContext -&gt; CryptolEnvStack -&gt; Environ
<span class="lineno"> 7161 </span><span class="decl"><span class="istickedoff">primEnviron opts bic cryenvs =</span>
<span class="lineno"> 7162 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7163 </span><span class="spaces">    </span><span class="istickedoff">-- Do a scope push so the builtins live by themselves in their own</span>
<span class="lineno"> 7164 </span><span class="spaces">    </span><span class="istickedoff">-- scope layer. This has the result of separating them from the</span>
<span class="lineno"> 7165 </span><span class="spaces">    </span><span class="istickedoff">-- user's variables in the :env output (which is now grouped by</span>
<span class="lineno"> 7166 </span><span class="spaces">    </span><span class="istickedoff">-- scope) and, because the builtin layer is readonly, might be</span>
<span class="lineno"> 7167 </span><span class="spaces">    </span><span class="istickedoff">-- marginally more efficient as the user's globals are added.</span>
<span class="lineno"> 7168 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 7169 </span><span class="spaces">    </span><span class="istickedoff">let tyenv = ScopedMap.push $ ScopedMap.seed primNamedTypeEnv</span>
<span class="lineno"> 7170 </span><span class="spaces">        </span><span class="istickedoff">varenv = ScopedMap.push $ ScopedMap.seed $ primValueEnv opts bic</span>
<span class="lineno"> 7171 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno"> 7172 </span><span class="spaces">    </span><span class="istickedoff">Environ varenv tyenv cryenvs</span></span>
<span class="lineno"> 7173 </span>

</pre>
</body>
</html>
