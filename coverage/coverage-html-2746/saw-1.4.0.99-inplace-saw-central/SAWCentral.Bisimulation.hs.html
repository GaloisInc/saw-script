<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Bisimulation
<span class="lineno">    3 </span>Description : Implementations of SAW-Script bisimulation prover
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : bboston7
<span class="lineno">    6 </span>Stability   : experimental
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>This module provides tools to prove bisimilarity of two circuits, or of a
<span class="lineno">    9 </span>circuit and a specification. At the moment, it does this through the single
<span class="lineno">   10 </span>'proveBisimulation' function, but we will expand this module with additional
<span class="lineno">   11 </span>functionality in the future.
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>At its core, we want to prove that two circuits executing in lockstep satisfy
<span class="lineno">   14 </span>some relation over the state of each circuit and their outputs. To achieve this,
<span class="lineno">   15 </span>the 'proveBisimulation' command takes:
<span class="lineno">   16 </span>* A list of already proved bisimulation theorems
<span class="lineno">   17 </span>* A state relation @srel : lhsState -&gt; rhsState -&gt; Bit@
<span class="lineno">   18 </span>* An output relation @orel : (lhsState, output) -&gt; (rhsState, output) -&gt; Bit@
<span class="lineno">   19 </span>* A term @lhs : (lhsState, input) -&gt; (lhsState, output)@
<span class="lineno">   20 </span>* A term @rhs : (rhsState, input) -&gt; (rhsState, output)@
<span class="lineno">   21 </span>and considers @lhs@ and @rhs@ bisimilar when the following two theorems hold:
<span class="lineno">   22 </span>* OUTPUT RELATION THEOREM:
<span class="lineno">   23 </span>    forall s1 s2 in.
<span class="lineno">   24 </span>      srel s1 s2 -&gt; orel (lhs (s1, in)) (rhs (s2, in))
<span class="lineno">   25 </span>* STATE RELATION THEOREM:
<span class="lineno">   26 </span>    forall s1 s2 out1 out2.
<span class="lineno">   27 </span>      orel (s1, out1) (s2, out2) -&gt; srel s1 s2
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>The OUTPUT RELATION THEOREM ensures that if the state relation holds prior to
<span class="lineno">   30 </span>executing @lhs@ and @rhs@, then the output relation holds after executing @lhs@
<span class="lineno">   31 </span>and @rhs@.  That is, the two terms step together.
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>The STATE RELATION THEOREM ensures that if the output relation holds over some
<span class="lineno">   34 </span>state and output value, then the state relation also holds over that same state.
<span class="lineno">   35 </span>This ensures that the output relation captures the state relation.
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>To enable compositionality, 'proveBisimulation' takes a list of proven
<span class="lineno">   38 </span>bisimulation theorems as 'BisimTheorem's.  For each 'BisimTheorem', this
<span class="lineno">   39 </span>implementation searches for invocations of the functions in the 'BisimTheorem'
<span class="lineno">   40 </span>and replaces them with uninterpreted values that satisfy the 'BisimTheorem''s
<span class="lineno">   41 </span>output relation.  Put another way, if @g_lhs@ contains some function @f_lhs@ and
<span class="lineno">   42 </span>@g_rhs@ contains some function @f_rhs@ where @f_lhs@ and @f_rhs@ satisfy some
<span class="lineno">   43 </span>output relation @f_orel@, then in the proof of some OUTPUT RELATION THEOREM for
<span class="lineno">   44 </span>@g_lhs@ and @g_rhs@, the prover can replace @f_lhs@ with an uninterpreted value
<span class="lineno">   45 </span>@v_lhs@ and @f_rhs@ with an uninterpreted value @v_rhs@.  Lastly, the prover
<span class="lineno">   46 </span>assumes @v_lhs@ and @v_rhs@ satisfy @f_orel@.
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>In order to make this assumption about @v_lhs@ and @v_rhs@, the state relation
<span class="lineno">   49 </span>of the outer terms must ensure that the inner terms' state relation holds.  As
<span class="lineno">   50 </span>such, the prover generates and proves a side condition for each applied
<span class="lineno">   51 </span>'BisimTheorem'.  Let @g_lhs_s@ and @g_rhs_s@ be the states for @g_lhs@ and
<span class="lineno">   52 </span>@g_rhs@ respectively.  Additionally, let there be a function
<span class="lineno">   53 </span>@extract_inner_state x x_s y@ that takes an outer term @x@, an outer state
<span class="lineno">   54 </span>@x_s@, and an inner term @y@, and returns the inner state of @x_s@ that @x@
<span class="lineno">   55 </span>passes to @y@.  Lastly, let @g_srel@ be the state relation for the @g@ terms,
<span class="lineno">   56 </span>and @f_srel@ be the state relation for the @f@ terms.  The prover then checks:
<span class="lineno">   57 </span>  COMPOSITION SIDE CONDITION:
<span class="lineno">   58 </span>    forall g_lhs_s g_rhs_s.
<span class="lineno">   59 </span>      g_srel g_lhs_s g_rhs_s -&gt; f_srel f_lhs_s f_rhs_s
<span class="lineno">   60 </span>      where
<span class="lineno">   61 </span>        f_lhs_s = extract_inner_state g_lhs g_lhs_s f_lhs
<span class="lineno">   62 </span>        f_rhs_s = extract_inner_state g_rhs g_rhs_s f_rhs
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>The reason for all of this complexity around composition is ultimately to reduce
<span class="lineno">   65 </span>the burden on the SMT solver by uninterpreting functions so that the SMT solver
<span class="lineno">   66 </span>may handle more complex proofs.
<span class="lineno">   67 </span>-}
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   70 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   71 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>module SAWCentral.Bisimulation
<span class="lineno">   74 </span>  ( BisimTheorem, proveBisimulation )
<span class="lineno">   75 </span>  where
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>import Control.Monad (foldM, forM_, unless)
<span class="lineno">   78 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   79 </span>import qualified Control.Monad.State.Strict as State
<span class="lineno">   80 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   81 </span>import Data.Foldable (foldl')
<span class="lineno">   82 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   83 </span>import qualified Data.IntSet as IntSet
<span class="lineno">   84 </span>import Data.IntSet (IntSet)
<span class="lineno">   85 </span>import qualified Data.Map.Strict as Map
<span class="lineno">   86 </span>import Data.Map.Strict (Map)
<span class="lineno">   87 </span>import Data.Maybe (mapMaybe)
<span class="lineno">   88 </span>import qualified Data.Text as Text
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>import qualified Cryptol.TypeCheck.Type as C
<span class="lineno">   91 </span>import qualified Cryptol.Utils.PP as C
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>import SAWCore.Name
<span class="lineno">   94 </span>import SAWCore.SharedTerm
<span class="lineno">   95 </span>import SAWCore.Term.Functor
<span class="lineno">   96 </span>import SAWCore.Term.Pretty (showTerm)
<span class="lineno">   97 </span>import SAWCore.Term.Raw
<span class="lineno">   98 </span>import SAWCore.Recognizer
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  101 </span>import qualified CryptolSAWCore.Cryptol as C
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>import SAWCentral.BisimulationTheorem
<span class="lineno">  104 </span>import SAWCentral.Builtins (unfold_term)
<span class="lineno">  105 </span>import SAWCentral.Options (Verbosity(..))
<span class="lineno">  106 </span>import SAWCentral.Panic (panic)
<span class="lineno">  107 </span>import SAWCentral.Proof
<span class="lineno">  108 </span>import SAWCentral.Prover.Util (checkBooleanSchema)
<span class="lineno">  109 </span>import SAWCentral.Value
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- State used to facilitate the replacement of a 'Constant' application in a
<span class="lineno">  112 </span>-- 'Term' with a 'Variable'.  Used in 'replaceConstantTerm' and
<span class="lineno">  113 </span>-- 'replaceConstantTermF'
<span class="lineno">  114 </span>data ReplaceState = ReplaceState {
<span class="lineno">  115 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">rsMemo</span></span></span> :: Map TermIndex Term
<span class="lineno">  116 </span> -- ^ Memoization table to avoid re-visiting the same shared term
<span class="lineno">  117 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">rsVariable</span></span></span> :: Maybe Term
<span class="lineno">  118 </span> -- ^ Variable that replaces the 'Constant' application, if the constant could be
<span class="lineno">  119 </span> -- located.
<span class="lineno">  120 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">rsApp</span></span></span> :: Maybe (TermF Term)
<span class="lineno">  121 </span> -- ^ Application that was replaced, if it could be located.
<span class="lineno">  122 </span>  }
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- Components needed for a bisimulation proof.
<span class="lineno">  125 </span>data BisimComponents = BisimComponents {
<span class="lineno">  126 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">bcTheorem</span></span></span> :: BisimTheorem
<span class="lineno">  127 </span> -- ^ Bisimulation theorem capturing relations and outputs
<span class="lineno">  128 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">bcInputType</span></span></span> :: C.Type
<span class="lineno">  129 </span> -- ^ Input type of the bisimilar functions
<span class="lineno">  130 </span>  }
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- An initial 'ReplaceState'
<span class="lineno">  133 </span>emptyReplaceState :: ReplaceState
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">emptyReplaceState = ReplaceState Map.empty Nothing <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- | Translate a list of 'TypedTerm' representing theorems for input to the
<span class="lineno">  137 </span>-- given validity-checking script and attempt to prove them.
<span class="lineno">  138 </span>proveAll :: ProofScript () -&gt; [TypedTerm] -&gt; TopLevel ()
<span class="lineno">  139 </span><span class="decl"><span class="istickedoff">proveAll script ts = do</span>
<span class="lineno">  140 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff">forM_ (zip [0..] ts) $ \(n, t) -&gt; do</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="istickedoff">io $ checkBooleanSchema (ttType t)</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">prop &lt;- io $ predicateToProp sc Universal (ttTerm t)</span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="istickedoff">let goal = ProofGoal</span>
<span class="lineno">  146 </span><span class="spaces">              </span><span class="istickedoff">{ goalNum  = <span class="nottickedoff">n</span></span>
<span class="lineno">  147 </span><span class="spaces">              </span><span class="istickedoff">, goalType = <span class="nottickedoff">&quot;prove&quot;</span></span>
<span class="lineno">  148 </span><span class="spaces">              </span><span class="istickedoff">, goalName = <span class="nottickedoff">&quot;prove_bisim&quot;</span></span>
<span class="lineno">  149 </span><span class="spaces">              </span><span class="istickedoff">, goalLoc  = <span class="nottickedoff">show pos</span></span>
<span class="lineno">  150 </span><span class="spaces">              </span><span class="istickedoff">, goalDesc = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno">  151 </span><span class="spaces">              </span><span class="istickedoff">, goalSequent = propToSequent prop</span>
<span class="lineno">  152 </span><span class="spaces">              </span><span class="istickedoff">, goalTags = <span class="nottickedoff">mempty</span></span>
<span class="lineno">  153 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="istickedoff">res &lt;- runProofScript script prop goal <span class="nottickedoff">Nothing</span> <span class="nottickedoff">&quot;prove_bisim&quot;</span> <span class="nottickedoff">True</span> False</span>
<span class="lineno">  155 </span><span class="spaces">    </span><span class="istickedoff">case res of</span>
<span class="lineno">  156 </span><span class="spaces">      </span><span class="istickedoff">UnfinishedProof {} -&gt; <span class="nottickedoff">failProof res</span></span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="istickedoff">ValidProof _ thm -&gt; recordTheoremProof <span class="nottickedoff">thm</span></span>
<span class="lineno">  158 </span><span class="spaces">      </span><span class="istickedoff">InvalidProof {} -&gt;  <span class="nottickedoff">failProof res</span></span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  160 </span><span class="spaces">    </span><span class="istickedoff">failProof :: ProofResult -&gt; TopLevel ()</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">failProof res = do</span></span>
<span class="lineno">  162 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">opts &lt;- rwPPOpts &lt;$&gt; getTopLevelRW</span></span>
<span class="lineno">  163 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;prove_bisim failed.\n&quot; ++ showsProofResult opts res &quot;&quot;</span></span></span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>-- | Generate 'Term' for application of a relation
<span class="lineno">  166 </span>scRelation :: TypedTerm -&gt; Term -&gt; Term -&gt; TopLevel Term
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff">scRelation rel relLhs relRhs = do</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="istickedoff">io $ scApplyAll sc (ttTerm rel) [relLhs, relRhs]</span></span>
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>-- | Import a Cryptol type and define a fresh variable of that type.
<span class="lineno">  173 </span>importFresh :: SharedContext -&gt; Text.Text -&gt; C.Type -&gt; IO Term
<span class="lineno">  174 </span><span class="decl"><span class="istickedoff">importFresh sc name t = scFreshVariable sc name =&lt;&lt; C.importType sc <span class="nottickedoff">C.emptyEnv</span> t</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>-- | Build the COMPOSITION SIDE CONDITION for 'bc' and 'bt'.  See the
<span class="lineno">  177 </span>-- documentation at the top of this file for information on the COMPOSITION SIDE
<span class="lineno">  178 </span>-- CONDITION.
<span class="lineno">  179 </span>--
<span class="lineno">  180 </span>-- This function works by examining the specific calls to @f_lhs@ in @g_lhs@ and
<span class="lineno">  181 </span>-- @f_rhs@ in @g_rhs@ to deduce how these subfunctions access state in their
<span class="lineno">  182 </span>-- respective super functions.  It then extracts these accessors and
<span class="lineno">  183 </span>-- instantiates them with the specific @g_lhs_s@ and @g_rhs_s@ values passed
<span class="lineno">  184 </span>-- into @g_lhs@ and @g_rhs@ respectively.
<span class="lineno">  185 </span>buildCompositionSideCondition
<span class="lineno">  186 </span>  :: BisimComponents
<span class="lineno">  187 </span>  -- ^ Components of the outer bisimulation under verification
<span class="lineno">  188 </span>  -&gt; BisimTheorem
<span class="lineno">  189 </span>  -- ^ Bisimulation theorem concerning inner function
<span class="lineno">  190 </span>  -&gt; TopLevel TypedTerm
<span class="lineno">  191 </span><span class="decl"><span class="istickedoff">buildCompositionSideCondition bc innerBt = do</span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">let outerBt = bcTheorem bc</span>
<span class="lineno">  194 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  195 </span><span class="spaces">  </span><span class="istickedoff">lhsOuterState &lt;- io $ importFresh sc &quot;lhsState&quot; (bisimTheoremLhsStateType outerBt) -- g_lhs_s</span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="istickedoff">rhsOuterState &lt;- io $ importFresh sc &quot;rhsState&quot; (bisimTheoremRhsStateType outerBt) -- g_rhs_s</span>
<span class="lineno">  197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff">-- NOTE: Although not used in the final formula, we need to capture the input</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">-- to the outer functions because the extracted inner function applications</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="istickedoff">-- depend on it.  Therefore, it is necessary to match the expected form of the</span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">-- inner variable that this function instantiates.</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">input &lt;- io $ importFresh sc &quot;input&quot; (bcInputType bc) -- in</span>
<span class="lineno">  203 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff">-- Locate inner function calls on each side and replace their arguments with</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">-- 'Variable's</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="istickedoff">(lhsInnerVar, lhsInnerApp) &lt;-</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">openConstantApp (bisimTheoremLhs innerBt) (bisimTheoremLhs outerBt)</span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="istickedoff">(rhsInnerVar, rhsInnerApp) &lt;-</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">openConstantApp (bisimTheoremRhs innerBt) (bisimTheoremRhs outerBt)</span>
<span class="lineno">  210 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  211 </span><span class="spaces">  </span><span class="istickedoff">-- Extract state accessors from each inner function</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="istickedoff">lhsInnerState &lt;- stateFromApp lhsInnerApp  -- f_lhs_s</span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="istickedoff">rhsInnerState &lt;- stateFromApp rhsInnerApp  -- f_rhs_s</span>
<span class="lineno">  214 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="istickedoff">-- Outer state relation</span>
<span class="lineno">  216 </span><span class="spaces">  </span><span class="istickedoff">-- g_srel g_lhs_s g_rhs_s</span>
<span class="lineno">  217 </span><span class="spaces">  </span><span class="istickedoff">outerRel &lt;-</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">scRelation (bisimTheoremStateRelation outerBt) lhsOuterState rhsOuterState</span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  220 </span><span class="spaces">  </span><span class="istickedoff">-- Inner state relation</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="istickedoff">-- f_srel f_lhs_s f_rhs_s</span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="istickedoff">innerRel &lt;-</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">scRelation (bisimTheoremStateRelation innerBt) lhsInnerState rhsInnerState</span>
<span class="lineno">  224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="istickedoff">-- Replace extcns in inner relation with outer inputs</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">lhsTuple &lt;- io $ scTuple sc [lhsOuterState, input]  -- (f_lhs_s, in)</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="istickedoff">rhsTuple &lt;- io $ scTuple sc [rhsOuterState, input]  -- (f_rhs_s, in)</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="istickedoff">innerRel' &lt;- io $</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">scInstantiate sc (IntMap.fromList [ (vnIndex lhsInnerVar, lhsTuple)</span>
<span class="lineno">  230 </span><span class="spaces">                                      </span><span class="istickedoff">, (vnIndex rhsInnerVar, rhsTuple)])</span>
<span class="lineno">  231 </span><span class="spaces">                     </span><span class="istickedoff">innerRel</span>
<span class="lineno">  232 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">-- outer state relation implies inner state relation</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="istickedoff">-- g_srel g_lhs_s g_rhs_s -&gt; f_srel f_lhs_s f_rhs_s</span>
<span class="lineno">  235 </span><span class="spaces">  </span><span class="istickedoff">implication &lt;- io $ scImplies sc outerRel innerRel'</span>
<span class="lineno">  236 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">-- Theorem to prove. Note that the 'input' is ultimately unused (see NOTE on</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">-- 'input' at the top of this function).</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="istickedoff">-- forall g_lhs_s g_rhs_s. g_srel g_lhs_s g_rhs_s -&gt; f_srel f_lhs_s f_rhs_s</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">let args = [input, rhsOuterState, lhsOuterState]</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff">theorem &lt;- io $ scAbstractTerms sc args implication</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">io $ mkTypedTerm sc theorem</span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>-- | Extract the state from the 'App' within a bisimulation side. Fails if 'app'
<span class="lineno">  245 </span>-- is not an 'App'.
<span class="lineno">  246 </span>stateFromApp :: TermF Term -&gt; TopLevel Term
<span class="lineno">  247 </span><span class="decl"><span class="istickedoff">stateFromApp app = do</span>
<span class="lineno">  248 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">case app of</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff">App _ arg -&gt; io $ scFlatTermF sc $ PairLeft arg</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  252 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">term &lt;- io $ scTermF sc app</span></span>
<span class="lineno">  253 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;Error: &quot; ++ showTerm term ++ &quot; is not an App&quot;</span></span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>-- | Given a term containing the application of a 'Constant', locate this
<span class="lineno">  256 </span>-- application and replace its argument with a 'Variable'.  Returns the inserted
<span class="lineno">  257 </span>-- 'VarName' and the updated 'App'.  Fails if 'constant' is not a 'Constant'.
<span class="lineno">  258 </span>openConstantApp :: TypedTerm
<span class="lineno">  259 </span>                -- ^ 'Constant' to search for.
<span class="lineno">  260 </span>                -&gt; TypedTerm
<span class="lineno">  261 </span>                -- ^ 'TypeTerm' to locate 'Constant' in.  Must itself be a
<span class="lineno">  262 </span>                -- 'Constant' (will be unfolded).
<span class="lineno">  263 </span>                -&gt; TopLevel (VarName, TermF Term)
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">openConstantApp constant t = do</span>
<span class="lineno">  265 </span><span class="spaces">  </span><span class="istickedoff">-- Unfold constant</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="istickedoff">name &lt;- constantName (unwrapTermF (ttTerm t))</span>
<span class="lineno">  267 </span><span class="spaces">  </span><span class="istickedoff">tUnfolded &lt;- unfold_term [name] t</span>
<span class="lineno">  268 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  269 </span><span class="spaces">  </span><span class="istickedoff">-- Break down lambda into its component parts.</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="istickedoff">(nm, _tp, body) &lt;- lambdaOrFail tUnfolded</span>
<span class="lineno">  271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="istickedoff">-- Replace outer function's argument with a 'Variable'</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="istickedoff">-- NOTE: The bisimulation relation type ensures this is a single argument</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="istickedoff">-- lambda, so it's OK to not recurse</span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="istickedoff">extractedF &lt;- extractApp constant body</span>
<span class="lineno">  276 </span><span class="spaces">  </span><span class="istickedoff">pure (nm, extractedF)</span>
<span class="lineno">  277 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  278 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">-- Break down lambda into its component parts.  Fails if 'tt' is not a</span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="istickedoff">-- lambda.</span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">lambdaOrFail :: TypedTerm -&gt; TopLevel (VarName, Term, Term)</span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="istickedoff">lambdaOrFail tt =</span>
<span class="lineno">  283 </span><span class="spaces">      </span><span class="istickedoff">case asLambda (ttTerm tt) of</span>
<span class="lineno">  284 </span><span class="spaces">        </span><span class="istickedoff">Just lambda -&gt; return lambda</span>
<span class="lineno">  285 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  286 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;Error: Expected a lambda term, got &quot; ++ show (ppTypedTerm tt)</span></span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>-- Traverses 'term' and extracts the application of 'constant' within it.  Fails
<span class="lineno">  289 </span>-- if 'constant' cannot be found within 'term'.
<span class="lineno">  290 </span>extractApp :: TypedTerm
<span class="lineno">  291 </span>           -- ^ 'Constant' to search for.
<span class="lineno">  292 </span>           -&gt; Term
<span class="lineno">  293 </span>           -- ^ 'Term' to search in.
<span class="lineno">  294 </span>           -&gt; TopLevel (TermF Term)
<span class="lineno">  295 </span><span class="decl"><span class="istickedoff">extractApp constant term =</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="istickedoff">case snd $ go (IntSet.empty, Nothing) term of</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="istickedoff">Just app -&gt; return app</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ unlines [ &quot;Error: Failed to locate constant in term.&quot;</span></span>
<span class="lineno">  299 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Constant: &quot; ++ show (ppTypedTerm constant)</span></span>
<span class="lineno">  300 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Term: &quot; ++ showTerm term ]</span></span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">go :: (IntSet, Maybe (TermF Term))</span>
<span class="lineno">  303 </span><span class="spaces">       </span><span class="istickedoff">-&gt; Term</span>
<span class="lineno">  304 </span><span class="spaces">       </span><span class="istickedoff">-&gt; (IntSet, Maybe (TermF Term))</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">go (seen, acc) t =</span>
<span class="lineno">  306 </span><span class="spaces">      </span><span class="istickedoff">case acc of</span>
<span class="lineno">  307 </span><span class="spaces">        </span><span class="istickedoff">Just res -&gt; (<span class="nottickedoff">seen</span>, Just res)</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  309 </span><span class="spaces">          </span><span class="istickedoff">case t of</span>
<span class="lineno">  310 </span><span class="spaces">            </span><span class="istickedoff">Unshared tf -&gt; <span class="nottickedoff">termf (seen, acc) tf</span></span>
<span class="lineno">  311 </span><span class="spaces">            </span><span class="istickedoff">STApp{ stAppIndex = i, stAppTermF = tf } -&gt;</span>
<span class="lineno">  312 </span><span class="spaces">              </span><span class="istickedoff">if <span class="tickonlyfalse">IntSet.member i seen</span></span>
<span class="lineno">  313 </span><span class="spaces">              </span><span class="istickedoff">then <span class="nottickedoff">(seen, acc)</span></span>
<span class="lineno">  314 </span><span class="spaces">              </span><span class="istickedoff">else termf (IntSet.insert i seen, acc) tf</span>
<span class="lineno">  315 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">termf :: (IntSet, Maybe (TermF Term))</span>
<span class="lineno">  317 </span><span class="spaces">          </span><span class="istickedoff">-&gt; TermF Term</span>
<span class="lineno">  318 </span><span class="spaces">          </span><span class="istickedoff">-&gt; (IntSet, Maybe (TermF Term))</span>
<span class="lineno">  319 </span><span class="spaces">    </span><span class="istickedoff">termf (seen, acc) tf =</span>
<span class="lineno">  320 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno">  321 </span><span class="spaces">        </span><span class="istickedoff">App fn _ | unwrapTermF fn == unwrapTermF (ttTerm constant) -&gt;</span>
<span class="lineno">  322 </span><span class="spaces">          </span><span class="istickedoff">(<span class="nottickedoff">seen</span>, Just tf)</span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; foldl' go (seen, acc) tf</span></span>
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>-- | Apply a prior proof result to simplify a bisimulation 'Term'.  Returns an
<span class="lineno">  326 </span>-- updated 'Term', and a potential side condition that must be proven (or
<span class="lineno">  327 </span>-- 'Nothing' if simplification had no effect).
<span class="lineno">  328 </span>--
<span class="lineno">  329 </span>-- This function works by searching for the functions from 'bt' in 'term'.  If
<span class="lineno">  330 </span>-- it finds them, it replaces the calls in 'term' with 'Variable's and adds an
<span class="lineno">  331 </span>-- assumption that the output relation holds over those 'Variable's.  This has the
<span class="lineno">  332 </span>-- effect of saving the SMT solver from having to reason again about
<span class="lineno">  333 </span>-- subrelations that have already been proven.  More formally, if @g_1@ and
<span class="lineno">  334 </span>-- @g_2@ contain subfunctions @f_1@ and @f_2@ that satisfy some output relation
<span class="lineno">  335 </span>-- @orel@, then this function replaces @f_1@ and @f_2@ with the uninterpreted
<span class="lineno">  336 </span>-- values @v_1@ and @v_2@ respectively and adds the assumption @orel v_1 v_2@.
<span class="lineno">  337 </span>--
<span class="lineno">  338 </span>-- When simplification succeeds, this function also returns the side condition
<span class="lineno">  339 </span>-- that the outer state relation from @g_1@ and @g_2@ implies that the inner
<span class="lineno">  340 </span>-- state relation on @f_1@ and @f_2@ holds.  See the documentation on
<span class="lineno">  341 </span>-- 'buildSuperStateRelation' for more information on the side condition.
<span class="lineno">  342 </span>applyTheorem :: BisimTheorem
<span class="lineno">  343 </span>             -- ^ Theorem to apply
<span class="lineno">  344 </span>             -&gt; BisimComponents
<span class="lineno">  345 </span>             -- ^ Components of bisimulation under verification
<span class="lineno">  346 </span>             -&gt; Term
<span class="lineno">  347 </span>             -- ^ Term to simplify
<span class="lineno">  348 </span>             -&gt; TopLevel (Term, Maybe TypedTerm)
<span class="lineno">  349 </span><span class="decl"><span class="istickedoff">applyTheorem bt bc term0 = do</span>
<span class="lineno">  350 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  351 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="istickedoff">-- Attempt to replace calls in 'term0' to the left side of 'bt' with a</span>
<span class="lineno">  353 </span><span class="spaces">  </span><span class="istickedoff">-- 'Variable'.  In other words, replace @f_1@ with @v_1@.</span>
<span class="lineno">  354 </span><span class="spaces">  </span><span class="istickedoff">let tpLhs = C.TCon (C.TC (C.TCTuple <span class="nottickedoff">2</span>)) [ bisimTheoremLhsStateType bt</span>
<span class="lineno">  355 </span><span class="spaces">                                          </span><span class="istickedoff">, bisimTheoremOutputType bt ]</span>
<span class="lineno">  356 </span><span class="spaces">  </span><span class="istickedoff">(term1, lhsRs) &lt;-</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">State.runStateT (replaceConstantTerm (bisimTheoremLhs bt) tpLhs term0)</span>
<span class="lineno">  358 </span><span class="spaces">                    </span><span class="istickedoff">emptyReplaceState</span>
<span class="lineno">  359 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  360 </span><span class="spaces">  </span><span class="istickedoff">-- Attempt to replace calls in 'term1' to the right side of 'bt' with a</span>
<span class="lineno">  361 </span><span class="spaces">  </span><span class="istickedoff">-- 'Variable'.  In other words, replace @f_2@ with @v_2@.</span>
<span class="lineno">  362 </span><span class="spaces">  </span><span class="istickedoff">let tpRhs = C.TCon (C.TC (C.TCTuple <span class="nottickedoff">2</span>)) [ bisimTheoremRhsStateType bt</span>
<span class="lineno">  363 </span><span class="spaces">                                          </span><span class="istickedoff">, bisimTheoremOutputType bt ]</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="istickedoff">(term2, rhsRs) &lt;-</span>
<span class="lineno">  365 </span><span class="spaces">    </span><span class="istickedoff">State.runStateT (replaceConstantTerm (bisimTheoremRhs bt) tpRhs term1)</span>
<span class="lineno">  366 </span><span class="spaces">                    </span><span class="istickedoff">emptyReplaceState</span>
<span class="lineno">  367 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  368 </span><span class="spaces">  </span><span class="istickedoff">case (rsVariable lhsRs, rsVariable rhsRs) of</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">(Just lhsEc, Just rhsEc) -&gt; do</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">-- Simplification succeeded! Add assumption and generate side condition</span>
<span class="lineno">  371 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  372 </span><span class="spaces">      </span><span class="istickedoff">-- Apply inner output relation to 'Variable's</span>
<span class="lineno">  373 </span><span class="spaces">      </span><span class="istickedoff">-- orel v_1 v_2</span>
<span class="lineno">  374 </span><span class="spaces">      </span><span class="istickedoff">app &lt;- io $ scApplyAll sc</span>
<span class="lineno">  375 </span><span class="spaces">                              </span><span class="istickedoff">(ttTerm (bisimTheoremOutputRelation bt))</span>
<span class="lineno">  376 </span><span class="spaces">                              </span><span class="istickedoff">[ lhsEc , rhsEc ]</span>
<span class="lineno">  377 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  378 </span><span class="spaces">      </span><span class="istickedoff">-- Use implication to assume relation holds in the main condition</span>
<span class="lineno">  379 </span><span class="spaces">      </span><span class="istickedoff">-- orel v_1 v_2 -&gt; term2</span>
<span class="lineno">  380 </span><span class="spaces">      </span><span class="istickedoff">main &lt;- io $ scImplies sc app term2</span>
<span class="lineno">  381 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  382 </span><span class="spaces">      </span><span class="istickedoff">-- Build side condition</span>
<span class="lineno">  383 </span><span class="spaces">      </span><span class="istickedoff">side &lt;- buildCompositionSideCondition bc bt</span>
<span class="lineno">  384 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  385 </span><span class="spaces">      </span><span class="istickedoff">pure (main, Just side)</span>
<span class="lineno">  386 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  387 </span><span class="spaces">      </span><span class="istickedoff">-- Application failed to match on one or both sides.  Return the Term</span>
<span class="lineno">  388 </span><span class="spaces">      </span><span class="istickedoff">-- unchanged.</span>
<span class="lineno">  389 </span><span class="spaces">      </span><span class="istickedoff">pure (term0, Nothing)</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>-- | Apply multiple proof results to simplify a bisimulation 'Term'.  Returns an
<span class="lineno">  392 </span>-- updated 'Term' and a list of side conditions that must be proven.  See the
<span class="lineno">  393 </span>-- documentation for 'applyTheorem' for more info.
<span class="lineno">  394 </span>applyAllTheorems :: [BisimTheorem]
<span class="lineno">  395 </span>                 -- ^ Theorems to apply
<span class="lineno">  396 </span>                 -&gt; BisimComponents
<span class="lineno">  397 </span>                 -- ^ Components of bisimulation under verification
<span class="lineno">  398 </span>                 -&gt; Term
<span class="lineno">  399 </span>                 -- ^ Term to simplify
<span class="lineno">  400 </span>                 -&gt; TopLevel (Term, [TypedTerm])
<span class="lineno">  401 </span><span class="decl"><span class="istickedoff">applyAllTheorems bthms bc term = foldM go (term, []) bthms</span>
<span class="lineno">  402 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  403 </span><span class="spaces">    </span><span class="istickedoff">go :: (Term, [TypedTerm]) -&gt; BisimTheorem -&gt; TopLevel (Term, [TypedTerm])</span>
<span class="lineno">  404 </span><span class="spaces">    </span><span class="istickedoff">go (curTerm, sides) bt = do</span>
<span class="lineno">  405 </span><span class="spaces">      </span><span class="istickedoff">(nextTerm, mSideCondition) &lt;- applyTheorem bt bc curTerm</span>
<span class="lineno">  406 </span><span class="spaces">      </span><span class="istickedoff">case mSideCondition of</span>
<span class="lineno">  407 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  408 </span><span class="spaces">          </span><span class="istickedoff">-- Application failed</span>
<span class="lineno">  409 </span><span class="spaces">          </span><span class="istickedoff">pure (nextTerm, sides)</span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="istickedoff">Just sideCondition -&gt; pure (nextTerm, sideCondition : sides)</span></span>
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>-- | Build the OUTPUT RELATION THEOREM for 'bc', as well as COMPOSITION SIDE
<span class="lineno">  414 </span>-- CONDITION terms for any theorems used in the OUTPUT RELATION THEOREM.
<span class="lineno">  415 </span>-- Returns a list of TypedTerms that must be proved. See the documentation at
<span class="lineno">  416 </span>-- the top of this file for information on OUTPUT RELATION THEOREM and
<span class="lineno">  417 </span>-- COMPOSITION SIDE CONDITION.
<span class="lineno">  418 </span>buildOutputRelationTheorem :: [BisimTheorem]
<span class="lineno">  419 </span>                           -- ^ Theorems available to use in proof
<span class="lineno">  420 </span>                           -&gt; BisimComponents
<span class="lineno">  421 </span>                           -- ^ Components of bisimulation under verification
<span class="lineno">  422 </span>                           -&gt; TopLevel [TypedTerm]
<span class="lineno">  423 </span><span class="decl"><span class="istickedoff">buildOutputRelationTheorem bthms bc = do</span>
<span class="lineno">  424 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="istickedoff">let outerBt = bcTheorem bc</span>
<span class="lineno">  426 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="istickedoff">-- Outer function inputs. See comments to the right of each line to see how</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">-- they line up with the documentation at the top of this file.</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">lhsState &lt;- io $ importFresh sc &quot;lhsState&quot; (bisimTheoremLhsStateType outerBt) -- s1</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">rhsState &lt;- io $ importFresh sc &quot;rhsState&quot; (bisimTheoremRhsStateType outerBt) -- s2</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="istickedoff">input &lt;- io $ importFresh sc &quot;input&quot; (bcInputType bc)                         -- in</span>
<span class="lineno">  432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="istickedoff">-- LHS/RHS constants</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">let lhs = ttTerm (bisimTheoremLhs outerBt)</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="istickedoff">let rhs = ttTerm (bisimTheoremRhs outerBt)</span>
<span class="lineno">  436 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">-- LHS/RHS inputs</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="istickedoff">lhsTuple &lt;- io $ scTuple sc [lhsState, input]  -- (s1, in)</span>
<span class="lineno">  439 </span><span class="spaces">  </span><span class="istickedoff">rhsTuple &lt;- io $ scTuple sc [rhsState, input]  -- (s2, in)</span>
<span class="lineno">  440 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="istickedoff">-- LHS/RHS outputs</span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="istickedoff">-- lhs (s1, in)</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">lhsOutput &lt;- io $ scApply sc lhs lhsTuple</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">-- rhs (s2, in)</span>
<span class="lineno">  445 </span><span class="spaces">  </span><span class="istickedoff">rhsOutput &lt;- io $ scApply sc rhs rhsTuple</span>
<span class="lineno">  446 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  447 </span><span class="spaces">  </span><span class="istickedoff">-- Initial relation result</span>
<span class="lineno">  448 </span><span class="spaces">  </span><span class="istickedoff">-- srel s1 s2</span>
<span class="lineno">  449 </span><span class="spaces">  </span><span class="istickedoff">initRelation &lt;-</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff">scRelation (bisimTheoremStateRelation outerBt) lhsState rhsState</span>
<span class="lineno">  451 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="istickedoff">-- Relation over outputs</span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="istickedoff">-- orel (lhs (s1, in)) (rhs (s2, in))</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="istickedoff">relationRes &lt;-</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">scRelation (bisimTheoremOutputRelation outerBt) lhsOutput rhsOutput</span>
<span class="lineno">  456 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  457 </span><span class="spaces">  </span><span class="istickedoff">-- initRelation implies relationRes</span>
<span class="lineno">  458 </span><span class="spaces">  </span><span class="istickedoff">-- srel s1 s2 -&gt; orel (lhs (s1, in)) (rhs (s2, in))</span>
<span class="lineno">  459 </span><span class="spaces">  </span><span class="istickedoff">implication &lt;- io $ scImplies sc initRelation relationRes</span>
<span class="lineno">  460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  461 </span><span class="spaces">  </span><span class="istickedoff">-- Unfold LHS/RHS constants to reveal opportunities for simplification</span>
<span class="lineno">  462 </span><span class="spaces">  </span><span class="istickedoff">let vs = map nameIndex $ mapMaybe asConstant [lhs, rhs]</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">implication_unfolded &lt;-</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">io $ scUnfoldConstants sc vs implication &gt;&gt;= betaNormalize sc</span>
<span class="lineno">  465 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="istickedoff">-- Simplify Term with any theorems that apply</span>
<span class="lineno">  467 </span><span class="spaces">  </span><span class="istickedoff">(implication', sideConditions) &lt;- applyAllTheorems bthms bc implication_unfolded</span>
<span class="lineno">  468 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="istickedoff">-- Function to prove</span>
<span class="lineno">  470 </span><span class="spaces">  </span><span class="istickedoff">-- forall s1 s2 in out1 out2.</span>
<span class="lineno">  471 </span><span class="spaces">  </span><span class="istickedoff">--   srel s1 s2 -&gt; orel (lhs (s1, in)) (rhs (s2, in))</span>
<span class="lineno">  472 </span><span class="spaces">  </span><span class="istickedoff">let args = [input, rhsState, lhsState]</span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="istickedoff">theorem &lt;- io $ scAbstractTerms sc args implication'</span>
<span class="lineno">  474 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">tt &lt;- io $ mkTypedTerm sc theorem</span>
<span class="lineno">  476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">pure $ tt : sideConditions</span></span>
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>-- | Build the STATE RELATION THEOREM for 'bc'. See the documentation at the top
<span class="lineno">  480 </span>-- of this file for information on the STATE RELATION THEOREM.
<span class="lineno">  481 </span>buildStateRelationTheorem :: BisimComponents -&gt; TopLevel TypedTerm
<span class="lineno">  482 </span><span class="decl"><span class="istickedoff">buildStateRelationTheorem bc = do</span>
<span class="lineno">  483 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  484 </span><span class="spaces">  </span><span class="istickedoff">let outerBt = bcTheorem bc</span>
<span class="lineno">  485 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">-- Outer function inputs. See comments to the right of each line to see how</span>
<span class="lineno">  487 </span><span class="spaces">  </span><span class="istickedoff">-- they line up with the documentation at the top of this file.</span>
<span class="lineno">  488 </span><span class="spaces">  </span><span class="istickedoff">lhsState &lt;- io $ importFresh sc &quot;lhsState&quot; (bisimTheoremLhsStateType outerBt)         -- s1</span>
<span class="lineno">  489 </span><span class="spaces">  </span><span class="istickedoff">rhsState &lt;- io $ importFresh sc &quot;rhsState&quot; (bisimTheoremRhsStateType outerBt)         -- s2</span>
<span class="lineno">  490 </span><span class="spaces">  </span><span class="istickedoff">initLhsOutput &lt;- io $ importFresh sc &quot;initLhsOutput&quot; (bisimTheoremOutputType outerBt) -- out1</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="istickedoff">initRhsOutput &lt;- io $ importFresh sc &quot;initRhsOutput&quot; (bisimTheoremOutputType outerBt) -- out2</span>
<span class="lineno">  492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  493 </span><span class="spaces">  </span><span class="istickedoff">-- LHS/RHS initial outputs</span>
<span class="lineno">  494 </span><span class="spaces">  </span><span class="istickedoff">lhsTuple &lt;- io $ scTuple sc [lhsState, initLhsOutput]  -- (s1, out1)</span>
<span class="lineno">  495 </span><span class="spaces">  </span><span class="istickedoff">rhsTuple &lt;- io $ scTuple sc [rhsState, initRhsOutput]  -- (s2, out2)</span>
<span class="lineno">  496 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  497 </span><span class="spaces">  </span><span class="istickedoff">-- LHS of implication</span>
<span class="lineno">  498 </span><span class="spaces">  </span><span class="istickedoff">-- orel (s1, out1) (s2, out2)</span>
<span class="lineno">  499 </span><span class="spaces">  </span><span class="istickedoff">lhsRelation &lt;-</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="istickedoff">scRelation (bisimTheoremOutputRelation outerBt) lhsTuple rhsTuple</span>
<span class="lineno">  501 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  502 </span><span class="spaces">  </span><span class="istickedoff">-- RHS of implication</span>
<span class="lineno">  503 </span><span class="spaces">  </span><span class="istickedoff">-- srel s1 s2</span>
<span class="lineno">  504 </span><span class="spaces">  </span><span class="istickedoff">rhsRelation &lt;-</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">scRelation (bisimTheoremStateRelation outerBt) lhsState rhsState</span>
<span class="lineno">  506 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  507 </span><span class="spaces">  </span><span class="istickedoff">-- lhsRelation implies rhsRelation</span>
<span class="lineno">  508 </span><span class="spaces">  </span><span class="istickedoff">-- orel (s1, out1) (s2, out2) -&gt; srel s1 s2</span>
<span class="lineno">  509 </span><span class="spaces">  </span><span class="istickedoff">implication &lt;- io $ scImplies sc lhsRelation rhsRelation</span>
<span class="lineno">  510 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  511 </span><span class="spaces">  </span><span class="istickedoff">-- Function to prove</span>
<span class="lineno">  512 </span><span class="spaces">  </span><span class="istickedoff">-- forall s1 s2 in out1 out2.</span>
<span class="lineno">  513 </span><span class="spaces">  </span><span class="istickedoff">--   orel (s1, out1) (s2, out2) -&gt; srel s1 s2</span>
<span class="lineno">  514 </span><span class="spaces">  </span><span class="istickedoff">let args = [initRhsOutput, initLhsOutput, rhsState, lhsState]</span>
<span class="lineno">  515 </span><span class="spaces">  </span><span class="istickedoff">theorem &lt;- io $ scAbstractTerms sc args implication</span>
<span class="lineno">  516 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="istickedoff">io $ mkTypedTerm sc theorem</span></span>
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>-- | Use bisimulation to prove that two terms simulate each other.  Proves the
<span class="lineno">  520 </span>-- OUTPUT RELATION THEOREM and STATE RELATION THEOREM for the bisimilar terms.
<span class="lineno">  521 </span>-- Additionally enables compositionality through the 'bthms' parameter.  This
<span class="lineno">  522 </span>-- function also proves the COMPOSITION SIDE CONDITION for every successfully
<span class="lineno">  523 </span>-- applied theorem in 'bthms'.  See the documentation at the top of this file
<span class="lineno">  524 </span>-- for the definitions of bisimulation and these theorems.
<span class="lineno">  525 </span>proveBisimulation ::
<span class="lineno">  526 </span>  ProofScript () -&gt;
<span class="lineno">  527 </span>  -- ^ Proof script to use over generated bisimulation term
<span class="lineno">  528 </span>  [BisimTheorem] -&gt;
<span class="lineno">  529 </span>  -- ^ Previously proved theorems that may be applied
<span class="lineno">  530 </span>  TypedTerm -&gt;
<span class="lineno">  531 </span>  -- ^ Relation over states for terms to prove bisimilar. Must have type
<span class="lineno">  532 </span>  -- @lhsState -&gt; rhsState -&gt; Bit@  Also called the &quot;state relation&quot;.
<span class="lineno">  533 </span>  TypedTerm -&gt;
<span class="lineno">  534 </span>  -- ^ Relation over states and outputs for terms to prove bisimilar. Must have
<span class="lineno">  535 </span>  -- type @(lhsState, output) -&gt; (rhsState, output) -&gt; Bit@.  Also called the
<span class="lineno">  536 </span>  -- &quot;output relation&quot;.
<span class="lineno">  537 </span>  TypedTerm -&gt;
<span class="lineno">  538 </span>  -- ^ LHS of bisimulation. Must have type
<span class="lineno">  539 </span>  -- @(lhsState, input) -&gt; (lhsState, output)@
<span class="lineno">  540 </span>  TypedTerm -&gt;
<span class="lineno">  541 </span>  -- ^ RHS of bisimulation. Must have type
<span class="lineno">  542 </span>  -- @(rhsState, input) -&gt; (rhsState, output)@
<span class="lineno">  543 </span>  TopLevel BisimTheorem
<span class="lineno">  544 </span><span class="decl"><span class="istickedoff">proveBisimulation script bthms srel orel lhs rhs = do</span>
<span class="lineno">  545 </span><span class="spaces">  </span><span class="istickedoff">-- Typechecking</span>
<span class="lineno">  546 </span><span class="spaces">  </span><span class="istickedoff">(lhsStateType, rhsStateType, outputType) &lt;- typecheckOutputRelation</span>
<span class="lineno">  547 </span><span class="spaces">  </span><span class="istickedoff">typecheckStateRelation lhsStateType rhsStateType</span>
<span class="lineno">  548 </span><span class="spaces">  </span><span class="istickedoff">(lhsName, lhsInputType) &lt;- typecheckSide lhs lhsStateType outputType</span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="istickedoff">(rhsName, rhsInputType) &lt;- typecheckSide rhs rhsStateType outputType</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">unless (lhsInputType == rhsInputType) $</span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="istickedoff">fail $ unlines [ &quot;Error: Mismatched input types in bisimulation terms.&quot;</span>
<span class="lineno">  552 </span><span class="spaces">                   </span><span class="istickedoff">, &quot;  LHS input type: &quot; ++ C.pretty lhsInputType</span>
<span class="lineno">  553 </span><span class="spaces">                   </span><span class="istickedoff">, &quot;  RHS input type: &quot; ++ C.pretty rhsInputType ]</span>
<span class="lineno">  554 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  555 </span><span class="spaces">  </span><span class="istickedoff">let bt = BisimTheorem</span>
<span class="lineno">  556 </span><span class="spaces">           </span><span class="istickedoff">{ bisimTheoremStateRelation = srel</span>
<span class="lineno">  557 </span><span class="spaces">           </span><span class="istickedoff">, bisimTheoremOutputRelation = orel</span>
<span class="lineno">  558 </span><span class="spaces">           </span><span class="istickedoff">, bisimTheoremLhs = lhs</span>
<span class="lineno">  559 </span><span class="spaces">           </span><span class="istickedoff">, bisimTheoremRhs = rhs</span>
<span class="lineno">  560 </span><span class="spaces">           </span><span class="istickedoff">, bisimTheoremOutputType = outputType</span>
<span class="lineno">  561 </span><span class="spaces">           </span><span class="istickedoff">, bisimTheoremLhsStateType = lhsStateType</span>
<span class="lineno">  562 </span><span class="spaces">           </span><span class="istickedoff">, bisimTheoremRhsStateType = rhsStateType</span>
<span class="lineno">  563 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno">  564 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  565 </span><span class="spaces">  </span><span class="istickedoff">let bc = BisimComponents</span>
<span class="lineno">  566 </span><span class="spaces">           </span><span class="istickedoff">{ bcTheorem = bt</span>
<span class="lineno">  567 </span><span class="spaces">           </span><span class="istickedoff">, bcInputType = lhsInputType</span>
<span class="lineno">  568 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno">  569 </span><span class="spaces">  </span><span class="istickedoff">outputTheorems &lt;- buildOutputRelationTheorem bthms bc</span>
<span class="lineno">  570 </span><span class="spaces">  </span><span class="istickedoff">stateTheorem &lt;- buildStateRelationTheorem bc</span>
<span class="lineno">  571 </span><span class="spaces">  </span><span class="istickedoff">proveAll script $ stateTheorem : outputTheorems</span>
<span class="lineno">  572 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  573 </span><span class="spaces">  </span><span class="istickedoff">-- Proof succeeded!</span>
<span class="lineno">  574 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info $ concat [ &quot;Successfully proved bisimulation between &quot;</span>
<span class="lineno">  575 </span><span class="spaces">                              </span><span class="istickedoff">, Text.unpack lhsName</span>
<span class="lineno">  576 </span><span class="spaces">                              </span><span class="istickedoff">, &quot; and &quot;</span>
<span class="lineno">  577 </span><span class="spaces">                              </span><span class="istickedoff">, Text.unpack rhsName ]</span>
<span class="lineno">  578 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="istickedoff">return $ BisimTheorem srel orel lhs rhs outputType lhsStateType rhsStateType</span>
<span class="lineno">  580 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  581 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">-- Typecheck output relation. The expected type is:</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">-- @(lhsStateType, outputType) -&gt; (rhsStateType, outputType) -&gt; Bit@</span>
<span class="lineno">  584 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  585 </span><span class="spaces">    </span><span class="istickedoff">-- If the relation typechecks, 'typecheckOutputRelation' evaluates to a</span>
<span class="lineno">  586 </span><span class="spaces">    </span><span class="istickedoff">-- tuple of:</span>
<span class="lineno">  587 </span><span class="spaces">    </span><span class="istickedoff">-- @(lhsStateType, rhsStateType, outputType)@</span>
<span class="lineno">  588 </span><span class="spaces">    </span><span class="istickedoff">-- Otherwise, this invokes 'fail' with a description of the specific</span>
<span class="lineno">  589 </span><span class="spaces">    </span><span class="istickedoff">-- typechecking error.</span>
<span class="lineno">  590 </span><span class="spaces">    </span><span class="istickedoff">typecheckOutputRelation :: TopLevel (C.Type, C.Type, C.Type)</span>
<span class="lineno">  591 </span><span class="spaces">    </span><span class="istickedoff">typecheckOutputRelation =</span>
<span class="lineno">  592 </span><span class="spaces">      </span><span class="istickedoff">case ttType orel of</span>
<span class="lineno">  593 </span><span class="spaces">        </span><span class="istickedoff">TypedTermSchema</span>
<span class="lineno">  594 </span><span class="spaces">          </span><span class="istickedoff">(C.Forall</span>
<span class="lineno">  595 </span><span class="spaces">            </span><span class="istickedoff">[]</span>
<span class="lineno">  596 </span><span class="spaces">            </span><span class="istickedoff">[]</span>
<span class="lineno">  597 </span><span class="spaces">            </span><span class="istickedoff">(C.TCon</span>
<span class="lineno">  598 </span><span class="spaces">              </span><span class="istickedoff">(C.TC C.TCFun)</span>
<span class="lineno">  599 </span><span class="spaces">              </span><span class="istickedoff">[ C.TCon (C.TC (C.TCTuple 2)) [s1, o1]</span>
<span class="lineno">  600 </span><span class="spaces">              </span><span class="istickedoff">, C.TCon</span>
<span class="lineno">  601 </span><span class="spaces">                </span><span class="istickedoff">(C.TC C.TCFun)</span>
<span class="lineno">  602 </span><span class="spaces">                </span><span class="istickedoff">[ C.TCon (C.TC (C.TCTuple 2)) [s2, o2]</span>
<span class="lineno">  603 </span><span class="spaces">                </span><span class="istickedoff">, C.TCon (C.TC C.TCBit) []]])) -&gt; do</span>
<span class="lineno">  604 </span><span class="spaces">          </span><span class="istickedoff">unless (o1 == o2) $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  605 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Error: Mismatched output types in relation.&quot;</span></span>
<span class="lineno">  606 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;LHS output type: &quot; ++ C.pretty o1</span></span>
<span class="lineno">  607 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;RHS output type: &quot; ++ C.pretty o2 ]</span></span>
<span class="lineno">  608 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  609 </span><span class="spaces">          </span><span class="istickedoff">return (s1, s2, o1)</span>
<span class="lineno">  610 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; fail $ &quot;Error: Unexpected output relation type: &quot;</span>
<span class="lineno">  611 </span><span class="spaces">                 </span><span class="istickedoff">++ show (ppTypedTermType (ttType orel))</span>
<span class="lineno">  612 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff">-- Check that 'lhsStateType' and 'rhsStateType' match the extracted types</span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="istickedoff">-- from 'typecheckOutputRelation'.  Invokes 'fail' if the types do not</span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="istickedoff">-- match.</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">typecheckStateRelation :: C.Type -&gt; C.Type -&gt; TopLevel ()</span>
<span class="lineno">  617 </span><span class="spaces">    </span><span class="istickedoff">typecheckStateRelation lhsStateType rhsStateType =</span>
<span class="lineno">  618 </span><span class="spaces">      </span><span class="istickedoff">case ttType srel of</span>
<span class="lineno">  619 </span><span class="spaces">        </span><span class="istickedoff">TypedTermSchema</span>
<span class="lineno">  620 </span><span class="spaces">          </span><span class="istickedoff">(C.Forall</span>
<span class="lineno">  621 </span><span class="spaces">            </span><span class="istickedoff">[]</span>
<span class="lineno">  622 </span><span class="spaces">            </span><span class="istickedoff">[]</span>
<span class="lineno">  623 </span><span class="spaces">            </span><span class="istickedoff">(C.TCon</span>
<span class="lineno">  624 </span><span class="spaces">              </span><span class="istickedoff">(C.TC C.TCFun)</span>
<span class="lineno">  625 </span><span class="spaces">              </span><span class="istickedoff">[ s1</span>
<span class="lineno">  626 </span><span class="spaces">              </span><span class="istickedoff">, C.TCon</span>
<span class="lineno">  627 </span><span class="spaces">                </span><span class="istickedoff">(C.TC C.TCFun)</span>
<span class="lineno">  628 </span><span class="spaces">                </span><span class="istickedoff">[ s2, C.TCon (C.TC C.TCBit) []]])) -&gt; do</span>
<span class="lineno">  629 </span><span class="spaces">          </span><span class="istickedoff">unless (s1 == lhsStateType) $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  630 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Error: LHS of state relation and output relations have incompatible state types:&quot;</span></span>
<span class="lineno">  631 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;  State relation LHS state type: &quot; ++ C.pretty s1</span></span>
<span class="lineno">  632 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Output relation LHS state type: &quot; ++ C.pretty lhsStateType ]</span></span>
<span class="lineno">  633 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  634 </span><span class="spaces">          </span><span class="istickedoff">unless (s2 == rhsStateType) $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  635 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Error: RHS of state relation and output relations have incompatible state types:&quot;</span></span>
<span class="lineno">  636 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;  State relation RHS state type: &quot; ++ C.pretty s2</span></span>
<span class="lineno">  637 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Output relation RHS state type: &quot; ++ C.pretty rhsStateType ]</span></span>
<span class="lineno">  638 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; fail $ &quot;Error: Unexpected state relation type: &quot;</span>
<span class="lineno">  639 </span><span class="spaces">                 </span><span class="istickedoff">++ show (ppTypedTermType (ttType srel))</span>
<span class="lineno">  640 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  641 </span><span class="spaces">    </span><span class="istickedoff">-- Typecheck bisimulation term. The expected type for a bisimulation term</span>
<span class="lineno">  642 </span><span class="spaces">    </span><span class="istickedoff">-- is:</span>
<span class="lineno">  643 </span><span class="spaces">    </span><span class="istickedoff">-- @(stateType, inputType) -&gt; (stateType, outputType)@</span>
<span class="lineno">  644 </span><span class="spaces">    </span><span class="istickedoff">--</span>
<span class="lineno">  645 </span><span class="spaces">    </span><span class="istickedoff">-- If the term typechecks, this function returns a pair containing the name</span>
<span class="lineno">  646 </span><span class="spaces">    </span><span class="istickedoff">-- of the 'Constant' and @inputType@.  Otherwise, this function invokes</span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="istickedoff">-- 'fail' with a description of the specific typechecking error.</span>
<span class="lineno">  648 </span><span class="spaces">    </span><span class="istickedoff">typecheckSide</span>
<span class="lineno">  649 </span><span class="spaces">      </span><span class="istickedoff">:: TypedTerm -&gt; C.Type -&gt; C.Type -&gt; TopLevel (Text.Text, C.Type)</span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="istickedoff">typecheckSide side stateType outputType = do</span>
<span class="lineno">  651 </span><span class="spaces">      </span><span class="istickedoff">-- Check that 'side' is a 'Constant' (necessary for composition)</span>
<span class="lineno">  652 </span><span class="spaces">      </span><span class="istickedoff">name &lt;- constantName $ unwrapTermF $ ttTerm side</span>
<span class="lineno">  653 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  654 </span><span class="spaces">      </span><span class="istickedoff">-- Check function arguments</span>
<span class="lineno">  655 </span><span class="spaces">      </span><span class="istickedoff">case ttType side of</span>
<span class="lineno">  656 </span><span class="spaces">        </span><span class="istickedoff">TypedTermSchema</span>
<span class="lineno">  657 </span><span class="spaces">          </span><span class="istickedoff">(C.Forall</span>
<span class="lineno">  658 </span><span class="spaces">            </span><span class="istickedoff">[]</span>
<span class="lineno">  659 </span><span class="spaces">            </span><span class="istickedoff">[]</span>
<span class="lineno">  660 </span><span class="spaces">            </span><span class="istickedoff">(C.TCon</span>
<span class="lineno">  661 </span><span class="spaces">              </span><span class="istickedoff">(C.TC C.TCFun)</span>
<span class="lineno">  662 </span><span class="spaces">              </span><span class="istickedoff">[ C.TCon (C.TC (C.TCTuple 2)) [s, i]</span>
<span class="lineno">  663 </span><span class="spaces">              </span><span class="istickedoff">, C.TCon (C.TC (C.TCTuple 2)) [s', o] ])) -&gt; do</span>
<span class="lineno">  664 </span><span class="spaces">          </span><span class="istickedoff">unless (s == stateType) $ fail $ unlines</span>
<span class="lineno">  665 </span><span class="spaces">            </span><span class="istickedoff">[ &quot;Error: State type in bisimulation term input does not match state type in relation.&quot;</span>
<span class="lineno">  666 </span><span class="spaces">            </span><span class="istickedoff">, &quot;  Expected: &quot; ++ C.pretty stateType</span>
<span class="lineno">  667 </span><span class="spaces">            </span><span class="istickedoff">, &quot;  Actual: &quot; ++ C.pretty s]</span>
<span class="lineno">  668 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  669 </span><span class="spaces">          </span><span class="istickedoff">unless (s' == stateType) $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  670 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Error: State type in bisimulation term output does not match state type in relation.&quot;</span></span>
<span class="lineno">  671 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Expected: &quot; ++ C.pretty stateType</span></span>
<span class="lineno">  672 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Actual: &quot; ++ C.pretty s']</span></span>
<span class="lineno">  673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  674 </span><span class="spaces">          </span><span class="istickedoff">unless (o == outputType) $ fail $ unlines</span>
<span class="lineno">  675 </span><span class="spaces">            </span><span class="istickedoff">[ &quot;Error: Output type in bisimulation term does not match output type in relation.&quot;</span>
<span class="lineno">  676 </span><span class="spaces">            </span><span class="istickedoff">,&quot;  Expected: &quot; ++ C.pretty outputType</span>
<span class="lineno">  677 </span><span class="spaces">            </span><span class="istickedoff">, &quot;  Actual: &quot; ++ C.pretty o ]</span>
<span class="lineno">  678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  679 </span><span class="spaces">          </span><span class="istickedoff">return (name, i)</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  681 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">let stStr = C.pretty stateType in</span></span>
<span class="lineno">  682 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  683 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Error: Unexpected bisimulation term type.&quot;</span></span>
<span class="lineno">  684 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Expected: (&quot; ++ stStr ++ &quot;, inputType) -&gt; (&quot; ++ stStr ++ &quot;, outputType)&quot;</span></span>
<span class="lineno">  685 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;  Actual: &quot; ++ show (ppTypedTermType (ttType side)) ]</span></span></span>
<span class="lineno">  686 </span>
<span class="lineno">  687 </span>-- | Replace the invocation of a specific 'Constant' with a 'Variable'.  The
<span class="lineno">  688 </span>-- function returns the resulting 'Term' and updates a 'ReplaceState' to hold
<span class="lineno">  689 </span>-- the generated 'Variable' and the specific 'App' that was replaced.
<span class="lineno">  690 </span>replaceConstantTerm :: TypedTerm
<span class="lineno">  691 </span>                    -- ^ 'Constant' to replace application of
<span class="lineno">  692 </span>                    -&gt; C.Type
<span class="lineno">  693 </span>                    -- ^ 'constant's return type
<span class="lineno">  694 </span>                    -&gt; Term
<span class="lineno">  695 </span>                    -- ^ 'Term' to perform replacement in
<span class="lineno">  696 </span>                    -&gt; State.StateT ReplaceState TopLevel Term
<span class="lineno">  697 </span><span class="decl"><span class="istickedoff">replaceConstantTerm constant constantRetType term = do</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- lift getSharedContext</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="istickedoff">case term of</span>
<span class="lineno">  700 </span><span class="spaces">    </span><span class="istickedoff">Unshared termF -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  701 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">termF' &lt;- replaceConstantTermF termF</span></span>
<span class="lineno">  702 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">liftIO $ scTermF sc termF'</span></span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">STApp{ stAppIndex = i, stAppTermF = termF } -&gt; do</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="istickedoff">table &lt;- State.gets rsMemo</span>
<span class="lineno">  705 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup i table of</span>
<span class="lineno">  706 </span><span class="spaces">        </span><span class="istickedoff">Just x -&gt; return x</span>
<span class="lineno">  707 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno">  708 </span><span class="spaces">          </span><span class="istickedoff">termF' &lt;- replaceConstantTermF termF</span>
<span class="lineno">  709 </span><span class="spaces">          </span><span class="istickedoff">term' &lt;- liftIO $ scTermF sc termF'</span>
<span class="lineno">  710 </span><span class="spaces">          </span><span class="istickedoff">let table' = Map.insert i term' table</span>
<span class="lineno">  711 </span><span class="spaces">          </span><span class="istickedoff">State.modify$ \st -&gt; st { rsMemo = table' }</span>
<span class="lineno">  712 </span><span class="spaces">          </span><span class="istickedoff">return term'</span>
<span class="lineno">  713 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  714 </span><span class="spaces">    </span><span class="istickedoff">-- | Partner function to 'replaceConstantTerm' that operates over 'TermF's.</span>
<span class="lineno">  715 </span><span class="spaces">    </span><span class="istickedoff">replaceConstantTermF</span>
<span class="lineno">  716 </span><span class="spaces">      </span><span class="istickedoff">:: TermF Term -&gt; State.StateT ReplaceState TopLevel (TermF Term)</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">replaceConstantTermF termF = do</span>
<span class="lineno">  718 </span><span class="spaces">      </span><span class="istickedoff">case termF of</span>
<span class="lineno">  719 </span><span class="spaces">        </span><span class="istickedoff">App x _ | unwrapTermF x == unwrapTermF (ttTerm constant) -&gt;</span>
<span class="lineno">  720 </span><span class="spaces">          </span><span class="istickedoff">State.gets rsVariable &gt;&gt;= \case</span>
<span class="lineno">  721 </span><span class="spaces">            </span><span class="istickedoff">Just v -&gt;</span>
<span class="lineno">  722 </span><span class="spaces">              </span><span class="istickedoff">State.gets rsApp &gt;&gt;= \case</span>
<span class="lineno">  723 </span><span class="spaces">                </span><span class="istickedoff">Just a | <span class="tickonlytrue">a == termF</span> -&gt;</span>
<span class="lineno">  724 </span><span class="spaces">                  </span><span class="istickedoff">-- Encountered another call to the function under replacement</span>
<span class="lineno">  725 </span><span class="spaces">                  </span><span class="istickedoff">-- that matches the replaced function.  This can happen even</span>
<span class="lineno">  726 </span><span class="spaces">                  </span><span class="istickedoff">-- when the underlying Cryptol does not explicitly make</span>
<span class="lineno">  727 </span><span class="spaces">                  </span><span class="istickedoff">-- multiple calls because translation to SAWCore can insert</span>
<span class="lineno">  728 </span><span class="spaces">                  </span><span class="istickedoff">-- additional function calls with the same arguments.  In this</span>
<span class="lineno">  729 </span><span class="spaces">                  </span><span class="istickedoff">-- case, simply return the same 'Variable' already generated.</span>
<span class="lineno">  730 </span><span class="spaces">                  </span><span class="istickedoff">return $ unwrapTermF v</span>
<span class="lineno">  731 </span><span class="spaces">                </span><span class="istickedoff">Just _ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  732 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">-- Encountered a call to the function under replacement with</span></span>
<span class="lineno">  733 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">-- different arguments.  This isn't yet supported.</span></span>
<span class="lineno">  734 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">name &lt;- Text.unpack &lt;$&gt; lift (constantName (unwrapTermF x))</span></span>
<span class="lineno">  735 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">fail $ concat [&quot;Error: Encountered multiple calls to &quot;</span></span>
<span class="lineno">  736 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">, name</span></span>
<span class="lineno">  737 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">, &quot;. Use of composition with multiple &quot;</span></span>
<span class="lineno">  738 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">, &quot;subfunction calls is not yet supported.&quot;</span></span>
<span class="lineno">  739 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  740 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;replaceConstantTermF&quot;</span></span>
<span class="lineno">  741 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">[&quot;rsApp should always exist when rsVariable exists&quot;]</span></span>
<span class="lineno">  742 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno">  743 </span><span class="spaces">              </span><span class="istickedoff">sc &lt;- lift getSharedContext</span>
<span class="lineno">  744 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  745 </span><span class="spaces">              </span><span class="istickedoff">-- Generate a 'Variable' and return it, thereby replacing 'termF'</span>
<span class="lineno">  746 </span><span class="spaces">              </span><span class="istickedoff">-- with it.</span>
<span class="lineno">  747 </span><span class="spaces">              </span><span class="istickedoff">tp &lt;- liftIO $ C.importType sc <span class="nottickedoff">C.emptyEnv</span> constantRetType</span>
<span class="lineno">  748 </span><span class="spaces">              </span><span class="istickedoff">name &lt;- lift $ constantName $ unwrapTermF x</span>
<span class="lineno">  749 </span><span class="spaces">              </span><span class="istickedoff">v &lt;- liftIO $ scFreshVariable sc name tp</span>
<span class="lineno">  750 </span><span class="spaces">              </span><span class="istickedoff">State.modify $ \st -&gt; st { rsVariable = Just v, rsApp = Just termF }</span>
<span class="lineno">  751 </span><span class="spaces">              </span><span class="istickedoff">return $ unwrapTermF v</span>
<span class="lineno">  752 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  753 </span><span class="spaces">          </span><span class="istickedoff">-- Recurse</span>
<span class="lineno">  754 </span><span class="spaces">          </span><span class="istickedoff">mapM (replaceConstantTerm constant constantRetType) termF</span></span>
<span class="lineno">  755 </span>
<span class="lineno">  756 </span>-- Extract the name from a 'Constant'. Fails if provided another kind of 'TermF'
<span class="lineno">  757 </span>constantName :: TermF Term -&gt; TopLevel Text.Text
<span class="lineno">  758 </span><span class="decl"><span class="istickedoff">constantName (Constant e) = return $ toShortName $ nameInfo e</span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="istickedoff">constantName tf = do</span>
<span class="lineno">  760 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  761 </span><span class="spaces">  </span><span class="istickedoff">term &lt;- io $ scTermF sc tf</span>
<span class="lineno">  762 </span><span class="spaces">  </span><span class="istickedoff">fail $ &quot;Error: Expected a constant, but got: &quot; ++ showTerm term</span></span>

</pre>
</body>
</html>
