<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    2 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">    3 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    4 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    5 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    6 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    7 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    8 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">    9 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">   10 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">   11 </span>{-# LANGUAGE DeriveAnyClass #-}
<span class="lineno">   12 </span>{-# LANGUAGE DerivingStrategies #-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>{- |
<span class="lineno">   15 </span>Module      : SAWCentral.MRSolver.Monad
<span class="lineno">   16 </span>Copyright   : Galois, Inc. 2022
<span class="lineno">   17 </span>License     : BSD3
<span class="lineno">   18 </span>Maintainer  : westbrook@galois.com
<span class="lineno">   19 </span>Stability   : experimental
<span class="lineno">   20 </span>Portability : non-portable (language extensions)
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>This module defines the monad used by Mr. Solver ('MRM') as well as the core
<span class="lineno">   23 </span>monadic combinators for operating on terms.
<span class="lineno">   24 </span>-}
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>module SAWCentral.MRSolver.Monad where
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>import Data.Maybe
<span class="lineno">   29 </span>import Data.List (find, findIndex, foldl')
<span class="lineno">   30 </span>import Data.IORef
<span class="lineno">   31 </span>import qualified Data.Text as T
<span class="lineno">   32 </span>import System.IO (hPutStrLn, stderr)
<span class="lineno">   33 </span>import Control.Monad (MonadPlus(..), foldM)
<span class="lineno">   34 </span>import Control.Monad.Catch (MonadThrow, MonadCatch)
<span class="lineno">   35 </span>import Control.Monad.Except (MonadError(..), ExceptT, runExceptT)
<span class="lineno">   36 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   37 </span>import Control.Monad.Reader (MonadReader(..), ReaderT(..))
<span class="lineno">   38 </span>import Control.Monad.State (MonadState(..), StateT(..), modify)
<span class="lineno">   39 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   40 </span>import Control.Monad.Trans.Maybe
<span class="lineno">   41 </span>import GHC.Generics
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>import Data.Map (Map)
<span class="lineno">   44 </span>import qualified Data.Map as Map
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>import Data.HashMap.Lazy (HashMap)
<span class="lineno">   47 </span>import qualified Data.HashMap.Lazy as HashMap
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>import Data.Set (Set)
<span class="lineno">   50 </span>import qualified Data.Set as Set
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>import Prettyprinter
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>import qualified SAWSupport.Pretty as PPS (Doc, Opts, render)
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import SAWCore.Term.Functor
<span class="lineno">   57 </span>import SAWCore.Term.CtxTerm (MonadTerm(..))
<span class="lineno">   58 </span>import SAWCore.Term.Pretty
<span class="lineno">   59 </span>import SAWCore.SCTypeCheck
<span class="lineno">   60 </span>import SAWCore.SharedTerm
<span class="lineno">   61 </span>import SAWCore.Module (Def(..), ResolvedName(..), lookupVarIndexInMap)
<span class="lineno">   62 </span>import SAWCore.Recognizer
<span class="lineno">   63 </span>import CryptolSAWCore.Monadify
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>import SAWCentral.Panic
<span class="lineno">   66 </span>import SAWCentral.Prover.SolverStats
<span class="lineno">   67 </span>import SAWCentral.Proof (Sequent, SolveResult)
<span class="lineno">   68 </span>import SAWCentral.Value (TopLevel)
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>import SAWCentral.MRSolver.Term
<span class="lineno">   71 </span>import SAWCentral.MRSolver.Evidence
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>----------------------------------------------------------------------
<span class="lineno">   75 </span>-- * MR Solver Errors
<span class="lineno">   76 </span>----------------------------------------------------------------------
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>-- | The context in which a failure occurred
<span class="lineno">   79 </span>data FailCtx
<span class="lineno">   80 </span>  = FailCtxRefines NormComp NormComp
<span class="lineno">   81 </span>  | FailCtxCoIndHyp CoIndHyp
<span class="lineno">   82 </span>  | FailCtxMNF Term
<span class="lineno">   83 </span>  | FailCtxProveRel Term Term
<span class="lineno">   84 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>-- | That's MR. Failure to you
<span class="lineno">   87 </span>data MRFailure
<span class="lineno">   88 </span>  = TermsNotEq Term Term
<span class="lineno">   89 </span>  | TypesNotEq Type Type
<span class="lineno">   90 </span>  | TypesNotUnifiable Type Type
<span class="lineno">   91 </span>  | BindTypesNotUnifiable Type Type
<span class="lineno">   92 </span>  | ReturnTypesNotEq Type Type
<span class="lineno">   93 </span>  | FunNamesDoNotRefine FunName [Term] FunName [Term]
<span class="lineno">   94 </span>  | CompsDoNotRefine NormComp NormComp
<span class="lineno">   95 </span>  | ReturnNotError (Either Term Term) Term
<span class="lineno">   96 </span>  | FunsNotEq FunName FunName
<span class="lineno">   97 </span>  | CannotLookupFunDef FunName
<span class="lineno">   98 </span>  | RecursiveUnfold FunName
<span class="lineno">   99 </span>  | MalformedTpDescList Term
<span class="lineno">  100 </span>  | MalformedDefs Term
<span class="lineno">  101 </span>  | MalformedComp Term
<span class="lineno">  102 </span>  | NotCompFunType Term Term
<span class="lineno">  103 </span>  | AssertionNotProvable Term
<span class="lineno">  104 </span>  | AssumptionNotProvable Term
<span class="lineno">  105 </span>  | InvariantNotProvable FunName FunName Term
<span class="lineno">  106 </span>    -- | A local variable binding
<span class="lineno">  107 </span>  | MRFailureLocalVar LocalName MRFailure
<span class="lineno">  108 </span>    -- | Information about the context of the failure
<span class="lineno">  109 </span>  | MRFailureCtx FailCtx MRFailure
<span class="lineno">  110 </span>    -- | Records a disjunctive branch we took, where both cases failed
<span class="lineno">  111 </span>  | MRFailureDisj MRFailure MRFailure
<span class="lineno">  112 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- | Remove the context from a 'MRFailure', i.e. remove all applications of the
<span class="lineno">  115 </span>-- 'MRFailureLocalVar' and 'MRFailureCtx' constructors
<span class="lineno">  116 </span>mrFailureWithoutCtx :: MRFailure -&gt; MRFailure
<span class="lineno">  117 </span><span class="decl"><span class="nottickedoff">mrFailureWithoutCtx (MRFailureLocalVar x err) =</span>
<span class="lineno">  118 </span><span class="spaces">  </span><span class="nottickedoff">MRFailureLocalVar x (mrFailureWithoutCtx err)</span>
<span class="lineno">  119 </span><span class="spaces"></span><span class="nottickedoff">mrFailureWithoutCtx (MRFailureCtx _ err) = mrFailureWithoutCtx err</span>
<span class="lineno">  120 </span><span class="spaces"></span><span class="nottickedoff">mrFailureWithoutCtx (MRFailureDisj err1 err2) =</span>
<span class="lineno">  121 </span><span class="spaces">  </span><span class="nottickedoff">MRFailureDisj (mrFailureWithoutCtx err1) (mrFailureWithoutCtx err2)</span>
<span class="lineno">  122 </span><span class="spaces"></span><span class="nottickedoff">mrFailureWithoutCtx err = err</span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- | Pretty-print an object prefixed with a 'String' that describes it
<span class="lineno">  125 </span>prettyPrefix :: PrettyInCtx a =&gt; String -&gt; a -&gt; PPInCtxM PPS.Doc
<span class="lineno">  126 </span><span class="decl"><span class="nottickedoff">prettyPrefix str a =</span>
<span class="lineno">  127 </span><span class="spaces">  </span><span class="nottickedoff">(pretty str &lt;&gt;) &lt;$&gt; nest 2 &lt;$&gt; (line &lt;&gt;) &lt;$&gt; prettyInCtx a</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- | Pretty-print two objects, prefixed with a 'String' and with a separator
<span class="lineno">  130 </span>prettyPrefixSep :: (PrettyInCtx a, PrettyInCtx b) =&gt;
<span class="lineno">  131 </span>                   String -&gt; a -&gt; String -&gt; b -&gt; PPInCtxM PPS.Doc
<span class="lineno">  132 </span><span class="decl"><span class="nottickedoff">prettyPrefixSep d1 t2 d3 t4 =</span>
<span class="lineno">  133 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx t2 &gt;&gt;= \d2 -&gt; prettyInCtx t4 &gt;&gt;= \d4 -&gt;</span>
<span class="lineno">  134 </span><span class="spaces">  </span><span class="nottickedoff">return $ group (pretty d1 &lt;&gt; nest 2 (line &lt;&gt; d2) &lt;&gt; line &lt;&gt;</span>
<span class="lineno">  135 </span><span class="spaces">                  </span><span class="nottickedoff">pretty d3 &lt;&gt; nest 2 (line &lt;&gt; d4))</span></span>
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>-- | Apply 'vsep' to a list of pretty-printing computations
<span class="lineno">  138 </span>vsepM :: [PPInCtxM PPS.Doc] -&gt; PPInCtxM PPS.Doc
<span class="lineno">  139 </span><span class="decl"><span class="nottickedoff">vsepM = fmap vsep . sequence</span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>instance PrettyInCtx FailCtx where
<span class="lineno">  142 </span>  <span class="decl"><span class="nottickedoff">prettyInCtx (FailCtxRefines m1 m2) =</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="nottickedoff">group &lt;$&gt; nest 2 &lt;$&gt;</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;When proving refinement:&quot; m1 &quot;|=&quot; m2</span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (FailCtxCoIndHyp hyp) =</span>
<span class="lineno">  146 </span><span class="spaces">    </span><span class="nottickedoff">group &lt;$&gt; nest 2 &lt;$&gt;</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;When doing co-induction with hypothesis:&quot; hyp</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (FailCtxMNF t) =</span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="nottickedoff">group &lt;$&gt; nest 2 &lt;$&gt; vsepM [return &quot;When normalizing computation:&quot;,</span>
<span class="lineno">  150 </span><span class="spaces">                                </span><span class="nottickedoff">prettyInCtx t]</span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (FailCtxProveRel t1 t2) =</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="nottickedoff">group &lt;$&gt; nest 2 &lt;$&gt; vsepM [return &quot;When proving terms equal:&quot;,</span>
<span class="lineno">  153 </span><span class="spaces">                                </span><span class="nottickedoff">prettyInCtx t1, prettyInCtx t2]</span></span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>instance PrettyInCtx MRFailure where
<span class="lineno">  156 </span>  <span class="decl"><span class="nottickedoff">prettyInCtx (TermsNotEq t1 t2) =</span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Could not prove terms equal:&quot; t1 &quot;and&quot; t2</span>
<span class="lineno">  158 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (TypesNotEq tp1 tp2) =</span>
<span class="lineno">  159 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Types not equal:&quot; tp1 &quot;and&quot; tp2</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (TypesNotUnifiable tp1 tp2) =</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Types cannot be unified:&quot; tp1 &quot;and&quot; tp2</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (BindTypesNotUnifiable tp1 tp2) =</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Could not start co-induction because bind types cannot be unified:&quot; tp1 &quot;and&quot; tp2</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (ReturnTypesNotEq tp1 tp2) =</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Could not form refinement because return types are not equal:&quot; tp1 &quot;and&quot; tp2</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (FunNamesDoNotRefine f1 args1 f2 args2) =</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="nottickedoff">snd (prettyInCtxFunBindH f1 args1) &gt;&gt;= \d1 -&gt;</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="nottickedoff">snd (prettyInCtxFunBindH f2 args2) &gt;&gt;= \d2 -&gt;</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="nottickedoff">let prefix = &quot;Could not prove function refinement:&quot; in</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="nottickedoff">let postfix = [&quot;because:&quot;,</span>
<span class="lineno">  171 </span><span class="spaces">                   </span><span class="nottickedoff">&quot;- No matching assumptions could be found&quot;,</span>
<span class="lineno">  172 </span><span class="spaces">                   </span><span class="nottickedoff">&quot;- At least one side cannot be unfolded without fix&quot;] in</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="nottickedoff">return $ group (prefix &lt;&gt; nest 2 (line &lt;&gt; d1) &lt;&gt; line &lt;&gt;</span>
<span class="lineno">  174 </span><span class="spaces">                    </span><span class="nottickedoff">&quot;|=&quot; &lt;&gt; nest 2 (line &lt;&gt; d2) &lt;&gt; line &lt;&gt; vsep postfix)</span>
<span class="lineno">  175 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (CompsDoNotRefine m1 m2) =</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Could not prove refinement: &quot; m1 &quot;|=&quot; m2</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (ReturnNotError eith_terr t) =</span>
<span class="lineno">  178 </span><span class="spaces">    </span><span class="nottickedoff">let (lr_s, terr) = either (&quot;left&quot;,) (&quot;right&quot;,) eith_terr in</span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;errorS:&quot; terr (&quot; on the &quot; ++ lr_s ++ &quot; does not match retS:&quot;) t</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (FunsNotEq nm1 nm2) =</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="nottickedoff">vsepM [return &quot;Named functions not equal:&quot;,</span>
<span class="lineno">  182 </span><span class="spaces">           </span><span class="nottickedoff">prettyInCtx nm1, prettyInCtx nm2]</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (CannotLookupFunDef nm) =</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Could not find definition for function:&quot; nm</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (RecursiveUnfold nm) =</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Recursive unfolding of function inside its own body:&quot; nm</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (MalformedTpDescList t) =</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Not a list of type descriptions:&quot; t</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (MalformedDefs t) =</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Cannot handle multiFixS recursive definitions term:&quot; t</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (MalformedComp t) =</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Could not handle computation:&quot; t</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (NotCompFunType tp t) =</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Not a computation or computational function type:&quot; tp</span>
<span class="lineno">  195 </span><span class="spaces">                    </span><span class="nottickedoff">&quot;for term:&quot; t</span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (AssertionNotProvable cond) =</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Failed to prove assertion:&quot; cond</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (AssumptionNotProvable cond) =</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefix &quot;Failed to prove condition for `assuming`:&quot; cond</span>
<span class="lineno">  200 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (InvariantNotProvable f g pre) =</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="nottickedoff">prettyAppList [return &quot;Could not prove loop invariant for functions&quot;,</span>
<span class="lineno">  202 </span><span class="spaces">                   </span><span class="nottickedoff">prettyInCtx f, return &quot;and&quot;, prettyInCtx g,</span>
<span class="lineno">  203 </span><span class="spaces">                   </span><span class="nottickedoff">return &quot;:&quot;, prettyInCtx pre]</span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (MRFailureLocalVar x err) =</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="nottickedoff">local (fmap (x:)) $ prettyInCtx err</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (MRFailureCtx ctx err) =</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="nottickedoff">do pp1 &lt;- prettyInCtx ctx</span>
<span class="lineno">  208 </span><span class="spaces">       </span><span class="nottickedoff">pp2 &lt;- prettyInCtx err</span>
<span class="lineno">  209 </span><span class="spaces">       </span><span class="nottickedoff">return (pp1 &lt;&gt; line &lt;&gt; pp2)</span>
<span class="lineno">  210 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (MRFailureDisj err1 err2) =</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="nottickedoff">prettyPrefixSep &quot;Tried two comparisons:&quot; err1 &quot;Backtracking...&quot; err2</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>-- | Render a 'MRFailure' to a 'String'
<span class="lineno">  214 </span>showMRFailure :: MREnv -&gt; MRFailure -&gt; String
<span class="lineno">  215 </span><span class="decl"><span class="nottickedoff">showMRFailure env = showInCtx (mrePPOpts env) emptyMRVarCtx</span></span>
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>-- | Render a 'MRFailure' to a 'String' without its context (see
<span class="lineno">  218 </span>-- 'mrFailureWithoutCtx')
<span class="lineno">  219 </span>showMRFailureNoCtx :: MREnv -&gt; MRFailure -&gt; String
<span class="lineno">  220 </span><span class="decl"><span class="nottickedoff">showMRFailureNoCtx env = showMRFailure env . mrFailureWithoutCtx</span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>----------------------------------------------------------------------
<span class="lineno">  224 </span>-- * MR Monad
<span class="lineno">  225 </span>----------------------------------------------------------------------
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>-- | Classification info for what sort of variable an 'MRVar' is
<span class="lineno">  228 </span>data MRVarInfo
<span class="lineno">  229 </span>     -- | An existential variable, that might be instantiated and that tracks
<span class="lineno">  230 </span>     -- how many uvars were in scope when it was created. An occurrence of an
<span class="lineno">  231 </span>     -- existential variable should always be applied to these uvars; this is
<span class="lineno">  232 </span>     -- ensured by only allowing evars to be created by 'mrFreshEVar'.
<span class="lineno">  233 </span>  = EVarInfo Int (Maybe Term)
<span class="lineno">  234 </span>    -- | A recursive function bound by @multiFixS@, with its body
<span class="lineno">  235 </span>  | CallVarInfo Term
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>instance PrettyInCtx MRVarInfo where
<span class="lineno">  238 </span>  <span class="decl"><span class="nottickedoff">prettyInCtx (EVarInfo _ maybe_t) =</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="nottickedoff">prettyAppList [ return &quot;EVar&quot;, parens &lt;$&gt; prettyInCtx maybe_t]</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (CallVarInfo t) =</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="nottickedoff">prettyAppList [ return &quot;CallVar&quot;, parens &lt;$&gt; prettyInCtx t]</span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>-- | A map from 'MRVar's to their info
<span class="lineno">  244 </span>type MRVarMap = Map MRVar MRVarInfo
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>-- | Test if a 'Term' is an application of an 'ExtCns' to some arguments
<span class="lineno">  247 </span>asExtCnsApp :: Recognizer Term (ExtCns Term, [Term])
<span class="lineno">  248 </span><span class="decl"><span class="nottickedoff">asExtCnsApp (asApplyAll -&gt; (asExtCns -&gt; Just ec, args)) =</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="nottickedoff">return (ec, args)</span>
<span class="lineno">  250 </span><span class="spaces"></span><span class="nottickedoff">asExtCnsApp _ = Nothing</span></span>
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>-- | Recognize an evar applied to 0 or more arguments relative to a 'MRVarMap'
<span class="lineno">  253 </span>-- along with its uvar context length and its instantiation, if any
<span class="lineno">  254 </span>asEVarApp :: MRVarMap -&gt; Recognizer Term (MRVar, Int, [Term], Maybe Term)
<span class="lineno">  255 </span><span class="decl"><span class="nottickedoff">asEVarApp var_map (asExtCnsApp -&gt; Just (ec, args))</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="nottickedoff">| Just (EVarInfo clen maybe_inst) &lt;- Map.lookup (MRVar ec) var_map =</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="nottickedoff">Just (MRVar ec, clen, args, maybe_inst)</span>
<span class="lineno">  258 </span><span class="spaces"></span><span class="nottickedoff">asEVarApp _ _ = Nothing</span></span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>-- | A co-inductive hypothesis of the form:
<span class="lineno">  261 </span>--
<span class="lineno">  262 </span>-- &gt; forall x1, ..., xn. F y1 ... ym |= G z1 ... zl
<span class="lineno">  263 </span>--
<span class="lineno">  264 </span>-- for some universal context @x1:T1, ..., xn:Tn@ and some lists of argument
<span class="lineno">  265 </span>-- expressions @y1, ..., ym@ and @z1, ..., zl@ over the universal context.
<span class="lineno">  266 </span>data CoIndHyp = CoIndHyp {
<span class="lineno">  267 </span>  -- | The uvars that were in scope when this assmption was created
<span class="lineno">  268 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypCtx</span></span></span> :: MRVarCtx,
<span class="lineno">  269 </span>  -- | The LHS function name
<span class="lineno">  270 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypLHSFun</span></span></span> :: FunName,
<span class="lineno">  271 </span>  -- | The RHS function name
<span class="lineno">  272 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypRHSFun</span></span></span> :: FunName,
<span class="lineno">  273 </span>  -- | The LHS argument expressions @y1, ..., ym@ over the 'coIndHypCtx' uvars
<span class="lineno">  274 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypLHS</span></span></span> :: [Term],
<span class="lineno">  275 </span>  -- | The RHS argument expressions @y1, ..., ym@ over the 'coIndHypCtx' uvars
<span class="lineno">  276 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypRHS</span></span></span> :: [Term],
<span class="lineno">  277 </span>  -- | The invariant for the left-hand arguments, as a closed function from
<span class="lineno">  278 </span>  -- the left-hand arguments to @Bool@
<span class="lineno">  279 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypInvariantLHS</span></span></span> :: Maybe Term,
<span class="lineno">  280 </span>  -- | The invariant for the right-hand arguments, as a closed function from
<span class="lineno">  281 </span>  -- the left-hand arguments to @Bool@
<span class="lineno">  282 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">coIndHypInvariantRHS</span></span></span> :: Maybe Term
<span class="lineno">  283 </span>} deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- | Extract the @i@th argument on either the left- or right-hand side of a
<span class="lineno">  286 </span>-- coinductive hypothesis
<span class="lineno">  287 </span>coIndHypArg :: CoIndHyp -&gt; Either Int Int -&gt; Term
<span class="lineno">  288 </span><span class="decl"><span class="nottickedoff">coIndHypArg hyp (Left i) = (coIndHypLHS hyp) !! i</span>
<span class="lineno">  289 </span><span class="spaces"></span><span class="nottickedoff">coIndHypArg hyp (Right i) = (coIndHypRHS hyp) !! i</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>-- | Set the @i@th argument on either the left- or right-hand side of a
<span class="lineno">  292 </span>-- coinductive hypothesis to the given value
<span class="lineno">  293 </span>coIndHypSetArg :: CoIndHyp -&gt; Either Int Int -&gt; Term -&gt; CoIndHyp
<span class="lineno">  294 </span><span class="decl"><span class="nottickedoff">coIndHypSetArg hyp@(CoIndHyp {..}) (Left i) x =</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="nottickedoff">hyp { coIndHypLHS = take i coIndHypLHS ++ x : drop (i+1) coIndHypLHS }</span>
<span class="lineno">  296 </span><span class="spaces"></span><span class="nottickedoff">coIndHypSetArg hyp@(CoIndHyp {..}) (Right i) x =</span>
<span class="lineno">  297 </span><span class="spaces">  </span><span class="nottickedoff">hyp { coIndHypRHS = take i coIndHypRHS ++ x : drop (i+1) coIndHypRHS }</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>-- | Add a variable to the context of a coinductive hypothesis, returning the
<span class="lineno">  300 </span>-- updated coinductive hypothesis and a 'Term' which is the new variable
<span class="lineno">  301 </span>coIndHypWithVar :: CoIndHyp -&gt; LocalName -&gt; Type -&gt; MRM t (CoIndHyp, Term)
<span class="lineno">  302 </span><span class="decl"><span class="nottickedoff">coIndHypWithVar (CoIndHyp ctx f1 f2 args1 args2 invar1 invar2) nm tp =</span>
<span class="lineno">  303 </span><span class="spaces">  </span><span class="nottickedoff">do var &lt;- liftSC1 scLocalVar 0</span>
<span class="lineno">  304 </span><span class="spaces">     </span><span class="nottickedoff">let ctx' = mrVarCtxAppend (singletonMRVarCtx nm tp) ctx</span>
<span class="lineno">  305 </span><span class="spaces">     </span><span class="nottickedoff">(args1', args2') &lt;- liftTermLike 0 1 (args1, args2)</span>
<span class="lineno">  306 </span><span class="spaces">     </span><span class="nottickedoff">return (CoIndHyp ctx' f1 f2 args1' args2' invar1 invar2, var)</span></span>
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>-- | A map from pairs of function names to co-inductive hypotheses over those
<span class="lineno">  309 </span>-- names
<span class="lineno">  310 </span>type CoIndHyps = Map (FunName, FunName) CoIndHyp
<span class="lineno">  311 </span>
<span class="lineno">  312 </span>instance PrettyInCtx CoIndHyp where
<span class="lineno">  313 </span>  <span class="decl"><span class="nottickedoff">prettyInCtx (CoIndHyp ctx f1 f2 args1 args2 invar1 invar2) =</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="nottickedoff">prettyWithCtx ctx $ -- ignore whatever context we're in and use `ctx` instead</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="nottickedoff">prettyAppList [prettyInCtx ctx, return &quot;.&quot;,</span>
<span class="lineno">  316 </span><span class="spaces">                   </span><span class="nottickedoff">(case invar1 of</span>
<span class="lineno">  317 </span><span class="spaces">                       </span><span class="nottickedoff">Just f -&gt; prettyTermApp f args1</span>
<span class="lineno">  318 </span><span class="spaces">                       </span><span class="nottickedoff">Nothing -&gt; return &quot;True&quot;), return &quot;=&gt;&quot;,</span>
<span class="lineno">  319 </span><span class="spaces">                   </span><span class="nottickedoff">(case invar2 of</span>
<span class="lineno">  320 </span><span class="spaces">                       </span><span class="nottickedoff">Just f -&gt; prettyTermApp f args2</span>
<span class="lineno">  321 </span><span class="spaces">                       </span><span class="nottickedoff">Nothing -&gt; return &quot;True&quot;), return &quot;=&gt;&quot;,</span>
<span class="lineno">  322 </span><span class="spaces">                   </span><span class="nottickedoff">prettyTermApp (funNameTerm f1) args1,</span>
<span class="lineno">  323 </span><span class="spaces">                   </span><span class="nottickedoff">return &quot;|=&quot;,</span>
<span class="lineno">  324 </span><span class="spaces">                   </span><span class="nottickedoff">prettyTermApp (funNameTerm f2) args2]</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>-- | An assumption that something is equal to one of the constructors of a
<span class="lineno">  327 </span>-- datatype, e.g. equal to @Left@ of some 'Term' or @Right@ of some 'Term'
<span class="lineno">  328 </span>data DataTypeAssump
<span class="lineno">  329 </span>  = IsLeft Term | IsRight Term | IsNum Term | IsInf
<span class="lineno">  330 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Generic</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">TermLike</span></span>)
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>instance PrettyInCtx DataTypeAssump where
<span class="lineno">  333 </span>  <span class="decl"><span class="nottickedoff">prettyInCtx (IsLeft  x) = prettyInCtx x &gt;&gt;= prettyPrefix &quot;Left _ _&quot;</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (IsRight x) = prettyInCtx x &gt;&gt;= prettyPrefix &quot;Right _ _&quot;</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx (IsNum   x) = prettyInCtx x &gt;&gt;= prettyPrefix &quot;TCNum&quot;</span>
<span class="lineno">  336 </span><span class="spaces">  </span><span class="nottickedoff">prettyInCtx IsInf = return &quot;TCInf&quot;</span></span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>-- | A map from 'Term's to 'DataTypeAssump's over that term
<span class="lineno">  339 </span>type DataTypeAssumps = HashMap Term DataTypeAssump
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>-- | Parameters and locals for MR. Solver
<span class="lineno">  342 </span>data MRInfo t = MRInfo {
<span class="lineno">  343 </span>  -- | Global shared context for building terms, etc.
<span class="lineno">  344 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriSC</span></span></span> :: SharedContext,
<span class="lineno">  345 </span>  -- | SMT timeout for SMT calls made by Mr. Solver
<span class="lineno">  346 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriSMTTimeout</span></span></span> :: Maybe Integer,
<span class="lineno">  347 </span>  -- | The top-level Mr Solver environment
<span class="lineno">  348 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriEnv</span></span></span> :: MREnv,
<span class="lineno">  349 </span>  -- | The function to be used as the SMT backend for Mr. Solver, taking a set
<span class="lineno">  350 </span>  -- of uninterpreted variables and a proposition to prove
<span class="lineno">  351 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriAskSMT</span></span></span> :: Set VarIndex -&gt; Sequent -&gt; TopLevel (SolverStats, SolveResult),
<span class="lineno">  352 </span>  -- | The set of function refinements to assume
<span class="lineno">  353 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriRefnset</span></span></span> :: Refnset t,
<span class="lineno">  354 </span>  -- | The current context of universal variables
<span class="lineno">  355 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriUVars</span></span></span> :: MRVarCtx,
<span class="lineno">  356 </span>  -- | The current set of co-inductive hypotheses
<span class="lineno">  357 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriCoIndHyps</span></span></span> :: CoIndHyps,
<span class="lineno">  358 </span>  -- | The current assumptions, which are conjoined into a single Boolean term;
<span class="lineno">  359 </span>  -- note that these have the current UVars free
<span class="lineno">  360 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriAssumptions</span></span></span> :: Term,
<span class="lineno">  361 </span>  -- | The current set of 'DataTypeAssump's
<span class="lineno">  362 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mriDataTypeAssumps</span></span></span> :: DataTypeAssumps
<span class="lineno">  363 </span>}
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>-- | State maintained by MR. Solver
<span class="lineno">  366 </span>data MRState t = MRState {
<span class="lineno">  367 </span>  -- | Cumulative stats on all solver runs made so far
<span class="lineno">  368 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mrsSolverStats</span></span></span> :: SolverStats,
<span class="lineno">  369 </span>  -- | The evidence object, which includes information about which
<span class="lineno">  370 </span>  -- 'FunAssump's in 'mriRefnset' have been used so far
<span class="lineno">  371 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mrsEvidence</span></span></span> :: MREvidence t,
<span class="lineno">  372 </span>  -- | The existential and letrec-bound variables
<span class="lineno">  373 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">mrsVars</span></span></span> :: MRVarMap
<span class="lineno">  374 </span>}
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>-- | The exception type for MR. Solver, which is either a 'MRFailure' or a
<span class="lineno">  377 </span>-- widening request
<span class="lineno">  378 </span>data MRExn = MRExnFailure MRFailure
<span class="lineno">  379 </span>             -- | A widening request gives two recursive function names whose
<span class="lineno">  380 </span>             -- coinductive assumption needs to be widened along with a list of
<span class="lineno">  381 </span>             -- indices into the argument lists for these functions (in either
<span class="lineno">  382 </span>             -- the arguments to the 'Left' or 'Right' function) that need to be
<span class="lineno">  383 </span>             -- generalized
<span class="lineno">  384 </span>           | MRExnWiden FunName FunName [Either Int Int]
<span class="lineno">  385 </span>           deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>-- | Mr. Monad, the monad used by MR. Solver, which has 'MRInfo' as as a
<span class="lineno">  388 </span>-- shared environment, 'MRState' as state, and 'MRFailure' as an exception
<span class="lineno">  389 </span>-- type, all over an 'IO' monad
<span class="lineno">  390 </span>newtype MRM t a = MRM { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unMRM</span></span></span> :: ReaderT (MRInfo t) (StateT (MRState t)
<span class="lineno">  391 </span>                                                    (ExceptT MRExn TopLevel)) a }
<span class="lineno">  392 </span>                deriving newtype (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">MonadIO</span></span>,
<span class="lineno">  393 </span>                                  <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadReader (MRInfo t)</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadState (MRState t)</span></span></span></span></span></span>,
<span class="lineno">  394 </span>                                  <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadError MRExn</span></span></span></span>, <span class="decl"><span class="nottickedoff">MonadThrow</span></span>, <span class="decl"><span class="nottickedoff">MonadCatch</span></span>)
<span class="lineno">  395 </span>
<span class="lineno">  396 </span>instance MonadTerm (MRM t) where
<span class="lineno">  397 </span>  <span class="decl"><span class="nottickedoff">mkTermF = liftSC1 scTermF</span></span>
<span class="lineno">  398 </span>  <span class="decl"><span class="nottickedoff">liftTerm = liftSC3 incVars</span></span>
<span class="lineno">  399 </span>  <span class="decl"><span class="nottickedoff">whnfTerm = liftSC1 scWhnf</span></span>
<span class="lineno">  400 </span>  <span class="decl"><span class="nottickedoff">substTerm = liftSC3 instantiateVarList</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>-- | Get the current value of 'mriSC'
<span class="lineno">  403 </span>mrSC :: MRM t SharedContext
<span class="lineno">  404 </span><span class="decl"><span class="nottickedoff">mrSC = mriSC &lt;$&gt; ask</span></span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>-- | Get the current value of 'mriSMTTimeout'
<span class="lineno">  407 </span>mrSMTTimeout :: MRM t (Maybe Integer)
<span class="lineno">  408 </span><span class="decl"><span class="nottickedoff">mrSMTTimeout = mriSMTTimeout &lt;$&gt; ask</span></span>
<span class="lineno">  409 </span>
<span class="lineno">  410 </span>-- | Get the current value of 'mriUVars'
<span class="lineno">  411 </span>mrUVars :: MRM t MRVarCtx
<span class="lineno">  412 </span><span class="decl"><span class="nottickedoff">mrUVars = mriUVars &lt;$&gt; ask</span></span>
<span class="lineno">  413 </span>
<span class="lineno">  414 </span>-- | Get the current function assumptions
<span class="lineno">  415 </span>mrRefnset :: MRM t (Refnset t)
<span class="lineno">  416 </span><span class="decl"><span class="nottickedoff">mrRefnset = mriRefnset &lt;$&gt; ask</span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>-- | Get the current value of 'mriCoIndHyps'
<span class="lineno">  419 </span>mrCoIndHyps :: MRM t CoIndHyps
<span class="lineno">  420 </span><span class="decl"><span class="nottickedoff">mrCoIndHyps = mriCoIndHyps &lt;$&gt; ask</span></span>
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>-- | Get the current value of 'mriAssumptions'
<span class="lineno">  423 </span>mrAssumptions :: MRM t Term
<span class="lineno">  424 </span><span class="decl"><span class="nottickedoff">mrAssumptions = mriAssumptions &lt;$&gt; ask</span></span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>-- | Get the current value of 'mriDataTypeAssumps'
<span class="lineno">  427 </span>mrDataTypeAssumps :: MRM t DataTypeAssumps
<span class="lineno">  428 </span><span class="decl"><span class="nottickedoff">mrDataTypeAssumps = mriDataTypeAssumps &lt;$&gt; ask</span></span>
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>-- | Call the SMT backend given by 'mriAskSMT' on a set of uninterpreted
<span class="lineno">  431 </span>-- variables and a proposition to prove
<span class="lineno">  432 </span>mrAskSMT :: Set VarIndex -&gt; Sequent -&gt; MRM t (SolverStats, SolveResult)
<span class="lineno">  433 </span><span class="decl"><span class="nottickedoff">mrAskSMT unints goal = do</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="nottickedoff">askSMT &lt;- mriAskSMT &lt;$&gt; ask</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="nottickedoff">MRM $ lift $ lift $ lift $ askSMT unints goal</span></span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>-- | Get the current debug level
<span class="lineno">  438 </span>mrDebugLevel :: MRM t Int
<span class="lineno">  439 </span><span class="decl"><span class="nottickedoff">mrDebugLevel = mreDebugLevel &lt;$&gt; mriEnv &lt;$&gt; ask</span></span>
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>-- | Get the current pretty-printing options
<span class="lineno">  442 </span>mrPPOpts :: MRM t PPS.Opts
<span class="lineno">  443 </span><span class="decl"><span class="nottickedoff">mrPPOpts = mrePPOpts &lt;$&gt; mriEnv &lt;$&gt; ask</span></span>
<span class="lineno">  444 </span>
<span class="lineno">  445 </span>-- | Get the current value of 'mriEnv'
<span class="lineno">  446 </span>mrEnv :: MRM t MREnv
<span class="lineno">  447 </span><span class="decl"><span class="nottickedoff">mrEnv = mriEnv &lt;$&gt; ask</span></span>
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>-- | Get the current value of 'mrsSolverStats'
<span class="lineno">  450 </span>mrSolverStats :: MRM t SolverStats
<span class="lineno">  451 </span><span class="decl"><span class="nottickedoff">mrSolverStats = mrsSolverStats &lt;$&gt; get</span></span>
<span class="lineno">  452 </span>
<span class="lineno">  453 </span>-- | Get the current value of 'mrsEvidence'
<span class="lineno">  454 </span>mrEvidence :: MRM t (MREvidence t)
<span class="lineno">  455 </span><span class="decl"><span class="nottickedoff">mrEvidence = mrsEvidence &lt;$&gt; get</span></span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>-- | Get the current value of 'mrsVars'
<span class="lineno">  458 </span>mrVars :: MRM t MRVarMap
<span class="lineno">  459 </span><span class="decl"><span class="nottickedoff">mrVars = mrsVars &lt;$&gt; get</span></span>
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>-- | Run a 'PPInCtxM' computation in the current context and with the current
<span class="lineno">  462 </span>-- 'PPOpts'
<span class="lineno">  463 </span>mrPPInCtxM :: PPInCtxM a -&gt; MRM t a
<span class="lineno">  464 </span><span class="decl"><span class="nottickedoff">mrPPInCtxM m = mrPPOpts &gt;&gt;= \opts -&gt; mrUVars &gt;&gt;= \ctx -&gt;</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="nottickedoff">return $ runPPInCtxM m opts ctx</span></span>
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>-- | Pretty-print an object in the current context and with the current 'PPOpts'
<span class="lineno">  468 </span>mrPPInCtx :: PrettyInCtx a =&gt; a -&gt; MRM t PPS.Doc
<span class="lineno">  469 </span><span class="decl"><span class="nottickedoff">mrPPInCtx a = mrPPOpts &gt;&gt;= \opts -&gt; mrUVars &gt;&gt;= \ctx -&gt;</span>
<span class="lineno">  470 </span><span class="spaces">  </span><span class="nottickedoff">return $ ppInCtx opts ctx a</span></span>
<span class="lineno">  471 </span>
<span class="lineno">  472 </span>-- | Pretty-print an object in the current context and render to a 'String' with
<span class="lineno">  473 </span>-- the current 'PPOpts'
<span class="lineno">  474 </span>mrShowInCtx :: PrettyInCtx a =&gt; a -&gt; MRM t String
<span class="lineno">  475 </span><span class="decl"><span class="nottickedoff">mrShowInCtx a = mrPPOpts &gt;&gt;= \opts -&gt; mrUVars &gt;&gt;= \ctx -&gt;</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="nottickedoff">return $ showInCtx opts ctx a</span></span>
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>-- | Run an 'MRM' computation and return a result or an error, including the
<span class="lineno">  480 </span>-- final state of 'mrsSolverStats' and 'mrsEvidence'
<span class="lineno">  481 </span>runMRM ::
<span class="lineno">  482 </span>  SharedContext -&gt;
<span class="lineno">  483 </span>  MREnv {- ^ The Mr Solver environment -} -&gt;
<span class="lineno">  484 </span>  Maybe Integer {- ^ Timeout in milliseconds for each SMT call -} -&gt;
<span class="lineno">  485 </span>  (Set VarIndex -&gt; Sequent -&gt; TopLevel (SolverStats, SolveResult))
<span class="lineno">  486 </span>    {- ^ The callback to use for making SMT queries -} -&gt;
<span class="lineno">  487 </span>  Refnset t {- ^ Any additional refinements to be assumed by Mr Solver -} -&gt;
<span class="lineno">  488 </span>  MRM t a {- ^ The monadic computation to run -} -&gt;
<span class="lineno">  489 </span>  TopLevel (Either MRFailure (a, (SolverStats, MREvidence t)))
<span class="lineno">  490 </span><span class="decl"><span class="nottickedoff">runMRM sc env timeout askSMT rs m =</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="nottickedoff">do true_tm &lt;- liftIO $ scBool sc True</span>
<span class="lineno">  492 </span><span class="spaces">     </span><span class="nottickedoff">let init_info = MRInfo { mriSC = sc, mriSMTTimeout = timeout,</span>
<span class="lineno">  493 </span><span class="spaces">                              </span><span class="nottickedoff">mriEnv = env, mriAskSMT = askSMT,</span>
<span class="lineno">  494 </span><span class="spaces">                              </span><span class="nottickedoff">mriRefnset = rs,</span>
<span class="lineno">  495 </span><span class="spaces">                              </span><span class="nottickedoff">mriUVars = emptyMRVarCtx,</span>
<span class="lineno">  496 </span><span class="spaces">                              </span><span class="nottickedoff">mriCoIndHyps = Map.empty,</span>
<span class="lineno">  497 </span><span class="spaces">                              </span><span class="nottickedoff">mriAssumptions = true_tm,</span>
<span class="lineno">  498 </span><span class="spaces">                              </span><span class="nottickedoff">mriDataTypeAssumps = HashMap.empty }</span>
<span class="lineno">  499 </span><span class="spaces">     </span><span class="nottickedoff">let init_st = MRState { mrsSolverStats = mempty, mrsEvidence = mempty,</span>
<span class="lineno">  500 </span><span class="spaces">                             </span><span class="nottickedoff">mrsVars = Map.empty }</span>
<span class="lineno">  501 </span><span class="spaces">     </span><span class="nottickedoff">res &lt;- runExceptT $ flip runStateT init_st $</span>
<span class="lineno">  502 </span><span class="spaces">       </span><span class="nottickedoff">flip runReaderT init_info $ unMRM m</span>
<span class="lineno">  503 </span><span class="spaces">     </span><span class="nottickedoff">case res of</span>
<span class="lineno">  504 </span><span class="spaces">       </span><span class="nottickedoff">Right (a, st) -&gt; return $ Right (a, (mrsSolverStats st, mrsEvidence st))</span>
<span class="lineno">  505 </span><span class="spaces">       </span><span class="nottickedoff">Left (MRExnFailure failure) -&gt; return $ Left failure</span>
<span class="lineno">  506 </span><span class="spaces">       </span><span class="nottickedoff">Left exn -&gt; fail (&quot;runMRM: unexpected internal exception: &quot; ++ show exn)</span></span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>-- | Run an 'MRM' computation and return a result or an error, discarding the
<span class="lineno">  509 </span>-- final state
<span class="lineno">  510 </span>evalMRM ::
<span class="lineno">  511 </span>  SharedContext -&gt;
<span class="lineno">  512 </span>  MREnv {- ^ The Mr Solver environment -} -&gt;
<span class="lineno">  513 </span>  Maybe Integer {- ^ Timeout in milliseconds for each SMT call -} -&gt;
<span class="lineno">  514 </span>  (Set VarIndex -&gt; Sequent -&gt; TopLevel (SolverStats, SolveResult))
<span class="lineno">  515 </span>    {- ^ The callback to use for making SMT queries -} -&gt;
<span class="lineno">  516 </span>  Refnset t {- ^ Any additional refinements to be assumed by Mr Solver -} -&gt;
<span class="lineno">  517 </span>  MRM t a {- ^ The monadic computation to eval -} -&gt;
<span class="lineno">  518 </span>  TopLevel (Either MRFailure a)
<span class="lineno">  519 </span><span class="decl"><span class="nottickedoff">evalMRM sc env timeout askSMT rs =</span>
<span class="lineno">  520 </span><span class="spaces">  </span><span class="nottickedoff">fmap (fmap fst) . runMRM sc env timeout askSMT rs</span></span>
<span class="lineno">  521 </span>
<span class="lineno">  522 </span>-- | Run an 'MRM' computation and return a final state or an error, discarding
<span class="lineno">  523 </span>-- the result
<span class="lineno">  524 </span>execMRM ::
<span class="lineno">  525 </span>  SharedContext -&gt;
<span class="lineno">  526 </span>  MREnv {- ^ The Mr Solver environment -} -&gt;
<span class="lineno">  527 </span>  Maybe Integer {- ^ Timeout in milliseconds for each SMT call -} -&gt;
<span class="lineno">  528 </span>  (Set VarIndex -&gt; Sequent -&gt; TopLevel (SolverStats, SolveResult))
<span class="lineno">  529 </span>    {- ^ The callback to use for making SMT queries -} -&gt;
<span class="lineno">  530 </span>  Refnset t {- ^ Any additional refinements to be assumed by Mr Solver -} -&gt;
<span class="lineno">  531 </span>  MRM t a {- ^ The monadic computation to exec -} -&gt;
<span class="lineno">  532 </span>  TopLevel (Either MRFailure (SolverStats, MREvidence t))
<span class="lineno">  533 </span><span class="decl"><span class="nottickedoff">execMRM sc env timeout askSMT rs =</span>
<span class="lineno">  534 </span><span class="spaces">  </span><span class="nottickedoff">fmap (fmap snd) . runMRM sc env timeout askSMT rs</span></span>
<span class="lineno">  535 </span>
<span class="lineno">  536 </span>-- | Throw an 'MRFailure'
<span class="lineno">  537 </span>throwMRFailure :: MRFailure -&gt; MRM t a
<span class="lineno">  538 </span><span class="decl"><span class="nottickedoff">throwMRFailure = throwError . MRExnFailure</span></span>
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>-- | Apply a function to any failure thrown by an 'MRM' computation
<span class="lineno">  541 </span>mapMRFailure :: (MRFailure -&gt; MRFailure) -&gt; MRM t a -&gt; MRM t a
<span class="lineno">  542 </span><span class="decl"><span class="nottickedoff">mapMRFailure f m = catchError m $ \case</span>
<span class="lineno">  543 </span><span class="spaces">  </span><span class="nottickedoff">MRExnFailure failure -&gt; throwError $ MRExnFailure $ f failure</span>
<span class="lineno">  544 </span><span class="spaces">  </span><span class="nottickedoff">e -&gt; throwError e</span></span>
<span class="lineno">  545 </span>
<span class="lineno">  546 </span>-- | Catch any 'MRFailure' raised by a computation
<span class="lineno">  547 </span>catchFailure :: MRM t a -&gt; (MRFailure -&gt; MRM t a) -&gt; MRM t a
<span class="lineno">  548 </span><span class="decl"><span class="nottickedoff">catchFailure m f =</span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="nottickedoff">m `catchError` \case</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="nottickedoff">MRExnFailure failure -&gt; f failure</span>
<span class="lineno">  551 </span><span class="spaces">  </span><span class="nottickedoff">e -&gt; throwError e</span></span>
<span class="lineno">  552 </span>
<span class="lineno">  553 </span>-- | Try two different 'MRM' computations, combining their failures if needed.
<span class="lineno">  554 </span>-- Note that the 'MRState' will reset if the first computation fails.
<span class="lineno">  555 </span>mrOr :: MRM t a -&gt; MRM t a -&gt; MRM t a
<span class="lineno">  556 </span><span class="decl"><span class="nottickedoff">mrOr m1 m2 =</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="nottickedoff">catchFailure m1 $ \err1 -&gt;</span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="nottickedoff">catchFailure m2 $ \err2 -&gt;</span>
<span class="lineno">  559 </span><span class="spaces">  </span><span class="nottickedoff">throwMRFailure $ MRFailureDisj err1 err2</span></span>
<span class="lineno">  560 </span>
<span class="lineno">  561 </span>-- | Run an 'MRM' computation in an extended failure context
<span class="lineno">  562 </span>withFailureCtx :: FailCtx -&gt; MRM t a -&gt; MRM t a
<span class="lineno">  563 </span><span class="decl"><span class="nottickedoff">withFailureCtx ctx = mapMRFailure (MRFailureCtx ctx)</span></span>
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>{-
<span class="lineno">  566 </span>-- | Catch any errors thrown by a computation and coerce them to a 'Left'
<span class="lineno">  567 </span>catchErrorEither :: MonadError e m =&gt; m a -&gt; m (Either e a)
<span class="lineno">  568 </span>catchErrorEither m = catchError (Right &lt;$&gt; m) (return . Left)
<span class="lineno">  569 </span>-}
<span class="lineno">  570 </span>
<span class="lineno">  571 </span>-- FIXME: replace these individual lifting functions with a more general
<span class="lineno">  572 </span>-- typeclass like LiftTCM
<span class="lineno">  573 </span>
<span class="lineno">  574 </span>-- | Lift a nullary SharedTerm computation into 'MRM'
<span class="lineno">  575 </span>liftSC0 :: (SharedContext -&gt; IO a) -&gt; MRM t a
<span class="lineno">  576 </span><span class="decl"><span class="nottickedoff">liftSC0 f = mrSC &gt;&gt;= \sc -&gt; liftIO (f sc)</span></span>
<span class="lineno">  577 </span>
<span class="lineno">  578 </span>-- | Lift a unary SharedTerm computation into 'MRM'
<span class="lineno">  579 </span>liftSC1 :: (SharedContext -&gt; a -&gt; IO b) -&gt; a -&gt; MRM t b
<span class="lineno">  580 </span><span class="decl"><span class="nottickedoff">liftSC1 f a = mrSC &gt;&gt;= \sc -&gt; liftIO (f sc a)</span></span>
<span class="lineno">  581 </span>
<span class="lineno">  582 </span>-- | Lift a binary SharedTerm computation into 'MRM'
<span class="lineno">  583 </span>liftSC2 :: (SharedContext -&gt; a -&gt; b -&gt; IO c) -&gt; a -&gt; b -&gt; MRM t c
<span class="lineno">  584 </span><span class="decl"><span class="nottickedoff">liftSC2 f a b = mrSC &gt;&gt;= \sc -&gt; liftIO (f sc a b)</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>-- | Lift a ternary SharedTerm computation into 'MRM'
<span class="lineno">  587 </span>liftSC3 :: (SharedContext -&gt; a -&gt; b -&gt; c -&gt; IO d) -&gt; a -&gt; b -&gt; c -&gt; MRM t d
<span class="lineno">  588 </span><span class="decl"><span class="nottickedoff">liftSC3 f a b c = mrSC &gt;&gt;= \sc -&gt; liftIO (f sc a b c)</span></span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>-- | Lift a quaternary SharedTerm computation into 'MRM'
<span class="lineno">  591 </span>liftSC4 :: (SharedContext -&gt; a -&gt; b -&gt; c -&gt; d -&gt; IO e) -&gt; a -&gt; b -&gt; c -&gt; d -&gt;
<span class="lineno">  592 </span>           MRM t e
<span class="lineno">  593 </span><span class="decl"><span class="nottickedoff">liftSC4 f a b c d = mrSC &gt;&gt;= \sc -&gt; liftIO (f sc a b c d)</span></span>
<span class="lineno">  594 </span>
<span class="lineno">  595 </span>-- | Lift a quinary SharedTerm computation into 'MRM'
<span class="lineno">  596 </span>liftSC5 :: (SharedContext -&gt; a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; IO f) -&gt;
<span class="lineno">  597 </span>           a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; MRM t f
<span class="lineno">  598 </span><span class="decl"><span class="nottickedoff">liftSC5 f a b c d e = mrSC &gt;&gt;= \sc -&gt; liftIO (f sc a b c d e)</span></span>
<span class="lineno">  599 </span>
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>----------------------------------------------------------------------
<span class="lineno">  602 </span>-- * Functions for Building Terms
<span class="lineno">  603 </span>----------------------------------------------------------------------
<span class="lineno">  604 </span>
<span class="lineno">  605 </span>-- | Create a term representing an application of @Prelude.error@
<span class="lineno">  606 </span>mrErrorTerm :: Term -&gt; T.Text -&gt; MRM t Term
<span class="lineno">  607 </span><span class="decl"><span class="nottickedoff">mrErrorTerm a str =</span>
<span class="lineno">  608 </span><span class="spaces">  </span><span class="nottickedoff">do err_str &lt;- liftSC1 scString str</span>
<span class="lineno">  609 </span><span class="spaces">     </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;Prelude.error&quot; [a, err_str]</span></span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>-- | Create a term representing an application of @Prelude.genBVVecFromVec@,
<span class="lineno">  612 </span>-- where the default value argument is @Prelude.error@ of the given 'T.Text'
<span class="lineno">  613 </span>mrGenBVVecFromVec :: Term -&gt; Term -&gt; Term -&gt; T.Text -&gt; Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  614 </span><span class="decl"><span class="nottickedoff">mrGenBVVecFromVec m a v def_err_str n len =</span>
<span class="lineno">  615 </span><span class="spaces">  </span><span class="nottickedoff">do err_tm &lt;- mrErrorTerm a def_err_str</span>
<span class="lineno">  616 </span><span class="spaces">     </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;Prelude.genBVVecFromVec&quot; [m, a, v, err_tm, n, len]</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>-- | Create a term representing an application of @Prelude.genFromBVVec@,
<span class="lineno">  619 </span>-- where the default value argument is @Prelude.error@ of the given 'T.Text'
<span class="lineno">  620 </span>mrGenFromBVVec :: Term -&gt; Term -&gt; Term -&gt; Term -&gt; T.Text -&gt; Term -&gt; MRM t Term
<span class="lineno">  621 </span><span class="decl"><span class="nottickedoff">mrGenFromBVVec n len a v def_err_str m =</span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="nottickedoff">do err_tm &lt;- mrErrorTerm a def_err_str</span>
<span class="lineno">  623 </span><span class="spaces">     </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;Prelude.genFromBVVec&quot; [n, len, a, v, err_tm, m]</span></span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>-- | Match a lambda of the form @(\i _ -&gt; f i)@ as @f@
<span class="lineno">  626 </span>asIndexWithProofFnTerm :: Recognizer Term (SharedContext -&gt; IO Term)
<span class="lineno">  627 </span><span class="decl"><span class="nottickedoff">asIndexWithProofFnTerm (asLambdaList -&gt; ([(ix_nm, ix_tp), _], e))</span>
<span class="lineno">  628 </span><span class="spaces">  </span><span class="nottickedoff">| not $ inBitSet 0 $ looseVars e</span>
<span class="lineno">  629 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ \sc -&gt;</span>
<span class="lineno">  630 </span><span class="spaces">    </span><span class="nottickedoff">do ix_var &lt;- scLocalVar sc 0</span>
<span class="lineno">  631 </span><span class="spaces">       </span><span class="nottickedoff">-- Substitute an error term for the proof variable and ix_var for ix in</span>
<span class="lineno">  632 </span><span class="spaces">       </span><span class="nottickedoff">-- the body e of the lambda</span>
<span class="lineno">  633 </span><span class="spaces">       </span><span class="nottickedoff">let s = [error &quot;asGen(BV)VecTerm: unexpected var occurrence&quot;, ix_var]</span>
<span class="lineno">  634 </span><span class="spaces">       </span><span class="nottickedoff">e' &lt;- instantiateVarList sc 0 s e</span>
<span class="lineno">  635 </span><span class="spaces">       </span><span class="nottickedoff">scLambda sc ix_nm ix_tp e'</span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="nottickedoff">asIndexWithProofFnTerm _ = Nothing</span></span>
<span class="lineno">  637 </span>
<span class="lineno">  638 </span>-- | Match a term of the form @gen n a f@ or @genWithProof n a (\i _ -&gt; f i)@
<span class="lineno">  639 </span>asGenVecTerm :: Recognizer Term (Term, Term, SharedContext -&gt; IO Term)
<span class="lineno">  640 </span><span class="decl"><span class="nottickedoff">asGenVecTerm (asApplyAll -&gt; (isGlobalDef &quot;Prelude.gen&quot; -&gt; Just _,</span>
<span class="lineno">  641 </span><span class="spaces">                             </span><span class="nottickedoff">[n, a, f]))</span>
<span class="lineno">  642 </span><span class="spaces">  </span><span class="nottickedoff">= Just (n, a, const $ return f)</span>
<span class="lineno">  643 </span><span class="spaces"></span><span class="nottickedoff">asGenVecTerm (asApplyAll -&gt; (isGlobalDef &quot;Prelude.genWithProof&quot; -&gt; Just _,</span>
<span class="lineno">  644 </span><span class="spaces">                             </span><span class="nottickedoff">[n, a, asIndexWithProofFnTerm -&gt; Just m_f]))</span>
<span class="lineno">  645 </span><span class="spaces">  </span><span class="nottickedoff">= Just (n, a, m_f)</span>
<span class="lineno">  646 </span><span class="spaces"></span><span class="nottickedoff">asGenVecTerm _ = Nothing</span></span>
<span class="lineno">  647 </span>
<span class="lineno">  648 </span>-- | Match a term of the form @genBVVecNoPf n len a f@ or
<span class="lineno">  649 </span>-- @genBVVec n len a (\i _ -&gt; f i)@
<span class="lineno">  650 </span>asGenBVVecTerm :: Recognizer Term (Term, Term, Term, SharedContext -&gt; IO Term)
<span class="lineno">  651 </span><span class="decl"><span class="nottickedoff">asGenBVVecTerm (asApplyAll -&gt; (isGlobalDef &quot;Prelude.genBVVecNoPf&quot; -&gt; Just _,</span>
<span class="lineno">  652 </span><span class="spaces">                               </span><span class="nottickedoff">[n, len, a, f]))</span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="nottickedoff">= Just (n, len, a, const $ return f)</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="nottickedoff">asGenBVVecTerm (asApplyAll -&gt; (isGlobalDef &quot;Prelude.genBVVec&quot; -&gt; Just _,</span>
<span class="lineno">  655 </span><span class="spaces">                               </span><span class="nottickedoff">[n, len, a, asIndexWithProofFnTerm -&gt; Just m_f]))</span>
<span class="lineno">  656 </span><span class="spaces">  </span><span class="nottickedoff">= Just (n, len, a, m_f)</span>
<span class="lineno">  657 </span><span class="spaces"></span><span class="nottickedoff">asGenBVVecTerm _ = Nothing</span></span>
<span class="lineno">  658 </span>
<span class="lineno">  659 </span>-- | Index into a vector using the @at@ accessor, taking in the same 'Term'
<span class="lineno">  660 </span>-- arguments as that function, but simplify when the vector is a term
<span class="lineno">  661 </span>-- constructed from @gen@ or @genWithProof@
<span class="lineno">  662 </span>mrAtVec :: Term -&gt; Term -&gt; Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  663 </span><span class="decl"><span class="nottickedoff">mrAtVec _ _ (asGenVecTerm -&gt; Just (_, _, m_f)) ix =</span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 m_f &gt;&gt;= \f -&gt; mrApply f ix</span>
<span class="lineno">  665 </span><span class="spaces"></span><span class="nottickedoff">mrAtVec len a v ix =</span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;Prelude.at&quot; [len, a, v, ix]</span></span>
<span class="lineno">  667 </span>
<span class="lineno">  668 </span>-- | Index into a vector using the @atBVVecNoPf@ accessor, taking in the same
<span class="lineno">  669 </span>-- 'Term' arguments as that function, but simplify when the vector is a term
<span class="lineno">  670 </span>-- constructed from @gen@ or @genWithProof@
<span class="lineno">  671 </span>mrAtBVVec :: Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  672 </span><span class="decl"><span class="nottickedoff">mrAtBVVec _ _ _ (asGenBVVecTerm -&gt; Just (_, _, _, m_f)) ix =</span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="nottickedoff">liftSC0 m_f &gt;&gt;= \f -&gt; mrApply f ix</span>
<span class="lineno">  674 </span><span class="spaces"></span><span class="nottickedoff">mrAtBVVec n len a v ix =</span>
<span class="lineno">  675 </span><span class="spaces">  </span><span class="nottickedoff">liftSC2 scGlobalApply &quot;Prelude.atBVVecNoPf&quot; [n, len, a, v, ix]</span></span>
<span class="lineno">  676 </span>
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>----------------------------------------------------------------------
<span class="lineno">  679 </span>-- * Monadic Operations on Terms
<span class="lineno">  680 </span>----------------------------------------------------------------------
<span class="lineno">  681 </span>
<span class="lineno">  682 </span>-- | Apply a 'TermProj' to perform a projection on a 'Term'
<span class="lineno">  683 </span>doTermProj :: Term -&gt; TermProj -&gt; MRM t Term
<span class="lineno">  684 </span><span class="decl"><span class="nottickedoff">doTermProj (asPairValue -&gt; Just (t, _)) TermProjLeft = return t</span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="nottickedoff">doTermProj (asPairValue -&gt; Just (_, t)) TermProjRight = return t</span>
<span class="lineno">  686 </span><span class="spaces"></span><span class="nottickedoff">doTermProj (asRecordValue -&gt; Just t_map) (TermProjRecord fld)</span>
<span class="lineno">  687 </span><span class="spaces">  </span><span class="nottickedoff">| Just t &lt;- Map.lookup fld t_map = return t</span>
<span class="lineno">  688 </span><span class="spaces"></span><span class="nottickedoff">doTermProj t TermProjLeft = liftSC1 scPairLeft t</span>
<span class="lineno">  689 </span><span class="spaces"></span><span class="nottickedoff">doTermProj t TermProjRight = liftSC1 scPairRight t</span>
<span class="lineno">  690 </span><span class="spaces"></span><span class="nottickedoff">doTermProj t (TermProjRecord fld) = liftSC2 scRecordSelect t fld</span></span>
<span class="lineno">  691 </span>
<span class="lineno">  692 </span>-- | Apply a 'TermProj' to a type to get the output type of the projection,
<span class="lineno">  693 </span>-- assuming that the type is already normalized
<span class="lineno">  694 </span>doTypeProj :: Term -&gt; TermProj -&gt; MRM t Term
<span class="lineno">  695 </span><span class="decl"><span class="nottickedoff">doTypeProj (asPairType -&gt; Just (tp1, _)) TermProjLeft = return tp1</span>
<span class="lineno">  696 </span><span class="spaces"></span><span class="nottickedoff">doTypeProj (asPairType -&gt; Just (_, tp2)) TermProjRight = return tp2</span>
<span class="lineno">  697 </span><span class="spaces"></span><span class="nottickedoff">doTypeProj (asRecordType -&gt; Just tp_map) (TermProjRecord fld)</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="nottickedoff">| Just tp &lt;- Map.lookup fld tp_map</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="nottickedoff">= return tp</span>
<span class="lineno">  700 </span><span class="spaces"></span><span class="nottickedoff">doTypeProj _ _ =</span>
<span class="lineno">  701 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: better error message? This is an error and not an MRFailure because</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="nottickedoff">-- we should only be projecting types for terms that we have already seen...</span>
<span class="lineno">  703 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;doTypeProj&quot;</span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>-- | Get and normalize the type of a 'FunName'
<span class="lineno">  706 </span>funNameType :: FunName -&gt; MRM t Term
<span class="lineno">  707 </span><span class="decl"><span class="nottickedoff">funNameType (CallSName var) = liftSC1 scWhnf $ mrVarType var</span>
<span class="lineno">  708 </span><span class="spaces"></span><span class="nottickedoff">funNameType (EVarFunName var) = liftSC1 scWhnf $ mrVarType var</span>
<span class="lineno">  709 </span><span class="spaces"></span><span class="nottickedoff">funNameType (GlobalName gd projs) =</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="nottickedoff">liftSC1 scWhnf (globalDefType gd) &gt;&gt;= \gd_tp -&gt;</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="nottickedoff">foldM doTypeProj gd_tp projs</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>-- | Apply a 'Term' to a list of arguments and beta-reduce in Mr. Monad
<span class="lineno">  714 </span>mrApplyAll :: Term -&gt; [Term] -&gt; MRM t Term
<span class="lineno">  715 </span><span class="decl"><span class="nottickedoff">mrApplyAll f args = liftSC2 scApplyAllBeta f args</span></span>
<span class="lineno">  716 </span>
<span class="lineno">  717 </span>-- | Apply a 'Term' to a single argument and beta-reduce in Mr. Monad
<span class="lineno">  718 </span>mrApply :: Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  719 </span><span class="decl"><span class="nottickedoff">mrApply f arg = mrApplyAll f [arg]</span></span>
<span class="lineno">  720 </span>
<span class="lineno">  721 </span>-- | Substitue a list of @N@ arguments into the body of an @N@-ary pi type
<span class="lineno">  722 </span>mrPiApplyAll :: Term -&gt; [Term] -&gt; MRM t Term
<span class="lineno">  723 </span><span class="decl"><span class="nottickedoff">mrPiApplyAll tp args</span>
<span class="lineno">  724 </span><span class="spaces">  </span><span class="nottickedoff">| Just (_, body) &lt;- asPiListN (length args) tp</span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="nottickedoff">= substTermLike 0 args body</span>
<span class="lineno">  726 </span><span class="spaces"></span><span class="nottickedoff">mrPiApplyAll _ _ = panic &quot;mrPiApplyAll&quot; [&quot;Too many arguments for pi type&quot;]</span></span>
<span class="lineno">  727 </span>
<span class="lineno">  728 </span>-- | Return the unit type as a 'Type'
<span class="lineno">  729 </span>mrUnitType :: MRM t Type
<span class="lineno">  730 </span><span class="decl"><span class="nottickedoff">mrUnitType = Type &lt;$&gt; liftSC0 scUnitType</span></span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>-- | Build a constructor application in Mr. Monad
<span class="lineno">  733 </span>mrCtorApp :: Ident -&gt; [Term] -&gt; MRM t Term
<span class="lineno">  734 </span><span class="decl"><span class="nottickedoff">mrCtorApp = liftSC2 scCtorApp</span></span>
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>-- | Build a 'Term' for a global in Mr. Monad
<span class="lineno">  737 </span>mrGlobalTerm :: Ident -&gt; MRM t Term
<span class="lineno">  738 </span><span class="decl"><span class="nottickedoff">mrGlobalTerm = liftSC1 scGlobalDef</span></span>
<span class="lineno">  739 </span>
<span class="lineno">  740 </span>-- | Build a 'Term' for a global and unfold the global
<span class="lineno">  741 </span>mrGlobalTermUnfold :: Ident -&gt; MRM t Term
<span class="lineno">  742 </span><span class="decl"><span class="nottickedoff">mrGlobalTermUnfold ident =</span>
<span class="lineno">  743 </span><span class="spaces">  </span><span class="nottickedoff">(defBody &lt;$&gt; liftSC1 scRequireDef ident) &gt;&gt;= \case</span>
<span class="lineno">  744 </span><span class="spaces">  </span><span class="nottickedoff">Just body -&gt; return body</span>
<span class="lineno">  745 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt; panic &quot;mrGlobalTermUnfold&quot; [&quot;Definition &quot; &lt;&gt; identText ident &lt;&gt;</span>
<span class="lineno">  746 </span><span class="spaces">                                         </span><span class="nottickedoff">&quot; does not have a body&quot;]</span></span>
<span class="lineno">  747 </span>
<span class="lineno">  748 </span>-- | Apply a named global to a list of arguments and beta-reduce in Mr. Monad
<span class="lineno">  749 </span>mrApplyGlobal :: Ident -&gt; [Term] -&gt; MRM t Term
<span class="lineno">  750 </span><span class="decl"><span class="nottickedoff">mrApplyGlobal f args = mrGlobalTerm f &gt;&gt;= \t -&gt; mrApplyAll t args</span></span>
<span class="lineno">  751 </span>
<span class="lineno">  752 </span>-- | Build an arrow type @a -&gt; b@ using a return type @b@ that does not have an
<span class="lineno">  753 </span>-- additional free deBruijn index for the input
<span class="lineno">  754 </span>mrArrowType :: LocalName -&gt; Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  755 </span><span class="decl"><span class="nottickedoff">mrArrowType n tp_in tp_out =</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="nottickedoff">liftSC3 scPi n tp_in =&lt;&lt; liftTermLike 0 1 tp_out</span></span>
<span class="lineno">  757 </span>
<span class="lineno">  758 </span>-- | Build the bitvector type @Vec n Bool@ from natural number term @n@
<span class="lineno">  759 </span>mrBvType :: Term -&gt; MRM t Term
<span class="lineno">  760 </span><span class="decl"><span class="nottickedoff">mrBvType n =</span>
<span class="lineno">  761 </span><span class="spaces">  </span><span class="nottickedoff">do bool_tp &lt;- liftSC0 scBoolType</span>
<span class="lineno">  762 </span><span class="spaces">     </span><span class="nottickedoff">liftSC2 scVecType n bool_tp</span></span>
<span class="lineno">  763 </span>
<span class="lineno">  764 </span>-- | Build the equality proposition @Eq a t1 t2@
<span class="lineno">  765 </span>mrEqProp :: Term -&gt; Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  766 </span><span class="decl"><span class="nottickedoff">mrEqProp tp t1 t2 = liftSC2 scDataTypeApp &quot;Prelude.Eq&quot; [tp,t1,t2]</span></span>
<span class="lineno">  767 </span>
<span class="lineno">  768 </span>-- | Like 'scBvConst', but if given a bitvector literal it is converted to a
<span class="lineno">  769 </span>-- natural number literal
<span class="lineno">  770 </span>mrBvToNat :: Term -&gt; Term -&gt; MRM t Term
<span class="lineno">  771 </span><span class="decl"><span class="nottickedoff">mrBvToNat _ (asArrayValue -&gt; Just (asBoolType -&gt; Just _,</span>
<span class="lineno">  772 </span><span class="spaces">                                   </span><span class="nottickedoff">mapM asBool -&gt; Just bits)) =</span>
<span class="lineno">  773 </span><span class="spaces">  </span><span class="nottickedoff">liftSC1 scNat $ foldl' (\n bit -&gt; if bit then 2*n+1 else 2*n) 0 bits</span>
<span class="lineno">  774 </span><span class="spaces"></span><span class="nottickedoff">mrBvToNat n len = liftSC2 scGlobalApply &quot;Prelude.bvToNat&quot; [n, len]</span></span>
<span class="lineno">  775 </span>
<span class="lineno">  776 </span>-- | Given a bit-width 'Term' and a natural number 'Term', return a bitvector
<span class="lineno">  777 </span>-- 'Term' of the given bit-width only if we can can do so without truncation
<span class="lineno">  778 </span>-- (i.e. only if we can ensure the given natural is in range)
<span class="lineno">  779 </span>mrBvNatInRange :: Term -&gt; Term -&gt; MRM t (Maybe Term)
<span class="lineno">  780 </span><span class="decl"><span class="nottickedoff">mrBvNatInRange (asNat -&gt; Just w) (asUnsignedConcreteBvToNat -&gt; Just v)</span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="nottickedoff">| v &lt; 2 ^ w = Just &lt;$&gt; liftSC2 scBvLit w (toInteger v)</span>
<span class="lineno">  782 </span><span class="spaces"></span><span class="nottickedoff">mrBvNatInRange w (asBvToNat -&gt; Just (w', bv)) =</span>
<span class="lineno">  783 </span><span class="spaces">  </span><span class="nottickedoff">mrBvCastInRange w w' bv</span>
<span class="lineno">  784 </span><span class="spaces"></span><span class="nottickedoff">mrBvNatInRange w (asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.intToNat&quot;,</span>
<span class="lineno">  785 </span><span class="spaces">                                 </span><span class="nottickedoff">[i])) = case i of</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="nottickedoff">(asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.natToInt&quot;, [v])) -&gt;</span>
<span class="lineno">  787 </span><span class="spaces">    </span><span class="nottickedoff">mrBvNatInRange w v</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="nottickedoff">(asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;Prelude.bvToInt&quot;, [w', bv])) -&gt;</span>
<span class="lineno">  789 </span><span class="spaces">    </span><span class="nottickedoff">mrBvCastInRange w w' bv</span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; return Nothing</span>
<span class="lineno">  791 </span><span class="spaces"></span><span class="nottickedoff">mrBvNatInRange _ _ = return Nothing</span></span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>-- | Given two bit-width 'Term's and a bitvector 'Term' of the second bit-width,
<span class="lineno">  794 </span>-- return a bitvector 'Term' of the first bit-width only if we can can do so
<span class="lineno">  795 </span>-- without truncation (i.e. only if we can ensure the given bitvector is in
<span class="lineno">  796 </span>-- range)
<span class="lineno">  797 </span>mrBvCastInRange :: Term -&gt; Term -&gt; Term -&gt; MRM t (Maybe Term)
<span class="lineno">  798 </span><span class="decl"><span class="nottickedoff">mrBvCastInRange w1_t w2_t bv =</span>
<span class="lineno">  799 </span><span class="spaces">  </span><span class="nottickedoff">do w1_w2_cvt &lt;- mrConvertible w1_t w2_t</span>
<span class="lineno">  800 </span><span class="spaces">     </span><span class="nottickedoff">if w1_w2_cvt then return $ Just bv</span>
<span class="lineno">  801 </span><span class="spaces">     </span><span class="nottickedoff">else case (asNat w1_t, asNat w1_t, asUnsignedConcreteBv bv) of</span>
<span class="lineno">  802 </span><span class="spaces">       </span><span class="nottickedoff">(Just w1, _, Just v) | v &lt; 2 ^ w1 -&gt;</span>
<span class="lineno">  803 </span><span class="spaces">         </span><span class="nottickedoff">Just &lt;$&gt; liftSC2 scBvLit w1 (toInteger v)</span>
<span class="lineno">  804 </span><span class="spaces">       </span><span class="nottickedoff">(Just w1, Just w2, _) | w1 &gt; w2 -&gt; </span>
<span class="lineno">  805 </span><span class="spaces">         </span><span class="nottickedoff">do w1_sub_w2_t &lt;- liftSC1 scNat (w1 - w2)</span>
<span class="lineno">  806 </span><span class="spaces">            </span><span class="nottickedoff">Just &lt;$&gt; liftSC3 scBvUExt w2_t w1_sub_w2_t bv</span>
<span class="lineno">  807 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; return Nothing</span></span>
<span class="lineno">  808 </span>
<span class="lineno">  809 </span>-- | Get the current context of uvars as a list of variable names and their
<span class="lineno">  810 </span>-- types as SAW core 'Term's, with the least recently bound uvar first, i.e., in
<span class="lineno">  811 </span>-- the order as seen \&quot;from the outside\&quot;
<span class="lineno">  812 </span>mrUVarsOuterToInner :: MRM t [(LocalName,Term)]
<span class="lineno">  813 </span><span class="decl"><span class="nottickedoff">mrUVarsOuterToInner = mrVarCtxOuterToInner &lt;$&gt; mrUVars</span></span>
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>-- | Get the current context of uvars as a list of variable names and their
<span class="lineno">  816 </span>-- types as SAW core 'Term's, with the most recently bound uvar first, i.e., in
<span class="lineno">  817 </span>-- the order as seen \&quot;from the inside\&quot;
<span class="lineno">  818 </span>mrUVarsInnerToOuter :: MRM t [(LocalName,Term)]
<span class="lineno">  819 </span><span class="decl"><span class="nottickedoff">mrUVarsInnerToOuter = mrVarCtxInnerToOuter &lt;$&gt; mrUVars</span></span>
<span class="lineno">  820 </span>
<span class="lineno">  821 </span>-- | Get the type of a 'Term' in the current uvar context
<span class="lineno">  822 </span>mrTypeOf :: Term -&gt; MRM t Term
<span class="lineno">  823 </span><span class="decl"><span class="nottickedoff">mrTypeOf t =</span>
<span class="lineno">  824 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: scTypeOf' wants the type context in the most recently bound var first</span>
<span class="lineno">  825 </span><span class="spaces">  </span><span class="nottickedoff">-- mrDebugPPPrefix 3 &quot;mrTypeOf:&quot; t &gt;&gt;</span>
<span class="lineno">  826 </span><span class="spaces">  </span><span class="nottickedoff">mrUVarsInnerToOuter &gt;&gt;= \ctx -&gt; liftSC2 scTypeOf' (map snd ctx) t</span></span>
<span class="lineno">  827 </span>
<span class="lineno">  828 </span>-- | Check if two 'Term's are convertible in the 'MRM' monad
<span class="lineno">  829 </span>mrConvertible :: Term -&gt; Term -&gt; MRM t Bool
<span class="lineno">  830 </span><span class="decl"><span class="nottickedoff">mrConvertible = liftSC4 scConvertibleEval scTypeCheckWHNF True</span></span>
<span class="lineno">  831 </span>
<span class="lineno">  832 </span>-- | Take a 'FunName' @f@ for a monadic function of type @vars -&gt; SpecM a@ and
<span class="lineno">  833 </span>-- compute the type @SpecM [args/vars]a@ of @f@ applied to @args@. Return the
<span class="lineno">  834 </span>-- type @[args/vars]a@ that @SpecM@ is applied to, along with its event type.
<span class="lineno">  835 </span>mrFunOutType :: FunName -&gt; [Term] -&gt; MRM t (EvTerm, Term)
<span class="lineno">  836 </span><span class="decl"><span class="nottickedoff">mrFunOutType fname args =</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="nottickedoff">do app &lt;- mrApplyAll (funNameTerm fname) args</span>
<span class="lineno">  838 </span><span class="spaces">     </span><span class="nottickedoff">r_tp &lt;- mrTypeOf app &gt;&gt;= liftSC1 scWhnf</span>
<span class="lineno">  839 </span><span class="spaces">     </span><span class="nottickedoff">case asSpecM r_tp of</span>
<span class="lineno">  840 </span><span class="spaces">       </span><span class="nottickedoff">Just (ev, tp) -&gt; return (ev, tp)</span>
<span class="lineno">  841 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; throwMRFailure (NotCompFunType r_tp app)</span></span>
<span class="lineno">  842 </span>
<span class="lineno">  843 </span>-- | Turn a 'LocalName' into one not in a list, adding a suffix if necessary
<span class="lineno">  844 </span>uniquifyName :: LocalName -&gt; [LocalName] -&gt; LocalName
<span class="lineno">  845 </span><span class="decl"><span class="nottickedoff">uniquifyName nm nms | notElem nm nms = nm</span>
<span class="lineno">  846 </span><span class="spaces"></span><span class="nottickedoff">uniquifyName nm nms =</span>
<span class="lineno">  847 </span><span class="spaces">  </span><span class="nottickedoff">case find (flip notElem nms) $</span>
<span class="lineno">  848 </span><span class="spaces">       </span><span class="nottickedoff">map (T.append nm . T.pack . show) [(0::Int) ..] of</span>
<span class="lineno">  849 </span><span class="spaces">    </span><span class="nottickedoff">Just nm' -&gt; nm'</span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; error &quot;uniquifyName&quot;</span></span>
<span class="lineno">  851 </span>
<span class="lineno">  852 </span>-- | Turn a list of 'LocalName's into one names not in a list, adding suffixes
<span class="lineno">  853 </span>-- if necessary
<span class="lineno">  854 </span>uniquifyNames :: [LocalName] -&gt; [LocalName] -&gt; [LocalName]
<span class="lineno">  855 </span><span class="decl"><span class="nottickedoff">uniquifyNames [] _ = []</span>
<span class="lineno">  856 </span><span class="spaces"></span><span class="nottickedoff">uniquifyNames (nm:nms) nms_other =</span>
<span class="lineno">  857 </span><span class="spaces">  </span><span class="nottickedoff">let nm' = uniquifyName nm nms_other in</span>
<span class="lineno">  858 </span><span class="spaces">  </span><span class="nottickedoff">nm' : uniquifyNames nms (nm' : nms_other)</span></span>
<span class="lineno">  859 </span>
<span class="lineno">  860 </span>-- | Build a lambda term with the lifting (in the sense of 'incVars') of an
<span class="lineno">  861 </span>-- MR Solver term
<span class="lineno">  862 </span>-- NOTE: The types in the given context can have earlier variables in the
<span class="lineno">  863 </span>-- context free. Thus, if passing a list of types all in the same context, later
<span class="lineno">  864 </span>-- types should be lifted.
<span class="lineno">  865 </span>mrLambdaLift :: TermLike tm =&gt; [(LocalName,Term)] -&gt; tm -&gt;
<span class="lineno">  866 </span>                ([Term] -&gt; tm -&gt; MRM t Term) -&gt; MRM t Term
<span class="lineno">  867 </span><span class="decl"><span class="nottickedoff">mrLambdaLift [] t f = f [] t</span>
<span class="lineno">  868 </span><span class="spaces"></span><span class="nottickedoff">mrLambdaLift ctx t f =</span>
<span class="lineno">  869 </span><span class="spaces">  </span><span class="nottickedoff">do -- uniquifyNames doesn't care about the order of the names in its second,</span>
<span class="lineno">  870 </span><span class="spaces">     </span><span class="nottickedoff">-- argument, thus either inner-to-outer or outer-to-inner would work</span>
<span class="lineno">  871 </span><span class="spaces">     </span><span class="nottickedoff">nms &lt;- uniquifyNames (map fst ctx) &lt;$&gt; map fst &lt;$&gt; mrUVarsInnerToOuter</span>
<span class="lineno">  872 </span><span class="spaces">     </span><span class="nottickedoff">let ctx' = zipWith (\nm (_,tp) -&gt; (nm,tp)) nms ctx</span>
<span class="lineno">  873 </span><span class="spaces">     </span><span class="nottickedoff">vars &lt;- reverse &lt;$&gt; mapM (liftSC1 scLocalVar) [0 .. length ctx - 1]</span>
<span class="lineno">  874 </span><span class="spaces">     </span><span class="nottickedoff">t' &lt;- liftTermLike 0 (length ctx) t</span>
<span class="lineno">  875 </span><span class="spaces">     </span><span class="nottickedoff">f vars t' &gt;&gt;= liftSC2 scLambdaList ctx'</span></span>
<span class="lineno">  876 </span>
<span class="lineno">  877 </span>-- Specialized versions of mrLambdaLift that expect a certain number of Term
<span class="lineno">  878 </span>-- arguments. As an alternative, we could change the type of mrLambdaLift to
<span class="lineno">  879 </span>-- take a length-indexed vector instead (thereby avoiding partial pattern
<span class="lineno">  880 </span>-- matches), but that is probably overkill for our needs.
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>-- | Call 'mrLambdaLift' with exactly one 'Term' argument.
<span class="lineno">  883 </span>mrLambdaLift1 :: TermLike tm =&gt; (LocalName,Term) -&gt; tm -&gt;
<span class="lineno">  884 </span>                 (Term -&gt; tm -&gt; MRM t Term) -&gt; MRM t Term
<span class="lineno">  885 </span><span class="decl"><span class="nottickedoff">mrLambdaLift1 (nm,tp) t f =</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="nottickedoff">mrLambdaLift [(nm,tp)] t $ \vars t' -&gt;</span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="nottickedoff">case vars of</span>
<span class="lineno">  888 </span><span class="spaces">      </span><span class="nottickedoff">[v] -&gt; f v t'</span>
<span class="lineno">  889 </span><span class="spaces">      </span><span class="nottickedoff">_   -&gt; panic &quot;mrLambdaLift1&quot; [&quot;Expected exactly one Term argument&quot;]</span></span>
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>-- | Call 'mrLambdaLift' with exactly two 'Term' arguments which are both in the
<span class="lineno">  892 </span>-- same context. (To create two lambdas where the type of the second variable
<span class="lineno">  893 </span>-- depends on the value of the first, use 'mrLambdaLift' directly.)
<span class="lineno">  894 </span>mrLambdaLift2 :: TermLike tm =&gt; (LocalName,Term) -&gt; (LocalName,Term) -&gt; tm -&gt;
<span class="lineno">  895 </span>                 (Term -&gt; Term -&gt; tm -&gt; MRM t Term) -&gt; MRM t Term
<span class="lineno">  896 </span><span class="decl"><span class="nottickedoff">mrLambdaLift2 (nm1,tp1) (nm2,tp2) t f =</span>
<span class="lineno">  897 </span><span class="spaces">  </span><span class="nottickedoff">liftTermLike 0 1 tp2 &gt;&gt;= \tp2' -&gt;</span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="nottickedoff">mrLambdaLift [(nm1,tp1), (nm2,tp2')] t $ \vars t' -&gt;</span>
<span class="lineno">  899 </span><span class="spaces">    </span><span class="nottickedoff">case vars of</span>
<span class="lineno">  900 </span><span class="spaces">      </span><span class="nottickedoff">[v1, v2] -&gt; f v1 v2 t'</span>
<span class="lineno">  901 </span><span class="spaces">      </span><span class="nottickedoff">_        -&gt; panic &quot;mrLambdaLift2&quot; [&quot;Expected exactly two Term arguments&quot;]</span></span>
<span class="lineno">  902 </span>
<span class="lineno">  903 </span>-- | Run a MR Solver computation in a context extended with a universal
<span class="lineno">  904 </span>-- variable, which is passed as a 'Term' to the sub-computation. Note that any
<span class="lineno">  905 </span>-- assumptions made in the sub-computation will be lost when it completes.
<span class="lineno">  906 </span>withUVar :: LocalName -&gt; Type -&gt; (Term -&gt; MRM t a) -&gt; MRM t a
<span class="lineno">  907 </span><span class="decl"><span class="nottickedoff">withUVar nm tp m = withUVars (singletonMRVarCtx nm tp) $ \case</span>
<span class="lineno">  908 </span><span class="spaces">  </span><span class="nottickedoff">[v] -&gt; m v</span>
<span class="lineno">  909 </span><span class="spaces">  </span><span class="nottickedoff">_   -&gt; panic &quot;withUVar&quot; [&quot;impossible&quot;]</span></span>
<span class="lineno">  910 </span>
<span class="lineno">  911 </span>-- | Run a MR Solver computation in a context extended with a universal variable
<span class="lineno">  912 </span>-- and pass it the lifting (in the sense of 'incVars') of an MR Solver term
<span class="lineno">  913 </span>withUVarLift :: TermLike tm =&gt; LocalName -&gt; Type -&gt; tm -&gt;
<span class="lineno">  914 </span>                (Term -&gt; tm -&gt; MRM t a) -&gt; MRM t a
<span class="lineno">  915 </span><span class="decl"><span class="nottickedoff">withUVarLift nm tp t m =</span>
<span class="lineno">  916 </span><span class="spaces">  </span><span class="nottickedoff">withUVar nm tp (\x -&gt; liftTermLike 0 1 t &gt;&gt;= m x)</span></span>
<span class="lineno">  917 </span>
<span class="lineno">  918 </span>-- | Run a MR Solver computation in a context extended with a list of universal
<span class="lineno">  919 </span>-- variables, passing 'Term's for those variables to the supplied computation.
<span class="lineno">  920 </span>withUVars :: MRVarCtx -&gt; ([Term] -&gt; MRM t a) -&gt; MRM t a
<span class="lineno">  921 </span><span class="decl"><span class="nottickedoff">withUVars (mrVarCtxLength -&gt; 0) f = f []</span>
<span class="lineno">  922 </span><span class="spaces"></span><span class="nottickedoff">withUVars ctx f =</span>
<span class="lineno">  923 </span><span class="spaces">  </span><span class="nottickedoff">do -- for uniquifyNames, we want to consider the oldest names first, thus we</span>
<span class="lineno">  924 </span><span class="spaces">     </span><span class="nottickedoff">-- must pass the first argument in outer-to-inner order. uniquifyNames</span>
<span class="lineno">  925 </span><span class="spaces">     </span><span class="nottickedoff">-- doesn't care about the order of the names in its second, argument, thus</span>
<span class="lineno">  926 </span><span class="spaces">     </span><span class="nottickedoff">-- either inner-to-outer or outer-to-inner would work</span>
<span class="lineno">  927 </span><span class="spaces">     </span><span class="nottickedoff">let ctx_l = mrVarCtxOuterToInner ctx</span>
<span class="lineno">  928 </span><span class="spaces">     </span><span class="nottickedoff">nms &lt;- uniquifyNames (map fst ctx_l) &lt;$&gt; map fst &lt;$&gt; mrUVarsInnerToOuter</span>
<span class="lineno">  929 </span><span class="spaces">     </span><span class="nottickedoff">let ctx_u = mrVarCtxFromOuterToInner $ zip nms $ map snd ctx_l</span>
<span class="lineno">  930 </span><span class="spaces">     </span><span class="nottickedoff">-- lift all the variables in our assumptions by the number of new uvars</span>
<span class="lineno">  931 </span><span class="spaces">     </span><span class="nottickedoff">-- we're adding (we do not have to lift the types in our uvar context</span>
<span class="lineno">  932 </span><span class="spaces">     </span><span class="nottickedoff">-- itself, since each type is in the context of all older uvars - see the</span>
<span class="lineno">  933 </span><span class="spaces">     </span><span class="nottickedoff">-- definition of MRVarCtx)</span>
<span class="lineno">  934 </span><span class="spaces">     </span><span class="nottickedoff">assumps' &lt;- mrAssumptions &gt;&gt;= liftTerm 0 (mrVarCtxLength ctx)</span>
<span class="lineno">  935 </span><span class="spaces">     </span><span class="nottickedoff">dataTypeAssumps' &lt;- mrDataTypeAssumps &gt;&gt;= mapM (liftTermLike 0 (mrVarCtxLength ctx))</span>
<span class="lineno">  936 </span><span class="spaces">     </span><span class="nottickedoff">-- make terms for our new uvars, extend the context, and continue</span>
<span class="lineno">  937 </span><span class="spaces">     </span><span class="nottickedoff">vars &lt;- reverse &lt;$&gt; mapM (liftSC1 scLocalVar) [0 .. mrVarCtxLength ctx - 1]</span>
<span class="lineno">  938 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriUVars = mrVarCtxAppend ctx_u (mriUVars info),</span>
<span class="lineno">  939 </span><span class="spaces">                            </span><span class="nottickedoff">mriAssumptions = assumps',</span>
<span class="lineno">  940 </span><span class="spaces">                            </span><span class="nottickedoff">mriDataTypeAssumps = dataTypeAssumps' }) $</span>
<span class="lineno">  941 </span><span class="spaces">       </span><span class="nottickedoff">mapM (\t -&gt; (t,) &lt;$&gt; mrTypeOf t) vars &gt;&gt;= \vars_with_types -&gt;</span>
<span class="lineno">  942 </span><span class="spaces">       </span><span class="nottickedoff">mrDebugPPPrefix 3 &quot;withUVars:&quot; vars_with_types &gt;&gt;</span>
<span class="lineno">  943 </span><span class="spaces">       </span><span class="nottickedoff">foldr (\nm m -&gt; mapMRFailure (MRFailureLocalVar nm) m) (f vars) nms</span></span>
<span class="lineno">  944 </span>
<span class="lineno">  945 </span>-- | Run a MR Solver in a top-level context, i.e., with no uvars or assumptions
<span class="lineno">  946 </span>withNoUVars :: MRM t a -&gt; MRM t a
<span class="lineno">  947 </span><span class="decl"><span class="nottickedoff">withNoUVars m =</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="nottickedoff">do true_tm &lt;- liftSC1 scBool True</span>
<span class="lineno">  949 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriUVars = emptyMRVarCtx, mriAssumptions = true_tm,</span>
<span class="lineno">  950 </span><span class="spaces">                            </span><span class="nottickedoff">mriDataTypeAssumps = HashMap.empty }) m</span></span>
<span class="lineno">  951 </span>
<span class="lineno">  952 </span>-- | Run a MR Solver in a context of only the specified UVars, no others -
<span class="lineno">  953 </span>-- note that this also clears all assumptions
<span class="lineno">  954 </span>withOnlyUVars :: MRVarCtx -&gt; MRM t a -&gt; MRM t a
<span class="lineno">  955 </span><span class="decl"><span class="nottickedoff">withOnlyUVars vars m = withNoUVars $ withUVars vars $ const m</span></span>
<span class="lineno">  956 </span>
<span class="lineno">  957 </span>-- | Build 'Term's for all the uvars currently in scope, ordered from least to
<span class="lineno">  958 </span>-- most recently bound
<span class="lineno">  959 </span>getAllUVarTerms :: MRM t [Term]
<span class="lineno">  960 </span><span class="decl"><span class="nottickedoff">getAllUVarTerms =</span>
<span class="lineno">  961 </span><span class="spaces">  </span><span class="nottickedoff">(mrVarCtxLength &lt;$&gt; mrUVars) &gt;&gt;= \len -&gt;</span>
<span class="lineno">  962 </span><span class="spaces">  </span><span class="nottickedoff">mapM (liftSC1 scLocalVar) [len-1, len-2 .. 0]</span></span>
<span class="lineno">  963 </span>
<span class="lineno">  964 </span>-- | Lambda-abstract all the current uvars out of a 'Term', with the least
<span class="lineno">  965 </span>-- recently bound variable being abstracted first
<span class="lineno">  966 </span>lambdaUVarsM :: Term -&gt; MRM t Term
<span class="lineno">  967 </span><span class="decl"><span class="nottickedoff">lambdaUVarsM t = mrUVarsOuterToInner &gt;&gt;= \ctx -&gt; liftSC2 scLambdaList ctx t</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>-- | Pi-abstract all the current uvars out of a 'Term', with the least recently
<span class="lineno">  970 </span>-- bound variable being abstracted first
<span class="lineno">  971 </span>piUVarsM :: Term -&gt; MRM t Term
<span class="lineno">  972 </span><span class="decl"><span class="nottickedoff">piUVarsM t = mrUVarsOuterToInner &gt;&gt;= \ctx -&gt; liftSC2 scPiList ctx t</span></span>
<span class="lineno">  973 </span>
<span class="lineno">  974 </span>-- | Instantiate all uvars in a term using the supplied function
<span class="lineno">  975 </span>instantiateUVarsM :: forall a t. TermLike a =&gt;
<span class="lineno">  976 </span>                     (LocalName -&gt; Term -&gt; MRM t Term) -&gt; a -&gt; MRM t a
<span class="lineno">  977 </span><span class="decl"><span class="nottickedoff">instantiateUVarsM f a =</span>
<span class="lineno">  978 </span><span class="spaces">  </span><span class="nottickedoff">do ctx &lt;- mrUVarsOuterToInner</span>
<span class="lineno">  979 </span><span class="spaces">     </span><span class="nottickedoff">-- Remember: the uvar context is outermost to innermost, so we bind</span>
<span class="lineno">  980 </span><span class="spaces">     </span><span class="nottickedoff">-- variables from left to right, substituting earlier ones into the types</span>
<span class="lineno">  981 </span><span class="spaces">     </span><span class="nottickedoff">-- of later ones, but all substitutions are in reverse order, since</span>
<span class="lineno">  982 </span><span class="spaces">     </span><span class="nottickedoff">-- substTerm and friends like innermost bindings first</span>
<span class="lineno">  983 </span><span class="spaces">     </span><span class="nottickedoff">let helper :: [Term] -&gt; [(LocalName,Term)] -&gt; MRM t [Term]</span>
<span class="lineno">  984 </span><span class="spaces">         </span><span class="nottickedoff">helper tms [] = return tms</span>
<span class="lineno">  985 </span><span class="spaces">         </span><span class="nottickedoff">helper tms ((nm,tp):vars) =</span>
<span class="lineno">  986 </span><span class="spaces">           </span><span class="nottickedoff">do tp' &lt;- substTerm 0 tms tp</span>
<span class="lineno">  987 </span><span class="spaces">              </span><span class="nottickedoff">tm &lt;- f nm tp'</span>
<span class="lineno">  988 </span><span class="spaces">              </span><span class="nottickedoff">helper (tm:tms) vars</span>
<span class="lineno">  989 </span><span class="spaces">     </span><span class="nottickedoff">ecs &lt;- helper [] ctx</span>
<span class="lineno">  990 </span><span class="spaces">     </span><span class="nottickedoff">substTermLike 0 ecs a</span></span>
<span class="lineno">  991 </span>
<span class="lineno">  992 </span>-- | Convert an 'MRVar' to a 'Term', applying it to all the uvars in scope
<span class="lineno">  993 </span>mrVarTerm :: MRVar -&gt; MRM t Term
<span class="lineno">  994 </span><span class="decl"><span class="nottickedoff">mrVarTerm (MRVar ec) =</span>
<span class="lineno">  995 </span><span class="spaces">  </span><span class="nottickedoff">do var_tm &lt;- liftSC1 scExtCns ec</span>
<span class="lineno">  996 </span><span class="spaces">     </span><span class="nottickedoff">vars &lt;- getAllUVarTerms</span>
<span class="lineno">  997 </span><span class="spaces">     </span><span class="nottickedoff">liftSC2 scApplyAll var_tm vars</span></span>
<span class="lineno">  998 </span>
<span class="lineno">  999 </span>-- | Create a dummy proof term of the specified type, which can be open but
<span class="lineno"> 1000 </span>-- should be of @Prop@ sort, by creating an 'ExtCns' axiom. This is sound as
<span class="lineno"> 1001 </span>-- long as we only use the resulting term in computation branches where we know
<span class="lineno"> 1002 </span>-- the proposition holds.
<span class="lineno"> 1003 </span>mrDummyProof :: Term -&gt; MRM t Term
<span class="lineno"> 1004 </span><span class="decl"><span class="nottickedoff">mrDummyProof tp = mrFreshVar &quot;pf&quot; tp &gt;&gt;= mrVarTerm</span></span>
<span class="lineno"> 1005 </span>
<span class="lineno"> 1006 </span>-- | Get the 'VarInfo' associated with a 'MRVar'
<span class="lineno"> 1007 </span>mrVarInfo :: MRVar -&gt; MRM t (Maybe MRVarInfo)
<span class="lineno"> 1008 </span><span class="decl"><span class="nottickedoff">mrVarInfo var = Map.lookup var &lt;$&gt; mrVars</span></span>
<span class="lineno"> 1009 </span>
<span class="lineno"> 1010 </span>-- | Convert an 'ExtCns' to a 'FunName'
<span class="lineno"> 1011 </span>extCnsToFunName :: ExtCns Term -&gt; MRM t FunName
<span class="lineno"> 1012 </span><span class="decl"><span class="nottickedoff">extCnsToFunName ec =</span>
<span class="lineno"> 1013 </span><span class="spaces">  </span><span class="nottickedoff">do let var = MRVar ec</span>
<span class="lineno"> 1014 </span><span class="spaces">     </span><span class="nottickedoff">mm &lt;- liftSC0 scGetModuleMap</span>
<span class="lineno"> 1015 </span><span class="spaces">     </span><span class="nottickedoff">let ?mm = mm</span>
<span class="lineno"> 1016 </span><span class="spaces">     </span><span class="nottickedoff">mrVarInfo var &gt;&gt;= \case</span>
<span class="lineno"> 1017 </span><span class="spaces">       </span><span class="nottickedoff">Just (EVarInfo _ _) -&gt; return $ EVarFunName var</span>
<span class="lineno"> 1018 </span><span class="spaces">       </span><span class="nottickedoff">Just (CallVarInfo _) -&gt; return $ CallSName var</span>
<span class="lineno"> 1019 </span><span class="spaces">       </span><span class="nottickedoff">Nothing</span>
<span class="lineno"> 1020 </span><span class="spaces">         </span><span class="nottickedoff">| Just glob &lt;- asTypedGlobalDef (Unshared $ FTermF $ ExtCns ec) -&gt;</span>
<span class="lineno"> 1021 </span><span class="spaces">           </span><span class="nottickedoff">return $ GlobalName glob []</span>
<span class="lineno"> 1022 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; error &quot;extCnsToFunName: unreachable&quot;</span></span>
<span class="lineno"> 1023 </span>
<span class="lineno"> 1024 </span>-- | Get the body of a global definition, raising an 'error' if none is found
<span class="lineno"> 1025 </span>mrGlobalDefBody :: Ident -&gt; MRM t Term
<span class="lineno"> 1026 </span><span class="decl"><span class="nottickedoff">mrGlobalDefBody ident = liftSC1 scFindDef ident &gt;&gt;= \case</span>
<span class="lineno"> 1027 </span><span class="spaces">  </span><span class="nottickedoff">Just (defBody -&gt; Just body) -&gt; pure body</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error $ &quot;mrGlobalDefBody: global has no definition: &quot; ++ show ident</span></span>
<span class="lineno"> 1029 </span>
<span class="lineno"> 1030 </span>-- | Get the body of a function @f@ if it has one
<span class="lineno"> 1031 </span>mrFunNameBody :: FunName -&gt; MRM t (Maybe Term)
<span class="lineno"> 1032 </span><span class="decl"><span class="nottickedoff">mrFunNameBody (CallSName var) =</span>
<span class="lineno"> 1033 </span><span class="spaces">  </span><span class="nottickedoff">mrVarInfo var &gt;&gt;= \case</span>
<span class="lineno"> 1034 </span><span class="spaces">  </span><span class="nottickedoff">Just (CallVarInfo body) -&gt; return $ Just body</span>
<span class="lineno"> 1035 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;mrFunBody: unknown letrec var&quot;</span>
<span class="lineno"> 1036 </span><span class="spaces"></span><span class="nottickedoff">mrFunNameBody (GlobalName glob projs) =</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="nottickedoff">do mm &lt;- liftSC0 scGetModuleMap</span>
<span class="lineno"> 1038 </span><span class="spaces">     </span><span class="nottickedoff">case lookupVarIndexInMap (globalDefIndex glob) mm of</span>
<span class="lineno"> 1039 </span><span class="spaces">       </span><span class="nottickedoff">Just (ResolvedDef (defBody -&gt; Just body)) -&gt;</span>
<span class="lineno"> 1040 </span><span class="spaces">         </span><span class="nottickedoff">Just &lt;$&gt; foldM doTermProj body projs</span>
<span class="lineno"> 1041 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; pure Nothing</span>
<span class="lineno"> 1042 </span><span class="spaces"></span><span class="nottickedoff">mrFunNameBody (EVarFunName _) = return Nothing</span></span>
<span class="lineno"> 1043 </span>
<span class="lineno"> 1044 </span>-- | Get the body of a function @f@ applied to some arguments, if possible
<span class="lineno"> 1045 </span>mrFunBody :: FunName -&gt; [Term] -&gt; MRM t (Maybe Term)
<span class="lineno"> 1046 </span><span class="decl"><span class="nottickedoff">mrFunBody f args = mrFunNameBody f &gt;&gt;= \case</span>
<span class="lineno"> 1047 </span><span class="spaces">  </span><span class="nottickedoff">Just body -&gt; Just &lt;$&gt; mrApplyAll body args</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt; return Nothing</span></span>
<span class="lineno"> 1049 </span>
<span class="lineno"> 1050 </span>-- | Get the body of a function @f@ applied to some arguments, as per
<span class="lineno"> 1051 </span>-- 'mrFunBody', and also return whether its body recursively calls itself, as
<span class="lineno"> 1052 </span>-- per 'mrCallsFun'
<span class="lineno"> 1053 </span>mrFunBodyRecInfo :: FunName -&gt; [Term] -&gt; MRM t (Maybe (Term, Bool))
<span class="lineno"> 1054 </span><span class="decl"><span class="nottickedoff">mrFunBodyRecInfo f args =</span>
<span class="lineno"> 1055 </span><span class="spaces">  </span><span class="nottickedoff">mrFunNameBody f &gt;&gt;= \case</span>
<span class="lineno"> 1056 </span><span class="spaces">  </span><span class="nottickedoff">Just body -&gt; do</span>
<span class="lineno"> 1057 </span><span class="spaces">    </span><span class="nottickedoff">body_applied &lt;- mrApplyAll body args</span>
<span class="lineno"> 1058 </span><span class="spaces">    </span><span class="nottickedoff">is_recursive &lt;- mrCallsFun f body</span>
<span class="lineno"> 1059 </span><span class="spaces">    </span><span class="nottickedoff">return $ Just (body_applied, is_recursive)</span>
<span class="lineno"> 1060 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt; return Nothing</span></span>
<span class="lineno"> 1061 </span>
<span class="lineno"> 1062 </span>-- | Test if a 'Term' contains, after possibly unfolding some functions, a call
<span class="lineno"> 1063 </span>-- to a given function @f@ again
<span class="lineno"> 1064 </span>mrCallsFun :: FunName -&gt; Term -&gt; MRM t Bool
<span class="lineno"> 1065 </span><span class="decl"><span class="nottickedoff">mrCallsFun f t0 =</span>
<span class="lineno"> 1066 </span><span class="spaces">  </span><span class="nottickedoff">do mm &lt;- liftSC0 scGetModuleMap</span>
<span class="lineno"> 1067 </span><span class="spaces">     </span><span class="nottickedoff">let ?mm = mm</span>
<span class="lineno"> 1068 </span><span class="spaces">     </span><span class="nottickedoff">let fn recurse seen t =</span>
<span class="lineno"> 1069 </span><span class="spaces">           </span><span class="nottickedoff">let onFunName g = mrFunNameBody g &gt;&gt;= \case</span>
<span class="lineno"> 1070 </span><span class="spaces">                 </span><span class="nottickedoff">_ | f == g -&gt; return True</span>
<span class="lineno"> 1071 </span><span class="spaces">                 </span><span class="nottickedoff">Just body | Set.notMember g seen -&gt; recurse (Set.insert g seen) body</span>
<span class="lineno"> 1072 </span><span class="spaces">                 </span><span class="nottickedoff">_ -&gt; return False</span>
<span class="lineno"> 1073 </span><span class="spaces">           </span><span class="nottickedoff">in case t of</span>
<span class="lineno"> 1074 </span><span class="spaces">           </span><span class="nottickedoff">(asExtCns -&gt; Just ec) -&gt; extCnsToFunName ec &gt;&gt;= onFunName</span>
<span class="lineno"> 1075 </span><span class="spaces">           </span><span class="nottickedoff">(asGlobalFunName -&gt; Just g) -&gt; onFunName g</span>
<span class="lineno"> 1076 </span><span class="spaces">           </span><span class="nottickedoff">(unwrapTermF -&gt; tf) -&gt;</span>
<span class="lineno"> 1077 </span><span class="spaces">             </span><span class="nottickedoff">foldM (\b t' -&gt; if b then return b else recurse seen t') False tf</span>
<span class="lineno"> 1078 </span><span class="spaces">     </span><span class="nottickedoff">memoFixTermFunAccum fn Set.empty t0</span></span>
<span class="lineno"> 1079 </span>
<span class="lineno"> 1080 </span>
<span class="lineno"> 1081 </span>----------------------------------------------------------------------
<span class="lineno"> 1082 </span>-- * Monadic Operations on Mr. Solver State
<span class="lineno"> 1083 </span>----------------------------------------------------------------------
<span class="lineno"> 1084 </span>
<span class="lineno"> 1085 </span>-- | Make a fresh 'MRVar' of a given type, which must be closed, i.e., have no
<span class="lineno"> 1086 </span>-- free uvars
<span class="lineno"> 1087 </span>mrFreshVarCl :: LocalName -&gt; Term -&gt; MRM t MRVar
<span class="lineno"> 1088 </span><span class="decl"><span class="nottickedoff">mrFreshVarCl nm tp = MRVar &lt;$&gt; liftSC2 scFreshEC nm tp</span></span>
<span class="lineno"> 1089 </span>
<span class="lineno"> 1090 </span>-- | Make a fresh 'MRVar' of type @(u1:tp1) -&gt; ... (un:tpn) -&gt; tp@, where the
<span class="lineno"> 1091 </span>-- @ui@ are all the current uvars
<span class="lineno"> 1092 </span>mrFreshVar :: LocalName -&gt; Term -&gt; MRM t MRVar
<span class="lineno"> 1093 </span><span class="decl"><span class="nottickedoff">mrFreshVar nm tp = piUVarsM tp &gt;&gt;= mrFreshVarCl nm</span></span>
<span class="lineno"> 1094 </span>
<span class="lineno"> 1095 </span>-- | Set the info associated with an 'MRVar', assuming it has not been set
<span class="lineno"> 1096 </span>mrSetVarInfo :: MRVar -&gt; MRVarInfo -&gt; MRM t ()
<span class="lineno"> 1097 </span><span class="decl"><span class="nottickedoff">mrSetVarInfo var info =</span>
<span class="lineno"> 1098 </span><span class="spaces">  </span><span class="nottickedoff">mrDebugPPInCtxM 3 (prettyWithCtx emptyMRVarCtx $</span>
<span class="lineno"> 1099 </span><span class="spaces">                     </span><span class="nottickedoff">prettyPrefixSep &quot;mrSetVarInfo&quot; var &quot;=&quot; info) &gt;&gt;</span>
<span class="lineno"> 1100 </span><span class="spaces">  </span><span class="nottickedoff">(modify $ \st -&gt;</span>
<span class="lineno"> 1101 </span><span class="spaces">   </span><span class="nottickedoff">st { mrsVars =</span>
<span class="lineno"> 1102 </span><span class="spaces">          </span><span class="nottickedoff">Map.alter (\case</span>
<span class="lineno"> 1103 </span><span class="spaces">                        </span><span class="nottickedoff">Just _ -&gt; error &quot;mrSetVarInfo&quot;</span>
<span class="lineno"> 1104 </span><span class="spaces">                        </span><span class="nottickedoff">Nothing -&gt; Just info)</span>
<span class="lineno"> 1105 </span><span class="spaces">          </span><span class="nottickedoff">var (mrsVars st) })</span></span>
<span class="lineno"> 1106 </span>
<span class="lineno"> 1107 </span>-- | Make a fresh existential variable of the given type, abstracting out all
<span class="lineno"> 1108 </span>-- the current uvars and returning the new evar applied to all current uvars
<span class="lineno"> 1109 </span>mrFreshEVar :: LocalName -&gt; Type -&gt; MRM t Term
<span class="lineno"> 1110 </span><span class="decl"><span class="nottickedoff">mrFreshEVar nm (Type tp) =</span>
<span class="lineno"> 1111 </span><span class="spaces">  </span><span class="nottickedoff">do var &lt;- mrFreshVar nm tp</span>
<span class="lineno"> 1112 </span><span class="spaces">     </span><span class="nottickedoff">ctx_len &lt;- mrVarCtxLength &lt;$&gt; mrUVars</span>
<span class="lineno"> 1113 </span><span class="spaces">     </span><span class="nottickedoff">mrSetVarInfo var (EVarInfo ctx_len Nothing)</span>
<span class="lineno"> 1114 </span><span class="spaces">     </span><span class="nottickedoff">mrVarTerm var</span></span>
<span class="lineno"> 1115 </span>
<span class="lineno"> 1116 </span>-- | Return a fresh sequence of existential variables from a 'MRVarCtx'.
<span class="lineno"> 1117 </span>-- Return the new evars all applied to the current uvars.
<span class="lineno"> 1118 </span>mrFreshEVars :: MRVarCtx -&gt; MRM t [Term]
<span class="lineno"> 1119 </span><span class="decl"><span class="nottickedoff">mrFreshEVars = helper [] . mrVarCtxOuterToInner where</span>
<span class="lineno"> 1120 </span><span class="spaces">  </span><span class="nottickedoff">-- Return fresh evars for the suffix of a context of variable names and types,</span>
<span class="lineno"> 1121 </span><span class="spaces">  </span><span class="nottickedoff">-- where the supplied Terms are evars that have already been generated for the</span>
<span class="lineno"> 1122 </span><span class="spaces">  </span><span class="nottickedoff">-- earlier part of the context, and so must be substituted into the remaining</span>
<span class="lineno"> 1123 </span><span class="spaces">  </span><span class="nottickedoff">-- types in the context. Since we want to make fresh evars for the oldest</span>
<span class="lineno"> 1124 </span><span class="spaces">  </span><span class="nottickedoff">-- variables first, the second argument must be in outer-to-inner order.</span>
<span class="lineno"> 1125 </span><span class="spaces">  </span><span class="nottickedoff">helper :: [Term] -&gt; [(LocalName,Term)] -&gt; MRM t [Term]</span>
<span class="lineno"> 1126 </span><span class="spaces">  </span><span class="nottickedoff">helper evars [] = return evars</span>
<span class="lineno"> 1127 </span><span class="spaces">  </span><span class="nottickedoff">helper evars ((nm,tp):ctx) =</span>
<span class="lineno"> 1128 </span><span class="spaces">    </span><span class="nottickedoff">do evar &lt;- substTerm 0 evars tp &gt;&gt;= mrFreshEVar nm . Type</span>
<span class="lineno"> 1129 </span><span class="spaces">       </span><span class="nottickedoff">helper (evar:evars) ctx</span></span>
<span class="lineno"> 1130 </span>
<span class="lineno"> 1131 </span>-- | Set the value of an evar to a closed term
<span class="lineno"> 1132 </span>mrSetEVarClosed :: MRVar -&gt; Term -&gt; MRM t ()
<span class="lineno"> 1133 </span><span class="decl"><span class="nottickedoff">mrSetEVarClosed var val =</span>
<span class="lineno"> 1134 </span><span class="spaces">  </span><span class="nottickedoff">do val_tp &lt;- mrTypeOf val</span>
<span class="lineno"> 1135 </span><span class="spaces">     </span><span class="nottickedoff">-- NOTE: need to instantiate any evars in the type of var, to ensure the</span>
<span class="lineno"> 1136 </span><span class="spaces">     </span><span class="nottickedoff">-- following subtyping check will succeed</span>
<span class="lineno"> 1137 </span><span class="spaces">     </span><span class="nottickedoff">var_tp &lt;- mrSubstEVars $ mrVarType var</span>
<span class="lineno"> 1138 </span><span class="spaces">     </span><span class="nottickedoff">-- FIXME: catch subtyping errors and report them as being evar failures</span>
<span class="lineno"> 1139 </span><span class="spaces">     </span><span class="nottickedoff">eith_err &lt;-</span>
<span class="lineno"> 1140 </span><span class="spaces">       </span><span class="nottickedoff">liftSC2 (runTCM $ checkSubtype (SCTypedTerm val val_tp) var_tp) Nothing []</span>
<span class="lineno"> 1141 </span><span class="spaces">     </span><span class="nottickedoff">case eith_err of</span>
<span class="lineno"> 1142 </span><span class="spaces">       </span><span class="nottickedoff">Left _ -&gt;</span>
<span class="lineno"> 1143 </span><span class="spaces">         </span><span class="nottickedoff">error (&quot;mrSetEVarClosed: incorrect instantiation for evar &quot; ++</span>
<span class="lineno"> 1144 </span><span class="spaces">                </span><span class="nottickedoff">showMRVar var ++</span>
<span class="lineno"> 1145 </span><span class="spaces">                </span><span class="nottickedoff">&quot;\nexpected type:\n&quot; ++ showTerm var_tp ++</span>
<span class="lineno"> 1146 </span><span class="spaces">                </span><span class="nottickedoff">&quot;\nactual type:\n&quot; ++ showTerm val_tp)</span>
<span class="lineno"> 1147 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; return ()</span>
<span class="lineno"> 1148 </span><span class="spaces">     </span><span class="nottickedoff">modify $ \st -&gt;</span>
<span class="lineno"> 1149 </span><span class="spaces">       </span><span class="nottickedoff">st { mrsVars =</span>
<span class="lineno"> 1150 </span><span class="spaces">            </span><span class="nottickedoff">Map.alter</span>
<span class="lineno"> 1151 </span><span class="spaces">            </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 1152 </span><span class="spaces">                </span><span class="nottickedoff">Just (EVarInfo clen Nothing) -&gt; Just $ EVarInfo clen (Just val)</span>
<span class="lineno"> 1153 </span><span class="spaces">                </span><span class="nottickedoff">Just (EVarInfo _ (Just _)) -&gt;</span>
<span class="lineno"> 1154 </span><span class="spaces">                  </span><span class="nottickedoff">error &quot;Setting existential variable: variable already set!&quot;</span>
<span class="lineno"> 1155 </span><span class="spaces">                </span><span class="nottickedoff">_ -&gt; error &quot;Setting existential variable: not an evar!&quot;)</span>
<span class="lineno"> 1156 </span><span class="spaces">            </span><span class="nottickedoff">var (mrsVars st) }</span></span>
<span class="lineno"> 1157 </span>
<span class="lineno"> 1158 </span>
<span class="lineno"> 1159 </span>-- | Try to set the value of the application @X e1 .. en@ of evar @X@ to an
<span class="lineno"> 1160 </span>-- expression @e@ by trying to set @X@ to @\ x1 ... xn -&gt; e@. This only works if
<span class="lineno"> 1161 </span>-- each free uvar @xi@ in @e@ is one of the arguments @ej@ to @X@ (though it
<span class="lineno"> 1162 </span>-- need not be the case that @i=j@). Return whether this succeeded.
<span class="lineno"> 1163 </span>mrTrySetAppliedEVar :: MRVar -&gt; [Term] -&gt; Term -&gt; MRM t Bool
<span class="lineno"> 1164 </span><span class="decl"><span class="nottickedoff">mrTrySetAppliedEVar evar args t =</span>
<span class="lineno"> 1165 </span><span class="spaces">  </span><span class="nottickedoff">-- Get the first N argument variables of the type of evar, where N is the</span>
<span class="lineno"> 1166 </span><span class="spaces">  </span><span class="nottickedoff">-- length of args; note that evar can have more than N arguments if t is a</span>
<span class="lineno"> 1167 </span><span class="spaces">  </span><span class="nottickedoff">-- higher-order term</span>
<span class="lineno"> 1168 </span><span class="spaces">  </span><span class="nottickedoff">let (take (length args) -&gt; evar_vars, _) = asPiList (mrVarType evar) in</span>
<span class="lineno"> 1169 </span><span class="spaces">  </span><span class="nottickedoff">-- Get all the free variables of t</span>
<span class="lineno"> 1170 </span><span class="spaces">  </span><span class="nottickedoff">let free_vars = bitSetElems (looseVars t) in</span>
<span class="lineno"> 1171 </span><span class="spaces">  </span><span class="nottickedoff">-- For each free var of t, find an arg equal to it</span>
<span class="lineno"> 1172 </span><span class="spaces">  </span><span class="nottickedoff">case mapM (\i -&gt; findIndex (\case</span>
<span class="lineno"> 1173 </span><span class="spaces">                                 </span><span class="nottickedoff">(asLocalVar -&gt; Just j) -&gt; i == j</span>
<span class="lineno"> 1174 </span><span class="spaces">                                 </span><span class="nottickedoff">_ -&gt; False) args) free_vars of</span>
<span class="lineno"> 1175 </span><span class="spaces">    </span><span class="nottickedoff">Just fv_arg_ixs</span>
<span class="lineno"> 1176 </span><span class="spaces">      </span><span class="nottickedoff">-- Check to make sure we have the right number of args</span>
<span class="lineno"> 1177 </span><span class="spaces">      </span><span class="nottickedoff">| length args == length evar_vars -&gt; do</span>
<span class="lineno"> 1178 </span><span class="spaces">          </span><span class="nottickedoff">-- Build a list of the input vars x1 ... xn as terms, noting that the</span>
<span class="lineno"> 1179 </span><span class="spaces">          </span><span class="nottickedoff">-- first variable is the least recently bound and so has the highest</span>
<span class="lineno"> 1180 </span><span class="spaces">          </span><span class="nottickedoff">-- deBruijn index</span>
<span class="lineno"> 1181 </span><span class="spaces">          </span><span class="nottickedoff">let arg_ixs = reverse [0 .. length args - 1]</span>
<span class="lineno"> 1182 </span><span class="spaces">          </span><span class="nottickedoff">arg_vars &lt;- mapM (liftSC1 scLocalVar) arg_ixs</span>
<span class="lineno"> 1183 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1184 </span><span class="spaces">          </span><span class="nottickedoff">-- For each free variable of t, we substitute the corresponding</span>
<span class="lineno"> 1185 </span><span class="spaces">          </span><span class="nottickedoff">-- variable xi, substituting error terms for the variables that are</span>
<span class="lineno"> 1186 </span><span class="spaces">          </span><span class="nottickedoff">-- not free (since we have nothing else to substitute for them)</span>
<span class="lineno"> 1187 </span><span class="spaces">          </span><span class="nottickedoff">let var_map = zip free_vars fv_arg_ixs</span>
<span class="lineno"> 1188 </span><span class="spaces">          </span><span class="nottickedoff">let subst_vars = if free_vars == [] then [] else</span>
<span class="lineno"> 1189 </span><span class="spaces">                             </span><span class="nottickedoff">[0 .. maximum free_vars]</span>
<span class="lineno"> 1190 </span><span class="spaces">          </span><span class="nottickedoff">let subst = flip map subst_vars $ \i -&gt;</span>
<span class="lineno"> 1191 </span><span class="spaces">                </span><span class="nottickedoff">maybe (error</span>
<span class="lineno"> 1192 </span><span class="spaces">                       </span><span class="nottickedoff">(&quot;mrTrySetAppliedEVar: unexpected free variable &quot;</span>
<span class="lineno"> 1193 </span><span class="spaces">                        </span><span class="nottickedoff">++ show i ++ &quot; in term\n&quot; ++ showTerm t))</span>
<span class="lineno"> 1194 </span><span class="spaces">                </span><span class="nottickedoff">(arg_vars !!) (lookup i var_map)</span>
<span class="lineno"> 1195 </span><span class="spaces">          </span><span class="nottickedoff">body &lt;- substTerm 0 subst t</span>
<span class="lineno"> 1196 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1197 </span><span class="spaces">          </span><span class="nottickedoff">-- Now instantiate evar to \x1 ... xn -&gt; body</span>
<span class="lineno"> 1198 </span><span class="spaces">          </span><span class="nottickedoff">evar_inst &lt;- liftSC2 scLambdaList evar_vars body</span>
<span class="lineno"> 1199 </span><span class="spaces">          </span><span class="nottickedoff">mrSetEVarClosed evar evar_inst</span>
<span class="lineno"> 1200 </span><span class="spaces">          </span><span class="nottickedoff">return True</span>
<span class="lineno"> 1201 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1202 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; return False</span></span>
<span class="lineno"> 1203 </span>
<span class="lineno"> 1204 </span>
<span class="lineno"> 1205 </span>-- | Replace all evars in a 'Term' with their instantiations when they have one
<span class="lineno"> 1206 </span>mrSubstEVars :: Term -&gt; MRM t Term
<span class="lineno"> 1207 </span><span class="decl"><span class="nottickedoff">mrSubstEVars = memoFixTermFun $ \recurse t -&gt;</span>
<span class="lineno"> 1208 </span><span class="spaces">  </span><span class="nottickedoff">do var_map &lt;- mrVars</span>
<span class="lineno"> 1209 </span><span class="spaces">     </span><span class="nottickedoff">case t of</span>
<span class="lineno"> 1210 </span><span class="spaces">       </span><span class="nottickedoff">-- If t is an instantiated evar, recurse on its instantiation</span>
<span class="lineno"> 1211 </span><span class="spaces">       </span><span class="nottickedoff">(asEVarApp var_map -&gt; Just (_, _, args, Just t')) -&gt;</span>
<span class="lineno"> 1212 </span><span class="spaces">         </span><span class="nottickedoff">mrApplyAll t' args &gt;&gt;= recurse</span>
<span class="lineno"> 1213 </span><span class="spaces">       </span><span class="nottickedoff">-- If t is anything else, recurse on its immediate subterms</span>
<span class="lineno"> 1214 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; traverseSubterms recurse t</span></span>
<span class="lineno"> 1215 </span>
<span class="lineno"> 1216 </span>-- | Replace all evars in a 'Term' with their instantiations when they have one
<span class="lineno"> 1217 </span>-- and \&quot;lower\&quot; those that do not. Lowering an evar in this context means
<span class="lineno"> 1218 </span>-- replacing each occurrence @X x1 .. xn@ of an evar @X@ applied to its context
<span class="lineno"> 1219 </span>-- of uvars with a fresh 'ExtCns' variable @Y@. This must be done after
<span class="lineno"> 1220 </span>-- 'instantiateUVarsM' has replaced all uvars with fresh 'ExtCns' variables,
<span class="lineno"> 1221 </span>-- which ensures that @X x1 .. xn@ is actually a closed, top-level term since
<span class="lineno"> 1222 </span>-- each @xi@ is now an 'ExtCns'. This is necessary so @X x1 .. xn@ can be
<span class="lineno"> 1223 </span>-- replaced by an 'ExtCns' @Y@, which is always closed. The idea of lowering is
<span class="lineno"> 1224 </span>-- that @X@ should always occur applied to these same values, so really we can
<span class="lineno"> 1225 </span>-- just treat the entire expression @X x1 .. xn@ as a single unknown value,
<span class="lineno"> 1226 </span>-- rather than worrying about how @X@ depends on its inputs.
<span class="lineno"> 1227 </span>mrSubstLowerEVars :: Term -&gt; MRM t Term
<span class="lineno"> 1228 </span><span class="decl"><span class="nottickedoff">mrSubstLowerEVars t_top =</span>
<span class="lineno"> 1229 </span><span class="spaces">  </span><span class="nottickedoff">do var_map &lt;- mrVars</span>
<span class="lineno"> 1230 </span><span class="spaces">     </span><span class="nottickedoff">lower_map &lt;- liftIO $ newIORef Map.empty</span>
<span class="lineno"> 1231 </span><span class="spaces">     </span><span class="nottickedoff">flip memoFixTermFun t_top $ \recurse t -&gt;</span>
<span class="lineno"> 1232 </span><span class="spaces">       </span><span class="nottickedoff">case t of</span>
<span class="lineno"> 1233 </span><span class="spaces">         </span><span class="nottickedoff">-- If t is an instantiated evar, recurse on its instantiation</span>
<span class="lineno"> 1234 </span><span class="spaces">         </span><span class="nottickedoff">(asEVarApp var_map -&gt; Just (_, _, args, Just t')) -&gt;</span>
<span class="lineno"> 1235 </span><span class="spaces">           </span><span class="nottickedoff">mrApplyAll t' args &gt;&gt;= recurse</span>
<span class="lineno"> 1236 </span><span class="spaces">         </span><span class="nottickedoff">-- If t is an uninstantiated evar, look up or create its lowering as a</span>
<span class="lineno"> 1237 </span><span class="spaces">         </span><span class="nottickedoff">-- variable, making sure it is applied to evars for its arguments</span>
<span class="lineno"> 1238 </span><span class="spaces">         </span><span class="nottickedoff">(asEVarApp var_map -&gt; Just (evar, clen, args, Nothing)) -&gt;</span>
<span class="lineno"> 1239 </span><span class="spaces">           </span><span class="nottickedoff">do let (cargs, args') = splitAt clen args</span>
<span class="lineno"> 1240 </span><span class="spaces">              </span><span class="nottickedoff">let my_panic :: () -&gt; a</span>
<span class="lineno"> 1241 </span><span class="spaces">                  </span><span class="nottickedoff">my_panic () =</span>
<span class="lineno"> 1242 </span><span class="spaces">                    </span><span class="nottickedoff">panic &quot;mrSubstLowerEVars&quot;</span>
<span class="lineno"> 1243 </span><span class="spaces">                    </span><span class="nottickedoff">[&quot;Unexpected evar application: &quot; &lt;&gt; T.pack (show t)]</span>
<span class="lineno"> 1244 </span><span class="spaces">              </span><span class="nottickedoff">let cargs_ec = fromMaybe (my_panic ()) $ mapM asExtCns cargs</span>
<span class="lineno"> 1245 </span><span class="spaces">              </span><span class="nottickedoff">t' &lt;- (Map.lookup evar &lt;$&gt; liftIO (readIORef lower_map)) &gt;&gt;= \case</span>
<span class="lineno"> 1246 </span><span class="spaces">                </span><span class="nottickedoff">Just (y, cargs_expected) -&gt;</span>
<span class="lineno"> 1247 </span><span class="spaces">                  </span><span class="nottickedoff">if cargs_ec == cargs_expected then return y else my_panic ()</span>
<span class="lineno"> 1248 </span><span class="spaces">                </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 1249 </span><span class="spaces">                  </span><span class="nottickedoff">do y_tp &lt;- mrPiApplyAll (mrVarType evar) cargs</span>
<span class="lineno"> 1250 </span><span class="spaces">                     </span><span class="nottickedoff">y &lt;- liftSC2 scFreshGlobal (T.pack $ showMRVar evar) y_tp</span>
<span class="lineno"> 1251 </span><span class="spaces">                     </span><span class="nottickedoff">liftIO $ modifyIORef' lower_map $</span>
<span class="lineno"> 1252 </span><span class="spaces">                       </span><span class="nottickedoff">Map.insert evar (y,cargs_ec)</span>
<span class="lineno"> 1253 </span><span class="spaces">                     </span><span class="nottickedoff">return y</span>
<span class="lineno"> 1254 </span><span class="spaces">              </span><span class="nottickedoff">mrApplyAll t' args' &gt;&gt;= recurse</span>
<span class="lineno"> 1255 </span><span class="spaces">         </span><span class="nottickedoff">-- If t is anything else, recurse on its immediate subterms</span>
<span class="lineno"> 1256 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; traverseSubterms recurse t</span></span>
<span class="lineno"> 1257 </span>
<span class="lineno"> 1258 </span>-- | Replace all evars in a 'Term' with their instantiations, returning
<span class="lineno"> 1259 </span>-- 'Nothing' if we hit an uninstantiated evar
<span class="lineno"> 1260 </span>mrSubstEVarsStrict :: Term -&gt; MRM t (Maybe Term)
<span class="lineno"> 1261 </span><span class="decl"><span class="nottickedoff">mrSubstEVarsStrict top_t =</span>
<span class="lineno"> 1262 </span><span class="spaces">  </span><span class="nottickedoff">runMaybeT $ flip memoFixTermFun top_t $ \recurse t -&gt;</span>
<span class="lineno"> 1263 </span><span class="spaces">  </span><span class="nottickedoff">do var_map &lt;- lift mrVars</span>
<span class="lineno"> 1264 </span><span class="spaces">     </span><span class="nottickedoff">case t of</span>
<span class="lineno"> 1265 </span><span class="spaces">       </span><span class="nottickedoff">-- If t is an instantiated evar, recurse on its instantiation</span>
<span class="lineno"> 1266 </span><span class="spaces">       </span><span class="nottickedoff">(asEVarApp var_map -&gt; Just (_, _, args, Just t')) -&gt;</span>
<span class="lineno"> 1267 </span><span class="spaces">         </span><span class="nottickedoff">lift (mrApplyAll t' args) &gt;&gt;= recurse</span>
<span class="lineno"> 1268 </span><span class="spaces">       </span><span class="nottickedoff">-- If t is an uninstantiated evar, return Nothing</span>
<span class="lineno"> 1269 </span><span class="spaces">       </span><span class="nottickedoff">(asEVarApp var_map -&gt; Just (_, _, _, Nothing)) -&gt;</span>
<span class="lineno"> 1270 </span><span class="spaces">         </span><span class="nottickedoff">mzero</span>
<span class="lineno"> 1271 </span><span class="spaces">       </span><span class="nottickedoff">-- If t is anything else, recurse on its immediate subterms</span>
<span class="lineno"> 1272 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; traverseSubterms recurse t</span></span>
<span class="lineno"> 1273 </span>
<span class="lineno"> 1274 </span>-- | Makes 'mrSubstEVarsStrict' be marked as used
<span class="lineno"> 1275 </span>_mrSubstEVarsStrict :: Term -&gt; MRM t (Maybe Term)
<span class="lineno"> 1276 </span><span class="decl"><span class="nottickedoff">_mrSubstEVarsStrict = mrSubstEVarsStrict</span></span>
<span class="lineno"> 1277 </span>
<span class="lineno"> 1278 </span>-- | Get the 'CoIndHyp' for a pair of 'FunName's, if there is one
<span class="lineno"> 1279 </span>mrGetCoIndHyp :: FunName -&gt; FunName -&gt; MRM t (Maybe CoIndHyp)
<span class="lineno"> 1280 </span><span class="decl"><span class="nottickedoff">mrGetCoIndHyp nm1 nm2 = Map.lookup (nm1, nm2) &lt;$&gt; mrCoIndHyps</span></span>
<span class="lineno"> 1281 </span>
<span class="lineno"> 1282 </span>-- | Run a compuation under an additional co-inductive assumption
<span class="lineno"> 1283 </span>withCoIndHyp :: CoIndHyp -&gt; MRM t a -&gt; MRM t a
<span class="lineno"> 1284 </span><span class="decl"><span class="nottickedoff">withCoIndHyp hyp m =</span>
<span class="lineno"> 1285 </span><span class="spaces">  </span><span class="nottickedoff">do mrDebugPPInCtxM 2 (prettyWithCtx emptyMRVarCtx $</span>
<span class="lineno"> 1286 </span><span class="spaces">                        </span><span class="nottickedoff">prettyPrefix &quot;withCoIndHyp&quot; hyp)</span>
<span class="lineno"> 1287 </span><span class="spaces">     </span><span class="nottickedoff">hyps' &lt;- Map.insert (coIndHypLHSFun hyp,</span>
<span class="lineno"> 1288 </span><span class="spaces">                          </span><span class="nottickedoff">coIndHypRHSFun hyp) hyp &lt;$&gt; mrCoIndHyps</span>
<span class="lineno"> 1289 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriCoIndHyps = hyps' }) m</span></span>
<span class="lineno"> 1290 </span>
<span class="lineno"> 1291 </span>-- | Generate fresh evars for the context of a 'CoIndHyp' and
<span class="lineno"> 1292 </span>-- substitute them into its arguments and right-hand side
<span class="lineno"> 1293 </span>instantiateCoIndHyp :: CoIndHyp -&gt; MRM t ([Term], [Term])
<span class="lineno"> 1294 </span><span class="decl"><span class="nottickedoff">instantiateCoIndHyp (CoIndHyp {..}) =</span>
<span class="lineno"> 1295 </span><span class="spaces">  </span><span class="nottickedoff">do evars &lt;- mrFreshEVars coIndHypCtx</span>
<span class="lineno"> 1296 </span><span class="spaces">     </span><span class="nottickedoff">lhs &lt;- substTermLike 0 evars coIndHypLHS</span>
<span class="lineno"> 1297 </span><span class="spaces">     </span><span class="nottickedoff">rhs &lt;- substTermLike 0 evars coIndHypRHS</span>
<span class="lineno"> 1298 </span><span class="spaces">     </span><span class="nottickedoff">return (lhs, rhs)</span></span>
<span class="lineno"> 1299 </span>
<span class="lineno"> 1300 </span>-- | Apply the invariants of a 'CoIndHyp' to their respective arguments,
<span class="lineno"> 1301 </span>-- yielding @Bool@ conditions, using the constant @True@ value when an
<span class="lineno"> 1302 </span>-- invariant is absent
<span class="lineno"> 1303 </span>applyCoIndHypInvariants :: CoIndHyp -&gt; MRM t (Term, Term)
<span class="lineno"> 1304 </span><span class="decl"><span class="nottickedoff">applyCoIndHypInvariants hyp =</span>
<span class="lineno"> 1305 </span><span class="spaces">  </span><span class="nottickedoff">let apply_invariant :: Maybe Term -&gt; [Term] -&gt; MRM t Term</span>
<span class="lineno"> 1306 </span><span class="spaces">      </span><span class="nottickedoff">apply_invariant (Just (asLambdaList -&gt; (vars, phi))) args</span>
<span class="lineno"> 1307 </span><span class="spaces">        </span><span class="nottickedoff">| length vars == length args</span>
<span class="lineno"> 1308 </span><span class="spaces">          </span><span class="nottickedoff">-- NOTE: applying to a list of arguments == substituting the reverse</span>
<span class="lineno"> 1309 </span><span class="spaces">          </span><span class="nottickedoff">-- of that list, because the first argument corresponds to the</span>
<span class="lineno"> 1310 </span><span class="spaces">          </span><span class="nottickedoff">-- greatest deBruijn index</span>
<span class="lineno"> 1311 </span><span class="spaces">        </span><span class="nottickedoff">= substTerm 0 (reverse args) phi</span>
<span class="lineno"> 1312 </span><span class="spaces">      </span><span class="nottickedoff">apply_invariant (Just _) _ =</span>
<span class="lineno"> 1313 </span><span class="spaces">        </span><span class="nottickedoff">error &quot;applyCoIndHypInvariants: wrong number of arguments for invariant!&quot;</span>
<span class="lineno"> 1314 </span><span class="spaces">      </span><span class="nottickedoff">apply_invariant Nothing _ = liftSC1 scBool True in</span>
<span class="lineno"> 1315 </span><span class="spaces">  </span><span class="nottickedoff">do invar1 &lt;- apply_invariant (coIndHypInvariantLHS hyp) (coIndHypLHS hyp)</span>
<span class="lineno"> 1316 </span><span class="spaces">     </span><span class="nottickedoff">invar2 &lt;- apply_invariant (coIndHypInvariantRHS hyp) (coIndHypRHS hyp)</span>
<span class="lineno"> 1317 </span><span class="spaces">     </span><span class="nottickedoff">return (invar1, invar2)</span></span>
<span class="lineno"> 1318 </span>
<span class="lineno"> 1319 </span>-- | Look up the 'FunAssump' for a 'FunName', if there is one
<span class="lineno"> 1320 </span>mrGetFunAssump :: FunName -&gt; MRM t (Maybe (FunAssump t))
<span class="lineno"> 1321 </span><span class="decl"><span class="nottickedoff">mrGetFunAssump nm = lookupFunAssump nm &lt;$&gt; mrRefnset</span></span>
<span class="lineno"> 1322 </span>
<span class="lineno"> 1323 </span>-- | Run a computation under the additional assumption that a named function
<span class="lineno"> 1324 </span>-- applied to a list of arguments refines a given right-hand side, all of which
<span class="lineno"> 1325 </span>-- are 'Term's that can have the current uvars free
<span class="lineno"> 1326 </span>withFunAssump :: FunName -&gt; [Term] -&gt; Term -&gt; MRM t a -&gt; MRM t a
<span class="lineno"> 1327 </span><span class="decl"><span class="nottickedoff">withFunAssump fname args rhs m =</span>
<span class="lineno"> 1328 </span><span class="spaces">  </span><span class="nottickedoff">do k &lt;- mkCompFunReturn &lt;$&gt; mrFunOutType fname args</span>
<span class="lineno"> 1329 </span><span class="spaces">     </span><span class="nottickedoff">mrDebugPPPrefixSep 1 &quot;withFunAssump&quot; (FunBind fname args k)</span>
<span class="lineno"> 1330 </span><span class="spaces">                                     </span><span class="nottickedoff">&quot;|=&quot; rhs</span>
<span class="lineno"> 1331 </span><span class="spaces">     </span><span class="nottickedoff">ctx &lt;- mrUVars</span>
<span class="lineno"> 1332 </span><span class="spaces">     </span><span class="nottickedoff">rs &lt;- mrRefnset</span>
<span class="lineno"> 1333 </span><span class="spaces">     </span><span class="nottickedoff">let assump = FunAssump ctx fname args (RewriteFunAssump rhs) Nothing</span>
<span class="lineno"> 1334 </span><span class="spaces">     </span><span class="nottickedoff">let rs' = addFunAssump assump rs</span>
<span class="lineno"> 1335 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriRefnset = rs' }) m</span></span>
<span class="lineno"> 1336 </span>
<span class="lineno"> 1337 </span>-- | Get the invariant hint associated with a function name, by unfolding the
<span class="lineno"> 1338 </span>-- name and checking if its body has the form
<span class="lineno"> 1339 </span>--
<span class="lineno"> 1340 </span>-- &gt; \ x1 ... xn -&gt; invariantHint a phi m
<span class="lineno"> 1341 </span>--
<span class="lineno"> 1342 </span>-- If so, return @\ x1 ... xn -&gt; phi@ as a term with the @xi@ variables free.
<span class="lineno"> 1343 </span>-- Otherwise, return 'Nothing'. Note that this function will also look past
<span class="lineno"> 1344 </span>-- any initial @bindS ... (assertFiniteS ...)@ applications.
<span class="lineno"> 1345 </span>mrGetInvariant :: FunName -&gt; MRM t (Maybe Term)
<span class="lineno"> 1346 </span><span class="decl"><span class="nottickedoff">mrGetInvariant nm =</span>
<span class="lineno"> 1347 </span><span class="spaces">  </span><span class="nottickedoff">mrFunNameBody nm &gt;&gt;= \case</span>
<span class="lineno"> 1348 </span><span class="spaces">    </span><span class="nottickedoff">Just body -&gt; mrGetInvariantBody body</span>
<span class="lineno"> 1349 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; return Nothing</span></span>
<span class="lineno"> 1350 </span>
<span class="lineno"> 1351 </span>-- | The main loop of 'mrGetInvariant', which operates on a function body
<span class="lineno"> 1352 </span>mrGetInvariantBody :: Term -&gt; MRM t (Maybe Term)
<span class="lineno"> 1353 </span><span class="decl"><span class="nottickedoff">mrGetInvariantBody tm = case asApplyAll tm of</span>
<span class="lineno"> 1354 </span><span class="spaces">  </span><span class="nottickedoff">-- go inside any top-level lambdas</span>
<span class="lineno"> 1355 </span><span class="spaces">  </span><span class="nottickedoff">(asLambda -&gt; Just (nm, tp, body), []) -&gt;</span>
<span class="lineno"> 1356 </span><span class="spaces">    </span><span class="nottickedoff">do body' &lt;- liftSC1 betaNormalize body</span>
<span class="lineno"> 1357 </span><span class="spaces">       </span><span class="nottickedoff">mb_phi &lt;- mrGetInvariantBody body'</span>
<span class="lineno"> 1358 </span><span class="spaces">       </span><span class="nottickedoff">liftSC3 scLambda nm tp `mapM` mb_phi</span>
<span class="lineno"> 1359 </span><span class="spaces">  </span><span class="nottickedoff">-- always beta-reduce</span>
<span class="lineno"> 1360 </span><span class="spaces">  </span><span class="nottickedoff">(f@(asLambda -&gt; Just _), args) -&gt;</span>
<span class="lineno"> 1361 </span><span class="spaces">    </span><span class="nottickedoff">do tm' &lt;- mrApplyAll f args</span>
<span class="lineno"> 1362 </span><span class="spaces">       </span><span class="nottickedoff">mrGetInvariantBody tm'</span>
<span class="lineno"> 1363 </span><span class="spaces">  </span><span class="nottickedoff">-- go inside any top-level applications of of bindS ... (assertFiniteS ...)</span>
<span class="lineno"> 1364 </span><span class="spaces">  </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.bindS&quot; -&gt; Just (),</span>
<span class="lineno"> 1365 </span><span class="spaces">   </span><span class="nottickedoff">[_, _, _,</span>
<span class="lineno"> 1366 </span><span class="spaces">    </span><span class="nottickedoff">(asApplyAll -&gt; (isGlobalDef &quot;CryptolM.assertFiniteS&quot; -&gt; Just (),</span>
<span class="lineno"> 1367 </span><span class="spaces">                    </span><span class="nottickedoff">[_, (asGlobalApply &quot;Cryptol.TCNum&quot; -&gt; Just [_])])),</span>
<span class="lineno"> 1368 </span><span class="spaces">    </span><span class="nottickedoff">k]) -&gt;</span>
<span class="lineno"> 1369 </span><span class="spaces">    </span><span class="nottickedoff">do pf &lt;- liftSC1 scGlobalDef &quot;Prelude.TrueI&quot;</span>
<span class="lineno"> 1370 </span><span class="spaces">       </span><span class="nottickedoff">body &lt;- mrApplyAll k [pf]</span>
<span class="lineno"> 1371 </span><span class="spaces">       </span><span class="nottickedoff">mrGetInvariantBody body</span>
<span class="lineno"> 1372 </span><span class="spaces">  </span><span class="nottickedoff">-- otherwise, return Just iff there is a top-level invariant hint</span>
<span class="lineno"> 1373 </span><span class="spaces">  </span><span class="nottickedoff">(isGlobalDef &quot;SpecM.invariantHint&quot; -&gt; Just (),</span>
<span class="lineno"> 1374 </span><span class="spaces">   </span><span class="nottickedoff">[_, phi, _]) -&gt; return $ Just phi</span>
<span class="lineno"> 1375 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; return Nothing</span></span>
<span class="lineno"> 1376 </span>
<span class="lineno"> 1377 </span>-- | Add an assumption of type @Bool@ to the current path condition while
<span class="lineno"> 1378 </span>-- executing a sub-computation
<span class="lineno"> 1379 </span>withAssumption :: Term -&gt; MRM t a -&gt; MRM t a
<span class="lineno"> 1380 </span><span class="decl"><span class="nottickedoff">withAssumption phi m =</span>
<span class="lineno"> 1381 </span><span class="spaces">  </span><span class="nottickedoff">do mrDebugPPPrefix 1 &quot;withAssumption&quot; phi</span>
<span class="lineno"> 1382 </span><span class="spaces">     </span><span class="nottickedoff">assumps &lt;- mrAssumptions</span>
<span class="lineno"> 1383 </span><span class="spaces">     </span><span class="nottickedoff">assumps' &lt;- liftSC2 scAnd phi assumps</span>
<span class="lineno"> 1384 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriAssumptions = assumps' }) m</span></span>
<span class="lineno"> 1385 </span>
<span class="lineno"> 1386 </span>-- | Remove any existing assumptions and replace them with a Boolean term
<span class="lineno"> 1387 </span>withOnlyAssumption :: Term -&gt; MRM t a -&gt; MRM t a
<span class="lineno"> 1388 </span><span class="decl"><span class="nottickedoff">withOnlyAssumption phi m =</span>
<span class="lineno"> 1389 </span><span class="spaces">  </span><span class="nottickedoff">do mrDebugPPPrefix 1 &quot;withOnlyAssumption&quot; phi</span>
<span class="lineno"> 1390 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriAssumptions = phi }) m</span></span>
<span class="lineno"> 1391 </span>
<span class="lineno"> 1392 </span>-- | Add a 'DataTypeAssump' to the current context while executing a
<span class="lineno"> 1393 </span>-- sub-computations
<span class="lineno"> 1394 </span>withDataTypeAssump :: Term -&gt; DataTypeAssump -&gt; MRM t a -&gt; MRM t a
<span class="lineno"> 1395 </span><span class="decl"><span class="nottickedoff">withDataTypeAssump x assump m =</span>
<span class="lineno"> 1396 </span><span class="spaces">  </span><span class="nottickedoff">do mrDebugPPPrefixSep 1 &quot;withDataTypeAssump&quot; x &quot;==&quot; assump</span>
<span class="lineno"> 1397 </span><span class="spaces">     </span><span class="nottickedoff">dataTypeAssumps' &lt;- HashMap.insert x assump &lt;$&gt; mrDataTypeAssumps</span>
<span class="lineno"> 1398 </span><span class="spaces">     </span><span class="nottickedoff">local (\info -&gt; info { mriDataTypeAssumps = dataTypeAssumps' }) m</span></span>
<span class="lineno"> 1399 </span>
<span class="lineno"> 1400 </span>-- | Get the 'DataTypeAssump' associated to the given term, if one exists
<span class="lineno"> 1401 </span>mrGetDataTypeAssump :: Term -&gt; MRM t (Maybe DataTypeAssump)
<span class="lineno"> 1402 </span><span class="decl"><span class="nottickedoff">mrGetDataTypeAssump x = HashMap.lookup x &lt;$&gt; mrDataTypeAssumps</span></span>
<span class="lineno"> 1403 </span>
<span class="lineno"> 1404 </span>-- | Record a use of an SMT solver (for tracking 'SolverStats' and 'MRSolverEvidence')
<span class="lineno"> 1405 </span>recordUsedSolver :: SolverStats -&gt; Term -&gt; MRM t ()
<span class="lineno"> 1406 </span><span class="decl"><span class="nottickedoff">recordUsedSolver stats prop =</span>
<span class="lineno"> 1407 </span><span class="spaces">  </span><span class="nottickedoff">modify $ \st -&gt; st { mrsSolverStats = stats &lt;&gt; mrsSolverStats st,</span>
<span class="lineno"> 1408 </span><span class="spaces">                       </span><span class="nottickedoff">mrsEvidence = MREUsedSolver stats prop : mrsEvidence st }</span></span>
<span class="lineno"> 1409 </span>
<span class="lineno"> 1410 </span>-- | Record a use of a 'FunAssump' (for 'MRSolverEvidence')
<span class="lineno"> 1411 </span>recordUsedFunAssump :: FunAssump t -&gt; MRM t ()
<span class="lineno"> 1412 </span><span class="decl"><span class="nottickedoff">recordUsedFunAssump (fassumpAnnotation -&gt; Just t) =</span>
<span class="lineno"> 1413 </span><span class="spaces">  </span><span class="nottickedoff">modify $ \st -&gt; st { mrsEvidence = MREUsedFunAssump t : mrsEvidence st }</span>
<span class="lineno"> 1414 </span><span class="spaces"></span><span class="nottickedoff">recordUsedFunAssump _ = return ()</span></span>
<span class="lineno"> 1415 </span>
<span class="lineno"> 1416 </span>
<span class="lineno"> 1417 </span>----------------------------------------------------------------------
<span class="lineno"> 1418 </span>-- * Functions for Debug Output
<span class="lineno"> 1419 </span>----------------------------------------------------------------------
<span class="lineno"> 1420 </span>
<span class="lineno"> 1421 </span>-- | Print a 'String' to 'stderr' if the debug level is at least the supplied
<span class="lineno"> 1422 </span>-- 'Int'
<span class="lineno"> 1423 </span>mrDebugPrint :: Int -&gt; String -&gt; MRM t ()
<span class="lineno"> 1424 </span><span class="decl"><span class="nottickedoff">mrDebugPrint i str =</span>
<span class="lineno"> 1425 </span><span class="spaces">  </span><span class="nottickedoff">mrDebugLevel &gt;&gt;= \lvl -&gt;</span>
<span class="lineno"> 1426 </span><span class="spaces">  </span><span class="nottickedoff">if lvl &gt;= i then liftIO (hPutStrLn stderr str) else return ()</span></span>
<span class="lineno"> 1427 </span>
<span class="lineno"> 1428 </span>-- | Print a document to 'stderr' if the debug level is at least the supplied
<span class="lineno"> 1429 </span>-- 'Int'
<span class="lineno"> 1430 </span>mrDebugPretty :: Int -&gt; PPS.Doc -&gt; MRM t ()
<span class="lineno"> 1431 </span><span class="decl"><span class="nottickedoff">mrDebugPretty i pp =</span>
<span class="lineno"> 1432 </span><span class="spaces">  </span><span class="nottickedoff">mrPPOpts &gt;&gt;= \opts -&gt;</span>
<span class="lineno"> 1433 </span><span class="spaces">  </span><span class="nottickedoff">mrDebugPrint i (PPS.render opts pp)</span></span>
<span class="lineno"> 1434 </span>
<span class="lineno"> 1435 </span>-- | Print to 'stderr' the result of running a 'PPInCtxM' computation in the
<span class="lineno"> 1436 </span>-- current context and with the current 'PPOpts' if the current debug level is
<span class="lineno"> 1437 </span>-- at least the supplied 'Int'
<span class="lineno"> 1438 </span>mrDebugPPInCtxM :: Int -&gt; PPInCtxM PPS.Doc -&gt; MRM t ()
<span class="lineno"> 1439 </span><span class="decl"><span class="nottickedoff">mrDebugPPInCtxM i m = mrDebugPretty i =&lt;&lt; mrPPInCtxM m</span></span>
<span class="lineno"> 1440 </span>
<span class="lineno"> 1441 </span>-- | Pretty-print an object to 'stderr' in the current context and with the
<span class="lineno"> 1442 </span>-- current 'PPOpts' if the current debug level is at least the supplied 'Int'
<span class="lineno"> 1443 </span>mrDebugPPInCtx :: PrettyInCtx a =&gt; Int -&gt; a -&gt; MRM t ()
<span class="lineno"> 1444 </span><span class="decl"><span class="nottickedoff">mrDebugPPInCtx i a = mrDebugPretty i =&lt;&lt; mrPPInCtx a</span></span>
<span class="lineno"> 1445 </span>
<span class="lineno"> 1446 </span>-- | Pretty-print the result of 'prettyPrefix' to 'stderr' in the
<span class="lineno"> 1447 </span>-- current context and with the current 'PPOpts' if the debug level is at least
<span class="lineno"> 1448 </span>-- the 'Int' provided
<span class="lineno"> 1449 </span>mrDebugPPPrefix :: PrettyInCtx a =&gt; Int -&gt; String -&gt; a -&gt; MRM t ()
<span class="lineno"> 1450 </span><span class="decl"><span class="nottickedoff">mrDebugPPPrefix i pre a =</span>
<span class="lineno"> 1451 </span><span class="spaces">  </span><span class="nottickedoff">mrDebugPPInCtxM i $ group &lt;$&gt; nest 2 &lt;$&gt; prettyPrefix pre a</span></span>
<span class="lineno"> 1452 </span>
<span class="lineno"> 1453 </span>-- | Pretty-print the result of 'prettyPrefixSep' to 'stderr' in the current
<span class="lineno"> 1454 </span>-- context and with the current 'PPOpts' if the debug level is at least the
<span class="lineno"> 1455 </span>-- 'Int' provided
<span class="lineno"> 1456 </span>mrDebugPPPrefixSep :: (PrettyInCtx a, PrettyInCtx b) =&gt;
<span class="lineno"> 1457 </span>                      Int -&gt; String -&gt; a -&gt; String -&gt; b -&gt; MRM t ()
<span class="lineno"> 1458 </span><span class="decl"><span class="nottickedoff">mrDebugPPPrefixSep i pre a1 sp a2 =</span>
<span class="lineno"> 1459 </span><span class="spaces">  </span><span class="nottickedoff">mrDebugPPInCtxM i $ group &lt;$&gt; nest 2 &lt;$&gt; prettyPrefixSep pre a1 sp a2</span></span>

</pre>
</body>
</html>
