<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    2 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    5 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">    6 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">    7 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    8 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   10 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   11 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   12 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   13 </span>{-# LANGUAGE FunctionalDependencies #-}
<span class="lineno">   14 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   15 </span>{-# LANGUAGE PartialTypeSignatures #-}
<span class="lineno">   16 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   17 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   18 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   19 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   20 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   21 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">   22 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   23 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">   24 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   25 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   26 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   27 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   28 </span>{-# Language DeriveFunctor #-}
<span class="lineno">   29 </span>{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
<span class="lineno">   30 </span>{-# HLINT ignore &quot;Move brackets to avoid $&quot; #-}
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>module Heapster.SAWTranslation where
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>import Prelude hiding (pi)
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>import Data.Maybe
<span class="lineno">   37 </span>import Numeric.Natural
<span class="lineno">   38 </span>import Data.List (delete, find, intersperse)
<span class="lineno">   39 </span>import Data.Text (pack)
<span class="lineno">   40 </span>import GHC.TypeLits (KnownNat, natVal)
<span class="lineno">   41 </span>import Data.BitVector.Sized (BV)
<span class="lineno">   42 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   43 </span>import Data.Functor.Constant
<span class="lineno">   44 </span>import qualified Control.Applicative as App
<span class="lineno">   45 </span>import Control.Lens hiding ((:&gt;), Index, ix, op, getting)
<span class="lineno">   46 </span>import qualified Control.Monad as Monad
<span class="lineno">   47 </span>import Control.Monad (MonadPlus(..), zipWithM)
<span class="lineno">   48 </span>import Control.Monad.Reader (MonadReader(..), Reader, runReader, withReader,
<span class="lineno">   49 </span>                             ReaderT(..), mapReaderT, ask)
<span class="lineno">   50 </span>import Control.Monad.State (MonadState(..), StateT(..))
<span class="lineno">   51 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   52 </span>import Control.Monad.Trans.Maybe
<span class="lineno">   53 </span>import Control.Monad.Writer (MonadWriter(..), WriterT(..))
<span class="lineno">   54 </span>import qualified Control.Monad.Fail as Fail
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import What4.ProgramLoc
<span class="lineno">   57 </span>import What4.Interface (StringLiteral(..))
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import qualified Data.Type.RList as RL
<span class="lineno">   60 </span>import Data.Binding.Hobbits hiding (sym, trans)
<span class="lineno">   61 </span>import Data.Binding.Hobbits.Liftable ()
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>import Prettyprinter as PP
<span class="lineno">   64 </span>import Prettyprinter.Render.String
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>import Data.Parameterized.TraversableF
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>import Lang.Crucible.Types
<span class="lineno">   69 </span>import Lang.Crucible.LLVM.Extension
<span class="lineno">   70 </span>import Lang.Crucible.LLVM.MemModel
<span class="lineno">   71 </span>import Lang.Crucible.LLVM.DataLayout
<span class="lineno">   72 </span>import Lang.Crucible.CFG.Expr
<span class="lineno">   73 </span>import qualified Lang.Crucible.CFG.Expr as Expr
<span class="lineno">   74 </span>import Lang.Crucible.CFG.Core
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>import SAWCore.Name
<span class="lineno">   77 </span>import SAWCore.OpenTerm
<span class="lineno">   78 </span>import SAWCore.Term.Functor hiding (Constant)
<span class="lineno">   79 </span>import SAWCore.SharedTerm hiding (Constant)
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>import Heapster.Panic
<span class="lineno">   82 </span>-- import Heapster.GenMonad
<span class="lineno">   83 </span>import Heapster.CruUtil
<span class="lineno">   84 </span>import Heapster.Permissions
<span class="lineno">   85 </span>import Heapster.Implication
<span class="lineno">   86 </span>import Heapster.TypedCrucible
<span class="lineno">   87 </span>import Heapster.NamedMb
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>import GHC.Stack
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>-- | FIXME: document and move to Hobbits
<span class="lineno">   93 </span>suffixMembers :: prx1 ctx1 -&gt; RAssign prx2 ctx2 -&gt;
<span class="lineno">   94 </span>                 RAssign (Member (ctx1 :++: ctx2)) ctx2
<span class="lineno">   95 </span><span class="decl"><span class="nottickedoff">suffixMembers _ MNil = MNil</span>
<span class="lineno">   96 </span><span class="spaces"></span><span class="nottickedoff">suffixMembers ctx1 (ctx2 :&gt;: _) =</span>
<span class="lineno">   97 </span><span class="spaces">  </span><span class="nottickedoff">RL.map Member_Step (suffixMembers ctx1 ctx2) :&gt;: Member_Base</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>-- | Weaken a 'Member' proof by appending another context to the context it
<span class="lineno">  100 </span>-- proves membership in
<span class="lineno">  101 </span>weakenMemberR :: RAssign any ctx2 -&gt; Member ctx1 a -&gt; Member (ctx1 :++: ctx2) a
<span class="lineno">  102 </span><span class="decl"><span class="nottickedoff">weakenMemberR MNil memb = memb</span>
<span class="lineno">  103 </span><span class="spaces"></span><span class="nottickedoff">weakenMemberR (ctx1 :&gt;: _) memb = Member_Step (weakenMemberR ctx1 memb)</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- | Test if a 'Member' of the append of two contexts is a 'Member' of the first
<span class="lineno">  106 </span>-- or the second context
<span class="lineno">  107 </span>appendMemberCase :: prx1 ctx1 -&gt; RAssign prx2 ctx2 -&gt;
<span class="lineno">  108 </span>                    Member (ctx1 :++: ctx2) a -&gt;
<span class="lineno">  109 </span>                    Either (Member ctx1 a) (Member ctx2 a)
<span class="lineno">  110 </span><span class="decl"><span class="nottickedoff">appendMemberCase _ MNil memb = Left memb</span>
<span class="lineno">  111 </span><span class="spaces"></span><span class="nottickedoff">appendMemberCase _ (_ :&gt;: _) Member_Base = Right Member_Base</span>
<span class="lineno">  112 </span><span class="spaces"></span><span class="nottickedoff">appendMemberCase ctx1 (ctx2 :&gt;: _) (Member_Step memb) =</span>
<span class="lineno">  113 </span><span class="spaces">  </span><span class="nottickedoff">case appendMemberCase ctx1 ctx2 memb of</span>
<span class="lineno">  114 </span><span class="spaces">    </span><span class="nottickedoff">Left memb1 -&gt; Left memb1</span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="nottickedoff">Right memb2 -&gt; Right (Member_Step memb2)</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- | Get the length of a 'Member' proof, thereby converting a 'Member' of a
<span class="lineno">  118 </span>-- context into a deBruijn index
<span class="lineno">  119 </span>memberLength :: Member ctx a -&gt; Natural
<span class="lineno">  120 </span><span class="decl"><span class="nottickedoff">memberLength Member_Base = 0</span>
<span class="lineno">  121 </span><span class="spaces"></span><span class="nottickedoff">memberLength (Member_Step memb) = 1 + memberLength memb</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>----------------------------------------------------------------------
<span class="lineno">  125 </span>-- * Type Translations
<span class="lineno">  126 </span>----------------------------------------------------------------------
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- | Call 'prettyCallStack' and insert a newline in front
<span class="lineno">  129 </span>nlPrettyCallStack :: CallStack -&gt; String
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">nlPrettyCallStack = (&quot;\n&quot; ++) . prettyCallStack</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- | The result of translating a type-like construct such as a 'TypeRepr' or a
<span class="lineno">  133 </span>-- permission, parameterized by the (Haskell) type of the translations of the
<span class="lineno">  134 </span>-- elements of that type. This are translated to 0 or more SAW types, along with
<span class="lineno">  135 </span>-- a (Haskell) function for mapping elements of those types their translation
<span class="lineno">  136 </span>-- construct in Haskell.
<span class="lineno">  137 </span>data TypeTrans tr = TypeTrans
<span class="lineno">  138 </span>                     { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typeTransTypes</span></span></span> :: [OpenTerm],
<span class="lineno">  139 </span>                       <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typeTransFun</span></span></span> :: [OpenTerm] -&gt; tr }
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- | Apply the 'typeTransFun' of a 'TypeTrans' to a list of SAW core terms
<span class="lineno">  142 </span>typeTransF :: HasCallStack =&gt; TypeTrans tr -&gt; [OpenTerm] -&gt; tr
<span class="lineno">  143 </span><span class="decl"><span class="nottickedoff">typeTransF (TypeTrans tps f) ts | length tps == length ts = f ts</span>
<span class="lineno">  144 </span><span class="spaces"></span><span class="nottickedoff">typeTransF (TypeTrans tps _) ts =</span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="nottickedoff">error (&quot;Type translation expected &quot; ++ show (length tps) ++</span>
<span class="lineno">  146 </span><span class="spaces">         </span><span class="nottickedoff">&quot; arguments, but got &quot; ++ show (length ts))</span></span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>instance <span class="decl"><span class="nottickedoff">Functor TypeTrans</span></span> where
<span class="lineno">  149 </span>  <span class="decl"><span class="nottickedoff">fmap f (TypeTrans ts tp_f) = TypeTrans ts (f . tp_f)</span></span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative TypeTrans</span></span></span></span></span></span> where
<span class="lineno">  152 </span>  <span class="decl"><span class="nottickedoff">pure = mkTypeTrans0</span></span>
<span class="lineno">  153 </span>  <span class="decl"><span class="nottickedoff">liftA2 f (TypeTrans tps1 f1) (TypeTrans tps2 f2) =</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="nottickedoff">TypeTrans (tps1 ++ tps2)</span>
<span class="lineno">  155 </span><span class="spaces">    </span><span class="nottickedoff">(\ts -&gt; f (f1 $ take (length tps1) ts) (f2 $ drop (length tps1) ts))</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>-- | Build a 'TypeTrans' represented by 0 SAW types
<span class="lineno">  158 </span>mkTypeTrans0 :: tr -&gt; TypeTrans tr
<span class="lineno">  159 </span><span class="decl"><span class="nottickedoff">mkTypeTrans0 tr = TypeTrans [] $ \case</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">[] -&gt; tr</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;mkTypeTrans0: incorrect number of terms&quot;</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>-- | Build a 'TypeTrans' represented by 1 SAW type
<span class="lineno">  164 </span>mkTypeTrans1 :: OpenTerm -&gt; (OpenTerm -&gt; tr) -&gt; TypeTrans tr
<span class="lineno">  165 </span><span class="decl"><span class="nottickedoff">mkTypeTrans1 tp f = TypeTrans [tp] $ \case</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="nottickedoff">[t] -&gt; f t</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;mkTypeTrans1: incorrect number of terms&quot;</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>-- | Build a 'TypeTrans' for an 'OpenTerm' of a given type
<span class="lineno">  170 </span>openTermTypeTrans :: OpenTerm -&gt; TypeTrans OpenTerm
<span class="lineno">  171 </span><span class="decl"><span class="nottickedoff">openTermTypeTrans tp = mkTypeTrans1 tp id</span></span>
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>-- | Build a 'TypeTrans' for a list of 'OpenTerm's of 0 or more types
<span class="lineno">  174 </span>openTermsTypeTrans :: [OpenTerm] -&gt; TypeTrans [OpenTerm]
<span class="lineno">  175 </span><span class="decl"><span class="nottickedoff">openTermsTypeTrans tps = TypeTrans tps id</span></span>
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>-- | Extract out the single SAW type associated with a 'TypeTrans', or the unit
<span class="lineno">  178 </span>-- type if it has 0 SAW types. It is an error if it has 2 or more SAW types.
<span class="lineno">  179 </span>typeTransType1 :: HasCallStack =&gt; TypeTrans tr -&gt; OpenTerm
<span class="lineno">  180 </span><span class="decl"><span class="nottickedoff">typeTransType1 (TypeTrans [] _) = unitTypeOpenTerm</span>
<span class="lineno">  181 </span><span class="spaces"></span><span class="nottickedoff">typeTransType1 (TypeTrans [tp] _) = tp</span>
<span class="lineno">  182 </span><span class="spaces"></span><span class="nottickedoff">typeTransType1 _ =</span>
<span class="lineno">  183 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;typeTransType1&quot; [&quot;found multiple types where at most 1 was expected&quot;]</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>-- | Map the 'typeTransTypes' field of a 'TypeTrans' to a single type, where a
<span class="lineno">  186 </span>-- single type is mapped to itself, an empty list of types is mapped to @unit@,
<span class="lineno">  187 </span>-- and a list of 2 or more types is mapped to a tuple of the types
<span class="lineno">  188 </span>typeTransTupleType :: TypeTrans tr -&gt; OpenTerm
<span class="lineno">  189 </span><span class="decl"><span class="nottickedoff">typeTransTupleType = tupleTypeOpenTerm' . typeTransTypes</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>-- | Convert a 'TypeTrans' over 0 or more types to one over a tuple of those
<span class="lineno">  192 </span>-- types
<span class="lineno">  193 </span>tupleTypeTrans :: TypeTrans tr -&gt; TypeTrans tr
<span class="lineno">  194 </span><span class="decl"><span class="nottickedoff">tupleTypeTrans ttrans =</span>
<span class="lineno">  195 </span><span class="spaces">  </span><span class="nottickedoff">let tps = typeTransTypes ttrans in</span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="nottickedoff">TypeTrans [tupleTypeOpenTerm' tps]</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="nottickedoff">(\case</span>
<span class="lineno">  198 </span><span class="spaces">      </span><span class="nottickedoff">[t] -&gt;</span>
<span class="lineno">  199 </span><span class="spaces">        </span><span class="nottickedoff">let len = fromIntegral $ length tps in</span>
<span class="lineno">  200 </span><span class="spaces">        </span><span class="nottickedoff">typeTransF ttrans $ map (\i -&gt; projTupleOpenTerm' len i t) $</span>
<span class="lineno">  201 </span><span class="spaces">        </span><span class="nottickedoff">take (length tps) [0..]</span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; panic &quot;tupleTypeTrans&quot; [&quot;incorrect number of terms&quot;])</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>-- | Build a type translation for a list of translations
<span class="lineno">  205 </span>listTypeTrans :: [TypeTrans tr] -&gt; TypeTrans [tr]
<span class="lineno">  206 </span><span class="decl"><span class="nottickedoff">listTypeTrans [] = pure []</span>
<span class="lineno">  207 </span><span class="spaces"></span><span class="nottickedoff">listTypeTrans (trans:transs) = App.liftA2 (:) trans $ listTypeTrans transs</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>-- | Tuple all the terms in a list into a single term, or return the empty list
<span class="lineno">  210 </span>-- if the input list is empty
<span class="lineno">  211 </span>tupleOpenTermList :: [OpenTerm] -&gt; [OpenTerm]
<span class="lineno">  212 </span><span class="decl"><span class="nottickedoff">tupleOpenTermList [] = []</span>
<span class="lineno">  213 </span><span class="spaces"></span><span class="nottickedoff">tupleOpenTermList ts = [tupleOpenTerm' ts]</span></span>
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>-- | Tuple all the type descriptions in a list, or return the empty list if the
<span class="lineno">  216 </span>-- input list is empty
<span class="lineno">  217 </span>tupleTpDescList :: [OpenTerm] -&gt; [OpenTerm]
<span class="lineno">  218 </span><span class="decl"><span class="nottickedoff">tupleTpDescList [] = []</span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="nottickedoff">tupleTpDescList ds = [tupleTpDesc ds]</span></span>
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>----------------------------------------------------------------------
<span class="lineno">  223 </span>-- * Expression Translations
<span class="lineno">  224 </span>----------------------------------------------------------------------
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>-- | The result of translating a 'PermExpr' at 'CrucibleType' @a@. This is a
<span class="lineno">  227 </span>-- form of partially static data in the sense of partial evaluation.
<span class="lineno">  228 </span>data ExprTrans (a :: CrucibleType) where
<span class="lineno">  229 </span>  -- | LLVM pointers have their translations dictated by their permissions, so
<span class="lineno">  230 </span>  -- the translations of their expressions have no computational content
<span class="lineno">  231 </span>  ETrans_LLVM :: ExprTrans (LLVMPointerType w)
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>  -- | LLVM blocks also have no computational content
<span class="lineno">  234 </span>  ETrans_LLVMBlock :: ExprTrans (LLVMBlockType w)
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>  -- | Frames also have no computational content
<span class="lineno">  237 </span>  ETrans_LLVMFrame :: ExprTrans (LLVMFrameType w)
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>  -- | Lifetimes also have no computational content
<span class="lineno">  240 </span>  ETrans_Lifetime :: ExprTrans LifetimeType
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>  -- | Read-write modalities also have no computational content
<span class="lineno">  243 </span>  ETrans_RWModality :: ExprTrans RWModalityType
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>  -- | Structs are translated as a sequence of translations of the fields
<span class="lineno">  246 </span>  ETrans_Struct :: ExprTransCtx (CtxToRList ctx) -&gt; ExprTrans (StructType ctx)
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>  -- | The computational content of functions is in their FunPerms, so functions
<span class="lineno">  249 </span>  -- themselves have no computational content
<span class="lineno">  250 </span>  ETrans_Fun :: ExprTrans (FunctionHandleType args ret)
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>  -- | The unit type has no computational content
<span class="lineno">  253 </span>  ETrans_Unit :: ExprTrans UnitType
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>  -- | The translation of Vectors of the Crucible any type have no content
<span class="lineno">  256 </span>  ETrans_AnyVector :: ExprTrans (VectorType AnyType)
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>  -- | The translation of a shape is an optional pair of a type description
<span class="lineno">  259 </span>  -- along with the type it represents, where 'Nothing' represents a shape with
<span class="lineno">  260 </span>  -- no computational content in its translation
<span class="lineno">  261 </span>  ETrans_Shape :: Maybe (OpenTerm, OpenTerm) -&gt; ExprTrans (LLVMShapeType w)
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>  -- | The translation of a permission is a list of 0 or more type descriptions
<span class="lineno">  264 </span>  -- along with the translations to the types they represent, in that order
<span class="lineno">  265 </span>  ETrans_Perm :: [OpenTerm] -&gt; [OpenTerm] -&gt; ExprTrans (ValuePermType a)
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>  -- | The translation for every other expression type is just a SAW term. Note
<span class="lineno">  268 </span>  -- that this construct should not be used for the types handled above.
<span class="lineno">  269 </span>  ETrans_Term :: TypeRepr a -&gt; OpenTerm -&gt; ExprTrans a
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>-- | A context mapping bound names to their type-level SAW translations
<span class="lineno">  272 </span>type ExprTransCtx = RAssign ExprTrans
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | Destruct an 'ExprTrans' of shape type to the optional type description and
<span class="lineno">  276 </span>-- type it represents, in that order
<span class="lineno">  277 </span>unETransShape :: ExprTrans (LLVMShapeType w) -&gt; Maybe (OpenTerm, OpenTerm)
<span class="lineno">  278 </span><span class="decl"><span class="nottickedoff">unETransShape (ETrans_Shape maybe_d_tp) = maybe_d_tp</span>
<span class="lineno">  279 </span><span class="spaces"></span><span class="nottickedoff">unETransShape (ETrans_Term _ _) =</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;unETransShape&quot; [&quot;Incorrect translation of a shape expression&quot;]</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>-- | Destruct an 'ExprTrans' of shape type to a type description type and type
<span class="lineno">  283 </span>-- it represents, using the unit type in place of a 'Nothing'
<span class="lineno">  284 </span>unETransShapeTuple :: ExprTrans (LLVMShapeType w) -&gt; (OpenTerm, OpenTerm)
<span class="lineno">  285 </span><span class="decl"><span class="nottickedoff">unETransShapeTuple =</span>
<span class="lineno">  286 </span><span class="spaces">  </span><span class="nottickedoff">fromMaybe (unitTpDesc, unitTypeOpenTerm) . unETransShape</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>-- | Destruct an 'ExprTrans' of permission type to a list of type descriptions
<span class="lineno">  289 </span>-- and the types they represent, in that order
<span class="lineno">  290 </span>unETransPerm :: ExprTrans (ValuePermType a) -&gt; ([OpenTerm], [OpenTerm])
<span class="lineno">  291 </span><span class="decl"><span class="nottickedoff">unETransPerm (ETrans_Perm ds tps) = (ds, tps)</span>
<span class="lineno">  292 </span><span class="spaces"></span><span class="nottickedoff">unETransPerm (ETrans_Term _ _) =</span>
<span class="lineno">  293 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;unETransPerm&quot; [&quot;Incorrect translation of a shape expression&quot;]</span></span>
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>-- | Describes a Haskell type that represents the translation of a term-like
<span class="lineno">  296 </span>-- construct that corresponds to 0 or more SAW terms
<span class="lineno">  297 </span>class IsTermTrans tr where
<span class="lineno">  298 </span>  transTerms :: HasCallStack =&gt; tr -&gt; [OpenTerm]
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- | Build a tuple of the terms contained in a translation, with 0 terms mapping
<span class="lineno">  301 </span>-- to the unit term and one term mapping to itself. If @ttrans@ is a 'TypeTrans'
<span class="lineno">  302 </span>-- describing the SAW types associated with a @tr@ translation, then this
<span class="lineno">  303 </span>-- function returns an element of the type @'tupleTypeTrans' ttrans@.
<span class="lineno">  304 </span>transTupleTerm :: IsTermTrans tr =&gt; tr -&gt; OpenTerm
<span class="lineno">  305 </span><span class="decl"><span class="nottickedoff">transTupleTerm = tupleOpenTerm' . transTerms</span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>-- | Convert a list of at most 1 SAW core terms to a single term, that is either
<span class="lineno">  308 </span>-- the sole term in the list or the unit value, raising an error if the list has
<span class="lineno">  309 </span>-- more than one term in it
<span class="lineno">  310 </span>termsExpect1 :: [OpenTerm] -&gt; OpenTerm
<span class="lineno">  311 </span><span class="decl"><span class="nottickedoff">termsExpect1 [] = unitOpenTerm</span>
<span class="lineno">  312 </span><span class="spaces"></span><span class="nottickedoff">termsExpect1 [t] = t</span>
<span class="lineno">  313 </span><span class="spaces"></span><span class="nottickedoff">termsExpect1 ts = panic &quot;termsExpect1&quot; [&quot;Expected at most one term, but found &quot;</span>
<span class="lineno">  314 </span><span class="spaces">                                        </span><span class="nottickedoff">++ show (length ts)]</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>-- | Like 'transTupleTerm' but raise an error if there are more than 1 terms
<span class="lineno">  317 </span>transTerm1 :: HasCallStack =&gt; IsTermTrans tr =&gt; tr -&gt; OpenTerm
<span class="lineno">  318 </span><span class="decl"><span class="nottickedoff">transTerm1 = termsExpect1 . transTerms</span></span>
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>instance (IsTermTrans tr1, IsTermTrans tr2) =&gt; IsTermTrans (tr1,tr2) where
<span class="lineno">  321 </span>  <span class="decl"><span class="nottickedoff">transTerms (tr1, tr2) = transTerms tr1 ++ transTerms tr2</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>instance IsTermTrans tr =&gt; IsTermTrans [tr] where
<span class="lineno">  324 </span>  <span class="decl"><span class="nottickedoff">transTerms = concatMap transTerms</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>instance IsTermTrans (TypeTrans tr) where
<span class="lineno">  327 </span>  <span class="decl"><span class="nottickedoff">transTerms = typeTransTypes</span></span>
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>instance IsTermTrans (ExprTrans tp) where
<span class="lineno">  330 </span>  <span class="decl"><span class="nottickedoff">transTerms ETrans_LLVM = []</span>
<span class="lineno">  331 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_LLVMBlock = []</span>
<span class="lineno">  332 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_LLVMFrame = []</span>
<span class="lineno">  333 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_Lifetime = []</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_RWModality = []</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (ETrans_Struct etranss) =</span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="nottickedoff">concat $ RL.mapToList transTerms etranss</span>
<span class="lineno">  337 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_Fun = []</span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_Unit = []</span>
<span class="lineno">  339 </span><span class="spaces">  </span><span class="nottickedoff">transTerms ETrans_AnyVector = []</span>
<span class="lineno">  340 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (ETrans_Shape (Just (d, _))) = [d]</span>
<span class="lineno">  341 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (ETrans_Shape Nothing) = [unitTpDesc]</span>
<span class="lineno">  342 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (ETrans_Perm ds _) = [tupleTpDesc ds]</span>
<span class="lineno">  343 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (ETrans_Term _ t) = [t]</span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>instance IsTermTrans (ExprTransCtx ctx) where
<span class="lineno">  346 </span>  <span class="decl"><span class="nottickedoff">transTerms = concat . RL.mapToList transTerms</span></span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>-- | Map a context of expression translations to a list of 'OpenTerm's
<span class="lineno">  350 </span>exprCtxToTerms :: ExprTransCtx tps -&gt; [OpenTerm]
<span class="lineno">  351 </span><span class="decl"><span class="nottickedoff">exprCtxToTerms = transTerms</span></span>
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>-- | Map an 'ExprTrans' to its type translation
<span class="lineno">  354 </span>exprTransType :: (?ev :: EventType) =&gt; ExprTrans tp -&gt; TypeTrans (ExprTrans tp)
<span class="lineno">  355 </span><span class="decl"><span class="nottickedoff">exprTransType ETrans_LLVM = mkTypeTrans0 ETrans_LLVM</span>
<span class="lineno">  356 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_LLVMBlock = mkTypeTrans0 ETrans_LLVMBlock</span>
<span class="lineno">  357 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_LLVMFrame = mkTypeTrans0 ETrans_LLVMFrame</span>
<span class="lineno">  358 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_Lifetime = mkTypeTrans0  ETrans_Lifetime</span>
<span class="lineno">  359 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_RWModality = mkTypeTrans0 ETrans_RWModality</span>
<span class="lineno">  360 </span><span class="spaces"></span><span class="nottickedoff">exprTransType (ETrans_Struct etranss) = ETrans_Struct &lt;$&gt; exprCtxType etranss</span>
<span class="lineno">  361 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_Fun = mkTypeTrans0 ETrans_Fun</span>
<span class="lineno">  362 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_Unit = mkTypeTrans0 ETrans_Unit</span>
<span class="lineno">  363 </span><span class="spaces"></span><span class="nottickedoff">exprTransType ETrans_AnyVector = mkTypeTrans0 ETrans_AnyVector</span>
<span class="lineno">  364 </span><span class="spaces"></span><span class="nottickedoff">exprTransType (ETrans_Shape _) =</span>
<span class="lineno">  365 </span><span class="spaces">  </span><span class="nottickedoff">mkTypeTrans1 tpDescTypeOpenTerm $ \d -&gt;</span>
<span class="lineno">  366 </span><span class="spaces">  </span><span class="nottickedoff">ETrans_Shape (Just (d, tpElemTypeOpenTerm ?ev d))</span>
<span class="lineno">  367 </span><span class="spaces"></span><span class="nottickedoff">exprTransType (ETrans_Perm _ _) =</span>
<span class="lineno">  368 </span><span class="spaces">  </span><span class="nottickedoff">mkTypeTrans1 tpDescTypeOpenTerm $ \d -&gt;</span>
<span class="lineno">  369 </span><span class="spaces">  </span><span class="nottickedoff">ETrans_Perm [d] [tpElemTypeOpenTerm ?ev d]</span>
<span class="lineno">  370 </span><span class="spaces"></span><span class="nottickedoff">exprTransType (ETrans_Term tp t) =</span>
<span class="lineno">  371 </span><span class="spaces">  </span><span class="nottickedoff">mkTypeTrans1 (openTermType t) (ETrans_Term tp)</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | Map a context of expression translation to a list of the SAW core types of
<span class="lineno">  374 </span>-- all the terms it contains
<span class="lineno">  375 </span>exprCtxType :: (?ev :: EventType) =&gt; ExprTransCtx ctx -&gt;
<span class="lineno">  376 </span>               TypeTrans (ExprTransCtx ctx)
<span class="lineno">  377 </span><span class="decl"><span class="nottickedoff">exprCtxType MNil = mkTypeTrans0 MNil</span>
<span class="lineno">  378 </span><span class="spaces"></span><span class="nottickedoff">exprCtxType (ectx :&gt;: e) = (:&gt;:) &lt;$&gt; exprCtxType ectx &lt;*&gt; exprTransType e</span></span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>-- | Convert an 'ExprTrans' to a list of SAW core terms of type @kindExpr K@,
<span class="lineno">  382 </span>-- one for each kind description @K@ returned by 'translateType' for the type of
<span class="lineno">  383 </span>-- the 'ExprTrans'
<span class="lineno">  384 </span>exprTransDescs :: (?ev :: EventType) =&gt; ExprTrans a -&gt; [OpenTerm]
<span class="lineno">  385 </span><span class="decl"><span class="nottickedoff">exprTransDescs ETrans_LLVM = []</span>
<span class="lineno">  386 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_LLVMBlock = []</span>
<span class="lineno">  387 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_LLVMFrame = []</span>
<span class="lineno">  388 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_Lifetime = []</span>
<span class="lineno">  389 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_RWModality = []</span>
<span class="lineno">  390 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs (ETrans_Struct etranss) =</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="nottickedoff">concat $ RL.mapToList exprTransDescs etranss</span>
<span class="lineno">  392 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_Fun = []</span>
<span class="lineno">  393 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_Unit = []</span>
<span class="lineno">  394 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs ETrans_AnyVector = []</span>
<span class="lineno">  395 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs (ETrans_Shape (Just (d, _))) = [d]</span>
<span class="lineno">  396 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs (ETrans_Shape Nothing) = []</span>
<span class="lineno">  397 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs (ETrans_Perm ds _) = ds</span>
<span class="lineno">  398 </span><span class="spaces"></span><span class="nottickedoff">exprTransDescs (ETrans_Term tp t) =</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="nottickedoff">case translateKindDescs tp of</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="nottickedoff">[d] -&gt; [constKindExpr d t]</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; panic &quot;exprTransDescs&quot; [&quot;ETrans_Term type has incorrect number of kinds&quot;]</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>-- | A \&quot;proof\&quot; that @ctx2@ is an extension of @ctx1@, i.e., that @ctx2@ equals
<span class="lineno">  404 </span>-- @ctx1 :++: ctx3@ for some @ctx3@
<span class="lineno">  405 </span>data CtxExt ctx1 ctx2 where
<span class="lineno">  406 </span>  CtxExt :: RAssign Proxy ctx3 -&gt; CtxExt ctx1 (ctx1 :++: ctx3)
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>-- | Build a context extension proof to an appended context
<span class="lineno">  409 </span>mkCtxExt :: RAssign prx ctx3 -&gt; CtxExt ctx1 (ctx1 :++: ctx3)
<span class="lineno">  410 </span><span class="decl"><span class="nottickedoff">mkCtxExt prxs = CtxExt $ RL.map (const Proxy) prxs</span></span>
<span class="lineno">  411 </span>
<span class="lineno">  412 </span>-- | Reflexivity of 'CtxExt'
<span class="lineno">  413 </span>reflCtxExt :: CtxExt ctx ctx
<span class="lineno">  414 </span><span class="decl"><span class="nottickedoff">reflCtxExt = CtxExt MNil</span></span>
<span class="lineno">  415 </span>
<span class="lineno">  416 </span>-- | Transitively combine two context extensions
<span class="lineno">  417 </span>transCtxExt :: CtxExt ctx1 ctx2 -&gt; CtxExt ctx2 ctx3 -&gt;
<span class="lineno">  418 </span>               CtxExt ctx1 ctx3
<span class="lineno">  419 </span><span class="decl"><span class="nottickedoff">transCtxExt ((CtxExt ectx2') :: CtxExt ctx1 ctx2) (CtxExt ectx3')</span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- RL.appendAssoc (Proxy :: Proxy ctx1) ectx2' ectx3'</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">= CtxExt (RL.append ectx2' ectx3')</span></span>
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>extCtxExt :: Proxy ctx1 -&gt; RAssign Proxy ctx2 -&gt; CtxExt (ctx1 :++: ctx2) ctx3 -&gt;
<span class="lineno">  424 </span>             CtxExt ctx1 ctx3
<span class="lineno">  425 </span><span class="decl"><span class="nottickedoff">extCtxExt ctx1 ctx2 (CtxExt ctx4)</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- RL.appendAssoc ctx1 ctx2 ctx4</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="nottickedoff">= CtxExt (RL.append ctx2 ctx4)</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>ctxExtToExprExt :: CtxExt ctx1 ctx2 -&gt; ExprTransCtx ctx2 -&gt;
<span class="lineno">  430 </span>                   ExprCtxExt ctx1 ctx2
<span class="lineno">  431 </span><span class="decl"><span class="nottickedoff">ctxExtToExprExt ((CtxExt ctx3) :: CtxExt ctx1 ctx2) ectx =</span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="nottickedoff">ExprCtxExt $ snd $ RL.split (Proxy :: Proxy ctx1) ctx3 ectx</span></span>
<span class="lineno">  433 </span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>-- | An extension of expression context @ctx1@ to @ctx2@, which is just an
<span class="lineno">  436 </span>-- 'ExprTransCtx' for the suffix @ctx3@ such that @ctx1:++:ctx3 = ctx2@
<span class="lineno">  437 </span>data ExprCtxExt ctx1 ctx2 where
<span class="lineno">  438 </span>  ExprCtxExt :: ExprTransCtx ctx3 -&gt; ExprCtxExt ctx1 (ctx1 :++: ctx3)
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>-- | The reflexive context extension, proving that any context extends itself
<span class="lineno">  441 </span>reflExprCtxExt :: ExprCtxExt ctx ctx
<span class="lineno">  442 </span><span class="decl"><span class="nottickedoff">reflExprCtxExt = ExprCtxExt MNil</span></span>
<span class="lineno">  443 </span>
<span class="lineno">  444 </span>-- | Transitively combine two context extensions
<span class="lineno">  445 </span>transExprCtxExt :: ExprCtxExt ctx1 ctx2 -&gt; ExprCtxExt ctx2 ctx3 -&gt;
<span class="lineno">  446 </span>                   ExprCtxExt ctx1 ctx3
<span class="lineno">  447 </span><span class="decl"><span class="nottickedoff">transExprCtxExt ((ExprCtxExt ectx2')</span>
<span class="lineno">  448 </span><span class="spaces">                 </span><span class="nottickedoff">:: ExprCtxExt ctx1 ctx2) (ExprCtxExt ectx3')</span>
<span class="lineno">  449 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- RL.appendAssoc (Proxy :: Proxy ctx1) ectx2' ectx3'</span>
<span class="lineno">  450 </span><span class="spaces">  </span><span class="nottickedoff">= ExprCtxExt (RL.append ectx2' ectx3')</span></span>
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>-- | Use any 'RAssign' object to extend a multi-binding
<span class="lineno">  453 </span>extMbAny :: RAssign any ctx2 -&gt; Mb ctx1 a -&gt; Mb (ctx1 :++: ctx2) a
<span class="lineno">  454 </span><span class="decl"><span class="nottickedoff">extMbAny ctx2 = extMbMulti (RL.map (const Proxy) ctx2)</span></span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>-- | Use a 'CtxExt' to extend a multi-binding
<span class="lineno">  457 </span>extMbExt :: ExprCtxExt ctx1 ctx2 -&gt; Mb ctx1 a -&gt; Mb ctx2 a
<span class="lineno">  458 </span><span class="decl"><span class="nottickedoff">extMbExt (ExprCtxExt ctx2) = extMbAny ctx2</span></span>
<span class="lineno">  459 </span>
<span class="lineno">  460 </span>{- FIXME: keeping this in case we need it later
<span class="lineno">  461 </span>-- | Un-extend the left-hand context of an expression context extension
<span class="lineno">  462 </span>extExprCtxExt :: ExprTrans tp -&gt; ExprCtxExt (ctx1 :&gt; tp) ctx2 -&gt;
<span class="lineno">  463 </span>                 ExprCtxExt ctx1 ctx2
<span class="lineno">  464 </span>extExprCtxExt etrans ((ExprCtxExt ctx3) :: ExprCtxExt (ctx1 :&gt; tp) ctx2) =
<span class="lineno">  465 </span>  case RL.appendRNilConsEq (Proxy :: Proxy ctx1) etrans ctx3 of
<span class="lineno">  466 </span>    Refl -&gt; ExprCtxExt (RL.append (MNil :&gt;: etrans) ctx3)
<span class="lineno">  467 </span>-}
<span class="lineno">  468 </span>
<span class="lineno">  469 </span>-- | Use an 'ExprCtxExt' to extend an 'ExprTransCtx'
<span class="lineno">  470 </span>extExprTransCtx :: ExprCtxExt ctx1 ctx2 -&gt; ExprTransCtx ctx1 -&gt;
<span class="lineno">  471 </span>                   ExprTransCtx ctx2
<span class="lineno">  472 </span><span class="decl"><span class="nottickedoff">extExprTransCtx (ExprCtxExt ectx2) ectx1 = RL.append ectx1 ectx2</span></span>
<span class="lineno">  473 </span>
<span class="lineno">  474 </span>-- | Use an 'ExprCtxExt' to \&quot;un-extend\&quot; an 'ExprTransCtx'
<span class="lineno">  475 </span>unextExprTransCtx :: ExprCtxExt ctx1 ctx2 -&gt; ExprTransCtx ctx2 -&gt;
<span class="lineno">  476 </span>                     ExprTransCtx ctx1
<span class="lineno">  477 </span><span class="decl"><span class="nottickedoff">unextExprTransCtx ((ExprCtxExt ectx3) :: ExprCtxExt ctx1 ctx2) ectx2 =</span>
<span class="lineno">  478 </span><span class="spaces">  </span><span class="nottickedoff">fst $ RL.split (Proxy :: Proxy ctx1) ectx3 ectx2</span></span>
<span class="lineno">  479 </span>
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>----------------------------------------------------------------------
<span class="lineno">  482 </span>-- * Translation Monads
<span class="lineno">  483 </span>----------------------------------------------------------------------
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>-- | Class for valid translation info types, which must contain at least a
<span class="lineno">  486 </span>-- context of expression translations
<span class="lineno">  487 </span>class TransInfo info where
<span class="lineno">  488 </span>  infoCtx :: info ctx -&gt; ExprTransCtx ctx
<span class="lineno">  489 </span>  infoEnv :: info ctx -&gt; PermEnv
<span class="lineno">  490 </span>  infoChecksFlag :: info ctx -&gt; ChecksFlag
<span class="lineno">  491 </span>  extTransInfo :: ExprTrans tp -&gt; info ctx -&gt; info (ctx :&gt; tp)
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>-- | A 'TransInfo' that additionally contains a monadic return type for the
<span class="lineno">  494 </span>-- current computation being built, allowing the use of monadic bind
<span class="lineno">  495 </span>class TransInfo info =&gt; TransInfoM info where
<span class="lineno">  496 </span>  infoRetType :: info ctx -&gt; OpenTerm
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | Get the event type stored in a 'TransInfo'
<span class="lineno">  499 </span>infoEvType :: TransInfo info =&gt; info ctx -&gt; EventType
<span class="lineno">  500 </span><span class="decl"><span class="nottickedoff">infoEvType = permEnvEventType . infoEnv</span></span>
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>-- | A \&quot;translation monad\&quot; is a 'Reader' monad with some info type that is
<span class="lineno">  503 </span>-- parameterized by a translation context
<span class="lineno">  504 </span>newtype TransM info (ctx :: RList CrucibleType) a =
<span class="lineno">  505 </span>  TransM { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unTransM</span></span></span> :: Reader (info ctx) a }
<span class="lineno">  506 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">OpenTermLike</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>instance Fail.MonadFail (TransM info ctx) where
<span class="lineno">  509 </span>  <span class="decl"><span class="nottickedoff">fail = error</span></span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>-- | The run function for the 'TransM' monad
<span class="lineno">  512 </span>runTransM :: TransM info ctx a -&gt; info ctx -&gt; a
<span class="lineno">  513 </span><span class="decl"><span class="nottickedoff">runTransM (TransM m) = runReader m</span></span>
<span class="lineno">  514 </span>
<span class="lineno">  515 </span>instance <span class="decl"><span class="nottickedoff">MonadReader (info ctx) (TransM info ctx)</span></span> where
<span class="lineno">  516 </span>  <span class="decl"><span class="nottickedoff">ask = TransM ask</span></span>
<span class="lineno">  517 </span>  <span class="decl"><span class="nottickedoff">local f (TransM m) = TransM $ local f m</span></span>
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>-- | Run a translation computation with a modified info object
<span class="lineno">  520 </span>withInfoM :: (info ctx -&gt; info' ctx') -&gt; TransM info' ctx' a -&gt;
<span class="lineno">  521 </span>             TransM info ctx a
<span class="lineno">  522 </span><span class="decl"><span class="nottickedoff">withInfoM f (TransM m) = TransM $ withReader f m</span></span>
<span class="lineno">  523 </span>
<span class="lineno">  524 </span>-- | Run a translation computation in an extended context
<span class="lineno">  525 </span>inExtTransM :: TransInfo info =&gt; ExprTrans tp -&gt; TransM info (ctx :&gt; tp) a -&gt;
<span class="lineno">  526 </span>               TransM info ctx a
<span class="lineno">  527 </span><span class="decl"><span class="nottickedoff">inExtTransM etrans (TransM m) = TransM $ withReader (extTransInfo etrans) m</span></span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>-- | Run a translation computation in a context extended with multiple types
<span class="lineno">  530 </span>inExtMultiTransM :: TransInfo info =&gt; ExprTransCtx ctx2 -&gt;
<span class="lineno">  531 </span>                    TransM info (ctx :++: ctx2) a -&gt;
<span class="lineno">  532 </span>                    TransM info ctx a
<span class="lineno">  533 </span><span class="decl"><span class="nottickedoff">inExtMultiTransM MNil m = m</span>
<span class="lineno">  534 </span><span class="spaces"></span><span class="nottickedoff">inExtMultiTransM (ctx :&gt;: etrans) m =</span>
<span class="lineno">  535 </span><span class="spaces">  </span><span class="nottickedoff">inExtMultiTransM ctx $ inExtTransM etrans m</span></span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>-- | Build a @sawLet@-binding in a translation monad that binds a pure variable
<span class="lineno">  538 </span>sawLetTransM :: String -&gt; OpenTerm -&gt; OpenTerm -&gt; OpenTerm -&gt;
<span class="lineno">  539 </span>                (OpenTerm -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  540 </span>                TransM info ctx OpenTerm
<span class="lineno">  541 </span><span class="decl"><span class="nottickedoff">sawLetTransM x tp tp_ret rhs body_m =</span>
<span class="lineno">  542 </span><span class="spaces">  </span><span class="nottickedoff">do r &lt;- ask</span>
<span class="lineno">  543 </span><span class="spaces">     </span><span class="nottickedoff">return $</span>
<span class="lineno">  544 </span><span class="spaces">       </span><span class="nottickedoff">sawLetOpenTerm (pack x) tp tp_ret rhs $ \x' -&gt;</span>
<span class="lineno">  545 </span><span class="spaces">       </span><span class="nottickedoff">runTransM (body_m x') r</span></span>
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>-- | Build 0 or more sawLet-bindings in a translation monad, using the same
<span class="lineno">  548 </span>-- variable name
<span class="lineno">  549 </span>sawLetTransMultiM :: String -&gt; [OpenTerm] -&gt; OpenTerm -&gt; [OpenTerm] -&gt;
<span class="lineno">  550 </span>                     ([OpenTerm] -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  551 </span>                     TransM info ctx OpenTerm
<span class="lineno">  552 </span><span class="decl"><span class="nottickedoff">sawLetTransMultiM _ [] _ [] f = f []</span>
<span class="lineno">  553 </span><span class="spaces"></span><span class="nottickedoff">sawLetTransMultiM x (tp:tps) ret_tp (rhs:rhss) f =</span>
<span class="lineno">  554 </span><span class="spaces">  </span><span class="nottickedoff">sawLetTransM x tp ret_tp rhs $ \var_tm -&gt;</span>
<span class="lineno">  555 </span><span class="spaces">  </span><span class="nottickedoff">sawLetTransMultiM x tps ret_tp rhss (\var_tms -&gt; f (var_tm:var_tms))</span>
<span class="lineno">  556 </span><span class="spaces"></span><span class="nottickedoff">sawLetTransMultiM _ _ _ _ _ =</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;sawLetTransMultiM&quot; [&quot;numbers of types and right-hand sides disagree&quot;]</span></span>
<span class="lineno">  558 </span>
<span class="lineno">  559 </span>-- | Run a translation computation in an extended context, where we sawLet-bind any
<span class="lineno">  560 </span>-- term in the supplied expression translation
<span class="lineno">  561 </span>inExtTransSAWLetBindM :: TransInfo info =&gt; TypeTrans (ExprTrans tp) -&gt;
<span class="lineno">  562 </span>                         OpenTerm -&gt; ExprTrans tp -&gt;
<span class="lineno">  563 </span>                         TransM info (ctx :&gt; tp) OpenTerm -&gt;
<span class="lineno">  564 </span>                         TransM info ctx OpenTerm
<span class="lineno">  565 </span><span class="decl"><span class="nottickedoff">inExtTransSAWLetBindM tp_trans tp_ret etrans m =</span>
<span class="lineno">  566 </span><span class="spaces">  </span><span class="nottickedoff">sawLetTransMultiM &quot;z&quot; (map openTermLike $</span>
<span class="lineno">  567 </span><span class="spaces">                         </span><span class="nottickedoff">typeTransTypes tp_trans) tp_ret (transTerms etrans) $</span>
<span class="lineno">  568 </span><span class="spaces">  </span><span class="nottickedoff">\var_tms -&gt; inExtTransM (typeTransF tp_trans var_tms) m</span></span>
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>-- | Run a translation computation in context @(ctx1 :++: ctx2) :++: ctx2@ by
<span class="lineno">  571 </span>-- copying the @ctx2@ portion of the current context
<span class="lineno">  572 </span>inExtMultiTransCopyLastM :: TransInfo info =&gt; prx ctx1 -&gt; RAssign any ctx2 -&gt;
<span class="lineno">  573 </span>                            TransM info ((ctx1 :++: ctx2) :++: ctx2) a -&gt;
<span class="lineno">  574 </span>                            TransM info (ctx1 :++: ctx2) a
<span class="lineno">  575 </span><span class="decl"><span class="nottickedoff">inExtMultiTransCopyLastM ctx1 ctx2 m =</span>
<span class="lineno">  576 </span><span class="spaces">  </span><span class="nottickedoff">do ectx &lt;- infoCtx &lt;$&gt; ask</span>
<span class="lineno">  577 </span><span class="spaces">     </span><span class="nottickedoff">let (_,ectx2) = RL.split ctx1 ctx2 ectx</span>
<span class="lineno">  578 </span><span class="spaces">     </span><span class="nottickedoff">inExtMultiTransM ectx2 m</span></span>
<span class="lineno">  579 </span>
<span class="lineno">  580 </span>-- | Run a translation computation in a specific context
<span class="lineno">  581 </span>inCtxTransM :: TransInfo info =&gt; ExprTransCtx ctx -&gt;
<span class="lineno">  582 </span>               TransM info ctx a -&gt; TransM info RNil a
<span class="lineno">  583 </span><span class="decl"><span class="nottickedoff">inCtxTransM MNil m = m</span>
<span class="lineno">  584 </span><span class="spaces"></span><span class="nottickedoff">inCtxTransM (ctx :&gt;: etrans) m = inCtxTransM ctx $ inExtTransM etrans m</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>-- | Build a multi-binding for the current context
<span class="lineno">  587 </span>nuMultiTransM :: TransInfo info =&gt; (RAssign Name ctx -&gt; b) -&gt;
<span class="lineno">  588 </span>                 TransM info ctx (Mb ctx b)
<span class="lineno">  589 </span><span class="decl"><span class="nottickedoff">nuMultiTransM f =</span>
<span class="lineno">  590 </span><span class="spaces">  </span><span class="nottickedoff">do info &lt;- ask</span>
<span class="lineno">  591 </span><span class="spaces">     </span><span class="nottickedoff">return $ nuMulti (RL.map (\_ -&gt; Proxy) (infoCtx info)) f</span></span>
<span class="lineno">  592 </span>
<span class="lineno">  593 </span>-- | Apply the result of a translation to that of another
<span class="lineno">  594 </span>applyTransM :: TransM info ctx OpenTerm -&gt; TransM info ctx OpenTerm -&gt;
<span class="lineno">  595 </span>               TransM info ctx OpenTerm
<span class="lineno">  596 </span><span class="decl"><span class="nottickedoff">applyTransM m1 m2 = applyOpenTerm &lt;$&gt; m1 &lt;*&gt; m2</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>-- | Apply the result of a translation to the results of multiple translations
<span class="lineno">  599 </span>applyMultiTransM :: TransM info ctx OpenTerm -&gt;
<span class="lineno">  600 </span>                    [TransM info ctx OpenTerm] -&gt;
<span class="lineno">  601 </span>                    TransM info ctx OpenTerm
<span class="lineno">  602 </span><span class="decl"><span class="nottickedoff">applyMultiTransM m ms = foldl applyTransM m ms</span></span>
<span class="lineno">  603 </span>
<span class="lineno">  604 </span>-- | Apply an identifier to the results of multiple translations
<span class="lineno">  605 </span>applyGlobalTransM :: Ident -&gt; [TransM info ctx OpenTerm] -&gt;
<span class="lineno">  606 </span>                     TransM info ctx OpenTerm
<span class="lineno">  607 </span><span class="decl"><span class="nottickedoff">applyGlobalTransM ident ms = applyGlobalOpenTerm ident &lt;$&gt; sequence ms</span></span>
<span class="lineno">  608 </span>
<span class="lineno">  609 </span>-- | Build a nested lambda-abstraction
<span class="lineno">  610 </span>--
<span class="lineno">  611 </span>-- &gt; \x1:tp1 -&gt; ... -&gt; \xn:tpn -&gt; body
<span class="lineno">  612 </span>--
<span class="lineno">  613 </span>-- over the types in a 'TypeTrans', using the 'String' as a variable name prefix
<span class="lineno">  614 </span>-- for the @xi@ variables
<span class="lineno">  615 </span>lambdaTrans :: String -&gt; TypeTrans tr -&gt; (tr -&gt; OpenTerm) -&gt; OpenTerm
<span class="lineno">  616 </span><span class="decl"><span class="nottickedoff">lambdaTrans x (TypeTrans tps tr_f) body_f =</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="nottickedoff">lambdaOpenTermMulti</span>
<span class="lineno">  618 </span><span class="spaces">  </span><span class="nottickedoff">(zipWith (\i tp -&gt; (pack (x ++ show (i :: Integer)), tp)) [0..] tps)</span>
<span class="lineno">  619 </span><span class="spaces">  </span><span class="nottickedoff">(body_f . tr_f)</span></span>
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>-- | Build a nested lambda-abstraction
<span class="lineno">  622 </span>--
<span class="lineno">  623 </span>-- &gt; \x1:tp1 -&gt; ... -&gt; \xn:tpn -&gt; body
<span class="lineno">  624 </span>--
<span class="lineno">  625 </span>-- over the types in a 'TypeTrans' inside a translation monad, using the
<span class="lineno">  626 </span>-- 'String' as a variable name prefix for the @xi@ variables
<span class="lineno">  627 </span>lambdaTransM :: String -&gt; TypeTrans tr -&gt; (tr -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  628 </span>                TransM info ctx OpenTerm
<span class="lineno">  629 </span><span class="decl"><span class="nottickedoff">lambdaTransM x tp body_f =</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \info -&gt; return (lambdaTrans x tp (flip runTransM info . body_f))</span></span>
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>-- | Build a lambda-abstraction
<span class="lineno">  633 </span>--
<span class="lineno">  634 </span>-- &gt; \x1:(tp1, ..., tpn) -&gt; body
<span class="lineno">  635 </span>--
<span class="lineno">  636 </span>-- over a tuple of the types in a 'TypeTrans'. Note that this always builds
<span class="lineno">  637 </span>-- exactly one lambda-abstraction, even if there are 0 types.
<span class="lineno">  638 </span>lambdaTupleTransM :: String -&gt; TypeTrans tr -&gt; (tr -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  639 </span>                     TransM info ctx OpenTerm
<span class="lineno">  640 </span><span class="decl"><span class="nottickedoff">lambdaTupleTransM x ttrans body_f =</span>
<span class="lineno">  641 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTransM x (tupleTypeTrans ttrans) body_f</span></span>
<span class="lineno">  642 </span>
<span class="lineno">  643 </span>-- | Build a pi-abstraction over the types in a 'TypeTrans' inside a
<span class="lineno">  644 </span>-- translation monad, using the 'String' as a variable name prefix
<span class="lineno">  645 </span>piTransM :: String -&gt; TypeTrans tr -&gt; (tr -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  646 </span>            TransM info ctx OpenTerm
<span class="lineno">  647 </span><span class="decl"><span class="nottickedoff">piTransM x tps body_f =</span>
<span class="lineno">  648 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \info -&gt;</span>
<span class="lineno">  649 </span><span class="spaces">  </span><span class="nottickedoff">return (piOpenTermMulti</span>
<span class="lineno">  650 </span><span class="spaces">          </span><span class="nottickedoff">(zipWith (\i tp -&gt; (pack (x ++ show (i :: Integer)), tp))</span>
<span class="lineno">  651 </span><span class="spaces">           </span><span class="nottickedoff">[0..] (typeTransTypes tps))</span>
<span class="lineno">  652 </span><span class="spaces">          </span><span class="nottickedoff">(\ts -&gt; runTransM (body_f $ typeTransF tps ts) info))</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>{-
<span class="lineno">  655 </span>-- | Build a pi-abstraction inside the 'TransM' monad
<span class="lineno">  656 </span>piOpenTermTransM :: String -&gt; OpenTerm -&gt;
<span class="lineno">  657 </span>                    (OpenTerm -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  658 </span>                    TransM info ctx OpenTerm
<span class="lineno">  659 </span>piOpenTermTransM x tp body_f =
<span class="lineno">  660 </span>  ask &gt;&gt;= \info -&gt;
<span class="lineno">  661 </span>  return (piOpenTerm (pack x) tp $ \t -&gt; runTransM (body_f t) info)
<span class="lineno">  662 </span>-}
<span class="lineno">  663 </span>
<span class="lineno">  664 </span>-- | Build a let-binding in a translation monad
<span class="lineno">  665 </span>letTransM :: String -&gt; OpenTerm -&gt; TransM info ctx OpenTerm -&gt;
<span class="lineno">  666 </span>             (OpenTerm -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  667 </span>             TransM info ctx OpenTerm
<span class="lineno">  668 </span><span class="decl"><span class="nottickedoff">letTransM x tp rhs_m body_m =</span>
<span class="lineno">  669 </span><span class="spaces">  </span><span class="nottickedoff">do r &lt;- ask</span>
<span class="lineno">  670 </span><span class="spaces">     </span><span class="nottickedoff">return $</span>
<span class="lineno">  671 </span><span class="spaces">       </span><span class="nottickedoff">letOpenTerm (pack x) tp (runTransM rhs_m r) $ \x' -&gt;</span>
<span class="lineno">  672 </span><span class="spaces">       </span><span class="nottickedoff">runTransM (body_m x') r</span></span>
<span class="lineno">  673 </span>
<span class="lineno">  674 </span>-- | Build a bitvector type in a translation monad
<span class="lineno">  675 </span>bitvectorTransM :: TransM info ctx OpenTerm -&gt; TransM info ctx OpenTerm
<span class="lineno">  676 </span><span class="decl"><span class="nottickedoff">bitvectorTransM m = bitvectorTypeOpenTerm &lt;$&gt; m</span></span>
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>-- | Build an @Either@ type in SAW from the 'typeTransTupleType's of the left
<span class="lineno">  679 </span>-- and right types
<span class="lineno">  680 </span>eitherTypeTrans :: TypeTrans trL -&gt; TypeTrans trR -&gt; OpenTerm
<span class="lineno">  681 </span><span class="decl"><span class="nottickedoff">eitherTypeTrans tp_l tp_r =</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="nottickedoff">eitherTypeOpenTerm (typeTransTupleType tp_l) (typeTransTupleType tp_r)</span></span>
<span class="lineno">  683 </span>
<span class="lineno">  684 </span>-- | Apply the @Left@ constructor of the @Either@ type in SAW to the
<span class="lineno">  685 </span>-- 'transTupleTerm' of the input
<span class="lineno">  686 </span>leftTrans :: TypeTrans trL -&gt; TypeTrans trR -&gt; OpenTerm -&gt; OpenTerm
<span class="lineno">  687 </span><span class="decl"><span class="nottickedoff">leftTrans tp_l tp_r t =</span>
<span class="lineno">  688 </span><span class="spaces">  </span><span class="nottickedoff">ctorOpenTerm &quot;Prelude.Left&quot; [typeTransTupleType tp_l,</span>
<span class="lineno">  689 </span><span class="spaces">                               </span><span class="nottickedoff">typeTransTupleType tp_r, t]</span></span>
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>-- | Apply the @Right@ constructor of the @Either@ type in SAW to the
<span class="lineno">  692 </span>-- 'transTupleTerm' of the input
<span class="lineno">  693 </span>rightTrans :: TypeTrans trL -&gt; TypeTrans trR -&gt; OpenTerm -&gt; OpenTerm
<span class="lineno">  694 </span><span class="decl"><span class="nottickedoff">rightTrans tp_l tp_r t =</span>
<span class="lineno">  695 </span><span class="spaces">  </span><span class="nottickedoff">ctorOpenTerm &quot;Prelude.Right&quot; [typeTransTupleType tp_l,</span>
<span class="lineno">  696 </span><span class="spaces">                                </span><span class="nottickedoff">typeTransTupleType tp_r, t]</span></span>
<span class="lineno">  697 </span>
<span class="lineno">  698 </span>-- | Eliminate a SAW @Either@ type
<span class="lineno">  699 </span>eitherElimTransM :: TypeTrans trL -&gt; TypeTrans trR -&gt;
<span class="lineno">  700 </span>                    TypeTrans tr -&gt; (trL -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  701 </span>                    (trR -&gt; TransM info ctx OpenTerm) -&gt; OpenTerm -&gt;
<span class="lineno">  702 </span>                    TransM info ctx OpenTerm
<span class="lineno">  703 </span><span class="decl"><span class="nottickedoff">eitherElimTransM tp_l tp_r tp_ret fl fr eith =</span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="nottickedoff">do fl_trans &lt;- lambdaTupleTransM &quot;x_left&quot; tp_l fl</span>
<span class="lineno">  705 </span><span class="spaces">     </span><span class="nottickedoff">fr_trans &lt;- lambdaTupleTransM &quot;x_right&quot; tp_r fr</span>
<span class="lineno">  706 </span><span class="spaces">     </span><span class="nottickedoff">return $ applyGlobalOpenTerm &quot;Prelude.either&quot;</span>
<span class="lineno">  707 </span><span class="spaces">       </span><span class="nottickedoff">[ typeTransTupleType tp_l, typeTransTupleType tp_r,</span>
<span class="lineno">  708 </span><span class="spaces">         </span><span class="nottickedoff">typeTransTupleType tp_ret, fl_trans, fr_trans, eith ]</span></span>
<span class="lineno">  709 </span>
<span class="lineno">  710 </span>-- | Eliminate a multi-way SAW @Eithers@ type, taking in: a list of the
<span class="lineno">  711 </span>-- translations of the types in the @Eithers@ type; the translation of the
<span class="lineno">  712 </span>-- output type; a list of functions for the branches of the @Eithers@
<span class="lineno">  713 </span>-- elimination; and the term of @Eithers@ type being eliminated
<span class="lineno">  714 </span>eithersElimTransM :: [TypeTrans tr_in] -&gt; TypeTrans tr_out -&gt;
<span class="lineno">  715 </span>                     [tr_in -&gt; TransM info ctx OpenTerm] -&gt; OpenTerm -&gt;
<span class="lineno">  716 </span>                     TransM info ctx OpenTerm
<span class="lineno">  717 </span><span class="decl"><span class="nottickedoff">eithersElimTransM tps tp_ret fs eith =</span>
<span class="lineno">  718 </span><span class="spaces">  </span><span class="nottickedoff">foldr (\(tp,f) restM -&gt;</span>
<span class="lineno">  719 </span><span class="spaces">          </span><span class="nottickedoff">do f_trans &lt;- lambdaTupleTransM &quot;x_eith_elim&quot; tp f</span>
<span class="lineno">  720 </span><span class="spaces">             </span><span class="nottickedoff">rest &lt;- restM</span>
<span class="lineno">  721 </span><span class="spaces">             </span><span class="nottickedoff">return (ctorOpenTerm &quot;Prelude.FunsTo_Cons&quot;</span>
<span class="lineno">  722 </span><span class="spaces">                     </span><span class="nottickedoff">[typeTransTupleType tp_ret,</span>
<span class="lineno">  723 </span><span class="spaces">                      </span><span class="nottickedoff">typeTransTupleType tp, f_trans, rest]))</span>
<span class="lineno">  724 </span><span class="spaces">  </span><span class="nottickedoff">(return $ ctorOpenTerm &quot;Prelude.FunsTo_Nil&quot; [typeTransTupleType tp_ret])</span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="nottickedoff">(zip tps fs)</span>
<span class="lineno">  726 </span><span class="spaces">  </span><span class="nottickedoff">&gt;&gt;= \elims_trans -&gt;</span>
<span class="lineno">  727 </span><span class="spaces">  </span><span class="nottickedoff">return (applyGlobalOpenTerm &quot;Prelude.eithers&quot;</span>
<span class="lineno">  728 </span><span class="spaces">          </span><span class="nottickedoff">[typeTransTupleType tp_ret, elims_trans, eith])</span></span>
<span class="lineno">  729 </span>
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>-- | Build the right-nested dependent pair type whose sequence of left-hand
<span class="lineno">  732 </span>-- projections have the types of the supplied 'TypeTrans' and whose right-hand
<span class="lineno">  733 </span>-- projection is the 'typeTransTupleType' of the supplied monadic function
<span class="lineno">  734 </span>sigmaTypeTransM :: LocalName -&gt; TypeTrans trL -&gt;
<span class="lineno">  735 </span>                   (trL -&gt; TransM info ctx (TypeTrans trR)) -&gt;
<span class="lineno">  736 </span>                   TransM info ctx OpenTerm
<span class="lineno">  737 </span><span class="decl"><span class="nottickedoff">sigmaTypeTransM x tptrans tp_f =</span>
<span class="lineno">  738 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \info -&gt;</span>
<span class="lineno">  739 </span><span class="spaces">  </span><span class="nottickedoff">return (sigmaTypeOpenTermMulti x (typeTransTypes tptrans)</span>
<span class="lineno">  740 </span><span class="spaces">          </span><span class="nottickedoff">(typeTransTupleType . flip runTransM info . tp_f . typeTransF tptrans))</span></span>
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>-- | Like 'sigmaTypeTransM', but translates @exists x.eq(y)@ into the tuple of
<span class="lineno">  743 </span>-- types of @x@, omitting the right-hand projection type
<span class="lineno">  744 </span>sigmaTypePermTransM :: TransInfo info =&gt; LocalName -&gt;
<span class="lineno">  745 </span>                       TypeTrans (ExprTrans trL) -&gt;
<span class="lineno">  746 </span>                       Mb (ctx :&gt; trL) (ValuePerm trR) -&gt;
<span class="lineno">  747 </span>                       TransM info ctx OpenTerm
<span class="lineno">  748 </span><span class="decl"><span class="nottickedoff">sigmaTypePermTransM x ttrans mb_p = case mbMatch mb_p of</span>
<span class="lineno">  749 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| ValPerm_Eq _ |] -&gt; return $ typeTransTupleType ttrans</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno">  751 </span><span class="spaces">    </span><span class="nottickedoff">sigmaTypeTransM x ttrans $ \etrans -&gt;</span>
<span class="lineno">  752 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM etrans (translate mb_p)</span></span>
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>-- | Build a nested dependent pair of the type returned by 'sigmaTypeTransM'.
<span class="lineno">  755 </span>-- Note that the 'TypeTrans' returned by the type-level function will in general
<span class="lineno">  756 </span>-- be in a larger context than that of the right-hand projection argument, so we
<span class="lineno">  757 </span>-- allow the representation types to be different to accommodate for this.
<span class="lineno">  758 </span>sigmaTransM :: (IsTermTrans trL, IsTermTrans trR2) =&gt;
<span class="lineno">  759 </span>               LocalName -&gt; TypeTrans trL -&gt;
<span class="lineno">  760 </span>               (trL -&gt; TransM info ctx (TypeTrans trR1)) -&gt;
<span class="lineno">  761 </span>               trL -&gt; TransM info ctx trR2 -&gt;
<span class="lineno">  762 </span>               TransM info ctx OpenTerm
<span class="lineno">  763 </span><span class="decl"><span class="nottickedoff">sigmaTransM _ (typeTransTypes -&gt; []) _ _ rhs_m = transTupleTerm &lt;$&gt; rhs_m</span>
<span class="lineno">  764 </span><span class="spaces"></span><span class="nottickedoff">sigmaTransM x tp_l tp_r lhs rhs_m =</span>
<span class="lineno">  765 </span><span class="spaces">  </span><span class="nottickedoff">do info &lt;- ask</span>
<span class="lineno">  766 </span><span class="spaces">     </span><span class="nottickedoff">rhs &lt;- rhs_m</span>
<span class="lineno">  767 </span><span class="spaces">     </span><span class="nottickedoff">return (sigmaOpenTermMulti x (typeTransTypes tp_l)</span>
<span class="lineno">  768 </span><span class="spaces">             </span><span class="nottickedoff">(typeTransTupleType . flip runTransM info . tp_r . typeTransF tp_l)</span>
<span class="lineno">  769 </span><span class="spaces">             </span><span class="nottickedoff">(transTerms lhs)</span>
<span class="lineno">  770 </span><span class="spaces">             </span><span class="nottickedoff">(transTupleTerm rhs))</span></span>
<span class="lineno">  771 </span>
<span class="lineno">  772 </span>-- | Like `sigmaTransM`, but translates `exists x.eq(y)` into just `x`
<span class="lineno">  773 </span>sigmaPermTransM :: (TransInfo info, IsTermTrans trR2) =&gt;
<span class="lineno">  774 </span>                   LocalName -&gt; TypeTrans (ExprTrans trL) -&gt;
<span class="lineno">  775 </span>                   Mb (ctx :&gt; trL) (ValuePerm trR1) -&gt;
<span class="lineno">  776 </span>                   ExprTrans trL -&gt; TransM info ctx trR2 -&gt;
<span class="lineno">  777 </span>                   TransM info ctx OpenTerm
<span class="lineno">  778 </span><span class="decl"><span class="nottickedoff">sigmaPermTransM x ttrans mb_p etrans rhs_m = case mbMatch mb_p of</span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| ValPerm_Eq _ |] -&gt; return $ transTupleTerm etrans</span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; sigmaTransM x ttrans (flip inExtTransM $ translate mb_p) etrans rhs_m</span></span>
<span class="lineno">  781 </span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>-- | Eliminate a dependent pair of the type returned by 'sigmaTypeTransM'
<span class="lineno">  784 </span>sigmaElimTransM :: LocalName -&gt; TypeTrans trL -&gt;
<span class="lineno">  785 </span>                   (trL -&gt; TransM info ctx (TypeTrans trR)) -&gt;
<span class="lineno">  786 </span>                   TransM info ctx (TypeTrans trRet) -&gt;
<span class="lineno">  787 </span>                   (trL -&gt; trR -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  788 </span>                   OpenTerm -&gt;
<span class="lineno">  789 </span>                   TransM info ctx OpenTerm
<span class="lineno">  790 </span><span class="decl"><span class="nottickedoff">sigmaElimTransM _ tp_l@(typeTransTypes -&gt; []) tp_r _ f sigma =</span>
<span class="lineno">  791 </span><span class="spaces">  </span><span class="nottickedoff">do let proj_l = typeTransF tp_l []</span>
<span class="lineno">  792 </span><span class="spaces">     </span><span class="nottickedoff">proj_r &lt;- flip (typeTransF . tupleTypeTrans) [sigma] &lt;$&gt; tp_r proj_l</span>
<span class="lineno">  793 </span><span class="spaces">     </span><span class="nottickedoff">f proj_l proj_r</span>
<span class="lineno">  794 </span><span class="spaces"></span><span class="nottickedoff">sigmaElimTransM x tp_l tp_r_mF _tp_ret_m f sigma =</span>
<span class="lineno">  795 </span><span class="spaces">  </span><span class="nottickedoff">do info &lt;- ask</span>
<span class="lineno">  796 </span><span class="spaces">     </span><span class="nottickedoff">let tp_r_f = flip runTransM info . tp_r_mF . typeTransF tp_l</span>
<span class="lineno">  797 </span><span class="spaces">     </span><span class="nottickedoff">return $</span>
<span class="lineno">  798 </span><span class="spaces">       </span><span class="nottickedoff">sigmaElimOpenTermMulti x (typeTransTypes tp_l)</span>
<span class="lineno">  799 </span><span class="spaces">       </span><span class="nottickedoff">(typeTransTupleType . tp_r_f)</span>
<span class="lineno">  800 </span><span class="spaces">       </span><span class="nottickedoff">sigma</span>
<span class="lineno">  801 </span><span class="spaces">       </span><span class="nottickedoff">(\ts -&gt; let (ts_l, ts_r) = splitAt (length (typeTransTypes tp_l)) ts</span>
<span class="lineno">  802 </span><span class="spaces">                   </span><span class="nottickedoff">trL = typeTransF tp_l ts_l</span>
<span class="lineno">  803 </span><span class="spaces">                   </span><span class="nottickedoff">tp_r = tupleTypeTrans $ tp_r_f ts_l in</span>
<span class="lineno">  804 </span><span class="spaces">               </span><span class="nottickedoff">flip runTransM info $ f trL (typeTransF tp_r ts_r))</span></span>
<span class="lineno">  805 </span>
<span class="lineno">  806 </span>
<span class="lineno">  807 </span>-- | Like `sigmaElimTransM`, but translates `exists x.eq(y)` into just `x`
<span class="lineno">  808 </span>sigmaElimPermTransM :: (TransInfo info) =&gt;
<span class="lineno">  809 </span>                       LocalName -&gt; TypeTrans (ExprTrans trL) -&gt;
<span class="lineno">  810 </span>                       Mb (ctx :&gt; trL) (ValuePerm trR) -&gt;
<span class="lineno">  811 </span>                       TransM info ctx (TypeTrans trRet) -&gt;
<span class="lineno">  812 </span>                       (ExprTrans trL -&gt; PermTrans (ctx :&gt; trL) trR -&gt;
<span class="lineno">  813 </span>                                         TransM info ctx OpenTerm) -&gt;
<span class="lineno">  814 </span>                       OpenTerm -&gt;
<span class="lineno">  815 </span>                       TransM info ctx OpenTerm
<span class="lineno">  816 </span><span class="decl"><span class="nottickedoff">sigmaElimPermTransM x tp_l mb_p tp_ret_m f sigma = case mbMatch mb_p of</span>
<span class="lineno">  817 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| ValPerm_Eq e |] -&gt;</span>
<span class="lineno">  818 </span><span class="spaces">    </span><span class="nottickedoff">f (typeTransF (tupleTypeTrans tp_l) [sigma]) (PTrans_Eq e)</span>
<span class="lineno">  819 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno">  820 </span><span class="spaces">    </span><span class="nottickedoff">sigmaElimTransM x tp_l (flip inExtTransM $ translate mb_p) tp_ret_m f sigma</span></span>
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>-- FIXME: consider using applyEventOpM and friends in the translation below
<span class="lineno">  823 </span>
<span class="lineno">  824 </span>-- | Apply an 'OpenTerm' to the current event type @E@ and to a
<span class="lineno">  825 </span>-- list of other arguments
<span class="lineno">  826 </span>applyEventOpM :: TransInfo info =&gt; OpenTerm -&gt; [OpenTerm] -&gt;
<span class="lineno">  827 </span>                 TransM info ctx OpenTerm
<span class="lineno">  828 </span><span class="decl"><span class="nottickedoff">applyEventOpM f args =</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="nottickedoff">do evType &lt;- evTypeTerm &lt;$&gt; infoEvType &lt;$&gt; ask</span>
<span class="lineno">  830 </span><span class="spaces">     </span><span class="nottickedoff">return $ applyOpenTermMulti f (evType : args)</span></span>
<span class="lineno">  831 </span>
<span class="lineno">  832 </span>-- | Apply a named operator to the current event type @E@ and to a list of other
<span class="lineno">  833 </span>-- arguments
<span class="lineno">  834 </span>applyNamedEventOpM :: TransInfo info =&gt; Ident -&gt; [OpenTerm] -&gt;
<span class="lineno">  835 </span>                      TransM info ctx OpenTerm
<span class="lineno">  836 </span><span class="decl"><span class="nottickedoff">applyNamedEventOpM f args = applyEventOpM (globalOpenTerm f) args</span></span>
<span class="lineno">  837 </span>
<span class="lineno">  838 </span>-- | The current non-monadic return type
<span class="lineno">  839 </span>returnTypeM :: TransInfoM info =&gt; TransM info ctx OpenTerm
<span class="lineno">  840 </span><span class="decl"><span class="nottickedoff">returnTypeM = infoRetType &lt;$&gt; ask</span></span>
<span class="lineno">  841 </span>
<span class="lineno">  842 </span>-- | Build the monadic return type @SpecM E ret@, where @ret@ is the current
<span class="lineno">  843 </span>-- return type in 'itiReturnType'
<span class="lineno">  844 </span>compReturnTypeM :: TransInfoM info =&gt; TransM info ctx OpenTerm
<span class="lineno">  845 </span><span class="decl"><span class="nottickedoff">compReturnTypeM =</span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno">  847 </span><span class="spaces">     </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno">  848 </span><span class="spaces">     </span><span class="nottickedoff">return $ specMTypeOpenTerm ev ret_tp</span></span>
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>-- | Like 'compReturnTypeM' but build a 'TypeTrans'
<span class="lineno">  851 </span>compReturnTypeTransM :: TransInfoM info =&gt; TransM info ctx (TypeTrans OpenTerm)
<span class="lineno">  852 </span><span class="decl"><span class="nottickedoff">compReturnTypeTransM = openTermTypeTrans &lt;$&gt; compReturnTypeM</span></span>
<span class="lineno">  853 </span>
<span class="lineno">  854 </span>-- | Build a term @bindS m k@ with the given @m@ of type @m_tp@ and where @k@
<span class="lineno">  855 </span>-- is build as a lambda with the given variable name and body
<span class="lineno">  856 </span>bindTransM :: TransInfoM info =&gt; OpenTerm -&gt; TypeTrans tr -&gt; String -&gt;
<span class="lineno">  857 </span>              (tr -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno">  858 </span>              TransM info ctx OpenTerm
<span class="lineno">  859 </span><span class="decl"><span class="nottickedoff">bindTransM m m_tptrans str f =</span>
<span class="lineno">  860 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno">  861 </span><span class="spaces">     </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno">  862 </span><span class="spaces">     </span><span class="nottickedoff">k_tm &lt;- lambdaTupleTransM str m_tptrans f</span>
<span class="lineno">  863 </span><span class="spaces">     </span><span class="nottickedoff">let m_tp = typeTransTupleType m_tptrans</span>
<span class="lineno">  864 </span><span class="spaces">     </span><span class="nottickedoff">return $ bindSOpenTerm ev m_tp ret_tp m k_tm</span></span>
<span class="lineno">  865 </span>
<span class="lineno">  866 </span>-- | This type turns any type satisfying 'TransInfo' into one satisfying
<span class="lineno">  867 </span>-- 'TransInfoM' by adding a monadic return type
<span class="lineno">  868 </span>data SpecMTransInfo info ctx = SpecMTransInfo (info ctx) OpenTerm
<span class="lineno">  869 </span>
<span class="lineno">  870 </span>instance TransInfo info =&gt; TransInfo (SpecMTransInfo info) where
<span class="lineno">  871 </span>  <span class="decl"><span class="nottickedoff">infoCtx (SpecMTransInfo info _) = infoCtx info</span></span>
<span class="lineno">  872 </span>  <span class="decl"><span class="nottickedoff">infoEnv (SpecMTransInfo info _) = infoEnv info</span></span>
<span class="lineno">  873 </span>  <span class="decl"><span class="nottickedoff">infoChecksFlag (SpecMTransInfo info _) = infoChecksFlag info</span></span>
<span class="lineno">  874 </span>  <span class="decl"><span class="nottickedoff">extTransInfo etrans (SpecMTransInfo info ret_tp) =</span>
<span class="lineno">  875 </span><span class="spaces">    </span><span class="nottickedoff">SpecMTransInfo (extTransInfo etrans info) ret_tp</span></span>
<span class="lineno">  876 </span>
<span class="lineno">  877 </span>instance TransInfo info =&gt; TransInfoM (SpecMTransInfo info) where
<span class="lineno">  878 </span>  <span class="decl"><span class="nottickedoff">infoRetType (SpecMTransInfo _ ret_tp) = ret_tp</span></span>
<span class="lineno">  879 </span>
<span class="lineno">  880 </span>-- | Build a monadic @SpecM@ computation using a particular return type
<span class="lineno">  881 </span>specMTransM :: OpenTerm -&gt; TransM (SpecMTransInfo info) ctx OpenTerm -&gt;
<span class="lineno">  882 </span>               TransM info ctx OpenTerm
<span class="lineno">  883 </span><span class="decl"><span class="nottickedoff">specMTransM ret_tp m = withInfoM (flip SpecMTransInfo ret_tp) m</span></span>
<span class="lineno">  884 </span>
<span class="lineno">  885 </span>-- | The class for translating to SAW
<span class="lineno">  886 </span>class Translate info ctx a tr | ctx a -&gt; tr where
<span class="lineno">  887 </span>  translate :: Mb ctx a -&gt; TransM info ctx tr
<span class="lineno">  888 </span>
<span class="lineno">  889 </span>-- | Translate to SAW and then convert to a single SAW term, raising an error if
<span class="lineno">  890 </span>-- the result has 0 or more than 1 terms
<span class="lineno">  891 </span>translate1 :: (IsTermTrans tr, Translate info ctx a tr, HasCallStack) =&gt;
<span class="lineno">  892 </span>              Mb ctx a -&gt; TransM info ctx OpenTerm
<span class="lineno">  893 </span><span class="decl"><span class="nottickedoff">translate1 a = translate a &gt;&gt;= \tr -&gt; case transTerms tr of</span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="nottickedoff">[t] -&gt; return t</span>
<span class="lineno">  895 </span><span class="spaces">  </span><span class="nottickedoff">ts -&gt; error (&quot;translate1: expected 1 term, found &quot; ++ show (length ts)</span>
<span class="lineno">  896 </span><span class="spaces">               </span><span class="nottickedoff">++ nlPrettyCallStack callStack)</span></span>
<span class="lineno">  897 </span>
<span class="lineno">  898 </span>-- | Translate a \&quot;closed\&quot; term, that is not in a binding
<span class="lineno">  899 </span>translateClosed :: (TransInfo info, Translate info ctx a tr) =&gt;
<span class="lineno">  900 </span>                   a -&gt; TransM info ctx tr
<span class="lineno">  901 </span><span class="decl"><span class="nottickedoff">translateClosed a = nuMultiTransM (const a) &gt;&gt;= translate</span></span>
<span class="lineno">  902 </span>
<span class="lineno">  903 </span>instance (Translate info ctx a tr, NuMatching a) =&gt;
<span class="lineno">  904 </span>         Translate info ctx [a] [tr] where
<span class="lineno">  905 </span>  <span class="decl"><span class="nottickedoff">translate = mapM translate . mbList</span></span>
<span class="lineno">  906 </span>
<span class="lineno">  907 </span>
<span class="lineno">  908 </span>----------------------------------------------------------------------
<span class="lineno">  909 </span>-- * Translating Types
<span class="lineno">  910 </span>----------------------------------------------------------------------
<span class="lineno">  911 </span>
<span class="lineno">  912 </span>-- | A flag for whether or not to perform checks in the translation. We use this
<span class="lineno">  913 </span>-- type, rather than just 'Bool', for documentation purposes.
<span class="lineno">  914 </span>newtype ChecksFlag = ChecksFlag { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">checksFlagSet</span></span></span> :: Bool }
<span class="lineno">  915 </span>
<span class="lineno">  916 </span>-- | The 'ChecksFlag' specifying not to perform any translation checks
<span class="lineno">  917 </span>noChecks :: ChecksFlag
<span class="lineno">  918 </span><span class="decl"><span class="nottickedoff">noChecks = ChecksFlag False</span></span>
<span class="lineno">  919 </span>
<span class="lineno">  920 </span>-- | The 'ChecksFlag' specifying to perform all translation checks
<span class="lineno">  921 </span>doChecks :: ChecksFlag
<span class="lineno">  922 </span><span class="decl"><span class="nottickedoff">doChecks = ChecksFlag True</span></span>
<span class="lineno">  923 </span>
<span class="lineno">  924 </span>-- | Translation info for translating types and pure expressions
<span class="lineno">  925 </span>data TypeTransInfo ctx =
<span class="lineno">  926 </span>  TypeTransInfo
<span class="lineno">  927 </span>  {
<span class="lineno">  928 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ttiExprCtx</span></span></span> :: ExprTransCtx ctx,
<span class="lineno">  929 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ttiPermEnv</span></span></span> :: PermEnv,
<span class="lineno">  930 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ttiChecksFlag</span></span></span> :: ChecksFlag
<span class="lineno">  931 </span>  }
<span class="lineno">  932 </span>
<span class="lineno">  933 </span>-- | Build an empty 'TypeTransInfo' from a 'PermEnv'
<span class="lineno">  934 </span>emptyTypeTransInfo :: PermEnv -&gt; ChecksFlag -&gt; TypeTransInfo RNil
<span class="lineno">  935 </span><span class="decl"><span class="nottickedoff">emptyTypeTransInfo = TypeTransInfo MNil</span></span>
<span class="lineno">  936 </span>
<span class="lineno">  937 </span>instance TransInfo TypeTransInfo where
<span class="lineno">  938 </span>  <span class="decl"><span class="nottickedoff">infoCtx (TypeTransInfo ctx _ _) = ctx</span></span>
<span class="lineno">  939 </span>  <span class="decl"><span class="nottickedoff">infoEnv (TypeTransInfo _ env _) = env</span></span>
<span class="lineno">  940 </span>  <span class="decl"><span class="nottickedoff">infoChecksFlag (TypeTransInfo _ _ cflag) = cflag</span></span>
<span class="lineno">  941 </span>  <span class="decl"><span class="nottickedoff">extTransInfo etrans (TypeTransInfo ctx env checks) =</span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="nottickedoff">TypeTransInfo (ctx :&gt;: etrans) env checks</span></span>
<span class="lineno">  943 </span>
<span class="lineno">  944 </span>-- | The translation monad specific to translating types and pure expressions
<span class="lineno">  945 </span>type TypeTransM = TransM TypeTransInfo
<span class="lineno">  946 </span>
<span class="lineno">  947 </span>-- | Any 'TransM' can run a 'TypeTransM'
<span class="lineno">  948 </span>tpTransM :: TransInfo info =&gt; TypeTransM ctx a -&gt; TransM info ctx a
<span class="lineno">  949 </span><span class="decl"><span class="nottickedoff">tpTransM =</span>
<span class="lineno">  950 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM $ \info -&gt;</span>
<span class="lineno">  951 </span><span class="spaces">  </span><span class="nottickedoff">TypeTransInfo (infoCtx info) (infoEnv info) (infoChecksFlag info)</span></span>
<span class="lineno">  952 </span>
<span class="lineno">  953 </span>-- | Run a 'TypeTransM' computation in the empty translation context
<span class="lineno">  954 </span>runNilTypeTransM :: PermEnv -&gt; ChecksFlag -&gt; TypeTransM RNil a -&gt; a
<span class="lineno">  955 </span><span class="decl"><span class="nottickedoff">runNilTypeTransM env checks m = runTransM m (emptyTypeTransInfo env checks)</span></span>
<span class="lineno">  956 </span>
<span class="lineno">  957 </span>-- | Convert a 'TypeTransM' computation into a pure function that takes in an
<span class="lineno">  958 </span>-- 'ExprTransCtx'
<span class="lineno">  959 </span>ctxFunTypeTransM :: TypeTransM ctx a -&gt; TypeTransM ctx' (ExprTransCtx ctx -&gt; a)
<span class="lineno">  960 </span><span class="decl"><span class="nottickedoff">ctxFunTypeTransM m =</span>
<span class="lineno">  961 </span><span class="spaces">  </span><span class="nottickedoff">do TypeTransInfo {..} &lt;- ask</span>
<span class="lineno">  962 </span><span class="spaces">     </span><span class="nottickedoff">return $ \ectx -&gt; runTransM m $ TypeTransInfo { ttiExprCtx = ectx, .. }</span></span>
<span class="lineno">  963 </span>
<span class="lineno">  964 </span>-- | Run a translation computation in an empty expression translation context
<span class="lineno">  965 </span>inEmptyCtxTransM :: TypeTransM RNil a -&gt; TypeTransM ctx a
<span class="lineno">  966 </span><span class="decl"><span class="nottickedoff">inEmptyCtxTransM =</span>
<span class="lineno">  967 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM (\(TypeTransInfo _ env checks) -&gt; TypeTransInfo MNil env checks)</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>instance TransInfo info =&gt; Translate info ctx (NatRepr n) OpenTerm where
<span class="lineno">  970 </span>  <span class="decl"><span class="nottickedoff">translate mb_n = return $ natOpenTerm $ mbLift $ fmap natValue mb_n</span></span>
<span class="lineno">  971 </span>
<span class="lineno">  972 </span>-- | Make a type translation that uses a single term of the given type
<span class="lineno">  973 </span>mkTermType1 :: KnownRepr TypeRepr a =&gt; OpenTerm -&gt; TypeTrans (ExprTrans a)
<span class="lineno">  974 </span><span class="decl"><span class="nottickedoff">mkTermType1 tp = mkTypeTrans1 tp (ETrans_Term knownRepr)</span></span>
<span class="lineno">  975 </span>
<span class="lineno">  976 </span>-- | Make a type translation that uses a single term of the given type using an
<span class="lineno">  977 </span>-- explicit 'TypeRepr' for the Crucible type
<span class="lineno">  978 </span>mkTermType1Repr :: TypeRepr a -&gt; OpenTerm -&gt; TypeTrans (ExprTrans a)
<span class="lineno">  979 </span><span class="decl"><span class="nottickedoff">mkTermType1Repr repr tp = mkTypeTrans1 tp (ETrans_Term repr)</span></span>
<span class="lineno">  980 </span>
<span class="lineno">  981 </span>
<span class="lineno">  982 </span>-- | Translate a permission expression type to a 'TypeTrans' and to a list of
<span class="lineno">  983 </span>-- kind descriptions that describe the types in the 'TypeTrans'
<span class="lineno">  984 </span>translateType :: (?ev :: EventType) =&gt; TypeRepr a -&gt;
<span class="lineno">  985 </span>                 (TypeTrans (ExprTrans a), [OpenTerm])
<span class="lineno">  986 </span><span class="decl"><span class="nottickedoff">translateType UnitRepr = (mkTypeTrans0 ETrans_Unit, [])</span>
<span class="lineno">  987 </span><span class="spaces"></span><span class="nottickedoff">translateType BoolRepr =</span>
<span class="lineno">  988 </span><span class="spaces">  </span><span class="nottickedoff">(mkTermType1 (globalOpenTerm &quot;Prelude.Bool&quot;), [boolKindDesc])</span>
<span class="lineno">  989 </span><span class="spaces"></span><span class="nottickedoff">translateType NatRepr =</span>
<span class="lineno">  990 </span><span class="spaces">  </span><span class="nottickedoff">(mkTermType1 (dataTypeOpenTerm &quot;Prelude.Nat&quot; []), [natKindDesc])</span>
<span class="lineno">  991 </span><span class="spaces"></span><span class="nottickedoff">translateType (BVRepr w) =</span>
<span class="lineno">  992 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="nottickedoff">(mkTermType1 (bitvectorTypeOpenTerm (natOpenTerm $ natValue w)),</span>
<span class="lineno">  994 </span><span class="spaces">   </span><span class="nottickedoff">[bvKindDesc (natValue w)])</span>
<span class="lineno">  995 </span><span class="spaces"></span><span class="nottickedoff">translateType (VectorRepr AnyRepr) = (mkTypeTrans0 ETrans_AnyVector, [])</span>
<span class="lineno">  996 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  997 </span><span class="spaces"></span><span class="nottickedoff">-- Our special-purpose intrinsic types, whose translations do not have</span>
<span class="lineno">  998 </span><span class="spaces"></span><span class="nottickedoff">-- computational content</span>
<span class="lineno">  999 </span><span class="spaces"></span><span class="nottickedoff">translateType (LLVMPointerRepr _) = (mkTypeTrans0 ETrans_LLVM, [])</span>
<span class="lineno"> 1000 </span><span class="spaces"></span><span class="nottickedoff">translateType (LLVMBlockRepr _) = (mkTypeTrans0 ETrans_LLVMBlock, [])</span>
<span class="lineno"> 1001 </span><span class="spaces"></span><span class="nottickedoff">translateType (LLVMFrameRepr _) = (mkTypeTrans0 ETrans_LLVMFrame, [])</span>
<span class="lineno"> 1002 </span><span class="spaces"></span><span class="nottickedoff">translateType LifetimeRepr = (mkTypeTrans0 ETrans_Lifetime, [])</span>
<span class="lineno"> 1003 </span><span class="spaces"></span><span class="nottickedoff">translateType PermListRepr =</span>
<span class="lineno"> 1004 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;translateType&quot; [&quot;PermList type no longer supported!&quot;]</span>
<span class="lineno"> 1005 </span><span class="spaces"></span><span class="nottickedoff">translateType RWModalityRepr = (mkTypeTrans0 ETrans_RWModality, [])</span>
<span class="lineno"> 1006 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1007 </span><span class="spaces"></span><span class="nottickedoff">-- Permissions and LLVM shapes translate to type descriptions</span>
<span class="lineno"> 1008 </span><span class="spaces"></span><span class="nottickedoff">translateType (ValuePermRepr _) =</span>
<span class="lineno"> 1009 </span><span class="spaces">  </span><span class="nottickedoff">(mkTypeTrans1 tpDescTypeOpenTerm (\d -&gt;</span>
<span class="lineno"> 1010 </span><span class="spaces">                                     </span><span class="nottickedoff">ETrans_Perm [d] [tpElemTypeOpenTerm ?ev d]),</span>
<span class="lineno"> 1011 </span><span class="spaces">   </span><span class="nottickedoff">[tpKindDesc])</span>
<span class="lineno"> 1012 </span><span class="spaces"></span><span class="nottickedoff">translateType (LLVMShapeRepr _) =</span>
<span class="lineno"> 1013 </span><span class="spaces">  </span><span class="nottickedoff">(mkTypeTrans1 tpDescTypeOpenTerm (\d -&gt; ETrans_Shape</span>
<span class="lineno"> 1014 </span><span class="spaces">                                          </span><span class="nottickedoff">(Just (d, tpElemTypeOpenTerm ?ev d))),</span>
<span class="lineno"> 1015 </span><span class="spaces">   </span><span class="nottickedoff">[tpKindDesc])</span>
<span class="lineno"> 1016 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1017 </span><span class="spaces"></span><span class="nottickedoff">translateType tp@(FloatRepr _) =</span>
<span class="lineno"> 1018 </span><span class="spaces">  </span><span class="nottickedoff">(mkTermType1Repr tp $ dataTypeOpenTerm &quot;Prelude.Float&quot; [],</span>
<span class="lineno"> 1019 </span><span class="spaces">   </span><span class="nottickedoff">panic &quot;translateType&quot; [&quot;Type descriptions of floats not yet supported&quot;])</span>
<span class="lineno"> 1020 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1021 </span><span class="spaces"></span><span class="nottickedoff">translateType (StringRepr UnicodeRepr) =</span>
<span class="lineno"> 1022 </span><span class="spaces">  </span><span class="nottickedoff">(mkTermType1 stringTypeOpenTerm,</span>
<span class="lineno"> 1023 </span><span class="spaces">   </span><span class="nottickedoff">panic &quot;translateType&quot; [&quot;Type descriptions of strings not yet supported&quot;])</span>
<span class="lineno"> 1024 </span><span class="spaces"></span><span class="nottickedoff">translateType (StringRepr _) =</span>
<span class="lineno"> 1025 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;translateType&quot; [&quot;Non-unicode strings not supported&quot;]</span>
<span class="lineno"> 1026 </span><span class="spaces"></span><span class="nottickedoff">translateType (FunctionHandleRepr _ _) =</span>
<span class="lineno"> 1027 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: function permissions translate to the SAW function, but the function</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="nottickedoff">-- handle itself has no SAW translation</span>
<span class="lineno"> 1029 </span><span class="spaces">  </span><span class="nottickedoff">(mkTypeTrans0 ETrans_Fun, [])</span>
<span class="lineno"> 1030 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1031 </span><span class="spaces"></span><span class="nottickedoff">translateType (StructRepr tps) =</span>
<span class="lineno"> 1032 </span><span class="spaces">    </span><span class="nottickedoff">let (tp_transs, ds) = translateCruCtx (mkCruCtx tps) in</span>
<span class="lineno"> 1033 </span><span class="spaces">    </span><span class="nottickedoff">(fmap ETrans_Struct tp_transs, ds)</span>
<span class="lineno"> 1034 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1035 </span><span class="spaces"></span><span class="nottickedoff">-- Default case is to panic for unsupported types</span>
<span class="lineno"> 1036 </span><span class="spaces"></span><span class="nottickedoff">translateType tp =</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;translateType&quot; [&quot;Type not supported: &quot; ++ show tp]</span></span>
<span class="lineno"> 1038 </span>
<span class="lineno"> 1039 </span>
<span class="lineno"> 1040 </span>-- | Translate a 'CruCtx' to a 'TypeTrans' and to a list of kind descriptions
<span class="lineno"> 1041 </span>-- that describe the types in the 'TypeTrans'
<span class="lineno"> 1042 </span>translateCruCtx :: (?ev :: EventType) =&gt; CruCtx ctx -&gt;
<span class="lineno"> 1043 </span>                   (TypeTrans (ExprTransCtx ctx), [OpenTerm])
<span class="lineno"> 1044 </span><span class="decl"><span class="nottickedoff">translateCruCtx CruCtxNil = (mkTypeTrans0 MNil, [])</span>
<span class="lineno"> 1045 </span><span class="spaces"></span><span class="nottickedoff">translateCruCtx (CruCtxCons ctx tp) =</span>
<span class="lineno"> 1046 </span><span class="spaces">  </span><span class="nottickedoff">let (ctx_trans, ds1) = translateCruCtx ctx</span>
<span class="lineno"> 1047 </span><span class="spaces">      </span><span class="nottickedoff">(tp_trans, ds2) = translateType tp in</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="nottickedoff">((:&gt;:) &lt;$&gt; ctx_trans &lt;*&gt; tp_trans, ds1 ++ ds2)</span></span>
<span class="lineno"> 1049 </span>
<span class="lineno"> 1050 </span>-- | Translate a permission expression type to a list of kind descriptions
<span class="lineno"> 1051 </span>translateKindDescs :: (?ev :: EventType) =&gt; TypeRepr a -&gt; [OpenTerm]
<span class="lineno"> 1052 </span><span class="decl"><span class="nottickedoff">translateKindDescs = snd . translateType</span></span>
<span class="lineno"> 1053 </span>
<span class="lineno"> 1054 </span>-- Translate an expression type to a 'TypeTrans', which both gives a list of 0
<span class="lineno"> 1055 </span>-- or more SAW core types and also gives a function to create an expression
<span class="lineno"> 1056 </span>-- translation from SAW core terms of those types
<span class="lineno"> 1057 </span>instance TransInfo info =&gt;
<span class="lineno"> 1058 </span>         Translate info ctx (TypeRepr a) (TypeTrans (ExprTrans a)) where
<span class="lineno"> 1059 </span>  <span class="decl"><span class="nottickedoff">translate tp =</span>
<span class="lineno"> 1060 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 1061 </span><span class="spaces">       </span><span class="nottickedoff">return $ fst $ let ?ev = ev in translateType $ mbLift tp</span></span>
<span class="lineno"> 1062 </span>
<span class="lineno"> 1063 </span>instance TransInfo info =&gt;
<span class="lineno"> 1064 </span>         Translate info ctx (CruCtx as) (TypeTrans (ExprTransCtx as)) where
<span class="lineno"> 1065 </span>  <span class="decl"><span class="nottickedoff">translate ctx =</span>
<span class="lineno"> 1066 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 1067 </span><span class="spaces">       </span><span class="nottickedoff">return $ fst $ let ?ev = ev in translateCruCtx $ mbLift ctx</span></span>
<span class="lineno"> 1068 </span>
<span class="lineno"> 1069 </span>-- | Translate all types in a Crucible context and lambda-abstract over them
<span class="lineno"> 1070 </span>lambdaExprCtx :: TransInfo info =&gt; CruCtx ctx -&gt; TransM info ctx OpenTerm -&gt;
<span class="lineno"> 1071 </span>                 TransM info RNil OpenTerm
<span class="lineno"> 1072 </span><span class="decl"><span class="nottickedoff">lambdaExprCtx ctx m =</span>
<span class="lineno"> 1073 </span><span class="spaces">  </span><span class="nottickedoff">translateClosed ctx &gt;&gt;= \tptrans -&gt;</span>
<span class="lineno"> 1074 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTransM &quot;e&quot; tptrans (\ectx -&gt; inCtxTransM ectx m)</span></span>
<span class="lineno"> 1075 </span>
<span class="lineno"> 1076 </span>-- | Translate all types in a Crucible context and lambda-abstract over them,
<span class="lineno"> 1077 </span>-- appending them to the existing context
<span class="lineno"> 1078 </span>lambdaExprCtxApp :: TransInfo info =&gt; CruCtx ctx2 -&gt;
<span class="lineno"> 1079 </span>                    TransM info (ctx1 :++: ctx2) OpenTerm -&gt;
<span class="lineno"> 1080 </span>                    TransM info ctx1 OpenTerm
<span class="lineno"> 1081 </span><span class="decl"><span class="nottickedoff">lambdaExprCtxApp ctx m =</span>
<span class="lineno"> 1082 </span><span class="spaces">  </span><span class="nottickedoff">translateClosed ctx &gt;&gt;= \tptrans -&gt;</span>
<span class="lineno"> 1083 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTransM &quot;e&quot; tptrans (\ectx -&gt; inExtMultiTransM ectx m)</span></span>
<span class="lineno"> 1084 </span>
<span class="lineno"> 1085 </span>-- | Translate all types in a Crucible context and pi-abstract over them
<span class="lineno"> 1086 </span>piExprCtx :: TransInfo info =&gt; CruCtx ctx -&gt; TransM info ctx OpenTerm -&gt;
<span class="lineno"> 1087 </span>             TransM info RNil OpenTerm
<span class="lineno"> 1088 </span><span class="decl"><span class="nottickedoff">piExprCtx ctx m =</span>
<span class="lineno"> 1089 </span><span class="spaces">  </span><span class="nottickedoff">translateClosed ctx &gt;&gt;= \tptrans -&gt;</span>
<span class="lineno"> 1090 </span><span class="spaces">  </span><span class="nottickedoff">piTransM &quot;e&quot; tptrans (\ectx -&gt; inCtxTransM ectx m)</span></span>
<span class="lineno"> 1091 </span>
<span class="lineno"> 1092 </span>-- | Like 'piExprCtx' but append the newly bound variables to the current
<span class="lineno"> 1093 </span>-- context, rather than running in the empty context
<span class="lineno"> 1094 </span>piExprCtxApp :: TransInfo info =&gt; CruCtx ctx2 -&gt;
<span class="lineno"> 1095 </span>                TransM info (ctx1 :++: ctx2) OpenTerm -&gt;
<span class="lineno"> 1096 </span>                TransM info ctx1 OpenTerm
<span class="lineno"> 1097 </span><span class="decl"><span class="nottickedoff">piExprCtxApp ctx m =</span>
<span class="lineno"> 1098 </span><span class="spaces">  </span><span class="nottickedoff">translateClosed ctx &gt;&gt;= \tptrans -&gt;</span>
<span class="lineno"> 1099 </span><span class="spaces">  </span><span class="nottickedoff">piTransM &quot;e&quot; tptrans (\ectx -&gt; inExtMultiTransM ectx m)</span></span>
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>
<span class="lineno"> 1102 </span>----------------------------------------------------------------------
<span class="lineno"> 1103 </span>-- * Translating to Type Descriptions
<span class="lineno"> 1104 </span>----------------------------------------------------------------------
<span class="lineno"> 1105 </span>
<span class="lineno"> 1106 </span>-- | Translation info for translating to type descriptions, which contains an
<span class="lineno"> 1107 </span>-- 'ExprTransCtx' for some prefix of @ctx@. The remainder of @ctx@ are variables
<span class="lineno"> 1108 </span>-- that each translate to zero or more deBruijn indices in type-level
<span class="lineno"> 1109 </span>-- expressions of the given kind descriptions. Note that this type does not
<span class="lineno"> 1110 </span>-- satisfy 'TransInfo', because that class requires an 'ExprTransCtx' for all of
<span class="lineno"> 1111 </span>-- @ctx@.
<span class="lineno"> 1112 </span>data DescTransInfo ctx where
<span class="lineno"> 1113 </span>  DescTransInfo ::
<span class="lineno"> 1114 </span>    ExprTransCtx ctx1 -&gt; RAssign (Constant [OpenTerm]) ctx2 -&gt; PermEnv -&gt;
<span class="lineno"> 1115 </span>    ChecksFlag -&gt; DescTransInfo (ctx1 :++: ctx2)
<span class="lineno"> 1116 </span>
<span class="lineno"> 1117 </span>-- | Extract the 'PermEnv' from a 'DescTransInfo'
<span class="lineno"> 1118 </span>dtiEnv :: DescTransInfo ctx -&gt; PermEnv
<span class="lineno"> 1119 </span><span class="decl"><span class="nottickedoff">dtiEnv (DescTransInfo _ _ env _) = env</span></span>
<span class="lineno"> 1120 </span>
<span class="lineno"> 1121 </span>-- | Extract the event type from a 'DescTransInfo'
<span class="lineno"> 1122 </span>dtiEvType :: DescTransInfo ctx -&gt; EventType
<span class="lineno"> 1123 </span><span class="decl"><span class="nottickedoff">dtiEvType = permEnvEventType . dtiEnv</span></span>
<span class="lineno"> 1124 </span>
<span class="lineno"> 1125 </span>-- | Build a sequence of 'Proxy's for the context of a 'DescTransInfo'
<span class="lineno"> 1126 </span>dtiProxies :: DescTransInfo ctx -&gt; RAssign Proxy ctx
<span class="lineno"> 1127 </span><span class="decl"><span class="nottickedoff">dtiProxies (DescTransInfo ectx1 ctx2 _ _) =</span>
<span class="lineno"> 1128 </span><span class="spaces">  </span><span class="nottickedoff">RL.append (RL.map (const Proxy) ectx1) (RL.map (const Proxy) ctx2)</span></span>
<span class="lineno"> 1129 </span>
<span class="lineno"> 1130 </span>-- | Translate a 'Member' proof representing a variable in a 'DescTransInfo'
<span class="lineno"> 1131 </span>-- context into either an 'ExprTrans', if the variable is bound in the
<span class="lineno"> 1132 </span>-- 'ExprTransCtx' portion of the context, or a 'Natural' that gives the deBruijn
<span class="lineno"> 1133 </span>-- index associated with the variable plus a list of its kind descriptions
<span class="lineno"> 1134 </span>dtiTranslateMemb :: DescTransInfo ctx -&gt; Member ctx a -&gt;
<span class="lineno"> 1135 </span>                    Either (ExprTrans a) (Natural, [OpenTerm])
<span class="lineno"> 1136 </span><span class="decl"><span class="nottickedoff">dtiTranslateMemb (DescTransInfo ectx MNil _ _) memb =</span>
<span class="lineno"> 1137 </span><span class="spaces">  </span><span class="nottickedoff">Left $ RL.get memb ectx</span>
<span class="lineno"> 1138 </span><span class="spaces"></span><span class="nottickedoff">dtiTranslateMemb (DescTransInfo _ (_ :&gt;: Constant ds) _ _) Member_Base =</span>
<span class="lineno"> 1139 </span><span class="spaces">  </span><span class="nottickedoff">Right (0, ds)</span>
<span class="lineno"> 1140 </span><span class="spaces"></span><span class="nottickedoff">dtiTranslateMemb (DescTransInfo ectx1 (ctx2 :&gt;: Constant kds)</span>
<span class="lineno"> 1141 </span><span class="spaces">                  </span><span class="nottickedoff">checks env) (Member_Step memb) =</span>
<span class="lineno"> 1142 </span><span class="spaces">  </span><span class="nottickedoff">case dtiTranslateMemb (DescTransInfo ectx1 ctx2 checks env) memb of</span>
<span class="lineno"> 1143 </span><span class="spaces">    </span><span class="nottickedoff">Left etrans -&gt; Left etrans</span>
<span class="lineno"> 1144 </span><span class="spaces">    </span><span class="nottickedoff">Right (i, ds) -&gt; Right (i + fromIntegral (length kds), ds)</span></span>
<span class="lineno"> 1145 </span>
<span class="lineno"> 1146 </span>-- | Extend the context of a 'DescTransInfo' with free deBruijn variables for a
<span class="lineno"> 1147 </span>-- list of kind descriptions
<span class="lineno"> 1148 </span>extDescTransInfo :: [OpenTerm] -&gt; DescTransInfo ctx -&gt; DescTransInfo (ctx :&gt; tp)
<span class="lineno"> 1149 </span><span class="decl"><span class="nottickedoff">extDescTransInfo ds (DescTransInfo ctx1 ctx2 env checks) =</span>
<span class="lineno"> 1150 </span><span class="spaces">  </span><span class="nottickedoff">DescTransInfo ctx1 (ctx2 :&gt;: Constant ds) env checks</span></span>
<span class="lineno"> 1151 </span>
<span class="lineno"> 1152 </span>-- | The translation monad specific to translating type descriptions
<span class="lineno"> 1153 </span>type DescTransM = TransM DescTransInfo
<span class="lineno"> 1154 </span>
<span class="lineno"> 1155 </span>-- | Run a 'DescTransM' computation with an additional deBruijn variable
<span class="lineno"> 1156 </span>inExtDescTransM :: [OpenTerm] -&gt; DescTransM (ctx :&gt; tp) a -&gt; DescTransM ctx a
<span class="lineno"> 1157 </span><span class="decl"><span class="nottickedoff">inExtDescTransM ds = withInfoM (extDescTransInfo ds)</span></span>
<span class="lineno"> 1158 </span>
<span class="lineno"> 1159 </span>-- | Run a 'DescTransM' computation with a set of additional deBruijn variables
<span class="lineno"> 1160 </span>inExtDescTransMultiM :: RAssign (Constant [OpenTerm]) ctx2 -&gt;
<span class="lineno"> 1161 </span>                        DescTransM (ctx1 :++: ctx2) a -&gt; DescTransM ctx1 a
<span class="lineno"> 1162 </span><span class="decl"><span class="nottickedoff">inExtDescTransMultiM MNil m = m</span>
<span class="lineno"> 1163 </span><span class="spaces"></span><span class="nottickedoff">inExtDescTransMultiM (ctx :&gt;: Constant tp) m =</span>
<span class="lineno"> 1164 </span><span class="spaces">  </span><span class="nottickedoff">inExtDescTransMultiM ctx $ inExtDescTransM tp m</span></span>
<span class="lineno"> 1165 </span>
<span class="lineno"> 1166 </span>-- | Run a 'DescTransM' computation in an extended expression context that binds
<span class="lineno"> 1167 </span>-- all the newly-bound variables to deBruijn indices. Pass the concatenated list
<span class="lineno"> 1168 </span>-- of all the kind descriptions of those variables to the sub-computation.
<span class="lineno"> 1169 </span>inExtCtxDescTransM :: CruCtx ctx2 -&gt;
<span class="lineno"> 1170 </span>                      ([OpenTerm] -&gt; DescTransM (ctx1 :++: ctx2) a) -&gt;
<span class="lineno"> 1171 </span>                      DescTransM ctx1 a
<span class="lineno"> 1172 </span><span class="decl"><span class="nottickedoff">inExtCtxDescTransM ctx m =</span>
<span class="lineno"> 1173 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- dtiEvType &lt;$&gt; ask</span>
<span class="lineno"> 1174 </span><span class="spaces">     </span><span class="nottickedoff">let kdesc_ctx =</span>
<span class="lineno"> 1175 </span><span class="spaces">           </span><span class="nottickedoff">let ?ev = ev in</span>
<span class="lineno"> 1176 </span><span class="spaces">           </span><span class="nottickedoff">RL.map (Constant . translateKindDescs) $ cruCtxToTypes ctx</span>
<span class="lineno"> 1177 </span><span class="spaces">         </span><span class="nottickedoff">kdescs = concat $ RL.toList kdesc_ctx</span>
<span class="lineno"> 1178 </span><span class="spaces">     </span><span class="nottickedoff">inExtDescTransMultiM kdesc_ctx $ m kdescs</span></span>
<span class="lineno"> 1179 </span>
<span class="lineno"> 1180 </span>-- | Run a 'DescTransM' computation in an expression context that binds a
<span class="lineno"> 1181 </span>-- context of deBruijn indices. Pass the concatenated list of all the kind
<span class="lineno"> 1182 </span>-- descriptions of those variables to the sub-computation.
<span class="lineno"> 1183 </span>inCtxDescTransM :: CruCtx ctx -&gt; ([OpenTerm] -&gt; DescTransM ctx a) -&gt;
<span class="lineno"> 1184 </span>                   DescTransM RNil a
<span class="lineno"> 1185 </span><span class="decl"><span class="nottickedoff">inCtxDescTransM ctx m =</span>
<span class="lineno"> 1186 </span><span class="spaces">  </span><span class="nottickedoff">case RL.prependRNilEq (cruCtxProxies ctx) of</span>
<span class="lineno"> 1187 </span><span class="spaces">    </span><span class="nottickedoff">Refl -&gt; inExtCtxDescTransM ctx m</span></span>
<span class="lineno"> 1188 </span>
<span class="lineno"> 1189 </span>-- | Run a 'DescTransM' computation in any 'TransM' monad satifying 'TransInfo'
<span class="lineno"> 1190 </span>descTransM :: TransInfo info =&gt; DescTransM ctx a -&gt; TransM info ctx a
<span class="lineno"> 1191 </span><span class="decl"><span class="nottickedoff">descTransM =</span>
<span class="lineno"> 1192 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM $ \info -&gt;</span>
<span class="lineno"> 1193 </span><span class="spaces">  </span><span class="nottickedoff">DescTransInfo (infoCtx info) MNil (infoEnv info) (infoChecksFlag info)</span></span>
<span class="lineno"> 1194 </span>
<span class="lineno"> 1195 </span>-- | The class for translating to type descriptions or type-level expressions.
<span class="lineno"> 1196 </span>-- This should hold for any type that has a 'Translate' instance to a
<span class="lineno"> 1197 </span>-- 'TypeTrans'. The type descriptions returned in this case should describe
<span class="lineno"> 1198 </span>-- exactly the types in the 'TypeTrans' returned by the 'Translate' instance,
<span class="lineno"> 1199 </span>-- though 'translateDesc' is allowed to 'panic' in some cases where 'translate'
<span class="lineno"> 1200 </span>-- succeeds, meaning that some of the types cannot be described in type
<span class="lineno"> 1201 </span>-- descriptions. This also holds for the 'PermExpr' type, where the return
<span class="lineno"> 1202 </span>-- values are type-level expressions for each of the kind descriptions returned
<span class="lineno"> 1203 </span>-- by 'translateType'.
<span class="lineno"> 1204 </span>class TranslateDescs a where
<span class="lineno"> 1205 </span>  translateDescs :: Mb ctx a -&gt; DescTransM ctx [OpenTerm]
<span class="lineno"> 1206 </span>
<span class="lineno"> 1207 </span>instance (NuMatching a, TranslateDescs a) =&gt; TranslateDescs [a] where
<span class="lineno"> 1208 </span>  <span class="decl"><span class="nottickedoff">translateDescs l = concat &lt;$&gt; mapM translateDescs (mbList l)</span></span>
<span class="lineno"> 1209 </span>
<span class="lineno"> 1210 </span>-- | Translate to a single type description by tupling all the descriptions
<span class="lineno"> 1211 </span>-- return by 'translateDescs'
<span class="lineno"> 1212 </span>translateDesc :: TranslateDescs a =&gt; Mb ctx a -&gt; DescTransM ctx OpenTerm
<span class="lineno"> 1213 </span><span class="decl"><span class="nottickedoff">translateDesc mb_a = tupleTpDesc &lt;$&gt; translateDescs mb_a</span></span>
<span class="lineno"> 1214 </span>
<span class="lineno"> 1215 </span>-- | Translate to a single type description or type expression, raising an error
<span class="lineno"> 1216 </span>-- if the given construct translates to 0 or more than 1 SAW core term
<span class="lineno"> 1217 </span>translateDesc1 :: TranslateDescs a =&gt; Mb ctx a -&gt; DescTransM ctx OpenTerm
<span class="lineno"> 1218 </span><span class="decl"><span class="nottickedoff">translateDesc1 mb_a = translateDescs mb_a &gt;&gt;= \case</span>
<span class="lineno"> 1219 </span><span class="spaces">  </span><span class="nottickedoff">[d] -&gt; return d</span>
<span class="lineno"> 1220 </span><span class="spaces">  </span><span class="nottickedoff">ds -&gt; panic &quot;translateDesc1&quot; [&quot;Expected one type-level expression, found &quot;</span>
<span class="lineno"> 1221 </span><span class="spaces">                                </span><span class="nottickedoff">++ show (length ds)]</span></span>
<span class="lineno"> 1222 </span>
<span class="lineno"> 1223 </span>-- | Translate a variable to either a SAW core value, if it is bound to a value,
<span class="lineno"> 1224 </span>-- or a natural number deBruijn index for the the first of the 0 or more
<span class="lineno"> 1225 </span>-- deBruijn indices that the variable translates to along with their kind
<span class="lineno"> 1226 </span>-- descriptions if not
<span class="lineno"> 1227 </span>translateVarDesc :: Mb ctx (ExprVar a) -&gt;
<span class="lineno"> 1228 </span>                    DescTransM ctx (Either (ExprTrans a) (Natural, [OpenTerm]))
<span class="lineno"> 1229 </span><span class="decl"><span class="nottickedoff">translateVarDesc mb_x = flip dtiTranslateMemb (translateVar mb_x) &lt;$&gt; ask</span></span>
<span class="lineno"> 1230 </span>
<span class="lineno"> 1231 </span>-- | A type translation with type descriptions for its types
<span class="lineno"> 1232 </span>data DescTypeTrans tr = DescTypeTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">descTypeTrans</span></span></span> :: TypeTrans tr,
<span class="lineno"> 1233 </span>                                        <span class="nottickedoff"><span class="decl"><span class="nottickedoff">descTypeTransDescs</span></span></span> :: [OpenTerm] }
<span class="lineno"> 1234 </span>
<span class="lineno"> 1235 </span>instance <span class="decl"><span class="nottickedoff">Functor DescTypeTrans</span></span> where
<span class="lineno"> 1236 </span>  <span class="decl"><span class="nottickedoff">fmap f (DescTypeTrans ttr ds) = DescTypeTrans (fmap f ttr) ds</span></span>
<span class="lineno"> 1237 </span>
<span class="lineno"> 1238 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative DescTypeTrans</span></span></span></span></span></span> where
<span class="lineno"> 1239 </span>  <span class="decl"><span class="nottickedoff">pure x = DescTypeTrans (mkTypeTrans0 x) []</span></span>
<span class="lineno"> 1240 </span>  <span class="decl"><span class="nottickedoff">liftA2 f (DescTypeTrans tr1 ds1) (DescTypeTrans tr2 ds2) =</span>
<span class="lineno"> 1241 </span><span class="spaces">    </span><span class="nottickedoff">DescTypeTrans (App.liftA2 f tr1 tr2) (ds1 ++ ds2)</span></span>
<span class="lineno"> 1242 </span>
<span class="lineno"> 1243 </span>-- | Apply the 'typeTransFun' of a 'TypeTrans' in a 'DescTypeTrans'
<span class="lineno"> 1244 </span>descTypeTransF :: HasCallStack =&gt; DescTypeTrans tr -&gt; [OpenTerm] -&gt; tr
<span class="lineno"> 1245 </span><span class="decl"><span class="nottickedoff">descTypeTransF dtp_trans = typeTransF (descTypeTrans dtp_trans)</span></span>
<span class="lineno"> 1246 </span>
<span class="lineno"> 1247 </span>-- | Build the type description of the multi-arity arrow type from the types in
<span class="lineno"> 1248 </span>-- order in the first type translation to the tuple of the types in the second
<span class="lineno"> 1249 </span>arrowDescTrans :: DescTypeTrans tr1 -&gt; DescTypeTrans tr2 -&gt; OpenTerm
<span class="lineno"> 1250 </span><span class="decl"><span class="nottickedoff">arrowDescTrans tp1 tp2 =</span>
<span class="lineno"> 1251 </span><span class="spaces">  </span><span class="nottickedoff">funTpDesc (descTypeTransDescs tp1) (tupleTpDesc $</span>
<span class="lineno"> 1252 </span><span class="spaces">                                      </span><span class="nottickedoff">descTypeTransDescs tp2)</span></span>
<span class="lineno"> 1253 </span>
<span class="lineno"> 1254 </span>-- | Translate a type-like object to a type translation and type descriptions
<span class="lineno"> 1255 </span>translateDescType :: TransInfo info =&gt; Translate info ctx a (TypeTrans tr) =&gt;
<span class="lineno"> 1256 </span>                     TranslateDescs a =&gt;
<span class="lineno"> 1257 </span>                     Mb ctx a -&gt; TransM info ctx (DescTypeTrans tr)
<span class="lineno"> 1258 </span><span class="decl"><span class="nottickedoff">translateDescType mb_a =</span>
<span class="lineno"> 1259 </span><span class="spaces">  </span><span class="nottickedoff">DescTypeTrans &lt;$&gt; translate mb_a &lt;*&gt; descTransM (translateDescs mb_a)</span></span>
<span class="lineno"> 1260 </span>
<span class="lineno"> 1261 </span>
<span class="lineno"> 1262 </span>----------------------------------------------------------------------
<span class="lineno"> 1263 </span>-- * Translating Permission Expressions
<span class="lineno"> 1264 </span>----------------------------------------------------------------------
<span class="lineno"> 1265 </span>
<span class="lineno"> 1266 </span>-- FIXME HERE: move these OpenTerm operations to OpenTerm.hs
<span class="lineno"> 1267 </span>
<span class="lineno"> 1268 </span>-- | Build a bitvector literal from a 'BV' value
<span class="lineno"> 1269 </span>bvBVOpenTerm :: NatRepr w -&gt; BV w -&gt; OpenTerm
<span class="lineno"> 1270 </span><span class="decl"><span class="nottickedoff">bvBVOpenTerm w bv = bvLitOpenTerm (BV.asBitsBE w bv)</span></span>
<span class="lineno"> 1271 </span>
<span class="lineno"> 1272 </span>bvNatOpenTerm :: Natural -&gt; Natural -&gt; OpenTerm
<span class="lineno"> 1273 </span><span class="decl"><span class="nottickedoff">bvNatOpenTerm w n =</span>
<span class="lineno"> 1274 </span><span class="spaces">  </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvNat&quot;)</span>
<span class="lineno"> 1275 </span><span class="spaces">  </span><span class="nottickedoff">[natOpenTerm w, natOpenTerm (n `mod` 2 ^ w)]</span></span>
<span class="lineno"> 1276 </span>
<span class="lineno"> 1277 </span>bvAddOpenTerm :: Natural -&gt; OpenTerm -&gt; OpenTerm -&gt; OpenTerm
<span class="lineno"> 1278 </span><span class="decl"><span class="nottickedoff">bvAddOpenTerm n x y =</span>
<span class="lineno"> 1279 </span><span class="spaces">  </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvAdd&quot;)</span>
<span class="lineno"> 1280 </span><span class="spaces">  </span><span class="nottickedoff">[natOpenTerm n, x, y]</span></span>
<span class="lineno"> 1281 </span>
<span class="lineno"> 1282 </span>bvMulOpenTerm :: Natural -&gt; OpenTerm -&gt; OpenTerm -&gt; OpenTerm
<span class="lineno"> 1283 </span><span class="decl"><span class="nottickedoff">bvMulOpenTerm n x y =</span>
<span class="lineno"> 1284 </span><span class="spaces">  </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvMul&quot;)</span>
<span class="lineno"> 1285 </span><span class="spaces">  </span><span class="nottickedoff">[natOpenTerm n, x, y]</span></span>
<span class="lineno"> 1286 </span>
<span class="lineno"> 1287 </span>bvSplitOpenTerm :: EndianForm -&gt; OpenTerm -&gt; OpenTerm -&gt; OpenTerm -&gt;
<span class="lineno"> 1288 </span>                   (OpenTerm, OpenTerm)
<span class="lineno"> 1289 </span><span class="decl"><span class="nottickedoff">bvSplitOpenTerm BigEndian sz1 sz2 e =</span>
<span class="lineno"> 1290 </span><span class="spaces">  </span><span class="nottickedoff">(applyGlobalOpenTerm &quot;Prelude.take&quot; [boolTypeOpenTerm, sz1, sz2, e],</span>
<span class="lineno"> 1291 </span><span class="spaces">   </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.drop&quot; [boolTypeOpenTerm, sz1, sz2, e])</span>
<span class="lineno"> 1292 </span><span class="spaces"></span><span class="nottickedoff">bvSplitOpenTerm LittleEndian sz1 sz2 e =</span>
<span class="lineno"> 1293 </span><span class="spaces">  </span><span class="nottickedoff">(applyGlobalOpenTerm &quot;Prelude.drop&quot; [boolTypeOpenTerm, sz2, sz1, e],</span>
<span class="lineno"> 1294 </span><span class="spaces">   </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.take&quot; [boolTypeOpenTerm, sz2, sz1, e])</span></span>
<span class="lineno"> 1295 </span>
<span class="lineno"> 1296 </span>bvConcatOpenTerm :: EndianForm -&gt; OpenTerm -&gt; OpenTerm -&gt;
<span class="lineno"> 1297 </span>                    OpenTerm -&gt; OpenTerm -&gt; OpenTerm
<span class="lineno"> 1298 </span><span class="decl"><span class="nottickedoff">bvConcatOpenTerm BigEndian sz1 sz2 e1 e2 =</span>
<span class="lineno"> 1299 </span><span class="spaces">  </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.append&quot; [sz1, sz2, boolTypeOpenTerm, e1, e2]</span>
<span class="lineno"> 1300 </span><span class="spaces"></span><span class="nottickedoff">bvConcatOpenTerm LittleEndian sz1 sz2 e1 e2 =</span>
<span class="lineno"> 1301 </span><span class="spaces">  </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.append&quot; [sz2, sz1, boolTypeOpenTerm, e2, e1]</span></span>
<span class="lineno"> 1302 </span>
<span class="lineno"> 1303 </span>-- | Translate a variable to a 'Member' proof, raising an error if the variable
<span class="lineno"> 1304 </span>-- is unbound
<span class="lineno"> 1305 </span>translateVar :: Mb ctx (ExprVar a) -&gt; Member ctx a
<span class="lineno"> 1306 </span><span class="decl"><span class="nottickedoff">translateVar mb_x | Left memb &lt;- mbNameBoundP mb_x = memb</span>
<span class="lineno"> 1307 </span><span class="spaces"></span><span class="nottickedoff">translateVar _ = panic &quot;translateVar&quot; [&quot;unbound variable!&quot;]</span></span>
<span class="lineno"> 1308 </span>
<span class="lineno"> 1309 </span>-- | Get the 'TypeRepr' of an expression
<span class="lineno"> 1310 </span>mbExprType :: KnownRepr TypeRepr a =&gt; Mb ctx (PermExpr a) -&gt; TypeRepr a
<span class="lineno"> 1311 </span><span class="decl"><span class="nottickedoff">mbExprType _ = knownRepr</span></span>
<span class="lineno"> 1312 </span>
<span class="lineno"> 1313 </span>-- | Get the 'TypeRepr' of an expression
<span class="lineno"> 1314 </span>mbVarType :: KnownRepr TypeRepr a =&gt; Mb ctx (ExprVar a) -&gt; TypeRepr a
<span class="lineno"> 1315 </span><span class="decl"><span class="nottickedoff">mbVarType _ = knownRepr</span></span>
<span class="lineno"> 1316 </span>
<span class="lineno"> 1317 </span>-- | Get the 'TypeRepr' bound by a binding
<span class="lineno"> 1318 </span>mbBindingType :: KnownRepr TypeRepr tp =&gt; Mb ctx (Binding tp a) -&gt; TypeRepr tp
<span class="lineno"> 1319 </span><span class="decl"><span class="nottickedoff">mbBindingType _ = knownRepr</span></span>
<span class="lineno"> 1320 </span>
<span class="lineno"> 1321 </span>
<span class="lineno"> 1322 </span>instance TransInfo info =&gt;
<span class="lineno"> 1323 </span>         Translate info ctx (ExprVar a) (ExprTrans a) where
<span class="lineno"> 1324 </span>  <span class="decl"><span class="nottickedoff">translate mb_x = RL.get (translateVar mb_x) &lt;$&gt; infoCtx &lt;$&gt; ask</span></span>
<span class="lineno"> 1325 </span>
<span class="lineno"> 1326 </span>instance TransInfo info =&gt;
<span class="lineno"> 1327 </span>         Translate info ctx (RAssign ExprVar as) (ExprTransCtx as) where
<span class="lineno"> 1328 </span>  <span class="decl"><span class="nottickedoff">translate mb_exprs = case mbMatch mb_exprs of</span>
<span class="lineno"> 1329 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MNil |] -&gt; return MNil</span>
<span class="lineno"> 1330 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ns :&gt;: n |] -&gt;</span>
<span class="lineno"> 1331 </span><span class="spaces">      </span><span class="nottickedoff">(:&gt;:) &lt;$&gt; translate ns &lt;*&gt; translate n</span></span>
<span class="lineno"> 1332 </span>
<span class="lineno"> 1333 </span>instance TransInfo info =&gt;
<span class="lineno"> 1334 </span>         Translate info ctx (PermExpr a) (ExprTrans a) where
<span class="lineno"> 1335 </span>  <span class="decl"><span class="nottickedoff">translate mb_e = case mbMatch mb_e of</span>
<span class="lineno"> 1336 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Var x |] -&gt; translate x</span>
<span class="lineno"> 1337 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Unit |] -&gt; return ETrans_Unit</span>
<span class="lineno"> 1338 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Bool True |] -&gt;</span>
<span class="lineno"> 1339 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ globalOpenTerm &quot;Prelude.True&quot;</span>
<span class="lineno"> 1340 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Bool False |] -&gt;</span>
<span class="lineno"> 1341 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ globalOpenTerm &quot;Prelude.False&quot;</span>
<span class="lineno"> 1342 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Nat i |] -&gt;</span>
<span class="lineno"> 1343 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ natOpenTerm $ mbLift i</span>
<span class="lineno"> 1344 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_String str |] -&gt;</span>
<span class="lineno"> 1345 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ stringLitOpenTerm $ pack $ mbLift str</span>
<span class="lineno"> 1346 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV bvfactors@[] off |] -&gt;</span>
<span class="lineno"> 1347 </span><span class="spaces">      </span><span class="nottickedoff">let w = natRepr3 bvfactors in</span>
<span class="lineno"> 1348 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ bvBVOpenTerm w $ mbLift off</span>
<span class="lineno"> 1349 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV bvfactors (BV.BV 0) |] -&gt;</span>
<span class="lineno"> 1350 </span><span class="spaces">      </span><span class="nottickedoff">let w = natVal3 bvfactors in</span>
<span class="lineno"> 1351 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt; foldr1 (bvAddOpenTerm w) &lt;$&gt; translate bvfactors</span>
<span class="lineno"> 1352 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV bvfactors off |] -&gt;</span>
<span class="lineno"> 1353 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natRepr3 bvfactors</span>
<span class="lineno"> 1354 </span><span class="spaces">         </span><span class="nottickedoff">bv_transs &lt;- translate bvfactors</span>
<span class="lineno"> 1355 </span><span class="spaces">         </span><span class="nottickedoff">return $ ETrans_Term knownRepr $</span>
<span class="lineno"> 1356 </span><span class="spaces">           </span><span class="nottickedoff">foldr (bvAddOpenTerm $ natValue w) (bvBVOpenTerm w $ mbLift off) bv_transs</span>
<span class="lineno"> 1357 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Struct args |] -&gt;</span>
<span class="lineno"> 1358 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Struct &lt;$&gt; translate args</span>
<span class="lineno"> 1359 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Always |] -&gt;</span>
<span class="lineno"> 1360 </span><span class="spaces">      </span><span class="nottickedoff">return ETrans_Lifetime</span>
<span class="lineno"> 1361 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_LLVMWord _ |] -&gt; return ETrans_LLVM</span>
<span class="lineno"> 1362 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_LLVMOffset _ _ |] -&gt; return ETrans_LLVM</span>
<span class="lineno"> 1363 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Fun _ |] -&gt; return ETrans_Fun</span>
<span class="lineno"> 1364 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PermListNil |] -&gt; return $ ETrans_Term knownRepr unitTypeOpenTerm</span>
<span class="lineno"> 1365 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PermListCons _ _ p l |] -&gt;</span>
<span class="lineno"> 1366 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt; (pairTypeOpenTerm &lt;$&gt;</span>
<span class="lineno"> 1367 </span><span class="spaces">                                 </span><span class="nottickedoff">(typeTransTupleType &lt;$&gt; translate p) &lt;*&gt;</span>
<span class="lineno"> 1368 </span><span class="spaces">                                 </span><span class="nottickedoff">(translate1 l))</span>
<span class="lineno"> 1369 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_RWModality _ |] -&gt; return ETrans_RWModality</span>
<span class="lineno"> 1370 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1371 </span><span class="spaces">    </span><span class="nottickedoff">-- LLVM shapes are translated to type descriptions by translateDescs</span>
<span class="lineno"> 1372 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_EmptyShape |] -&gt;</span>
<span class="lineno"> 1373 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Shape Nothing</span>
<span class="lineno"> 1374 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_NamedShape _ _ nmsh args |] -&gt;</span>
<span class="lineno"> 1375 </span><span class="spaces">      </span><span class="nottickedoff">case mbMatch $ fmap namedShapeBody nmsh of</span>
<span class="lineno"> 1376 </span><span class="spaces">        </span><span class="nottickedoff">[nuMP| DefinedShapeBody _ |] -&gt;</span>
<span class="lineno"> 1377 </span><span class="spaces">          </span><span class="nottickedoff">translate (mbMap2 unfoldNamedShape nmsh args)</span>
<span class="lineno"> 1378 </span><span class="spaces">        </span><span class="nottickedoff">[nuMP| OpaqueShapeBody _ tp_id desc_id |] -&gt;</span>
<span class="lineno"> 1379 </span><span class="spaces">          </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 1380 </span><span class="spaces">             </span><span class="nottickedoff">let (_, k_ds) =</span>
<span class="lineno"> 1381 </span><span class="spaces">                   </span><span class="nottickedoff">let ?ev = ev in</span>
<span class="lineno"> 1382 </span><span class="spaces">                   </span><span class="nottickedoff">translateCruCtx (mbLift $ fmap namedShapeArgs nmsh)</span>
<span class="lineno"> 1383 </span><span class="spaces">             </span><span class="nottickedoff">args_terms &lt;- transTerms &lt;$&gt; translate args</span>
<span class="lineno"> 1384 </span><span class="spaces">             </span><span class="nottickedoff">args_ds &lt;- descTransM $ translateDescs args</span>
<span class="lineno"> 1385 </span><span class="spaces">             </span><span class="nottickedoff">return $</span>
<span class="lineno"> 1386 </span><span class="spaces">               </span><span class="nottickedoff">ETrans_Shape</span>
<span class="lineno"> 1387 </span><span class="spaces">               </span><span class="nottickedoff">(Just (substIndIdTpDescMulti (mbLift desc_id) k_ds args_ds,</span>
<span class="lineno"> 1388 </span><span class="spaces">                      </span><span class="nottickedoff">applyGlobalOpenTerm (mbLift tp_id) args_terms))</span>
<span class="lineno"> 1389 </span><span class="spaces">        </span><span class="nottickedoff">[nuMP| RecShapeBody _ tp_id desc_id |] -&gt;</span>
<span class="lineno"> 1390 </span><span class="spaces">          </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 1391 </span><span class="spaces">             </span><span class="nottickedoff">let (_, k_ds) =</span>
<span class="lineno"> 1392 </span><span class="spaces">                   </span><span class="nottickedoff">let ?ev = ev in</span>
<span class="lineno"> 1393 </span><span class="spaces">                   </span><span class="nottickedoff">translateCruCtx (mbLift $ fmap namedShapeArgs nmsh)</span>
<span class="lineno"> 1394 </span><span class="spaces">             </span><span class="nottickedoff">args_terms &lt;- transTerms &lt;$&gt; translate args</span>
<span class="lineno"> 1395 </span><span class="spaces">             </span><span class="nottickedoff">args_ds &lt;- descTransM $ translateDescs args</span>
<span class="lineno"> 1396 </span><span class="spaces">             </span><span class="nottickedoff">return $</span>
<span class="lineno"> 1397 </span><span class="spaces">               </span><span class="nottickedoff">ETrans_Shape</span>
<span class="lineno"> 1398 </span><span class="spaces">               </span><span class="nottickedoff">(Just (substIdTpDescMulti (mbLift desc_id) k_ds args_ds,</span>
<span class="lineno"> 1399 </span><span class="spaces">                      </span><span class="nottickedoff">applyGlobalOpenTerm (mbLift tp_id) args_terms))</span>
<span class="lineno"> 1400 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_EqShape _ _ |] -&gt; return $ ETrans_Shape Nothing</span>
<span class="lineno"> 1401 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PtrShape _ _ sh |] -&gt; translate sh</span>
<span class="lineno"> 1402 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_FieldShape fsh |] -&gt;</span>
<span class="lineno"> 1403 </span><span class="spaces">      </span><span class="nottickedoff">do ds &lt;- descTransM (translateDescs fsh)</span>
<span class="lineno"> 1404 </span><span class="spaces">         </span><span class="nottickedoff">tps &lt;- translate fsh</span>
<span class="lineno"> 1405 </span><span class="spaces">         </span><span class="nottickedoff">return $ case (ds, tps) of</span>
<span class="lineno"> 1406 </span><span class="spaces">           </span><span class="nottickedoff">([], []) -&gt; ETrans_Shape Nothing</span>
<span class="lineno"> 1407 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; ETrans_Shape $ Just (tupleTpDesc ds, tupleTypeOpenTerm' tps)</span>
<span class="lineno"> 1408 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ArrayShape mb_len _ mb_sh |] -&gt;</span>
<span class="lineno"> 1409 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 mb_len</span>
<span class="lineno"> 1410 </span><span class="spaces">         </span><span class="nottickedoff">let w_term = natOpenTerm w</span>
<span class="lineno"> 1411 </span><span class="spaces">         </span><span class="nottickedoff">len_d &lt;- descTransM $ translateBVDesc mb_len</span>
<span class="lineno"> 1412 </span><span class="spaces">         </span><span class="nottickedoff">len_term &lt;- translate1 mb_len</span>
<span class="lineno"> 1413 </span><span class="spaces">         </span><span class="nottickedoff">(elem_d, elem_tp) &lt;- unETransShapeTuple &lt;$&gt; translate mb_sh</span>
<span class="lineno"> 1414 </span><span class="spaces">         </span><span class="nottickedoff">return $</span>
<span class="lineno"> 1415 </span><span class="spaces">           </span><span class="nottickedoff">ETrans_Shape</span>
<span class="lineno"> 1416 </span><span class="spaces">           </span><span class="nottickedoff">(Just (bvVecTpDesc w_term len_d elem_d,</span>
<span class="lineno"> 1417 </span><span class="spaces">                  </span><span class="nottickedoff">bvVecTypeOpenTerm w_term len_term elem_tp))</span>
<span class="lineno"> 1418 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_TupShape sh |] -&gt;</span>
<span class="lineno"> 1419 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Shape &lt;$&gt; Just &lt;$&gt; unETransShapeTuple &lt;$&gt; translate sh</span>
<span class="lineno"> 1420 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_SeqShape sh1 sh2 |] -&gt;</span>
<span class="lineno"> 1421 </span><span class="spaces">      </span><span class="nottickedoff">do shtr1 &lt;- unETransShape &lt;$&gt; translate sh1</span>
<span class="lineno"> 1422 </span><span class="spaces">         </span><span class="nottickedoff">shtr2 &lt;- unETransShape &lt;$&gt; translate sh2</span>
<span class="lineno"> 1423 </span><span class="spaces">         </span><span class="nottickedoff">return $ ETrans_Shape $ case (shtr1, shtr2) of</span>
<span class="lineno"> 1424 </span><span class="spaces">           </span><span class="nottickedoff">(Nothing, _) -&gt; shtr2</span>
<span class="lineno"> 1425 </span><span class="spaces">           </span><span class="nottickedoff">(_, Nothing) -&gt; shtr1</span>
<span class="lineno"> 1426 </span><span class="spaces">           </span><span class="nottickedoff">(Just (d1,tp1), Just (d2,tp2)) -&gt;</span>
<span class="lineno"> 1427 </span><span class="spaces">             </span><span class="nottickedoff">Just (pairTpDesc d1 d2, pairTypeOpenTerm tp1 tp2)</span>
<span class="lineno"> 1428 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_OrShape sh1 sh2 |] -&gt;</span>
<span class="lineno"> 1429 </span><span class="spaces">      </span><span class="nottickedoff">do (d1, tp1) &lt;- unETransShapeTuple &lt;$&gt; translate sh1</span>
<span class="lineno"> 1430 </span><span class="spaces">         </span><span class="nottickedoff">(d2, tp2) &lt;- unETransShapeTuple &lt;$&gt; translate sh2</span>
<span class="lineno"> 1431 </span><span class="spaces">         </span><span class="nottickedoff">return $</span>
<span class="lineno"> 1432 </span><span class="spaces">           </span><span class="nottickedoff">ETrans_Shape (Just (sumTpDesc d1 d2, eitherTypeOpenTerm tp1 tp2))</span>
<span class="lineno"> 1433 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ExShape mb_mb_sh |] -&gt;</span>
<span class="lineno"> 1434 </span><span class="spaces">      </span><span class="nottickedoff">do let tp_repr = mbLift $ fmap bindingType mb_mb_sh</span>
<span class="lineno"> 1435 </span><span class="spaces">         </span><span class="nottickedoff">let mb_sh = mbCombine RL.typeCtxProxies mb_mb_sh</span>
<span class="lineno"> 1436 </span><span class="spaces">         </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 1437 </span><span class="spaces">         </span><span class="nottickedoff">let (tptrans, _) = let ?ev = ev in translateType tp_repr</span>
<span class="lineno"> 1438 </span><span class="spaces">         </span><span class="nottickedoff">d &lt;- descTransM $</span>
<span class="lineno"> 1439 </span><span class="spaces">           </span><span class="nottickedoff">inExtCtxDescTransM (singletonCruCtx tp_repr) $ \kdescs -&gt;</span>
<span class="lineno"> 1440 </span><span class="spaces">           </span><span class="nottickedoff">sigmaTpDescMulti kdescs &lt;$&gt; translateDesc mb_sh</span>
<span class="lineno"> 1441 </span><span class="spaces">         </span><span class="nottickedoff">-- NOTE: we are explicitly using laziness of the ETrans_Shape</span>
<span class="lineno"> 1442 </span><span class="spaces">         </span><span class="nottickedoff">-- constructor so that the following recursive call does not generate</span>
<span class="lineno"> 1443 </span><span class="spaces">         </span><span class="nottickedoff">-- the type description a second time and then throw it away. The</span>
<span class="lineno"> 1444 </span><span class="spaces">         </span><span class="nottickedoff">-- reason we don't use that result is that that recursive call is in</span>
<span class="lineno"> 1445 </span><span class="spaces">         </span><span class="nottickedoff">-- the context of SAW core variables for tp (bound by sigmaTypeTransM),</span>
<span class="lineno"> 1446 </span><span class="spaces">         </span><span class="nottickedoff">-- whereas the description of the sigma type requires binding deBruijn</span>
<span class="lineno"> 1447 </span><span class="spaces">         </span><span class="nottickedoff">-- index for that sigma type variable</span>
<span class="lineno"> 1448 </span><span class="spaces">         </span><span class="nottickedoff">tp &lt;- sigmaTypeTransM &quot;x_exsh&quot; tptrans $ \e -&gt;</span>
<span class="lineno"> 1449 </span><span class="spaces">           </span><span class="nottickedoff">inExtTransM e (openTermTypeTrans &lt;$&gt; snd &lt;$&gt;</span>
<span class="lineno"> 1450 </span><span class="spaces">                          </span><span class="nottickedoff">unETransShapeTuple &lt;$&gt; translate mb_sh)</span>
<span class="lineno"> 1451 </span><span class="spaces">         </span><span class="nottickedoff">return $ ETrans_Shape $ Just (d, tp)</span>
<span class="lineno"> 1452 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_FalseShape |] -&gt;</span>
<span class="lineno"> 1453 </span><span class="spaces">      </span><span class="nottickedoff">return $</span>
<span class="lineno"> 1454 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Shape $ Just (voidTpDesc, dataTypeOpenTerm &quot;Prelude.Void&quot; [])</span>
<span class="lineno"> 1455 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1456 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ValPerm p |] -&gt;</span>
<span class="lineno"> 1457 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Perm &lt;$&gt; descTransM (translateDescs p) &lt;*&gt; (typeTransTypes &lt;$&gt;</span>
<span class="lineno"> 1458 </span><span class="spaces">                                                         </span><span class="nottickedoff">translate p)</span></span>
<span class="lineno"> 1459 </span>
<span class="lineno"> 1460 </span>
<span class="lineno"> 1461 </span>-- LLVM field shapes translate to the list of type descriptions that the
<span class="lineno"> 1462 </span>-- permission they contain translates to
<span class="lineno"> 1463 </span>instance TransInfo info =&gt;
<span class="lineno"> 1464 </span>         Translate info ctx (LLVMFieldShape w) [OpenTerm] where
<span class="lineno"> 1465 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt; [nuMP| LLVMFieldShape p |]) =</span>
<span class="lineno"> 1466 </span><span class="spaces">    </span><span class="nottickedoff">typeTransTypes &lt;$&gt; translate p</span></span>
<span class="lineno"> 1467 </span>
<span class="lineno"> 1468 </span>-- The TranslateDescs instance for LLVM field shapes returns the type
<span class="lineno"> 1469 </span>-- descriptions associated with the contained permission
<span class="lineno"> 1470 </span>instance TranslateDescs (LLVMFieldShape w) where
<span class="lineno"> 1471 </span>  <span class="decl"><span class="nottickedoff">translateDescs (mbMatch -&gt; [nuMP| LLVMFieldShape p |]) =</span>
<span class="lineno"> 1472 </span><span class="spaces">    </span><span class="nottickedoff">translateDescs p</span></span>
<span class="lineno"> 1473 </span>
<span class="lineno"> 1474 </span>-- A sequence of expressions translates to an ExprTransCtx
<span class="lineno"> 1475 </span>instance TransInfo info =&gt;
<span class="lineno"> 1476 </span>         Translate info ctx (PermExprs as) (ExprTransCtx as) where
<span class="lineno"> 1477 </span>  <span class="decl"><span class="nottickedoff">translate mb_exprs = case mbMatch mb_exprs of</span>
<span class="lineno"> 1478 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExprs_Nil |] -&gt; return MNil</span>
<span class="lineno"> 1479 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExprs_Cons es e |] -&gt;</span>
<span class="lineno"> 1480 </span><span class="spaces">      </span><span class="nottickedoff">(:&gt;:) &lt;$&gt; translate es &lt;*&gt; translate e</span></span>
<span class="lineno"> 1481 </span>
<span class="lineno"> 1482 </span>-- A BVFactor translates to a SAW core term of bitvector type
<span class="lineno"> 1483 </span>instance TransInfo info =&gt; Translate info ctx (BVFactor w) OpenTerm where
<span class="lineno"> 1484 </span>  <span class="decl"><span class="nottickedoff">translate mb_f = case mbMatch mb_f of</span>
<span class="lineno"> 1485 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVFactor (BV.BV 1) x |] -&gt; translate1 (fmap PExpr_Var x)</span>
<span class="lineno"> 1486 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVFactor i x |] -&gt;</span>
<span class="lineno"> 1487 </span><span class="spaces">      </span><span class="nottickedoff">let w = natRepr4 x in</span>
<span class="lineno"> 1488 </span><span class="spaces">      </span><span class="nottickedoff">bvMulOpenTerm (natValue w) (bvBVOpenTerm w $ mbLift i) &lt;$&gt;</span>
<span class="lineno"> 1489 </span><span class="spaces">      </span><span class="nottickedoff">translate1 (fmap PExpr_Var x)</span></span>
<span class="lineno"> 1490 </span>
<span class="lineno"> 1491 </span>-- | Translate a bitvector constant value to a type-level expression
<span class="lineno"> 1492 </span>translateBVConstDesc :: NatRepr w -&gt; BV w -&gt; OpenTerm
<span class="lineno"> 1493 </span><span class="decl"><span class="nottickedoff">translateBVConstDesc w bv =</span>
<span class="lineno"> 1494 </span><span class="spaces">  </span><span class="nottickedoff">bvConstTpExpr (natValue w) (bvBVOpenTerm w bv)</span></span>
<span class="lineno"> 1495 </span>
<span class="lineno"> 1496 </span>-- | Translate a bitvector variable to a type-level expression
<span class="lineno"> 1497 </span>translateBVVarDesc :: NatRepr w -&gt; Mb ctx (ExprVar (BVType w)) -&gt;
<span class="lineno"> 1498 </span>                      DescTransM ctx OpenTerm
<span class="lineno"> 1499 </span><span class="decl"><span class="nottickedoff">translateBVVarDesc w mb_x = translateVarDesc mb_x &gt;&gt;= \case</span>
<span class="lineno"> 1500 </span><span class="spaces">  </span><span class="nottickedoff">Left bv -&gt; return $ bvConstTpExpr (natValue w) (transTerm1 bv)</span>
<span class="lineno"> 1501 </span><span class="spaces">  </span><span class="nottickedoff">Right (ix, [_]) -&gt; return $ varTpExpr (bvExprKind $ natValue w) ix</span>
<span class="lineno"> 1502 </span><span class="spaces">  </span><span class="nottickedoff">Right (_, ds) -&gt;</span>
<span class="lineno"> 1503 </span><span class="spaces">    </span><span class="nottickedoff">panic &quot;translateBVVarDesc&quot; [&quot;Expected one kind for variable, found &quot;</span>
<span class="lineno"> 1504 </span><span class="spaces">                                </span><span class="nottickedoff">++ show (length ds)]</span></span>
<span class="lineno"> 1505 </span>
<span class="lineno"> 1506 </span>-- | Translate a 'BVFactor' to a type-level expression
<span class="lineno"> 1507 </span>translateBVFactorDesc :: Mb ctx (BVFactor w) -&gt; DescTransM ctx OpenTerm
<span class="lineno"> 1508 </span><span class="decl"><span class="nottickedoff">translateBVFactorDesc mb_f =</span>
<span class="lineno"> 1509 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch mb_f of</span>
<span class="lineno"> 1510 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVFactor (BV.BV 1) mb_x |] -&gt;</span>
<span class="lineno"> 1511 </span><span class="spaces">      </span><span class="nottickedoff">translateBVVarDesc (natRepr4 mb_x) mb_x</span>
<span class="lineno"> 1512 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVFactor mb_i mb_x |] -&gt;</span>
<span class="lineno"> 1513 </span><span class="spaces">      </span><span class="nottickedoff">let w = natRepr4 mb_x in</span>
<span class="lineno"> 1514 </span><span class="spaces">      </span><span class="nottickedoff">bvMulTpExpr (natValue w) (translateBVConstDesc w $ mbLift mb_i) &lt;$&gt;</span>
<span class="lineno"> 1515 </span><span class="spaces">      </span><span class="nottickedoff">translateBVVarDesc w mb_x</span></span>
<span class="lineno"> 1516 </span>
<span class="lineno"> 1517 </span>-- | Translate an expression of bitvector type to a type-level expression
<span class="lineno"> 1518 </span>translateBVDesc :: KnownNat w =&gt; Mb ctx (PermExpr (BVType w)) -&gt;
<span class="lineno"> 1519 </span>                   DescTransM ctx OpenTerm
<span class="lineno"> 1520 </span><span class="decl"><span class="nottickedoff">translateBVDesc mb_e =</span>
<span class="lineno"> 1521 </span><span class="spaces">  </span><span class="nottickedoff">let w = mbExprBVTypeWidth mb_e in</span>
<span class="lineno"> 1522 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch mb_e of</span>
<span class="lineno"> 1523 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Var mb_x |] -&gt; translateBVVarDesc w mb_x</span>
<span class="lineno"> 1524 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV [] mb_off |] -&gt;</span>
<span class="lineno"> 1525 </span><span class="spaces">      </span><span class="nottickedoff">return $ translateBVConstDesc w $ mbLift mb_off</span>
<span class="lineno"> 1526 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV mb_factors (BV.BV 0) |] -&gt;</span>
<span class="lineno"> 1527 </span><span class="spaces">      </span><span class="nottickedoff">bvSumTpExprs (natValue w) &lt;$&gt;</span>
<span class="lineno"> 1528 </span><span class="spaces">      </span><span class="nottickedoff">mapM translateBVFactorDesc (mbList mb_factors)</span>
<span class="lineno"> 1529 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV mb_factors mb_off |] -&gt;</span>
<span class="lineno"> 1530 </span><span class="spaces">      </span><span class="nottickedoff">do fs_exprs &lt;- mapM translateBVFactorDesc $ mbList mb_factors</span>
<span class="lineno"> 1531 </span><span class="spaces">         </span><span class="nottickedoff">let i_expr = translateBVConstDesc w $ mbLift mb_off</span>
<span class="lineno"> 1532 </span><span class="spaces">         </span><span class="nottickedoff">return $ bvSumTpExprs (natValue w) (fs_exprs ++ [i_expr])</span></span>
<span class="lineno"> 1533 </span>
<span class="lineno"> 1534 </span>-- translateDescs on a variable translates to a list of variable kind exprs
<span class="lineno"> 1535 </span>instance TranslateDescs (ExprVar a) where
<span class="lineno"> 1536 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_x =</span>
<span class="lineno"> 1537 </span><span class="spaces">    </span><span class="nottickedoff">(dtiEvType &lt;$&gt; ask) &gt;&gt;= \ev -&gt;</span>
<span class="lineno"> 1538 </span><span class="spaces">    </span><span class="nottickedoff">translateVarDesc mb_x &gt;&gt;= \case</span>
<span class="lineno"> 1539 </span><span class="spaces">    </span><span class="nottickedoff">Left etrans -&gt; return $ let ?ev = ev in exprTransDescs etrans</span>
<span class="lineno"> 1540 </span><span class="spaces">    </span><span class="nottickedoff">Right (ix, ds) -&gt; return $ zipWith varKindExpr ds [ix..]</span></span>
<span class="lineno"> 1541 </span>
<span class="lineno"> 1542 </span>-- translateDescs on permission expressions yield a list of SAW core terms of
<span class="lineno"> 1543 </span>-- types @kindExpr K1@, @kindExpr K2@, etc., one for each kind @K@ in the list
<span class="lineno"> 1544 </span>-- of kind descriptions returned by translateType
<span class="lineno"> 1545 </span>instance TranslateDescs (PermExpr a) where
<span class="lineno"> 1546 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_e = case mbMatch mb_e of</span>
<span class="lineno"> 1547 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Var mb_x |] -&gt; translateDescs mb_x</span>
<span class="lineno"> 1548 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Unit |] -&gt; return []</span>
<span class="lineno"> 1549 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Bool b |] -&gt;</span>
<span class="lineno"> 1550 </span><span class="spaces">      </span><span class="nottickedoff">return [constTpExpr boolExprKind $ boolOpenTerm $ mbLift b]</span>
<span class="lineno"> 1551 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Nat n |] -&gt;</span>
<span class="lineno"> 1552 </span><span class="spaces">      </span><span class="nottickedoff">return [constTpExpr natExprKind $ natOpenTerm $ mbLift n]</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_String _ |] -&gt;</span>
<span class="lineno"> 1554 </span><span class="spaces">      </span><span class="nottickedoff">panic &quot;translateDescs&quot;</span>
<span class="lineno"> 1555 </span><span class="spaces">      </span><span class="nottickedoff">[&quot;Cannot (yet?) translate strings to type-level expressions&quot;]</span>
<span class="lineno"> 1556 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_BV _ _ |] -&gt; (:[]) &lt;$&gt; translateBVDesc mb_e</span>
<span class="lineno"> 1557 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Struct es |] -&gt; translateDescs es</span>
<span class="lineno"> 1558 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Always |] -&gt; return []</span>
<span class="lineno"> 1559 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_LLVMWord _ |] -&gt; return []</span>
<span class="lineno"> 1560 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_LLVMOffset _ _ |] -&gt; return []</span>
<span class="lineno"> 1561 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_Fun _ |] -&gt; return []</span>
<span class="lineno"> 1562 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PermListNil |] -&gt;</span>
<span class="lineno"> 1563 </span><span class="spaces">      </span><span class="nottickedoff">panic &quot;translateDescs&quot; [&quot;PermList type no longer supported!&quot;]</span>
<span class="lineno"> 1564 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PermListCons _ _ _ _ |] -&gt;</span>
<span class="lineno"> 1565 </span><span class="spaces">      </span><span class="nottickedoff">panic &quot;translateDescs&quot; [&quot;PermList type no longer supported!&quot;]</span>
<span class="lineno"> 1566 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_RWModality _ |] -&gt; return []</span>
<span class="lineno"> 1567 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1568 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: the cases for the shape expressions here overlap significantly with</span>
<span class="lineno"> 1569 </span><span class="spaces">    </span><span class="nottickedoff">-- those in the Translate instance for PermExpr. The difference is that</span>
<span class="lineno"> 1570 </span><span class="spaces">    </span><span class="nottickedoff">-- these cases can handle some of the expression context being deBruijn</span>
<span class="lineno"> 1571 </span><span class="spaces">    </span><span class="nottickedoff">-- indices instead of ExprTranss, by virtue of the fact that here we only</span>
<span class="lineno"> 1572 </span><span class="spaces">    </span><span class="nottickedoff">-- return the type descriptions and not the types.</span>
<span class="lineno"> 1573 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 1574 </span><span class="spaces">    </span><span class="nottickedoff">-- Also note that shapes translate to 0 or 1 types and type descriptions, so</span>
<span class="lineno"> 1575 </span><span class="spaces">    </span><span class="nottickedoff">-- translateDescs will always return an empty or one-element list for shpaes</span>
<span class="lineno"> 1576 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_EmptyShape |] -&gt; return []</span>
<span class="lineno"> 1577 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_NamedShape _ _ nmsh args |] -&gt;</span>
<span class="lineno"> 1578 </span><span class="spaces">      </span><span class="nottickedoff">case mbMatch $ fmap namedShapeBody nmsh of</span>
<span class="lineno"> 1579 </span><span class="spaces">        </span><span class="nottickedoff">[nuMP| DefinedShapeBody _ |] -&gt;</span>
<span class="lineno"> 1580 </span><span class="spaces">          </span><span class="nottickedoff">translateDescs (mbMap2 unfoldNamedShape nmsh args)</span>
<span class="lineno"> 1581 </span><span class="spaces">        </span><span class="nottickedoff">[nuMP| OpaqueShapeBody _ _ desc_id |] -&gt;</span>
<span class="lineno"> 1582 </span><span class="spaces">          </span><span class="nottickedoff">do ev &lt;- dtiEvType &lt;$&gt; ask</span>
<span class="lineno"> 1583 </span><span class="spaces">             </span><span class="nottickedoff">let (_, k_ds) =</span>
<span class="lineno"> 1584 </span><span class="spaces">                   </span><span class="nottickedoff">let ?ev = ev in</span>
<span class="lineno"> 1585 </span><span class="spaces">                   </span><span class="nottickedoff">translateCruCtx (mbLift $ fmap namedShapeArgs nmsh)</span>
<span class="lineno"> 1586 </span><span class="spaces">             </span><span class="nottickedoff">args_ds &lt;- translateDescs args</span>
<span class="lineno"> 1587 </span><span class="spaces">             </span><span class="nottickedoff">return [substIdTpDescMulti (mbLift desc_id) k_ds args_ds]</span>
<span class="lineno"> 1588 </span><span class="spaces">        </span><span class="nottickedoff">[nuMP| RecShapeBody _ _ desc_id |] -&gt;</span>
<span class="lineno"> 1589 </span><span class="spaces">          </span><span class="nottickedoff">do ev &lt;- dtiEvType &lt;$&gt; ask</span>
<span class="lineno"> 1590 </span><span class="spaces">             </span><span class="nottickedoff">let (_, k_ds) =</span>
<span class="lineno"> 1591 </span><span class="spaces">                   </span><span class="nottickedoff">let ?ev = ev in</span>
<span class="lineno"> 1592 </span><span class="spaces">                   </span><span class="nottickedoff">translateCruCtx (mbLift $ fmap namedShapeArgs nmsh)</span>
<span class="lineno"> 1593 </span><span class="spaces">             </span><span class="nottickedoff">args_ds &lt;- translateDescs args</span>
<span class="lineno"> 1594 </span><span class="spaces">             </span><span class="nottickedoff">return [substIndIdTpDescMulti (mbLift desc_id) k_ds args_ds]</span>
<span class="lineno"> 1595 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_EqShape _ _ |] -&gt; return []</span>
<span class="lineno"> 1596 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_PtrShape _ _ sh |] -&gt; translateDescs sh</span>
<span class="lineno"> 1597 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_FieldShape fsh |] -&gt; tupleTpDescList &lt;$&gt; translateDescs fsh</span>
<span class="lineno"> 1598 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ArrayShape mb_len _ mb_sh |] -&gt;</span>
<span class="lineno"> 1599 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 mb_len</span>
<span class="lineno"> 1600 </span><span class="spaces">         </span><span class="nottickedoff">let w_term = natOpenTerm w</span>
<span class="lineno"> 1601 </span><span class="spaces">         </span><span class="nottickedoff">len_term &lt;- translateBVDesc mb_len</span>
<span class="lineno"> 1602 </span><span class="spaces">         </span><span class="nottickedoff">elem_d &lt;- translateDesc mb_sh</span>
<span class="lineno"> 1603 </span><span class="spaces">         </span><span class="nottickedoff">return [bvVecTpDesc w_term len_term elem_d]</span>
<span class="lineno"> 1604 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_TupShape sh |] -&gt;</span>
<span class="lineno"> 1605 </span><span class="spaces">      </span><span class="nottickedoff">(:[]) &lt;$&gt; tupleTpDesc &lt;$&gt; translateDescs sh</span>
<span class="lineno"> 1606 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_SeqShape sh1 sh2 |] -&gt;</span>
<span class="lineno"> 1607 </span><span class="spaces">      </span><span class="nottickedoff">do ds1 &lt;- translateDescs sh1</span>
<span class="lineno"> 1608 </span><span class="spaces">         </span><span class="nottickedoff">ds2 &lt;- translateDescs sh2</span>
<span class="lineno"> 1609 </span><span class="spaces">         </span><span class="nottickedoff">-- Since both ds1 and ds2 have length at most 1, the below is the same</span>
<span class="lineno"> 1610 </span><span class="spaces">         </span><span class="nottickedoff">-- as choosing one list if the other is empty and pairing the two if</span>
<span class="lineno"> 1611 </span><span class="spaces">         </span><span class="nottickedoff">-- they both have 1 element</span>
<span class="lineno"> 1612 </span><span class="spaces">         </span><span class="nottickedoff">return $ tupleTpDescList (ds1 ++ ds2)</span>
<span class="lineno"> 1613 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_OrShape sh1 sh2 |] -&gt;</span>
<span class="lineno"> 1614 </span><span class="spaces">      </span><span class="nottickedoff">(\d -&gt; [d]) &lt;$&gt; (sumTpDesc &lt;$&gt; translateDesc sh1 &lt;*&gt; translateDesc sh2)</span>
<span class="lineno"> 1615 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ExShape mb_sh |] -&gt;</span>
<span class="lineno"> 1616 </span><span class="spaces">      </span><span class="nottickedoff">let tp = mbLift $ fmap bindingType mb_sh in</span>
<span class="lineno"> 1617 </span><span class="spaces">      </span><span class="nottickedoff">inExtCtxDescTransM (singletonCruCtx tp) $ \kdescs -&gt;</span>
<span class="lineno"> 1618 </span><span class="spaces">      </span><span class="nottickedoff">(\d -&gt; [d]) &lt;$&gt; sigmaTpDescMulti kdescs &lt;$&gt;</span>
<span class="lineno"> 1619 </span><span class="spaces">      </span><span class="nottickedoff">translateDesc (mbCombine RL.typeCtxProxies mb_sh)</span>
<span class="lineno"> 1620 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_FalseShape |] -&gt; return [voidTpDesc]</span>
<span class="lineno"> 1621 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1622 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PExpr_ValPerm mb_p |] -&gt; translateDescs mb_p</span></span>
<span class="lineno"> 1623 </span>
<span class="lineno"> 1624 </span>
<span class="lineno"> 1625 </span>instance TranslateDescs (PermExprs tps) where
<span class="lineno"> 1626 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_es = case mbMatch mb_es of</span>
<span class="lineno"> 1627 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MNil |] -&gt; return []</span>
<span class="lineno"> 1628 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| es :&gt;: e |] -&gt; (++) &lt;$&gt; translateDescs es &lt;*&gt; translateDescs e</span></span>
<span class="lineno"> 1629 </span>
<span class="lineno"> 1630 </span>
<span class="lineno"> 1631 </span>-- | Build the type description that substitutes the translations of the
<span class="lineno"> 1632 </span>-- supplied arguments into a type description for the body of an inductive type
<span class="lineno"> 1633 </span>-- description. That is, for inductive type description @Tp_Ind T@, return the
<span class="lineno"> 1634 </span>-- substitution instance @[args/xs]T@. Note that @T@ is expected to have
<span class="lineno"> 1635 </span>-- deBruijn index 0 free, to represent resursive occurrences of the inductive
<span class="lineno"> 1636 </span>-- type, and this substitution should preserve that, leaving index 0 free.
<span class="lineno"> 1637 </span>substNamedIndTpDesc :: TransInfo info =&gt; Ident -&gt;
<span class="lineno"> 1638 </span>                       CruCtx tps -&gt; Mb ctx (PermExprs tps) -&gt;
<span class="lineno"> 1639 </span>                       TransM info ctx OpenTerm
<span class="lineno"> 1640 </span><span class="decl"><span class="nottickedoff">substNamedIndTpDesc d_id tps args =</span>
<span class="lineno"> 1641 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 1642 </span><span class="spaces">     </span><span class="nottickedoff">let ks = let ?ev = ev in snd $ translateCruCtx tps</span>
<span class="lineno"> 1643 </span><span class="spaces">     </span><span class="nottickedoff">args_exprs &lt;- descTransM $ translateDescs args</span>
<span class="lineno"> 1644 </span><span class="spaces">     </span><span class="nottickedoff">return $ substEnvTpDesc 1 (zip ks args_exprs) (globalOpenTerm d_id)</span></span>
<span class="lineno"> 1645 </span>
<span class="lineno"> 1646 </span>
<span class="lineno"> 1647 </span>----------------------------------------------------------------------
<span class="lineno"> 1648 </span>-- * Permission Translations
<span class="lineno"> 1649 </span>----------------------------------------------------------------------
<span class="lineno"> 1650 </span>
<span class="lineno"> 1651 </span>-- | The result of translating a \&quot;proof element\&quot; of a permission of type
<span class="lineno"> 1652 </span>-- @'ValuePerm' a@. The idea here is that, for a permission implication or typed
<span class="lineno"> 1653 </span>-- statement that consumes or emits permission @p@, the translation consumes or
<span class="lineno"> 1654 </span>-- emits an element of the SAW type @'translate' p@.
<span class="lineno"> 1655 </span>--
<span class="lineno"> 1656 </span>-- Another way to look at a @'PermTrans'@ for permission @p@ is that it is a
<span class="lineno"> 1657 </span>-- partially static representation (in the sense of the partial evaluation
<span class="lineno"> 1658 </span>-- literature) of a SAW expression of type @'translate' p@. Note that we do
<span class="lineno"> 1659 </span>-- not include special representations for disjunctions, existentials, or
<span class="lineno"> 1660 </span>-- recursive permissions, however, because our type-checker does not
<span class="lineno"> 1661 </span>-- generally introduce these forms as intermediate values.
<span class="lineno"> 1662 </span>data PermTrans (ctx :: RList CrucibleType) (a :: CrucibleType) where
<span class="lineno"> 1663 </span>  -- | An @eq(e)@ permission has no computational content
<span class="lineno"> 1664 </span>  PTrans_Eq :: Mb ctx (PermExpr a) -&gt; PermTrans ctx a
<span class="lineno"> 1665 </span>
<span class="lineno"> 1666 </span>  -- | A conjuction of atomic permission translations
<span class="lineno"> 1667 </span>  PTrans_Conj :: [AtomicPermTrans ctx a] -&gt; PermTrans ctx a
<span class="lineno"> 1668 </span>
<span class="lineno"> 1669 </span>  -- | The translation of a defined permission is a wrapper around the
<span class="lineno"> 1670 </span>  -- translation of what it is defined as
<span class="lineno"> 1671 </span>  PTrans_Defined :: NamedPermName (DefinedSort b) args a -&gt;
<span class="lineno"> 1672 </span>                    Mb ctx (PermExprs args) -&gt; Mb ctx (PermOffset a) -&gt;
<span class="lineno"> 1673 </span>                    PermTrans ctx a -&gt; PermTrans ctx a
<span class="lineno"> 1674 </span>
<span class="lineno"> 1675 </span>  -- | The translation for disjunctive, existential, and named permissions
<span class="lineno"> 1676 </span>  PTrans_Term :: Mb ctx (ValuePerm a) -&gt; OpenTerm -&gt; PermTrans ctx a
<span class="lineno"> 1677 </span>
<span class="lineno"> 1678 </span>
<span class="lineno"> 1679 </span>-- | The 'PermTrans' type for atomic permissions
<span class="lineno"> 1680 </span>data AtomicPermTrans ctx a where
<span class="lineno"> 1681 </span>
<span class="lineno"> 1682 </span>  -- | The translation of an LLVM field permission is just the translation of
<span class="lineno"> 1683 </span>  -- its contents
<span class="lineno"> 1684 </span>  APTrans_LLVMField :: (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1685 </span>                       Mb ctx (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 1686 </span>                       PermTrans ctx (LLVMPointerType sz) -&gt;
<span class="lineno"> 1687 </span>                       AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1688 </span>
<span class="lineno"> 1689 </span>  -- | LLVM array permisions are translated to an 'LLVMArrayPermTrans'
<span class="lineno"> 1690 </span>  APTrans_LLVMArray :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1691 </span>                       LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 1692 </span>                       AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1693 </span>
<span class="lineno"> 1694 </span>  -- | The translation of an LLVM block permission is an element of the
<span class="lineno"> 1695 </span>  -- translation of its shape to a type or 'Nothing' if the shape translates to
<span class="lineno"> 1696 </span>  -- no types
<span class="lineno"> 1697 </span>  APTrans_LLVMBlock :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1698 </span>                       Mb ctx (LLVMBlockPerm w) -&gt; Maybe OpenTerm -&gt;
<span class="lineno"> 1699 </span>                       AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1700 </span>
<span class="lineno"> 1701 </span>  -- | LLVM free permissions have no computational content
<span class="lineno"> 1702 </span>  APTrans_LLVMFree :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1703 </span>                      Mb ctx (PermExpr (BVType w)) -&gt;
<span class="lineno"> 1704 </span>                      AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1705 </span>
<span class="lineno"> 1706 </span>  -- | LLVM function pointer permissions have the same computational content as
<span class="lineno"> 1707 </span>  -- a function permission
<span class="lineno"> 1708 </span>  APTrans_LLVMFunPtr :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1709 </span>                        TypeRepr (FunctionHandleType cargs ret) -&gt;
<span class="lineno"> 1710 </span>                        PermTrans ctx (FunctionHandleType cargs ret) -&gt;
<span class="lineno"> 1711 </span>                        AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1712 </span>
<span class="lineno"> 1713 </span>  -- | IsLLVMPtr permissions have no computational content
<span class="lineno"> 1714 </span>  APTrans_IsLLVMPtr :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1715 </span>                       AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1716 </span>
<span class="lineno"> 1717 </span>  -- | The translation of an LLVMBlockShape permission is an element of the
<span class="lineno"> 1718 </span>  -- translation of its shape to a type or 'Nothing' if the shape translates to
<span class="lineno"> 1719 </span>  -- no types
<span class="lineno"> 1720 </span>  APTrans_LLVMBlockShape :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1721 </span>                            Mb ctx (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno"> 1722 </span>                            Maybe OpenTerm -&gt;
<span class="lineno"> 1723 </span>                            AtomicPermTrans ctx (LLVMBlockType w)
<span class="lineno"> 1724 </span>
<span class="lineno"> 1725 </span>  -- | Perm_NamedConj permissions are a permission + a term
<span class="lineno"> 1726 </span>  APTrans_NamedConj :: NameSortIsConj ns ~ 'True =&gt;
<span class="lineno"> 1727 </span>                       NamedPermName ns args a -&gt; Mb ctx (PermExprs args) -&gt;
<span class="lineno"> 1728 </span>                       Mb ctx (PermOffset a) -&gt; OpenTerm -&gt;
<span class="lineno"> 1729 </span>                       AtomicPermTrans ctx a
<span class="lineno"> 1730 </span>
<span class="lineno"> 1731 </span>  -- | Defined Perm_NamedConj permissions are just a wrapper around the
<span class="lineno"> 1732 </span>  -- translation of the permission definition
<span class="lineno"> 1733 </span>  APTrans_DefinedNamedConj :: NamedPermName (DefinedSort 'True) args a -&gt;
<span class="lineno"> 1734 </span>                              Mb ctx (PermExprs args) -&gt;
<span class="lineno"> 1735 </span>                              Mb ctx (PermOffset a) -&gt;
<span class="lineno"> 1736 </span>                              PermTrans ctx a -&gt;
<span class="lineno"> 1737 </span>                              AtomicPermTrans ctx a
<span class="lineno"> 1738 </span>
<span class="lineno"> 1739 </span>  -- | LLVM frame permissions have no computational content
<span class="lineno"> 1740 </span>  APTrans_LLVMFrame :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1741 </span>                       Mb ctx (LLVMFramePerm w) -&gt;
<span class="lineno"> 1742 </span>                       AtomicPermTrans ctx (LLVMFrameType w)
<span class="lineno"> 1743 </span>
<span class="lineno"> 1744 </span>  -- | @lowned@ permissions translate to a monadic function from (the
<span class="lineno"> 1745 </span>  -- translation of) the input permissions to the output permissions
<span class="lineno"> 1746 </span>  APTrans_LOwned ::
<span class="lineno"> 1747 </span>    Mb ctx [PermExpr LifetimeType] -&gt; CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 1748 </span>    Mb ctx (ExprPerms ps_in) -&gt; Mb ctx (ExprPerms ps_out) -&gt;
<span class="lineno"> 1749 </span>    LOwnedTrans ctx ps_extra ps_in ps_out -&gt;
<span class="lineno"> 1750 </span>    AtomicPermTrans ctx LifetimeType
<span class="lineno"> 1751 </span>
<span class="lineno"> 1752 </span>  -- | Simple @lowned@ permissions have no translation, because they represent
<span class="lineno"> 1753 </span>  -- @lowned@ permissions whose translations are just the identity function
<span class="lineno"> 1754 </span>  APTrans_LOwnedSimple :: CruCtx ps -&gt; Mb ctx (ExprPerms ps) -&gt;
<span class="lineno"> 1755 </span>                          AtomicPermTrans ctx LifetimeType
<span class="lineno"> 1756 </span>
<span class="lineno"> 1757 </span>  -- | LCurrent permissions have no computational content
<span class="lineno"> 1758 </span>  APTrans_LCurrent :: Mb ctx (PermExpr LifetimeType) -&gt;
<span class="lineno"> 1759 </span>                      AtomicPermTrans ctx LifetimeType
<span class="lineno"> 1760 </span>
<span class="lineno"> 1761 </span>  -- | LFinished permissions have no computational content
<span class="lineno"> 1762 </span>  APTrans_LFinished :: AtomicPermTrans ctx LifetimeType
<span class="lineno"> 1763 </span>
<span class="lineno"> 1764 </span>  -- | The translation of a struct permission is sequence of the translations of
<span class="lineno"> 1765 </span>  -- the permissions in the struct permission
<span class="lineno"> 1766 </span>  APTrans_Struct :: PermTransCtx ctx (CtxToRList args) -&gt;
<span class="lineno"> 1767 </span>                    AtomicPermTrans ctx (StructType args)
<span class="lineno"> 1768 </span>
<span class="lineno"> 1769 </span>  -- | The translation of functional permission is a SAW term of @specFun@ type
<span class="lineno"> 1770 </span>  APTrans_Fun :: Mb ctx (FunPerm ghosts (CtxToRList cargs) gouts ret) -&gt;
<span class="lineno"> 1771 </span>                 FunTrans -&gt; AtomicPermTrans ctx (FunctionHandleType cargs ret)
<span class="lineno"> 1772 </span>
<span class="lineno"> 1773 </span>  -- | Propositional permissions are represented by a SAW term
<span class="lineno"> 1774 </span>  APTrans_BVProp :: (1 &lt;= w, KnownNat w) =&gt; BVPropTrans ctx w -&gt;
<span class="lineno"> 1775 </span>                    AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1776 </span>
<span class="lineno"> 1777 </span>  -- | Any permissions have no SAW terms
<span class="lineno"> 1778 </span>  APTrans_Any :: AtomicPermTrans ctx a
<span class="lineno"> 1779 </span>
<span class="lineno"> 1780 </span>
<span class="lineno"> 1781 </span>-- | The translation of a proof of a 'BVProp'
<span class="lineno"> 1782 </span>data BVPropTrans ctx w = BVPropTrans (Mb ctx (BVProp w)) OpenTerm
<span class="lineno"> 1783 </span>
<span class="lineno"> 1784 </span>-- | Build the translation of a 'BVProp' permission from a proof of it
<span class="lineno"> 1785 </span>bvPropPerm :: (1 &lt;= w, KnownNat w) =&gt; BVPropTrans ctx w -&gt;
<span class="lineno"> 1786 </span>              PermTrans ctx (LLVMPointerType w)
<span class="lineno"> 1787 </span><span class="decl"><span class="nottickedoff">bvPropPerm prop = PTrans_Conj [APTrans_BVProp prop]</span></span>
<span class="lineno"> 1788 </span>
<span class="lineno"> 1789 </span>-- | The translation of a 'BVRange' is the translation of its two elements
<span class="lineno"> 1790 </span>data BVRangeTrans ctx w =
<span class="lineno"> 1791 </span>  BVRangeTrans (Mb ctx (BVRange w))
<span class="lineno"> 1792 </span>  (ExprTrans (BVType w)) (ExprTrans (BVType w))
<span class="lineno"> 1793 </span>
<span class="lineno"> 1794 </span>-- | Extract the translation of the offset from the translation of a 'BVRange'
<span class="lineno"> 1795 </span>bvRangeTransOff :: BVRangeTrans ctx w -&gt; ExprTrans (BVType w)
<span class="lineno"> 1796 </span><span class="decl"><span class="nottickedoff">bvRangeTransOff (BVRangeTrans _ off _) = off</span></span>
<span class="lineno"> 1797 </span>
<span class="lineno"> 1798 </span>-- | Extract the translation of the length from the translation of a 'BVRange'
<span class="lineno"> 1799 </span>bvRangeTransLen :: BVRangeTrans ctx w -&gt; ExprTrans (BVType w)
<span class="lineno"> 1800 </span><span class="decl"><span class="nottickedoff">bvRangeTransLen (BVRangeTrans _ _ len) = len</span></span>
<span class="lineno"> 1801 </span>
<span class="lineno"> 1802 </span>-- | The translation of the vacuously true permission
<span class="lineno"> 1803 </span>pattern PTrans_True :: PermTrans ctx a
<span class="lineno"> 1804 </span>pattern PTrans_True = <span class="nottickedoff">PTrans_Conj []</span>
<span class="lineno"> 1805 </span>
<span class="lineno"> 1806 </span>-- | A single @lowned@ permission translation
<span class="lineno"> 1807 </span>pattern PTrans_LOwned ::
<span class="lineno"> 1808 </span>  () =&gt; (a ~ LifetimeType) =&gt;
<span class="lineno"> 1809 </span>  Mb ctx [PermExpr LifetimeType] -&gt; CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 1810 </span>  Mb ctx (ExprPerms ps_in) -&gt; Mb ctx (ExprPerms ps_out) -&gt;
<span class="lineno"> 1811 </span>  LOwnedTrans ctx ps_extra ps_in ps_out -&gt;
<span class="lineno"> 1812 </span>  PermTrans ctx a
<span class="lineno"> 1813 </span>pattern PTrans_LOwned mb_ls tps_in tps_out mb_ps_in mb_ps_out t =
<span class="lineno"> 1814 </span>  <span class="nottickedoff">PTrans_Conj [APTrans_LOwned mb_ls tps_in tps_out mb_ps_in mb_ps_out t]</span>
<span class="lineno"> 1815 </span>
<span class="lineno"> 1816 </span>-- | A single function permission
<span class="lineno"> 1817 </span>pattern PTrans_Fun :: () =&gt; (a ~ FunctionHandleType cargs ret) =&gt;
<span class="lineno"> 1818 </span>                      Mb ctx (FunPerm ghosts (CtxToRList cargs) gouts ret) -&gt;
<span class="lineno"> 1819 </span>                      FunTrans -&gt; PermTrans ctx a
<span class="lineno"> 1820 </span>pattern PTrans_Fun mb_fun_perm tr = <span class="nottickedoff">PTrans_Conj [APTrans_Fun mb_fun_perm tr]</span>
<span class="lineno"> 1821 </span>
<span class="lineno"> 1822 </span>-- | The translation of a function permission to a term of type @specFun E T@
<span class="lineno"> 1823 </span>-- for some type description @T@
<span class="lineno"> 1824 </span>--
<span class="lineno"> 1825 </span>-- FIXME: do we even need the type description or event type?
<span class="lineno"> 1826 </span>data FunTrans =
<span class="lineno"> 1827 </span>  FunTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">funTransEv</span></span></span> :: EventType,
<span class="lineno"> 1828 </span>             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">funTransTpDesc</span></span></span> :: OpenTerm,
<span class="lineno"> 1829 </span>             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">funTransTerm</span></span></span> :: OpenTerm }
<span class="lineno"> 1830 </span>
<span class="lineno"> 1831 </span>-- | Apply a 'FunTransTerm' to a list of arguments
<span class="lineno"> 1832 </span>applyFunTrans :: FunTrans -&gt; [OpenTerm] -&gt; OpenTerm
<span class="lineno"> 1833 </span><span class="decl"><span class="nottickedoff">applyFunTrans f = applyOpenTermMulti (funTransTerm f)</span></span>
<span class="lineno"> 1834 </span>
<span class="lineno"> 1835 </span>-- | Build a type translation for a disjunctive, existential, or named
<span class="lineno"> 1836 </span>-- permission that uses the 'PTrans_Term' constructor
<span class="lineno"> 1837 </span>mkPermTypeTrans1 :: Mb ctx (ValuePerm a) -&gt; OpenTerm -&gt;
<span class="lineno"> 1838 </span>                    TypeTrans (PermTrans ctx a)
<span class="lineno"> 1839 </span><span class="decl"><span class="nottickedoff">mkPermTypeTrans1 mb_p tp = mkTypeTrans1 tp (PTrans_Term mb_p)</span></span>
<span class="lineno"> 1840 </span>
<span class="lineno"> 1841 </span>-- | Extract the body of a conjunction or raise an error
<span class="lineno"> 1842 </span>unPTransConj :: String -&gt; PermTrans ctx a -&gt; [AtomicPermTrans ctx a]
<span class="lineno"> 1843 </span><span class="decl"><span class="nottickedoff">unPTransConj _ (PTrans_Conj ps) = ps</span>
<span class="lineno"> 1844 </span><span class="spaces"></span><span class="nottickedoff">unPTransConj str _ = error (str ++ &quot;: not a conjunction&quot;)</span></span>
<span class="lineno"> 1845 </span>
<span class="lineno"> 1846 </span>-- | Extract the body of a conjunction, which should have exactly one conjunct,
<span class="lineno"> 1847 </span>-- or raise an error
<span class="lineno"> 1848 </span>unPTransConj1 :: String -&gt; PermTrans ctx a -&gt; AtomicPermTrans ctx a
<span class="lineno"> 1849 </span><span class="decl"><span class="nottickedoff">unPTransConj1 str ptrans =</span>
<span class="lineno"> 1850 </span><span class="spaces">  </span><span class="nottickedoff">case unPTransConj str ptrans of</span>
<span class="lineno"> 1851 </span><span class="spaces">    </span><span class="nottickedoff">[aptrans] -&gt; aptrans</span>
<span class="lineno"> 1852 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error (str ++ &quot;: not a single-element conjunction&quot;)</span></span>
<span class="lineno"> 1853 </span>
<span class="lineno"> 1854 </span>-- | Extract out a list of proofs of 'BVProp's from a proof of a conjunction
<span class="lineno"> 1855 </span>unPTransBVProps :: String -&gt; PermTrans ctx (LLVMPointerType w) -&gt;
<span class="lineno"> 1856 </span>                   [BVPropTrans ctx w]
<span class="lineno"> 1857 </span><span class="decl"><span class="nottickedoff">unPTransBVProps _ ptrans</span>
<span class="lineno"> 1858 </span><span class="spaces">  </span><span class="nottickedoff">| PTrans_Conj ps &lt;- ptrans</span>
<span class="lineno"> 1859 </span><span class="spaces">  </span><span class="nottickedoff">, Just transs &lt;- mapM (\ap -&gt; case ap of</span>
<span class="lineno"> 1860 </span><span class="spaces">                            </span><span class="nottickedoff">APTrans_BVProp p -&gt; Just p</span>
<span class="lineno"> 1861 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; Nothing) ps</span>
<span class="lineno"> 1862 </span><span class="spaces">  </span><span class="nottickedoff">= transs</span>
<span class="lineno"> 1863 </span><span class="spaces"></span><span class="nottickedoff">unPTransBVProps str _ = error (str ++ &quot;: not a list of BVProp permissions&quot;)</span></span>
<span class="lineno"> 1864 </span>
<span class="lineno"> 1865 </span>-- | Extract the body of a conjunction of a single field permission
<span class="lineno"> 1866 </span>unPTransLLVMField :: String -&gt; NatRepr sz -&gt;
<span class="lineno"> 1867 </span>                     PermTrans ctx (LLVMPointerType w) -&gt;
<span class="lineno"> 1868 </span>                     (Mb ctx (LLVMFieldPerm w sz),
<span class="lineno"> 1869 </span>                      PermTrans ctx (LLVMPointerType sz))
<span class="lineno"> 1870 </span><span class="decl"><span class="nottickedoff">unPTransLLVMField _ sz (PTrans_Conj [APTrans_LLVMField mb_fp ptrans])</span>
<span class="lineno"> 1871 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality sz (mbLift $ fmap llvmFieldSize mb_fp)</span>
<span class="lineno"> 1872 </span><span class="spaces">  </span><span class="nottickedoff">= (mb_fp, ptrans)</span>
<span class="lineno"> 1873 </span><span class="spaces"></span><span class="nottickedoff">unPTransLLVMField str _ _ =</span>
<span class="lineno"> 1874 </span><span class="spaces">  </span><span class="nottickedoff">error (str ++ &quot;: not an LLVM field permission of the required size&quot;)</span></span>
<span class="lineno"> 1875 </span>
<span class="lineno"> 1876 </span>-- | Extract the body of a conjunction of a single array permission
<span class="lineno"> 1877 </span>unPTransLLVMArray :: String -&gt; PermTrans ctx (LLVMPointerType w) -&gt;
<span class="lineno"> 1878 </span>                     LLVMArrayPermTrans ctx w
<span class="lineno"> 1879 </span><span class="decl"><span class="nottickedoff">unPTransLLVMArray _ (PTrans_Conj [APTrans_LLVMArray aptrans]) = aptrans</span>
<span class="lineno"> 1880 </span><span class="spaces"></span><span class="nottickedoff">unPTransLLVMArray str _ = error (str ++ &quot;: not an LLVM array permission&quot;)</span></span>
<span class="lineno"> 1881 </span>
<span class="lineno"> 1882 </span>data SomeLOwnedTrans ctx ps_in ps_out =
<span class="lineno"> 1883 </span>  forall ps_extra. SomeLOwnedTrans (LOwnedTrans ctx ps_extra ps_in ps_out)
<span class="lineno"> 1884 </span>
<span class="lineno"> 1885 </span>-- | Extract the 'LOwnedTrans' of a conjunction of a single @lowned@ permission
<span class="lineno"> 1886 </span>-- with the specified input and output types
<span class="lineno"> 1887 </span>unPTransLOwned :: String -&gt; Mb ctx (CruCtx ps_in) -&gt; Mb ctx (CruCtx ps_out) -&gt;
<span class="lineno"> 1888 </span>                  PermTrans ctx LifetimeType -&gt;
<span class="lineno"> 1889 </span>                  SomeLOwnedTrans ctx ps_in ps_out
<span class="lineno"> 1890 </span><span class="decl"><span class="nottickedoff">unPTransLOwned _ tps_in tps_out</span>
<span class="lineno"> 1891 </span><span class="spaces">  </span><span class="nottickedoff">(PTrans_LOwned _ (testEquality (mbLift tps_in) -&gt; Just Refl)</span>
<span class="lineno"> 1892 </span><span class="spaces">   </span><span class="nottickedoff">(testEquality (mbLift tps_out) -&gt; Just Refl) _ _ lotr)</span>
<span class="lineno"> 1893 </span><span class="spaces">  </span><span class="nottickedoff">= SomeLOwnedTrans lotr</span>
<span class="lineno"> 1894 </span><span class="spaces"></span><span class="nottickedoff">unPTransLOwned fname _ _ _ =</span>
<span class="lineno"> 1895 </span><span class="spaces">  </span><span class="nottickedoff">panic fname [&quot;Expected lowned permission&quot;]</span></span>
<span class="lineno"> 1896 </span>
<span class="lineno"> 1897 </span>-- | A context mapping bound names to their perm translations
<span class="lineno"> 1898 </span>type PermTransCtx ctx ps = RAssign (PermTrans ctx) ps
<span class="lineno"> 1899 </span>
<span class="lineno"> 1900 </span>-- | A 'DescTypeTrans' yielding a single 'PermTrans'
<span class="lineno"> 1901 </span>type Desc1PermTpTrans ctx a = DescTypeTrans (PermTrans ctx a)
<span class="lineno"> 1902 </span>
<span class="lineno"> 1903 </span>-- | A 'DescTypeTrans' yielding a 'PermTransCtx'
<span class="lineno"> 1904 </span>type DescPermsTpTrans ctx ps = DescTypeTrans (PermTransCtx ctx ps)
<span class="lineno"> 1905 </span>
<span class="lineno"> 1906 </span>-- | Prepand an empty list of permissions to a 'DescPermsTpTrans'
<span class="lineno"> 1907 </span>preNilDescPermsTpTrans :: DescPermsTpTrans ctx ps -&gt;
<span class="lineno"> 1908 </span>                          DescPermsTpTrans ctx (RNil :++: ps)
<span class="lineno"> 1909 </span><span class="decl"><span class="nottickedoff">preNilDescPermsTpTrans = App.liftA2 RL.append (pure MNil)</span></span>
<span class="lineno"> 1910 </span>
<span class="lineno"> 1911 </span>-- | Build a permission translation context with just @true@ permissions
<span class="lineno"> 1912 </span>truePermTransCtx :: CruCtx ps -&gt; PermTransCtx ctx ps
<span class="lineno"> 1913 </span><span class="decl"><span class="nottickedoff">truePermTransCtx CruCtxNil = MNil</span>
<span class="lineno"> 1914 </span><span class="spaces"></span><span class="nottickedoff">truePermTransCtx (CruCtxCons ctx _) = truePermTransCtx ctx :&gt;: PTrans_True</span></span>
<span class="lineno"> 1915 </span>
<span class="lineno"> 1916 </span>-- | Build a permission translation context with equality permissions
<span class="lineno"> 1917 </span>eqPermTransCtx :: forall (ctx :: RList CrucibleType) (ps :: RList CrucibleType) any.
<span class="lineno"> 1918 </span>                  RAssign any ctx -&gt; RAssign (Member ctx) ps -&gt;
<span class="lineno"> 1919 </span>                  PermTransCtx ctx ps
<span class="lineno"> 1920 </span><span class="decl"><span class="nottickedoff">eqPermTransCtx ns =</span>
<span class="lineno"> 1921 </span><span class="spaces">  </span><span class="nottickedoff">RL.map (\memb -&gt; PTrans_Eq $ nuMulti (RL.map (\_-&gt; Proxy) ns) (PExpr_Var . RL.get memb))</span></span>
<span class="lineno"> 1922 </span>
<span class="lineno"> 1923 </span>
<span class="lineno"> 1924 </span>instance IsTermTrans (PermTrans ctx a) where
<span class="lineno"> 1925 </span>  <span class="decl"><span class="nottickedoff">transTerms (PTrans_Eq _) = []</span>
<span class="lineno"> 1926 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (PTrans_Conj aps) = transTerms aps</span>
<span class="lineno"> 1927 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (PTrans_Defined _ _ _ ptrans) = transTerms ptrans</span>
<span class="lineno"> 1928 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (PTrans_Term _ t) = [t]</span></span>
<span class="lineno"> 1929 </span>
<span class="lineno"> 1930 </span>instance IsTermTrans (PermTransCtx ctx ps) where
<span class="lineno"> 1931 </span>  <span class="decl"><span class="nottickedoff">transTerms = concat . RL.mapToList transTerms</span></span>
<span class="lineno"> 1932 </span>
<span class="lineno"> 1933 </span>instance IsTermTrans (AtomicPermTrans ctx a) where
<span class="lineno"> 1934 </span>  <span class="decl"><span class="nottickedoff">transTerms (APTrans_LLVMField _ ptrans) = transTerms ptrans</span>
<span class="lineno"> 1935 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LLVMArray arr_trans) = transTerms arr_trans</span>
<span class="lineno"> 1936 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LLVMBlock _ ts) = maybeToList ts</span>
<span class="lineno"> 1937 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LLVMFree _) = []</span>
<span class="lineno"> 1938 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LLVMFunPtr _ trans) = transTerms trans</span>
<span class="lineno"> 1939 </span><span class="spaces">  </span><span class="nottickedoff">transTerms APTrans_IsLLVMPtr = []</span>
<span class="lineno"> 1940 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LLVMBlockShape _ ts) = maybeToList ts</span>
<span class="lineno"> 1941 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_NamedConj _ _ _ t) = [t]</span>
<span class="lineno"> 1942 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_DefinedNamedConj _ _ _ ptrans) = transTerms ptrans</span>
<span class="lineno"> 1943 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LLVMFrame _) = []</span>
<span class="lineno"> 1944 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LOwned _ _ _ eps_in _ lotr) =</span>
<span class="lineno"> 1945 </span><span class="spaces">    </span><span class="nottickedoff">[lownedTransTerm eps_in lotr]</span>
<span class="lineno"> 1946 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LOwnedSimple _ _) = []</span>
<span class="lineno"> 1947 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_LCurrent _) = []</span>
<span class="lineno"> 1948 </span><span class="spaces">  </span><span class="nottickedoff">transTerms APTrans_LFinished = []</span>
<span class="lineno"> 1949 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_Struct pctx) = transTerms pctx</span>
<span class="lineno"> 1950 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_Fun _ f) = [funTransTerm f]</span>
<span class="lineno"> 1951 </span><span class="spaces">  </span><span class="nottickedoff">transTerms (APTrans_BVProp prop) = transTerms prop</span>
<span class="lineno"> 1952 </span><span class="spaces">  </span><span class="nottickedoff">transTerms APTrans_Any = []</span></span>
<span class="lineno"> 1953 </span>
<span class="lineno"> 1954 </span>instance IsTermTrans (BVPropTrans ctx w) where
<span class="lineno"> 1955 </span>  <span class="decl"><span class="nottickedoff">transTerms (BVPropTrans _ t) = [t]</span></span>
<span class="lineno"> 1956 </span>
<span class="lineno"> 1957 </span>instance IsTermTrans (BVRangeTrans ctx w) where
<span class="lineno"> 1958 </span>  <span class="decl"><span class="nottickedoff">transTerms (BVRangeTrans _ trans1 trans2) =</span>
<span class="lineno"> 1959 </span><span class="spaces">    </span><span class="nottickedoff">transTerms trans1 ++ transTerms trans2</span></span>
<span class="lineno"> 1960 </span>
<span class="lineno"> 1961 </span>instance IsTermTrans (LLVMArrayPermTrans ctx a) where
<span class="lineno"> 1962 </span>  <span class="decl"><span class="nottickedoff">transTerms arr_trans =</span>
<span class="lineno"> 1963 </span><span class="spaces">    </span><span class="nottickedoff">[llvmArrayTransTerm arr_trans]</span></span> -- : transTerms (llvmArrayTransBorrows arr_trans)
<span class="lineno"> 1964 </span>
<span class="lineno"> 1965 </span>{-
<span class="lineno"> 1966 </span>instance IsTermTrans (LLVMArrayBorrowTrans ctx w) where
<span class="lineno"> 1967 </span>  transTerms (LLVMArrayBorrowTrans _ prop_transs) = transTerms prop_transs
<span class="lineno"> 1968 </span>-}
<span class="lineno"> 1969 </span>
<span class="lineno"> 1970 </span>
<span class="lineno"> 1971 </span>-- | Extract out the permission of a permission translation result
<span class="lineno"> 1972 </span>permTransPerm :: RAssign Proxy ctx -&gt; PermTrans ctx a -&gt; Mb ctx (ValuePerm a)
<span class="lineno"> 1973 </span><span class="decl"><span class="nottickedoff">permTransPerm _ (PTrans_Eq e) = fmap ValPerm_Eq e</span>
<span class="lineno"> 1974 </span><span class="spaces"></span><span class="nottickedoff">permTransPerm prxs (PTrans_Conj ts) =</span>
<span class="lineno"> 1975 </span><span class="spaces">  </span><span class="nottickedoff">fmap ValPerm_Conj $ foldr (mbMap2 (:)) (nuMulti prxs $ const []) $</span>
<span class="lineno"> 1976 </span><span class="spaces">  </span><span class="nottickedoff">map (atomicPermTransPerm prxs) ts</span>
<span class="lineno"> 1977 </span><span class="spaces"></span><span class="nottickedoff">permTransPerm _ (PTrans_Defined npn mb_args mb_off _) =</span>
<span class="lineno"> 1978 </span><span class="spaces">  </span><span class="nottickedoff">mbMap2 (ValPerm_Named npn) mb_args mb_off</span>
<span class="lineno"> 1979 </span><span class="spaces"></span><span class="nottickedoff">permTransPerm _ (PTrans_Term p _) = p</span></span>
<span class="lineno"> 1980 </span>
<span class="lineno"> 1981 </span>-- | Extract out the atomic permission of an atomic permission translation result
<span class="lineno"> 1982 </span>atomicPermTransPerm :: RAssign Proxy ctx -&gt; AtomicPermTrans ctx a -&gt;
<span class="lineno"> 1983 </span>                       Mb ctx (AtomicPerm a)
<span class="lineno"> 1984 </span><span class="decl"><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LLVMField fld _) = fmap Perm_LLVMField fld</span>
<span class="lineno"> 1985 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LLVMArray arr_trans) =</span>
<span class="lineno"> 1986 </span><span class="spaces">  </span><span class="nottickedoff">fmap Perm_LLVMArray $ llvmArrayTransPerm arr_trans</span>
<span class="lineno"> 1987 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LLVMBlock mb_bp _) = fmap Perm_LLVMBlock mb_bp</span>
<span class="lineno"> 1988 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LLVMFree e) = fmap Perm_LLVMFree e</span>
<span class="lineno"> 1989 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm prxs (APTrans_LLVMFunPtr tp ptrans) =</span>
<span class="lineno"> 1990 </span><span class="spaces">  </span><span class="nottickedoff">fmap (Perm_LLVMFunPtr tp) (permTransPerm prxs ptrans)</span>
<span class="lineno"> 1991 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm prxs APTrans_IsLLVMPtr = nuMulti prxs $ const Perm_IsLLVMPtr</span>
<span class="lineno"> 1992 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LLVMBlockShape mb_sh _) =</span>
<span class="lineno"> 1993 </span><span class="spaces">  </span><span class="nottickedoff">fmap Perm_LLVMBlockShape mb_sh</span>
<span class="lineno"> 1994 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_NamedConj npn args off _) =</span>
<span class="lineno"> 1995 </span><span class="spaces">  </span><span class="nottickedoff">mbMap2 (Perm_NamedConj npn) args off</span>
<span class="lineno"> 1996 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_DefinedNamedConj npn args off _) =</span>
<span class="lineno"> 1997 </span><span class="spaces">  </span><span class="nottickedoff">mbMap2 (Perm_NamedConj npn) args off</span>
<span class="lineno"> 1998 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LLVMFrame fp) = fmap Perm_LLVMFrame fp</span>
<span class="lineno"> 1999 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LOwned</span>
<span class="lineno"> 2000 </span><span class="spaces">                       </span><span class="nottickedoff">mb_ls tps_in tps_out mb_ps_in mb_ps_out _) =</span>
<span class="lineno"> 2001 </span><span class="spaces">  </span><span class="nottickedoff">mbMap3 (\ls -&gt; Perm_LOwned ls tps_in tps_out) mb_ls mb_ps_in mb_ps_out</span>
<span class="lineno"> 2002 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LOwnedSimple tps mb_lops) =</span>
<span class="lineno"> 2003 </span><span class="spaces">  </span><span class="nottickedoff">fmap (Perm_LOwnedSimple tps) mb_lops</span>
<span class="lineno"> 2004 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_LCurrent l) = fmap Perm_LCurrent l</span>
<span class="lineno"> 2005 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm prxs APTrans_LFinished = nus prxs $ const Perm_LFinished</span>
<span class="lineno"> 2006 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm prxs (APTrans_Struct ps) =</span>
<span class="lineno"> 2007 </span><span class="spaces">  </span><span class="nottickedoff">fmap Perm_Struct $ permTransCtxPerms prxs ps</span>
<span class="lineno"> 2008 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_Fun fp _) = fmap Perm_Fun fp</span>
<span class="lineno"> 2009 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm _ (APTrans_BVProp (BVPropTrans prop _)) =</span>
<span class="lineno"> 2010 </span><span class="spaces">  </span><span class="nottickedoff">fmap Perm_BVProp prop</span>
<span class="lineno"> 2011 </span><span class="spaces"></span><span class="nottickedoff">atomicPermTransPerm prxs APTrans_Any = nuMulti prxs $ const $ Perm_Any</span></span>
<span class="lineno"> 2012 </span>
<span class="lineno"> 2013 </span>-- | Extract out the permissions from a context of permission translations
<span class="lineno"> 2014 </span>permTransCtxPerms :: RAssign Proxy ctx -&gt; PermTransCtx ctx ps -&gt;
<span class="lineno"> 2015 </span>                     Mb ctx (ValuePerms ps)
<span class="lineno"> 2016 </span><span class="decl"><span class="nottickedoff">permTransCtxPerms prxs MNil = nuMulti prxs $ const ValPerms_Nil</span>
<span class="lineno"> 2017 </span><span class="spaces"></span><span class="nottickedoff">permTransCtxPerms prxs (ptranss :&gt;: ptrans) =</span>
<span class="lineno"> 2018 </span><span class="spaces">  </span><span class="nottickedoff">mbMap2 ValPerms_Cons (permTransCtxPerms prxs ptranss) (permTransPerm prxs ptrans)</span></span>
<span class="lineno"> 2019 </span>
<span class="lineno"> 2020 </span>-- | Extract out the LLVM borrow from its translation
<span class="lineno"> 2021 </span>{-
<span class="lineno"> 2022 </span>borrowTransMbBorrow :: LLVMArrayBorrowTrans ctx w -&gt; Mb ctx (LLVMArrayBorrow w)
<span class="lineno"> 2023 </span>borrowTransMbBorrow (LLVMArrayBorrowTrans mb_b _) = mb_b
<span class="lineno"> 2024 </span>-}
<span class="lineno"> 2025 </span>
<span class="lineno"> 2026 </span>-- | Test that a permission equals that of a permission translation
<span class="lineno"> 2027 </span>permTransPermEq :: PermTrans ctx a -&gt; Mb ctx (ValuePerm a) -&gt; Bool
<span class="lineno"> 2028 </span><span class="decl"><span class="nottickedoff">permTransPermEq ptrans mb_p =</span>
<span class="lineno"> 2029 </span><span class="spaces">  </span><span class="nottickedoff">permTransPerm (mbToProxy mb_p) ptrans == mb_p</span></span>
<span class="lineno"> 2030 </span>
<span class="lineno"> 2031 </span>-- | Extend the context of a 'PermTrans' with a single type
<span class="lineno"> 2032 </span>extPermTrans :: ExtPermTrans f =&gt; ExprTrans tp -&gt; f ctx a -&gt; f (ctx :&gt; tp) a
<span class="lineno"> 2033 </span><span class="decl"><span class="nottickedoff">extPermTrans e = extPermTransMulti (MNil :&gt;: e)</span></span>
<span class="lineno"> 2034 </span>
<span class="lineno"> 2035 </span>-- | Extend the context of a permission translation using a 'CtxExt'
<span class="lineno"> 2036 </span>extPermTransExt :: ExprCtxExt ctx1 ctx2 -&gt;
<span class="lineno"> 2037 </span>                   PermTrans ctx1 a -&gt; PermTrans ctx2 a
<span class="lineno"> 2038 </span><span class="decl"><span class="nottickedoff">extPermTransExt (ExprCtxExt ctx) ptrans =</span>
<span class="lineno"> 2039 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ctx ptrans</span></span>
<span class="lineno"> 2040 </span>
<span class="lineno"> 2041 </span>-- | Extend the context of a 'PermTransCtx' using a 'CtxExt'
<span class="lineno"> 2042 </span>extPermTransCtxExt :: ExprCtxExt ctx1 ctx2 -&gt;
<span class="lineno"> 2043 </span>                      PermTransCtx ctx1 ps -&gt; PermTransCtx ctx2 ps
<span class="lineno"> 2044 </span><span class="decl"><span class="nottickedoff">extPermTransCtxExt cext = RL.map (extPermTransExt cext)</span></span>
<span class="lineno"> 2045 </span>
<span class="lineno"> 2046 </span>
<span class="lineno"> 2047 </span>-- | Generic function to extend the context of the translation of a permission
<span class="lineno"> 2048 </span>class ExtPermTrans f where
<span class="lineno"> 2049 </span>  extPermTransMulti :: ExprTransCtx ctx2 -&gt; f ctx1 a -&gt; f (ctx1 :++: ctx2) a
<span class="lineno"> 2050 </span>
<span class="lineno"> 2051 </span>instance ExtPermTrans PermTrans where
<span class="lineno"> 2052 </span>  <span class="decl"><span class="nottickedoff">extPermTransMulti ectx (PTrans_Eq e) =</span>
<span class="lineno"> 2053 </span><span class="spaces">    </span><span class="nottickedoff">PTrans_Eq $ extMbAny ectx e</span>
<span class="lineno"> 2054 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (PTrans_Conj aps) =</span>
<span class="lineno"> 2055 </span><span class="spaces">    </span><span class="nottickedoff">PTrans_Conj (map (extPermTransMulti ectx) aps)</span>
<span class="lineno"> 2056 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (PTrans_Defined n args a ptrans) =</span>
<span class="lineno"> 2057 </span><span class="spaces">    </span><span class="nottickedoff">PTrans_Defined n (extMbAny ectx args) (extMbAny ectx a)</span>
<span class="lineno"> 2058 </span><span class="spaces">    </span><span class="nottickedoff">(extPermTransMulti ectx ptrans)</span>
<span class="lineno"> 2059 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (PTrans_Term p t) = PTrans_Term (extMbAny ectx p) t</span></span>
<span class="lineno"> 2060 </span>
<span class="lineno"> 2061 </span>instance ExtPermTrans AtomicPermTrans where
<span class="lineno"> 2062 </span>  <span class="decl"><span class="nottickedoff">extPermTransMulti ectx (APTrans_LLVMField fld ptrans) =</span>
<span class="lineno"> 2063 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMField (extMbAny ectx fld) (extPermTransMulti ectx ptrans)</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LLVMArray arr_trans) =</span>
<span class="lineno"> 2065 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMArray $ extPermTransMulti ectx arr_trans</span>
<span class="lineno"> 2066 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LLVMBlock mb_bp ts) =</span>
<span class="lineno"> 2067 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMBlock (extMbAny ectx mb_bp) ts</span>
<span class="lineno"> 2068 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx  (APTrans_LLVMFree e) =</span>
<span class="lineno"> 2069 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMFree $ extMbAny ectx e</span>
<span class="lineno"> 2070 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LLVMFunPtr tp ptrans) =</span>
<span class="lineno"> 2071 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMFunPtr tp (extPermTransMulti ectx ptrans)</span>
<span class="lineno"> 2072 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti _ APTrans_IsLLVMPtr = APTrans_IsLLVMPtr</span>
<span class="lineno"> 2073 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LLVMBlockShape mb_sh ts) =</span>
<span class="lineno"> 2074 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMBlockShape (extMbAny ectx mb_sh) ts</span>
<span class="lineno"> 2075 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_NamedConj npn args off t) =</span>
<span class="lineno"> 2076 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_NamedConj npn (extMbAny ectx args) (extMbAny ectx off) t</span>
<span class="lineno"> 2077 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_DefinedNamedConj npn args off ptrans) =</span>
<span class="lineno"> 2078 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_DefinedNamedConj npn (extMbAny ectx args) (extMbAny ectx off)</span>
<span class="lineno"> 2079 </span><span class="spaces">    </span><span class="nottickedoff">(extPermTransMulti ectx ptrans)</span>
<span class="lineno"> 2080 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LLVMFrame fp) =</span>
<span class="lineno"> 2081 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LLVMFrame $ extMbAny ectx fp</span>
<span class="lineno"> 2082 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LOwned ls tps_in tps_out ps_in ps_out lotr) =</span>
<span class="lineno"> 2083 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LOwned (extMbAny ectx ls) tps_in tps_out</span>
<span class="lineno"> 2084 </span><span class="spaces">    </span><span class="nottickedoff">(extMbAny ectx ps_in) (extMbAny ectx ps_out)</span>
<span class="lineno"> 2085 </span><span class="spaces">    </span><span class="nottickedoff">(extLOwnedTransMulti ectx lotr)</span>
<span class="lineno"> 2086 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LOwnedSimple tps lops) =</span>
<span class="lineno"> 2087 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LOwnedSimple tps (extMbAny ectx lops)</span>
<span class="lineno"> 2088 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_LCurrent p) =</span>
<span class="lineno"> 2089 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_LCurrent $ extMbAny ectx p</span>
<span class="lineno"> 2090 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti _ APTrans_LFinished = APTrans_LFinished</span>
<span class="lineno"> 2091 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_Struct ps) =</span>
<span class="lineno"> 2092 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_Struct $ RL.map (extPermTransMulti ectx) ps</span>
<span class="lineno"> 2093 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_Fun fp trans) =</span>
<span class="lineno"> 2094 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_Fun (extMbAny ectx fp) trans</span>
<span class="lineno"> 2095 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti ectx (APTrans_BVProp prop_trans) =</span>
<span class="lineno"> 2096 </span><span class="spaces">    </span><span class="nottickedoff">APTrans_BVProp $ extPermTransMulti ectx prop_trans</span>
<span class="lineno"> 2097 </span><span class="spaces">  </span><span class="nottickedoff">extPermTransMulti _ APTrans_Any = APTrans_Any</span></span>
<span class="lineno"> 2098 </span>
<span class="lineno"> 2099 </span>instance ExtPermTrans LLVMArrayPermTrans where
<span class="lineno"> 2100 </span>  <span class="decl"><span class="nottickedoff">extPermTransMulti ectx (LLVMArrayPermTrans ap len sh {- bs -} t) =</span>
<span class="lineno"> 2101 </span><span class="spaces">    </span><span class="nottickedoff">LLVMArrayPermTrans (extMbAny ectx ap) len</span>
<span class="lineno"> 2102 </span><span class="spaces">    </span><span class="nottickedoff">(fmap (extPermTransMulti ectx) sh) {- (map extPermTrans bs) -} t</span></span>
<span class="lineno"> 2103 </span>
<span class="lineno"> 2104 </span>{-
<span class="lineno"> 2105 </span>instance ExtPermTrans LLVMArrayBorrowTrans where
<span class="lineno"> 2106 </span>  extPermTrans (LLVMArrayBorrowTrans mb_b prop_transs) =
<span class="lineno"> 2107 </span>    LLVMArrayBorrowTrans (extMb mb_b) (map extPermTrans prop_transs)
<span class="lineno"> 2108 </span>-}
<span class="lineno"> 2109 </span>
<span class="lineno"> 2110 </span>instance ExtPermTrans BVPropTrans where
<span class="lineno"> 2111 </span>  <span class="decl"><span class="nottickedoff">extPermTransMulti ectx (BVPropTrans prop t) =</span>
<span class="lineno"> 2112 </span><span class="spaces">    </span><span class="nottickedoff">BVPropTrans (extMbAny ectx prop) t</span></span>
<span class="lineno"> 2113 </span>
<span class="lineno"> 2114 </span>instance ExtPermTrans BVRangeTrans where
<span class="lineno"> 2115 </span>  <span class="decl"><span class="nottickedoff">extPermTransMulti ectx (BVRangeTrans rng t1 t2) =</span>
<span class="lineno"> 2116 </span><span class="spaces">    </span><span class="nottickedoff">BVRangeTrans (extMbAny ectx rng) t1 t2</span></span>
<span class="lineno"> 2117 </span>
<span class="lineno"> 2118 </span>-- | Extend the context of a permission translation context
<span class="lineno"> 2119 </span>extPermTransCtx :: ExprTrans tp -&gt; PermTransCtx ctx ps -&gt;
<span class="lineno"> 2120 </span>                   PermTransCtx (ctx :&gt; tp) ps
<span class="lineno"> 2121 </span><span class="decl"><span class="nottickedoff">extPermTransCtx e = RL.map (extPermTrans e)</span></span>
<span class="lineno"> 2122 </span>
<span class="lineno"> 2123 </span>-- | Extend the context of a permission translation context
<span class="lineno"> 2124 </span>extPermTransCtxMulti :: ExprTransCtx ctx2 -&gt; PermTransCtx ctx1 ps -&gt;
<span class="lineno"> 2125 </span>                        PermTransCtx (ctx1 :++: ctx2) ps
<span class="lineno"> 2126 </span><span class="decl"><span class="nottickedoff">extPermTransCtxMulti ectx2 = RL.map (extPermTransMulti ectx2)</span></span>
<span class="lineno"> 2127 </span>
<span class="lineno"> 2128 </span>-- | Add another permission translation to a permission translation context
<span class="lineno"> 2129 </span>consPermTransCtx :: PermTransCtx ctx ps -&gt; PermTrans ctx a -&gt;
<span class="lineno"> 2130 </span>                    PermTransCtx ctx (ps :&gt; a)
<span class="lineno"> 2131 </span><span class="decl"><span class="nottickedoff">consPermTransCtx = (:&gt;:)</span></span>
<span class="lineno"> 2132 </span>
<span class="lineno"> 2133 </span>-- | Apply 'offsetLLVMAtomicPerm' to the permissions associated with an atomic
<span class="lineno"> 2134 </span>-- permission translation, returning 'Nothing' if the offset does not exist
<span class="lineno"> 2135 </span>offsetLLVMAtomicPermTrans :: (1 &lt;= w, KnownNat w) =&gt; Mb ctx (PermExpr (BVType w)) -&gt;
<span class="lineno"> 2136 </span>                             AtomicPermTrans ctx (LLVMPointerType w) -&gt;
<span class="lineno"> 2137 </span>                             Maybe (AtomicPermTrans ctx (LLVMPointerType w))
<span class="lineno"> 2138 </span><span class="decl"><span class="nottickedoff">offsetLLVMAtomicPermTrans mb_off ptrans</span>
<span class="lineno"> 2139 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| Just 0 |] &lt;- mbMatch $ fmap bvMatchConstInt mb_off = Just ptrans</span>
<span class="lineno"> 2140 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans mb_off (APTrans_LLVMField fld ptrans) =</span>
<span class="lineno"> 2141 </span><span class="spaces">  </span><span class="nottickedoff">Just $ APTrans_LLVMField (mbMap2 offsetLLVMFieldPerm mb_off fld) ptrans</span>
<span class="lineno"> 2142 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans mb_off (APTrans_LLVMArray</span>
<span class="lineno"> 2143 </span><span class="spaces">                                  </span><span class="nottickedoff">(LLVMArrayPermTrans ap len sh {- bs -} t)) =</span>
<span class="lineno"> 2144 </span><span class="spaces">  </span><span class="nottickedoff">Just $ APTrans_LLVMArray $</span>
<span class="lineno"> 2145 </span><span class="spaces">  </span><span class="nottickedoff">LLVMArrayPermTrans (mbMap2 offsetLLVMArrayPerm mb_off ap) len sh {- bs -} t</span>
<span class="lineno"> 2146 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans mb_off (APTrans_LLVMBlock mb_bp ts) =</span>
<span class="lineno"> 2147 </span><span class="spaces">  </span><span class="nottickedoff">Just $ APTrans_LLVMBlock</span>
<span class="lineno"> 2148 </span><span class="spaces">  </span><span class="nottickedoff">(mbMap2 (\off bp -&gt;</span>
<span class="lineno"> 2149 </span><span class="spaces">            </span><span class="nottickedoff">bp { llvmBlockOffset =</span>
<span class="lineno"> 2150 </span><span class="spaces">                   </span><span class="nottickedoff">bvAdd (llvmBlockOffset bp) off } ) mb_off mb_bp)</span>
<span class="lineno"> 2151 </span><span class="spaces">  </span><span class="nottickedoff">ts</span>
<span class="lineno"> 2152 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans _ (APTrans_LLVMFree _) = Nothing</span>
<span class="lineno"> 2153 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans _ (APTrans_LLVMFunPtr _ _) = Nothing</span>
<span class="lineno"> 2154 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans _ p@APTrans_IsLLVMPtr = Just p</span>
<span class="lineno"> 2155 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans off (APTrans_NamedConj npn args off' t) =</span>
<span class="lineno"> 2156 </span><span class="spaces">  </span><span class="nottickedoff">Just $ APTrans_NamedConj npn args (mbMap2 addPermOffsets off' $</span>
<span class="lineno"> 2157 </span><span class="spaces">                                     </span><span class="nottickedoff">fmap mkLLVMPermOffset off) t</span>
<span class="lineno"> 2158 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans off (APTrans_DefinedNamedConj npn args off' ptrans) =</span>
<span class="lineno"> 2159 </span><span class="spaces">  </span><span class="nottickedoff">Just $ APTrans_DefinedNamedConj npn args (mbMap2 addPermOffsets off' $</span>
<span class="lineno"> 2160 </span><span class="spaces">                                            </span><span class="nottickedoff">fmap mkLLVMPermOffset off)</span>
<span class="lineno"> 2161 </span><span class="spaces">  </span><span class="nottickedoff">(offsetLLVMPermTrans off ptrans)</span>
<span class="lineno"> 2162 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMAtomicPermTrans _ _ = Nothing</span></span>
<span class="lineno"> 2163 </span>
<span class="lineno"> 2164 </span>-- | Apply 'offsetLLVMPerm' to the permissions associated with a permission
<span class="lineno"> 2165 </span>-- translation
<span class="lineno"> 2166 </span>offsetLLVMPermTrans :: (1 &lt;= w, KnownNat w) =&gt; Mb ctx (PermExpr (BVType w)) -&gt;
<span class="lineno"> 2167 </span>                       PermTrans ctx (LLVMPointerType w) -&gt;
<span class="lineno"> 2168 </span>                       PermTrans ctx (LLVMPointerType w)
<span class="lineno"> 2169 </span><span class="decl"><span class="nottickedoff">offsetLLVMPermTrans mb_off (PTrans_Eq mb_e) =</span>
<span class="lineno"> 2170 </span><span class="spaces">  </span><span class="nottickedoff">PTrans_Eq $ mbMap2 (\off e -&gt; addLLVMOffset e (bvNegate off)) mb_off mb_e</span>
<span class="lineno"> 2171 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPermTrans mb_off (PTrans_Conj ps) =</span>
<span class="lineno"> 2172 </span><span class="spaces">  </span><span class="nottickedoff">PTrans_Conj $ mapMaybe (offsetLLVMAtomicPermTrans mb_off) ps</span>
<span class="lineno"> 2173 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPermTrans mb_off (PTrans_Defined n args off ptrans) =</span>
<span class="lineno"> 2174 </span><span class="spaces">  </span><span class="nottickedoff">PTrans_Defined n args (mbMap2 addPermOffsets off</span>
<span class="lineno"> 2175 </span><span class="spaces">                         </span><span class="nottickedoff">(fmap mkLLVMPermOffset mb_off)) $</span>
<span class="lineno"> 2176 </span><span class="spaces">  </span><span class="nottickedoff">offsetLLVMPermTrans mb_off ptrans</span>
<span class="lineno"> 2177 </span><span class="spaces"></span><span class="nottickedoff">offsetLLVMPermTrans mb_off (PTrans_Term mb_p t) =</span>
<span class="lineno"> 2178 </span><span class="spaces">  </span><span class="nottickedoff">PTrans_Term (mbMap2 offsetLLVMPerm mb_off mb_p) t</span></span>
<span class="lineno"> 2179 </span>
<span class="lineno"> 2180 </span>-- | Apply 'offsetPerm' to the permissions associated with a permission
<span class="lineno"> 2181 </span>-- translation
<span class="lineno"> 2182 </span>offsetPermTrans :: Mb ctx (PermOffset a) -&gt; PermTrans ctx a -&gt; PermTrans ctx a
<span class="lineno"> 2183 </span><span class="decl"><span class="nottickedoff">offsetPermTrans mb_off = case mbMatch mb_off of</span>
<span class="lineno"> 2184 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| NoPermOffset |] -&gt; id</span>
<span class="lineno"> 2185 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| LLVMPermOffset off |] -&gt; offsetLLVMPermTrans off</span></span>
<span class="lineno"> 2186 </span>
<span class="lineno"> 2187 </span>
<span class="lineno"> 2188 </span>----------------------------------------------------------------------
<span class="lineno"> 2189 </span>-- * Translations of Array Permissions
<span class="lineno"> 2190 </span>----------------------------------------------------------------------
<span class="lineno"> 2191 </span>
<span class="lineno"> 2192 </span>-- | The translation of an LLVM array permission is a SAW term of @BVVec@ type,
<span class="lineno"> 2193 </span>-- along with a SAW term for its length as a bitvector and the type translation
<span class="lineno"> 2194 </span>-- for a @memblock@ permission to its head cell, which can be offset to get a
<span class="lineno"> 2195 </span>-- @memblock@ permission for any of its cells.
<span class="lineno"> 2196 </span>data LLVMArrayPermTrans ctx w = LLVMArrayPermTrans {
<span class="lineno"> 2197 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayTransPerm</span></span></span> :: Mb ctx (LLVMArrayPerm w),
<span class="lineno"> 2198 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayTransLen</span></span></span> :: OpenTerm,
<span class="lineno"> 2199 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayTransHeadCell</span></span></span> :: TypeTrans (AtomicPermTrans ctx (LLVMPointerType w)),
<span class="lineno"> 2200 </span>  -- llvmArrayTransBorrows :: [LLVMArrayBorrowTrans ctx w],
<span class="lineno"> 2201 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">llvmArrayTransTerm</span></span></span> :: OpenTerm
<span class="lineno"> 2202 </span>  }
<span class="lineno"> 2203 </span>
<span class="lineno"> 2204 </span>-- | Get the SAW type of the cells of the translation of an array permission
<span class="lineno"> 2205 </span>llvmArrayTransCellType :: LLVMArrayPermTrans ctx w -&gt; OpenTerm
<span class="lineno"> 2206 </span><span class="decl"><span class="nottickedoff">llvmArrayTransCellType = typeTransTupleType . llvmArrayTransHeadCell</span></span>
<span class="lineno"> 2207 </span>
<span class="lineno"> 2208 </span>
<span class="lineno"> 2209 </span>-- | The translation of an 'LLVMArrayBorrow' is an element / proof of the
<span class="lineno"> 2210 </span>-- translation of the the 'BVProp' returned by 'llvmArrayBorrowInArrayBase'
<span class="lineno"> 2211 </span>{-
<span class="lineno"> 2212 </span>data LLVMArrayBorrowTrans ctx w =
<span class="lineno"> 2213 </span>  LLVMArrayBorrowTrans
<span class="lineno"> 2214 </span>  { llvmArrayBorrowTransBorrow :: Mb ctx (LLVMArrayBorrow w),
<span class="lineno"> 2215 </span>    llvmArrayBorrowTransProps :: [BVPropTrans ctx w] }
<span class="lineno"> 2216 </span>-}
<span class="lineno"> 2217 </span>
<span class="lineno"> 2218 </span>{-
<span class="lineno"> 2219 </span>-- | Add a borrow to an LLVM array permission translation
<span class="lineno"> 2220 </span>llvmArrayTransAddBorrow :: LLVMArrayBorrowTrans ctx w -&gt;
<span class="lineno"> 2221 </span>                           LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2222 </span>                           LLVMArrayPermTrans ctx w
<span class="lineno"> 2223 </span>llvmArrayTransAddBorrow b arr_trans =
<span class="lineno"> 2224 </span>  arr_trans { llvmArrayTransPerm =
<span class="lineno"> 2225 </span>                mbMap2 llvmArrayAddBorrow (llvmArrayBorrowTransBorrow b)
<span class="lineno"> 2226 </span>                (llvmArrayTransPerm arr_trans)
<span class="lineno"> 2227 </span>            , llvmArrayTransBorrows = b : llvmArrayTransBorrows arr_trans }
<span class="lineno"> 2228 </span>
<span class="lineno"> 2229 </span>-- | Find the index in the list of borrows of a specific borrow
<span class="lineno"> 2230 </span>llvmArrayTransFindBorrowIx :: Mb ctx (LLVMArrayBorrow w) -&gt;
<span class="lineno"> 2231 </span>                              LLVMArrayPermTrans ctx w -&gt; Int
<span class="lineno"> 2232 </span>llvmArrayTransFindBorrowIx b arr_trans =
<span class="lineno"> 2233 </span>  mbLift $ mbMap2 llvmArrayFindBorrow b (llvmArrayTransPerm arr_trans)
<span class="lineno"> 2234 </span>
<span class="lineno"> 2235 </span>-- | Find the index in the list of borrows of a specific borrow
<span class="lineno"> 2236 </span>llvmArrayTransFindBorrow :: Mb ctx (LLVMArrayBorrow w) -&gt;
<span class="lineno"> 2237 </span>                            LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2238 </span>                            LLVMArrayBorrowTrans ctx w
<span class="lineno"> 2239 </span>llvmArrayTransFindBorrow b arr_trans =
<span class="lineno"> 2240 </span>  llvmArrayTransBorrows arr_trans !! llvmArrayTransFindBorrowIx b arr_trans
<span class="lineno"> 2241 </span>
<span class="lineno"> 2242 </span>-- | Remove a borrow from an LLVM array permission translation
<span class="lineno"> 2243 </span>llvmArrayTransRemBorrow :: LLVMArrayBorrowTrans ctx w -&gt;
<span class="lineno"> 2244 </span>                           LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2245 </span>                           LLVMArrayPermTrans ctx w
<span class="lineno"> 2246 </span>llvmArrayTransRemBorrow b_trans arr_trans =
<span class="lineno"> 2247 </span>  let b = llvmArrayBorrowTransBorrow b_trans in
<span class="lineno"> 2248 </span>  arr_trans { llvmArrayTransPerm =
<span class="lineno"> 2249 </span>                mbMap2 llvmArrayRemBorrow b (llvmArrayTransPerm arr_trans)
<span class="lineno"> 2250 </span>            , llvmArrayTransBorrows =
<span class="lineno"> 2251 </span>                deleteNth (llvmArrayTransFindBorrowIx b arr_trans)
<span class="lineno"> 2252 </span>                (llvmArrayTransBorrows arr_trans) }
<span class="lineno"> 2253 </span>-}
<span class="lineno"> 2254 </span>
<span class="lineno"> 2255 </span>-- | Read an array cell of the translation of an LLVM array permission at a
<span class="lineno"> 2256 </span>-- given index, given proofs of the propositions that the index is in the array
<span class="lineno"> 2257 </span>-- as returned by 'llvmArrayIndexInArray'. Note that the first proposition
<span class="lineno"> 2258 </span>-- should always be that the cell number is &lt;= the array length.
<span class="lineno"> 2259 </span>getLLVMArrayTransCell :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2260 </span>                         Mb ctx (PermExpr (BVType w)) -&gt; OpenTerm -&gt;
<span class="lineno"> 2261 </span>                         [BVPropTrans ctx w] -&gt;
<span class="lineno"> 2262 </span>                         AtomicPermTrans ctx (LLVMPointerType w)
<span class="lineno"> 2263 </span><span class="decl"><span class="nottickedoff">getLLVMArrayTransCell arr_trans mb_cell cell_tm (BVPropTrans _ in_rng_pf:_) =</span>
<span class="lineno"> 2264 </span><span class="spaces">  </span><span class="nottickedoff">let w = fromInteger $ natVal arr_trans in</span>
<span class="lineno"> 2265 </span><span class="spaces">  </span><span class="nottickedoff">fromJust $</span>
<span class="lineno"> 2266 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: remove offsetLLVMAtomicPermTrans, as it requires changing all</span>
<span class="lineno"> 2267 </span><span class="spaces">  </span><span class="nottickedoff">-- name-bindings in the PermTrans it is applied to back to FreshFuns, i.e., it</span>
<span class="lineno"> 2268 </span><span class="spaces">  </span><span class="nottickedoff">-- substitutes for all the names</span>
<span class="lineno"> 2269 </span><span class="spaces">  </span><span class="nottickedoff">offsetLLVMAtomicPermTrans (mbMap2 llvmArrayCellToOffset</span>
<span class="lineno"> 2270 </span><span class="spaces">                             </span><span class="nottickedoff">(llvmArrayTransPerm arr_trans) mb_cell) $</span>
<span class="lineno"> 2271 </span><span class="spaces">  </span><span class="nottickedoff">typeTransF (tupleTypeTrans (llvmArrayTransHeadCell arr_trans))</span>
<span class="lineno"> 2272 </span><span class="spaces">  </span><span class="nottickedoff">[applyGlobalOpenTerm &quot;Prelude.atBVVec&quot;</span>
<span class="lineno"> 2273 </span><span class="spaces">   </span><span class="nottickedoff">[natOpenTerm w, llvmArrayTransLen arr_trans,</span>
<span class="lineno"> 2274 </span><span class="spaces">    </span><span class="nottickedoff">llvmArrayTransCellType arr_trans, llvmArrayTransTerm arr_trans,</span>
<span class="lineno"> 2275 </span><span class="spaces">    </span><span class="nottickedoff">cell_tm, in_rng_pf]]</span>
<span class="lineno"> 2276 </span><span class="spaces"></span><span class="nottickedoff">getLLVMArrayTransCell _ _ _ _ =</span>
<span class="lineno"> 2277 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;getLLVMArrayTransCell: malformed arguments&quot;</span></span>
<span class="lineno"> 2278 </span>
<span class="lineno"> 2279 </span>
<span class="lineno"> 2280 </span>-- | Write an array cell of the translation of an LLVM array permission at a
<span class="lineno"> 2281 </span>-- given index
<span class="lineno"> 2282 </span>setLLVMArrayTransCell :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2283 </span>                         LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2284 </span>                         OpenTerm -&gt; AtomicPermTrans ctx (LLVMPointerType w) -&gt;
<span class="lineno"> 2285 </span>                         LLVMArrayPermTrans ctx w
<span class="lineno"> 2286 </span><span class="decl"><span class="nottickedoff">setLLVMArrayTransCell arr_trans cell_ix_tm cell_value =</span>
<span class="lineno"> 2287 </span><span class="spaces">  </span><span class="nottickedoff">let w = fromInteger $ natVal arr_trans in</span>
<span class="lineno"> 2288 </span><span class="spaces">  </span><span class="nottickedoff">arr_trans {</span>
<span class="lineno"> 2289 </span><span class="spaces">    </span><span class="nottickedoff">llvmArrayTransTerm =</span>
<span class="lineno"> 2290 </span><span class="spaces">        </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.updBVVec&quot;</span>
<span class="lineno"> 2291 </span><span class="spaces">        </span><span class="nottickedoff">[natOpenTerm w, llvmArrayTransLen arr_trans,</span>
<span class="lineno"> 2292 </span><span class="spaces">         </span><span class="nottickedoff">llvmArrayTransCellType arr_trans, llvmArrayTransTerm arr_trans,</span>
<span class="lineno"> 2293 </span><span class="spaces">         </span><span class="nottickedoff">cell_ix_tm, transTupleTerm cell_value] }</span></span>
<span class="lineno"> 2294 </span>
<span class="lineno"> 2295 </span>
<span class="lineno"> 2296 </span>-- | Read a slice (= a sub-array) of the translation of an LLVM array permission
<span class="lineno"> 2297 </span>-- for the supplied 'BVRange', given the translation of the sub-array permission
<span class="lineno"> 2298 </span>-- and proofs of the propositions that the 'BVRange' is in the array as returned
<span class="lineno"> 2299 </span>-- by 'llvmArrayCellsInArray'. Note that the first two of these propositions are
<span class="lineno"> 2300 </span>-- those returned by 'bvPropRangeSubset'.
<span class="lineno"> 2301 </span>getLLVMArrayTransSlice :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2302 </span>                          TypeTrans (LLVMArrayPermTrans ctx w) -&gt;
<span class="lineno"> 2303 </span>                          BVRangeTrans ctx w -&gt; [BVPropTrans ctx w] -&gt;
<span class="lineno"> 2304 </span>                          LLVMArrayPermTrans ctx w
<span class="lineno"> 2305 </span><span class="decl"><span class="nottickedoff">getLLVMArrayTransSlice arr_trans sub_arr_tp rng_trans prop_transs =</span>
<span class="lineno"> 2306 </span><span class="spaces">  </span><span class="nottickedoff">let w = fromInteger $ natVal arr_trans</span>
<span class="lineno"> 2307 </span><span class="spaces">      </span><span class="nottickedoff">elem_tp = llvmArrayTransCellType arr_trans</span>
<span class="lineno"> 2308 </span><span class="spaces">      </span><span class="nottickedoff">len_tm = llvmArrayTransLen arr_trans</span>
<span class="lineno"> 2309 </span><span class="spaces">      </span><span class="nottickedoff">v_tm = llvmArrayTransTerm arr_trans</span>
<span class="lineno"> 2310 </span><span class="spaces">      </span><span class="nottickedoff">off_tm = transTerm1 $ bvRangeTransOff rng_trans</span>
<span class="lineno"> 2311 </span><span class="spaces">      </span><span class="nottickedoff">len'_tm = transTerm1 $ bvRangeTransLen rng_trans</span>
<span class="lineno"> 2312 </span><span class="spaces">      </span><span class="nottickedoff">(p1_trans, p2_trans) = case prop_transs of</span>
<span class="lineno"> 2313 </span><span class="spaces">        </span><span class="nottickedoff">t1:t2:_ -&gt; (t1,t2)</span>
<span class="lineno"> 2314 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; panic &quot;getLLVMArrayTransSlice&quot; [&quot;Malformed input BVPropTrans list&quot;]</span>
<span class="lineno"> 2315 </span><span class="spaces">      </span><span class="nottickedoff">BVPropTrans _ p1_tm = p1_trans</span>
<span class="lineno"> 2316 </span><span class="spaces">      </span><span class="nottickedoff">BVPropTrans _ p2_tm = p2_trans in</span>
<span class="lineno"> 2317 </span><span class="spaces">  </span><span class="nottickedoff">typeTransF sub_arr_tp</span>
<span class="lineno"> 2318 </span><span class="spaces">  </span><span class="nottickedoff">[applyGlobalOpenTerm &quot;Prelude.sliceBVVec&quot;</span>
<span class="lineno"> 2319 </span><span class="spaces">   </span><span class="nottickedoff">[natOpenTerm w, len_tm, elem_tp, off_tm, len'_tm, p1_tm, p2_tm, v_tm]]</span></span>
<span class="lineno"> 2320 </span>
<span class="lineno"> 2321 </span>-- | Write a slice (= a sub-array) of the translation of an LLVM array
<span class="lineno"> 2322 </span>-- permission given the translation of the slice and of the offset of that slice
<span class="lineno"> 2323 </span>-- in the larger array
<span class="lineno"> 2324 </span>setLLVMArrayTransSlice :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPermTrans ctx w -&gt;
<span class="lineno"> 2325 </span>                          LLVMArrayPermTrans ctx w -&gt; OpenTerm -&gt;
<span class="lineno"> 2326 </span>                          LLVMArrayPermTrans ctx w
<span class="lineno"> 2327 </span><span class="decl"><span class="nottickedoff">setLLVMArrayTransSlice arr_trans sub_arr_trans off_tm =</span>
<span class="lineno"> 2328 </span><span class="spaces">  </span><span class="nottickedoff">let w = fromInteger $ natVal arr_trans</span>
<span class="lineno"> 2329 </span><span class="spaces">      </span><span class="nottickedoff">elem_tp = llvmArrayTransCellType arr_trans</span>
<span class="lineno"> 2330 </span><span class="spaces">      </span><span class="nottickedoff">len_tm = llvmArrayTransLen arr_trans</span>
<span class="lineno"> 2331 </span><span class="spaces">      </span><span class="nottickedoff">arr_tm = llvmArrayTransTerm arr_trans</span>
<span class="lineno"> 2332 </span><span class="spaces">      </span><span class="nottickedoff">len'_tm = llvmArrayTransLen sub_arr_trans</span>
<span class="lineno"> 2333 </span><span class="spaces">      </span><span class="nottickedoff">sub_arr_tm = llvmArrayTransTerm sub_arr_trans in</span>
<span class="lineno"> 2334 </span><span class="spaces">  </span><span class="nottickedoff">arr_trans</span>
<span class="lineno"> 2335 </span><span class="spaces">  </span><span class="nottickedoff">{ llvmArrayTransTerm =</span>
<span class="lineno"> 2336 </span><span class="spaces">      </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.updSliceBVVec&quot;</span>
<span class="lineno"> 2337 </span><span class="spaces">      </span><span class="nottickedoff">[natOpenTerm w, len_tm, elem_tp, arr_tm, off_tm, len'_tm, sub_arr_tm] }</span></span>
<span class="lineno"> 2338 </span>
<span class="lineno"> 2339 </span>
<span class="lineno"> 2340 </span>----------------------------------------------------------------------
<span class="lineno"> 2341 </span>-- * Translations of Lifetime Ownership Permissions
<span class="lineno"> 2342 </span>----------------------------------------------------------------------
<span class="lineno"> 2343 </span>
<span class="lineno"> 2344 </span>-- | An 'LOwnedInfo' is essentially a set of translations of \&quot;proof objects\&quot;
<span class="lineno"> 2345 </span>-- of permission list @ps@, in a variable context @ctx@, along with additional
<span class="lineno"> 2346 </span>-- information (the @SpecM@ event type and the eventual return type of the
<span class="lineno"> 2347 </span>-- overall computation) required to apply @bindS@
<span class="lineno"> 2348 </span>data LOwnedInfo ps ctx =
<span class="lineno"> 2349 </span>  LOwnedInfo { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lownedInfoECtx</span></span></span> :: ExprTransCtx ctx,
<span class="lineno"> 2350 </span>               <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lownedInfoPCtx</span></span></span> :: PermTransCtx ctx ps,
<span class="lineno"> 2351 </span>               <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lownedInfoPVars</span></span></span> :: RAssign (Member ctx) ps,
<span class="lineno"> 2352 </span>               <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lownedInfoEvType</span></span></span> :: EventType,
<span class="lineno"> 2353 </span>               <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lownedInfoRetType</span></span></span> :: OpenTerm }
<span class="lineno"> 2354 </span>
<span class="lineno"> 2355 </span>-- NOTE: LOwnedInfo does not satisfy TransInfo because it doesn't have a
<span class="lineno"> 2356 </span>-- PermEnv; this is probably more of a limitation of the TransInfo interface,
<span class="lineno"> 2357 </span>-- which should be refactored if we want this
<span class="lineno"> 2358 </span>{-
<span class="lineno"> 2359 </span>instance TransInfo (LOwnedInfo ps) where
<span class="lineno"> 2360 </span>  infoCtx = lownedInfoECtx
<span class="lineno"> 2361 </span>  infoEnv = ??
<span class="lineno"> 2362 </span>  infoChecksFlag _ = noChecks
<span class="lineno"> 2363 </span>  extTransInfo = extLOwnedInfo
<span class="lineno"> 2364 </span>
<span class="lineno"> 2365 </span>instance TransInfoM (LOwnedInfo ps) where
<span class="lineno"> 2366 </span>  infoRetType = lownedInfoRetType
<span class="lineno"> 2367 </span>-}
<span class="lineno"> 2368 </span>
<span class="lineno"> 2369 </span>-- | Convert the permission translations in an 'LOwnedInfo' to SAW core terms
<span class="lineno"> 2370 </span>lownedInfoPCtxTerms :: LOwnedInfo ps ctx -&gt; [OpenTerm]
<span class="lineno"> 2371 </span><span class="decl"><span class="nottickedoff">lownedInfoPCtxTerms = transTerms . lownedInfoPCtx</span></span>
<span class="lineno"> 2372 </span>
<span class="lineno"> 2373 </span>-- | Convert an 'ImpTransInfo' to an 'LOwnedInfo'
<span class="lineno"> 2374 </span>impInfoToLOwned :: ImpTransInfo ext blocks tops rets ps ctx -&gt; LOwnedInfo ps ctx
<span class="lineno"> 2375 </span><span class="decl"><span class="nottickedoff">impInfoToLOwned (ImpTransInfo {..}) =</span>
<span class="lineno"> 2376 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedInfo { lownedInfoECtx = itiExprCtx,</span>
<span class="lineno"> 2377 </span><span class="spaces">               </span><span class="nottickedoff">lownedInfoPCtx = itiPermStack,</span>
<span class="lineno"> 2378 </span><span class="spaces">               </span><span class="nottickedoff">lownedInfoPVars = itiPermStackVars,</span>
<span class="lineno"> 2379 </span><span class="spaces">               </span><span class="nottickedoff">lownedInfoEvType = permEnvEventType itiPermEnv,</span>
<span class="lineno"> 2380 </span><span class="spaces">               </span><span class="nottickedoff">lownedInfoRetType = itiReturnType }</span></span>
<span class="lineno"> 2381 </span>
<span class="lineno"> 2382 </span>-- | Convert an 'LOwnedInfo' to an 'ImpTransInfo' using an existing
<span class="lineno"> 2383 </span>-- 'ImpTransInfo', throwing away all permissions in the 'ImpTransInfo'
<span class="lineno"> 2384 </span>lownedInfoToImp :: LOwnedInfo ps ctx -&gt;
<span class="lineno"> 2385 </span>                   ImpTransInfo ext blocks tops rets ps' ctx' -&gt;
<span class="lineno"> 2386 </span>                   ImpTransInfo ext blocks tops rets ps ctx
<span class="lineno"> 2387 </span><span class="decl"><span class="nottickedoff">lownedInfoToImp (LOwnedInfo {..}) (ImpTransInfo {..}) =</span>
<span class="lineno"> 2388 </span><span class="spaces">  </span><span class="nottickedoff">ImpTransInfo { itiExprCtx = lownedInfoECtx, itiPermStack = lownedInfoPCtx,</span>
<span class="lineno"> 2389 </span><span class="spaces">                 </span><span class="nottickedoff">itiPermStackVars = lownedInfoPVars,</span>
<span class="lineno"> 2390 </span><span class="spaces">                 </span><span class="nottickedoff">itiPermCtx = RL.map (const PTrans_True) lownedInfoECtx,</span>
<span class="lineno"> 2391 </span><span class="spaces">                 </span><span class="nottickedoff">itiReturnType = lownedInfoRetType, .. }</span></span>
<span class="lineno"> 2392 </span>
<span class="lineno"> 2393 </span>loInfoSetPerms :: PermTransCtx ctx ps' -&gt; RAssign (Member ctx) ps' -&gt;
<span class="lineno"> 2394 </span>                  LOwnedInfo ps ctx -&gt; LOwnedInfo ps' ctx
<span class="lineno"> 2395 </span><span class="decl"><span class="nottickedoff">loInfoSetPerms ps' vars' (LOwnedInfo {..}) =</span>
<span class="lineno"> 2396 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedInfo { lownedInfoPCtx = ps', lownedInfoPVars = vars', ..}</span></span>
<span class="lineno"> 2397 </span>
<span class="lineno"> 2398 </span>loInfoSplit :: prx ps1 -&gt; RAssign any ps2 -&gt;
<span class="lineno"> 2399 </span>               LOwnedInfo (ps1 :++: ps2) ctx -&gt;
<span class="lineno"> 2400 </span>               (LOwnedInfo ps1 ctx, LOwnedInfo ps2 ctx)
<span class="lineno"> 2401 </span><span class="decl"><span class="nottickedoff">loInfoSplit (_ :: prx ps1) prx2 (LOwnedInfo {..}) =</span>
<span class="lineno"> 2402 </span><span class="spaces">  </span><span class="nottickedoff">let prx1 :: Proxy ps1 = Proxy</span>
<span class="lineno"> 2403 </span><span class="spaces">      </span><span class="nottickedoff">(ps1, ps2) = RL.split prx1 prx2 lownedInfoPCtx</span>
<span class="lineno"> 2404 </span><span class="spaces">      </span><span class="nottickedoff">(vars1, vars2) = RL.split prx1 prx2 lownedInfoPVars in</span>
<span class="lineno"> 2405 </span><span class="spaces">  </span><span class="nottickedoff">(LOwnedInfo { lownedInfoPCtx = ps1, lownedInfoPVars = vars1, .. },</span>
<span class="lineno"> 2406 </span><span class="spaces">   </span><span class="nottickedoff">LOwnedInfo { lownedInfoPCtx = ps2, lownedInfoPVars = vars2, .. })</span></span>
<span class="lineno"> 2407 </span>
<span class="lineno"> 2408 </span>loInfoAppend :: LOwnedInfo ps1 ctx -&gt; LOwnedInfo ps2 ctx -&gt;
<span class="lineno"> 2409 </span>                LOwnedInfo (ps1 :++: ps2) ctx
<span class="lineno"> 2410 </span><span class="decl"><span class="nottickedoff">loInfoAppend info1 info2 =</span>
<span class="lineno"> 2411 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedInfo { lownedInfoECtx = lownedInfoECtx info1</span>
<span class="lineno"> 2412 </span><span class="spaces">             </span><span class="nottickedoff">, lownedInfoPCtx =</span>
<span class="lineno"> 2413 </span><span class="spaces">                 </span><span class="nottickedoff">RL.append (lownedInfoPCtx info1) (lownedInfoPCtx info2)</span>
<span class="lineno"> 2414 </span><span class="spaces">             </span><span class="nottickedoff">, lownedInfoPVars =</span>
<span class="lineno"> 2415 </span><span class="spaces">                 </span><span class="nottickedoff">RL.append (lownedInfoPVars info1) (lownedInfoPVars info2)</span>
<span class="lineno"> 2416 </span><span class="spaces">             </span><span class="nottickedoff">, lownedInfoEvType = lownedInfoEvType info1</span>
<span class="lineno"> 2417 </span><span class="spaces">             </span><span class="nottickedoff">, lownedInfoRetType = lownedInfoRetType info1 }</span></span>
<span class="lineno"> 2418 </span>
<span class="lineno"> 2419 </span>extLOwnedInfoExt :: ExprCtxExt ctx1 ctx2 -&gt; LOwnedInfo ps ctx1 -&gt;
<span class="lineno"> 2420 </span>                    LOwnedInfo ps ctx2
<span class="lineno"> 2421 </span><span class="decl"><span class="nottickedoff">extLOwnedInfoExt cext@(ExprCtxExt ectx3) (LOwnedInfo {..}) =</span>
<span class="lineno"> 2422 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedInfo { lownedInfoECtx = RL.append lownedInfoECtx ectx3,</span>
<span class="lineno"> 2423 </span><span class="spaces">               </span><span class="nottickedoff">lownedInfoPCtx = extPermTransCtxExt cext lownedInfoPCtx,</span>
<span class="lineno"> 2424 </span><span class="spaces">               </span><span class="nottickedoff">lownedInfoPVars = RL.map (weakenMemberR ectx3) lownedInfoPVars,</span>
<span class="lineno"> 2425 </span><span class="spaces">               </span><span class="nottickedoff">.. }</span></span>
<span class="lineno"> 2426 </span>
<span class="lineno"> 2427 </span>extLOwnedInfo :: ExprTrans tp -&gt; LOwnedInfo ps ctx -&gt; LOwnedInfo ps (ctx :&gt; tp)
<span class="lineno"> 2428 </span><span class="decl"><span class="nottickedoff">extLOwnedInfo etrans = extLOwnedInfoExt (ExprCtxExt (MNil :&gt;: etrans))</span></span>
<span class="lineno"> 2429 </span>
<span class="lineno"> 2430 </span>-- | An 'LOwnedTransM' is a form of parameterized continuation-state monad
<span class="lineno"> 2431 </span>-- similar to the construct in GenMonad.hs. A computation of this type returns
<span class="lineno"> 2432 </span>-- an @a@ while also mapping from permission stack @ps_in@, represented as an
<span class="lineno"> 2433 </span>-- 'LOwnedInfo', to permission stack @ps_out@. The additional complexity here is
<span class="lineno"> 2434 </span>-- that the expression context @ctx@ can change during computation, and that
<span class="lineno"> 2435 </span>-- type argument parameterizes the 'LOwnedInfo' structure. Specifically, the
<span class="lineno"> 2436 </span>-- 'LOwnedInfo' structure for @ps_in@ can be relative to any context @ctx_in@
<span class="lineno"> 2437 </span>-- that extends type argument @ctx@, where the extension is chosen by the caller
<span class="lineno"> 2438 </span>-- / context outside the computation. The computation itself can then choose the
<span class="lineno"> 2439 </span>-- extended context @ctx_out@ extending @ctx_in@ to be used for the 'LOwnedInfo'
<span class="lineno"> 2440 </span>-- structure for @ps_out@.
<span class="lineno"> 2441 </span>newtype LOwnedTransM ps_in ps_out ctx a =
<span class="lineno"> 2442 </span>  LOwnedTransM {
<span class="lineno"> 2443 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">runLOwnedTransM</span></span></span> ::
<span class="lineno"> 2444 </span>      forall ctx_in. ExprCtxExt ctx ctx_in -&gt; LOwnedInfo ps_in ctx_in -&gt;
<span class="lineno"> 2445 </span>      (forall ctx_out. ExprCtxExt ctx_in ctx_out -&gt; LOwnedInfo ps_out ctx_out -&gt;
<span class="lineno"> 2446 </span>       a -&gt; OpenTerm) -&gt;
<span class="lineno"> 2447 </span>      OpenTerm }
<span class="lineno"> 2448 </span>
<span class="lineno"> 2449 </span>-- | The bind operation for 'LOwnedTransM'
<span class="lineno"> 2450 </span>(&gt;&gt;&gt;=) :: LOwnedTransM ps_in ps' ctx a -&gt; (a -&gt; LOwnedTransM ps' ps_out ctx b) -&gt;
<span class="lineno"> 2451 </span>          LOwnedTransM ps_in ps_out ctx b
<span class="lineno"> 2452 </span><span class="decl"><span class="nottickedoff">m &gt;&gt;&gt;= f = LOwnedTransM $ \cext s1 k -&gt;</span>
<span class="lineno"> 2453 </span><span class="spaces">  </span><span class="nottickedoff">runLOwnedTransM m cext s1 $ \cext' s2 x -&gt;</span>
<span class="lineno"> 2454 </span><span class="spaces">  </span><span class="nottickedoff">runLOwnedTransM (f x) (transExprCtxExt cext cext') s2 $ \cext'' -&gt;</span>
<span class="lineno"> 2455 </span><span class="spaces">  </span><span class="nottickedoff">k (transExprCtxExt cext' cext'')</span></span>
<span class="lineno"> 2456 </span>
<span class="lineno"> 2457 </span>-- | The bind operation for 'LOwnedTransM' that throws away the first value
<span class="lineno"> 2458 </span>(&gt;&gt;&gt;) :: LOwnedTransM ps_in ps' ctx a -&gt; LOwnedTransM ps' ps_out ctx b -&gt;
<span class="lineno"> 2459 </span>         LOwnedTransM ps_in ps_out ctx b
<span class="lineno"> 2460 </span><span class="decl"><span class="nottickedoff">m1 &gt;&gt;&gt; m2 = m1 &gt;&gt;&gt;= \_ -&gt; m2</span></span>
<span class="lineno"> 2461 </span>
<span class="lineno"> 2462 </span>instance <span class="decl"><span class="nottickedoff">Functor (LOwnedTransM ps_in ps_out ctx)</span></span> where
<span class="lineno"> 2463 </span>  <span class="decl"><span class="nottickedoff">fmap f m = m &gt;&gt;&gt;= \x -&gt; return (f x)</span></span>
<span class="lineno"> 2464 </span>
<span class="lineno"> 2465 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative (LOwnedTransM ps ps ctx)</span></span></span></span></span></span> where
<span class="lineno"> 2466 </span>  <span class="decl"><span class="nottickedoff">pure x = LOwnedTransM $ \_ s k -&gt; k reflExprCtxExt s x</span></span>
<span class="lineno"> 2467 </span>  <span class="decl"><span class="nottickedoff">(&lt;*&gt;) = Monad.ap</span></span>
<span class="lineno"> 2468 </span>
<span class="lineno"> 2469 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monad (LOwnedTransM ps ps ctx)</span></span></span></span> where
<span class="lineno"> 2470 </span>  <span class="decl"><span class="nottickedoff">(&gt;&gt;=) = (&gt;&gt;&gt;=)</span></span>
<span class="lineno"> 2471 </span>
<span class="lineno"> 2472 </span>-- | Set the output permission stack to @ps_out@
<span class="lineno"> 2473 </span>gput :: LOwnedInfo ps_out ctx -&gt; LOwnedTransM ps_in ps_out ctx ()
<span class="lineno"> 2474 </span><span class="decl"><span class="nottickedoff">gput loInfo =</span>
<span class="lineno"> 2475 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTransM $ \cext _ k -&gt;</span>
<span class="lineno"> 2476 </span><span class="spaces">  </span><span class="nottickedoff">k reflExprCtxExt (extLOwnedInfoExt cext loInfo) ()</span></span>
<span class="lineno"> 2477 </span>
<span class="lineno"> 2478 </span>{-
<span class="lineno"> 2479 </span>data ExtLOwnedInfo ps ctx where
<span class="lineno"> 2480 </span>  ExtLOwnedInfo :: ExprCtxExt ctx ctx' -&gt; LOwnedInfo ps ctx' -&gt;
<span class="lineno"> 2481 </span>                   ExtLOwnedInfo ps ctx
<span class="lineno"> 2482 </span>
<span class="lineno"> 2483 </span>instance ps_in ~ ps_out =&gt;
<span class="lineno"> 2484 </span>         MonadState (ExtLOwnedInfo ps_in ctx) (LOwnedTransM ps_in ps_out ctx) where
<span class="lineno"> 2485 </span>  get = LOwnedTransM $ \cext s k -&gt; k reflExprCtxExt s (ExtLOwnedInfo cext s)
<span class="lineno"> 2486 </span>  put = gput
<span class="lineno"> 2487 </span>-}
<span class="lineno"> 2488 </span>
<span class="lineno"> 2489 </span>-- | Get the current permission stack, with the additional complexity that it
<span class="lineno"> 2490 </span>-- could be in an extended expression context @ctx'@
<span class="lineno"> 2491 </span>ggetting :: (forall ctx'. ExprCtxExt ctx ctx' -&gt;
<span class="lineno"> 2492 </span>             LOwnedInfo ps_in ctx' -&gt; LOwnedTransM ps_in ps_out ctx' a) -&gt;
<span class="lineno"> 2493 </span>            LOwnedTransM ps_in ps_out ctx a
<span class="lineno"> 2494 </span><span class="decl"><span class="nottickedoff">ggetting f =</span>
<span class="lineno"> 2495 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTransM $ \cext s k -&gt;</span>
<span class="lineno"> 2496 </span><span class="spaces">  </span><span class="nottickedoff">runLOwnedTransM (f cext s) reflExprCtxExt s $ \cext' -&gt;</span>
<span class="lineno"> 2497 </span><span class="spaces">  </span><span class="nottickedoff">k cext'</span></span>
<span class="lineno"> 2498 </span>
<span class="lineno"> 2499 </span>-- | Modify the current permission stack relative to its extended expression
<span class="lineno"> 2500 </span>-- context @ctx'@
<span class="lineno"> 2501 </span>gmodify :: (forall ctx'. ExprCtxExt ctx ctx' -&gt;
<span class="lineno"> 2502 </span>            LOwnedInfo ps_in ctx' -&gt; LOwnedInfo ps_out ctx') -&gt;
<span class="lineno"> 2503 </span>           LOwnedTransM ps_in ps_out ctx ()
<span class="lineno"> 2504 </span><span class="decl"><span class="nottickedoff">gmodify f = ggetting $ \cext loInfo -&gt; gput (f cext loInfo)</span></span>
<span class="lineno"> 2505 </span>
<span class="lineno"> 2506 </span>-- | Extend the expression context of an 'LOwnedTransM' computation
<span class="lineno"> 2507 </span>extLOwnedTransM :: ExprCtxExt ctx ctx' -&gt; LOwnedTransM ps_in ps_out ctx a -&gt;
<span class="lineno"> 2508 </span>                   LOwnedTransM ps_in ps_out ctx' a
<span class="lineno"> 2509 </span><span class="decl"><span class="nottickedoff">extLOwnedTransM cext m =</span>
<span class="lineno"> 2510 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTransM $ \cext' -&gt; runLOwnedTransM m (transExprCtxExt cext cext')</span></span>
<span class="lineno"> 2511 </span>
<span class="lineno"> 2512 </span>-- | A representation of the translation of an @lowned@ permission as a
<span class="lineno"> 2513 </span>-- transformer from a permission stack @ps_in@ to a permission stack @ps_out@
<span class="lineno"> 2514 </span>type LOwnedTransTerm ctx ps_in ps_out = LOwnedTransM ps_in ps_out ctx ()
<span class="lineno"> 2515 </span>
<span class="lineno"> 2516 </span>-- | Build an 'LOwnedTransTerm' transformer from @ps_in@ to @ps_out@ relative to
<span class="lineno"> 2517 </span>-- context @ctx@ that applies a single SAW core monadic function that takes in
<span class="lineno"> 2518 </span>-- the translations of @ps_in@ and returns a tuple of the translations of
<span class="lineno"> 2519 </span>-- @ps_out@
<span class="lineno"> 2520 </span>mkLOwnedTransTermFromTerm :: DescPermsTpTrans ctx ps_in -&gt;
<span class="lineno"> 2521 </span>                             DescPermsTpTrans ctx ps_out -&gt;
<span class="lineno"> 2522 </span>                             RAssign (Member ctx) ps_out -&gt; OpenTerm -&gt;
<span class="lineno"> 2523 </span>                             LOwnedTransTerm ctx ps_in ps_out
<span class="lineno"> 2524 </span><span class="decl"><span class="nottickedoff">mkLOwnedTransTermFromTerm _trans_in trans_out vars_out t =</span>
<span class="lineno"> 2525 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTransM $ \(ExprCtxExt ctx') loInfo k -&gt;</span>
<span class="lineno"> 2526 </span><span class="spaces">  </span><span class="nottickedoff">let ev = lownedInfoEvType loInfo</span>
<span class="lineno"> 2527 </span><span class="spaces">      </span><span class="nottickedoff">t_app = applyOpenTermMulti t $ lownedInfoPCtxTerms loInfo</span>
<span class="lineno"> 2528 </span><span class="spaces">      </span><span class="nottickedoff">t_ret_trans = tupleTypeTrans $ descTypeTrans trans_out</span>
<span class="lineno"> 2529 </span><span class="spaces">      </span><span class="nottickedoff">t_ret_tp = typeTransTupleType $ descTypeTrans trans_out in</span>
<span class="lineno"> 2530 </span><span class="spaces">  </span><span class="nottickedoff">bindSOpenTerm ev t_ret_tp (lownedInfoRetType loInfo) t_app $</span>
<span class="lineno"> 2531 </span><span class="spaces">  </span><span class="nottickedoff">lambdaOpenTerm &quot;lowned_ret&quot; t_ret_tp $ \lowned_ret -&gt;</span>
<span class="lineno"> 2532 </span><span class="spaces">  </span><span class="nottickedoff">let pctx_out' =</span>
<span class="lineno"> 2533 </span><span class="spaces">        </span><span class="nottickedoff">extPermTransCtxMulti ctx' $ typeTransF t_ret_trans [lowned_ret]</span>
<span class="lineno"> 2534 </span><span class="spaces">      </span><span class="nottickedoff">vars_out' = RL.map (weakenMemberR ctx') vars_out in</span>
<span class="lineno"> 2535 </span><span class="spaces">  </span><span class="nottickedoff">k reflExprCtxExt (loInfoSetPerms pctx_out' vars_out' loInfo) ()</span></span>
<span class="lineno"> 2536 </span>
<span class="lineno"> 2537 </span>
<span class="lineno"> 2538 </span>-- | Build the SAW core term for the function of type @specFun T@ for the
<span class="lineno"> 2539 </span>-- transformation from @ps_in@ to @ps_out@ represented by an 'LOwnedTransTerm'
<span class="lineno"> 2540 </span>lownedTransTermFun :: EventType -&gt; ExprTransCtx ctx -&gt;
<span class="lineno"> 2541 </span>                      RAssign (Member ctx) ps_in -&gt;
<span class="lineno"> 2542 </span>                      DescPermsTpTrans ctx ps_in -&gt;
<span class="lineno"> 2543 </span>                      DescPermsTpTrans ctx ps_out -&gt;
<span class="lineno"> 2544 </span>                      LOwnedTransTerm ctx ps_in ps_out -&gt; OpenTerm
<span class="lineno"> 2545 </span><span class="decl"><span class="nottickedoff">lownedTransTermFun ev ectx vars_in tps_in tps_out t =</span>
<span class="lineno"> 2546 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTrans &quot;p&quot; (descTypeTrans tps_in) $ \ps_in -&gt;</span>
<span class="lineno"> 2547 </span><span class="spaces">  </span><span class="nottickedoff">let ret_tp = typeTransTupleType $ descTypeTrans tps_out</span>
<span class="lineno"> 2548 </span><span class="spaces">      </span><span class="nottickedoff">loInfo =</span>
<span class="lineno"> 2549 </span><span class="spaces">        </span><span class="nottickedoff">LOwnedInfo { lownedInfoECtx = ectx,</span>
<span class="lineno"> 2550 </span><span class="spaces">                     </span><span class="nottickedoff">lownedInfoPCtx = ps_in, lownedInfoPVars = vars_in,</span>
<span class="lineno"> 2551 </span><span class="spaces">                     </span><span class="nottickedoff">lownedInfoEvType = ev, lownedInfoRetType = ret_tp } in</span>
<span class="lineno"> 2552 </span><span class="spaces">  </span><span class="nottickedoff">runLOwnedTransM t reflExprCtxExt loInfo $ \_ loInfo_out _ -&gt;</span>
<span class="lineno"> 2553 </span><span class="spaces">  </span><span class="nottickedoff">retSOpenTerm ev ret_tp $ tupleOpenTerm' $ lownedInfoPCtxTerms loInfo_out</span></span>
<span class="lineno"> 2554 </span>
<span class="lineno"> 2555 </span>-- | Extend the expression context of an 'LOwnedTransTerm'
<span class="lineno"> 2556 </span>extLOwnedTransTerm :: ExprTransCtx ctx2 -&gt;
<span class="lineno"> 2557 </span>                      LOwnedTransTerm ctx1 ps_in ps_out -&gt;
<span class="lineno"> 2558 </span>                      LOwnedTransTerm (ctx1 :++: ctx2) ps_in ps_out
<span class="lineno"> 2559 </span><span class="decl"><span class="nottickedoff">extLOwnedTransTerm ectx2 = extLOwnedTransM (ExprCtxExt ectx2)</span></span>
<span class="lineno"> 2560 </span>
<span class="lineno"> 2561 </span>-- | Build an 'LOwnedTransTerm' that acts as the identity function on the SAW
<span class="lineno"> 2562 </span>-- core terms in the permissions, using the supplied permission translation for
<span class="lineno"> 2563 </span>-- the output permissions, which must have the same SAW core terms as the input
<span class="lineno"> 2564 </span>-- permissions (or the identity translation would be ill-typed)
<span class="lineno"> 2565 </span>idLOwnedTransTerm :: DescPermsTpTrans ctx ps_out -&gt;
<span class="lineno"> 2566 </span>                     RAssign (Member ctx) ps_out -&gt;
<span class="lineno"> 2567 </span>                     LOwnedTransTerm ctx ps_in ps_out
<span class="lineno"> 2568 </span><span class="decl"><span class="nottickedoff">idLOwnedTransTerm dtr_out vars_out =</span>
<span class="lineno"> 2569 </span><span class="spaces">  </span><span class="nottickedoff">gmodify $ \(ExprCtxExt ctx') loInfo -&gt;</span>
<span class="lineno"> 2570 </span><span class="spaces">  </span><span class="nottickedoff">loInfo { lownedInfoPVars = RL.map (weakenMemberR ctx') vars_out,</span>
<span class="lineno"> 2571 </span><span class="spaces">           </span><span class="nottickedoff">lownedInfoPCtx =</span>
<span class="lineno"> 2572 </span><span class="spaces">             </span><span class="nottickedoff">descTypeTransF (fmap (extPermTransCtxMulti ctx') dtr_out)</span>
<span class="lineno"> 2573 </span><span class="spaces">             </span><span class="nottickedoff">(lownedInfoPCtxTerms loInfo) }</span></span>
<span class="lineno"> 2574 </span>
<span class="lineno"> 2575 </span>
<span class="lineno"> 2576 </span>-- | Partially apply an 'LOwnedTransTerm' to some of its input permissions
<span class="lineno"> 2577 </span>applyLOwnedTransTerm :: prx ps_in -&gt; PermTransCtx ctx ps_extra -&gt;
<span class="lineno"> 2578 </span>                        RAssign (Member ctx) ps_extra -&gt;
<span class="lineno"> 2579 </span>                        LOwnedTransTerm ctx (ps_extra :++: ps_in) ps_out -&gt;
<span class="lineno"> 2580 </span>                        LOwnedTransTerm ctx ps_in ps_out
<span class="lineno"> 2581 </span><span class="decl"><span class="nottickedoff">applyLOwnedTransTerm _ ps_extra vars_extra t =</span>
<span class="lineno"> 2582 </span><span class="spaces">  </span><span class="nottickedoff">gmodify (\(ExprCtxExt ctx') loInfo -&gt;</span>
<span class="lineno"> 2583 </span><span class="spaces">            </span><span class="nottickedoff">loInfoSetPerms</span>
<span class="lineno"> 2584 </span><span class="spaces">            </span><span class="nottickedoff">(RL.append (extPermTransCtxMulti ctx' ps_extra)</span>
<span class="lineno"> 2585 </span><span class="spaces">             </span><span class="nottickedoff">(lownedInfoPCtx loInfo))</span>
<span class="lineno"> 2586 </span><span class="spaces">            </span><span class="nottickedoff">(RL.append (RL.map (weakenMemberR ctx') vars_extra)</span>
<span class="lineno"> 2587 </span><span class="spaces">             </span><span class="nottickedoff">(lownedInfoPVars loInfo))</span>
<span class="lineno"> 2588 </span><span class="spaces">            </span><span class="nottickedoff">loInfo)</span>
<span class="lineno"> 2589 </span><span class="spaces">  </span><span class="nottickedoff">&gt;&gt;&gt; t</span></span>
<span class="lineno"> 2590 </span>
<span class="lineno"> 2591 </span>-- | Weaken an 'LOwnedTransTerm' by adding an extra permission to its input and
<span class="lineno"> 2592 </span>-- output permissions
<span class="lineno"> 2593 </span>weakenLOwnedTransTerm :: Desc1PermTpTrans ctx tp -&gt;
<span class="lineno"> 2594 </span>                         LOwnedTransTerm ctx ps_in ps_out -&gt;
<span class="lineno"> 2595 </span>                         LOwnedTransTerm ctx (ps_in :&gt; tp) (ps_out :&gt; tp)
<span class="lineno"> 2596 </span><span class="decl"><span class="nottickedoff">weakenLOwnedTransTerm tptr t =</span>
<span class="lineno"> 2597 </span><span class="spaces">  </span><span class="nottickedoff">ggetting $ \cext info_top -&gt;</span>
<span class="lineno"> 2598 </span><span class="spaces">  </span><span class="nottickedoff">let (info_ps_in, info_tp) = loInfoSplit Proxy (MNil :&gt;: Proxy) info_top in</span>
<span class="lineno"> 2599 </span><span class="spaces">  </span><span class="nottickedoff">gput info_ps_in &gt;&gt;&gt;</span>
<span class="lineno"> 2600 </span><span class="spaces">  </span><span class="nottickedoff">extLOwnedTransM cext t &gt;&gt;&gt;</span>
<span class="lineno"> 2601 </span><span class="spaces">  </span><span class="nottickedoff">gmodify (\cext' info' -&gt;</span>
<span class="lineno"> 2602 </span><span class="spaces">            </span><span class="nottickedoff">loInfoAppend info' $ extLOwnedInfoExt cext' $</span>
<span class="lineno"> 2603 </span><span class="spaces">            </span><span class="nottickedoff">info_tp { lownedInfoPCtx =</span>
<span class="lineno"> 2604 </span><span class="spaces">                        </span><span class="nottickedoff">(MNil :&gt;:) $ extPermTransExt cext $</span>
<span class="lineno"> 2605 </span><span class="spaces">                        </span><span class="nottickedoff">descTypeTransF tptr (lownedInfoPCtxTerms info_tp) })</span></span>
<span class="lineno"> 2606 </span>
<span class="lineno"> 2607 </span>-- | Combine 'LOwnedTransTerm's for the 'SImpl_MapLifetime' rule
<span class="lineno"> 2608 </span>mapLtLOwnedTransTerm ::
<span class="lineno"> 2609 </span>  prx ps_extra1 -&gt; RAssign any1 ps_extra2 -&gt; RAssign any2 ps_in -&gt;
<span class="lineno"> 2610 </span>  LOwnedTransTerm ctx (ps_extra1 :++: ps_in) ps_mid -&gt;
<span class="lineno"> 2611 </span>  LOwnedTransTerm ctx (ps_extra2 :++: ps_mid) ps_out -&gt;
<span class="lineno"> 2612 </span>  LOwnedTransTerm ctx ((ps_extra1 :++: ps_extra2) :++: ps_in) ps_out
<span class="lineno"> 2613 </span><span class="decl"><span class="nottickedoff">mapLtLOwnedTransTerm prx_extra1 prx_extra2 prx_in t1 t2 =</span>
<span class="lineno"> 2614 </span><span class="spaces">  </span><span class="nottickedoff">ggetting $ \cext info_extra_in -&gt;</span>
<span class="lineno"> 2615 </span><span class="spaces">  </span><span class="nottickedoff">let (info_extra, info_in) = loInfoSplit Proxy prx_in info_extra_in</span>
<span class="lineno"> 2616 </span><span class="spaces">      </span><span class="nottickedoff">(info_extra1, info_extra2) =</span>
<span class="lineno"> 2617 </span><span class="spaces">        </span><span class="nottickedoff">loInfoSplit prx_extra1 prx_extra2 info_extra in</span>
<span class="lineno"> 2618 </span><span class="spaces">  </span><span class="nottickedoff">gput (loInfoAppend info_extra1 info_in) &gt;&gt;&gt;</span>
<span class="lineno"> 2619 </span><span class="spaces">  </span><span class="nottickedoff">extLOwnedTransM cext t1 &gt;&gt;&gt;</span>
<span class="lineno"> 2620 </span><span class="spaces">  </span><span class="nottickedoff">gmodify (\cext' info_out -&gt;</span>
<span class="lineno"> 2621 </span><span class="spaces">            </span><span class="nottickedoff">loInfoAppend (extLOwnedInfoExt cext' info_extra2) info_out) &gt;&gt;&gt;</span>
<span class="lineno"> 2622 </span><span class="spaces">  </span><span class="nottickedoff">extLOwnedTransM cext t2</span></span>
<span class="lineno"> 2623 </span>
<span class="lineno"> 2624 </span>-- | The translation of an @lowned@ permission
<span class="lineno"> 2625 </span>data LOwnedTrans ctx ps_extra ps_in ps_out =
<span class="lineno"> 2626 </span>  LOwnedTrans {
<span class="lineno"> 2627 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrEvType</span></span></span> :: EventType,
<span class="lineno"> 2628 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrECtx</span></span></span> :: ExprTransCtx ctx,
<span class="lineno"> 2629 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrPsExtra</span></span></span> :: PermTransCtx ctx ps_extra,
<span class="lineno"> 2630 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrVarsExtra</span></span></span> :: RAssign (Member ctx) ps_extra,
<span class="lineno"> 2631 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrTpTransIn</span></span></span> :: DescPermsTpTrans ctx ps_in,
<span class="lineno"> 2632 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrTpTransOut</span></span></span> :: DescPermsTpTrans ctx ps_out,
<span class="lineno"> 2633 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrTpTransExtra</span></span></span> :: DescPermsTpTrans ctx ps_extra,
<span class="lineno"> 2634 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">lotrTerm</span></span></span> :: LOwnedTransTerm ctx (ps_extra :++: ps_in) ps_out }
<span class="lineno"> 2635 </span>
<span class="lineno"> 2636 </span>-- | Build an initial 'LOwnedTrans' with an empty @ps_extra@
<span class="lineno"> 2637 </span>mkLOwnedTrans :: EventType -&gt; ExprTransCtx ctx -&gt; DescPermsTpTrans ctx ps_in -&gt;
<span class="lineno"> 2638 </span>                 DescPermsTpTrans ctx ps_out -&gt; RAssign (Member ctx) ps_out -&gt;
<span class="lineno"> 2639 </span>                 OpenTerm -&gt; LOwnedTrans ctx RNil ps_in ps_out
<span class="lineno"> 2640 </span><span class="decl"><span class="nottickedoff">mkLOwnedTrans ev ectx tps_in tps_out vars_out t =</span>
<span class="lineno"> 2641 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTrans ev ectx MNil MNil tps_in tps_out (pure MNil)</span>
<span class="lineno"> 2642 </span><span class="spaces">  </span><span class="nottickedoff">(mkLOwnedTransTermFromTerm (preNilDescPermsTpTrans tps_in) tps_out vars_out t)</span></span>
<span class="lineno"> 2643 </span>
<span class="lineno"> 2644 </span>-- | Build an initial 'LOwnedTrans' with an empty @ps_extra@ and an identity
<span class="lineno"> 2645 </span>-- function on SAW core terms
<span class="lineno"> 2646 </span>mkLOwnedTransId :: EventType -&gt; ExprTransCtx ctx -&gt; DescPermsTpTrans ctx ps -&gt;
<span class="lineno"> 2647 </span>                   DescPermsTpTrans ctx ps -&gt; RAssign (Member ctx) ps -&gt;
<span class="lineno"> 2648 </span>                   LOwnedTrans ctx RNil ps ps
<span class="lineno"> 2649 </span><span class="decl"><span class="nottickedoff">mkLOwnedTransId ev ectx tps_in tps_out vars_out =</span>
<span class="lineno"> 2650 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTrans ev ectx MNil MNil tps_in tps_out (pure MNil)</span>
<span class="lineno"> 2651 </span><span class="spaces">  </span><span class="nottickedoff">(idLOwnedTransTerm tps_out vars_out)</span></span>
<span class="lineno"> 2652 </span>
<span class="lineno"> 2653 </span>-- | Extend the context of an 'LOwnedTrans'
<span class="lineno"> 2654 </span>extLOwnedTransMulti :: ExprTransCtx ctx2 -&gt;
<span class="lineno"> 2655 </span>                       LOwnedTrans ctx1 ps_extra ps_in ps_out -&gt;
<span class="lineno"> 2656 </span>                       LOwnedTrans (ctx1 :++: ctx2) ps_extra ps_in ps_out
<span class="lineno"> 2657 </span><span class="decl"><span class="nottickedoff">extLOwnedTransMulti ctx2 (LOwnedTrans ev ectx ps_extra vars_extra ptrans_in</span>
<span class="lineno"> 2658 </span><span class="spaces">                          </span><span class="nottickedoff">ptrans_out ptrans_extra t) =</span>
<span class="lineno"> 2659 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTrans</span>
<span class="lineno"> 2660 </span><span class="spaces">  </span><span class="nottickedoff">ev (RL.append ectx ctx2) (extPermTransCtxMulti ctx2 ps_extra)</span>
<span class="lineno"> 2661 </span><span class="spaces">  </span><span class="nottickedoff">(RL.map (weakenMemberR ctx2) vars_extra)</span>
<span class="lineno"> 2662 </span><span class="spaces">  </span><span class="nottickedoff">(fmap (extPermTransCtxMulti ctx2) ptrans_in)</span>
<span class="lineno"> 2663 </span><span class="spaces">  </span><span class="nottickedoff">(fmap (extPermTransCtxMulti ctx2) ptrans_out)</span>
<span class="lineno"> 2664 </span><span class="spaces">  </span><span class="nottickedoff">(fmap (extPermTransCtxMulti ctx2) ptrans_extra)</span>
<span class="lineno"> 2665 </span><span class="spaces">  </span><span class="nottickedoff">(extLOwnedTransTerm ctx2 t)</span></span>
<span class="lineno"> 2666 </span>
<span class="lineno"> 2667 </span>-- | Weaken an 'LOwnedTrans' by adding one more permission to the input and
<span class="lineno"> 2668 </span>-- output permission lists. The SAW core terms taken in for the new input
<span class="lineno"> 2669 </span>-- permission are used as the SAW core terms for the new output permission, so
<span class="lineno"> 2670 </span>-- the weakening acts as a form of identity function between these new
<span class="lineno"> 2671 </span>-- permissions. The new input and output permissions can be different, but they
<span class="lineno"> 2672 </span>-- should translate to the same list of SAW core types, or otherwise the new
<span class="lineno"> 2673 </span>-- transformation would be ill-typed.
<span class="lineno"> 2674 </span>weakenLOwnedTrans ::
<span class="lineno"> 2675 </span>  Desc1PermTpTrans ctx tp -&gt;
<span class="lineno"> 2676 </span>  Desc1PermTpTrans ctx tp -&gt;
<span class="lineno"> 2677 </span>  LOwnedTrans ctx ps_extra ps_in ps_out -&gt;
<span class="lineno"> 2678 </span>  LOwnedTrans ctx ps_extra (ps_in :&gt; tp) (ps_out :&gt; tp)
<span class="lineno"> 2679 </span><span class="decl"><span class="nottickedoff">weakenLOwnedTrans tp_in tp_out (LOwnedTrans {..}) =</span>
<span class="lineno"> 2680 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTrans { lotrTpTransIn = App.liftA2 (:&gt;:) lotrTpTransIn tp_in,</span>
<span class="lineno"> 2681 </span><span class="spaces">                </span><span class="nottickedoff">lotrTpTransOut = App.liftA2 (:&gt;:) lotrTpTransOut tp_out,</span>
<span class="lineno"> 2682 </span><span class="spaces">                </span><span class="nottickedoff">lotrTerm = weakenLOwnedTransTerm tp_out lotrTerm, .. }</span></span>
<span class="lineno"> 2683 </span>
<span class="lineno"> 2684 </span>-- | Convert an 'LOwnedTrans' to a monadic function from @ps_in@ to @ps_out@ by
<span class="lineno"> 2685 </span>-- partially applying its function to the @ps_extra@ permissions it already
<span class="lineno"> 2686 </span>-- contains
<span class="lineno"> 2687 </span>lownedTransTerm :: Mb ctx (ExprPerms ps_in) -&gt;
<span class="lineno"> 2688 </span>                   LOwnedTrans ctx ps_extra ps_in ps_out -&gt; OpenTerm
<span class="lineno"> 2689 </span><span class="decl"><span class="nottickedoff">lownedTransTerm (mbExprPermsMembers -&gt; Just vars_in) lotr =</span>
<span class="lineno"> 2690 </span><span class="spaces">  </span><span class="nottickedoff">let lot = applyLOwnedTransTerm Proxy</span>
<span class="lineno"> 2691 </span><span class="spaces">        </span><span class="nottickedoff">(lotrPsExtra lotr) (lotrVarsExtra lotr) (lotrTerm lotr) in</span>
<span class="lineno"> 2692 </span><span class="spaces">  </span><span class="nottickedoff">lownedTransTermFun (lotrEvType lotr) (lotrECtx lotr) vars_in</span>
<span class="lineno"> 2693 </span><span class="spaces">  </span><span class="nottickedoff">(lotrTpTransIn lotr) (lotrTpTransOut lotr) lot</span>
<span class="lineno"> 2694 </span><span class="spaces"></span><span class="nottickedoff">lownedTransTerm _ _ =</span>
<span class="lineno"> 2695 </span><span class="spaces">  </span><span class="nottickedoff">failOpenTerm &quot;FIXME HERE NOW: write this error message&quot;</span></span>
<span class="lineno"> 2696 </span>
<span class="lineno"> 2697 </span>-- | Apply the 'SImpl_MapLifetime' rule to an 'LOwnedTrans'
<span class="lineno"> 2698 </span>mapLtLOwnedTrans ::
<span class="lineno"> 2699 </span>  PermTransCtx ctx ps1 -&gt; RAssign (Member ctx) ps1 -&gt;
<span class="lineno"> 2700 </span>  DescPermsTpTrans ctx ps1 -&gt;
<span class="lineno"> 2701 </span>  PermTransCtx ctx ps2 -&gt; RAssign (Member ctx) ps2 -&gt;
<span class="lineno"> 2702 </span>  DescPermsTpTrans ctx ps2 -&gt;
<span class="lineno"> 2703 </span>  RAssign any ps_in' -&gt; DescPermsTpTrans ctx ps_in' -&gt;
<span class="lineno"> 2704 </span>  DescPermsTpTrans ctx ps_out' -&gt;
<span class="lineno"> 2705 </span>  LOwnedTransTerm ctx (ps1 :++: ps_in') ps_in -&gt;
<span class="lineno"> 2706 </span>  LOwnedTransTerm ctx (ps2 :++: ps_out) ps_out' -&gt;
<span class="lineno"> 2707 </span>  LOwnedTrans ctx ps_extra ps_in ps_out -&gt;
<span class="lineno"> 2708 </span>  LOwnedTrans ctx ((ps1 :++: ps_extra) :++: ps2) ps_in' ps_out'
<span class="lineno"> 2709 </span><span class="decl"><span class="nottickedoff">mapLtLOwnedTrans pctx1 vars1 dtr1 pctx2 vars2 dtr2</span>
<span class="lineno"> 2710 </span><span class="spaces">  </span><span class="nottickedoff">prx_in' dtr_in' dtr_out' t1 t2</span>
<span class="lineno"> 2711 </span><span class="spaces">  </span><span class="nottickedoff">(LOwnedTrans {..}) =</span>
<span class="lineno"> 2712 </span><span class="spaces">  </span><span class="nottickedoff">LOwnedTrans</span>
<span class="lineno"> 2713 </span><span class="spaces">  </span><span class="nottickedoff">{ lotrEvType = lotrEvType</span>
<span class="lineno"> 2714 </span><span class="spaces">  </span><span class="nottickedoff">, lotrECtx = lotrECtx</span>
<span class="lineno"> 2715 </span><span class="spaces">  </span><span class="nottickedoff">, lotrPsExtra = RL.append (RL.append pctx1 lotrPsExtra) pctx2</span>
<span class="lineno"> 2716 </span><span class="spaces">  </span><span class="nottickedoff">, lotrVarsExtra = RL.append (RL.append vars1 lotrVarsExtra) vars2</span>
<span class="lineno"> 2717 </span><span class="spaces">  </span><span class="nottickedoff">, lotrTpTransIn = dtr_in' , lotrTpTransOut = dtr_out'</span>
<span class="lineno"> 2718 </span><span class="spaces">  </span><span class="nottickedoff">, lotrTpTransExtra =</span>
<span class="lineno"> 2719 </span><span class="spaces">      </span><span class="nottickedoff">App.liftA2 RL.append (App.liftA2 RL.append dtr1 lotrTpTransExtra) dtr2</span>
<span class="lineno"> 2720 </span><span class="spaces">  </span><span class="nottickedoff">, lotrTerm =</span>
<span class="lineno"> 2721 </span><span class="spaces">      </span><span class="nottickedoff">mapLtLOwnedTransTerm (RL.append pctx1 lotrPsExtra) pctx2 prx_in'</span>
<span class="lineno"> 2722 </span><span class="spaces">      </span><span class="nottickedoff">(mapLtLOwnedTransTerm pctx1 lotrPsExtra prx_in' t1 lotrTerm)</span>
<span class="lineno"> 2723 </span><span class="spaces">      </span><span class="nottickedoff">t2</span>
<span class="lineno"> 2724 </span><span class="spaces">  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 2725 </span>
<span class="lineno"> 2726 </span>
<span class="lineno"> 2727 </span>----------------------------------------------------------------------
<span class="lineno"> 2728 </span>-- * Translating Permissions to Types
<span class="lineno"> 2729 </span>----------------------------------------------------------------------
<span class="lineno"> 2730 </span>
<span class="lineno"> 2731 </span>-- | Make a type translation of a 'BVProp' from it and its pure type
<span class="lineno"> 2732 </span>mkBVPropTrans :: Mb ctx (BVProp w) -&gt; OpenTerm -&gt;
<span class="lineno"> 2733 </span>                 TypeTrans (BVPropTrans ctx w)
<span class="lineno"> 2734 </span><span class="decl"><span class="nottickedoff">mkBVPropTrans prop tp = mkTypeTrans1 tp $ BVPropTrans prop</span></span>
<span class="lineno"> 2735 </span>
<span class="lineno"> 2736 </span>instance (1 &lt;= w, KnownNat w, TransInfo info) =&gt;
<span class="lineno"> 2737 </span>         Translate info ctx (BVProp w) (TypeTrans (BVPropTrans ctx w)) where
<span class="lineno"> 2738 </span>  <span class="decl"><span class="nottickedoff">translate prop = case mbMatch prop of</span>
<span class="lineno"> 2739 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_Eq e1 e2 |] -&gt;</span>
<span class="lineno"> 2740 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 2741 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 2742 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 2743 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkBVPropTrans prop $</span>
<span class="lineno"> 2744 </span><span class="spaces">           </span><span class="nottickedoff">dataTypeOpenTerm &quot;Prelude.Eq&quot;</span>
<span class="lineno"> 2745 </span><span class="spaces">           </span><span class="nottickedoff">[applyOpenTermMulti (globalOpenTerm &quot;Prelude.Vec&quot;)</span>
<span class="lineno"> 2746 </span><span class="spaces">            </span><span class="nottickedoff">[natOpenTerm w, globalOpenTerm &quot;Prelude.Bool&quot;],</span>
<span class="lineno"> 2747 </span><span class="spaces">            </span><span class="nottickedoff">t1, t2]</span>
<span class="lineno"> 2748 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2749 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_Neq _ _ |] -&gt;</span>
<span class="lineno"> 2750 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: we don't need a proof object for not equal proofs, because we don't</span>
<span class="lineno"> 2751 </span><span class="spaces">      </span><span class="nottickedoff">-- actually use them for anything, but it is easier to just have all BVProps</span>
<span class="lineno"> 2752 </span><span class="spaces">      </span><span class="nottickedoff">-- be represented as something, so we use the unit type</span>
<span class="lineno"> 2753 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkBVPropTrans prop unitTypeOpenTerm</span>
<span class="lineno"> 2754 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2755 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_ULt e1 e2 |] -&gt;</span>
<span class="lineno"> 2756 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 2757 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 2758 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 2759 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkBVPropTrans prop $</span>
<span class="lineno"> 2760 </span><span class="spaces">           </span><span class="nottickedoff">dataTypeOpenTerm &quot;Prelude.Eq&quot;</span>
<span class="lineno"> 2761 </span><span class="spaces">           </span><span class="nottickedoff">[globalOpenTerm &quot;Prelude.Bool&quot;,</span>
<span class="lineno"> 2762 </span><span class="spaces">            </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvult&quot;)</span>
<span class="lineno"> 2763 </span><span class="spaces">            </span><span class="nottickedoff">[natOpenTerm w, t1, t2], trueOpenTerm]</span>
<span class="lineno"> 2764 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2765 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_ULeq e1 e2 |] -&gt;</span>
<span class="lineno"> 2766 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 2767 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 2768 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 2769 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkBVPropTrans prop $</span>
<span class="lineno"> 2770 </span><span class="spaces">           </span><span class="nottickedoff">dataTypeOpenTerm &quot;Prelude.Eq&quot;</span>
<span class="lineno"> 2771 </span><span class="spaces">           </span><span class="nottickedoff">[globalOpenTerm &quot;Prelude.Bool&quot;,</span>
<span class="lineno"> 2772 </span><span class="spaces">            </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvule&quot;)</span>
<span class="lineno"> 2773 </span><span class="spaces">            </span><span class="nottickedoff">[natOpenTerm w, t1, t2], trueOpenTerm]</span>
<span class="lineno"> 2774 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2775 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVProp_ULeq_Diff e1 e2 e3 |] -&gt;</span>
<span class="lineno"> 2776 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 2777 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 2778 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 2779 </span><span class="spaces">         </span><span class="nottickedoff">t3 &lt;- translate1 e3</span>
<span class="lineno"> 2780 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkBVPropTrans prop $</span>
<span class="lineno"> 2781 </span><span class="spaces">           </span><span class="nottickedoff">dataTypeOpenTerm &quot;Prelude.Eq&quot;</span>
<span class="lineno"> 2782 </span><span class="spaces">           </span><span class="nottickedoff">[globalOpenTerm &quot;Prelude.Bool&quot;,</span>
<span class="lineno"> 2783 </span><span class="spaces">            </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvule&quot;)</span>
<span class="lineno"> 2784 </span><span class="spaces">            </span><span class="nottickedoff">[natOpenTerm w, t1,</span>
<span class="lineno"> 2785 </span><span class="spaces">             </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.bvSub&quot;)</span>
<span class="lineno"> 2786 </span><span class="spaces">              </span><span class="nottickedoff">[natOpenTerm w, t2, t3]],</span>
<span class="lineno"> 2787 </span><span class="spaces">            </span><span class="nottickedoff">trueOpenTerm]</span></span>
<span class="lineno"> 2788 </span>
<span class="lineno"> 2789 </span>instance (1 &lt;= w, KnownNat w, TransInfo info) =&gt;
<span class="lineno"> 2790 </span>         Translate info ctx (BVRange w) (BVRangeTrans ctx w) where
<span class="lineno"> 2791 </span>  <span class="decl"><span class="nottickedoff">translate rng@(mbMatch -&gt; [nuMP| BVRange off len |]) =</span>
<span class="lineno"> 2792 </span><span class="spaces">    </span><span class="nottickedoff">do off_tm &lt;- translate off</span>
<span class="lineno"> 2793 </span><span class="spaces">       </span><span class="nottickedoff">len_tm &lt;- translate len</span>
<span class="lineno"> 2794 </span><span class="spaces">       </span><span class="nottickedoff">return $ BVRangeTrans rng off_tm len_tm</span></span>
<span class="lineno"> 2795 </span>
<span class="lineno"> 2796 </span>-- Translate a permission to a TypeTrans, that contains a list of 0 or more SAW
<span class="lineno"> 2797 </span>-- core types along with a mapping from SAW core terms of those types to a
<span class="lineno"> 2798 </span>-- PermTrans for the type of the permission
<span class="lineno"> 2799 </span>instance TransInfo info =&gt;
<span class="lineno"> 2800 </span>         Translate info ctx (ValuePerm a) (TypeTrans (PermTrans ctx a)) where
<span class="lineno"> 2801 </span>  <span class="decl"><span class="nottickedoff">translate p = case mbMatch p of</span>
<span class="lineno"> 2802 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Eq e |] -&gt; return $ mkTypeTrans0 $ PTrans_Eq e</span>
<span class="lineno"> 2803 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Or p1 p2 |] -&gt;</span>
<span class="lineno"> 2804 </span><span class="spaces">      </span><span class="nottickedoff">do tp1 &lt;- translate p1</span>
<span class="lineno"> 2805 </span><span class="spaces">         </span><span class="nottickedoff">tp2 &lt;- translate p2</span>
<span class="lineno"> 2806 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkPermTypeTrans1 p (eitherTypeTrans tp1 tp2)</span>
<span class="lineno"> 2807 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Exists p1 |] -&gt;</span>
<span class="lineno"> 2808 </span><span class="spaces">      </span><span class="nottickedoff">do let tp = mbBindingType p1</span>
<span class="lineno"> 2809 </span><span class="spaces">         </span><span class="nottickedoff">tp_trans &lt;- translateClosed tp</span>
<span class="lineno"> 2810 </span><span class="spaces">         </span><span class="nottickedoff">mkPermTypeTrans1 p &lt;$&gt;</span>
<span class="lineno"> 2811 </span><span class="spaces">           </span><span class="nottickedoff">sigmaTypePermTransM &quot;x_ex&quot; tp_trans (mbCombine RL.typeCtxProxies p1)</span>
<span class="lineno"> 2812 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Named npn args off |] -&gt;</span>
<span class="lineno"> 2813 </span><span class="spaces">      </span><span class="nottickedoff">do env &lt;- infoEnv &lt;$&gt; ask</span>
<span class="lineno"> 2814 </span><span class="spaces">         </span><span class="nottickedoff">case lookupNamedPerm env (mbLift npn) of</span>
<span class="lineno"> 2815 </span><span class="spaces">           </span><span class="nottickedoff">Just (NamedPerm_Opaque op) -&gt;</span>
<span class="lineno"> 2816 </span><span class="spaces">             </span><span class="nottickedoff">mkPermTypeTrans1 p &lt;$&gt;</span>
<span class="lineno"> 2817 </span><span class="spaces">             </span><span class="nottickedoff">applyGlobalOpenTerm (opaquePermTrans op) &lt;$&gt;</span>
<span class="lineno"> 2818 </span><span class="spaces">             </span><span class="nottickedoff">transTerms &lt;$&gt; translate args</span>
<span class="lineno"> 2819 </span><span class="spaces">           </span><span class="nottickedoff">Just (NamedPerm_Rec rp) -&gt;</span>
<span class="lineno"> 2820 </span><span class="spaces">             </span><span class="nottickedoff">mkPermTypeTrans1 p &lt;$&gt;</span>
<span class="lineno"> 2821 </span><span class="spaces">             </span><span class="nottickedoff">applyGlobalOpenTerm (recPermTransType rp) &lt;$&gt;</span>
<span class="lineno"> 2822 </span><span class="spaces">             </span><span class="nottickedoff">transTerms &lt;$&gt; translate args</span>
<span class="lineno"> 2823 </span><span class="spaces">           </span><span class="nottickedoff">Just (NamedPerm_Defined dp) -&gt;</span>
<span class="lineno"> 2824 </span><span class="spaces">             </span><span class="nottickedoff">fmap (PTrans_Defined (mbLift npn) args off) &lt;$&gt;</span>
<span class="lineno"> 2825 </span><span class="spaces">             </span><span class="nottickedoff">translate (mbMap2 (unfoldDefinedPerm dp) args off)</span>
<span class="lineno"> 2826 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; panic &quot;translate&quot; [&quot;Unknown permission name!&quot;]</span>
<span class="lineno"> 2827 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Conj ps |] -&gt;</span>
<span class="lineno"> 2828 </span><span class="spaces">      </span><span class="nottickedoff">fmap PTrans_Conj &lt;$&gt; listTypeTrans &lt;$&gt; translate ps</span>
<span class="lineno"> 2829 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Var x _ |] -&gt;</span>
<span class="lineno"> 2830 </span><span class="spaces">      </span><span class="nottickedoff">do (_, tps) &lt;- unETransPerm &lt;$&gt; translate x</span>
<span class="lineno"> 2831 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkPermTypeTrans1 p (tupleTypeOpenTerm' tps)</span>
<span class="lineno"> 2832 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_False |] -&gt;</span>
<span class="lineno"> 2833 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkPermTypeTrans1 p $ globalOpenTerm &quot;Prelude.FalseProp&quot;</span></span>
<span class="lineno"> 2834 </span>
<span class="lineno"> 2835 </span>-- Translate a permission to type descriptions for the types returned by the
<span class="lineno"> 2836 </span>-- Translate instance above
<span class="lineno"> 2837 </span>instance TranslateDescs (ValuePerm a) where
<span class="lineno"> 2838 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 2839 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Eq _ |] -&gt; return []</span>
<span class="lineno"> 2840 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Or p1 p2 |] -&gt;</span>
<span class="lineno"> 2841 </span><span class="spaces">      </span><span class="nottickedoff">(:[]) &lt;$&gt; (sumTpDesc &lt;$&gt; translateDesc p1 &lt;*&gt; translateDesc p2)</span>
<span class="lineno"> 2842 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Exists mb_mb_p' |]</span>
<span class="lineno"> 2843 </span><span class="spaces">      </span><span class="nottickedoff">| [nuP| ValPerm_Eq _ |] &lt;- mbCombine RL.typeCtxProxies mb_mb_p' -&gt;</span>
<span class="lineno"> 2844 </span><span class="spaces">        </span><span class="nottickedoff">do ev &lt;- dtiEvType &lt;$&gt; ask</span>
<span class="lineno"> 2845 </span><span class="spaces">           </span><span class="nottickedoff">let tp_repr = mbLift $ fmap bindingType mb_mb_p'</span>
<span class="lineno"> 2846 </span><span class="spaces">               </span><span class="nottickedoff">(_, k_ds) = let ?ev = ev in translateType tp_repr</span>
<span class="lineno"> 2847 </span><span class="spaces">           </span><span class="nottickedoff">return [tupleTpDesc $ map kindToTpDesc k_ds]</span>
<span class="lineno"> 2848 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Exists mb_mb_p' |] -&gt;</span>
<span class="lineno"> 2849 </span><span class="spaces">      </span><span class="nottickedoff">do let tp_repr = mbLift $ fmap bindingType mb_mb_p'</span>
<span class="lineno"> 2850 </span><span class="spaces">         </span><span class="nottickedoff">let mb_p' = mbCombine RL.typeCtxProxies mb_mb_p'</span>
<span class="lineno"> 2851 </span><span class="spaces">         </span><span class="nottickedoff">inExtCtxDescTransM (singletonCruCtx tp_repr) $ \kdescs -&gt;</span>
<span class="lineno"> 2852 </span><span class="spaces">           </span><span class="nottickedoff">(:[]) &lt;$&gt; sigmaTpDescMulti kdescs &lt;$&gt; translateDesc mb_p'</span>
<span class="lineno"> 2853 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Named mb_npn args off |] -&gt;</span>
<span class="lineno"> 2854 </span><span class="spaces">      </span><span class="nottickedoff">do let npn = mbLift mb_npn</span>
<span class="lineno"> 2855 </span><span class="spaces">         </span><span class="nottickedoff">env &lt;- dtiEnv &lt;$&gt; ask</span>
<span class="lineno"> 2856 </span><span class="spaces">         </span><span class="nottickedoff">args_ds &lt;- translateDescs args</span>
<span class="lineno"> 2857 </span><span class="spaces">         </span><span class="nottickedoff">let (_, k_ds) =</span>
<span class="lineno"> 2858 </span><span class="spaces">               </span><span class="nottickedoff">let ?ev = permEnvEventType env in</span>
<span class="lineno"> 2859 </span><span class="spaces">               </span><span class="nottickedoff">translateCruCtx (namedPermNameArgs npn)</span>
<span class="lineno"> 2860 </span><span class="spaces">         </span><span class="nottickedoff">case lookupNamedPerm env npn of</span>
<span class="lineno"> 2861 </span><span class="spaces">           </span><span class="nottickedoff">Just (NamedPerm_Opaque op) -&gt;</span>
<span class="lineno"> 2862 </span><span class="spaces">             </span><span class="nottickedoff">return [substIdTpDescMulti (opaquePermTransDesc op) k_ds args_ds]</span>
<span class="lineno"> 2863 </span><span class="spaces">           </span><span class="nottickedoff">Just (NamedPerm_Rec rp) -&gt;</span>
<span class="lineno"> 2864 </span><span class="spaces">             </span><span class="nottickedoff">return [substIndIdTpDescMulti (recPermTransDesc rp) k_ds args_ds]</span>
<span class="lineno"> 2865 </span><span class="spaces">           </span><span class="nottickedoff">Just (NamedPerm_Defined dp) -&gt;</span>
<span class="lineno"> 2866 </span><span class="spaces">             </span><span class="nottickedoff">translateDescs (mbMap2 (unfoldDefinedPerm dp) args off)</span>
<span class="lineno"> 2867 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; panic &quot;translate&quot; [&quot;Unknown permission name!&quot;]</span>
<span class="lineno"> 2868 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Conj ps |] -&gt; translateDescs ps</span>
<span class="lineno"> 2869 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_Var mb_x _ |] -&gt; translateDescs mb_x</span>
<span class="lineno"> 2870 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerm_False |] -&gt; return [voidTpDesc]</span></span>
<span class="lineno"> 2871 </span>
<span class="lineno"> 2872 </span>
<span class="lineno"> 2873 </span>instance TransInfo info =&gt;
<span class="lineno"> 2874 </span>         Translate info ctx (AtomicPerm a) (TypeTrans
<span class="lineno"> 2875 </span>                                            (AtomicPermTrans ctx a)) where
<span class="lineno"> 2876 </span>  <span class="decl"><span class="nottickedoff">translate mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 2877 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMField fld |] -&gt;</span>
<span class="lineno"> 2878 </span><span class="spaces">      </span><span class="nottickedoff">fmap (APTrans_LLVMField fld) &lt;$&gt; translate (fmap llvmFieldContents fld)</span>
<span class="lineno"> 2879 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2880 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMArray ap |] -&gt;</span>
<span class="lineno"> 2881 </span><span class="spaces">      </span><span class="nottickedoff">fmap APTrans_LLVMArray &lt;$&gt; translate ap</span>
<span class="lineno"> 2882 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2883 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMBlock bp |] -&gt;</span>
<span class="lineno"> 2884 </span><span class="spaces">      </span><span class="nottickedoff">do shtrans &lt;- unETransShape &lt;$&gt; translate (fmap llvmBlockShape bp)</span>
<span class="lineno"> 2885 </span><span class="spaces">         </span><span class="nottickedoff">return $ case shtrans of</span>
<span class="lineno"> 2886 </span><span class="spaces">           </span><span class="nottickedoff">Just (_, tp) -&gt; mkTypeTrans1 tp (APTrans_LLVMBlock bp . Just)</span>
<span class="lineno"> 2887 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; mkTypeTrans0 (APTrans_LLVMBlock bp Nothing)</span>
<span class="lineno"> 2888 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFree e |] -&gt;</span>
<span class="lineno"> 2889 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkTypeTrans0 $ APTrans_LLVMFree e</span>
<span class="lineno"> 2890 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFunPtr tp p |] -&gt;</span>
<span class="lineno"> 2891 </span><span class="spaces">      </span><span class="nottickedoff">translate p &gt;&gt;= \tp_ptrans -&gt;</span>
<span class="lineno"> 2892 </span><span class="spaces">      </span><span class="nottickedoff">return $ fmap (APTrans_LLVMFunPtr $ mbLift tp) tp_ptrans</span>
<span class="lineno"> 2893 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |] -&gt;</span>
<span class="lineno"> 2894 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkTypeTrans0 APTrans_IsLLVMPtr</span>
<span class="lineno"> 2895 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMBlockShape sh |] -&gt;</span>
<span class="lineno"> 2896 </span><span class="spaces">      </span><span class="nottickedoff">do shtrans &lt;- unETransShape &lt;$&gt; translate sh</span>
<span class="lineno"> 2897 </span><span class="spaces">         </span><span class="nottickedoff">return $ case shtrans of</span>
<span class="lineno"> 2898 </span><span class="spaces">           </span><span class="nottickedoff">Just (_, tp) -&gt; mkTypeTrans1 tp (APTrans_LLVMBlockShape sh . Just)</span>
<span class="lineno"> 2899 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; mkTypeTrans0 (APTrans_LLVMBlockShape sh Nothing)</span>
<span class="lineno"> 2900 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_NamedConj npn args off |]</span>
<span class="lineno"> 2901 </span><span class="spaces">      </span><span class="nottickedoff">| [nuMP| DefinedSortRepr _ |] &lt;- mbMatch $ fmap namedPermNameSort npn -&gt;</span>
<span class="lineno"> 2902 </span><span class="spaces">        </span><span class="nottickedoff">-- To translate P&lt;args&gt;@off as an atomic permission, we translate it as a</span>
<span class="lineno"> 2903 </span><span class="spaces">        </span><span class="nottickedoff">-- normal permission and map the resulting PermTrans to an AtomicPermTrans</span>
<span class="lineno"> 2904 </span><span class="spaces">        </span><span class="nottickedoff">do tptrans &lt;- translate $ mbMap2 (ValPerm_Named $ mbLift npn) args off</span>
<span class="lineno"> 2905 </span><span class="spaces">           </span><span class="nottickedoff">return $ fmap (APTrans_DefinedNamedConj (mbLift npn) args off) tptrans</span>
<span class="lineno"> 2906 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_NamedConj npn args off |] -&gt;</span>
<span class="lineno"> 2907 </span><span class="spaces">      </span><span class="nottickedoff">-- To translate P&lt;args&gt;@off as an atomic permission, we translate it as a</span>
<span class="lineno"> 2908 </span><span class="spaces">      </span><span class="nottickedoff">-- normal permission and map the resulting PermTrans to an AtomicPermTrans</span>
<span class="lineno"> 2909 </span><span class="spaces">      </span><span class="nottickedoff">do ptrans &lt;- translate $ mbMap2 (ValPerm_Named $ mbLift npn) args off</span>
<span class="lineno"> 2910 </span><span class="spaces">         </span><span class="nottickedoff">return $ fmap (\case</span>
<span class="lineno"> 2911 </span><span class="spaces">                           </span><span class="nottickedoff">(PTrans_Term _ t) -&gt;</span>
<span class="lineno"> 2912 </span><span class="spaces">                             </span><span class="nottickedoff">APTrans_NamedConj (mbLift npn) args off t</span>
<span class="lineno"> 2913 </span><span class="spaces">                           </span><span class="nottickedoff">_ -&gt; error &quot;translateSimplImpl: Perm_NamedConj&quot;) ptrans</span>
<span class="lineno"> 2914 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFrame fp |] -&gt;</span>
<span class="lineno"> 2915 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkTypeTrans0 $ APTrans_LLVMFrame fp</span>
<span class="lineno"> 2916 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LOwned ls tps_in tps_out ps_in ps_out |] -&gt;</span>
<span class="lineno"> 2917 </span><span class="spaces">      </span><span class="nottickedoff">case mbExprPermsMembers ps_out of</span>
<span class="lineno"> 2918 </span><span class="spaces">        </span><span class="nottickedoff">Just vars_out -&gt;</span>
<span class="lineno"> 2919 </span><span class="spaces">          </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 2920 </span><span class="spaces">             </span><span class="nottickedoff">ectx &lt;- infoCtx &lt;$&gt; ask</span>
<span class="lineno"> 2921 </span><span class="spaces">             </span><span class="nottickedoff">dtr_in &lt;- translateDescType ps_in</span>
<span class="lineno"> 2922 </span><span class="spaces">             </span><span class="nottickedoff">dtr_out &lt;- translateDescType ps_out</span>
<span class="lineno"> 2923 </span><span class="spaces">             </span><span class="nottickedoff">tp &lt;- piTransM &quot;p&quot; (descTypeTrans dtr_in)</span>
<span class="lineno"> 2924 </span><span class="spaces">               </span><span class="nottickedoff">(const $ return $ specMTypeOpenTerm ev $</span>
<span class="lineno"> 2925 </span><span class="spaces">                </span><span class="nottickedoff">typeTransTupleType $ descTypeTrans dtr_out)</span>
<span class="lineno"> 2926 </span><span class="spaces">             </span><span class="nottickedoff">return $ mkTypeTrans1 tp $ \t -&gt;</span>
<span class="lineno"> 2927 </span><span class="spaces">               </span><span class="nottickedoff">(APTrans_LOwned ls (mbLift tps_in) (mbLift tps_out) ps_in ps_out $</span>
<span class="lineno"> 2928 </span><span class="spaces">                </span><span class="nottickedoff">mkLOwnedTrans ev ectx dtr_in dtr_out vars_out t)</span>
<span class="lineno"> 2929 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2930 </span><span class="spaces">          </span><span class="nottickedoff">panic &quot;translate&quot; [&quot;lowned output permission is ill-formed&quot;]</span>
<span class="lineno"> 2931 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LOwnedSimple tps lops |] -&gt;</span>
<span class="lineno"> 2932 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkTypeTrans0 $ APTrans_LOwnedSimple (mbLift tps) lops</span>
<span class="lineno"> 2933 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LCurrent l |] -&gt;</span>
<span class="lineno"> 2934 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkTypeTrans0 $ APTrans_LCurrent l</span>
<span class="lineno"> 2935 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LFinished |] -&gt;</span>
<span class="lineno"> 2936 </span><span class="spaces">      </span><span class="nottickedoff">return $ mkTypeTrans0 APTrans_LFinished</span>
<span class="lineno"> 2937 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Struct ps |] -&gt;</span>
<span class="lineno"> 2938 </span><span class="spaces">      </span><span class="nottickedoff">fmap APTrans_Struct &lt;$&gt; translate ps</span>
<span class="lineno"> 2939 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Fun fun_perm |] -&gt;</span>
<span class="lineno"> 2940 </span><span class="spaces">      </span><span class="nottickedoff">do tp &lt;- translate fun_perm</span>
<span class="lineno"> 2941 </span><span class="spaces">         </span><span class="nottickedoff">d &lt;- descTransM $ translateDesc1 fun_perm</span>
<span class="lineno"> 2942 </span><span class="spaces">         </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 2943 </span><span class="spaces">         </span><span class="nottickedoff">return $ mkTypeTrans1 tp (APTrans_Fun fun_perm . FunTrans ev d)</span>
<span class="lineno"> 2944 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_BVProp prop |] -&gt;</span>
<span class="lineno"> 2945 </span><span class="spaces">      </span><span class="nottickedoff">fmap APTrans_BVProp &lt;$&gt; translate prop</span>
<span class="lineno"> 2946 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Any |] -&gt; return $ mkTypeTrans0 APTrans_Any</span></span>
<span class="lineno"> 2947 </span>
<span class="lineno"> 2948 </span>
<span class="lineno"> 2949 </span>instance TranslateDescs (AtomicPerm a) where
<span class="lineno"> 2950 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 2951 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMField fld |] -&gt; translateDescs (fmap llvmFieldContents fld)</span>
<span class="lineno"> 2952 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMArray ap |] -&gt; translateDescs ap</span>
<span class="lineno"> 2953 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMBlock bp |] -&gt; translateDescs (fmap llvmBlockShape bp)</span>
<span class="lineno"> 2954 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFree _ |] -&gt; return []</span>
<span class="lineno"> 2955 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFunPtr _ p |] -&gt; translateDescs p</span>
<span class="lineno"> 2956 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |] -&gt; return []</span>
<span class="lineno"> 2957 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMBlockShape sh |] -&gt; translateDescs sh</span>
<span class="lineno"> 2958 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_NamedConj npn args off |] -&gt;</span>
<span class="lineno"> 2959 </span><span class="spaces">      </span><span class="nottickedoff">translateDescs $ mbMap2 (ValPerm_Named $ mbLift npn) args off</span>
<span class="lineno"> 2960 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LLVMFrame _ |] -&gt; return []</span>
<span class="lineno"> 2961 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LOwned _ _ _ ps_in ps_out |] -&gt;</span>
<span class="lineno"> 2962 </span><span class="spaces">      </span><span class="nottickedoff">do ds_in &lt;- translateDescs ps_in</span>
<span class="lineno"> 2963 </span><span class="spaces">         </span><span class="nottickedoff">d_out &lt;- translateDesc ps_out</span>
<span class="lineno"> 2964 </span><span class="spaces">         </span><span class="nottickedoff">return [funTpDesc ds_in d_out]</span>
<span class="lineno"> 2965 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LOwnedSimple _ _ |] -&gt; return []</span>
<span class="lineno"> 2966 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LCurrent _ |] -&gt; return []</span>
<span class="lineno"> 2967 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_LFinished |] -&gt; return []</span>
<span class="lineno"> 2968 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Struct ps |] -&gt; translateDescs ps</span>
<span class="lineno"> 2969 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Fun fun_perm |] -&gt; translateDescs fun_perm</span>
<span class="lineno"> 2970 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_BVProp _ |] -&gt;</span>
<span class="lineno"> 2971 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: Translating BVProps to type descriptions would require a lot more</span>
<span class="lineno"> 2972 </span><span class="spaces">      </span><span class="nottickedoff">-- type-level expressions, including a type-level kind for equality types,</span>
<span class="lineno"> 2973 </span><span class="spaces">      </span><span class="nottickedoff">-- that would greatly complicate the definition of type descriptions.</span>
<span class="lineno"> 2974 </span><span class="spaces">      </span><span class="nottickedoff">-- Instead, we choose not to translate them, meaning they cannot be used</span>
<span class="lineno"> 2975 </span><span class="spaces">      </span><span class="nottickedoff">-- in places where type descriptions are required, such as the types of</span>
<span class="lineno"> 2976 </span><span class="spaces">      </span><span class="nottickedoff">-- functions or lowned permissions.</span>
<span class="lineno"> 2977 </span><span class="spaces">      </span><span class="nottickedoff">panic &quot;translateDescs&quot;</span>
<span class="lineno"> 2978 </span><span class="spaces">      </span><span class="nottickedoff">[&quot;Cannot translate BV propositions to type descriptions&quot;]</span>
<span class="lineno"> 2979 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Perm_Any |] -&gt; return []</span></span>
<span class="lineno"> 2980 </span>
<span class="lineno"> 2981 </span>
<span class="lineno"> 2982 </span>-- | Translate an array permission to a 'TypeTrans' for an array permission
<span class="lineno"> 2983 </span>-- translation, also returning the translations of the bitvector width as a
<span class="lineno"> 2984 </span>-- natural, the length of the array as a bitvector, and the type of the elements
<span class="lineno"> 2985 </span>-- of the translation of the array
<span class="lineno"> 2986 </span>translateLLVMArrayPerm :: (1 &lt;= w, KnownNat w, TransInfo info) =&gt;
<span class="lineno"> 2987 </span>                          Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 2988 </span>                          TransM info ctx (OpenTerm,OpenTerm,OpenTerm,
<span class="lineno"> 2989 </span>                                           TypeTrans (LLVMArrayPermTrans ctx w))
<span class="lineno"> 2990 </span><span class="decl"><span class="nottickedoff">translateLLVMArrayPerm mb_ap =</span>
<span class="lineno"> 2991 </span><span class="spaces">  </span><span class="nottickedoff">do let w = natVal2 mb_ap</span>
<span class="lineno"> 2992 </span><span class="spaces">     </span><span class="nottickedoff">let w_term = natOpenTerm w</span>
<span class="lineno"> 2993 </span><span class="spaces">     </span><span class="nottickedoff">-- To translate mb_ap to an element type, we form the block permission for</span>
<span class="lineno"> 2994 </span><span class="spaces">     </span><span class="nottickedoff">-- the first cell of the array and translate that to a TypeTrans</span>
<span class="lineno"> 2995 </span><span class="spaces">     </span><span class="nottickedoff">elem_tp_trans &lt;- translate $ mbMapCl $(mkClosed [| Perm_LLVMBlock .</span>
<span class="lineno"> 2996 </span><span class="spaces">                                                      </span><span class="nottickedoff">llvmArrayPermHead |]) mb_ap</span>
<span class="lineno"> 2997 </span><span class="spaces">     </span><span class="nottickedoff">let elem_tp = typeTransTupleType elem_tp_trans</span>
<span class="lineno"> 2998 </span><span class="spaces">     </span><span class="nottickedoff">len_term &lt;- translate1 $ mbLLVMArrayLen mb_ap</span>
<span class="lineno"> 2999 </span><span class="spaces">     </span><span class="nottickedoff">{-</span>
<span class="lineno"> 3000 </span><span class="spaces">     </span><span class="nottickedoff">bs_trans &lt;-</span>
<span class="lineno"> 3001 </span><span class="spaces">       </span><span class="nottickedoff">listTypeTrans &lt;$&gt; mapM (translateLLVMArrayBorrow ap) (mbList bs) -}</span>
<span class="lineno"> 3002 </span><span class="spaces">     </span><span class="nottickedoff">let arr_tp = bvVecTypeOpenTerm w_term len_term elem_tp</span>
<span class="lineno"> 3003 </span><span class="spaces">     </span><span class="nottickedoff">return (w_term, len_term, elem_tp,</span>
<span class="lineno"> 3004 </span><span class="spaces">             </span><span class="nottickedoff">mkTypeTrans1 arr_tp</span>
<span class="lineno"> 3005 </span><span class="spaces">             </span><span class="nottickedoff">({- flip $ -} LLVMArrayPermTrans mb_ap len_term elem_tp_trans</span>
<span class="lineno"> 3006 </span><span class="spaces">                           </span><span class="nottickedoff">{- &lt;*&gt; bs_trans -}))</span></span>
<span class="lineno"> 3007 </span>
<span class="lineno"> 3008 </span>instance (1 &lt;= w, KnownNat w, TransInfo info) =&gt;
<span class="lineno"> 3009 </span>         Translate info ctx (LLVMArrayPerm w) (TypeTrans
<span class="lineno"> 3010 </span>                                               (LLVMArrayPermTrans ctx w)) where
<span class="lineno"> 3011 </span>  <span class="decl"><span class="nottickedoff">translate mb_ap =</span>
<span class="lineno"> 3012 </span><span class="spaces">    </span><span class="nottickedoff">(\(_,_,_,tp_trans) -&gt; tp_trans) &lt;$&gt; translateLLVMArrayPerm mb_ap</span></span>
<span class="lineno"> 3013 </span>
<span class="lineno"> 3014 </span>instance (1 &lt;= w, KnownNat w) =&gt; TranslateDescs (LLVMArrayPerm w) where
<span class="lineno"> 3015 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_ap =</span>
<span class="lineno"> 3016 </span><span class="spaces">    </span><span class="nottickedoff">do let w = natVal2 mb_ap</span>
<span class="lineno"> 3017 </span><span class="spaces">       </span><span class="nottickedoff">let w_term = natOpenTerm w</span>
<span class="lineno"> 3018 </span><span class="spaces">       </span><span class="nottickedoff">len_term &lt;- translateDesc1 $ mbLLVMArrayLen mb_ap</span>
<span class="lineno"> 3019 </span><span class="spaces">       </span><span class="nottickedoff">-- To translate mb_ap to a type description, we form the block permission</span>
<span class="lineno"> 3020 </span><span class="spaces">       </span><span class="nottickedoff">-- for the first cell of the array and translate that to a type desc</span>
<span class="lineno"> 3021 </span><span class="spaces">       </span><span class="nottickedoff">elem_d &lt;-</span>
<span class="lineno"> 3022 </span><span class="spaces">         </span><span class="nottickedoff">translateDesc $ mbMapCl $(mkClosed [| Perm_LLVMBlock .</span>
<span class="lineno"> 3023 </span><span class="spaces">                                             </span><span class="nottickedoff">llvmArrayPermHead |]) mb_ap</span>
<span class="lineno"> 3024 </span><span class="spaces">       </span><span class="nottickedoff">return [bvVecTpDesc w_term len_term elem_d]</span></span>
<span class="lineno"> 3025 </span>
<span class="lineno"> 3026 </span>{-
<span class="lineno"> 3027 </span>-- | Translate an 'LLVMArrayBorrow' into an 'LLVMArrayBorrowTrans'. This
<span class="lineno"> 3028 </span>-- requires a special-purpose function, instead of the 'Translate' class,
<span class="lineno"> 3029 </span>-- because it requires the array permission.
<span class="lineno"> 3030 </span>translateLLVMArrayBorrow :: (1 &lt;= w, KnownNat w, TransInfo info) =&gt;
<span class="lineno"> 3031 </span>                            Mb ctx (LLVMArrayPerm w) -&gt;
<span class="lineno"> 3032 </span>                            Mb ctx (LLVMArrayBorrow w) -&gt;
<span class="lineno"> 3033 </span>                            TransM info ctx (TypeTrans
<span class="lineno"> 3034 </span>                                             (LLVMArrayBorrowTrans ctx w))
<span class="lineno"> 3035 </span>translateLLVMArrayBorrow mb_ap mb_b =
<span class="lineno"> 3036 </span>  do let mb_props = mbMap2 llvmArrayBorrowInArrayBase mb_ap mb_b
<span class="lineno"> 3037 </span>     prop_trans &lt;- mapM translate $ mbList mb_props
<span class="lineno"> 3038 </span>     return (LLVMArrayBorrowTrans mb_b &lt;$&gt; listTypeTrans prop_trans)
<span class="lineno"> 3039 </span>-}
<span class="lineno"> 3040 </span>
<span class="lineno"> 3041 </span>instance TransInfo info =&gt;
<span class="lineno"> 3042 </span>         Translate info ctx (ValuePerms ps) (TypeTrans
<span class="lineno"> 3043 </span>                                             (PermTransCtx ctx ps)) where
<span class="lineno"> 3044 </span>  <span class="decl"><span class="nottickedoff">translate mb_ps = case mbMatch mb_ps of</span>
<span class="lineno"> 3045 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerms_Nil |] -&gt; return $ mkTypeTrans0 MNil</span>
<span class="lineno"> 3046 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerms_Cons ps p |] -&gt;</span>
<span class="lineno"> 3047 </span><span class="spaces">      </span><span class="nottickedoff">App.liftA2 (:&gt;:) &lt;$&gt; translate ps &lt;*&gt; translate p</span></span>
<span class="lineno"> 3048 </span>
<span class="lineno"> 3049 </span>instance TranslateDescs (ValuePerms ps) where
<span class="lineno"> 3050 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_ps = case mbMatch mb_ps of</span>
<span class="lineno"> 3051 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerms_Nil |] -&gt; return []</span>
<span class="lineno"> 3052 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ValPerms_Cons ps p |] -&gt;</span>
<span class="lineno"> 3053 </span><span class="spaces">      </span><span class="nottickedoff">(++) &lt;$&gt; translateDescs ps &lt;*&gt; translateDescs p</span></span>
<span class="lineno"> 3054 </span>
<span class="lineno"> 3055 </span>
<span class="lineno"> 3056 </span>-- Translate a DistPerms by translating its corresponding ValuePerms
<span class="lineno"> 3057 </span>instance TransInfo info =&gt;
<span class="lineno"> 3058 </span>         Translate info ctx (DistPerms ps) (TypeTrans
<span class="lineno"> 3059 </span>                                            (PermTransCtx ctx ps)) where
<span class="lineno"> 3060 </span>  <span class="decl"><span class="nottickedoff">translate = translate . mbDistPermsToValuePerms</span></span>
<span class="lineno"> 3061 </span>
<span class="lineno"> 3062 </span>instance TranslateDescs (DistPerms ps) where
<span class="lineno"> 3063 </span>  <span class="decl"><span class="nottickedoff">translateDescs = translateDescs . mbDistPermsToValuePerms</span></span>
<span class="lineno"> 3064 </span>
<span class="lineno"> 3065 </span>
<span class="lineno"> 3066 </span>instance TransInfo info =&gt;
<span class="lineno"> 3067 </span>         Translate info ctx (TypedDistPerms ps) (TypeTrans
<span class="lineno"> 3068 </span>                                                 (PermTransCtx ctx ps)) where
<span class="lineno"> 3069 </span>  <span class="decl"><span class="nottickedoff">translate = translate . mbDistPermsToValuePerms . fmap unTypeDistPerms</span></span>
<span class="lineno"> 3070 </span>
<span class="lineno"> 3071 </span>instance TransInfo info =&gt;
<span class="lineno"> 3072 </span>         Translate info ctx (ExprPerms ps) (TypeTrans
<span class="lineno"> 3073 </span>                                            (PermTransCtx ctx ps)) where
<span class="lineno"> 3074 </span>  <span class="decl"><span class="nottickedoff">translate mb_eps</span>
<span class="lineno"> 3075 </span><span class="spaces">    </span><span class="nottickedoff">| Just mb_ps &lt;- mbExprPermsToValuePerms mb_eps = translate mb_ps</span>
<span class="lineno"> 3076 </span><span class="spaces">  </span><span class="nottickedoff">translate mb_ps =</span>
<span class="lineno"> 3077 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;Translating expression permissions that could not be converted &quot; ++</span>
<span class="lineno"> 3078 </span><span class="spaces">           </span><span class="nottickedoff">&quot;to variable permissions:&quot; ++ permPrettyString emptyPPInfo mb_ps)</span></span>
<span class="lineno"> 3079 </span>
<span class="lineno"> 3080 </span>instance TranslateDescs (ExprPerms ps) where
<span class="lineno"> 3081 </span>  <span class="decl"><span class="nottickedoff">translateDescs mb_eps</span>
<span class="lineno"> 3082 </span><span class="spaces">    </span><span class="nottickedoff">| Just mb_ps &lt;- mbExprPermsToValuePerms mb_eps = translateDescs mb_ps</span>
<span class="lineno"> 3083 </span><span class="spaces">  </span><span class="nottickedoff">translateDescs mb_ps =</span>
<span class="lineno"> 3084 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;Translating expression permissions that could not be converted &quot; ++</span>
<span class="lineno"> 3085 </span><span class="spaces">           </span><span class="nottickedoff">&quot;to variable permissions:&quot; ++ permPrettyString emptyPPInfo mb_ps)</span></span>
<span class="lineno"> 3086 </span>
<span class="lineno"> 3087 </span>
<span class="lineno"> 3088 </span>-- Translate a FunPerm to a type that pi-abstracts over all the real and ghost
<span class="lineno"> 3089 </span>-- arguments, takes in all the input permissions individually, and returns a
<span class="lineno"> 3090 </span>-- sigma that quantifiers over the return values and tuples all the output
<span class="lineno"> 3091 </span>-- permissions together
<span class="lineno"> 3092 </span>instance TransInfo info =&gt;
<span class="lineno"> 3093 </span>         Translate info ctx (FunPerm ghosts args gouts ret) OpenTerm where
<span class="lineno"> 3094 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt;</span>
<span class="lineno"> 3095 </span><span class="spaces">             </span><span class="nottickedoff">[nuMP| FunPerm ghosts args gouts ret perms_in perms_out |]) =</span>
<span class="lineno"> 3096 </span><span class="spaces">    </span><span class="nottickedoff">let tops = appendCruCtx (mbLift ghosts) (mbLift args)</span>
<span class="lineno"> 3097 </span><span class="spaces">        </span><span class="nottickedoff">tops_prxs = cruCtxProxies tops</span>
<span class="lineno"> 3098 </span><span class="spaces">        </span><span class="nottickedoff">rets = CruCtxCons (mbLift gouts) (mbLift ret)</span>
<span class="lineno"> 3099 </span><span class="spaces">        </span><span class="nottickedoff">rets_prxs = cruCtxProxies rets in</span>
<span class="lineno"> 3100 </span><span class="spaces">    </span><span class="nottickedoff">(RL.map (const Proxy) &lt;$&gt; infoCtx &lt;$&gt; ask) &gt;&gt;= \ctx -&gt;</span>
<span class="lineno"> 3101 </span><span class="spaces">    </span><span class="nottickedoff">(infoEvType &lt;$&gt; ask) &gt;&gt;= \ev -&gt;</span>
<span class="lineno"> 3102 </span><span class="spaces">    </span><span class="nottickedoff">case RL.appendAssoc ctx tops_prxs rets_prxs of</span>
<span class="lineno"> 3103 </span><span class="spaces">      </span><span class="nottickedoff">Refl -&gt;</span>
<span class="lineno"> 3104 </span><span class="spaces">        </span><span class="nottickedoff">piExprCtxApp tops $</span>
<span class="lineno"> 3105 </span><span class="spaces">        </span><span class="nottickedoff">do tptrans_in &lt;- translate (mbCombine tops_prxs perms_in)</span>
<span class="lineno"> 3106 </span><span class="spaces">           </span><span class="nottickedoff">piTransM &quot;p&quot; tptrans_in $ \_ -&gt;</span>
<span class="lineno"> 3107 </span><span class="spaces">             </span><span class="nottickedoff">specMTypeOpenTerm ev &lt;$&gt;</span>
<span class="lineno"> 3108 </span><span class="spaces">             </span><span class="nottickedoff">translateRetType rets (mbCombine</span>
<span class="lineno"> 3109 </span><span class="spaces">                                    </span><span class="nottickedoff">(RL.append tops_prxs rets_prxs) perms_out)</span></span>
<span class="lineno"> 3110 </span>
<span class="lineno"> 3111 </span>-- Translate a FunPerm to a type description of the type that it translates to;
<span class="lineno"> 3112 </span>-- see the comments on the Translate instance above for a description of this
<span class="lineno"> 3113 </span>-- type
<span class="lineno"> 3114 </span>instance TranslateDescs (FunPerm ghosts args gouts ret) where
<span class="lineno"> 3115 </span>  <span class="decl"><span class="nottickedoff">translateDescs (mbMatch -&gt;</span>
<span class="lineno"> 3116 </span><span class="spaces">                  </span><span class="nottickedoff">[nuMP| FunPerm ghosts args gouts ret perms_in perms_out |]) =</span>
<span class="lineno"> 3117 </span><span class="spaces">    </span><span class="nottickedoff">let tops = appendCruCtx (mbLift ghosts) (mbLift args)</span>
<span class="lineno"> 3118 </span><span class="spaces">        </span><span class="nottickedoff">tops_prxs = cruCtxProxies tops</span>
<span class="lineno"> 3119 </span><span class="spaces">        </span><span class="nottickedoff">rets = CruCtxCons (mbLift gouts) (mbLift ret)</span>
<span class="lineno"> 3120 </span><span class="spaces">        </span><span class="nottickedoff">rets_prxs = cruCtxProxies rets in</span>
<span class="lineno"> 3121 </span><span class="spaces">    </span><span class="nottickedoff">(dtiProxies &lt;$&gt; ask) &gt;&gt;= \ctx -&gt;</span>
<span class="lineno"> 3122 </span><span class="spaces">    </span><span class="nottickedoff">case RL.appendAssoc ctx tops_prxs rets_prxs of</span>
<span class="lineno"> 3123 </span><span class="spaces">      </span><span class="nottickedoff">Refl -&gt;</span>
<span class="lineno"> 3124 </span><span class="spaces">        </span><span class="nottickedoff">inExtCtxDescTransM tops $ \kdescs -&gt;</span>
<span class="lineno"> 3125 </span><span class="spaces">        </span><span class="nottickedoff">(\d -&gt; [d]) &lt;$&gt; piTpDescMulti kdescs &lt;$&gt;</span>
<span class="lineno"> 3126 </span><span class="spaces">        </span><span class="nottickedoff">do ds_in &lt;- translateDescs (mbCombine tops_prxs perms_in)</span>
<span class="lineno"> 3127 </span><span class="spaces">           </span><span class="nottickedoff">funTpDesc ds_in &lt;$&gt;</span>
<span class="lineno"> 3128 </span><span class="spaces">             </span><span class="nottickedoff">translateRetTpDesc rets (mbCombine</span>
<span class="lineno"> 3129 </span><span class="spaces">                                      </span><span class="nottickedoff">(RL.append tops_prxs rets_prxs) perms_out)</span></span>
<span class="lineno"> 3130 </span>
<span class="lineno"> 3131 </span>-- | Lambda-abstraction over a permission
<span class="lineno"> 3132 </span>lambdaPermTrans :: TransInfo info =&gt; String -&gt; Mb ctx (ValuePerm a) -&gt;
<span class="lineno"> 3133 </span>                   (PermTrans ctx a -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno"> 3134 </span>                   TransM info ctx OpenTerm
<span class="lineno"> 3135 </span><span class="decl"><span class="nottickedoff">lambdaPermTrans str p f =</span>
<span class="lineno"> 3136 </span><span class="spaces">  </span><span class="nottickedoff">translate p &gt;&gt;= \tptrans -&gt; lambdaTransM str tptrans f</span></span>
<span class="lineno"> 3137 </span>
<span class="lineno"> 3138 </span>-- | Lambda-abstraction over a sequence of permissions
<span class="lineno"> 3139 </span>lambdaPermCtx :: TransInfo info =&gt; Mb ctx (ValuePerms ps) -&gt;
<span class="lineno"> 3140 </span>                 (PermTransCtx ctx ps -&gt; TransM info ctx OpenTerm) -&gt;
<span class="lineno"> 3141 </span>                 TransM info ctx OpenTerm
<span class="lineno"> 3142 </span><span class="decl"><span class="nottickedoff">lambdaPermCtx ps f =</span>
<span class="lineno"> 3143 </span><span class="spaces">  </span><span class="nottickedoff">translate ps &gt;&gt;= \tptrans -&gt; lambdaTransM &quot;p&quot; tptrans f</span></span>
<span class="lineno"> 3144 </span>
<span class="lineno"> 3145 </span>-- | Build the return type for a function, as a right-nested sigma type over the
<span class="lineno"> 3146 </span>-- translations of the types in @rets@, with the tuple of the translations of
<span class="lineno"> 3147 </span>-- the returned permissions to types
<span class="lineno"> 3148 </span>translateRetType :: TransInfo info =&gt; CruCtx rets -&gt;
<span class="lineno"> 3149 </span>                    Mb (ctx :++: rets) (ValuePerms ps) -&gt;
<span class="lineno"> 3150 </span>                    TransM info ctx OpenTerm
<span class="lineno"> 3151 </span><span class="decl"><span class="nottickedoff">translateRetType rets ret_perms =</span>
<span class="lineno"> 3152 </span><span class="spaces">  </span><span class="nottickedoff">do tptrans &lt;- translateClosed rets</span>
<span class="lineno"> 3153 </span><span class="spaces">     </span><span class="nottickedoff">sigmaTypeTransM &quot;ret&quot; tptrans $ \ectx -&gt;</span>
<span class="lineno"> 3154 </span><span class="spaces">       </span><span class="nottickedoff">inExtMultiTransM ectx (translate ret_perms)</span></span>
<span class="lineno"> 3155 </span>
<span class="lineno"> 3156 </span>-- | Build the type description of the type returned by 'translateRetType'
<span class="lineno"> 3157 </span>translateRetTpDesc :: CruCtx rets -&gt;
<span class="lineno"> 3158 </span>                      Mb (ctx :++: rets) (ValuePerms ps) -&gt;
<span class="lineno"> 3159 </span>                      DescTransM ctx OpenTerm
<span class="lineno"> 3160 </span><span class="decl"><span class="nottickedoff">translateRetTpDesc rets ret_perms =</span>
<span class="lineno"> 3161 </span><span class="spaces">  </span><span class="nottickedoff">inExtCtxDescTransM rets $ \kdescs -&gt;</span>
<span class="lineno"> 3162 </span><span class="spaces">  </span><span class="nottickedoff">sigmaTpDescMulti kdescs &lt;$&gt; translateDesc ret_perms</span></span>
<span class="lineno"> 3163 </span>
<span class="lineno"> 3164 </span>-- | Build the pure return type (not including the application of @SpecM@) for
<span class="lineno"> 3165 </span>-- the function resulting from an entrypoint
<span class="lineno"> 3166 </span>translateEntryRetType :: TransInfo info =&gt;
<span class="lineno"> 3167 </span>                         TypedEntry phase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 3168 </span>                         TransM info ((tops :++: args) :++: ghosts) OpenTerm
<span class="lineno"> 3169 </span><span class="decl"><span class="nottickedoff">translateEntryRetType (TypedEntry {..}</span>
<span class="lineno"> 3170 </span><span class="spaces">                       </span><span class="nottickedoff">:: TypedEntry phase ext blocks tops rets args ghosts) =</span>
<span class="lineno"> 3171 </span><span class="spaces">  </span><span class="nottickedoff">let mb_perms_out =</span>
<span class="lineno"> 3172 </span><span class="spaces">        </span><span class="nottickedoff">mbCombine (cruCtxProxies typedEntryRets) $</span>
<span class="lineno"> 3173 </span><span class="spaces">        </span><span class="nottickedoff">extMbMulti (cruCtxProxies typedEntryGhosts) $</span>
<span class="lineno"> 3174 </span><span class="spaces">        </span><span class="nottickedoff">extMbMulti (cruCtxProxies typedEntryArgs) $</span>
<span class="lineno"> 3175 </span><span class="spaces">        </span><span class="nottickedoff">mbSeparate @_ @tops (cruCtxProxies typedEntryRets) typedEntryPermsOut in</span>
<span class="lineno"> 3176 </span><span class="spaces">  </span><span class="nottickedoff">translateRetType typedEntryRets mb_perms_out</span></span>
<span class="lineno"> 3177 </span>
<span class="lineno"> 3178 </span>
<span class="lineno"> 3179 </span>----------------------------------------------------------------------
<span class="lineno"> 3180 </span>-- * The Implication Translation Monad
<span class="lineno"> 3181 </span>----------------------------------------------------------------------
<span class="lineno"> 3182 </span>
<span class="lineno"> 3183 </span>-- | A mapping from a block entrypoint to a corresponding SAW monadic function
<span class="lineno"> 3184 </span>-- that is bound to its translation if it has one: only those entrypoints marked
<span class="lineno"> 3185 </span>-- as the heads of strongly-connect components have translations as recursive
<span class="lineno"> 3186 </span>-- functions
<span class="lineno"> 3187 </span>data TypedEntryTrans ext blocks tops rets args ghosts =
<span class="lineno"> 3188 </span>  TypedEntryTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryTransEntry</span></span></span> ::
<span class="lineno"> 3189 </span>                      TypedEntry TransPhase ext blocks tops rets args ghosts,
<span class="lineno"> 3190 </span>                    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryTransFun</span></span></span> :: Maybe OpenTerm }
<span class="lineno"> 3191 </span>
<span class="lineno"> 3192 </span>-- | A mapping from a block to the SAW functions for each entrypoint
<span class="lineno"> 3193 </span>data TypedBlockTrans ext blocks tops rets args =
<span class="lineno"> 3194 </span>  TypedBlockTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedBlockTransEntries</span></span></span> ::
<span class="lineno"> 3195 </span>                      [Some (TypedEntryTrans ext blocks tops rets args)] }
<span class="lineno"> 3196 </span>
<span class="lineno"> 3197 </span>-- | A mapping from all block entrypoints to their SAW translations
<span class="lineno"> 3198 </span>type TypedBlockMapTrans ext blocks tops rets =
<span class="lineno"> 3199 </span>  RAssign (TypedBlockTrans ext blocks tops rets) blocks
<span class="lineno"> 3200 </span>
<span class="lineno"> 3201 </span>-- | A dummy 'TypedBlockMapTrans' with no blocks
<span class="lineno"> 3202 </span>emptyTypedBlockMapTrans :: TypedBlockMapTrans () RNil RNil RNil
<span class="lineno"> 3203 </span><span class="decl"><span class="nottickedoff">emptyTypedBlockMapTrans = MNil</span></span>
<span class="lineno"> 3204 </span>
<span class="lineno"> 3205 </span>-- | Look up the translation of an entry by entry ID
<span class="lineno"> 3206 </span>lookupEntryTrans :: TypedEntryID blocks args -&gt;
<span class="lineno"> 3207 </span>                    TypedBlockMapTrans ext blocks tops rets -&gt;
<span class="lineno"> 3208 </span>                    Some (TypedEntryTrans ext blocks tops rets args)
<span class="lineno"> 3209 </span><span class="decl"><span class="nottickedoff">lookupEntryTrans entryID blkMap =</span>
<span class="lineno"> 3210 </span><span class="spaces">  </span><span class="nottickedoff">maybe (error &quot;lookupEntryTrans&quot;) id $</span>
<span class="lineno"> 3211 </span><span class="spaces">  </span><span class="nottickedoff">find (\(Some entryTrans) -&gt;</span>
<span class="lineno"> 3212 </span><span class="spaces">         </span><span class="nottickedoff">entryID == typedEntryID (typedEntryTransEntry entryTrans)) $</span>
<span class="lineno"> 3213 </span><span class="spaces">  </span><span class="nottickedoff">typedBlockTransEntries (RL.get (entryBlockMember entryID) blkMap)</span></span>
<span class="lineno"> 3214 </span>
<span class="lineno"> 3215 </span>-- | Look up the translation of an entry by entry ID and make sure that it has
<span class="lineno"> 3216 </span>-- the supplied ghost arguments
<span class="lineno"> 3217 </span>lookupEntryTransCast :: TypedEntryID blocks args -&gt; CruCtx ghosts -&gt;
<span class="lineno"> 3218 </span>                        TypedBlockMapTrans ext blocks tops rets -&gt;
<span class="lineno"> 3219 </span>                        TypedEntryTrans ext blocks tops rets args ghosts
<span class="lineno"> 3220 </span><span class="decl"><span class="nottickedoff">lookupEntryTransCast entryID ghosts blkMap</span>
<span class="lineno"> 3221 </span><span class="spaces">  </span><span class="nottickedoff">| Some entry_trans &lt;- lookupEntryTrans entryID blkMap</span>
<span class="lineno"> 3222 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality ghosts (typedEntryGhosts $</span>
<span class="lineno"> 3223 </span><span class="spaces">                                      </span><span class="nottickedoff">typedEntryTransEntry entry_trans)</span>
<span class="lineno"> 3224 </span><span class="spaces">  </span><span class="nottickedoff">= entry_trans</span>
<span class="lineno"> 3225 </span><span class="spaces"></span><span class="nottickedoff">lookupEntryTransCast _ _ _ =</span>
<span class="lineno"> 3226 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;lookupEntryTransCast: incorrect ghosts argument&quot;</span></span>
<span class="lineno"> 3227 </span>
<span class="lineno"> 3228 </span>-- | A 'TypedCallSite' with existentially quantified ghost variables
<span class="lineno"> 3229 </span>data SomeTypedCallSite blocks tops args vars =
<span class="lineno"> 3230 </span>  forall ghosts.
<span class="lineno"> 3231 </span>  SomeTypedCallSite (TypedCallSite TransPhase blocks tops args ghosts vars)
<span class="lineno"> 3232 </span>
<span class="lineno"> 3233 </span>-- | Look up a call site by id in a 'TypedBlockMapTrans'
<span class="lineno"> 3234 </span>lookupCallSite :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 3235 </span>                  TypedBlockMapTrans ext blocks tops rets -&gt;
<span class="lineno"> 3236 </span>                  SomeTypedCallSite blocks tops args vars
<span class="lineno"> 3237 </span><span class="decl"><span class="nottickedoff">lookupCallSite siteID blkMap</span>
<span class="lineno"> 3238 </span><span class="spaces">  </span><span class="nottickedoff">| Some entry_trans &lt;- lookupEntryTrans (callSiteDest siteID) blkMap</span>
<span class="lineno"> 3239 </span><span class="spaces">  </span><span class="nottickedoff">, Just site &lt;- typedEntryCallerSite siteID (typedEntryTransEntry entry_trans)</span>
<span class="lineno"> 3240 </span><span class="spaces">  </span><span class="nottickedoff">= SomeTypedCallSite site</span>
<span class="lineno"> 3241 </span><span class="spaces"></span><span class="nottickedoff">lookupCallSite siteID blkMap</span>
<span class="lineno"> 3242 </span><span class="spaces">  </span><span class="nottickedoff">| Some entry_trans &lt;- lookupEntryTrans (callSiteDest siteID) blkMap =</span>
<span class="lineno"> 3243 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;lookupCallSite: no call site for site ID: &quot; ++ show siteID ++</span>
<span class="lineno"> 3244 </span><span class="spaces">           </span><span class="nottickedoff">&quot;\n&quot; ++ &quot;call sites for entrypoint: &quot; ++</span>
<span class="lineno"> 3245 </span><span class="spaces">           </span><span class="nottickedoff">show (map (\(Some site) -&gt; show $ typedCallSiteID site)</span>
<span class="lineno"> 3246 </span><span class="spaces">                 </span><span class="nottickedoff">(typedEntryCallers $ typedEntryTransEntry entry_trans)))</span></span>
<span class="lineno"> 3247 </span>
<span class="lineno"> 3248 </span>
<span class="lineno"> 3249 </span>-- | Contextual info for an implication translation
<span class="lineno"> 3250 </span>data ImpTransInfo ext blocks tops rets ps ctx =
<span class="lineno"> 3251 </span>  ImpTransInfo
<span class="lineno"> 3252 </span>  {
<span class="lineno"> 3253 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiExprCtx</span></span></span> :: ExprTransCtx ctx,
<span class="lineno"> 3254 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiPermCtx</span></span></span> :: PermTransCtx ctx ctx,
<span class="lineno"> 3255 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiPermStack</span></span></span> :: PermTransCtx ctx ps,
<span class="lineno"> 3256 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiPermStackVars</span></span></span> :: RAssign (Member ctx) ps,
<span class="lineno"> 3257 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiPermEnv</span></span></span> :: PermEnv,
<span class="lineno"> 3258 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiBlockMapTrans</span></span></span> :: TypedBlockMapTrans ext blocks tops rets,
<span class="lineno"> 3259 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiReturnType</span></span></span> :: OpenTerm,
<span class="lineno"> 3260 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">itiChecksFlag</span></span></span> :: ChecksFlag
<span class="lineno"> 3261 </span>  }
<span class="lineno"> 3262 </span>
<span class="lineno"> 3263 </span>instance TransInfo (ImpTransInfo ext blocks tops rets ps) where
<span class="lineno"> 3264 </span>  <span class="decl"><span class="nottickedoff">infoCtx = itiExprCtx</span></span>
<span class="lineno"> 3265 </span>  <span class="decl"><span class="nottickedoff">infoEnv = itiPermEnv</span></span>
<span class="lineno"> 3266 </span>  <span class="decl"><span class="nottickedoff">infoChecksFlag = itiChecksFlag</span></span>
<span class="lineno"> 3267 </span>  <span class="decl"><span class="nottickedoff">extTransInfo etrans (ImpTransInfo {..}) =</span>
<span class="lineno"> 3268 </span><span class="spaces">    </span><span class="nottickedoff">ImpTransInfo</span>
<span class="lineno"> 3269 </span><span class="spaces">    </span><span class="nottickedoff">{ itiExprCtx = itiExprCtx :&gt;: etrans</span>
<span class="lineno"> 3270 </span><span class="spaces">    </span><span class="nottickedoff">, itiPermCtx = consPermTransCtx (extPermTransCtx etrans itiPermCtx) PTrans_True</span>
<span class="lineno"> 3271 </span><span class="spaces">    </span><span class="nottickedoff">, itiPermStack = extPermTransCtx etrans itiPermStack</span>
<span class="lineno"> 3272 </span><span class="spaces">    </span><span class="nottickedoff">, itiPermStackVars = RL.map Member_Step itiPermStackVars</span>
<span class="lineno"> 3273 </span><span class="spaces">    </span><span class="nottickedoff">, .. }</span></span>
<span class="lineno"> 3274 </span>
<span class="lineno"> 3275 </span>instance TransInfoM (ImpTransInfo ext blocks tops rets ps) where
<span class="lineno"> 3276 </span>  <span class="decl"><span class="nottickedoff">infoRetType = itiReturnType</span></span>
<span class="lineno"> 3277 </span>
<span class="lineno"> 3278 </span>-- | The monad for impure translations
<span class="lineno"> 3279 </span>type ImpTransM ext blocks tops rets ps =
<span class="lineno"> 3280 </span>  TransM (ImpTransInfo ext blocks tops rets ps)
<span class="lineno"> 3281 </span>
<span class="lineno"> 3282 </span>-- | Run an 'ImpTransM' computation in a 'TypeTransM' context (FIXME: better
<span class="lineno"> 3283 </span>-- documentation; e.g., the pctx starts on top of the stack)
<span class="lineno"> 3284 </span>impTransM :: forall ctx ps ext blocks tops rets a.
<span class="lineno"> 3285 </span>             RAssign (Member ctx) ps -&gt; PermTransCtx ctx ps -&gt;
<span class="lineno"> 3286 </span>             TypedBlockMapTrans ext blocks tops rets -&gt; OpenTerm -&gt;
<span class="lineno"> 3287 </span>             ImpTransM ext blocks tops rets ps ctx a -&gt;
<span class="lineno"> 3288 </span>             TypeTransM ctx a
<span class="lineno"> 3289 </span><span class="decl"><span class="nottickedoff">impTransM pvars pctx mapTrans retType =</span>
<span class="lineno"> 3290 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM $ \(TypeTransInfo ectx penv pflag) -&gt;</span>
<span class="lineno"> 3291 </span><span class="spaces">  </span><span class="nottickedoff">ImpTransInfo { itiExprCtx = ectx,</span>
<span class="lineno"> 3292 </span><span class="spaces">                 </span><span class="nottickedoff">itiPermCtx = RL.map (const $ PTrans_True) ectx,</span>
<span class="lineno"> 3293 </span><span class="spaces">                 </span><span class="nottickedoff">itiPermStack = pctx,</span>
<span class="lineno"> 3294 </span><span class="spaces">                 </span><span class="nottickedoff">itiPermStackVars = pvars,</span>
<span class="lineno"> 3295 </span><span class="spaces">                 </span><span class="nottickedoff">itiPermEnv = penv,</span>
<span class="lineno"> 3296 </span><span class="spaces">                 </span><span class="nottickedoff">itiBlockMapTrans = mapTrans,</span>
<span class="lineno"> 3297 </span><span class="spaces">                 </span><span class="nottickedoff">itiReturnType = retType,</span>
<span class="lineno"> 3298 </span><span class="spaces">                 </span><span class="nottickedoff">itiChecksFlag = pflag</span>
<span class="lineno"> 3299 </span><span class="spaces">               </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 3300 </span>
<span class="lineno"> 3301 </span>-- | Run an inner 'ImpTransM' computation that does not use the block map
<span class="lineno"> 3302 </span>emptyBlocksImpTransM :: ImpTransM () RNil RNil RNil ps ctx a -&gt;
<span class="lineno"> 3303 </span>                        ImpTransM ext blocks tops rets ps ctx a
<span class="lineno"> 3304 </span><span class="decl"><span class="nottickedoff">emptyBlocksImpTransM =</span>
<span class="lineno"> 3305 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM (\(ImpTransInfo {..}) -&gt;</span>
<span class="lineno"> 3306 </span><span class="spaces">              </span><span class="nottickedoff">ImpTransInfo { itiBlockMapTrans = emptyTypedBlockMapTrans, .. })</span></span>
<span class="lineno"> 3307 </span>
<span class="lineno"> 3308 </span>-- | Run an implication translation computation in an \&quot;empty\&quot; environment,
<span class="lineno"> 3309 </span>-- where there are no variables in scope and no permissions held anywhere
<span class="lineno"> 3310 </span>inEmptyEnvImpTransM :: ImpTransM ext blocks tops rets RNil RNil a -&gt;
<span class="lineno"> 3311 </span>                       ImpTransM ext blocks tops rets ps ctx a
<span class="lineno"> 3312 </span><span class="decl"><span class="nottickedoff">inEmptyEnvImpTransM =</span>
<span class="lineno"> 3313 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM (\(ImpTransInfo {..}) -&gt;</span>
<span class="lineno"> 3314 </span><span class="spaces">              </span><span class="nottickedoff">ImpTransInfo { itiExprCtx = MNil, itiPermCtx = MNil,</span>
<span class="lineno"> 3315 </span><span class="spaces">                             </span><span class="nottickedoff">itiPermStack = MNil, itiPermStackVars = MNil, .. })</span></span>
<span class="lineno"> 3316 </span>
<span class="lineno"> 3317 </span>-- | Run an implication translation computation with no primary permissions on
<span class="lineno"> 3318 </span>-- any of the variables
<span class="lineno"> 3319 </span>withEmptyPermsImpTransM :: ImpTransM ext blocks tops rets ps ctx a -&gt;
<span class="lineno"> 3320 </span>                           ImpTransM ext blocks tops rets ps ctx a
<span class="lineno"> 3321 </span><span class="decl"><span class="nottickedoff">withEmptyPermsImpTransM =</span>
<span class="lineno"> 3322 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM (\(ImpTransInfo {..}) -&gt;</span>
<span class="lineno"> 3323 </span><span class="spaces">              </span><span class="nottickedoff">ImpTransInfo {</span>
<span class="lineno"> 3324 </span><span class="spaces">                </span><span class="nottickedoff">itiPermCtx = RL.map (const PTrans_True) itiExprCtx,</span>
<span class="lineno"> 3325 </span><span class="spaces">                </span><span class="nottickedoff">.. })</span></span>
<span class="lineno"> 3326 </span>
<span class="lineno"> 3327 </span>-- | Get most recently bound variable
<span class="lineno"> 3328 </span>getTopVarM :: ImpTransM ext blocks tops rets ps (ctx :&gt; tp) (ExprTrans tp)
<span class="lineno"> 3329 </span><span class="decl"><span class="nottickedoff">getTopVarM = (\(_ :&gt;: p) -&gt; p) &lt;$&gt; itiExprCtx &lt;$&gt; ask</span></span>
<span class="lineno"> 3330 </span>
<span class="lineno"> 3331 </span>-- | Get the top permission on the stack
<span class="lineno"> 3332 </span>getTopPermM :: ImpTransM ext blocks tops rets (ps :&gt; tp) ctx (PermTrans ctx tp)
<span class="lineno"> 3333 </span><span class="decl"><span class="nottickedoff">getTopPermM = (\(_ :&gt;: p) -&gt; p) &lt;$&gt; itiPermStack &lt;$&gt; ask</span></span>
<span class="lineno"> 3334 </span>
<span class="lineno"> 3335 </span>-- | Helper to disambiguate the @ext@ type variable
<span class="lineno"> 3336 </span>getExtReprM :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 3337 </span>               ImpTransM ext blocks tops rets ps ctx (ExtRepr ext)
<span class="lineno"> 3338 </span><span class="decl"><span class="nottickedoff">getExtReprM = return knownRepr</span></span>
<span class="lineno"> 3339 </span>
<span class="lineno"> 3340 </span>-- | Apply a transformation to the (translation of the) current perm stack
<span class="lineno"> 3341 </span>withPermStackM :: (RAssign (Member ctx) ps_in -&gt; RAssign (Member ctx) ps_out) -&gt;
<span class="lineno"> 3342 </span>                  (PermTransCtx ctx ps_in -&gt; PermTransCtx ctx ps_out) -&gt;
<span class="lineno"> 3343 </span>                  ImpTransM ext blocks tops rets ps_out ctx a -&gt;
<span class="lineno"> 3344 </span>                  ImpTransM ext blocks tops rets ps_in ctx a
<span class="lineno"> 3345 </span><span class="decl"><span class="nottickedoff">withPermStackM f_vars f_p =</span>
<span class="lineno"> 3346 </span><span class="spaces">  </span><span class="nottickedoff">withInfoM $ \info -&gt;</span>
<span class="lineno"> 3347 </span><span class="spaces">  </span><span class="nottickedoff">info { itiPermStack = f_p (itiPermStack info),</span>
<span class="lineno"> 3348 </span><span class="spaces">         </span><span class="nottickedoff">itiPermStackVars = f_vars (itiPermStackVars info) }</span></span>
<span class="lineno"> 3349 </span>
<span class="lineno"> 3350 </span>-- | Apply a transformation to the (translation of the) current perm stack, also
<span class="lineno"> 3351 </span>-- converting some portion of it (selected by the supplied selector function) to
<span class="lineno"> 3352 </span>-- the SAW core terms it represents using 'transTerms'
<span class="lineno"> 3353 </span>withPermStackTermsM ::
<span class="lineno"> 3354 </span>  IsTermTrans tr =&gt;
<span class="lineno"> 3355 </span>  (PermTransCtx ctx ps_in -&gt; tr) -&gt;
<span class="lineno"> 3356 </span>  (RAssign (Member ctx) ps_in -&gt; RAssign (Member ctx) ps_out) -&gt;
<span class="lineno"> 3357 </span>  ([OpenTerm] -&gt; PermTransCtx ctx ps_in -&gt;
<span class="lineno"> 3358 </span>   PermTransCtx ctx ps_out) -&gt;
<span class="lineno"> 3359 </span>  ImpTransM ext blocks tops rets ps_out ctx OpenTerm -&gt;
<span class="lineno"> 3360 </span>  ImpTransM ext blocks tops rets ps_in ctx OpenTerm
<span class="lineno"> 3361 </span><span class="decl"><span class="nottickedoff">withPermStackTermsM f_sel f_vars f_p m =</span>
<span class="lineno"> 3362 </span><span class="spaces">  </span><span class="nottickedoff">do pctx &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 3363 </span><span class="spaces">     </span><span class="nottickedoff">withPermStackM f_vars (f_p $ transTerms $ f_sel pctx) m</span></span>
<span class="lineno"> 3364 </span>
<span class="lineno"> 3365 </span>-- | Apply a transformation to the (translation of the) current perm stack, also
<span class="lineno"> 3366 </span>-- converting the top permission to the SAW core terms it represents using
<span class="lineno"> 3367 </span>-- 'transTerms'; i.e., perform 'withPermStackTermsM' with the top of the stack
<span class="lineno"> 3368 </span>withPermStackTopTermsM ::
<span class="lineno"> 3369 </span>  (RAssign (Member ctx) (ps_in :&gt; tp) -&gt; RAssign (Member ctx) ps_out) -&gt;
<span class="lineno"> 3370 </span>  ([OpenTerm] -&gt; PermTransCtx ctx (ps_in :&gt; tp) -&gt;
<span class="lineno"> 3371 </span>   PermTransCtx ctx ps_out) -&gt;
<span class="lineno"> 3372 </span>  ImpTransM ext blocks tops rets ps_out ctx OpenTerm -&gt;
<span class="lineno"> 3373 </span>  ImpTransM ext blocks tops rets (ps_in :&gt; tp) ctx OpenTerm
<span class="lineno"> 3374 </span><span class="decl"><span class="nottickedoff">withPermStackTopTermsM = withPermStackTermsM (\ (_ :&gt;: ptrans) -&gt; ptrans)</span></span>
<span class="lineno"> 3375 </span>
<span class="lineno"> 3376 </span>
<span class="lineno"> 3377 </span>-- | Get the current permission stack as a 'DistPerms' in context
<span class="lineno"> 3378 </span>getPermStackDistPerms :: ImpTransM ext blocks tops rets ps ctx
<span class="lineno"> 3379 </span>                         (Mb ctx (DistPerms ps))
<span class="lineno"> 3380 </span><span class="decl"><span class="nottickedoff">getPermStackDistPerms =</span>
<span class="lineno"> 3381 </span><span class="spaces">  </span><span class="nottickedoff">do stack &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 3382 </span><span class="spaces">     </span><span class="nottickedoff">stack_vars &lt;- itiPermStackVars &lt;$&gt; ask</span>
<span class="lineno"> 3383 </span><span class="spaces">     </span><span class="nottickedoff">prxs &lt;- RL.map (const Proxy) &lt;$&gt; itiPermCtx &lt;$&gt; ask</span>
<span class="lineno"> 3384 </span><span class="spaces">     </span><span class="nottickedoff">return $</span>
<span class="lineno"> 3385 </span><span class="spaces">       </span><span class="nottickedoff">(nuMulti prxs $ \ns -&gt;</span>
<span class="lineno"> 3386 </span><span class="spaces">         </span><span class="nottickedoff">valuePermsToDistPerms (RL.map (flip RL.get ns) stack_vars))</span>
<span class="lineno"> 3387 </span><span class="spaces">       </span><span class="nottickedoff">`mbApply`</span>
<span class="lineno"> 3388 </span><span class="spaces">       </span><span class="nottickedoff">permTransCtxPerms prxs stack</span></span>
<span class="lineno"> 3389 </span>
<span class="lineno"> 3390 </span>-- | Run a computation if the current 'ChecksFlag' is set
<span class="lineno"> 3391 </span>ifChecksFlagM :: ImpTransM ext blocks tops rets ps ctx () -&gt;
<span class="lineno"> 3392 </span>                 ImpTransM ext blocks tops rets ps ctx ()
<span class="lineno"> 3393 </span><span class="decl"><span class="nottickedoff">ifChecksFlagM m =</span>
<span class="lineno"> 3394 </span><span class="spaces">  </span><span class="nottickedoff">(itiChecksFlag &lt;$&gt; ask) &gt;&gt;= \checks -&gt;</span>
<span class="lineno"> 3395 </span><span class="spaces">  </span><span class="nottickedoff">if checksFlagSet checks then m else return ()</span></span>
<span class="lineno"> 3396 </span>
<span class="lineno"> 3397 </span>-- | Assert a property of the current permission stack, raising an 'error' if it
<span class="lineno"> 3398 </span>-- fails to hold. The 'String' names the construct being translated.
<span class="lineno"> 3399 </span>assertPermStackM :: HasCallStack =&gt; String -&gt;
<span class="lineno"> 3400 </span>                    (RAssign (Member ctx) ps -&gt; PermTransCtx ctx ps -&gt; Bool) -&gt;
<span class="lineno"> 3401 </span>                    ImpTransM ext blocks tops rets ps ctx ()
<span class="lineno"> 3402 </span><span class="decl"><span class="nottickedoff">assertPermStackM nm f =</span>
<span class="lineno"> 3403 </span><span class="spaces">  </span><span class="nottickedoff">ifChecksFlagM</span>
<span class="lineno"> 3404 </span><span class="spaces">  </span><span class="nottickedoff">(ask &gt;&gt;= \info -&gt;</span>
<span class="lineno"> 3405 </span><span class="spaces">   </span><span class="nottickedoff">if f (itiPermStackVars info) (itiPermStack info) then return () else</span>
<span class="lineno"> 3406 </span><span class="spaces">     </span><span class="nottickedoff">error (&quot;translate: &quot; ++ nm ++ nlPrettyCallStack callStack))</span></span>
<span class="lineno"> 3407 </span>
<span class="lineno"> 3408 </span>-- | Assert that the top portion of the current permission stack equals the
<span class="lineno"> 3409 </span>-- given 'DistPerms'
<span class="lineno"> 3410 </span>assertPermStackTopEqM :: HasCallStack =&gt; ps ~ (ps1 :++: ps2) =&gt;
<span class="lineno"> 3411 </span>                         String -&gt; f ps1 -&gt; Mb ctx (DistPerms ps2) -&gt;
<span class="lineno"> 3412 </span>                         ImpTransM ext blocks tops rets ps ctx ()
<span class="lineno"> 3413 </span><span class="decl"><span class="nottickedoff">assertPermStackTopEqM nm prx expected =</span>
<span class="lineno"> 3414 </span><span class="spaces">  </span><span class="nottickedoff">ifChecksFlagM</span>
<span class="lineno"> 3415 </span><span class="spaces">  </span><span class="nottickedoff">(getPermStackDistPerms &gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 3416 </span><span class="spaces">   </span><span class="nottickedoff">let actuals =</span>
<span class="lineno"> 3417 </span><span class="spaces">         </span><span class="nottickedoff">fmap (snd . splitDistPerms prx (mbDistPermsToProxies expected)) perms in</span>
<span class="lineno"> 3418 </span><span class="spaces">   </span><span class="nottickedoff">if expected == actuals then return () else</span>
<span class="lineno"> 3419 </span><span class="spaces">     </span><span class="nottickedoff">error (&quot;assertPermStackEqM (&quot; ++ nm ++ &quot;): expected permission stack:\n&quot; ++</span>
<span class="lineno"> 3420 </span><span class="spaces">            </span><span class="nottickedoff">permPrettyString emptyPPInfo expected ++</span>
<span class="lineno"> 3421 </span><span class="spaces">            </span><span class="nottickedoff">&quot;\nFound permission stack:\n&quot; ++</span>
<span class="lineno"> 3422 </span><span class="spaces">            </span><span class="nottickedoff">permPrettyString emptyPPInfo actuals ++</span>
<span class="lineno"> 3423 </span><span class="spaces">            </span><span class="nottickedoff">nlPrettyCallStack callStack))</span></span>
<span class="lineno"> 3424 </span>
<span class="lineno"> 3425 </span>-- | Assert that the current permission stack equals the given 'DistPerms'
<span class="lineno"> 3426 </span>assertPermStackEqM :: HasCallStack =&gt; String -&gt; Mb ctx (DistPerms ps) -&gt;
<span class="lineno"> 3427 </span>                      ImpTransM ext blocks tops rets ps ctx ()
<span class="lineno"> 3428 </span><span class="decl"><span class="nottickedoff">assertPermStackEqM nm perms =</span>
<span class="lineno"> 3429 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: unify this function with assertPermStackTopEqM</span>
<span class="lineno"> 3430 </span><span class="spaces">  </span><span class="nottickedoff">ifChecksFlagM</span>
<span class="lineno"> 3431 </span><span class="spaces">  </span><span class="nottickedoff">(getPermStackDistPerms &gt;&gt;= \stack_perms -&gt;</span>
<span class="lineno"> 3432 </span><span class="spaces">   </span><span class="nottickedoff">if perms == stack_perms then return () else</span>
<span class="lineno"> 3433 </span><span class="spaces">     </span><span class="nottickedoff">error (&quot;assertPermStackEqM (&quot; ++ nm ++ &quot;): expected permission stack:\n&quot; ++</span>
<span class="lineno"> 3434 </span><span class="spaces">            </span><span class="nottickedoff">permPrettyString emptyPPInfo perms ++</span>
<span class="lineno"> 3435 </span><span class="spaces">            </span><span class="nottickedoff">&quot;\nFound permission stack:\n&quot; ++</span>
<span class="lineno"> 3436 </span><span class="spaces">            </span><span class="nottickedoff">permPrettyString emptyPPInfo stack_perms ++</span>
<span class="lineno"> 3437 </span><span class="spaces">            </span><span class="nottickedoff">nlPrettyCallStack callStack))</span></span>
<span class="lineno"> 3438 </span>
<span class="lineno"> 3439 </span>-- | Assert that the top permission is as given by the arguments
<span class="lineno"> 3440 </span>assertTopPermM :: HasCallStack =&gt; String -&gt; Mb ctx (ExprVar a) -&gt;
<span class="lineno"> 3441 </span>                  Mb ctx (ValuePerm a) -&gt;
<span class="lineno"> 3442 </span>                  ImpTransM ext blocks tops rets (ps :&gt; a) ctx ()
<span class="lineno"> 3443 </span><span class="decl"><span class="nottickedoff">assertTopPermM nm x p =</span>
<span class="lineno"> 3444 </span><span class="spaces">  </span><span class="nottickedoff">ifChecksFlagM</span>
<span class="lineno"> 3445 </span><span class="spaces">  </span><span class="nottickedoff">(getPermStackDistPerms &gt;&gt;= \stack_perms -&gt;</span>
<span class="lineno"> 3446 </span><span class="spaces">   </span><span class="nottickedoff">case mbMatch stack_perms of</span>
<span class="lineno"> 3447 </span><span class="spaces">     </span><span class="nottickedoff">[nuMP| DistPermsCons _ x' p' |] | x == x' &amp;&amp; p == p' -&gt; return ()</span>
<span class="lineno"> 3448 </span><span class="spaces">     </span><span class="nottickedoff">[nuMP| DistPermsCons _ x' p' |] -&gt;</span>
<span class="lineno"> 3449 </span><span class="spaces">       </span><span class="nottickedoff">error (&quot;assertTopPermM (&quot; ++ nm ++ &quot;): expected top permissions:\n&quot; ++</span>
<span class="lineno"> 3450 </span><span class="spaces">              </span><span class="nottickedoff">permPrettyString emptyPPInfo (mbMap2 distPerms1 x p) ++</span>
<span class="lineno"> 3451 </span><span class="spaces">              </span><span class="nottickedoff">&quot;\nFound top permissions:\n&quot; ++</span>
<span class="lineno"> 3452 </span><span class="spaces">              </span><span class="nottickedoff">permPrettyString emptyPPInfo (mbMap2 distPerms1 x' p') ++</span>
<span class="lineno"> 3453 </span><span class="spaces">              </span><span class="nottickedoff">nlPrettyCallStack callStack ++</span>
<span class="lineno"> 3454 </span><span class="spaces">              </span><span class="nottickedoff">&quot;\nCurrent perm stack:\n&quot; ++</span>
<span class="lineno"> 3455 </span><span class="spaces">              </span><span class="nottickedoff">permPrettyString emptyPPInfo stack_perms))</span></span>
<span class="lineno"> 3456 </span>
<span class="lineno"> 3457 </span>-- | Get the (translation of the) perms for a variable
<span class="lineno"> 3458 </span>getVarPermM :: Mb ctx (ExprVar tp) -&gt;
<span class="lineno"> 3459 </span>               ImpTransM ext blocks tops rets ps ctx (PermTrans ctx tp)
<span class="lineno"> 3460 </span><span class="decl"><span class="nottickedoff">getVarPermM x = RL.get (translateVar x) &lt;$&gt; itiPermCtx &lt;$&gt; ask</span></span>
<span class="lineno"> 3461 </span>
<span class="lineno"> 3462 </span>-- | Assert that a variable has a given permission
<span class="lineno"> 3463 </span>assertVarPermM :: HasCallStack =&gt; String -&gt; Mb ctx (ExprVar tp) -&gt;
<span class="lineno"> 3464 </span>                  Mb ctx (ValuePerm tp) -&gt;
<span class="lineno"> 3465 </span>                  ImpTransM ext blocks tops rets ps ctx ()
<span class="lineno"> 3466 </span><span class="decl"><span class="nottickedoff">assertVarPermM nm x p =</span>
<span class="lineno"> 3467 </span><span class="spaces">  </span><span class="nottickedoff">do x_p &lt;- permTransPerm (mbToProxy p) &lt;$&gt; getVarPermM x</span>
<span class="lineno"> 3468 </span><span class="spaces">     </span><span class="nottickedoff">if x_p == p then return () else</span>
<span class="lineno"> 3469 </span><span class="spaces">       </span><span class="nottickedoff">error (&quot;assertVarPermM (&quot; ++ nm ++ &quot;):\n&quot; ++</span>
<span class="lineno"> 3470 </span><span class="spaces">              </span><span class="nottickedoff">&quot;expected: &quot; ++ permPrettyString emptyPPInfo p ++ &quot;\n&quot; ++</span>
<span class="lineno"> 3471 </span><span class="spaces">              </span><span class="nottickedoff">&quot;found:&quot; ++ permPrettyString emptyPPInfo x_p ++</span>
<span class="lineno"> 3472 </span><span class="spaces">              </span><span class="nottickedoff">nlPrettyCallStack callStack)</span></span>
<span class="lineno"> 3473 </span>
<span class="lineno"> 3474 </span>-- | Set the (translation of the) perms for a variable in a computation
<span class="lineno"> 3475 </span>setVarPermM :: Mb ctx (ExprVar tp) -&gt; PermTrans ctx tp -&gt;
<span class="lineno"> 3476 </span>               ImpTransM ext blocks tops rets ps ctx a -&gt;
<span class="lineno"> 3477 </span>               ImpTransM ext blocks tops rets ps ctx a
<span class="lineno"> 3478 </span><span class="decl"><span class="nottickedoff">setVarPermM x p =</span>
<span class="lineno"> 3479 </span><span class="spaces">  </span><span class="nottickedoff">local $ \info -&gt; info { itiPermCtx =</span>
<span class="lineno"> 3480 </span><span class="spaces">                            </span><span class="nottickedoff">RL.set (translateVar x) p $ itiPermCtx info }</span></span>
<span class="lineno"> 3481 </span>
<span class="lineno"> 3482 </span>-- | Clear all permissions in the permission variable map in a sub-computation,
<span class="lineno"> 3483 </span>-- leaving only those permissions on the top of the stack
<span class="lineno"> 3484 </span>clearVarPermsM :: ImpTransM ext blocks tops rets ps ctx a -&gt;
<span class="lineno"> 3485 </span>                  ImpTransM ext blocks tops rets ps ctx a
<span class="lineno"> 3486 </span><span class="decl"><span class="nottickedoff">clearVarPermsM =</span>
<span class="lineno"> 3487 </span><span class="spaces">  </span><span class="nottickedoff">local $ \info -&gt; info { itiPermCtx =</span>
<span class="lineno"> 3488 </span><span class="spaces">                            </span><span class="nottickedoff">RL.map (const PTrans_True) $ itiPermCtx info }</span></span>
<span class="lineno"> 3489 </span>
<span class="lineno"> 3490 </span>-- | Build an @errorS@ computation with the given error message
<span class="lineno"> 3491 </span>mkErrorComp :: String -&gt; ImpTransM ext blocks tops rets ps_out ctx OpenTerm
<span class="lineno"> 3492 </span><span class="decl"><span class="nottickedoff">mkErrorComp msg =</span>
<span class="lineno"> 3493 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 3494 </span><span class="spaces">     </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 3495 </span><span class="spaces">     </span><span class="nottickedoff">return $ errorSOpenTerm ev ret_tp msg</span></span>
<span class="lineno"> 3496 </span>
<span class="lineno"> 3497 </span>-- | The typeclass for the implication translation of a functor at any
<span class="lineno"> 3498 </span>-- permission set inside any binding to an 'OpenTerm'
<span class="lineno"> 3499 </span>class NuMatchingAny1 f =&gt; ImplTranslateF f ext blocks tops rets where
<span class="lineno"> 3500 </span>  translateF :: Mb ctx (f ps) -&gt; ImpTransM ext blocks tops rets ps ctx OpenTerm
<span class="lineno"> 3501 </span>
<span class="lineno"> 3502 </span>
<span class="lineno"> 3503 </span>----------------------------------------------------------------------
<span class="lineno"> 3504 </span>-- * Translating Permission Implication Constructs
<span class="lineno"> 3505 </span>----------------------------------------------------------------------
<span class="lineno"> 3506 </span>
<span class="lineno"> 3507 </span>-- | A failure continuation represents any catch that is around the current
<span class="lineno"> 3508 </span>-- 'PermImpl', and can either be a term to jump to / call (meaning that there is
<span class="lineno"> 3509 </span>-- a catch) or an error message (meaning there is not)
<span class="lineno"> 3510 </span>data ImplFailCont
<span class="lineno"> 3511 </span>     -- | A continuation that calls a term on failure
<span class="lineno"> 3512 </span>  = ImplFailContTerm OpenTerm
<span class="lineno"> 3513 </span>    -- | An error message to print on failure, along with the event type needed
<span class="lineno"> 3514 </span>    -- to build an @errorS@ spec term
<span class="lineno"> 3515 </span>  | ImplFailContMsg EventType String
<span class="lineno"> 3516 </span>
<span class="lineno"> 3517 </span>-- | The prefix used in error strings for implication failures
<span class="lineno"> 3518 </span>implicationFailurePrefix :: String
<span class="lineno"> 3519 </span><span class="decl"><span class="nottickedoff">implicationFailurePrefix = &quot;Heapster implication failure:\n&quot;</span></span>
<span class="lineno"> 3520 </span>
<span class="lineno"> 3521 </span>-- | Convert an 'ImplFailCont' to an error, which should have the given type
<span class="lineno"> 3522 </span>implFailContTerm :: OpenTerm -&gt; ImplFailCont -&gt; OpenTerm
<span class="lineno"> 3523 </span><span class="decl"><span class="nottickedoff">implFailContTerm _ (ImplFailContTerm t) = t</span>
<span class="lineno"> 3524 </span><span class="spaces"></span><span class="nottickedoff">implFailContTerm tp (ImplFailContMsg ev msg) =</span>
<span class="lineno"> 3525 </span><span class="spaces">  </span><span class="nottickedoff">errorSOpenTerm ev tp $ implicationFailurePrefix ++ msg</span></span>
<span class="lineno"> 3526 </span>
<span class="lineno"> 3527 </span>-- | Convert an 'ImplFailCont' to an error as in 'implFailContTerm', but use an
<span class="lineno"> 3528 </span>-- alternate error message in the case of 'ImplFailContMsg'
<span class="lineno"> 3529 </span>implFailAltContTerm :: OpenTerm -&gt; String -&gt; ImplFailCont -&gt; OpenTerm
<span class="lineno"> 3530 </span><span class="decl"><span class="nottickedoff">implFailAltContTerm _ _ (ImplFailContTerm t) = t</span>
<span class="lineno"> 3531 </span><span class="spaces"></span><span class="nottickedoff">implFailAltContTerm tp msg (ImplFailContMsg ev _) =</span>
<span class="lineno"> 3532 </span><span class="spaces">  </span><span class="nottickedoff">errorSOpenTerm ev tp $ &quot;Failed to prove: &quot; ++ msg</span></span>
<span class="lineno"> 3533 </span>
<span class="lineno"> 3534 </span>-- | The type of terms use to translation permission implications, which can
<span class="lineno"> 3535 </span>-- contain calls to the current failure continuation
<span class="lineno"> 3536 </span>newtype PImplTerm ext blocks tops rets ps ctx =
<span class="lineno"> 3537 </span>  PImplTerm { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">popPImplTerm</span></span></span> ::
<span class="lineno"> 3538 </span>                ImplFailCont -&gt; ImpTransM ext blocks tops rets ps ctx OpenTerm }
<span class="lineno"> 3539 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">OpenTermLike</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 3540 </span>
<span class="lineno"> 3541 </span>-- | Build a 'PImplTerm' from the first 'PImplTerm' that uses the second as the
<span class="lineno"> 3542 </span>-- failure continuation
<span class="lineno"> 3543 </span>catchPImplTerm :: PImplTerm ext blocks tops rets ps ctx -&gt;
<span class="lineno"> 3544 </span>                  PImplTerm ext blocks tops rets ps ctx -&gt;
<span class="lineno"> 3545 </span>                  PImplTerm ext blocks tops rets ps ctx
<span class="lineno"> 3546 </span><span class="decl"><span class="nottickedoff">catchPImplTerm t t_catch =</span>
<span class="lineno"> 3547 </span><span class="spaces">  </span><span class="nottickedoff">PImplTerm $ \k -&gt;</span>
<span class="lineno"> 3548 </span><span class="spaces">  </span><span class="nottickedoff">compReturnTypeM &gt;&gt;= \tp -&gt;</span>
<span class="lineno"> 3549 </span><span class="spaces">  </span><span class="nottickedoff">letTransM &quot;catchpoint&quot; tp (popPImplTerm t_catch k) $ \k_tm -&gt;</span>
<span class="lineno"> 3550 </span><span class="spaces">  </span><span class="nottickedoff">popPImplTerm t $ ImplFailContTerm k_tm</span></span>
<span class="lineno"> 3551 </span>
<span class="lineno"> 3552 </span>-- | The failure 'PImplTerm', which immediately calls its failure continuation
<span class="lineno"> 3553 </span>failPImplTerm :: PImplTerm ext blocks tops rets ps ctx
<span class="lineno"> 3554 </span><span class="decl"><span class="nottickedoff">failPImplTerm =</span>
<span class="lineno"> 3555 </span><span class="spaces">  </span><span class="nottickedoff">PImplTerm $ \k -&gt; returnTypeM &gt;&gt;= \tp -&gt; return (implFailContTerm tp k)</span></span>
<span class="lineno"> 3556 </span>
<span class="lineno"> 3557 </span>-- | Return the failure 'PImplTerm' like 'failPImplTerm' but use an alternate
<span class="lineno"> 3558 </span>-- error message in the case that the failure continuation is an error message
<span class="lineno"> 3559 </span>failPImplTermAlt :: String -&gt; PImplTerm ext blocks tops rets ps ctx
<span class="lineno"> 3560 </span><span class="decl"><span class="nottickedoff">failPImplTermAlt msg = PImplTerm $ \k -&gt;</span>
<span class="lineno"> 3561 </span><span class="spaces">  </span><span class="nottickedoff">returnTypeM &gt;&gt;= \tp -&gt;</span>
<span class="lineno"> 3562 </span><span class="spaces">  </span><span class="nottickedoff">return (implFailContTerm tp (case k of</span>
<span class="lineno"> 3563 </span><span class="spaces">                                  </span><span class="nottickedoff">ImplFailContMsg ev _ -&gt; ImplFailContMsg ev msg</span>
<span class="lineno"> 3564 </span><span class="spaces">                                  </span><span class="nottickedoff">_ -&gt; k))</span></span>
<span class="lineno"> 3565 </span>
<span class="lineno"> 3566 </span>-- | \&quot;Force\&quot; an optional 'PImplTerm' to a 'PImplTerm' by converting a
<span class="lineno"> 3567 </span>-- 'Nothing' to the 'failPImplTerm'
<span class="lineno"> 3568 </span>forcePImplTerm :: Maybe (PImplTerm ext blocks tops rets ps ctx) -&gt;
<span class="lineno"> 3569 </span>                  PImplTerm ext blocks tops rets ps ctx
<span class="lineno"> 3570 </span><span class="decl"><span class="nottickedoff">forcePImplTerm (Just t) = t</span>
<span class="lineno"> 3571 </span><span class="spaces"></span><span class="nottickedoff">forcePImplTerm Nothing = failPImplTerm</span></span>
<span class="lineno"> 3572 </span>
<span class="lineno"> 3573 </span>
<span class="lineno"> 3574 </span>-- | A flag to indicate whether a 'PImplTerm' calls its failure continuation
<span class="lineno"> 3575 </span>data HasFailures = HasFailures | NoFailures deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 3576 </span>
<span class="lineno"> 3577 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Semigroup HasFailures</span></span></span></span> where
<span class="lineno"> 3578 </span>  <span class="decl"><span class="nottickedoff">HasFailures &lt;&gt; _ = HasFailures</span>
<span class="lineno"> 3579 </span><span class="spaces">  </span><span class="nottickedoff">_ &lt;&gt; HasFailures = HasFailures</span>
<span class="lineno"> 3580 </span><span class="spaces">  </span><span class="nottickedoff">NoFailures &lt;&gt; NoFailures = NoFailures</span></span>
<span class="lineno"> 3581 </span>
<span class="lineno"> 3582 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monoid HasFailures</span></span></span></span> where
<span class="lineno"> 3583 </span>  <span class="decl"><span class="nottickedoff">mempty = NoFailures</span></span>
<span class="lineno"> 3584 </span>
<span class="lineno"> 3585 </span>-- | A function for translating an @r@
<span class="lineno"> 3586 </span>newtype ImpRTransFun r ext blocks tops rets ctx =
<span class="lineno"> 3587 </span>  ImpRTransFun { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">appImpTransFun</span></span></span> ::
<span class="lineno"> 3588 </span>                   forall ps ctx'. CtxExt ctx ctx' -&gt; Mb ctx' (r ps) -&gt;
<span class="lineno"> 3589 </span>                   ImpTransM ext blocks tops rets ps ctx' OpenTerm }
<span class="lineno"> 3590 </span>
<span class="lineno"> 3591 </span>extImpRTransFun :: RAssign Proxy ctx' -&gt;
<span class="lineno"> 3592 </span>                   ImpRTransFun r ext blocks tops rets ctx -&gt;
<span class="lineno"> 3593 </span>                   ImpRTransFun r ext blocks tops rets (ctx :++: ctx')
<span class="lineno"> 3594 </span><span class="decl"><span class="nottickedoff">extImpRTransFun ctx' f =</span>
<span class="lineno"> 3595 </span><span class="spaces">  </span><span class="nottickedoff">ImpRTransFun $ \cext mb_r -&gt;</span>
<span class="lineno"> 3596 </span><span class="spaces">  </span><span class="nottickedoff">appImpTransFun f (extCtxExt Proxy ctx' cext) mb_r</span></span>
<span class="lineno"> 3597 </span>
<span class="lineno"> 3598 </span>
<span class="lineno"> 3599 </span>-- | A monad transformer that adds an 'ImpRTransFun' translation function
<span class="lineno"> 3600 </span>newtype ImpRTransFunT r ext blocks tops rets ctx m a =
<span class="lineno"> 3601 </span>  ImpRTransFunT { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unImpRTransFunT</span></span></span> ::
<span class="lineno"> 3602 </span>                    ReaderT (ImpRTransFun r ext blocks tops rets ctx) m a }
<span class="lineno"> 3603 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">MonadTrans</span></span>)
<span class="lineno"> 3604 </span>
<span class="lineno"> 3605 </span>-- | Run an 'ImpRTransFunT' computation to get an underlying computation in @m@
<span class="lineno"> 3606 </span>runImpRTransFunT :: ImpRTransFunT r ext blocks tops rets ctx m a -&gt;
<span class="lineno"> 3607 </span>                    ImpRTransFun r ext blocks tops rets ctx -&gt; m a
<span class="lineno"> 3608 </span><span class="decl"><span class="nottickedoff">runImpRTransFunT m = runReaderT (unImpRTransFunT m)</span></span>
<span class="lineno"> 3609 </span>
<span class="lineno"> 3610 </span>-- | Map the underlying computation type of an 'ImpRTransFunT'
<span class="lineno"> 3611 </span>mapImpRTransFunT :: (m a -&gt; n b) -&gt;
<span class="lineno"> 3612 </span>                    ImpRTransFunT r ext blocks tops rets ctx m a -&gt;
<span class="lineno"> 3613 </span>                    ImpRTransFunT r ext blocks tops rets ctx n b
<span class="lineno"> 3614 </span><span class="decl"><span class="nottickedoff">mapImpRTransFunT f = ImpRTransFunT . mapReaderT f . unImpRTransFunT</span></span>
<span class="lineno"> 3615 </span>
<span class="lineno"> 3616 </span>-- | The computation type for translation permission implications, which
<span class="lineno"> 3617 </span>-- includes the following effects: a 'MaybeT' for representing terms that
<span class="lineno"> 3618 </span>-- translate to errors using 'Nothing'; a 'WriterT' that tracks all the error
<span class="lineno"> 3619 </span>-- messages used in translating a term along with a 'HasFailures' flag that
<span class="lineno"> 3620 </span>-- indicates whether the returned 'PImplTerm' uses its failure continuation; and
<span class="lineno"> 3621 </span>-- an 'ImpRTransFunT' to pass along a function for translating the final @r@
<span class="lineno"> 3622 </span>-- result inside the current 'PermImpl'
<span class="lineno"> 3623 </span>type PImplTransM r ext blocks tops rets ctx =
<span class="lineno"> 3624 </span>  MaybeT (WriterT ([String], HasFailures)
<span class="lineno"> 3625 </span>          (ImpRTransFunT r ext blocks tops rets ctx Identity))
<span class="lineno"> 3626 </span>
<span class="lineno"> 3627 </span>-- | Run a 'PermImplTransM' computation
<span class="lineno"> 3628 </span>runPermImplTransM ::
<span class="lineno"> 3629 </span>  PImplTransM r ext blocks tops rets ctx a -&gt;
<span class="lineno"> 3630 </span>  ImpRTransFun r ext blocks tops rets ctx -&gt;
<span class="lineno"> 3631 </span>  (Maybe a, ([String], HasFailures))
<span class="lineno"> 3632 </span><span class="decl"><span class="nottickedoff">runPermImplTransM m rTransFun =</span>
<span class="lineno"> 3633 </span><span class="spaces">  </span><span class="nottickedoff">runIdentity $ runImpRTransFunT (runWriterT $ runMaybeT m) rTransFun</span></span>
<span class="lineno"> 3634 </span>
<span class="lineno"> 3635 </span>extPermImplTransM :: RAssign Proxy ctx' -&gt;
<span class="lineno"> 3636 </span>                     PImplTransM r ext blocks tops rets (ctx :++: ctx') a -&gt;
<span class="lineno"> 3637 </span>                     PImplTransM r ext blocks tops rets ctx a
<span class="lineno"> 3638 </span><span class="decl"><span class="nottickedoff">extPermImplTransM ctx' m =</span>
<span class="lineno"> 3639 </span><span class="spaces">  </span><span class="nottickedoff">pimplRTransFunM &gt;&gt;= \rtransFun -&gt;</span>
<span class="lineno"> 3640 </span><span class="spaces">  </span><span class="nottickedoff">MaybeT $ WriterT $ return $ runPermImplTransM m $ extImpRTransFun ctx' rtransFun</span></span>
<span class="lineno"> 3641 </span>
<span class="lineno"> 3642 </span>{-
<span class="lineno"> 3643 </span>extPermImplTransM :: ExprTransCtx ctx' -&gt;
<span class="lineno"> 3644 </span>                     PImplTransM r ext blocks tops rets ps (ctx :++: ctx') a -&gt;
<span class="lineno"> 3645 </span>                     PImplTransM r ext blocks tops rets ps ctx a
<span class="lineno"> 3646 </span>extPermImplTransM ctx' m =
<span class="lineno"> 3647 </span>  pimplRTransFunM &gt;&gt;= \rtransFun -&gt;
<span class="lineno"> 3648 </span>  MaybeT $ WriterT $ return $ runPermImplTransM m $ extImpRTransFun ctx' rtransFun
<span class="lineno"> 3649 </span>
<span class="lineno"> 3650 </span>extPermImplTransMTerm :: CruCtx ctx' -&gt;
<span class="lineno"> 3651 </span>                         PImplTransMTerm r ext blocks tops rets ps (ctx :++: ctx') -&gt;
<span class="lineno"> 3652 </span>                         PImplTransMTerm r ext blocks tops rets ps ctx
<span class="lineno"> 3653 </span>extPermImplTransMTerm ctx' m =
<span class="lineno"> 3654 </span>  MaybeT $ WriterT $ ImpRTransFun $ reader $ \rtransFun -&gt; PImplTerm $ \k -&gt;
<span class="lineno"> 3655 </span>  TransM $ reader $ \info -&gt;
<span class="lineno"> 3656 </span>  let ectx' = runTransM (translateClosed ctx') info in
<span class="lineno"> 3657 </span>  return $ runPermImplTransM m $ extImpRTransFun ectx' rtransFun
<span class="lineno"> 3658 </span>-}
<span class="lineno"> 3659 </span>
<span class="lineno"> 3660 </span>-- | Look up the @r@ translation function
<span class="lineno"> 3661 </span>pimplRTransFunM :: PImplTransM r ext blocks tops rets ctx
<span class="lineno"> 3662 </span>                   (ImpRTransFun r ext blocks tops rets ctx)
<span class="lineno"> 3663 </span><span class="decl"><span class="nottickedoff">pimplRTransFunM = lift $ lift $ ImpRTransFunT ask</span></span>
<span class="lineno"> 3664 </span>
<span class="lineno"> 3665 </span>-- | Build an error term by recording the error message and returning 'Nothing'
<span class="lineno"> 3666 </span>pimplFailM :: String -&gt; PImplTransM r ext blocks tops rets ctx a
<span class="lineno"> 3667 </span><span class="decl"><span class="nottickedoff">pimplFailM msg = tell ([msg],HasFailures) &gt;&gt; mzero</span></span>
<span class="lineno"> 3668 </span>
<span class="lineno"> 3669 </span>-- | Catch a potential 'Nothing' return value in a 'PImplTransM' computation
<span class="lineno"> 3670 </span>pimplCatchM :: PImplTransM r ext blocks tops rets ctx a -&gt;
<span class="lineno"> 3671 </span>               PImplTransM r ext blocks tops rets ctx (Maybe a)
<span class="lineno"> 3672 </span><span class="decl"><span class="nottickedoff">pimplCatchM m = lift $ runMaybeT m</span></span>
<span class="lineno"> 3673 </span>
<span class="lineno"> 3674 </span>-- | Prepend a 'String' to all error messages generated in a computation
<span class="lineno"> 3675 </span>pimplPrependMsgM :: String -&gt; PImplTransM r ext blocks tops rets ctx a -&gt;
<span class="lineno"> 3676 </span>                    PImplTransM r ext blocks tops rets ctx a
<span class="lineno"> 3677 </span><span class="decl"><span class="nottickedoff">pimplPrependMsgM str m =</span>
<span class="lineno"> 3678 </span><span class="spaces">  </span><span class="nottickedoff">pass ((, (\(msgs, hasfs) -&gt; (map (str++) msgs, hasfs))) &lt;$&gt; m)</span></span>
<span class="lineno"> 3679 </span>
<span class="lineno"> 3680 </span>type PImplTransMTerm r ext blocks tops rets ps ctx =
<span class="lineno"> 3681 </span>  PImplTransM r ext blocks tops rets ctx
<span class="lineno"> 3682 </span>  (PImplTerm ext blocks tops rets ps ctx)
<span class="lineno"> 3683 </span>
<span class="lineno"> 3684 </span>-- | Run the first 'PImplTransM' computation to produce a 'PImplTerm' and use
<span class="lineno"> 3685 </span>-- the second computation to generate the failure continuation of that first
<span class="lineno"> 3686 </span>-- 'PImplTerm', using optimizations to omit the first or second term when it is
<span class="lineno"> 3687 </span>-- not needed.
<span class="lineno"> 3688 </span>pimplHandleFailM :: PImplTransMTerm r ext blocks tops rets ps ctx -&gt;
<span class="lineno"> 3689 </span>                    PImplTransMTerm r ext blocks tops rets ps ctx -&gt;
<span class="lineno"> 3690 </span>                    PImplTransMTerm r ext blocks tops rets ps ctx
<span class="lineno"> 3691 </span><span class="decl"><span class="nottickedoff">pimplHandleFailM m m_catch =</span>
<span class="lineno"> 3692 </span><span class="spaces">  </span><span class="nottickedoff">do</span>
<span class="lineno"> 3693 </span><span class="spaces">    </span><span class="nottickedoff">-- Run the default computation m, exposing whether it returned a term or not</span>
<span class="lineno"> 3694 </span><span class="spaces">    </span><span class="nottickedoff">-- and whether it calls the failure continuation or not</span>
<span class="lineno"> 3695 </span><span class="spaces">     </span><span class="nottickedoff">(maybe_t, (fails,hasf)) &lt;- lift $ lift $ runWriterT $ runMaybeT m</span>
<span class="lineno"> 3696 </span><span class="spaces">     </span><span class="nottickedoff">-- We want to retain all failure messages from m, but we are handling any</span>
<span class="lineno"> 3697 </span><span class="spaces">     </span><span class="nottickedoff">-- calls to the failure continuation, so we are NoFailures for now</span>
<span class="lineno"> 3698 </span><span class="spaces">     </span><span class="nottickedoff">tell (fails, NoFailures)</span>
<span class="lineno"> 3699 </span><span class="spaces">     </span><span class="nottickedoff">case (maybe_t, hasf) of</span>
<span class="lineno"> 3700 </span><span class="spaces">       </span><span class="nottickedoff">(Just t, NoFailures) -&gt;</span>
<span class="lineno"> 3701 </span><span class="spaces">         </span><span class="nottickedoff">-- If t does not call the failure continuation, then we have no need to</span>
<span class="lineno"> 3702 </span><span class="spaces">         </span><span class="nottickedoff">-- use m_catch, and we just return t</span>
<span class="lineno"> 3703 </span><span class="spaces">         </span><span class="nottickedoff">return t</span>
<span class="lineno"> 3704 </span><span class="spaces">       </span><span class="nottickedoff">(Just t, HasFailures) -&gt;</span>
<span class="lineno"> 3705 </span><span class="spaces">         </span><span class="nottickedoff">-- If t does potentially call the failure continuation, then let-bind</span>
<span class="lineno"> 3706 </span><span class="spaces">         </span><span class="nottickedoff">-- the result of m_catch as its failure continuation; note that we</span>
<span class="lineno"> 3707 </span><span class="spaces">         </span><span class="nottickedoff">-- preserve any MaybeT and WriterT effects of m_catch, meaning that its</span>
<span class="lineno"> 3708 </span><span class="spaces">         </span><span class="nottickedoff">-- failure messages and HasFailures flag are preserved, and if it</span>
<span class="lineno"> 3709 </span><span class="spaces">         </span><span class="nottickedoff">-- returns Nothing then so will this entire computation</span>
<span class="lineno"> 3710 </span><span class="spaces">         </span><span class="nottickedoff">do maybe_t_catch &lt;- lift $ runMaybeT m_catch</span>
<span class="lineno"> 3711 </span><span class="spaces">            </span><span class="nottickedoff">case maybe_t_catch of</span>
<span class="lineno"> 3712 </span><span class="spaces">              </span><span class="nottickedoff">Just t_catch -&gt; return $ catchPImplTerm t t_catch</span>
<span class="lineno"> 3713 </span><span class="spaces">              </span><span class="nottickedoff">Nothing -&gt; return t</span>
<span class="lineno"> 3714 </span><span class="spaces">       </span><span class="nottickedoff">(Nothing, _) -&gt;</span>
<span class="lineno"> 3715 </span><span class="spaces">         </span><span class="nottickedoff">-- If t definitely fails, then just use m_catch</span>
<span class="lineno"> 3716 </span><span class="spaces">         </span><span class="nottickedoff">m_catch</span></span>
<span class="lineno"> 3717 </span>
<span class="lineno"> 3718 </span>
<span class="lineno"> 3719 </span>-- | Translate the output permissions of a 'SimplImpl'
<span class="lineno"> 3720 </span>translateSimplImplOut :: Mb ctx (SimplImpl ps_in ps_out) -&gt;
<span class="lineno"> 3721 </span>                         ImpTransM ext blocks tops rets ps ctx
<span class="lineno"> 3722 </span>                         (TypeTrans (PermTransCtx ctx ps_out))
<span class="lineno"> 3723 </span><span class="decl"><span class="nottickedoff">translateSimplImplOut = translate . mbSimplImplOut</span></span>
<span class="lineno"> 3724 </span>
<span class="lineno"> 3725 </span>-- | Translate the head output permission of a 'SimplImpl'
<span class="lineno"> 3726 </span>translateSimplImplOutHead :: Mb ctx (SimplImpl ps_in (ps_out :&gt; a)) -&gt;
<span class="lineno"> 3727 </span>                             ImpTransM ext blocks tops rets ps ctx
<span class="lineno"> 3728 </span>                             (TypeTrans (PermTrans ctx a))
<span class="lineno"> 3729 </span><span class="decl"><span class="nottickedoff">translateSimplImplOutHead =</span>
<span class="lineno"> 3730 </span><span class="spaces">  </span><span class="nottickedoff">translate . mbMapCl $(mkClosed [| varAndPermPerm . RL.head |]) . mbSimplImplOut</span></span>
<span class="lineno"> 3731 </span>
<span class="lineno"> 3732 </span>-- | Translate the head of the tail of the output permission of a 'SimplImpl'
<span class="lineno"> 3733 </span>translateSimplImplOutTailHead :: Mb ctx (SimplImpl ps_in (ps_out :&gt; a :&gt; b)) -&gt;
<span class="lineno"> 3734 </span>                                 ImpTransM ext blocks tops rets ps ctx
<span class="lineno"> 3735 </span>                                 (TypeTrans (PermTrans ctx a))
<span class="lineno"> 3736 </span><span class="decl"><span class="nottickedoff">translateSimplImplOutTailHead =</span>
<span class="lineno"> 3737 </span><span class="spaces">  </span><span class="nottickedoff">translate . mbMapCl $(mkClosed [| varAndPermPerm . RL.head . RL.tail |])</span>
<span class="lineno"> 3738 </span><span class="spaces">  </span><span class="nottickedoff">. mbSimplImplOut</span></span>
<span class="lineno"> 3739 </span>
<span class="lineno"> 3740 </span>-- | Translate a 'SimplImpl' to a function on translation computations
<span class="lineno"> 3741 </span>translateSimplImpl ::
<span class="lineno"> 3742 </span>  Proxy ps -&gt; Mb ctx (SimplImpl ps_in ps_out) -&gt;
<span class="lineno"> 3743 </span>  ImpTransM ext blocks tops rets (ps :++: ps_out) ctx OpenTerm -&gt;
<span class="lineno"> 3744 </span>  ImpTransM ext blocks tops rets (ps :++: ps_in) ctx OpenTerm
<span class="lineno"> 3745 </span><span class="decl"><span class="nottickedoff">translateSimplImpl (ps0 :: Proxy ps0) mb_simpl m = case mbMatch mb_simpl of</span>
<span class="lineno"> 3746 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_Drop _ _ |] -&gt;</span>
<span class="lineno"> 3747 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (\(xs :&gt;: _) -&gt; xs) (\(ps :&gt;: _) -&gt; ps) m</span>
<span class="lineno"> 3748 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3749 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_Copy x _ |] -&gt;</span>
<span class="lineno"> 3750 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x) (\(ps :&gt;: p) -&gt; ps :&gt;: p :&gt;: p) m</span>
<span class="lineno"> 3751 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3752 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_Swap _ _ _ _ |] -&gt;</span>
<span class="lineno"> 3753 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (\(xs :&gt;: x :&gt;: y) -&gt; xs :&gt;: y :&gt;: x)</span>
<span class="lineno"> 3754 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: px :&gt;: py) -&gt; pctx :&gt;: py :&gt;: px)</span>
<span class="lineno"> 3755 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3756 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3757 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_MoveUp (mb_ps1 :: DistPerms ps1) (_mb_x :: ExprVar a) _</span>
<span class="lineno"> 3758 </span><span class="spaces">                      </span><span class="nottickedoff">(mb_ps2 :: DistPerms ps2) |] -&gt;</span>
<span class="lineno"> 3759 </span><span class="spaces">    </span><span class="nottickedoff">let ps1 = mbRAssignProxies mb_ps1</span>
<span class="lineno"> 3760 </span><span class="spaces">        </span><span class="nottickedoff">ps2 = mbRAssignProxies mb_ps2</span>
<span class="lineno"> 3761 </span><span class="spaces">        </span><span class="nottickedoff">prxa = Proxy :: Proxy a</span>
<span class="lineno"> 3762 </span><span class="spaces">        </span><span class="nottickedoff">prx0a = Proxy :: Proxy (ps0 :&gt; a) in</span>
<span class="lineno"> 3763 </span><span class="spaces">    </span><span class="nottickedoff">case (RL.appendRNilConsEq ps0 prxa (RL.append ps1 ps2)) of</span>
<span class="lineno"> 3764 </span><span class="spaces">      </span><span class="nottickedoff">Refl -&gt;</span>
<span class="lineno"> 3765 </span><span class="spaces">        </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 3766 </span><span class="spaces">        </span><span class="nottickedoff">(\xs -&gt;</span>
<span class="lineno"> 3767 </span><span class="spaces">          </span><span class="nottickedoff">let ((xs0 :&gt;: x), xs12) = RL.split prx0a (RL.append ps1 ps2) xs</span>
<span class="lineno"> 3768 </span><span class="spaces">              </span><span class="nottickedoff">(xs1, xs2) = RL.split ps1 ps2 xs12 in</span>
<span class="lineno"> 3769 </span><span class="spaces">          </span><span class="nottickedoff">RL.append xs0 $ RL.append (xs1 :&gt;: x) xs2)</span>
<span class="lineno"> 3770 </span><span class="spaces">        </span><span class="nottickedoff">(\pctx -&gt;</span>
<span class="lineno"> 3771 </span><span class="spaces">          </span><span class="nottickedoff">let ((pctx0 :&gt;: ptrans), pctx12) =</span>
<span class="lineno"> 3772 </span><span class="spaces">                </span><span class="nottickedoff">RL.split prx0a (RL.append ps1 ps2) pctx</span>
<span class="lineno"> 3773 </span><span class="spaces">              </span><span class="nottickedoff">(pctx1, pctx2) = RL.split ps1 ps2 pctx12 in</span>
<span class="lineno"> 3774 </span><span class="spaces">          </span><span class="nottickedoff">RL.append pctx0 $ RL.append (pctx1 :&gt;: ptrans) pctx2)</span>
<span class="lineno"> 3775 </span><span class="spaces">        </span><span class="nottickedoff">m</span>
<span class="lineno"> 3776 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3777 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_MoveDown mb_ps1 (mb_x :: ExprVar a) _ mb_ps2 |]</span>
<span class="lineno"> 3778 </span><span class="spaces">    </span><span class="nottickedoff">| prx_a &lt;- mbLift $ fmap (const (Proxy :: Proxy a)) mb_x</span>
<span class="lineno"> 3779 </span><span class="spaces">    </span><span class="nottickedoff">, ps1 &lt;- mbRAssignProxies mb_ps1</span>
<span class="lineno"> 3780 </span><span class="spaces">    </span><span class="nottickedoff">, ps1a &lt;- ps1 :&gt;: prx_a</span>
<span class="lineno"> 3781 </span><span class="spaces">    </span><span class="nottickedoff">, ps2 &lt;- mbRAssignProxies mb_ps2</span>
<span class="lineno"> 3782 </span><span class="spaces">    </span><span class="nottickedoff">, Refl &lt;- RL.appendRNilConsEq ps0 prx_a (RL.append ps1 ps2) -&gt;</span>
<span class="lineno"> 3783 </span><span class="spaces">      </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 3784 </span><span class="spaces">      </span><span class="nottickedoff">(\xs -&gt;</span>
<span class="lineno"> 3785 </span><span class="spaces">        </span><span class="nottickedoff">let (xs0, xs1a2) = RL.split ps0 (RL.append ps1a ps2) xs</span>
<span class="lineno"> 3786 </span><span class="spaces">            </span><span class="nottickedoff">((xs1 :&gt;: x), xs2) = RL.split ps1a ps2 xs1a2 in</span>
<span class="lineno"> 3787 </span><span class="spaces">        </span><span class="nottickedoff">RL.append xs0 (RL.append (MNil :&gt;: x) $ RL.append xs1 xs2))</span>
<span class="lineno"> 3788 </span><span class="spaces">      </span><span class="nottickedoff">(\pctx -&gt;</span>
<span class="lineno"> 3789 </span><span class="spaces">        </span><span class="nottickedoff">let (pctx0, pctx1a2) = RL.split ps0 (RL.append ps1a ps2) pctx</span>
<span class="lineno"> 3790 </span><span class="spaces">            </span><span class="nottickedoff">((pctx1 :&gt;: ptrans), pctx2) = RL.split ps1a ps2 pctx1a2 in</span>
<span class="lineno"> 3791 </span><span class="spaces">        </span><span class="nottickedoff">RL.append pctx0 (RL.append (MNil :&gt;: ptrans) $ RL.append pctx1 pctx2))</span>
<span class="lineno"> 3792 </span><span class="spaces">      </span><span class="nottickedoff">m</span>
<span class="lineno"> 3793 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3794 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroOrL _ p1 p2 |] -&gt;</span>
<span class="lineno"> 3795 </span><span class="spaces">    </span><span class="nottickedoff">do tp1 &lt;- translate p1</span>
<span class="lineno"> 3796 </span><span class="spaces">       </span><span class="nottickedoff">tp2 &lt;- translate p2</span>
<span class="lineno"> 3797 </span><span class="spaces">       </span><span class="nottickedoff">tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3798 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 3799 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (ps :&gt;: _p_top) -&gt;</span>
<span class="lineno"> 3800 </span><span class="spaces">           </span><span class="nottickedoff">ps :&gt;: typeTransF tptrans [leftTrans tp1 tp2 (tupleOpenTerm' ts)])</span>
<span class="lineno"> 3801 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3802 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3803 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroOrR _ p1 p2 |] -&gt;</span>
<span class="lineno"> 3804 </span><span class="spaces">    </span><span class="nottickedoff">do tp1 &lt;- translate p1</span>
<span class="lineno"> 3805 </span><span class="spaces">       </span><span class="nottickedoff">tp2 &lt;- translate p2</span>
<span class="lineno"> 3806 </span><span class="spaces">       </span><span class="nottickedoff">tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3807 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 3808 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (ps :&gt;: _p_top) -&gt;</span>
<span class="lineno"> 3809 </span><span class="spaces">           </span><span class="nottickedoff">ps :&gt;: typeTransF tptrans [rightTrans tp1 tp2 (tupleOpenTerm' ts)])</span>
<span class="lineno"> 3810 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3811 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3812 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroExists _ e p |] -&gt;</span>
<span class="lineno"> 3813 </span><span class="spaces">    </span><span class="nottickedoff">do let tp = mbExprType e</span>
<span class="lineno"> 3814 </span><span class="spaces">       </span><span class="nottickedoff">tp_trans &lt;- translateClosed tp</span>
<span class="lineno"> 3815 </span><span class="spaces">       </span><span class="nottickedoff">out_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3816 </span><span class="spaces">       </span><span class="nottickedoff">etrans &lt;- translate e</span>
<span class="lineno"> 3817 </span><span class="spaces">       </span><span class="nottickedoff">trm &lt;-</span>
<span class="lineno"> 3818 </span><span class="spaces">         </span><span class="nottickedoff">sigmaPermTransM &quot;x_ex&quot; tp_trans (mbCombine RL.typeCtxProxies p)</span>
<span class="lineno"> 3819 </span><span class="spaces">         </span><span class="nottickedoff">etrans getTopPermM</span>
<span class="lineno"> 3820 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 3821 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF out_trans [trm])</span>
<span class="lineno"> 3822 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3823 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3824 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_Cast _ _ _ |] -&gt;</span>
<span class="lineno"> 3825 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3826 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: ptrans) -&gt; pctx :&gt;: ptrans)</span>
<span class="lineno"> 3827 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3828 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3829 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CastPerm (_::ExprVar a) eqp |] -&gt;</span>
<span class="lineno"> 3830 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOut mb_simpl</span>
<span class="lineno"> 3831 </span><span class="spaces">       </span><span class="nottickedoff">let prxs_a = MNil :&gt;: (Proxy :: Proxy a)</span>
<span class="lineno"> 3832 </span><span class="spaces">       </span><span class="nottickedoff">let prxs1 = mbLift $ mbMapCl $(mkClosed [| distPermsToProxies</span>
<span class="lineno"> 3833 </span><span class="spaces">                                                </span><span class="nottickedoff">. eqProofPerms |]) eqp</span>
<span class="lineno"> 3834 </span><span class="spaces">       </span><span class="nottickedoff">let prxs = RL.append prxs_a prxs1</span>
<span class="lineno"> 3835 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM</span>
<span class="lineno"> 3836 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; snd $ RL.split ps0 prxs pctx)</span>
<span class="lineno"> 3837 </span><span class="spaces">         </span><span class="nottickedoff">id</span>
<span class="lineno"> 3838 </span><span class="spaces">         </span><span class="nottickedoff">(\ts pctx -&gt;</span>
<span class="lineno"> 3839 </span><span class="spaces">           </span><span class="nottickedoff">let pctx1 = fst $ RL.split ps0 prxs pctx in</span>
<span class="lineno"> 3840 </span><span class="spaces">           </span><span class="nottickedoff">RL.append pctx1 (typeTransF ttrans ts))</span>
<span class="lineno"> 3841 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3842 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3843 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroEqRefl x |] -&gt;</span>
<span class="lineno"> 3844 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3845 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3846 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; pctx :&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 3847 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3848 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_InvertEq _ y |] -&gt;</span>
<span class="lineno"> 3849 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3850 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM ((:&gt;: translateVar y) . RL.tail)</span>
<span class="lineno"> 3851 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 3852 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3853 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_InvTransEq _ _ _ |] -&gt;</span>
<span class="lineno"> 3854 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3855 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3856 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 3857 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3858 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_UnitEq x _ |] -&gt;</span>
<span class="lineno"> 3859 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3860 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3861 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; pctx :&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 3862 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3863 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3864 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CopyEq _ _ |] -&gt;</span>
<span class="lineno"> 3865 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 3866 </span><span class="spaces">    </span><span class="nottickedoff">(\(vars :&gt;: var) -&gt; (vars :&gt;: var :&gt;: var))</span>
<span class="lineno"> 3867 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans) -&gt; (pctx :&gt;: ptrans :&gt;: ptrans))</span>
<span class="lineno"> 3868 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3869 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3870 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMWordEq _ _ _ |] -&gt;</span>
<span class="lineno"> 3871 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3872 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail (\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 3873 </span><span class="spaces">                                </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 3874 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3875 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMOffsetZeroEq x |] -&gt;</span>
<span class="lineno"> 3876 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3877 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3878 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; pctx :&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 3879 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3880 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroConj x |] -&gt;</span>
<span class="lineno"> 3881 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x) (:&gt;: PTrans_True) m</span>
<span class="lineno"> 3882 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3883 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ExtractConj x _ mb_i |] -&gt;</span>
<span class="lineno"> 3884 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3885 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 3886 </span><span class="spaces">      </span><span class="nottickedoff">let ps = unPTransConj &quot;translateSimplImpl: SImpl_ExtractConj&quot; ptrans</span>
<span class="lineno"> 3887 </span><span class="spaces">          </span><span class="nottickedoff">i = mbLift mb_i in</span>
<span class="lineno"> 3888 </span><span class="spaces">      </span><span class="nottickedoff">if i &lt; length ps then</span>
<span class="lineno"> 3889 </span><span class="spaces">        </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [ps !! i]</span>
<span class="lineno"> 3890 </span><span class="spaces">        </span><span class="nottickedoff">:&gt;: PTrans_Conj (deleteNth i ps)</span>
<span class="lineno"> 3891 </span><span class="spaces">      </span><span class="nottickedoff">else</span>
<span class="lineno"> 3892 </span><span class="spaces">        </span><span class="nottickedoff">error &quot;translateSimplImpl: SImpl_ExtractConj: index out of bounds&quot;)</span>
<span class="lineno"> 3893 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3894 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3895 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CopyConj x _ mb_i |] -&gt;</span>
<span class="lineno"> 3896 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3897 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 3898 </span><span class="spaces">      </span><span class="nottickedoff">let ps = unPTransConj &quot;translateSimplImpl: SImpl_CopyConj&quot; ptrans</span>
<span class="lineno"> 3899 </span><span class="spaces">          </span><span class="nottickedoff">i = mbLift mb_i in</span>
<span class="lineno"> 3900 </span><span class="spaces">      </span><span class="nottickedoff">if i &lt; length ps then pctx :&gt;: PTrans_Conj [ps !! i] :&gt;: ptrans else</span>
<span class="lineno"> 3901 </span><span class="spaces">        </span><span class="nottickedoff">error &quot;translateSimplImpl: SImpl_CopyConj: index out of bounds&quot;)</span>
<span class="lineno"> 3902 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3903 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3904 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_InsertConj _ _ _ i |] -&gt;</span>
<span class="lineno"> 3905 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3906 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptransi :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 3907 </span><span class="spaces">      </span><span class="nottickedoff">let ps = unPTransConj &quot;translateSimplImpl: SImpl_InsertConj&quot; ptrans</span>
<span class="lineno"> 3908 </span><span class="spaces">          </span><span class="nottickedoff">pi = unPTransConj1 &quot;translateSimplImpl: SImpl_InsertConj&quot; ptransi in</span>
<span class="lineno"> 3909 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj (take (mbLift i) ps ++ pi : drop (mbLift i) ps))</span>
<span class="lineno"> 3910 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3911 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3912 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_AppendConjs _ _ _ |] -&gt;</span>
<span class="lineno"> 3913 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3914 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans1 :&gt;: ptrans2) -&gt;</span>
<span class="lineno"> 3915 </span><span class="spaces">      </span><span class="nottickedoff">let ps1 = unPTransConj &quot;translateSimplImpl: SImpl_AppendConjs&quot; ptrans1</span>
<span class="lineno"> 3916 </span><span class="spaces">          </span><span class="nottickedoff">ps2 = unPTransConj &quot;translateSimplImpl: SImpl_AppendConjs&quot; ptrans2 in</span>
<span class="lineno"> 3917 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj (ps1 ++ ps2))</span>
<span class="lineno"> 3918 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3919 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3920 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_SplitConjs x _ mb_i |] -&gt;</span>
<span class="lineno"> 3921 </span><span class="spaces">    </span><span class="nottickedoff">let i = mbLift mb_i in</span>
<span class="lineno"> 3922 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3923 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 3924 </span><span class="spaces">      </span><span class="nottickedoff">let ps = unPTransConj &quot;translateSimplImpl: SImpl_SplitConjs&quot; ptrans in</span>
<span class="lineno"> 3925 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj (take i ps) :&gt;: PTrans_Conj (drop i ps))</span>
<span class="lineno"> 3926 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3927 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3928 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroStructTrue x _ |] -&gt;</span>
<span class="lineno"> 3929 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3930 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 3931 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; pctx :&gt;: typeTransF tptrans [])</span>
<span class="lineno"> 3932 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3933 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3934 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_StructEqToPerm _ _ |] -&gt;</span>
<span class="lineno"> 3935 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3936 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 3937 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF tptrans [])</span>
<span class="lineno"> 3938 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3939 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3940 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_StructPermToEq _ _ |] -&gt;</span>
<span class="lineno"> 3941 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3942 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 3943 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF tptrans [])</span>
<span class="lineno"> 3944 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3945 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3946 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroStructField _ _ memb _ |] -&gt;</span>
<span class="lineno"> 3947 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3948 </span><span class="spaces">    </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 3949 </span><span class="spaces">        </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_Struct pctx_str] :&gt;: ptrans -&gt;</span>
<span class="lineno"> 3950 </span><span class="spaces">          </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_Struct $</span>
<span class="lineno"> 3951 </span><span class="spaces">                                </span><span class="nottickedoff">RL.set (mbLift memb) ptrans pctx_str]</span>
<span class="lineno"> 3952 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 3953 </span><span class="spaces">          </span><span class="nottickedoff">[&quot;SImpl_IntroStructField: Unexpected permission stack&quot;])</span>
<span class="lineno"> 3954 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3955 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3956 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ConstFunPerm _ _ _ ident |] -&gt;</span>
<span class="lineno"> 3957 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3958 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 3959 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 3960 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tptrans [globalOpenTerm $ mbLift ident])</span>
<span class="lineno"> 3961 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3962 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3963 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMWord _ _ _ |] -&gt;</span>
<span class="lineno"> 3964 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3965 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3966 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 3967 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tptrans [])</span>
<span class="lineno"> 3968 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3969 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3970 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_InvertLLVMOffsetEq _ _ mb_y |] -&gt;</span>
<span class="lineno"> 3971 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3972 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 3973 </span><span class="spaces">         </span><span class="nottickedoff">(\(vars :&gt;: _) -&gt; (vars :&gt;: translateVar mb_y))</span>
<span class="lineno"> 3974 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF tptrans [])</span>
<span class="lineno"> 3975 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3976 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3977 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_OffsetLLVMWord _ _ _ _ |] -&gt;</span>
<span class="lineno"> 3978 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3979 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 3980 </span><span class="spaces">         </span><span class="nottickedoff">(\(vars :&gt;: _ :&gt;: x_var) -&gt; vars :&gt;: x_var)</span>
<span class="lineno"> 3981 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt; pctx :&gt;: typeTransF tptrans [])</span>
<span class="lineno"> 3982 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3983 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3984 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMPtr _ _ _ _ |] -&gt;</span>
<span class="lineno"> 3985 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: offsetLLVMPerm can throw away conjuncts, like free and llvmfunptr</span>
<span class="lineno"> 3986 </span><span class="spaces">    </span><span class="nottickedoff">-- permissions, that change the type of the translation</span>
<span class="lineno"> 3987 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3988 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM RL.tail</span>
<span class="lineno"> 3989 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt; pctx :&gt;: typeTransF tptrans ts)</span>
<span class="lineno"> 3990 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 3991 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3992 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMFree _ _ e2 |] -&gt;</span>
<span class="lineno"> 3993 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 3994 </span><span class="spaces">    </span><span class="nottickedoff">((:&gt;: PTrans_Conj [APTrans_LLVMFree e2]) . RL.tail . RL.tail)</span>
<span class="lineno"> 3995 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 3996 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3997 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMFieldOffset _ _ _ |] -&gt;</span>
<span class="lineno"> 3998 </span><span class="spaces">    </span><span class="nottickedoff">do tptrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 3999 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM</span>
<span class="lineno"> 4000 </span><span class="spaces">         </span><span class="nottickedoff">(\(_ :&gt;: ptrans :&gt;: _) -&gt; ptrans)</span>
<span class="lineno"> 4001 </span><span class="spaces">         </span><span class="nottickedoff">RL.tail</span>
<span class="lineno"> 4002 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt; pctx :&gt;: typeTransF tptrans ts)</span>
<span class="lineno"> 4003 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4004 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4005 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMFieldContents x _ mb_fld |] -&gt;</span>
<span class="lineno"> 4006 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM ((:&gt;: translateVar x) . RL.tail . RL.tail)</span>
<span class="lineno"> 4007 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 4008 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_LLVMField mb_fld ptrans])</span>
<span class="lineno"> 4009 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 4010 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4011 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_DemoteLLVMFieldRW _ mb_fld |] -&gt;</span>
<span class="lineno"> 4012 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4013 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 4014 </span><span class="spaces">      </span><span class="nottickedoff">let (_,ptrans') =</span>
<span class="lineno"> 4015 </span><span class="spaces">            </span><span class="nottickedoff">unPTransLLVMField</span>
<span class="lineno"> 4016 </span><span class="spaces">            </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_DemoteLLVMFieldRW&quot;</span>
<span class="lineno"> 4017 </span><span class="spaces">            </span><span class="nottickedoff">knownNat ptrans in</span>
<span class="lineno"> 4018 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [</span>
<span class="lineno"> 4019 </span><span class="spaces">        </span><span class="nottickedoff">APTrans_LLVMField</span>
<span class="lineno"> 4020 </span><span class="spaces">        </span><span class="nottickedoff">(mbMapCl $(mkClosed [| \fld -&gt; fld { llvmFieldRW = PExpr_Read } |]) mb_fld)</span>
<span class="lineno"> 4021 </span><span class="spaces">        </span><span class="nottickedoff">ptrans'])</span>
<span class="lineno"> 4022 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 4023 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4024 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_SplitLLVMTrueField x _ _ _ |] -&gt;</span>
<span class="lineno"> 4025 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOut mb_simpl</span>
<span class="lineno"> 4026 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 4027 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; RL.append pctx $ typeTransF ttrans [])</span>
<span class="lineno"> 4028 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4029 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4030 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_TruncateLLVMTrueField _ _ _ |] -&gt;</span>
<span class="lineno"> 4031 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOut mb_simpl</span>
<span class="lineno"> 4032 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4033 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; RL.append pctx $ typeTransF ttrans [])</span>
<span class="lineno"> 4034 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4035 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4036 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ConcatLLVMTrueFields _ _ _ |] -&gt;</span>
<span class="lineno"> 4037 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOut mb_simpl</span>
<span class="lineno"> 4038 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 4039 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt; RL.append pctx $ typeTransF ttrans [])</span>
<span class="lineno"> 4040 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4041 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4042 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_DemoteLLVMArrayRW _ _ |] -&gt;</span>
<span class="lineno"> 4043 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4044 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4045 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4046 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4047 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4048 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCopy _ mb_ap _ _ |] -&gt;</span>
<span class="lineno"> 4049 </span><span class="spaces">    </span><span class="nottickedoff">do let mb_sub_ap =</span>
<span class="lineno"> 4050 </span><span class="spaces">             </span><span class="nottickedoff">case mbSimplImplOut mb_simpl of</span>
<span class="lineno"> 4051 </span><span class="spaces">               </span><span class="nottickedoff">[nuP| _ :&gt;: VarAndPerm _ (ValPerm_LLVMArray sub_ap) :&gt;: _ |] -&gt;</span>
<span class="lineno"> 4052 </span><span class="spaces">                 </span><span class="nottickedoff">sub_ap</span>
<span class="lineno"> 4053 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; error &quot;translateSimplImpl: SImpl_LLVMArrayCopy: unexpected perms&quot;</span>
<span class="lineno"> 4054 </span><span class="spaces">       </span><span class="nottickedoff">sub_ap_tp_trans &lt;- translate mb_sub_ap</span>
<span class="lineno"> 4055 </span><span class="spaces">       </span><span class="nottickedoff">rng_trans &lt;- translate $ mbMap2 llvmSubArrayRange mb_ap mb_sub_ap</span>
<span class="lineno"> 4056 </span><span class="spaces">       </span><span class="nottickedoff">-- let mb_sub_borrows = fmap llvmArrayBorrows mb_sub_ap</span>
<span class="lineno"> 4057 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4058 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: ptrans_array :&gt;: ptrans_props) -&gt;</span>
<span class="lineno"> 4059 </span><span class="spaces">           </span><span class="nottickedoff">let array_trans =</span>
<span class="lineno"> 4060 </span><span class="spaces">                 </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4061 </span><span class="spaces">                 </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCopy&quot; ptrans_array</span>
<span class="lineno"> 4062 </span><span class="spaces">               </span><span class="nottickedoff">prop_transs =</span>
<span class="lineno"> 4063 </span><span class="spaces">                 </span><span class="nottickedoff">unPTransBVProps</span>
<span class="lineno"> 4064 </span><span class="spaces">                 </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCopy&quot; ptrans_props in</span>
<span class="lineno"> 4065 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4066 </span><span class="spaces">           </span><span class="nottickedoff">PTrans_Conj [APTrans_LLVMArray $</span>
<span class="lineno"> 4067 </span><span class="spaces">                        </span><span class="nottickedoff">getLLVMArrayTransSlice array_trans sub_ap_tp_trans</span>
<span class="lineno"> 4068 </span><span class="spaces">                        </span><span class="nottickedoff">rng_trans {- mb_sub_borrows -} prop_transs]</span>
<span class="lineno"> 4069 </span><span class="spaces">           </span><span class="nottickedoff">:&gt;: ptrans_array)</span>
<span class="lineno"> 4070 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4071 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4072 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayBorrow _ mb_ap _ _ |] -&gt;</span>
<span class="lineno"> 4073 </span><span class="spaces">    </span><span class="nottickedoff">do let mb_sub_ap =</span>
<span class="lineno"> 4074 </span><span class="spaces">             </span><span class="nottickedoff">case mbSimplImplOut mb_simpl of</span>
<span class="lineno"> 4075 </span><span class="spaces">               </span><span class="nottickedoff">[nuP| _ :&gt;: VarAndPerm _ (ValPerm_LLVMArray sub_ap) :&gt;: _ |] -&gt;</span>
<span class="lineno"> 4076 </span><span class="spaces">                 </span><span class="nottickedoff">sub_ap</span>
<span class="lineno"> 4077 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; error &quot;translateSimplImpl: SImpl_LLVMArrayCopy: unexpected perms&quot;</span>
<span class="lineno"> 4078 </span><span class="spaces">       </span><span class="nottickedoff">sub_ap_tp_trans &lt;- translate mb_sub_ap</span>
<span class="lineno"> 4079 </span><span class="spaces">       </span><span class="nottickedoff">let mb_rng = mbMap2 llvmSubArrayRange mb_ap mb_sub_ap</span>
<span class="lineno"> 4080 </span><span class="spaces">       </span><span class="nottickedoff">rng_trans &lt;- translate mb_rng</span>
<span class="lineno"> 4081 </span><span class="spaces">       </span><span class="nottickedoff">-- let mb_sub_borrows = fmap llvmArrayBorrows mb_sub_ap</span>
<span class="lineno"> 4082 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4083 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: ptrans_array :&gt;: ptrans_props) -&gt;</span>
<span class="lineno"> 4084 </span><span class="spaces">           </span><span class="nottickedoff">let array_trans =</span>
<span class="lineno"> 4085 </span><span class="spaces">                 </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4086 </span><span class="spaces">                 </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayBorrow&quot; ptrans_array</span>
<span class="lineno"> 4087 </span><span class="spaces">               </span><span class="nottickedoff">prop_transs =</span>
<span class="lineno"> 4088 </span><span class="spaces">                 </span><span class="nottickedoff">unPTransBVProps</span>
<span class="lineno"> 4089 </span><span class="spaces">                 </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayBorrow&quot; ptrans_props</span>
<span class="lineno"> 4090 </span><span class="spaces">               </span><span class="nottickedoff">{- borrow_trans =</span>
<span class="lineno"> 4091 </span><span class="spaces">                 </span><span class="nottickedoff">LLVMArrayBorrowTrans (fmap RangeBorrow mb_rng) prop_transs -}</span>
<span class="lineno"> 4092 </span><span class="spaces">               </span><span class="nottickedoff">sub_array_trans =</span>
<span class="lineno"> 4093 </span><span class="spaces">                 </span><span class="nottickedoff">APTrans_LLVMArray $</span>
<span class="lineno"> 4094 </span><span class="spaces">                 </span><span class="nottickedoff">getLLVMArrayTransSlice array_trans sub_ap_tp_trans rng_trans</span>
<span class="lineno"> 4095 </span><span class="spaces">                 </span><span class="nottickedoff">{- mb_sub_borrows -} prop_transs</span>
<span class="lineno"> 4096 </span><span class="spaces">               </span><span class="nottickedoff">array_trans' =</span>
<span class="lineno"> 4097 </span><span class="spaces">                 </span><span class="nottickedoff">array_trans {</span>
<span class="lineno"> 4098 </span><span class="spaces">                 </span><span class="nottickedoff">llvmArrayTransPerm =</span>
<span class="lineno"> 4099 </span><span class="spaces">                     </span><span class="nottickedoff">mbMap2 (\ap sub_ap -&gt;</span>
<span class="lineno"> 4100 </span><span class="spaces">                              </span><span class="nottickedoff">llvmArrayAddBorrow (llvmSubArrayBorrow ap sub_ap) $</span>
<span class="lineno"> 4101 </span><span class="spaces">                              </span><span class="nottickedoff">llvmArrayRemArrayBorrows ap sub_ap)</span>
<span class="lineno"> 4102 </span><span class="spaces">                     </span><span class="nottickedoff">mb_ap mb_sub_ap } in</span>
<span class="lineno"> 4103 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4104 </span><span class="spaces">           </span><span class="nottickedoff">PTrans_Conj [sub_array_trans]</span>
<span class="lineno"> 4105 </span><span class="spaces">           </span><span class="nottickedoff">:&gt;: PTrans_Conj [APTrans_LLVMArray array_trans'])</span>
<span class="lineno"> 4106 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4107 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4108 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayReturn _ mb_ap mb_ret_ap |] -&gt;</span>
<span class="lineno"> 4109 </span><span class="spaces">    </span><span class="nottickedoff">do (_ :&gt;: ptrans_sub_array :&gt;: ptrans_array) &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4110 </span><span class="spaces">       </span><span class="nottickedoff">let mb_cell =</span>
<span class="lineno"> 4111 </span><span class="spaces">             </span><span class="nottickedoff">fmap fromJust $ mbMap2 llvmArrayIsOffsetArray mb_ap mb_ret_ap</span>
<span class="lineno"> 4112 </span><span class="spaces">       </span><span class="nottickedoff">cell_tm &lt;- translate1 mb_cell</span>
<span class="lineno"> 4113 </span><span class="spaces">       </span><span class="nottickedoff">let array_trans =</span>
<span class="lineno"> 4114 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4115 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayReturn&quot; ptrans_array</span>
<span class="lineno"> 4116 </span><span class="spaces">       </span><span class="nottickedoff">let sub_array_trans =</span>
<span class="lineno"> 4117 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4118 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayReturn&quot; ptrans_sub_array</span>
<span class="lineno"> 4119 </span><span class="spaces">           </span><span class="nottickedoff">{- borrow_i =</span>
<span class="lineno"> 4120 </span><span class="spaces">             </span><span class="nottickedoff">mbLift $ mbMap2 llvmArrayFindBorrow (fmap</span>
<span class="lineno"> 4121 </span><span class="spaces">                                                  </span><span class="nottickedoff">RangeBorrow mb_rng) mb_ap</span>
<span class="lineno"> 4122 </span><span class="spaces">           </span><span class="nottickedoff">borrow_trans = llvmArrayTransBorrows array_trans !! borrow_i -}</span>
<span class="lineno"> 4123 </span><span class="spaces">       </span><span class="nottickedoff">let array_trans' =</span>
<span class="lineno"> 4124 </span><span class="spaces">             </span><span class="nottickedoff">(setLLVMArrayTransSlice array_trans sub_array_trans cell_tm)</span>
<span class="lineno"> 4125 </span><span class="spaces">             </span><span class="nottickedoff">{ llvmArrayTransPerm =</span>
<span class="lineno"> 4126 </span><span class="spaces">                 </span><span class="nottickedoff">mbMap2 (\ap ret_ap -&gt;</span>
<span class="lineno"> 4127 </span><span class="spaces">                          </span><span class="nottickedoff">llvmArrayRemBorrow (llvmSubArrayBorrow ap ret_ap) $</span>
<span class="lineno"> 4128 </span><span class="spaces">                          </span><span class="nottickedoff">llvmArrayAddArrayBorrows ap ret_ap) mb_ap mb_ret_ap }</span>
<span class="lineno"> 4129 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 4130 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4131 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_LLVMArray array_trans'])</span>
<span class="lineno"> 4132 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4133 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4134 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayAppend _ mb_ap1 mb_ap2 |] -&gt;</span>
<span class="lineno"> 4135 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4136 </span><span class="spaces">       </span><span class="nottickedoff">(w_term, len1_tm, elem_tp, _) &lt;- translateLLVMArrayPerm mb_ap1</span>
<span class="lineno"> 4137 </span><span class="spaces">       </span><span class="nottickedoff">(_, len2_tm, _, _) &lt;- translateLLVMArrayPerm mb_ap2</span>
<span class="lineno"> 4138 </span><span class="spaces">       </span><span class="nottickedoff">tp_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4139 </span><span class="spaces">       </span><span class="nottickedoff">len3_tm &lt;-</span>
<span class="lineno"> 4140 </span><span class="spaces">         </span><span class="nottickedoff">translate1 $</span>
<span class="lineno"> 4141 </span><span class="spaces">         </span><span class="nottickedoff">fmap (\case</span>
<span class="lineno"> 4142 </span><span class="spaces">                  </span><span class="nottickedoff">(ValPerm_LLVMArray ap) -&gt; llvmArrayLen ap</span>
<span class="lineno"> 4143 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; error &quot;translateSimplImpl: SImpl_LLVMArrayAppend&quot;) $</span>
<span class="lineno"> 4144 </span><span class="spaces">         </span><span class="nottickedoff">fmap distPermsHeadPerm $ mbSimplImplOut mb_simpl</span>
<span class="lineno"> 4145 </span><span class="spaces">       </span><span class="nottickedoff">(_ :&gt;: ptrans1 :&gt;: ptrans2) &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4146 </span><span class="spaces">       </span><span class="nottickedoff">let arr_out_comp_tm =</span>
<span class="lineno"> 4147 </span><span class="spaces">             </span><span class="nottickedoff">applyGlobalOpenTerm &quot;SpecM.appendCastBVVecS&quot;</span>
<span class="lineno"> 4148 </span><span class="spaces">             </span><span class="nottickedoff">[evTypeTerm ev, w_term, len1_tm, len2_tm, len3_tm,</span>
<span class="lineno"> 4149 </span><span class="spaces">              </span><span class="nottickedoff">elem_tp, transTerm1 ptrans1, transTerm1 ptrans2]</span>
<span class="lineno"> 4150 </span><span class="spaces">       </span><span class="nottickedoff">bindTransM arr_out_comp_tm tp_trans &quot;appended_array&quot; $ \ptrans_arr' -&gt;</span>
<span class="lineno"> 4151 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM RL.tail (\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4152 </span><span class="spaces">                                  </span><span class="nottickedoff">pctx :&gt;: ptrans_arr') m</span>
<span class="lineno"> 4153 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4154 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4155 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayRearrange _ _ _ |] -&gt;</span>
<span class="lineno"> 4156 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4157 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4158 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4159 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4160 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4161 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayToField _ _ _ |] -&gt;</span>
<span class="lineno"> 4162 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4163 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4164 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [])</span>
<span class="lineno"> 4165 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4166 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4167 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayEmpty x mb_ap |] -&gt;</span>
<span class="lineno"> 4168 </span><span class="spaces">    </span><span class="nottickedoff">do (w_tm, _, elem_tp, ap_tp_trans) &lt;- translateLLVMArrayPerm mb_ap</span>
<span class="lineno"> 4169 </span><span class="spaces">       </span><span class="nottickedoff">-- First we build a term of type Vec 0 elem_tp using EmptyVec</span>
<span class="lineno"> 4170 </span><span class="spaces">       </span><span class="nottickedoff">let vec_tm = applyGlobalOpenTerm &quot;Prelude.EmptyVec&quot; [elem_tp]</span>
<span class="lineno"> 4171 </span><span class="spaces">       </span><span class="nottickedoff">-- Next, we build a computation that casts it to BVVec w 0x0 elem_tp</span>
<span class="lineno"> 4172 </span><span class="spaces">       </span><span class="nottickedoff">let w = fromIntegral $ natVal2 mb_ap</span>
<span class="lineno"> 4173 </span><span class="spaces">       </span><span class="nottickedoff">let bvZero_nat_tm =</span>
<span class="lineno"> 4174 </span><span class="spaces">             </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.bvToNat&quot;</span>
<span class="lineno"> 4175 </span><span class="spaces">             </span><span class="nottickedoff">[w_tm, bvLitOpenTerm (replicate w False)]</span>
<span class="lineno"> 4176 </span><span class="spaces">       </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4177 </span><span class="spaces">       </span><span class="nottickedoff">let vec_cast_m =</span>
<span class="lineno"> 4178 </span><span class="spaces">             </span><span class="nottickedoff">applyGlobalOpenTerm &quot;SpecM.castVecS&quot;</span>
<span class="lineno"> 4179 </span><span class="spaces">             </span><span class="nottickedoff">[evTypeTerm ev, elem_tp, natOpenTerm 0, bvZero_nat_tm, vec_tm]</span>
<span class="lineno"> 4180 </span><span class="spaces">       </span><span class="nottickedoff">bindTransM vec_cast_m ap_tp_trans &quot;empty_vec&quot; $ \ptrans_arr -&gt;</span>
<span class="lineno"> 4181 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 4182 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; pctx :&gt;: PTrans_Conj [APTrans_LLVMArray ptrans_arr])</span>
<span class="lineno"> 4183 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4184 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4185 </span><span class="spaces"></span><span class="nottickedoff">-- translate1/translateClosed ( zeroOfType &lt;- get the default element )</span>
<span class="lineno"> 4186 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayBorrowed x _ mb_ap |] -&gt;</span>
<span class="lineno"> 4187 </span><span class="spaces">    </span><span class="nottickedoff">do (w_tm, len_tm, elem_tp, ap_tp_trans) &lt;- translateLLVMArrayPerm mb_ap</span>
<span class="lineno"> 4188 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM (:&gt;: translateVar x)</span>
<span class="lineno"> 4189 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: ptrans_block) -&gt;</span>
<span class="lineno"> 4190 </span><span class="spaces">           </span><span class="nottickedoff">let arr_term =</span>
<span class="lineno"> 4191 </span><span class="spaces">                 </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.repeatBVVec&quot;</span>
<span class="lineno"> 4192 </span><span class="spaces">                 </span><span class="nottickedoff">[w_tm, len_tm, elem_tp, termsExpect1 ts] in</span>
<span class="lineno"> 4193 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4194 </span><span class="spaces">           </span><span class="nottickedoff">PTrans_Conj [APTrans_LLVMArray $ typeTransF ap_tp_trans [arr_term]] :&gt;:</span>
<span class="lineno"> 4195 </span><span class="spaces">           </span><span class="nottickedoff">ptrans_block)</span>
<span class="lineno"> 4196 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4197 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4198 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayFromBlock _ _ |] -&gt;</span>
<span class="lineno"> 4199 </span><span class="spaces">    </span><span class="nottickedoff">do mb_ap &lt;-</span>
<span class="lineno"> 4200 </span><span class="spaces">         </span><span class="nottickedoff">case mbSimplImplOut mb_simpl of</span>
<span class="lineno"> 4201 </span><span class="spaces">           </span><span class="nottickedoff">[nuP| DistPermsCons _ _ (ValPerm_LLVMArray mb_ap) |] -&gt; return mb_ap</span>
<span class="lineno"> 4202 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; error (&quot;translateSimplImpl: SImpl_LLVMArrayFromBlock: &quot;</span>
<span class="lineno"> 4203 </span><span class="spaces">                       </span><span class="nottickedoff">++ &quot;unexpected form of output permission&quot;)</span>
<span class="lineno"> 4204 </span><span class="spaces">       </span><span class="nottickedoff">(w_tm, len_tm, elem_tp, ap_tp_trans) &lt;- translateLLVMArrayPerm mb_ap</span>
<span class="lineno"> 4205 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4206 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ptrans_cell) -&gt;</span>
<span class="lineno"> 4207 </span><span class="spaces">           </span><span class="nottickedoff">let arr_term =</span>
<span class="lineno"> 4208 </span><span class="spaces">                 </span><span class="nottickedoff">-- FIXME: this generates a BVVec of length (bvNat n 1), whereas</span>
<span class="lineno"> 4209 </span><span class="spaces">                 </span><span class="nottickedoff">-- what we need is a BVVec of length [0,0,...,1]; the two are</span>
<span class="lineno"> 4210 </span><span class="spaces">                 </span><span class="nottickedoff">-- provably equal but not convertible in SAW core</span>
<span class="lineno"> 4211 </span><span class="spaces">                 </span><span class="nottickedoff">{-</span>
<span class="lineno"> 4212 </span><span class="spaces">                 </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.singletonBVVec&quot;)</span>
<span class="lineno"> 4213 </span><span class="spaces">                 </span><span class="nottickedoff">[w_tm, elem_tp, ts]</span>
<span class="lineno"> 4214 </span><span class="spaces">                 </span><span class="nottickedoff">-}</span>
<span class="lineno"> 4215 </span><span class="spaces">                 </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.repeatBVVec&quot;</span>
<span class="lineno"> 4216 </span><span class="spaces">                 </span><span class="nottickedoff">[w_tm, len_tm, elem_tp, tupleOpenTerm' ts] in</span>
<span class="lineno"> 4217 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4218 </span><span class="spaces">           </span><span class="nottickedoff">PTrans_Conj [APTrans_LLVMArray $ typeTransF ap_tp_trans [arr_term]])</span>
<span class="lineno"> 4219 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4220 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4221 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4222 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCellCopy _ _ mb_cell |] -&gt;</span>
<span class="lineno"> 4223 </span><span class="spaces">    </span><span class="nottickedoff">do (_ :&gt;: ptrans_array :&gt;: ptrans_props) &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4224 </span><span class="spaces">       </span><span class="nottickedoff">let arr_trans =</span>
<span class="lineno"> 4225 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4226 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCellCopy&quot; ptrans_array</span>
<span class="lineno"> 4227 </span><span class="spaces">       </span><span class="nottickedoff">let prop_transs =</span>
<span class="lineno"> 4228 </span><span class="spaces">             </span><span class="nottickedoff">unPTransBVProps</span>
<span class="lineno"> 4229 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCellCopy&quot; ptrans_props</span>
<span class="lineno"> 4230 </span><span class="spaces">       </span><span class="nottickedoff">cell_tm &lt;- translate1 mb_cell</span>
<span class="lineno"> 4231 </span><span class="spaces">       </span><span class="nottickedoff">let cell_ptrans =</span>
<span class="lineno"> 4232 </span><span class="spaces">             </span><span class="nottickedoff">getLLVMArrayTransCell arr_trans mb_cell cell_tm prop_transs</span>
<span class="lineno"> 4233 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4234 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4235 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [cell_ptrans] :&gt;: ptrans_array)</span>
<span class="lineno"> 4236 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4237 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4238 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCellBorrow _ mb_ap mb_cell |] -&gt;</span>
<span class="lineno"> 4239 </span><span class="spaces">    </span><span class="nottickedoff">do (_ :&gt;: ptrans_array :&gt;: ptrans_props) &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4240 </span><span class="spaces">       </span><span class="nottickedoff">let arr_trans =</span>
<span class="lineno"> 4241 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4242 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCellBorrow&quot; ptrans_array</span>
<span class="lineno"> 4243 </span><span class="spaces">       </span><span class="nottickedoff">let prop_transs =</span>
<span class="lineno"> 4244 </span><span class="spaces">             </span><span class="nottickedoff">unPTransBVProps</span>
<span class="lineno"> 4245 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCellBorrow&quot; ptrans_props</span>
<span class="lineno"> 4246 </span><span class="spaces">       </span><span class="nottickedoff">cell_tm &lt;- translate1 mb_cell</span>
<span class="lineno"> 4247 </span><span class="spaces">       </span><span class="nottickedoff">let cell_ptrans =</span>
<span class="lineno"> 4248 </span><span class="spaces">             </span><span class="nottickedoff">getLLVMArrayTransCell arr_trans mb_cell cell_tm prop_transs</span>
<span class="lineno"> 4249 </span><span class="spaces">       </span><span class="nottickedoff">{- let b = LLVMArrayBorrowTrans (fmap FieldBorrow ix) prop_transs -}</span>
<span class="lineno"> 4250 </span><span class="spaces">       </span><span class="nottickedoff">let arr_trans' =</span>
<span class="lineno"> 4251 </span><span class="spaces">             </span><span class="nottickedoff">arr_trans { llvmArrayTransPerm =</span>
<span class="lineno"> 4252 </span><span class="spaces">                           </span><span class="nottickedoff">mbMap2 (\ap cell -&gt;</span>
<span class="lineno"> 4253 </span><span class="spaces">                                    </span><span class="nottickedoff">llvmArrayAddBorrow (FieldBorrow cell) ap)</span>
<span class="lineno"> 4254 </span><span class="spaces">                           </span><span class="nottickedoff">mb_ap mb_cell }</span>
<span class="lineno"> 4255 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4256 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4257 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [cell_ptrans] :&gt;:</span>
<span class="lineno"> 4258 </span><span class="spaces">           </span><span class="nottickedoff">PTrans_Conj [APTrans_LLVMArray arr_trans'])</span>
<span class="lineno"> 4259 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4260 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4261 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCellReturn _ mb_ap mb_cell |] -&gt;</span>
<span class="lineno"> 4262 </span><span class="spaces">    </span><span class="nottickedoff">do (_ :&gt;: ptrans_cell :&gt;: ptrans_array) &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4263 </span><span class="spaces">       </span><span class="nottickedoff">let aptrans_cell = case ptrans_cell of</span>
<span class="lineno"> 4264 </span><span class="spaces">             </span><span class="nottickedoff">PTrans_Conj [aptrans] -&gt; aptrans</span>
<span class="lineno"> 4265 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error (&quot;translateSimplImpl: SImpl_LLVMArrayCellReturn: &quot;</span>
<span class="lineno"> 4266 </span><span class="spaces">                         </span><span class="nottickedoff">++ &quot;found non-field perm where field perm was expected&quot;)</span>
<span class="lineno"> 4267 </span><span class="spaces">       </span><span class="nottickedoff">let arr_trans =</span>
<span class="lineno"> 4268 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLLVMArray</span>
<span class="lineno"> 4269 </span><span class="spaces">             </span><span class="nottickedoff">&quot;translateSimplImpl: SImpl_LLVMArrayCellReturn&quot; ptrans_array</span>
<span class="lineno"> 4270 </span><span class="spaces">       </span><span class="nottickedoff">{- let b_trans = llvmArrayTransFindBorrow (fmap FieldBorrow cell) arr_trans -}</span>
<span class="lineno"> 4271 </span><span class="spaces">       </span><span class="nottickedoff">let arr_trans' = arr_trans</span>
<span class="lineno"> 4272 </span><span class="spaces">             </span><span class="nottickedoff">{ llvmArrayTransPerm =</span>
<span class="lineno"> 4273 </span><span class="spaces">                 </span><span class="nottickedoff">mbMap2 (\ap cell -&gt;</span>
<span class="lineno"> 4274 </span><span class="spaces">                          </span><span class="nottickedoff">llvmArrayRemBorrow (FieldBorrow cell) ap) mb_ap mb_cell }</span>
<span class="lineno"> 4275 </span><span class="spaces">       </span><span class="nottickedoff">cell_tm &lt;- translate1 mb_cell</span>
<span class="lineno"> 4276 </span><span class="spaces">       </span><span class="nottickedoff">let arr_trans'' = setLLVMArrayTransCell arr_trans' cell_tm aptrans_cell</span>
<span class="lineno"> 4277 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 4278 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4279 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_LLVMArray arr_trans''])</span>
<span class="lineno"> 4280 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4281 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4282 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayContents _ mb_ap mb_sh impl |] -&gt;</span>
<span class="lineno"> 4283 </span><span class="spaces">    </span><span class="nottickedoff">do p_out_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4284 </span><span class="spaces">       </span><span class="nottickedoff">(w_term, len_term, elem_tp, _) &lt;- translateLLVMArrayPerm mb_ap</span>
<span class="lineno"> 4285 </span><span class="spaces">       </span><span class="nottickedoff">cell_in_trans &lt;-</span>
<span class="lineno"> 4286 </span><span class="spaces">         </span><span class="nottickedoff">translate $ mbMapCl $(mkClosed [| ValPerm_LLVMBlock .</span>
<span class="lineno"> 4287 </span><span class="spaces">                                         </span><span class="nottickedoff">llvmArrayPermHead |]) mb_ap</span>
<span class="lineno"> 4288 </span><span class="spaces">       </span><span class="nottickedoff">cell_out_trans &lt;-</span>
<span class="lineno"> 4289 </span><span class="spaces">         </span><span class="nottickedoff">translate $ mbMap2 (\ap sh -&gt; ValPerm_LLVMBlock $ llvmArrayPermHead $</span>
<span class="lineno"> 4290 </span><span class="spaces">                                       </span><span class="nottickedoff">ap { llvmArrayCellShape = sh })</span>
<span class="lineno"> 4291 </span><span class="spaces">         </span><span class="nottickedoff">mb_ap mb_sh</span>
<span class="lineno"> 4292 </span><span class="spaces">       </span><span class="nottickedoff">impl_tm &lt;-</span>
<span class="lineno"> 4293 </span><span class="spaces">         </span><span class="nottickedoff">-- FIXME: this code just fabricates a pretend LLVM value for the</span>
<span class="lineno"> 4294 </span><span class="spaces">         </span><span class="nottickedoff">-- arbitrary cell of the array that is used to substitute for the</span>
<span class="lineno"> 4295 </span><span class="spaces">         </span><span class="nottickedoff">-- variable bound by the LocalPermImpl, which seems like a hack...</span>
<span class="lineno"> 4296 </span><span class="spaces">         </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 4297 </span><span class="spaces">         </span><span class="nottickedoff">translateCurryLocalPermImpl &quot;Error mapping array cell permissions:&quot;</span>
<span class="lineno"> 4298 </span><span class="spaces">         </span><span class="nottickedoff">(mbCombine RL.typeCtxProxies impl) MNil MNil</span>
<span class="lineno"> 4299 </span><span class="spaces">         </span><span class="nottickedoff">(fmap ((MNil :&gt;:) . extPermTrans ETrans_LLVM) cell_in_trans)</span>
<span class="lineno"> 4300 </span><span class="spaces">         </span><span class="nottickedoff">(MNil :&gt;: Member_Base)</span>
<span class="lineno"> 4301 </span><span class="spaces">         </span><span class="nottickedoff">(fmap ((MNil :&gt;:) . extPermTrans ETrans_LLVM) cell_out_trans)</span>
<span class="lineno"> 4302 </span><span class="spaces">       </span><span class="nottickedoff">-- Build the computation that maps impl_tm over the input array using the</span>
<span class="lineno"> 4303 </span><span class="spaces">       </span><span class="nottickedoff">-- mapBVVecM monadic combinator</span>
<span class="lineno"> 4304 </span><span class="spaces">       </span><span class="nottickedoff">ptrans_arr &lt;- getTopPermM</span>
<span class="lineno"> 4305 </span><span class="spaces">       </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4306 </span><span class="spaces">       </span><span class="nottickedoff">let arr_out_comp_tm =</span>
<span class="lineno"> 4307 </span><span class="spaces">             </span><span class="nottickedoff">applyGlobalOpenTerm &quot;SpecM.mapBVVecS&quot;</span>
<span class="lineno"> 4308 </span><span class="spaces">             </span><span class="nottickedoff">[evTypeTerm ev, elem_tp, typeTransType1 cell_out_trans, impl_tm,</span>
<span class="lineno"> 4309 </span><span class="spaces">              </span><span class="nottickedoff">w_term, len_term, transTerm1 ptrans_arr]</span>
<span class="lineno"> 4310 </span><span class="spaces">       </span><span class="nottickedoff">-- Now use bindS to bind the result of arr_out_comp_tm in the remaining</span>
<span class="lineno"> 4311 </span><span class="spaces">       </span><span class="nottickedoff">-- computation</span>
<span class="lineno"> 4312 </span><span class="spaces">       </span><span class="nottickedoff">bindTransM arr_out_comp_tm p_out_trans &quot;mapped_array&quot; $ \ptrans_arr' -&gt;</span>
<span class="lineno"> 4313 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM id (\(pctx :&gt;: _) -&gt; pctx :&gt;: ptrans_arr') m</span>
<span class="lineno"> 4314 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4315 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMFieldIsPtr x _ |] -&gt;</span>
<span class="lineno"> 4316 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 4317 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans_fld) -&gt;</span>
<span class="lineno"> 4318 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_IsLLVMPtr] :&gt;: ptrans_fld)</span>
<span class="lineno"> 4319 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 4320 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4321 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayIsPtr x _ |] -&gt;</span>
<span class="lineno"> 4322 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 4323 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans_array) -&gt;</span>
<span class="lineno"> 4324 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_IsLLVMPtr] :&gt;: ptrans_array)</span>
<span class="lineno"> 4325 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 4326 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4327 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LLVMBlockIsPtr x _ |] -&gt;</span>
<span class="lineno"> 4328 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 4329 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans) -&gt;</span>
<span class="lineno"> 4330 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_IsLLVMPtr] :&gt;: ptrans)</span>
<span class="lineno"> 4331 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 4332 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4333 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_SplitLifetime mb_x f args l mb_l2 _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4334 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME HERE: get rid of the mbMaps!</span>
<span class="lineno"> 4335 </span><span class="spaces">    </span><span class="nottickedoff">do let l2_e = fmap PExpr_Var mb_l2</span>
<span class="lineno"> 4336 </span><span class="spaces">       </span><span class="nottickedoff">let f_l_args = mbMap3 ltFuncApply f args l</span>
<span class="lineno"> 4337 </span><span class="spaces">       </span><span class="nottickedoff">let f_l2_min = mbMap2 ltFuncMinApply f l2_e</span>
<span class="lineno"> 4338 </span><span class="spaces">       </span><span class="nottickedoff">let x_tp = mbVarType mb_x</span>
<span class="lineno"> 4339 </span><span class="spaces">       </span><span class="nottickedoff">f_l2_args_trans &lt;- translateSimplImplOutTailHead mb_simpl</span>
<span class="lineno"> 4340 </span><span class="spaces">       </span><span class="nottickedoff">f_l_args_trans &lt;- tpTransM $ translateDescType f_l_args</span>
<span class="lineno"> 4341 </span><span class="spaces">       </span><span class="nottickedoff">f_l2_min_trans &lt;- tpTransM $ translateDescType f_l2_min</span>
<span class="lineno"> 4342 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM</span>
<span class="lineno"> 4343 </span><span class="spaces">         </span><span class="nottickedoff">(\ (_ :&gt;: ptrans_x :&gt;: _ :&gt;: _) -&gt; ptrans_x)</span>
<span class="lineno"> 4344 </span><span class="spaces">         </span><span class="nottickedoff">(\(ns :&gt;: x :&gt;: _ :&gt;: l2) -&gt; ns :&gt;: x :&gt;: l2)</span>
<span class="lineno"> 4345 </span><span class="spaces">         </span><span class="nottickedoff">(\ts pctx_all -&gt; case pctx_all of</span>
<span class="lineno"> 4346 </span><span class="spaces">             </span><span class="nottickedoff">(pctx :&gt;: _ptrans_x :&gt;: _ :&gt;:</span>
<span class="lineno"> 4347 </span><span class="spaces">              </span><span class="nottickedoff">PTrans_LOwned mb_ls tps_in tps_out mb_ps_in mb_ps_out t)</span>
<span class="lineno"> 4348 </span><span class="spaces">               </span><span class="nottickedoff">-&gt;</span>
<span class="lineno"> 4349 </span><span class="spaces">               </span><span class="nottickedoff">pctx :&gt;: typeTransF f_l2_args_trans ts :&gt;:</span>
<span class="lineno"> 4350 </span><span class="spaces">               </span><span class="nottickedoff">PTrans_LOwned mb_ls (CruCtxCons tps_in x_tp)</span>
<span class="lineno"> 4351 </span><span class="spaces">               </span><span class="nottickedoff">(CruCtxCons tps_out x_tp)</span>
<span class="lineno"> 4352 </span><span class="spaces">               </span><span class="nottickedoff">(mbMap3 (\ps x p -&gt; ps :&gt;: ExprAndPerm (PExpr_Var x) p)</span>
<span class="lineno"> 4353 </span><span class="spaces">                </span><span class="nottickedoff">mb_ps_in mb_x f_l2_min)</span>
<span class="lineno"> 4354 </span><span class="spaces">               </span><span class="nottickedoff">(mbMap3 (\ps x p -&gt; ps :&gt;: ExprAndPerm (PExpr_Var x) p)</span>
<span class="lineno"> 4355 </span><span class="spaces">                </span><span class="nottickedoff">mb_ps_out mb_x f_l_args)</span>
<span class="lineno"> 4356 </span><span class="spaces">               </span><span class="nottickedoff">(weakenLOwnedTrans f_l2_min_trans f_l_args_trans t)</span>
<span class="lineno"> 4357 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 4358 </span><span class="spaces">               </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4359 </span><span class="spaces">               </span><span class="nottickedoff">[&quot;In SImpl_SplitLifetime rule: expected an lowned permission&quot;])</span>
<span class="lineno"> 4360 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4361 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4362 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_SubsumeLifetime _ _ _ _ _ _ mb_l2 |] -&gt;</span>
<span class="lineno"> 4363 </span><span class="spaces">    </span><span class="nottickedoff">flip (withPermStackM id) m $ \case</span>
<span class="lineno"> 4364 </span><span class="spaces">    </span><span class="nottickedoff">(pctx :&gt;: PTrans_LOwned mb_ls tps_in tps_out mb_ps_in mb_ps_out t) -&gt;</span>
<span class="lineno"> 4365 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4366 </span><span class="spaces">      </span><span class="nottickedoff">PTrans_LOwned (mbMap2 (:) mb_l2 mb_ls) tps_in tps_out mb_ps_in mb_ps_out t</span>
<span class="lineno"> 4367 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 4368 </span><span class="spaces">      </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4369 </span><span class="spaces">      </span><span class="nottickedoff">[&quot;In SImpl_SubsumeLifetime rule: expected an lowned permission&quot;]</span>
<span class="lineno"> 4370 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4371 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ContainedLifetimeCurrent _ _ _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4372 </span><span class="spaces">    </span><span class="nottickedoff">do ttr_lcur &lt;- translateSimplImplOutTailHead mb_simpl</span>
<span class="lineno"> 4373 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 4374 </span><span class="spaces">         </span><span class="nottickedoff">(\(ns :&gt;: l1) -&gt; ns :&gt;: l1 :&gt;: l1)</span>
<span class="lineno"> 4375 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: ptrans_l) -&gt;</span>
<span class="lineno"> 4376 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttr_lcur [] :&gt;: ptrans_l)</span>
<span class="lineno"> 4377 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4378 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4379 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_RemoveContainedLifetime _ _ _ _ _ _ mb_l2 |] -&gt;</span>
<span class="lineno"> 4380 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 4381 </span><span class="spaces">    </span><span class="nottickedoff">(\(ns :&gt;: l :&gt;: _) -&gt; ns :&gt;: l)</span>
<span class="lineno"> 4382 </span><span class="spaces">    </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 4383 </span><span class="spaces">        </span><span class="nottickedoff">(pctx :&gt;:</span>
<span class="lineno"> 4384 </span><span class="spaces">         </span><span class="nottickedoff">PTrans_LOwned mb_ls tps_in tps_out mb_ps_in mb_ps_out t :&gt;: _) -&gt;</span>
<span class="lineno"> 4385 </span><span class="spaces">          </span><span class="nottickedoff">let mb_ls' = mbMap2 (\l2 ls -&gt;</span>
<span class="lineno"> 4386 </span><span class="spaces">                                </span><span class="nottickedoff">delete (PExpr_Var l2) ls) mb_l2 mb_ls in</span>
<span class="lineno"> 4387 </span><span class="spaces">          </span><span class="nottickedoff">pctx :&gt;: PTrans_LOwned mb_ls' tps_in tps_out mb_ps_in mb_ps_out t</span>
<span class="lineno"> 4388 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 4389 </span><span class="spaces">          </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4390 </span><span class="spaces">          </span><span class="nottickedoff">[&quot;In SImpl_RemoveContainedLifetime rule: expected an lowned permission&quot;])</span>
<span class="lineno"> 4391 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 4392 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4393 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_WeakenLifetime _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4394 </span><span class="spaces">    </span><span class="nottickedoff">do pctx_out_trans &lt;- translateSimplImplOut mb_simpl</span>
<span class="lineno"> 4395 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM (\(_ :&gt;: ptrans_x :&gt;: _) -&gt; ptrans_x)</span>
<span class="lineno"> 4396 </span><span class="spaces">         </span><span class="nottickedoff">RL.tail</span>
<span class="lineno"> 4397 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4398 </span><span class="spaces">           </span><span class="nottickedoff">-- NOTE: lcurrent permissions have no term translations, so we can</span>
<span class="lineno"> 4399 </span><span class="spaces">           </span><span class="nottickedoff">-- construct the output PermTransCtx by just passing the terms in</span>
<span class="lineno"> 4400 </span><span class="spaces">           </span><span class="nottickedoff">-- ptrans_x to pctx_out_trans</span>
<span class="lineno"> 4401 </span><span class="spaces">           </span><span class="nottickedoff">RL.append pctx (typeTransF pctx_out_trans ts))</span>
<span class="lineno"> 4402 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4403 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4404 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_MapLifetime _ mb_ls tps_in tps_out _ _ tps_in' tps_out'</span>
<span class="lineno"> 4405 </span><span class="spaces">                           </span><span class="nottickedoff">ps_in' ps_out' ps1 ps2 impl_in impl_out |] -&gt;</span>
<span class="lineno"> 4406 </span><span class="spaces">    </span><span class="nottickedoff">-- First, translate the various permissions and implications</span>
<span class="lineno"> 4407 </span><span class="spaces">    </span><span class="nottickedoff">do ttr_inF' &lt;- tpTransM $ translateDescType ps_in'</span>
<span class="lineno"> 4408 </span><span class="spaces">       </span><span class="nottickedoff">ttr_outF' &lt;- tpTransM $ translateDescType ps_out'</span>
<span class="lineno"> 4409 </span><span class="spaces">       </span><span class="nottickedoff">ttr1F &lt;- tpTransM $ translateDescType ps1</span>
<span class="lineno"> 4410 </span><span class="spaces">       </span><span class="nottickedoff">ttr2F &lt;- tpTransM $ translateDescType ps2</span>
<span class="lineno"> 4411 </span><span class="spaces">       </span><span class="nottickedoff">t1 &lt;-</span>
<span class="lineno"> 4412 </span><span class="spaces">         </span><span class="nottickedoff">translateLOwnedPermImpl &quot;Error mapping lowned input perms:&quot; impl_in</span>
<span class="lineno"> 4413 </span><span class="spaces">       </span><span class="nottickedoff">t2 &lt;-</span>
<span class="lineno"> 4414 </span><span class="spaces">         </span><span class="nottickedoff">translateLOwnedPermImpl &quot;Error mapping lowned output perms:&quot; impl_out</span>
<span class="lineno"> 4415 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4416 </span><span class="spaces">       </span><span class="nottickedoff">-- Next, split out the various input permissions from the rest of the pctx</span>
<span class="lineno"> 4417 </span><span class="spaces">       </span><span class="nottickedoff">let prxs1 = mbRAssignProxies ps1</span>
<span class="lineno"> 4418 </span><span class="spaces">       </span><span class="nottickedoff">let prxs2 = mbRAssignProxies ps2</span>
<span class="lineno"> 4419 </span><span class="spaces">       </span><span class="nottickedoff">let prxs_in = RL.append prxs1 prxs2 :&gt;: Proxy</span>
<span class="lineno"> 4420 </span><span class="spaces">       </span><span class="nottickedoff">let prxs_in' = cruCtxProxies $ mbLift tps_in'</span>
<span class="lineno"> 4421 </span><span class="spaces">       </span><span class="nottickedoff">pctx &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4422 </span><span class="spaces">       </span><span class="nottickedoff">let (pctx0, pctx12 :&gt;: ptrans_l) = RL.split ps0 prxs_in pctx</span>
<span class="lineno"> 4423 </span><span class="spaces">       </span><span class="nottickedoff">let (pctx1, pctx2) = RL.split prxs1 prxs2 pctx12</span>
<span class="lineno"> 4424 </span><span class="spaces">       </span><span class="nottickedoff">let some_lotr =</span>
<span class="lineno"> 4425 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLOwned &quot;translateSimplImpl&quot; tps_in tps_out ptrans_l</span>
<span class="lineno"> 4426 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4427 </span><span class="spaces">       </span><span class="nottickedoff">-- Also split out the input variables and replace them with the ps_out vars</span>
<span class="lineno"> 4428 </span><span class="spaces">       </span><span class="nottickedoff">pctx_vars &lt;- itiPermStackVars &lt;$&gt; ask</span>
<span class="lineno"> 4429 </span><span class="spaces">       </span><span class="nottickedoff">let (vars_ps, vars12 :&gt;: _) = RL.split ps0 prxs_in pctx_vars</span>
<span class="lineno"> 4430 </span><span class="spaces">       </span><span class="nottickedoff">let (vars1, vars2) = RL.split prxs1 prxs2 vars12</span>
<span class="lineno"> 4431 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4432 </span><span class="spaces">       </span><span class="nottickedoff">-- Finally, modify the PTrans_LOwned on top of the stack using</span>
<span class="lineno"> 4433 </span><span class="spaces">       </span><span class="nottickedoff">-- mapLtLOwnedTrans</span>
<span class="lineno"> 4434 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 4435 </span><span class="spaces">         </span><span class="nottickedoff">(\(_ :&gt;: l) -&gt; vars_ps :&gt;: l)</span>
<span class="lineno"> 4436 </span><span class="spaces">         </span><span class="nottickedoff">(\_ -&gt;</span>
<span class="lineno"> 4437 </span><span class="spaces">           </span><span class="nottickedoff">case some_lotr of</span>
<span class="lineno"> 4438 </span><span class="spaces">             </span><span class="nottickedoff">SomeLOwnedTrans lotr -&gt;</span>
<span class="lineno"> 4439 </span><span class="spaces">               </span><span class="nottickedoff">pctx0 :&gt;:</span>
<span class="lineno"> 4440 </span><span class="spaces">               </span><span class="nottickedoff">PTrans_LOwned mb_ls (mbLift tps_in') (mbLift tps_out') ps_in' ps_out'</span>
<span class="lineno"> 4441 </span><span class="spaces">               </span><span class="nottickedoff">(mapLtLOwnedTrans pctx1 vars1 ttr1F pctx2 vars2 ttr2F</span>
<span class="lineno"> 4442 </span><span class="spaces">                </span><span class="nottickedoff">prxs_in' ttr_inF' ttr_outF' t1 t2 lotr))</span>
<span class="lineno"> 4443 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4444 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4445 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_EndLifetime _ tps_in tps_out ps_in ps_out |] -&gt;</span>
<span class="lineno"> 4446 </span><span class="spaces">    </span><span class="nottickedoff">-- First, translate the in and out permissions of the lowned permission</span>
<span class="lineno"> 4447 </span><span class="spaces">    </span><span class="nottickedoff">do tr_out &lt;- translate ps_out</span>
<span class="lineno"> 4448 </span><span class="spaces">       </span><span class="nottickedoff">let prxs_in = mbRAssignProxies ps_in :&gt;: Proxy</span>
<span class="lineno"> 4449 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4450 </span><span class="spaces">       </span><span class="nottickedoff">-- Next, split out the ps_in permissions from the rest of the pctx</span>
<span class="lineno"> 4451 </span><span class="spaces">       </span><span class="nottickedoff">pctx &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 4452 </span><span class="spaces">       </span><span class="nottickedoff">let (pctx_ps, pctx_in :&gt;: ptrans_l) = RL.split ps0 prxs_in pctx</span>
<span class="lineno"> 4453 </span><span class="spaces">       </span><span class="nottickedoff">let some_lotr =</span>
<span class="lineno"> 4454 </span><span class="spaces">             </span><span class="nottickedoff">unPTransLOwned &quot;translateSimplImpl&quot; tps_in tps_out ptrans_l</span>
<span class="lineno"> 4455 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4456 </span><span class="spaces">       </span><span class="nottickedoff">-- Also split out the ps_in variables and replace them with the ps_out vars</span>
<span class="lineno"> 4457 </span><span class="spaces">       </span><span class="nottickedoff">pctx_vars &lt;- itiPermStackVars &lt;$&gt; ask</span>
<span class="lineno"> 4458 </span><span class="spaces">       </span><span class="nottickedoff">let (ps_vars, _ :&gt;: _) = RL.split ps0 prxs_in pctx_vars</span>
<span class="lineno"> 4459 </span><span class="spaces">       </span><span class="nottickedoff">let vars_out = case mbExprPermsMembers ps_out of</span>
<span class="lineno"> 4460 </span><span class="spaces">             </span><span class="nottickedoff">Just x -&gt; x</span>
<span class="lineno"> 4461 </span><span class="spaces">             </span><span class="nottickedoff">Nothing -&gt; panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4462 </span><span class="spaces">               </span><span class="nottickedoff">[&quot;In SImpl_EndLifetime rule: malformed ps_out&quot;]</span>
<span class="lineno"> 4463 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4464 </span><span class="spaces">       </span><span class="nottickedoff">-- Now we apply the lifetime ownerhip function to ps_in and bind its output</span>
<span class="lineno"> 4465 </span><span class="spaces">       </span><span class="nottickedoff">-- in the rest of the computation</span>
<span class="lineno"> 4466 </span><span class="spaces">       </span><span class="nottickedoff">case some_lotr of</span>
<span class="lineno"> 4467 </span><span class="spaces">         </span><span class="nottickedoff">SomeLOwnedTrans lotr -&gt;</span>
<span class="lineno"> 4468 </span><span class="spaces">           </span><span class="nottickedoff">let lotr_f = lownedTransTerm ps_in lotr in</span>
<span class="lineno"> 4469 </span><span class="spaces">           </span><span class="nottickedoff">bindTransM (applyOpenTermMulti lotr_f $</span>
<span class="lineno"> 4470 </span><span class="spaces">                       </span><span class="nottickedoff">transTerms pctx_in) tr_out &quot;endl_ps&quot; $ \pctx_out -&gt;</span>
<span class="lineno"> 4471 </span><span class="spaces">           </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 4472 </span><span class="spaces">           </span><span class="nottickedoff">(\(_ :&gt;: l) -&gt; RL.append ps_vars vars_out :&gt;: l)</span>
<span class="lineno"> 4473 </span><span class="spaces">           </span><span class="nottickedoff">(\_ -&gt; RL.append pctx_ps pctx_out :&gt;:</span>
<span class="lineno"> 4474 </span><span class="spaces">                  </span><span class="nottickedoff">PTrans_Conj [APTrans_LFinished])</span>
<span class="lineno"> 4475 </span><span class="spaces">           </span><span class="nottickedoff">m</span>
<span class="lineno"> 4476 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4477 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLOwnedSimple _ _ _ |] -&gt;</span>
<span class="lineno"> 4478 </span><span class="spaces">    </span><span class="nottickedoff">do let prx_ps_l = mbRAssignProxies $ mbSimplImplIn mb_simpl</span>
<span class="lineno"> 4479 </span><span class="spaces">       </span><span class="nottickedoff">ttrans &lt;- translateSimplImplOut mb_simpl</span>
<span class="lineno"> 4480 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM</span>
<span class="lineno"> 4481 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt;</span>
<span class="lineno"> 4482 </span><span class="spaces">           </span><span class="nottickedoff">let (_, pctx_ps :&gt;: _) = RL.split ps0 prx_ps_l pctx in pctx_ps)</span>
<span class="lineno"> 4483 </span><span class="spaces">         </span><span class="nottickedoff">id</span>
<span class="lineno"> 4484 </span><span class="spaces">         </span><span class="nottickedoff">(\ts pctx -&gt;</span>
<span class="lineno"> 4485 </span><span class="spaces">           </span><span class="nottickedoff">let (pctx0, _) = RL.split ps0 prx_ps_l pctx in</span>
<span class="lineno"> 4486 </span><span class="spaces">           </span><span class="nottickedoff">RL.append pctx0 $ typeTransF ttrans ts)</span>
<span class="lineno"> 4487 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4488 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4489 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLOwnedSimple mb_l mb_tps mb_ps |] -&gt;</span>
<span class="lineno"> 4490 </span><span class="spaces">    </span><span class="nottickedoff">case (mbExprPermsMembers mb_ps, mbMaybe (mbMap2 lownedPermsSimpleIn mb_l mb_ps)) of</span>
<span class="lineno"> 4491 </span><span class="spaces">      </span><span class="nottickedoff">(Just vars, Just mb_ps') -&gt;</span>
<span class="lineno"> 4492 </span><span class="spaces">        </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4493 </span><span class="spaces">           </span><span class="nottickedoff">ectx &lt;- infoCtx &lt;$&gt; ask</span>
<span class="lineno"> 4494 </span><span class="spaces">           </span><span class="nottickedoff">dtr_in &lt;- tpTransM $ translateDescType mb_ps'</span>
<span class="lineno"> 4495 </span><span class="spaces">           </span><span class="nottickedoff">dtr_out &lt;- tpTransM $ translateDescType mb_ps</span>
<span class="lineno"> 4496 </span><span class="spaces">           </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4497 </span><span class="spaces">             </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4498 </span><span class="spaces">               </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4499 </span><span class="spaces">               </span><span class="nottickedoff">PTrans_LOwned (fmap (const []) mb_l)</span>
<span class="lineno"> 4500 </span><span class="spaces">               </span><span class="nottickedoff">(mbLift mb_tps) (mbLift mb_tps) mb_ps' mb_ps</span>
<span class="lineno"> 4501 </span><span class="spaces">               </span><span class="nottickedoff">(mkLOwnedTransId ev ectx dtr_in dtr_out vars))</span>
<span class="lineno"> 4502 </span><span class="spaces">             </span><span class="nottickedoff">m</span>
<span class="lineno"> 4503 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 4504 </span><span class="spaces">        </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4505 </span><span class="spaces">        </span><span class="nottickedoff">[&quot;In SImpl_ElimLOwnedSimple rule: malformed permissions argument&quot;]</span>
<span class="lineno"> 4506 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4507 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LCurrentRefl l |] -&gt;</span>
<span class="lineno"> 4508 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4509 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar l) (:&gt;: typeTransF ttrans []) m</span>
<span class="lineno"> 4510 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4511 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_LCurrentTrans _ _ _ |] -&gt;</span>
<span class="lineno"> 4512 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4513 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail (\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4514 </span><span class="spaces">                                </span><span class="nottickedoff">(pctx :&gt;: typeTransF ttrans [])) m</span>
<span class="lineno"> 4515 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4516 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_DemoteLLVMBlockRW _ _ |] -&gt;</span>
<span class="lineno"> 4517 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4518 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4519 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4520 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4521 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4522 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockEmpty x _ |] -&gt;</span>
<span class="lineno"> 4523 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4524 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 4525 </span><span class="spaces">         </span><span class="nottickedoff">(\pctx -&gt; pctx :&gt;: typeTransF ttrans [])</span>
<span class="lineno"> 4526 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4527 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4528 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_CoerceLLVMBlockEmpty _ _ |] -&gt;</span>
<span class="lineno"> 4529 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4530 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4531 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [])</span>
<span class="lineno"> 4532 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4533 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4534 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockToBytes _ mb_bp |] -&gt;</span>
<span class="lineno"> 4535 </span><span class="spaces">    </span><span class="nottickedoff">do let w = natVal2 mb_bp</span>
<span class="lineno"> 4536 </span><span class="spaces">       </span><span class="nottickedoff">let w_term = natOpenTerm w</span>
<span class="lineno"> 4537 </span><span class="spaces">       </span><span class="nottickedoff">len_term &lt;- translate1 $ fmap llvmBlockLen mb_bp</span>
<span class="lineno"> 4538 </span><span class="spaces">       </span><span class="nottickedoff">ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4539 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4540 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4541 </span><span class="spaces">           </span><span class="nottickedoff">let arr_term =</span>
<span class="lineno"> 4542 </span><span class="spaces">                 </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.repeatBVVec&quot;</span>
<span class="lineno"> 4543 </span><span class="spaces">                 </span><span class="nottickedoff">[w_term, len_term, unitTypeOpenTerm, unitOpenTerm] in</span>
<span class="lineno"> 4544 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans [arr_term])</span>
<span class="lineno"> 4545 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4546 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4547 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockTuple _ _ |] -&gt;</span>
<span class="lineno"> 4548 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4549 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4550 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4551 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans [tupleOpenTerm' ts])</span>
<span class="lineno"> 4552 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4553 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4554 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockTuple _ mb_bp |] -&gt;</span>
<span class="lineno"> 4555 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4556 </span><span class="spaces">       </span><span class="nottickedoff">shtrans &lt;- unETransShape &lt;$&gt; translate (mbLLVMBlockShape mb_bp)</span>
<span class="lineno"> 4557 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4558 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4559 </span><span class="spaces">           </span><span class="nottickedoff">let ts' = case shtrans of { Just _ -&gt; ts ; Nothing -&gt; [] } in</span>
<span class="lineno"> 4560 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts')</span>
<span class="lineno"> 4561 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4562 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4563 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockSeqEmpty _ _ |] -&gt;</span>
<span class="lineno"> 4564 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4565 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4566 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4567 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4568 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4569 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4570 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockSeqEmpty _ _ |] -&gt;</span>
<span class="lineno"> 4571 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4572 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4573 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4574 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4575 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4576 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_SplitLLVMBlockEmpty _ _ _ |] -&gt;</span>
<span class="lineno"> 4577 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4578 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4579 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [])</span>
<span class="lineno"> 4580 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4581 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4582 </span><span class="spaces">  </span><span class="nottickedoff">-- Intro for a recursive named shape applies the fold function for the shape</span>
<span class="lineno"> 4583 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockNamed _ bp nmsh |]</span>
<span class="lineno"> 4584 </span><span class="spaces">    </span><span class="nottickedoff">| [nuMP| RecShapeBody _ _ mb_sh_id |] &lt;- mbMatch $ fmap namedShapeBody nmsh</span>
<span class="lineno"> 4585 </span><span class="spaces">    </span><span class="nottickedoff">, [nuMP| PExpr_NamedShape _ _ nmsh' mb_args |] &lt;- mbMatch $ fmap llvmBlockShape bp -&gt;</span>
<span class="lineno"> 4586 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: although nmsh' should equal nmsh, it's easier to just use nmsh'</span>
<span class="lineno"> 4587 </span><span class="spaces">      </span><span class="nottickedoff">-- rather than convince GHC that they have the same argument types</span>
<span class="lineno"> 4588 </span><span class="spaces">      </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4589 </span><span class="spaces">         </span><span class="nottickedoff">let args_ctx = mbLift $ fmap namedShapeArgs nmsh'</span>
<span class="lineno"> 4590 </span><span class="spaces">         </span><span class="nottickedoff">d &lt;- substNamedIndTpDesc (mbLift mb_sh_id) args_ctx mb_args</span>
<span class="lineno"> 4591 </span><span class="spaces">         </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4592 </span><span class="spaces">         </span><span class="nottickedoff">unfolded_ptrans &lt;- getTopPermM</span>
<span class="lineno"> 4593 </span><span class="spaces">         </span><span class="nottickedoff">let folded_m = applyGlobalOpenTerm &quot;SpecM.foldTpElem&quot;</span>
<span class="lineno"> 4594 </span><span class="spaces">               </span><span class="nottickedoff">[evTypeTerm ev, d, transTupleTerm unfolded_ptrans]</span>
<span class="lineno"> 4595 </span><span class="spaces">         </span><span class="nottickedoff">bindTransM folded_m ttrans &quot;ind_val&quot; $ \ptrans -&gt;</span>
<span class="lineno"> 4596 </span><span class="spaces">           </span><span class="nottickedoff">withPermStackM id (\(pctx :&gt;: _) -&gt; pctx :&gt;: ptrans) m</span>
<span class="lineno"> 4597 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4598 </span><span class="spaces">  </span><span class="nottickedoff">-- Intro for a defined named shape (the other case) is a no-op</span>
<span class="lineno"> 4599 </span><span class="spaces">    </span><span class="nottickedoff">| [nuMP| DefinedShapeBody _ |] &lt;- mbMatch $ fmap namedShapeBody nmsh -&gt;</span>
<span class="lineno"> 4600 </span><span class="spaces">      </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4601 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4602 </span><span class="spaces">           </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4603 </span><span class="spaces">           </span><span class="nottickedoff">m</span>
<span class="lineno"> 4604 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4605 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise -&gt;</span>
<span class="lineno"> 4606 </span><span class="spaces">        </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4607 </span><span class="spaces">        </span><span class="nottickedoff">[&quot;SImpl_IntroLLVMBlockNamed, unknown named shape&quot;]</span>
<span class="lineno"> 4608 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4609 </span><span class="spaces">  </span><span class="nottickedoff">-- Elim for a recursive named shape applies the unfold function for the shape</span>
<span class="lineno"> 4610 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockNamed _ bp nmsh |]</span>
<span class="lineno"> 4611 </span><span class="spaces">    </span><span class="nottickedoff">| [nuMP| RecShapeBody _ _ mb_sh_id |] &lt;- mbMatch $ fmap namedShapeBody nmsh</span>
<span class="lineno"> 4612 </span><span class="spaces">    </span><span class="nottickedoff">, [nuMP| PExpr_NamedShape _ _ nmsh' mb_args |] &lt;- mbMatch $ fmap llvmBlockShape bp -&gt;</span>
<span class="lineno"> 4613 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: although nmsh' should equal nmsh, it's easier to just use nmsh'</span>
<span class="lineno"> 4614 </span><span class="spaces">      </span><span class="nottickedoff">-- rather than convince GHC that they have the same argument types</span>
<span class="lineno"> 4615 </span><span class="spaces">      </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4616 </span><span class="spaces">         </span><span class="nottickedoff">let args_ctx = mbLift $ fmap namedShapeArgs nmsh'</span>
<span class="lineno"> 4617 </span><span class="spaces">         </span><span class="nottickedoff">d &lt;- substNamedIndTpDesc (mbLift mb_sh_id) args_ctx mb_args</span>
<span class="lineno"> 4618 </span><span class="spaces">         </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4619 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4620 </span><span class="spaces">           </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4621 </span><span class="spaces">             </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4622 </span><span class="spaces">             </span><span class="nottickedoff">typeTransF ttrans [applyGlobalOpenTerm &quot;SpecM.unfoldTpElem&quot;</span>
<span class="lineno"> 4623 </span><span class="spaces">                                </span><span class="nottickedoff">[evTypeTerm ev, d, tupleOpenTerm' ts]])</span>
<span class="lineno"> 4624 </span><span class="spaces">           </span><span class="nottickedoff">m</span>
<span class="lineno"> 4625 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4626 </span><span class="spaces">  </span><span class="nottickedoff">-- Elim for a defined named shape (the other case) is a no-op</span>
<span class="lineno"> 4627 </span><span class="spaces">    </span><span class="nottickedoff">| [nuMP| DefinedShapeBody _ |] &lt;- mbMatch $ fmap namedShapeBody nmsh -&gt;</span>
<span class="lineno"> 4628 </span><span class="spaces">      </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4629 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4630 </span><span class="spaces">           </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4631 </span><span class="spaces">             </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4632 </span><span class="spaces">           </span><span class="nottickedoff">m</span>
<span class="lineno"> 4633 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4634 </span><span class="spaces">    </span><span class="nottickedoff">| otherwise -&gt;</span>
<span class="lineno"> 4635 </span><span class="spaces">        </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot; [&quot;ElimLLVMBlockNamed, unknown named shape&quot;]</span>
<span class="lineno"> 4636 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4637 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockNamedMods _ _ |] -&gt;</span>
<span class="lineno"> 4638 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4639 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4640 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4641 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4642 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4643 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4644 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockNamedMods _ _ |] -&gt;</span>
<span class="lineno"> 4645 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4646 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4647 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4648 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4649 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4650 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4651 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockFromEq _ _ _ |] -&gt;</span>
<span class="lineno"> 4652 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4653 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM RL.tail</span>
<span class="lineno"> 4654 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4655 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4656 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4657 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4658 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockPtr _ _ |] -&gt;</span>
<span class="lineno"> 4659 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4660 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4661 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4662 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4663 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4664 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4665 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockPtr _ _ |] -&gt;</span>
<span class="lineno"> 4666 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4667 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4668 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4669 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4670 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4671 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4672 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockField _ _ |] -&gt;</span>
<span class="lineno"> 4673 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4674 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4675 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4676 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans (tupleOpenTermList ts))</span>
<span class="lineno"> 4677 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4678 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4679 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockField _ _ |] -&gt;</span>
<span class="lineno"> 4680 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4681 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4682 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4683 </span><span class="spaces">           </span><span class="nottickedoff">-- We tuple both ttrans and ts because ts is either an empty list or</span>
<span class="lineno"> 4684 </span><span class="spaces">           </span><span class="nottickedoff">-- a tuple of the terms we want to pass to ttrans; tupling ts makes</span>
<span class="lineno"> 4685 </span><span class="spaces">           </span><span class="nottickedoff">-- it into a list of length 1</span>
<span class="lineno"> 4686 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF (tupleTypeTrans ttrans) [tupleOpenTerm' ts])</span>
<span class="lineno"> 4687 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4688 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4689 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockArray _ _ |] -&gt;</span>
<span class="lineno"> 4690 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4691 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4692 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4693 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans [termsExpect1 ts])</span>
<span class="lineno"> 4694 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4695 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4696 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockArray _ _ |] -&gt;</span>
<span class="lineno"> 4697 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4698 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4699 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4700 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4701 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4702 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4703 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockSeq _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4704 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4705 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM</span>
<span class="lineno"> 4706 </span><span class="spaces">         </span><span class="nottickedoff">(\(_ :&gt;: ptrans1 :&gt;: ptrans2) -&gt; (ptrans1,ptrans2))</span>
<span class="lineno"> 4707 </span><span class="spaces">         </span><span class="nottickedoff">RL.tail</span>
<span class="lineno"> 4708 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4709 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans (tupleOpenTermList ts))</span>
<span class="lineno"> 4710 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4711 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4712 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockSeq _ mb_bp mb_sh2 |] -&gt;</span>
<span class="lineno"> 4713 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4714 </span><span class="spaces">       </span><span class="nottickedoff">shtrans1 &lt;- unETransShape &lt;$&gt; translate (mbLLVMBlockShape mb_bp)</span>
<span class="lineno"> 4715 </span><span class="spaces">       </span><span class="nottickedoff">shtrans2 &lt;- unETransShape &lt;$&gt; translate mb_sh2</span>
<span class="lineno"> 4716 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4717 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4718 </span><span class="spaces">           </span><span class="nottickedoff">-- NOTE: if both output shapes have translations, then this rule</span>
<span class="lineno"> 4719 </span><span class="spaces">           </span><span class="nottickedoff">-- takes in a pair and projects its two components; otherwise its</span>
<span class="lineno"> 4720 </span><span class="spaces">           </span><span class="nottickedoff">-- output uses the same list of 0 or 1 terms as the input</span>
<span class="lineno"> 4721 </span><span class="spaces">           </span><span class="nottickedoff">let ts' = if isJust shtrans1 &amp;&amp; isJust shtrans2 then</span>
<span class="lineno"> 4722 </span><span class="spaces">                       </span><span class="nottickedoff">let t = termsExpect1 ts in [pairLeftOpenTerm t,</span>
<span class="lineno"> 4723 </span><span class="spaces">                                                   </span><span class="nottickedoff">pairRightOpenTerm t]</span>
<span class="lineno"> 4724 </span><span class="spaces">                     </span><span class="nottickedoff">else tupleOpenTermList ts in</span>
<span class="lineno"> 4725 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF ttrans ts')</span>
<span class="lineno"> 4726 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4727 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4728 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockOr _ _ _ |] -&gt;</span>
<span class="lineno"> 4729 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4730 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4731 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [termsExpect1 ts])</span>
<span class="lineno"> 4732 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4733 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4734 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockOr _ _ _ |] -&gt;</span>
<span class="lineno"> 4735 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4736 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4737 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [termsExpect1 ts])</span>
<span class="lineno"> 4738 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4739 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4740 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockEx _ _ |] -&gt;</span>
<span class="lineno"> 4741 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4742 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4743 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [termsExpect1 ts])</span>
<span class="lineno"> 4744 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4745 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4746 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockEx _ _ |] -&gt;</span>
<span class="lineno"> 4747 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4748 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4749 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [termsExpect1 ts])</span>
<span class="lineno"> 4750 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4751 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4752 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockFalse _ _ |] -&gt;</span>
<span class="lineno"> 4753 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4754 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4755 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans [termsExpect1 ts])</span>
<span class="lineno"> 4756 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4757 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4758 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_FoldNamed _ (NamedPerm_Rec mb_rp) mb_args _ |] -&gt;</span>
<span class="lineno"> 4759 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4760 </span><span class="spaces">       </span><span class="nottickedoff">let args_ctx = mbLift $ fmap (namedPermNameArgs . recPermName) mb_rp</span>
<span class="lineno"> 4761 </span><span class="spaces">       </span><span class="nottickedoff">let d_id = mbLift $ fmap recPermTransDesc mb_rp</span>
<span class="lineno"> 4762 </span><span class="spaces">       </span><span class="nottickedoff">d &lt;- substNamedIndTpDesc d_id args_ctx mb_args</span>
<span class="lineno"> 4763 </span><span class="spaces">       </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4764 </span><span class="spaces">       </span><span class="nottickedoff">unfolded_ptrans &lt;- getTopPermM</span>
<span class="lineno"> 4765 </span><span class="spaces">       </span><span class="nottickedoff">let folded_m = applyGlobalOpenTerm &quot;SpecM.foldTpElem&quot;</span>
<span class="lineno"> 4766 </span><span class="spaces">             </span><span class="nottickedoff">[evTypeTerm ev, d, transTupleTerm unfolded_ptrans]</span>
<span class="lineno"> 4767 </span><span class="spaces">       </span><span class="nottickedoff">bindTransM folded_m ttrans &quot;ind_val&quot; $ \ptrans -&gt;</span>
<span class="lineno"> 4768 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM id (\(pctx :&gt;: _) -&gt; pctx :&gt;: ptrans) m</span>
<span class="lineno"> 4769 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4770 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_UnfoldNamed _ (NamedPerm_Rec mb_rp) mb_args _ |] -&gt;</span>
<span class="lineno"> 4771 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4772 </span><span class="spaces">       </span><span class="nottickedoff">let args_ctx = mbLift $ fmap (namedPermNameArgs . recPermName) mb_rp</span>
<span class="lineno"> 4773 </span><span class="spaces">       </span><span class="nottickedoff">let d_id = mbLift $ fmap recPermTransDesc mb_rp</span>
<span class="lineno"> 4774 </span><span class="spaces">       </span><span class="nottickedoff">d &lt;- substNamedIndTpDesc d_id args_ctx mb_args</span>
<span class="lineno"> 4775 </span><span class="spaces">       </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 4776 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4777 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4778 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4779 </span><span class="spaces">           </span><span class="nottickedoff">typeTransF ttrans [applyGlobalOpenTerm &quot;SpecM.unfoldTpElem&quot;</span>
<span class="lineno"> 4780 </span><span class="spaces">                              </span><span class="nottickedoff">[evTypeTerm ev, d, tupleOpenTerm' ts]])</span>
<span class="lineno"> 4781 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4782 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4783 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_FoldNamed _ (NamedPerm_Defined _) _ _ |] -&gt;</span>
<span class="lineno"> 4784 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4785 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4786 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4787 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4788 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4789 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_UnfoldNamed _ (NamedPerm_Defined _) _ _ |] -&gt;</span>
<span class="lineno"> 4790 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4791 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4792 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4793 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4794 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4795 </span><span class="spaces">  </span><span class="nottickedoff">{-</span>
<span class="lineno"> 4796 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_Mu _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4797 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;FIXME HERE: SImpl_Mu: translation not yet implemented&quot;</span>
<span class="lineno"> 4798 </span><span class="spaces">  </span><span class="nottickedoff">-}</span>
<span class="lineno"> 4799 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4800 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_NamedToConj _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4801 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4802 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4803 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4804 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4805 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4806 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_NamedFromConj _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4807 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4808 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4809 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4810 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4811 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4812 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_NamedArgAlways _ _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4813 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4814 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4815 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4816 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4817 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4818 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_NamedArgCurrent _ _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4819 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4820 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM (\ (_ :&gt;: ptrans :&gt;: _) -&gt; ptrans)</span>
<span class="lineno"> 4821 </span><span class="spaces">         </span><span class="nottickedoff">RL.tail</span>
<span class="lineno"> 4822 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4823 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4824 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4825 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_NamedArgWrite _ _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4826 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4827 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4828 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4829 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4830 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4831 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_NamedArgRead _ _ _ _ _ |] -&gt;</span>
<span class="lineno"> 4832 </span><span class="spaces">    </span><span class="nottickedoff">do ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4833 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM id</span>
<span class="lineno"> 4834 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt; pctx :&gt;: typeTransF ttrans ts)</span>
<span class="lineno"> 4835 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4836 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4837 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ReachabilityTrans _ rp args _ y e |] -&gt;</span>
<span class="lineno"> 4838 </span><span class="spaces">    </span><span class="nottickedoff">do args_trans &lt;- translate args</span>
<span class="lineno"> 4839 </span><span class="spaces">       </span><span class="nottickedoff">e_trans &lt;- translate e</span>
<span class="lineno"> 4840 </span><span class="spaces">       </span><span class="nottickedoff">y_trans &lt;- translate y</span>
<span class="lineno"> 4841 </span><span class="spaces">       </span><span class="nottickedoff">ttrans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4842 </span><span class="spaces">       </span><span class="nottickedoff">let trans_ident = mbLift $ fmap recPermTransMethod rp</span>
<span class="lineno"> 4843 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTermsM</span>
<span class="lineno"> 4844 </span><span class="spaces">         </span><span class="nottickedoff">(\(_ :&gt;: ptrans_x :&gt;: ptrans_y) -&gt; (ptrans_x, ptrans_y))</span>
<span class="lineno"> 4845 </span><span class="spaces">         </span><span class="nottickedoff">RL.tail</span>
<span class="lineno"> 4846 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4847 </span><span class="spaces">           </span><span class="nottickedoff">if length ts == 2 then</span>
<span class="lineno"> 4848 </span><span class="spaces">             </span><span class="nottickedoff">pctx :&gt;:</span>
<span class="lineno"> 4849 </span><span class="spaces">             </span><span class="nottickedoff">typeTransF (tupleTypeTrans ttrans) [applyGlobalOpenTerm trans_ident</span>
<span class="lineno"> 4850 </span><span class="spaces">                                                 </span><span class="nottickedoff">(transTerms args_trans</span>
<span class="lineno"> 4851 </span><span class="spaces">                                                  </span><span class="nottickedoff">++ transTerms e_trans</span>
<span class="lineno"> 4852 </span><span class="spaces">                                                  </span><span class="nottickedoff">++ transTerms y_trans</span>
<span class="lineno"> 4853 </span><span class="spaces">                                                  </span><span class="nottickedoff">++ transTerms e_trans</span>
<span class="lineno"> 4854 </span><span class="spaces">                                                  </span><span class="nottickedoff">++ ts)]</span>
<span class="lineno"> 4855 </span><span class="spaces">           </span><span class="nottickedoff">else</span>
<span class="lineno"> 4856 </span><span class="spaces">             </span><span class="nottickedoff">panic &quot;translateSimplImpl&quot;</span>
<span class="lineno"> 4857 </span><span class="spaces">             </span><span class="nottickedoff">[&quot;SImpl_ReachabilityTrans: incorrect number of terms in translation&quot;])</span>
<span class="lineno"> 4858 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 4859 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4860 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroAnyEqEq _ _ _ |] -&gt;</span>
<span class="lineno"> 4861 </span><span class="spaces">    </span><span class="nottickedoff">do tp_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4862 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 4863 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4864 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tp_trans []) m</span>
<span class="lineno"> 4865 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4866 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_IntroAnyWordPtr _ _ _ |] -&gt;</span>
<span class="lineno"> 4867 </span><span class="spaces">    </span><span class="nottickedoff">do tp_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4868 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM RL.tail</span>
<span class="lineno"> 4869 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 4870 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tp_trans []) m</span>
<span class="lineno"> 4871 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4872 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimAnyToEq _ _ |] -&gt;</span>
<span class="lineno"> 4873 </span><span class="spaces">    </span><span class="nottickedoff">do tp_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4874 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4875 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4876 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tp_trans []) m</span>
<span class="lineno"> 4877 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4878 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| SImpl_ElimAnyToPtr _ _ |] -&gt;</span>
<span class="lineno"> 4879 </span><span class="spaces">    </span><span class="nottickedoff">do tp_trans &lt;- translateSimplImplOutHead mb_simpl</span>
<span class="lineno"> 4880 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 4881 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 4882 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tp_trans []) m</span></span>
<span class="lineno"> 4883 </span>
<span class="lineno"> 4884 </span>
<span class="lineno"> 4885 </span>-- | Translate a normal unary 'PermImpl1' rule that succeeds and applies the
<span class="lineno"> 4886 </span>-- translation function if the argument succeeds and fails if the translation of
<span class="lineno"> 4887 </span>-- the argument fails
<span class="lineno"> 4888 </span>translatePermImplUnary ::
<span class="lineno"> 4889 </span>  NuMatchingAny1 r =&gt; RL.TypeCtx bs =&gt;
<span class="lineno"> 4890 </span>  Mb ctx (MbPermImpls r (RNil :&gt; '(bs,ps_out))) -&gt;
<span class="lineno"> 4891 </span>  (ImpTransM ext blocks tops rets ps_out (ctx :++: bs) OpenTerm -&gt;
<span class="lineno"> 4892 </span>   ImpTransM ext blocks tops rets ps ctx OpenTerm) -&gt;
<span class="lineno"> 4893 </span>  PImplTransMTerm r ext blocks tops rets ps ctx
<span class="lineno"> 4894 </span><span class="decl"><span class="nottickedoff">translatePermImplUnary (mbMatch -&gt; [nuMP| MbPermImpls_Cons _ _ mb_impl |]) f =</span>
<span class="lineno"> 4895 </span><span class="spaces">  </span><span class="nottickedoff">let bs = RL.typeCtxProxies in</span>
<span class="lineno"> 4896 </span><span class="spaces">  </span><span class="nottickedoff">PImplTerm &lt;$&gt; fmap f &lt;$&gt; popPImplTerm &lt;$&gt;</span>
<span class="lineno"> 4897 </span><span class="spaces">  </span><span class="nottickedoff">extPermImplTransM bs (translatePermImpl (mbCombine bs mb_impl))</span></span>
<span class="lineno"> 4898 </span>
<span class="lineno"> 4899 </span>-- | Translate a 'PermImpl1' to a function on translation computations
<span class="lineno"> 4900 </span>translatePermImpl1 :: NuMatchingAny1 r =&gt;
<span class="lineno"> 4901 </span>                      Mb ctx (PermImpl1 ps ps_outs) -&gt;
<span class="lineno"> 4902 </span>                      Mb ctx (MbPermImpls r ps_outs) -&gt;
<span class="lineno"> 4903 </span>                      PImplTransMTerm r ext blocks tops rets ps ctx
<span class="lineno"> 4904 </span><span class="decl"><span class="nottickedoff">translatePermImpl1 mb_impl mb_impls = case (mbMatch mb_impl, mbMatch mb_impls) of</span>
<span class="lineno"> 4905 </span><span class="spaces">  </span><span class="nottickedoff">-- A failure translates to a call to the catch handler, which is the most recent</span>
<span class="lineno"> 4906 </span><span class="spaces">  </span><span class="nottickedoff">-- Impl1_Catch, if one exists, or the SAW errorM function otherwise</span>
<span class="lineno"> 4907 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_Fail err |], _) -&gt;</span>
<span class="lineno"> 4908 </span><span class="spaces">    </span><span class="nottickedoff">pimplFailM (mbLift (fmap ppError err))</span>
<span class="lineno"> 4909 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4910 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_Catch dbg_str |],</span>
<span class="lineno"> 4911 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| (MbPermImpls_Cons _ (MbPermImpls_Cons _ _ mb_impl1) mb_impl2) |]) -&gt;</span>
<span class="lineno"> 4912 </span><span class="spaces">    </span><span class="nottickedoff">pimplHandleFailM</span>
<span class="lineno"> 4913 </span><span class="spaces">    </span><span class="nottickedoff">(pimplPrependMsgM (&quot;Case 1 of &quot; ++ mbLift dbg_str) $</span>
<span class="lineno"> 4914 </span><span class="spaces">     </span><span class="nottickedoff">translatePermImpl $ mbCombine RL.typeCtxProxies mb_impl1)</span>
<span class="lineno"> 4915 </span><span class="spaces">    </span><span class="nottickedoff">(pimplPrependMsgM (&quot;Case 2 of &quot; ++ mbLift dbg_str) $</span>
<span class="lineno"> 4916 </span><span class="spaces">     </span><span class="nottickedoff">translatePermImpl $ mbCombine RL.typeCtxProxies mb_impl2)</span>
<span class="lineno"> 4917 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4918 </span><span class="spaces">  </span><span class="nottickedoff">-- A push moves the given permission from x to the top of the perm stack</span>
<span class="lineno"> 4919 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_Push x p |], _) -&gt;</span>
<span class="lineno"> 4920 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 4921 </span><span class="spaces">    </span><span class="nottickedoff">do () &lt;- assertVarPermM &quot;Impl1_Push&quot; x p</span>
<span class="lineno"> 4922 </span><span class="spaces">       </span><span class="nottickedoff">ptrans &lt;- getVarPermM x</span>
<span class="lineno"> 4923 </span><span class="spaces">       </span><span class="nottickedoff">setVarPermM x (PTrans_True)</span>
<span class="lineno"> 4924 </span><span class="spaces">         </span><span class="nottickedoff">(withPermStackM (:&gt;: translateVar x) (:&gt;: ptrans) m)</span>
<span class="lineno"> 4925 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4926 </span><span class="spaces">  </span><span class="nottickedoff">-- A pop moves the given permission from the top of the perm stack to x</span>
<span class="lineno"> 4927 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_Pop x p |], _) -&gt;</span>
<span class="lineno"> 4928 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 4929 </span><span class="spaces">    </span><span class="nottickedoff">do () &lt;- assertTopPermM &quot;Impl1_Pop 1&quot; x p</span>
<span class="lineno"> 4930 </span><span class="spaces">       </span><span class="nottickedoff">() &lt;- assertVarPermM &quot;Impl1_Pop 2&quot; x (nuMulti (mbToProxy p) $</span>
<span class="lineno"> 4931 </span><span class="spaces">                                             </span><span class="nottickedoff">const ValPerm_True)</span>
<span class="lineno"> 4932 </span><span class="spaces">       </span><span class="nottickedoff">ptrans &lt;- getTopPermM</span>
<span class="lineno"> 4933 </span><span class="spaces">       </span><span class="nottickedoff">setVarPermM x ptrans (withPermStackM RL.tail RL.tail m)</span>
<span class="lineno"> 4934 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4935 </span><span class="spaces">  </span><span class="nottickedoff">-- If all branches of an or elimination fail, the whole thing fails; otherwise,</span>
<span class="lineno"> 4936 </span><span class="spaces">  </span><span class="nottickedoff">-- an or elimination performs a multi way Eithers elimination</span>
<span class="lineno"> 4937 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ElimOrs dbg_str x mb_or_list |], _) -&gt;</span>
<span class="lineno"> 4938 </span><span class="spaces">    </span><span class="nottickedoff">-- First, translate all the PermImpls in mb_impls, using pitmCatching to</span>
<span class="lineno"> 4939 </span><span class="spaces">    </span><span class="nottickedoff">-- isolate failures to each particular branch, but still reporting failures</span>
<span class="lineno"> 4940 </span><span class="spaces">    </span><span class="nottickedoff">-- in any branch</span>
<span class="lineno"> 4941 </span><span class="spaces">    </span><span class="nottickedoff">zipWithM (\mb_impl' (i::Int) -&gt;</span>
<span class="lineno"> 4942 </span><span class="spaces">               </span><span class="nottickedoff">pimplPrependMsgM (&quot;Case &quot; ++ show i ++</span>
<span class="lineno"> 4943 </span><span class="spaces">                                 </span><span class="nottickedoff">&quot; of &quot; ++ mbLift dbg_str) $</span>
<span class="lineno"> 4944 </span><span class="spaces">               </span><span class="nottickedoff">pimplCatchM $ translatePermImpl mb_impl')</span>
<span class="lineno"> 4945 </span><span class="spaces">    </span><span class="nottickedoff">(mbOrListPermImpls mb_or_list mb_impls) [1..] &gt;&gt;= \maybe_transs -&gt;</span>
<span class="lineno"> 4946 </span><span class="spaces">    </span><span class="nottickedoff">-- As a special case, if all branches fail (representing as translating to</span>
<span class="lineno"> 4947 </span><span class="spaces">    </span><span class="nottickedoff">-- Nothing), then the entire or elimination fails</span>
<span class="lineno"> 4948 </span><span class="spaces">    </span><span class="nottickedoff">if all isNothing maybe_transs then mzero else</span>
<span class="lineno"> 4949 </span><span class="spaces">      </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 4950 </span><span class="spaces">      </span><span class="nottickedoff">do let mb_or_p = mbOrListPerm mb_or_list</span>
<span class="lineno"> 4951 </span><span class="spaces">         </span><span class="nottickedoff">() &lt;- assertTopPermM &quot;Impl1_ElimOrs&quot; x mb_or_p</span>
<span class="lineno"> 4952 </span><span class="spaces">         </span><span class="nottickedoff">tps &lt;- mapM translate $ mbOrListDisjs mb_or_list</span>
<span class="lineno"> 4953 </span><span class="spaces">         </span><span class="nottickedoff">tp_ret &lt;- compReturnTypeTransM</span>
<span class="lineno"> 4954 </span><span class="spaces">         </span><span class="nottickedoff">top_ptrans &lt;- getTopPermM</span>
<span class="lineno"> 4955 </span><span class="spaces">         </span><span class="nottickedoff">eithersElimTransM tps tp_ret</span>
<span class="lineno"> 4956 </span><span class="spaces">           </span><span class="nottickedoff">(flip map maybe_transs $ \maybe_trans ptrans -&gt;</span>
<span class="lineno"> 4957 </span><span class="spaces">             </span><span class="nottickedoff">withPermStackM id ((:&gt;: ptrans) . RL.tail) $</span>
<span class="lineno"> 4958 </span><span class="spaces">             </span><span class="nottickedoff">popPImplTerm (forcePImplTerm maybe_trans) k)</span>
<span class="lineno"> 4959 </span><span class="spaces">           </span><span class="nottickedoff">(transTerm1 top_ptrans)</span>
<span class="lineno"> 4960 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4961 </span><span class="spaces">  </span><span class="nottickedoff">-- An existential elimination performs a pattern-match on a Sigma</span>
<span class="lineno"> 4962 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ElimExists x p |], _) -&gt;</span>
<span class="lineno"> 4963 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 4964 </span><span class="spaces">    </span><span class="nottickedoff">do let tp = mbBindingType p</span>
<span class="lineno"> 4965 </span><span class="spaces">       </span><span class="nottickedoff">() &lt;- assertTopPermM &quot;Impl1_ElimExists&quot; x (fmap ValPerm_Exists p)</span>
<span class="lineno"> 4966 </span><span class="spaces">       </span><span class="nottickedoff">top_ptrans &lt;- getTopPermM</span>
<span class="lineno"> 4967 </span><span class="spaces">       </span><span class="nottickedoff">tp_trans &lt;- translateClosed tp</span>
<span class="lineno"> 4968 </span><span class="spaces">       </span><span class="nottickedoff">sigmaElimPermTransM &quot;x_elimEx&quot; tp_trans</span>
<span class="lineno"> 4969 </span><span class="spaces">         </span><span class="nottickedoff">(mbCombine RL.typeCtxProxies p)</span>
<span class="lineno"> 4970 </span><span class="spaces">         </span><span class="nottickedoff">compReturnTypeTransM</span>
<span class="lineno"> 4971 </span><span class="spaces">         </span><span class="nottickedoff">(\etrans ptrans -&gt;</span>
<span class="lineno"> 4972 </span><span class="spaces">           </span><span class="nottickedoff">inExtTransM etrans $</span>
<span class="lineno"> 4973 </span><span class="spaces">           </span><span class="nottickedoff">withPermStackM id ((:&gt;: ptrans) . RL.tail) m)</span>
<span class="lineno"> 4974 </span><span class="spaces">         </span><span class="nottickedoff">(transTerm1 top_ptrans)</span>
<span class="lineno"> 4975 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4976 </span><span class="spaces">  </span><span class="nottickedoff">-- A false elimination becomes a call to efq</span>
<span class="lineno"> 4977 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ElimFalse mb_x |], _) -&gt;</span>
<span class="lineno"> 4978 </span><span class="spaces">    </span><span class="nottickedoff">return $ PImplTerm $ const $</span>
<span class="lineno"> 4979 </span><span class="spaces">    </span><span class="nottickedoff">do mb_false &lt;- nuMultiTransM $ const ValPerm_False</span>
<span class="lineno"> 4980 </span><span class="spaces">       </span><span class="nottickedoff">() &lt;- assertTopPermM &quot;Impl1_ElimFalse&quot; mb_x mb_false</span>
<span class="lineno"> 4981 </span><span class="spaces">       </span><span class="nottickedoff">top_ptrans &lt;- getTopPermM</span>
<span class="lineno"> 4982 </span><span class="spaces">       </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.efq&quot; [compReturnTypeM,</span>
<span class="lineno"> 4983 </span><span class="spaces">                                        </span><span class="nottickedoff">return (transTerm1 top_ptrans)]</span>
<span class="lineno"> 4984 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4985 </span><span class="spaces">  </span><span class="nottickedoff">-- A SimplImpl is translated using translateSimplImpl</span>
<span class="lineno"> 4986 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_Simpl simpl mb_prx |], _) -&gt;</span>
<span class="lineno"> 4987 </span><span class="spaces">    </span><span class="nottickedoff">let prx' = mbLift mb_prx in</span>
<span class="lineno"> 4988 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 4989 </span><span class="spaces">    </span><span class="nottickedoff">assertPermStackTopEqM &quot;SimplImpl in&quot; prx' (fmap simplImplIn simpl) &gt;&gt;= \() -&gt;</span>
<span class="lineno"> 4990 </span><span class="spaces">    </span><span class="nottickedoff">translateSimplImpl prx' simpl $</span>
<span class="lineno"> 4991 </span><span class="spaces">    </span><span class="nottickedoff">do () &lt;- assertPermStackTopEqM &quot;SimplImpl out&quot; prx' (fmap simplImplOut simpl)</span>
<span class="lineno"> 4992 </span><span class="spaces">       </span><span class="nottickedoff">m</span>
<span class="lineno"> 4993 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4994 </span><span class="spaces">  </span><span class="nottickedoff">-- A let binding becomes a let binding</span>
<span class="lineno"> 4995 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_LetBind _ e |], _) -&gt;</span>
<span class="lineno"> 4996 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 4997 </span><span class="spaces">    </span><span class="nottickedoff">do etrans &lt;- translate e</span>
<span class="lineno"> 4998 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransM etrans $</span>
<span class="lineno"> 4999 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: PTrans_Eq (extMb e)) m</span>
<span class="lineno"> 5000 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5001 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ElimStructField x _ _ memb |], _) -&gt;</span>
<span class="lineno"> 5002 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5003 </span><span class="spaces">    </span><span class="nottickedoff">do etrans_x &lt;- translate x</span>
<span class="lineno"> 5004 </span><span class="spaces">       </span><span class="nottickedoff">let etrans_y = case etrans_x of</span>
<span class="lineno"> 5005 </span><span class="spaces">             </span><span class="nottickedoff">ETrans_Struct flds -&gt; RL.get (mbLift memb) flds</span>
<span class="lineno"> 5006 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;translatePermImpl1: Impl1_ElimStructField&quot;</span>
<span class="lineno"> 5007 </span><span class="spaces">       </span><span class="nottickedoff">let mb_y = mbCombine RL.typeCtxProxies $ fmap (const $ nu $ \y -&gt;</span>
<span class="lineno"> 5008 </span><span class="spaces">                                                       </span><span class="nottickedoff">PExpr_Var y) x</span>
<span class="lineno"> 5009 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransM etrans_y $</span>
<span class="lineno"> 5010 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base)</span>
<span class="lineno"> 5011 </span><span class="spaces">         </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 5012 </span><span class="spaces">             </span><span class="nottickedoff">(pctx :&gt;: PTrans_Conj [APTrans_Struct pctx_str]) -&gt;</span>
<span class="lineno"> 5013 </span><span class="spaces">               </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [APTrans_Struct $</span>
<span class="lineno"> 5014 </span><span class="spaces">                                     </span><span class="nottickedoff">RL.set (mbLift memb) (PTrans_Eq mb_y) pctx_str]</span>
<span class="lineno"> 5015 </span><span class="spaces">               </span><span class="nottickedoff">:&gt;: RL.get (mbLift memb) pctx_str</span>
<span class="lineno"> 5016 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 5017 </span><span class="spaces">               </span><span class="nottickedoff">error &quot;translatePermImpl1: Impl1_ElimStructField&quot;)</span>
<span class="lineno"> 5018 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 5019 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5020 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ElimLLVMFieldContents _ mb_fld |], _) -&gt;</span>
<span class="lineno"> 5021 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5022 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 5023 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base)</span>
<span class="lineno"> 5024 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: ptrans_x) -&gt;</span>
<span class="lineno"> 5025 </span><span class="spaces">      </span><span class="nottickedoff">let (_,ptrans') =</span>
<span class="lineno"> 5026 </span><span class="spaces">            </span><span class="nottickedoff">unPTransLLVMField &quot;translatePermImpl1: Impl1_ElimLLVMFieldContents&quot;</span>
<span class="lineno"> 5027 </span><span class="spaces">            </span><span class="nottickedoff">knownNat ptrans_x in</span>
<span class="lineno"> 5028 </span><span class="spaces">      </span><span class="nottickedoff">pctx :&gt;: PTrans_Conj [</span>
<span class="lineno"> 5029 </span><span class="spaces">        </span><span class="nottickedoff">APTrans_LLVMField</span>
<span class="lineno"> 5030 </span><span class="spaces">        </span><span class="nottickedoff">(mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5031 </span><span class="spaces">         </span><span class="nottickedoff">mbMapCl $(mkClosed [| \fld -&gt; nu $ \y -&gt;</span>
<span class="lineno"> 5032 </span><span class="spaces">                              </span><span class="nottickedoff">llvmFieldSetEqVar fld y |]) mb_fld) $</span>
<span class="lineno"> 5033 </span><span class="spaces">        </span><span class="nottickedoff">PTrans_Eq (mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5034 </span><span class="spaces">                   </span><span class="nottickedoff">fmap (const $ nu PExpr_Var) mb_fld)]</span>
<span class="lineno"> 5035 </span><span class="spaces">      </span><span class="nottickedoff">:&gt;: ptrans')</span>
<span class="lineno"> 5036 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5037 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5038 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ElimLLVMBlockToEq _ mb_bp |], _) -&gt;</span>
<span class="lineno"> 5039 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5040 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVMBlock $</span>
<span class="lineno"> 5041 </span><span class="spaces">    </span><span class="nottickedoff">do let mb_p_out1 =</span>
<span class="lineno"> 5042 </span><span class="spaces">             </span><span class="nottickedoff">mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5043 </span><span class="spaces">             </span><span class="nottickedoff">mbMapCl $(mkClosed</span>
<span class="lineno"> 5044 </span><span class="spaces">                       </span><span class="nottickedoff">[| \bp -&gt; nu $ \y -&gt;</span>
<span class="lineno"> 5045 </span><span class="spaces">                         </span><span class="nottickedoff">let len = llvmBlockLen bp in</span>
<span class="lineno"> 5046 </span><span class="spaces">                         </span><span class="nottickedoff">ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 5047 </span><span class="spaces">                         </span><span class="nottickedoff">bp { llvmBlockShape =</span>
<span class="lineno"> 5048 </span><span class="spaces">                                </span><span class="nottickedoff">PExpr_EqShape len $ PExpr_Var y } |])</span>
<span class="lineno"> 5049 </span><span class="spaces">             </span><span class="nottickedoff">mb_bp</span>
<span class="lineno"> 5050 </span><span class="spaces">       </span><span class="nottickedoff">tp_trans1 &lt;- translate mb_p_out1</span>
<span class="lineno"> 5051 </span><span class="spaces">       </span><span class="nottickedoff">let mb_p_out2 =</span>
<span class="lineno"> 5052 </span><span class="spaces">             </span><span class="nottickedoff">mbMapCl $(mkClosed</span>
<span class="lineno"> 5053 </span><span class="spaces">                       </span><span class="nottickedoff">[| ValPerm_Conj1</span>
<span class="lineno"> 5054 </span><span class="spaces">                        </span><span class="nottickedoff">. Perm_LLVMBlockShape . modalizeBlockShape |]) $</span>
<span class="lineno"> 5055 </span><span class="spaces">             </span><span class="nottickedoff">extMb mb_bp</span>
<span class="lineno"> 5056 </span><span class="spaces">       </span><span class="nottickedoff">tp_trans2 &lt;- translate mb_p_out2</span>
<span class="lineno"> 5057 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackTopTermsM (:&gt;: Member_Base)</span>
<span class="lineno"> 5058 </span><span class="spaces">         </span><span class="nottickedoff">(\ts (pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 5059 </span><span class="spaces">           </span><span class="nottickedoff">pctx :&gt;: typeTransF tp_trans1 [] :&gt;: typeTransF tp_trans2 ts)</span>
<span class="lineno"> 5060 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 5061 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5062 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_SplitLLVMWordField _ mb_fp mb_sz1 mb_endianness |], _) -&gt;</span>
<span class="lineno"> 5063 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5064 </span><span class="spaces">    </span><span class="nottickedoff">do let mb_e = case mbLLVMFieldContents mb_fp of</span>
<span class="lineno"> 5065 </span><span class="spaces">             </span><span class="nottickedoff">[nuP| ValPerm_Eq (PExpr_LLVMWord e) |] -&gt; e</span>
<span class="lineno"> 5066 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;translatePermImpl1: Impl1_SplitLLVMWordField&quot;</span>
<span class="lineno"> 5067 </span><span class="spaces">       </span><span class="nottickedoff">e_tm &lt;- translate1 mb_e</span>
<span class="lineno"> 5068 </span><span class="spaces">       </span><span class="nottickedoff">sz1_tm &lt;- translate mb_sz1</span>
<span class="lineno"> 5069 </span><span class="spaces">       </span><span class="nottickedoff">sz2_tm &lt;- translateClosed $ mbLLVMFieldSize mb_fp</span>
<span class="lineno"> 5070 </span><span class="spaces">       </span><span class="nottickedoff">let sz2m1_tm = applyGlobalOpenTerm &quot;Prelude.subNat&quot; [sz2_tm, sz1_tm]</span>
<span class="lineno"> 5071 </span><span class="spaces">       </span><span class="nottickedoff">let (e1_tm,e2_tm) =</span>
<span class="lineno"> 5072 </span><span class="spaces">             </span><span class="nottickedoff">bvSplitOpenTerm (mbLift mb_endianness) sz1_tm sz2m1_tm e_tm</span>
<span class="lineno"> 5073 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransM (ETrans_Term knownRepr e1_tm) $</span>
<span class="lineno"> 5074 </span><span class="spaces">         </span><span class="nottickedoff">inExtTransM (ETrans_Term knownRepr e2_tm) $</span>
<span class="lineno"> 5075 </span><span class="spaces">         </span><span class="nottickedoff">translate</span>
<span class="lineno"> 5076 </span><span class="spaces">         </span><span class="nottickedoff">(mbCombine RL.typeCtxProxies $ flip mbMapCl mb_fp</span>
<span class="lineno"> 5077 </span><span class="spaces">          </span><span class="nottickedoff">($(mkClosed</span>
<span class="lineno"> 5078 </span><span class="spaces">             </span><span class="nottickedoff">[| \sz1 endianness fp -&gt;</span>
<span class="lineno"> 5079 </span><span class="spaces">               </span><span class="nottickedoff">impl1SplitLLVMWordFieldOutPerms fp sz1 endianness |])</span>
<span class="lineno"> 5080 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` toClosed (mbLift mb_sz1)</span>
<span class="lineno"> 5081 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` toClosed (mbLift mb_endianness))) &gt;&gt;= \pctx_out -&gt;</span>
<span class="lineno"> 5082 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 5083 </span><span class="spaces">         </span><span class="nottickedoff">(\(vars :&gt;: x) -&gt; vars :&gt;: x :&gt;: x :&gt;:</span>
<span class="lineno"> 5084 </span><span class="spaces">                           </span><span class="nottickedoff">Member_Step Member_Base :&gt;: Member_Base)</span>
<span class="lineno"> 5085 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 5086 </span><span class="spaces">           </span><span class="nottickedoff">-- NOTE: all output perms are eq or ptr to eq perms, so contain no</span>
<span class="lineno"> 5087 </span><span class="spaces">           </span><span class="nottickedoff">-- SAW core terms</span>
<span class="lineno"> 5088 </span><span class="spaces">           </span><span class="nottickedoff">pctx `RL.append` typeTransF pctx_out [])</span>
<span class="lineno"> 5089 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 5090 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5091 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TruncateLLVMWordField _ mb_fp mb_sz1 mb_endianness |], _) -&gt;</span>
<span class="lineno"> 5092 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5093 </span><span class="spaces">    </span><span class="nottickedoff">do let mb_e = case mbLLVMFieldContents mb_fp of</span>
<span class="lineno"> 5094 </span><span class="spaces">             </span><span class="nottickedoff">[nuP| ValPerm_Eq (PExpr_LLVMWord e) |] -&gt; e</span>
<span class="lineno"> 5095 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;translatePermImpl1: Impl1_TruncateLLVMWordField&quot;</span>
<span class="lineno"> 5096 </span><span class="spaces">       </span><span class="nottickedoff">e_tm &lt;- translate1 mb_e</span>
<span class="lineno"> 5097 </span><span class="spaces">       </span><span class="nottickedoff">sz1_tm &lt;- translate mb_sz1</span>
<span class="lineno"> 5098 </span><span class="spaces">       </span><span class="nottickedoff">sz2_tm &lt;- translateClosed $ mbLLVMFieldSize mb_fp</span>
<span class="lineno"> 5099 </span><span class="spaces">       </span><span class="nottickedoff">let sz2m1_tm = applyGlobalOpenTerm &quot;Prelude.subNat&quot; [sz2_tm, sz1_tm]</span>
<span class="lineno"> 5100 </span><span class="spaces">       </span><span class="nottickedoff">let (e1_tm,_) =</span>
<span class="lineno"> 5101 </span><span class="spaces">             </span><span class="nottickedoff">bvSplitOpenTerm (mbLift mb_endianness) sz1_tm sz2m1_tm e_tm</span>
<span class="lineno"> 5102 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransM (ETrans_Term knownRepr e1_tm) $</span>
<span class="lineno"> 5103 </span><span class="spaces">         </span><span class="nottickedoff">translate</span>
<span class="lineno"> 5104 </span><span class="spaces">         </span><span class="nottickedoff">(mbCombine RL.typeCtxProxies $ flip mbMapCl mb_fp</span>
<span class="lineno"> 5105 </span><span class="spaces">          </span><span class="nottickedoff">($(mkClosed</span>
<span class="lineno"> 5106 </span><span class="spaces">             </span><span class="nottickedoff">[| \sz1 endianness fp -&gt;</span>
<span class="lineno"> 5107 </span><span class="spaces">               </span><span class="nottickedoff">impl1TruncateLLVMWordFieldOutPerms fp sz1 endianness |])</span>
<span class="lineno"> 5108 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` toClosed (mbLift mb_sz1)</span>
<span class="lineno"> 5109 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` toClosed (mbLift mb_endianness))) &gt;&gt;= \pctx_out -&gt;</span>
<span class="lineno"> 5110 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base)</span>
<span class="lineno"> 5111 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 5112 </span><span class="spaces">           </span><span class="nottickedoff">-- NOTE: all output perms are eq or ptr to eq perms, so contain no</span>
<span class="lineno"> 5113 </span><span class="spaces">           </span><span class="nottickedoff">-- SAW core terms</span>
<span class="lineno"> 5114 </span><span class="spaces">           </span><span class="nottickedoff">pctx `RL.append` typeTransF pctx_out [])</span>
<span class="lineno"> 5115 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 5116 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5117 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_ConcatLLVMWordFields _ mb_fp1 mb_e2 mb_endianness |], _) -&gt;</span>
<span class="lineno"> 5118 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5119 </span><span class="spaces">    </span><span class="nottickedoff">do let mb_e1 = case mbLLVMFieldContents mb_fp1 of</span>
<span class="lineno"> 5120 </span><span class="spaces">             </span><span class="nottickedoff">[nuP| ValPerm_Eq (PExpr_LLVMWord e1) |] -&gt; e1</span>
<span class="lineno"> 5121 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;translatePermImpl1: Impl1_ConcatLLVMWordFields&quot;</span>
<span class="lineno"> 5122 </span><span class="spaces">       </span><span class="nottickedoff">e1_tm &lt;- translate1 mb_e1</span>
<span class="lineno"> 5123 </span><span class="spaces">       </span><span class="nottickedoff">e2_tm &lt;- translate1 mb_e2</span>
<span class="lineno"> 5124 </span><span class="spaces">       </span><span class="nottickedoff">sz1_tm &lt;- translateClosed $ mbLLVMFieldSize mb_fp1</span>
<span class="lineno"> 5125 </span><span class="spaces">       </span><span class="nottickedoff">sz2_tm &lt;- translateClosed $ mbExprBVTypeWidth mb_e2</span>
<span class="lineno"> 5126 </span><span class="spaces">       </span><span class="nottickedoff">let endianness = mbLift mb_endianness</span>
<span class="lineno"> 5127 </span><span class="spaces">       </span><span class="nottickedoff">let e_tm = bvConcatOpenTerm endianness sz1_tm sz2_tm e1_tm e2_tm</span>
<span class="lineno"> 5128 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransM (ETrans_Term knownRepr e_tm) $</span>
<span class="lineno"> 5129 </span><span class="spaces">         </span><span class="nottickedoff">translate (mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5130 </span><span class="spaces">                    </span><span class="nottickedoff">mbMap2 (\fp1 e2 -&gt;</span>
<span class="lineno"> 5131 </span><span class="spaces">                             </span><span class="nottickedoff">impl1ConcatLLVMWordFieldsOutPerms fp1 e2 endianness)</span>
<span class="lineno"> 5132 </span><span class="spaces">                    </span><span class="nottickedoff">mb_fp1 mb_e2) &gt;&gt;= \pctx_out -&gt;</span>
<span class="lineno"> 5133 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 5134 </span><span class="spaces">         </span><span class="nottickedoff">(\(vars :&gt;: x :&gt;: _) -&gt; (vars :&gt;: x :&gt;: Member_Base))</span>
<span class="lineno"> 5135 </span><span class="spaces">         </span><span class="nottickedoff">(\(pctx :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 5136 </span><span class="spaces">           </span><span class="nottickedoff">-- NOTE: all output perms are eq or ptr to eq perms, so contain no</span>
<span class="lineno"> 5137 </span><span class="spaces">           </span><span class="nottickedoff">-- SAW core terms</span>
<span class="lineno"> 5138 </span><span class="spaces">           </span><span class="nottickedoff">pctx `RL.append` typeTransF pctx_out [])</span>
<span class="lineno"> 5139 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 5140 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5141 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_BeginLifetime |], _) -&gt;</span>
<span class="lineno"> 5142 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5143 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_Lifetime $</span>
<span class="lineno"> 5144 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 5145 </span><span class="spaces">       </span><span class="nottickedoff">ectx &lt;- infoCtx &lt;$&gt; ask</span>
<span class="lineno"> 5146 </span><span class="spaces">       </span><span class="nottickedoff">let prxs = RL.map (const Proxy) ectx</span>
<span class="lineno"> 5147 </span><span class="spaces">       </span><span class="nottickedoff">let mb_ps = (nuMulti prxs (const MNil))</span>
<span class="lineno"> 5148 </span><span class="spaces">       </span><span class="nottickedoff">let ttr = pure MNil</span>
<span class="lineno"> 5149 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base)</span>
<span class="lineno"> 5150 </span><span class="spaces">         </span><span class="nottickedoff">(:&gt;:</span>
<span class="lineno"> 5151 </span><span class="spaces">          </span><span class="nottickedoff">PTrans_LOwned</span>
<span class="lineno"> 5152 </span><span class="spaces">          </span><span class="nottickedoff">(nuMulti prxs (const [])) CruCtxNil CruCtxNil mb_ps mb_ps</span>
<span class="lineno"> 5153 </span><span class="spaces">          </span><span class="nottickedoff">(mkLOwnedTransId ev ectx ttr ttr MNil))</span>
<span class="lineno"> 5154 </span><span class="spaces">         </span><span class="nottickedoff">m</span>
<span class="lineno"> 5155 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5156 </span><span class="spaces">  </span><span class="nottickedoff">-- If e1 and e2 are already equal, short-circuit the proof construction and then</span>
<span class="lineno"> 5157 </span><span class="spaces">  </span><span class="nottickedoff">-- elimination</span>
<span class="lineno"> 5158 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_Eq e1 e2) _ |], _)</span>
<span class="lineno"> 5159 </span><span class="spaces">    </span><span class="nottickedoff">| mbLift (mbMap2 bvEq e1 e2) -&gt;</span>
<span class="lineno"> 5160 </span><span class="spaces">      </span><span class="nottickedoff">translatePermImplUnary mb_impls $ \m -&gt;</span>
<span class="lineno"> 5161 </span><span class="spaces">      </span><span class="nottickedoff">do bv_tp &lt;- typeTransType1 &lt;$&gt; translateClosed (mbExprType e1)</span>
<span class="lineno"> 5162 </span><span class="spaces">         </span><span class="nottickedoff">e1_trans &lt;- translate1 e1</span>
<span class="lineno"> 5163 </span><span class="spaces">         </span><span class="nottickedoff">let pf = ctorOpenTerm &quot;Prelude.Refl&quot; [bv_tp, e1_trans]</span>
<span class="lineno"> 5164 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 5165 </span><span class="spaces">           </span><span class="nottickedoff">(:&gt;: PTrans_Conj [APTrans_BVProp (BVPropTrans prop pf)])</span>
<span class="lineno"> 5166 </span><span class="spaces">           </span><span class="nottickedoff">m</span>
<span class="lineno"> 5167 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5168 </span><span class="spaces">  </span><span class="nottickedoff">-- If e1 and e2 are definitely not equal, treat this as a fail</span>
<span class="lineno"> 5169 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp _ (BVProp_Eq e1 e2) prop_str |], _)</span>
<span class="lineno"> 5170 </span><span class="spaces">    </span><span class="nottickedoff">| not $ mbLift (mbMap2 bvCouldEqual e1 e2) -&gt;</span>
<span class="lineno"> 5171 </span><span class="spaces">      </span><span class="nottickedoff">pimplFailM (mbLift prop_str)</span>
<span class="lineno"> 5172 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5173 </span><span class="spaces">  </span><span class="nottickedoff">-- Otherwise, insert an equality test with proof construction. Note that, as</span>
<span class="lineno"> 5174 </span><span class="spaces">  </span><span class="nottickedoff">-- with all TryProveBVProps, if the test fails and there is no failure</span>
<span class="lineno"> 5175 </span><span class="spaces">  </span><span class="nottickedoff">-- continuation, we insert just the proposition failure string using</span>
<span class="lineno"> 5176 </span><span class="spaces">  </span><span class="nottickedoff">-- implTransAltErr, not the entire type-checking error message, because this is</span>
<span class="lineno"> 5177 </span><span class="spaces">  </span><span class="nottickedoff">-- considered just an assertion and not a failure</span>
<span class="lineno"> 5178 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_Eq e1 e2) prop_str |],</span>
<span class="lineno"> 5179 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |]) -&gt;</span>
<span class="lineno"> 5180 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5181 </span><span class="spaces">    </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5182 </span><span class="spaces">    </span><span class="nottickedoff">do prop_tp_trans &lt;- translate prop</span>
<span class="lineno"> 5183 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp_m &lt;- compReturnTypeM</span>
<span class="lineno"> 5184 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 5185 </span><span class="spaces">       </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ifBvEqWithProof&quot;</span>
<span class="lineno"> 5186 </span><span class="spaces">         </span><span class="nottickedoff">[ return ret_tp_m</span>
<span class="lineno"> 5187 </span><span class="spaces">         </span><span class="nottickedoff">, return (natOpenTerm $ natVal2 prop), translate1 e1, translate1 e2</span>
<span class="lineno"> 5188 </span><span class="spaces">         </span><span class="nottickedoff">, return (implFailAltContTerm ret_tp (mbLift prop_str) k)</span>
<span class="lineno"> 5189 </span><span class="spaces">         </span><span class="nottickedoff">, lambdaTransM &quot;eq_pf&quot; prop_tp_trans</span>
<span class="lineno"> 5190 </span><span class="spaces">           </span><span class="nottickedoff">(\prop_trans -&gt;</span>
<span class="lineno"> 5191 </span><span class="spaces">             </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x) (:&gt;: bvPropPerm prop_trans) $</span>
<span class="lineno"> 5192 </span><span class="spaces">             </span><span class="nottickedoff">popPImplTerm trans k)</span>
<span class="lineno"> 5193 </span><span class="spaces">         </span><span class="nottickedoff">]</span>
<span class="lineno"> 5194 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5195 </span><span class="spaces">  </span><span class="nottickedoff">-- If e1 and e2 are already unequal, short-circuit and do nothing</span>
<span class="lineno"> 5196 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_Neq e1 e2) _ |], _)</span>
<span class="lineno"> 5197 </span><span class="spaces">    </span><span class="nottickedoff">| not $ mbLift (mbMap2 bvCouldEqual e1 e2) -&gt;</span>
<span class="lineno"> 5198 </span><span class="spaces">      </span><span class="nottickedoff">translatePermImplUnary mb_impls $</span>
<span class="lineno"> 5199 </span><span class="spaces">        </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 5200 </span><span class="spaces">          </span><span class="nottickedoff">(:&gt;: PTrans_Conj [APTrans_BVProp (BVPropTrans prop unitOpenTerm)])</span>
<span class="lineno"> 5201 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5202 </span><span class="spaces">  </span><span class="nottickedoff">-- For an inequality test, we don't need a proof, so just insert an if</span>
<span class="lineno"> 5203 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_Neq e1 e2) prop_str |],</span>
<span class="lineno"> 5204 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |]) -&gt;</span>
<span class="lineno"> 5205 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5206 </span><span class="spaces">    </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5207 </span><span class="spaces">    </span><span class="nottickedoff">let w = natVal2 prop in</span>
<span class="lineno"> 5208 </span><span class="spaces">    </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ite&quot;</span>
<span class="lineno"> 5209 </span><span class="spaces">    </span><span class="nottickedoff">[ compReturnTypeM</span>
<span class="lineno"> 5210 </span><span class="spaces">    </span><span class="nottickedoff">, applyGlobalTransM &quot;Prelude.bvEq&quot;</span>
<span class="lineno"> 5211 </span><span class="spaces">      </span><span class="nottickedoff">[ return (natOpenTerm w), translate1 e1, translate1 e2 ]</span>
<span class="lineno"> 5212 </span><span class="spaces">    </span><span class="nottickedoff">, (\ret_tp -&gt;</span>
<span class="lineno"> 5213 </span><span class="spaces">        </span><span class="nottickedoff">implFailAltContTerm ret_tp (mbLift prop_str) k) &lt;$&gt; returnTypeM</span>
<span class="lineno"> 5214 </span><span class="spaces">    </span><span class="nottickedoff">, withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 5215 </span><span class="spaces">      </span><span class="nottickedoff">(:&gt;: PTrans_Conj [APTrans_BVProp (BVPropTrans prop unitOpenTerm)]) $</span>
<span class="lineno"> 5216 </span><span class="spaces">      </span><span class="nottickedoff">popPImplTerm trans k]</span>
<span class="lineno"> 5217 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5218 </span><span class="spaces">  </span><span class="nottickedoff">-- If we know e1 &lt; e2 statically, translate to unsafeAssert</span>
<span class="lineno"> 5219 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_ULt e1 e2) _ |],</span>
<span class="lineno"> 5220 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |])</span>
<span class="lineno"> 5221 </span><span class="spaces">    </span><span class="nottickedoff">| mbLift (fmap bvPropHolds prop) -&gt;</span>
<span class="lineno"> 5222 </span><span class="spaces">      </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5223 </span><span class="spaces">      </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5224 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 5225 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 5226 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 5227 </span><span class="spaces">         </span><span class="nottickedoff">let pf_tm =</span>
<span class="lineno"> 5228 </span><span class="spaces">               </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.unsafeAssertBVULt&quot;</span>
<span class="lineno"> 5229 </span><span class="spaces">               </span><span class="nottickedoff">[natOpenTerm w, t1, t2]</span>
<span class="lineno"> 5230 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 5231 </span><span class="spaces">           </span><span class="nottickedoff">(:&gt;: bvPropPerm (BVPropTrans prop pf_tm))</span>
<span class="lineno"> 5232 </span><span class="spaces">           </span><span class="nottickedoff">(popPImplTerm trans k)</span>
<span class="lineno"> 5233 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5234 </span><span class="spaces">  </span><span class="nottickedoff">-- If we don't know e1 &lt; e2 statically, translate to ifWithProof of bvult</span>
<span class="lineno"> 5235 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_ULt e1 e2) prop_str |],</span>
<span class="lineno"> 5236 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |]) -&gt;</span>
<span class="lineno"> 5237 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5238 </span><span class="spaces">    </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5239 </span><span class="spaces">    </span><span class="nottickedoff">do prop_tp_trans &lt;- translate prop</span>
<span class="lineno"> 5240 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp_m &lt;- compReturnTypeM</span>
<span class="lineno"> 5241 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 5242 </span><span class="spaces">       </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ifWithProof&quot;</span>
<span class="lineno"> 5243 </span><span class="spaces">         </span><span class="nottickedoff">[ return ret_tp_m</span>
<span class="lineno"> 5244 </span><span class="spaces">         </span><span class="nottickedoff">, applyGlobalTransM &quot;Prelude.bvult&quot;</span>
<span class="lineno"> 5245 </span><span class="spaces">           </span><span class="nottickedoff">[ return (natOpenTerm $ natVal2 prop), translate1 e1, translate1 e2 ]</span>
<span class="lineno"> 5246 </span><span class="spaces">         </span><span class="nottickedoff">, return (implFailAltContTerm ret_tp (mbLift prop_str) k)</span>
<span class="lineno"> 5247 </span><span class="spaces">         </span><span class="nottickedoff">, lambdaTransM &quot;ult_pf&quot; prop_tp_trans</span>
<span class="lineno"> 5248 </span><span class="spaces">           </span><span class="nottickedoff">(\prop_trans -&gt;</span>
<span class="lineno"> 5249 </span><span class="spaces">             </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x) (:&gt;: bvPropPerm prop_trans) $</span>
<span class="lineno"> 5250 </span><span class="spaces">             </span><span class="nottickedoff">popPImplTerm trans k)</span>
<span class="lineno"> 5251 </span><span class="spaces">         </span><span class="nottickedoff">]</span>
<span class="lineno"> 5252 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5253 </span><span class="spaces">  </span><span class="nottickedoff">-- If we know e1 &lt;= e2 statically, translate to unsafeAssert</span>
<span class="lineno"> 5254 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_ULeq e1 e2) _ |],</span>
<span class="lineno"> 5255 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |])</span>
<span class="lineno"> 5256 </span><span class="spaces">    </span><span class="nottickedoff">| mbLift (fmap bvPropHolds prop) -&gt;</span>
<span class="lineno"> 5257 </span><span class="spaces">      </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5258 </span><span class="spaces">      </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5259 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 5260 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 5261 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 5262 </span><span class="spaces">         </span><span class="nottickedoff">let pf_tm =</span>
<span class="lineno"> 5263 </span><span class="spaces">               </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.unsafeAssertBVULe&quot;</span>
<span class="lineno"> 5264 </span><span class="spaces">               </span><span class="nottickedoff">[natOpenTerm w, t1, t2]</span>
<span class="lineno"> 5265 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 5266 </span><span class="spaces">           </span><span class="nottickedoff">(:&gt;: bvPropPerm (BVPropTrans prop pf_tm))</span>
<span class="lineno"> 5267 </span><span class="spaces">           </span><span class="nottickedoff">(popPImplTerm trans k)</span>
<span class="lineno"> 5268 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5269 </span><span class="spaces">  </span><span class="nottickedoff">-- If we don't know e1 &lt;= e2 statically, translate to ifWithProof of bvule</span>
<span class="lineno"> 5270 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_ULeq e1 e2) prop_str |],</span>
<span class="lineno"> 5271 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |]) -&gt;</span>
<span class="lineno"> 5272 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5273 </span><span class="spaces">    </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5274 </span><span class="spaces">    </span><span class="nottickedoff">do prop_tp_trans &lt;- translate prop</span>
<span class="lineno"> 5275 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp_m &lt;- compReturnTypeM</span>
<span class="lineno"> 5276 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 5277 </span><span class="spaces">       </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ifWithProof&quot;</span>
<span class="lineno"> 5278 </span><span class="spaces">         </span><span class="nottickedoff">[ return ret_tp_m</span>
<span class="lineno"> 5279 </span><span class="spaces">         </span><span class="nottickedoff">, applyGlobalTransM &quot;Prelude.bvule&quot;</span>
<span class="lineno"> 5280 </span><span class="spaces">           </span><span class="nottickedoff">[ return (natOpenTerm $ natVal2 prop), translate1 e1, translate1 e2 ]</span>
<span class="lineno"> 5281 </span><span class="spaces">         </span><span class="nottickedoff">, return (implFailAltContTerm ret_tp (mbLift prop_str) k)</span>
<span class="lineno"> 5282 </span><span class="spaces">         </span><span class="nottickedoff">, lambdaTransM &quot;ule_pf&quot; prop_tp_trans</span>
<span class="lineno"> 5283 </span><span class="spaces">           </span><span class="nottickedoff">(\prop_trans -&gt;</span>
<span class="lineno"> 5284 </span><span class="spaces">             </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x) (:&gt;: bvPropPerm prop_trans) $</span>
<span class="lineno"> 5285 </span><span class="spaces">             </span><span class="nottickedoff">popPImplTerm trans k)</span>
<span class="lineno"> 5286 </span><span class="spaces">         </span><span class="nottickedoff">]</span>
<span class="lineno"> 5287 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5288 </span><span class="spaces">  </span><span class="nottickedoff">-- If we know e1 &lt;= e2-e3 statically, translate to unsafeAssert</span>
<span class="lineno"> 5289 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_ULeq_Diff e1 e2 e3) _ |],</span>
<span class="lineno"> 5290 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |])</span>
<span class="lineno"> 5291 </span><span class="spaces">    </span><span class="nottickedoff">| mbLift (fmap bvPropHolds prop) -&gt;</span>
<span class="lineno"> 5292 </span><span class="spaces">      </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5293 </span><span class="spaces">      </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5294 </span><span class="spaces">      </span><span class="nottickedoff">do let w = natVal4 e1</span>
<span class="lineno"> 5295 </span><span class="spaces">         </span><span class="nottickedoff">t1 &lt;- translate1 e1</span>
<span class="lineno"> 5296 </span><span class="spaces">         </span><span class="nottickedoff">t2 &lt;- translate1 e2</span>
<span class="lineno"> 5297 </span><span class="spaces">         </span><span class="nottickedoff">t3 &lt;- translate1 e3</span>
<span class="lineno"> 5298 </span><span class="spaces">         </span><span class="nottickedoff">let pf_tm =</span>
<span class="lineno"> 5299 </span><span class="spaces">               </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.unsafeAssertBVULe&quot;</span>
<span class="lineno"> 5300 </span><span class="spaces">               </span><span class="nottickedoff">[natOpenTerm w, t1,</span>
<span class="lineno"> 5301 </span><span class="spaces">                </span><span class="nottickedoff">applyGlobalOpenTerm &quot;Prelude.bvSub&quot; [natOpenTerm w, t2, t3]]</span>
<span class="lineno"> 5302 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x)</span>
<span class="lineno"> 5303 </span><span class="spaces">           </span><span class="nottickedoff">(:&gt;: bvPropPerm (BVPropTrans prop pf_tm))</span>
<span class="lineno"> 5304 </span><span class="spaces">           </span><span class="nottickedoff">(popPImplTerm trans k)</span>
<span class="lineno"> 5305 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5306 </span><span class="spaces">  </span><span class="nottickedoff">-- If we don't know e1 &lt;= e2-e3 statically, translate to ifWithProof of bvule</span>
<span class="lineno"> 5307 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp x prop@(BVProp_ULeq_Diff e1 e2 e3) prop_str |],</span>
<span class="lineno"> 5308 </span><span class="spaces">   </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons _ _ mb_impl' |]) -&gt;</span>
<span class="lineno"> 5309 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImpl (mbCombine RL.typeCtxProxies mb_impl') &gt;&gt;= \trans -&gt;</span>
<span class="lineno"> 5310 </span><span class="spaces">    </span><span class="nottickedoff">return $ PImplTerm $ \k -&gt;</span>
<span class="lineno"> 5311 </span><span class="spaces">    </span><span class="nottickedoff">do prop_tp_trans &lt;- translate prop</span>
<span class="lineno"> 5312 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp_m &lt;- compReturnTypeM</span>
<span class="lineno"> 5313 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 5314 </span><span class="spaces">       </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ifWithProof&quot;</span>
<span class="lineno"> 5315 </span><span class="spaces">         </span><span class="nottickedoff">[ return ret_tp_m</span>
<span class="lineno"> 5316 </span><span class="spaces">         </span><span class="nottickedoff">, applyGlobalTransM &quot;Prelude.bvule&quot;</span>
<span class="lineno"> 5317 </span><span class="spaces">           </span><span class="nottickedoff">[ return (natOpenTerm $ natVal2 prop), translate1 e1</span>
<span class="lineno"> 5318 </span><span class="spaces">           </span><span class="nottickedoff">, applyGlobalTransM &quot;Prelude.bvSub&quot;</span>
<span class="lineno"> 5319 </span><span class="spaces">             </span><span class="nottickedoff">[return (natOpenTerm $ natVal2 prop), translate1 e2, translate1 e3]</span>
<span class="lineno"> 5320 </span><span class="spaces">           </span><span class="nottickedoff">]</span>
<span class="lineno"> 5321 </span><span class="spaces">         </span><span class="nottickedoff">, return (implFailAltContTerm ret_tp (mbLift prop_str) k)</span>
<span class="lineno"> 5322 </span><span class="spaces">         </span><span class="nottickedoff">, lambdaTransM &quot;ule_diff_pf&quot; prop_tp_trans</span>
<span class="lineno"> 5323 </span><span class="spaces">           </span><span class="nottickedoff">(\prop_trans -&gt;</span>
<span class="lineno"> 5324 </span><span class="spaces">             </span><span class="nottickedoff">withPermStackM (:&gt;: translateVar x) (:&gt;: bvPropPerm prop_trans) $</span>
<span class="lineno"> 5325 </span><span class="spaces">             </span><span class="nottickedoff">popPImplTerm trans k)</span>
<span class="lineno"> 5326 </span><span class="spaces">         </span><span class="nottickedoff">]</span>
<span class="lineno"> 5327 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5328 </span><span class="spaces">  </span><span class="nottickedoff">([nuMP| Impl1_TryProveBVProp _ _ _ |], _) -&gt;</span>
<span class="lineno"> 5329 </span><span class="spaces">    </span><span class="nottickedoff">pimplFailM (&quot;translatePermImpl1: Unhandled BVProp case&quot;)</span></span>
<span class="lineno"> 5330 </span>
<span class="lineno"> 5331 </span>-- | Translate a 'PermImpl' in the 'PermImplTransM' monad to a function that
<span class="lineno"> 5332 </span>-- takes a failure continuation and returns a monadic computation to generate
<span class="lineno"> 5333 </span>-- the translation as a term
<span class="lineno"> 5334 </span>translatePermImpl :: NuMatchingAny1 r =&gt; Mb ctx (PermImpl r ps) -&gt;
<span class="lineno"> 5335 </span>                     PImplTransMTerm r ext blocks tops rets ps ctx
<span class="lineno"> 5336 </span><span class="decl"><span class="nottickedoff">translatePermImpl mb_impl = case mbMatch mb_impl of</span>
<span class="lineno"> 5337 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PermImpl_Done r |] -&gt;</span>
<span class="lineno"> 5338 </span><span class="spaces">    </span><span class="nottickedoff">do f &lt;- pimplRTransFunM</span>
<span class="lineno"> 5339 </span><span class="spaces">       </span><span class="nottickedoff">return $ PImplTerm $ const $ appImpTransFun f reflCtxExt r</span>
<span class="lineno"> 5340 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PermImpl_Step impl1 mb_impls |] -&gt;</span>
<span class="lineno"> 5341 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImpl1 impl1 mb_impls</span></span>
<span class="lineno"> 5342 </span>
<span class="lineno"> 5343 </span>translatePermImplToTerm :: NuMatchingAny1 r =&gt; String -&gt;
<span class="lineno"> 5344 </span>                           Mb ctx (PermImpl r ps) -&gt;
<span class="lineno"> 5345 </span>                           ImpRTransFun r ext blocks tops rets ctx -&gt;
<span class="lineno"> 5346 </span>                           ImpTransM ext blocks tops rets ps ctx OpenTerm
<span class="lineno"> 5347 </span><span class="decl"><span class="nottickedoff">translatePermImplToTerm err mb_impl k =</span>
<span class="lineno"> 5348 </span><span class="spaces">  </span><span class="nottickedoff">let (maybe_ptm, (errs,_)) =</span>
<span class="lineno"> 5349 </span><span class="spaces">        </span><span class="nottickedoff">runPermImplTransM (translatePermImpl mb_impl) k in</span>
<span class="lineno"> 5350 </span><span class="spaces">  </span><span class="nottickedoff">(infoEvType &lt;$&gt; ask) &gt;&gt;= \ev -&gt;</span>
<span class="lineno"> 5351 </span><span class="spaces">  </span><span class="nottickedoff">popPImplTerm (forcePImplTerm maybe_ptm) $</span>
<span class="lineno"> 5352 </span><span class="spaces">  </span><span class="nottickedoff">ImplFailContMsg ev (err ++ &quot;\n\n&quot;</span>
<span class="lineno"> 5353 </span><span class="spaces">                      </span><span class="nottickedoff">++ concat (intersperse</span>
<span class="lineno"> 5354 </span><span class="spaces">                                 </span><span class="nottickedoff">&quot;\n\n--------------------\n\n&quot; errs))</span></span>
<span class="lineno"> 5355 </span>
<span class="lineno"> 5356 </span>instance ImplTranslateF r ext blocks tops rets =&gt;
<span class="lineno"> 5357 </span>         Translate (ImpTransInfo ext blocks tops rets ps)
<span class="lineno"> 5358 </span>                   ctx (AnnotPermImpl r ps) OpenTerm where
<span class="lineno"> 5359 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt; [nuMP| AnnotPermImpl err mb_impl |]) =</span>
<span class="lineno"> 5360 </span><span class="spaces">    </span><span class="nottickedoff">translatePermImplToTerm (mbLift err) mb_impl (ImpRTransFun $</span>
<span class="lineno"> 5361 </span><span class="spaces">                                                  </span><span class="nottickedoff">const translateF)</span></span>
<span class="lineno"> 5362 </span>
<span class="lineno"> 5363 </span>-- We translate a LocalImplRet to a term that returns all current permissions
<span class="lineno"> 5364 </span>instance ImplTranslateF (LocalImplRet ps) ext blocks ps_in rets where
<span class="lineno"> 5365 </span>  <span class="decl"><span class="nottickedoff">translateF _ =</span>
<span class="lineno"> 5366 </span><span class="spaces">    </span><span class="nottickedoff">do pctx &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 5367 </span><span class="spaces">       </span><span class="nottickedoff">ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 5368 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 5369 </span><span class="spaces">       </span><span class="nottickedoff">return $ retSOpenTerm ev ret_tp $ transTupleTerm pctx</span></span>
<span class="lineno"> 5370 </span>
<span class="lineno"> 5371 </span>-- | Translate a local implication to its output, adding an error message
<span class="lineno"> 5372 </span>translateLocalPermImpl :: String -&gt; Mb ctx (LocalPermImpl ps_in ps_out) -&gt;
<span class="lineno"> 5373 </span>                          ImpTransM ext blocks tops rets ps_in ctx OpenTerm
<span class="lineno"> 5374 </span><span class="decl"><span class="nottickedoff">translateLocalPermImpl err (mbMatch -&gt; [nuMP| LocalPermImpl impl |]) =</span>
<span class="lineno"> 5375 </span><span class="spaces">  </span><span class="nottickedoff">clearVarPermsM $ translate $ fmap (AnnotPermImpl err) impl</span></span>
<span class="lineno"> 5376 </span>
<span class="lineno"> 5377 </span>-- | Translate a local implication over two sequences of permissions (already
<span class="lineno"> 5378 </span>-- translated to types) to a monadic function with the first sequence of
<span class="lineno"> 5379 </span>-- permissions as free variables and that takes in the second permissions as
<span class="lineno"> 5380 </span>-- arguments. This monadic function is relative to the empty function stack.
<span class="lineno"> 5381 </span>-- Note that the translations of the second input permissions and the output
<span class="lineno"> 5382 </span>-- permissions must have exactly one type, i.e., already be tupled.
<span class="lineno"> 5383 </span>translateCurryLocalPermImpl ::
<span class="lineno"> 5384 </span>  String -&gt; Mb ctx (LocalPermImpl (ps1 :++: ps2) ps_out) -&gt;
<span class="lineno"> 5385 </span>  PermTransCtx ctx ps1 -&gt; RAssign (Member ctx) ps1 -&gt;
<span class="lineno"> 5386 </span>  TypeTrans (PermTransCtx ctx ps2) -&gt; RAssign (Member ctx) ps2 -&gt;
<span class="lineno"> 5387 </span>  TypeTrans (PermTransCtx ctx ps_out) -&gt;
<span class="lineno"> 5388 </span>  ImpTransM ext blocks tops rets ps ctx OpenTerm
<span class="lineno"> 5389 </span><span class="decl"><span class="nottickedoff">translateCurryLocalPermImpl err impl pctx1 vars1 tp_trans2 vars2 tp_trans_out =</span>
<span class="lineno"> 5390 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTransM &quot;x_local&quot; tp_trans2 $ \pctx2 -&gt;</span>
<span class="lineno"> 5391 </span><span class="spaces">  </span><span class="nottickedoff">local (\info -&gt; info { itiReturnType = typeTransTupleType tp_trans_out }) $</span>
<span class="lineno"> 5392 </span><span class="spaces">  </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 5393 </span><span class="spaces">    </span><span class="nottickedoff">(const (RL.append vars1 vars2))</span>
<span class="lineno"> 5394 </span><span class="spaces">    </span><span class="nottickedoff">(const (RL.append pctx1 pctx2))</span>
<span class="lineno"> 5395 </span><span class="spaces">    </span><span class="nottickedoff">(translateLocalPermImpl err impl)</span></span>
<span class="lineno"> 5396 </span>
<span class="lineno"> 5397 </span>-- | Translate a 'LocalPermImpl' to an 'LOwnedTransTerm'
<span class="lineno"> 5398 </span>translateLOwnedPermImpl :: String -&gt; Mb ctx (LocalPermImpl ps_in ps_out) -&gt;
<span class="lineno"> 5399 </span>                           ImpTransM ext blocks tops rets ps ctx
<span class="lineno"> 5400 </span>                           (LOwnedTransTerm ctx ps_in ps_out)
<span class="lineno"> 5401 </span><span class="decl"><span class="nottickedoff">translateLOwnedPermImpl err (mbMatch -&gt; [nuMP| LocalPermImpl mb_impl |]) =</span>
<span class="lineno"> 5402 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \info_top -&gt;</span>
<span class="lineno"> 5403 </span><span class="spaces">  </span><span class="nottickedoff">return $ LOwnedTransM $ \e_ext loinfo_in k -&gt;</span>
<span class="lineno"> 5404 </span><span class="spaces">  </span><span class="nottickedoff">flip runTransM (lownedInfoToImp loinfo_in info_top) $</span>
<span class="lineno"> 5405 </span><span class="spaces">  </span><span class="nottickedoff">translatePermImplToTerm err (extMbExt e_ext mb_impl) $</span>
<span class="lineno"> 5406 </span><span class="spaces">  </span><span class="nottickedoff">ImpRTransFun $ \cext' r -&gt;</span>
<span class="lineno"> 5407 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch r of</span>
<span class="lineno"> 5408 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LocalImplRet Refl |] -&gt;</span>
<span class="lineno"> 5409 </span><span class="spaces">      </span><span class="nottickedoff">do info_out &lt;- ask</span>
<span class="lineno"> 5410 </span><span class="spaces">         </span><span class="nottickedoff">let e_ext' = ctxExtToExprExt cext' $ itiExprCtx info_out</span>
<span class="lineno"> 5411 </span><span class="spaces">         </span><span class="nottickedoff">return $ k e_ext' (impInfoToLOwned info_out) ()</span></span>
<span class="lineno"> 5412 </span>
<span class="lineno"> 5413 </span>
<span class="lineno"> 5414 </span>----------------------------------------------------------------------
<span class="lineno"> 5415 </span>-- * Translating Typed Crucible Expressions
<span class="lineno"> 5416 </span>----------------------------------------------------------------------
<span class="lineno"> 5417 </span>
<span class="lineno"> 5418 </span>-- translate for a TypedReg yields an ExprTrans
<span class="lineno"> 5419 </span>instance TransInfo info =&gt;
<span class="lineno"> 5420 </span>         Translate info ctx (TypedReg tp) (ExprTrans tp) where
<span class="lineno"> 5421 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt; [nuMP| TypedReg x |]) = translate x</span></span>
<span class="lineno"> 5422 </span>
<span class="lineno"> 5423 </span>instance TransInfo info =&gt;
<span class="lineno"> 5424 </span>         Translate info ctx (TypedRegs tps) (ExprTransCtx tps) where
<span class="lineno"> 5425 </span>  <span class="decl"><span class="nottickedoff">translate mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 5426 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedRegsNil |] -&gt; return MNil</span>
<span class="lineno"> 5427 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedRegsCons rs r |] -&gt;</span>
<span class="lineno"> 5428 </span><span class="spaces">      </span><span class="nottickedoff">(:&gt;:) &lt;$&gt; translate rs &lt;*&gt; translate r</span></span>
<span class="lineno"> 5429 </span>
<span class="lineno"> 5430 </span>instance TransInfo info =&gt;
<span class="lineno"> 5431 </span>         Translate info ctx (RegWithVal tp) (ExprTrans tp) where
<span class="lineno"> 5432 </span>  <span class="decl"><span class="nottickedoff">translate mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 5433 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| RegWithVal _ e |] -&gt; translate e</span>
<span class="lineno"> 5434 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| RegNoVal x |] -&gt; translate x</span></span>
<span class="lineno"> 5435 </span>
<span class="lineno"> 5436 </span>-- | Translate a 'RegWithVal' to exactly one SAW term via 'transTerm1'
<span class="lineno"> 5437 </span>translateRWV :: TransInfo info =&gt; Mb ctx (RegWithVal a) -&gt;
<span class="lineno"> 5438 </span>                TransM info ctx OpenTerm
<span class="lineno"> 5439 </span><span class="decl"><span class="nottickedoff">translateRWV mb_rwv = translate1 mb_rwv</span></span>
<span class="lineno"> 5440 </span>
<span class="lineno"> 5441 </span>-- translate for a TypedExpr yields an ExprTrans
<span class="lineno"> 5442 </span>instance (PermCheckExtC ext exprExt, TransInfo info) =&gt;
<span class="lineno"> 5443 </span>         Translate info ctx (App ext RegWithVal tp) (ExprTrans tp) where
<span class="lineno"> 5444 </span>  <span class="decl"><span class="nottickedoff">translate mb_e = case mbMatch mb_e of</span>
<span class="lineno"> 5445 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BaseIsEq BaseBoolRepr e1 e2 |] -&gt;</span>
<span class="lineno"> 5446 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5447 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.boolEq&quot;)</span>
<span class="lineno"> 5448 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5449 </span><span class="spaces">  </span><span class="nottickedoff">--  [nuMP| BaseIsEq BaseNatRepr e1 e2 |] -&gt;</span>
<span class="lineno"> 5450 </span><span class="spaces">  </span><span class="nottickedoff">--    ETrans_Term &lt;$&gt;</span>
<span class="lineno"> 5451 </span><span class="spaces">  </span><span class="nottickedoff">--    applyMultiTransM (return $ globalOpenTerm &quot;Prelude.equalNat&quot;)</span>
<span class="lineno"> 5452 </span><span class="spaces">  </span><span class="nottickedoff">--    [translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5453 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BaseIsEq (BaseBVRepr w) e1 e2 |] -&gt;</span>
<span class="lineno"> 5454 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5455 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvEq&quot;)</span>
<span class="lineno"> 5456 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5457 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5458 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| EmptyApp |] -&gt; return ETrans_Unit</span>
<span class="lineno"> 5459 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5460 </span><span class="spaces">    </span><span class="nottickedoff">-- Booleans</span>
<span class="lineno"> 5461 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolLit True |] -&gt;</span>
<span class="lineno"> 5462 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ globalOpenTerm &quot;Prelude.True&quot;</span>
<span class="lineno"> 5463 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolLit False |] -&gt;</span>
<span class="lineno"> 5464 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ globalOpenTerm &quot;Prelude.False&quot;</span>
<span class="lineno"> 5465 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Not e |] -&gt;</span>
<span class="lineno"> 5466 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5467 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.not&quot;)</span>
<span class="lineno"> 5468 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e]</span>
<span class="lineno"> 5469 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| And e1 e2 |] -&gt;</span>
<span class="lineno"> 5470 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5471 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.and&quot;)</span>
<span class="lineno"> 5472 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5473 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Or e1 e2 |] -&gt;</span>
<span class="lineno"> 5474 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5475 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.or&quot;)</span>
<span class="lineno"> 5476 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5477 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolXor e1 e2 |] -&gt;</span>
<span class="lineno"> 5478 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5479 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.xor&quot;)</span>
<span class="lineno"> 5480 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5481 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5482 </span><span class="spaces">    </span><span class="nottickedoff">-- Natural numbers</span>
<span class="lineno"> 5483 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Expr.NatLit n |] -&gt;</span>
<span class="lineno"> 5484 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ natOpenTerm $ mbLift n</span>
<span class="lineno"> 5485 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatLt e1 e2 |] -&gt;</span>
<span class="lineno"> 5486 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5487 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.ltNat&quot;)</span>
<span class="lineno"> 5488 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5489 </span><span class="spaces">    </span><span class="nottickedoff">-- [nuMP| NatLe _ _ |] -&gt;</span>
<span class="lineno"> 5490 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatEq e1 e2 |] -&gt;</span>
<span class="lineno"> 5491 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5492 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.equalNat&quot;)</span>
<span class="lineno"> 5493 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5494 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatAdd e1 e2 |] -&gt;</span>
<span class="lineno"> 5495 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5496 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.addNat&quot;)</span>
<span class="lineno"> 5497 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5498 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatSub e1 e2 |] -&gt;</span>
<span class="lineno"> 5499 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5500 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.subNat&quot;)</span>
<span class="lineno"> 5501 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5502 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatMul e1 e2 |] -&gt;</span>
<span class="lineno"> 5503 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5504 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.mulNat&quot;)</span>
<span class="lineno"> 5505 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5506 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatDiv e1 e2 |] -&gt;</span>
<span class="lineno"> 5507 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5508 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.divNat&quot;)</span>
<span class="lineno"> 5509 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5510 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatMod e1 e2 |] -&gt;</span>
<span class="lineno"> 5511 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5512 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.modNat&quot;)</span>
<span class="lineno"> 5513 </span><span class="spaces">      </span><span class="nottickedoff">[translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5514 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5515 </span><span class="spaces">    </span><span class="nottickedoff">-- Function handles: the expression part of a function handle has no</span>
<span class="lineno"> 5516 </span><span class="spaces">    </span><span class="nottickedoff">-- computational content</span>
<span class="lineno"> 5517 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| HandleLit _ |] -&gt; return ETrans_Fun</span>
<span class="lineno"> 5518 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5519 </span><span class="spaces">    </span><span class="nottickedoff">-- Bitvectors</span>
<span class="lineno"> 5520 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUndef w |] -&gt;</span>
<span class="lineno"> 5521 </span><span class="spaces">      </span><span class="nottickedoff">-- FIXME: we should really handle poison values; this translation just</span>
<span class="lineno"> 5522 </span><span class="spaces">      </span><span class="nottickedoff">-- treats them as if there were the bitvector 0 value</span>
<span class="lineno"> 5523 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term (BVRepr $ mbLift w) $</span>
<span class="lineno"> 5524 </span><span class="spaces">      </span><span class="nottickedoff">bvBVOpenTerm (mbLift w) $ BV.zero (mbLift w)</span>
<span class="lineno"> 5525 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVLit w mb_bv |] -&gt;</span>
<span class="lineno"> 5526 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term (BVRepr $ mbLift w) $</span>
<span class="lineno"> 5527 </span><span class="spaces">      </span><span class="nottickedoff">bvBVOpenTerm (mbLift w) $ mbLift mb_bv</span>
<span class="lineno"> 5528 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVConcat w1 w2 e1 e2 |] -&gt;</span>
<span class="lineno"> 5529 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ addNat (mbLift w1) (mbLift w2)) &lt;$&gt;</span>
<span class="lineno"> 5530 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.join&quot;)</span>
<span class="lineno"> 5531 </span><span class="spaces">      </span><span class="nottickedoff">[translate w1, translate w2, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5532 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVTrunc w1 w2 e |] -&gt;</span>
<span class="lineno"> 5533 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w1) &lt;$&gt;</span>
<span class="lineno"> 5534 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvTrunc&quot;)</span>
<span class="lineno"> 5535 </span><span class="spaces">      </span><span class="nottickedoff">[return (natOpenTerm (natValue (mbLift w2) - natValue (mbLift w1))),</span>
<span class="lineno"> 5536 </span><span class="spaces">       </span><span class="nottickedoff">translate w1,</span>
<span class="lineno"> 5537 </span><span class="spaces">       </span><span class="nottickedoff">translateRWV e]</span>
<span class="lineno"> 5538 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVZext w1 w2 e |] -&gt;</span>
<span class="lineno"> 5539 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w1) &lt;$&gt;</span>
<span class="lineno"> 5540 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvUExt&quot;)</span>
<span class="lineno"> 5541 </span><span class="spaces">      </span><span class="nottickedoff">[return (natOpenTerm (natValue (mbLift w1) - natValue (mbLift w2))),</span>
<span class="lineno"> 5542 </span><span class="spaces">       </span><span class="nottickedoff">translate w2, translateRWV e]</span>
<span class="lineno"> 5543 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSext w1 w2 e |] -&gt;</span>
<span class="lineno"> 5544 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w1) &lt;$&gt;</span>
<span class="lineno"> 5545 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSExt&quot;)</span>
<span class="lineno"> 5546 </span><span class="spaces">      </span><span class="nottickedoff">[return (natOpenTerm (natValue (mbLift w1) - natValue (mbLift w2))),</span>
<span class="lineno"> 5547 </span><span class="spaces">       </span><span class="nottickedoff">-- NOTE: bvSExt adds 1 to the 2nd arg</span>
<span class="lineno"> 5548 </span><span class="spaces">       </span><span class="nottickedoff">return (natOpenTerm (natValue (mbLift w2) - 1)),</span>
<span class="lineno"> 5549 </span><span class="spaces">       </span><span class="nottickedoff">translateRWV e]</span>
<span class="lineno"> 5550 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVNot w e |] -&gt;</span>
<span class="lineno"> 5551 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5552 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvNot&quot;)</span>
<span class="lineno"> 5553 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e]</span>
<span class="lineno"> 5554 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVAnd w e1 e2 |] -&gt;</span>
<span class="lineno"> 5555 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5556 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvAnd&quot;)</span>
<span class="lineno"> 5557 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5558 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVOr w e1 e2 |] -&gt;</span>
<span class="lineno"> 5559 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5560 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvOr&quot;)</span>
<span class="lineno"> 5561 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5562 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVXor w e1 e2 |] -&gt;</span>
<span class="lineno"> 5563 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5564 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvXor&quot;)</span>
<span class="lineno"> 5565 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5566 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVNeg w e |] -&gt;</span>
<span class="lineno"> 5567 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5568 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvNeg&quot;)</span>
<span class="lineno"> 5569 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e]</span>
<span class="lineno"> 5570 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVAdd w e1 e2 |] -&gt;</span>
<span class="lineno"> 5571 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5572 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvAdd&quot;)</span>
<span class="lineno"> 5573 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5574 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSub w e1 e2 |] -&gt;</span>
<span class="lineno"> 5575 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5576 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSub&quot;)</span>
<span class="lineno"> 5577 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5578 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVMul w e1 e2 |] -&gt;</span>
<span class="lineno"> 5579 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5580 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvMul&quot;)</span>
<span class="lineno"> 5581 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5582 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUdiv w e1 e2 |] -&gt;</span>
<span class="lineno"> 5583 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5584 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvUDiv&quot;)</span>
<span class="lineno"> 5585 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5586 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSdiv w e1 e2 |] -&gt;</span>
<span class="lineno"> 5587 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5588 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSDiv&quot;)</span>
<span class="lineno"> 5589 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5590 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUrem w e1 e2 |] -&gt;</span>
<span class="lineno"> 5591 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5592 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvURem&quot;)</span>
<span class="lineno"> 5593 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5594 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSrem w e1 e2 |] -&gt;</span>
<span class="lineno"> 5595 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5596 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSRem&quot;)</span>
<span class="lineno"> 5597 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5598 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUle w e1 e2 |] -&gt;</span>
<span class="lineno"> 5599 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5600 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvule&quot;)</span>
<span class="lineno"> 5601 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5602 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUlt w e1 e2 |] -&gt;</span>
<span class="lineno"> 5603 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5604 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvult&quot;)</span>
<span class="lineno"> 5605 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5606 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSle w e1 e2 |] -&gt;</span>
<span class="lineno"> 5607 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5608 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvsle&quot;)</span>
<span class="lineno"> 5609 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5610 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSlt w e1 e2 |] -&gt;</span>
<span class="lineno"> 5611 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5612 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvslt&quot;)</span>
<span class="lineno"> 5613 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5614 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVCarry w e1 e2 |] -&gt;</span>
<span class="lineno"> 5615 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5616 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvCarry&quot;)</span>
<span class="lineno"> 5617 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5618 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSCarry w e1 e2 |] -&gt;</span>
<span class="lineno"> 5619 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: bvSCarry adds 1 to the bitvector length</span>
<span class="lineno"> 5620 </span><span class="spaces">      </span><span class="nottickedoff">let w_minus_1 = natOpenTerm (natValue (mbLift w) - 1) in</span>
<span class="lineno"> 5621 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5622 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSCarry&quot;)</span>
<span class="lineno"> 5623 </span><span class="spaces">      </span><span class="nottickedoff">[return w_minus_1, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5624 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSBorrow w e1 e2 |] -&gt;</span>
<span class="lineno"> 5625 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: bvSBorrow adds 1 to the bitvector length</span>
<span class="lineno"> 5626 </span><span class="spaces">      </span><span class="nottickedoff">let w_minus_1 = natOpenTerm (natValue (mbLift w) - 1) in</span>
<span class="lineno"> 5627 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5628 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSBorrow&quot;)</span>
<span class="lineno"> 5629 </span><span class="spaces">      </span><span class="nottickedoff">[return w_minus_1, translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5630 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVShl w e1 e2 |] -&gt;</span>
<span class="lineno"> 5631 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5632 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvShiftL&quot;)</span>
<span class="lineno"> 5633 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, return (globalOpenTerm &quot;Prelude.Bool&quot;), translate w,</span>
<span class="lineno"> 5634 </span><span class="spaces">       </span><span class="nottickedoff">return (globalOpenTerm &quot;Prelude.False&quot;), translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5635 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVLshr w e1 e2 |] -&gt;</span>
<span class="lineno"> 5636 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5637 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvShiftR&quot;)</span>
<span class="lineno"> 5638 </span><span class="spaces">      </span><span class="nottickedoff">[translate w, return (globalOpenTerm &quot;Prelude.Bool&quot;), translate w,</span>
<span class="lineno"> 5639 </span><span class="spaces">       </span><span class="nottickedoff">return (globalOpenTerm &quot;Prelude.False&quot;), translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5640 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVAshr w e1 e2 |] -&gt;</span>
<span class="lineno"> 5641 </span><span class="spaces">      </span><span class="nottickedoff">let w_minus_1 = natOpenTerm (natValue (mbLift w) - 1) in</span>
<span class="lineno"> 5642 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr $ mbLift w) &lt;$&gt;</span>
<span class="lineno"> 5643 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvSShiftR&quot;)</span>
<span class="lineno"> 5644 </span><span class="spaces">      </span><span class="nottickedoff">[return w_minus_1, return (globalOpenTerm &quot;Prelude.Bool&quot;), translate w,</span>
<span class="lineno"> 5645 </span><span class="spaces">       </span><span class="nottickedoff">translateRWV e1, translateRWV e2]</span>
<span class="lineno"> 5646 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolToBV mb_w e |] -&gt;</span>
<span class="lineno"> 5647 </span><span class="spaces">      </span><span class="nottickedoff">let w = mbLift mb_w in</span>
<span class="lineno"> 5648 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term (BVRepr w) &lt;$&gt;</span>
<span class="lineno"> 5649 </span><span class="spaces">      </span><span class="nottickedoff">applyMultiTransM (return $ globalOpenTerm &quot;Prelude.ite&quot;)</span>
<span class="lineno"> 5650 </span><span class="spaces">      </span><span class="nottickedoff">[bitvectorTransM (translate mb_w),</span>
<span class="lineno"> 5651 </span><span class="spaces">       </span><span class="nottickedoff">translateRWV e,</span>
<span class="lineno"> 5652 </span><span class="spaces">       </span><span class="nottickedoff">return (bvBVOpenTerm w (BV.one w)),</span>
<span class="lineno"> 5653 </span><span class="spaces">       </span><span class="nottickedoff">return (bvBVOpenTerm w (BV.zero w))]</span>
<span class="lineno"> 5654 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVNonzero mb_w e |] -&gt;</span>
<span class="lineno"> 5655 </span><span class="spaces">      </span><span class="nottickedoff">let w = mbLift mb_w in</span>
<span class="lineno"> 5656 </span><span class="spaces">      </span><span class="nottickedoff">ETrans_Term knownRepr &lt;$&gt;</span>
<span class="lineno"> 5657 </span><span class="spaces">      </span><span class="nottickedoff">applyTransM (return $ globalOpenTerm &quot;Prelude.not&quot;)</span>
<span class="lineno"> 5658 </span><span class="spaces">      </span><span class="nottickedoff">(applyMultiTransM (return $ globalOpenTerm &quot;Prelude.bvEq&quot;)</span>
<span class="lineno"> 5659 </span><span class="spaces">       </span><span class="nottickedoff">[translate mb_w, translateRWV e,</span>
<span class="lineno"> 5660 </span><span class="spaces">        </span><span class="nottickedoff">return (bvBVOpenTerm w (BV.zero w))])</span>
<span class="lineno"> 5661 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5662 </span><span class="spaces">    </span><span class="nottickedoff">-- Strings</span>
<span class="lineno"> 5663 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Expr.StringLit (UnicodeLiteral text) |] -&gt;</span>
<span class="lineno"> 5664 </span><span class="spaces">      </span><span class="nottickedoff">return $ ETrans_Term knownRepr $ stringLitOpenTerm $</span>
<span class="lineno"> 5665 </span><span class="spaces">      </span><span class="nottickedoff">mbLift text</span>
<span class="lineno"> 5666 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5667 </span><span class="spaces">    </span><span class="nottickedoff">-- Everything else is an error</span>
<span class="lineno"> 5668 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 5669 </span><span class="spaces">      </span><span class="nottickedoff">error (&quot;Unhandled expression form: &quot; ++</span>
<span class="lineno"> 5670 </span><span class="spaces">              </span><span class="nottickedoff">(renderString (layoutSmart opts (mbLift $ fmap (ppApp (const $ pretty (&quot;_&quot; :: String))) mb_e))))</span>
<span class="lineno"> 5671 </span><span class="spaces">        </span><span class="nottickedoff">where opts = PP.LayoutOptions (PP.AvailablePerLine 80 0.8)</span></span>
<span class="lineno"> 5672 </span>
<span class="lineno"> 5673 </span>
<span class="lineno"> 5674 </span>-- translate for a TypedExpr yields an ExprTrans
<span class="lineno"> 5675 </span>instance (PermCheckExtC ext exprExt, TransInfo info) =&gt;
<span class="lineno"> 5676 </span>         Translate info ctx (TypedExpr ext tp) (ExprTrans tp) where
<span class="lineno"> 5677 </span>  <span class="decl"><span class="nottickedoff">translate mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 5678 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedExpr _ (Just e) |] -&gt; translate e</span>
<span class="lineno"> 5679 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedExpr app Nothing |] -&gt; translate app</span></span>
<span class="lineno"> 5680 </span>
<span class="lineno"> 5681 </span>-- | Get the output permission on the return value of a 'TypedExpr'
<span class="lineno"> 5682 </span>exprOutPerm :: PermCheckExtC ext exprExt =&gt; Mb ctx (TypedExpr ext tp) -&gt;
<span class="lineno"> 5683 </span>               PermTrans ctx tp
<span class="lineno"> 5684 </span><span class="decl"><span class="nottickedoff">exprOutPerm mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 5685 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedExpr _ (Just e) |] -&gt; PTrans_Eq e</span>
<span class="lineno"> 5686 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedExpr _ Nothing |] -&gt; PTrans_True</span></span>
<span class="lineno"> 5687 </span>
<span class="lineno"> 5688 </span>
<span class="lineno"> 5689 </span>----------------------------------------------------------------------
<span class="lineno"> 5690 </span>-- * Translating Typed Crucible Jump Targets
<span class="lineno"> 5691 </span>----------------------------------------------------------------------
<span class="lineno"> 5692 </span>
<span class="lineno"> 5693 </span>{-
<span class="lineno"> 5694 </span>debugPrettyPermCtx :: RAssign Proxy ctx -&gt; PermTransCtx ctx ps -&gt; [Doc]
<span class="lineno"> 5695 </span>debugPrettyPermCtx _ MNil = []
<span class="lineno"> 5696 </span>debugPrettyPermCtx prxs (ptranss :&gt;: ptrans) =
<span class="lineno"> 5697 </span>  debugPrettyPermCtx prxs ptranss ++
<span class="lineno"> 5698 </span>  [permPretty emptyPPInfo (permTransPerm prxs ptrans) &lt;+&gt;
<span class="lineno"> 5699 </span>   string (&quot;(&quot; ++ show (length $ transTerms ptrans) ++ &quot; terms)&quot;)]
<span class="lineno"> 5700 </span>-}
<span class="lineno"> 5701 </span>
<span class="lineno"> 5702 </span>{-
<span class="lineno"> 5703 </span>-- | Apply the translation of a function-like construct (i.e., a
<span class="lineno"> 5704 </span>-- 'TypedJumpTarget' or 'TypedFnHandle') to the pure plus impure translations of
<span class="lineno"> 5705 </span>-- its arguments, given as 'DistPerms', which should match the current
<span class="lineno"> 5706 </span>-- stack. The 'String' argument is the name of the construct being applied, for
<span class="lineno"> 5707 </span>-- use in error reporting.
<span class="lineno"> 5708 </span>translateApply :: String -&gt; OpenTerm -&gt; Mb ctx (DistPerms ps) -&gt;
<span class="lineno"> 5709 </span>                  ImpTransM ext blocks tops rets ps ctx OpenTerm
<span class="lineno"> 5710 </span>translateApply nm f perms =
<span class="lineno"> 5711 </span>  do assertPermStackEqM nm perms
<span class="lineno"> 5712 </span>     expr_ctx &lt;- itiExprCtx &lt;$&gt; ask
<span class="lineno"> 5713 </span>     arg_membs &lt;- itiPermStackVars &lt;$&gt; ask
<span class="lineno"> 5714 </span>     let e_args = RL.map (flip RL.get expr_ctx) arg_membs
<span class="lineno"> 5715 </span>     i_args &lt;- itiPermStack &lt;$&gt; ask
<span class="lineno"> 5716 </span>     return $
<span class="lineno"> 5717 </span>       {-
<span class="lineno"> 5718 </span>       trace (&quot;translateApply for &quot; ++ nm ++ &quot; with perm arguments:\n&quot; ++
<span class="lineno"> 5719 </span>              -- renderDoc (list $ debugPrettyPermCtx (mbToProxy perms) i_args)
<span class="lineno"> 5720 </span>              -- permPrettyString emptyPPInfo (permTransCtxPerms (mbToProxy perms) i_args)
<span class="lineno"> 5721 </span>              permPrettyString emptyPPInfo perms
<span class="lineno"> 5722 </span>             ) $ -}
<span class="lineno"> 5723 </span>       applyOpenTermMulti f (exprCtxToTerms e_args ++ permCtxToTerms i_args)
<span class="lineno"> 5724 </span>-}
<span class="lineno"> 5725 </span>
<span class="lineno"> 5726 </span>-- | Translate a call to (the translation of) an entrypoint, by either calling
<span class="lineno"> 5727 </span>-- the letrec-bound variable for the entrypoint, if it has one, or by just
<span class="lineno"> 5728 </span>-- translating the body of the entrypoint if it does not.
<span class="lineno"> 5729 </span>translateCallEntry :: forall ext exprExt tops args ghosts blocks ctx rets.
<span class="lineno"> 5730 </span>                      PermCheckExtC ext exprExt =&gt; String -&gt;
<span class="lineno"> 5731 </span>                      TypedEntryTrans ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 5732 </span>                      Mb ctx (RAssign ExprVar tops) -&gt;
<span class="lineno"> 5733 </span>                      Mb ctx (RAssign ExprVar args) -&gt;
<span class="lineno"> 5734 </span>                      Mb ctx (RAssign ExprVar ghosts) -&gt;
<span class="lineno"> 5735 </span>                      ImpTransM ext blocks tops rets
<span class="lineno"> 5736 </span>                      ((tops :++: args) :++: ghosts) ctx OpenTerm
<span class="lineno"> 5737 </span><span class="decl"><span class="nottickedoff">translateCallEntry nm entry_trans mb_tops mb_args mb_ghosts =</span>
<span class="lineno"> 5738 </span><span class="spaces">  </span><span class="nottickedoff">-- First test that the stack == the required perms for entryID</span>
<span class="lineno"> 5739 </span><span class="spaces">  </span><span class="nottickedoff">do let entry = typedEntryTransEntry entry_trans</span>
<span class="lineno"> 5740 </span><span class="spaces">     </span><span class="nottickedoff">ectx_ag &lt;- translate $ mbMap2 RL.append mb_args mb_ghosts</span>
<span class="lineno"> 5741 </span><span class="spaces">     </span><span class="nottickedoff">pctx &lt;- itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 5742 </span><span class="spaces">     </span><span class="nottickedoff">let mb_tops_args = mbMap2 RL.append mb_tops mb_args</span>
<span class="lineno"> 5743 </span><span class="spaces">     </span><span class="nottickedoff">let mb_s =</span>
<span class="lineno"> 5744 </span><span class="spaces">           </span><span class="nottickedoff">mbMap2 (\args ghosts -&gt;</span>
<span class="lineno"> 5745 </span><span class="spaces">                    </span><span class="nottickedoff">permVarSubstOfNames $ RL.append args ghosts)</span>
<span class="lineno"> 5746 </span><span class="spaces">           </span><span class="nottickedoff">mb_tops_args mb_ghosts</span>
<span class="lineno"> 5747 </span><span class="spaces">     </span><span class="nottickedoff">let mb_perms = fmap (\s -&gt; varSubst s $ mbValuePermsToDistPerms $</span>
<span class="lineno"> 5748 </span><span class="spaces">                                </span><span class="nottickedoff">typedEntryPermsIn entry) mb_s</span>
<span class="lineno"> 5749 </span><span class="spaces">     </span><span class="nottickedoff">() &lt;- assertPermStackEqM nm mb_perms</span>
<span class="lineno"> 5750 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5751 </span><span class="spaces">     </span><span class="nottickedoff">-- Now check if entryID has an associated recursive function</span>
<span class="lineno"> 5752 </span><span class="spaces">     </span><span class="nottickedoff">case typedEntryTransFun entry_trans of</span>
<span class="lineno"> 5753 </span><span class="spaces">       </span><span class="nottickedoff">Just f -&gt;</span>
<span class="lineno"> 5754 </span><span class="spaces">         </span><span class="nottickedoff">-- If so, apply the function to all the terms in the args and ghosts</span>
<span class="lineno"> 5755 </span><span class="spaces">         </span><span class="nottickedoff">-- (but not the tops, which are free) plus all the permissions on the</span>
<span class="lineno"> 5756 </span><span class="spaces">         </span><span class="nottickedoff">-- stack</span>
<span class="lineno"> 5757 </span><span class="spaces">         </span><span class="nottickedoff">return (applyOpenTermMulti f</span>
<span class="lineno"> 5758 </span><span class="spaces">                 </span><span class="nottickedoff">(exprCtxToTerms ectx_ag ++ transTerms pctx))</span>
<span class="lineno"> 5759 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5760 </span><span class="spaces">         </span><span class="nottickedoff">-- Otherwise, continue translating with the target entrypoint, with all</span>
<span class="lineno"> 5761 </span><span class="spaces">         </span><span class="nottickedoff">-- the current expressions free but with only those permissions on top</span>
<span class="lineno"> 5762 </span><span class="spaces">         </span><span class="nottickedoff">-- of the stack</span>
<span class="lineno"> 5763 </span><span class="spaces">         </span><span class="nottickedoff">withEmptyPermsImpTransM $ translate $</span>
<span class="lineno"> 5764 </span><span class="spaces">         </span><span class="nottickedoff">fmap (\s -&gt; varSubst s $ _mbBinding $ typedEntryBody entry) mb_s</span></span>
<span class="lineno"> 5765 </span>
<span class="lineno"> 5766 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 5767 </span>         Translate (ImpTransInfo ext blocks tops rets ps) ctx
<span class="lineno"> 5768 </span>         (CallSiteImplRet blocks tops args ghosts ps) OpenTerm where
<span class="lineno"> 5769 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt;</span>
<span class="lineno"> 5770 </span><span class="spaces">             </span><span class="nottickedoff">[nuMP| CallSiteImplRet entryID ghosts Refl mb_tvars mb_avars mb_gvars |]) =</span>
<span class="lineno"> 5771 </span><span class="spaces">    </span><span class="nottickedoff">do entry_trans &lt;-</span>
<span class="lineno"> 5772 </span><span class="spaces">         </span><span class="nottickedoff">lookupEntryTransCast (mbLift entryID) (mbLift ghosts) &lt;$&gt;</span>
<span class="lineno"> 5773 </span><span class="spaces">         </span><span class="nottickedoff">itiBlockMapTrans &lt;$&gt; ask</span>
<span class="lineno"> 5774 </span><span class="spaces">       </span><span class="nottickedoff">translateCallEntry &quot;CallSiteImplRet&quot; entry_trans mb_tvars mb_avars mb_gvars</span></span>
<span class="lineno"> 5775 </span>
<span class="lineno"> 5776 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 5777 </span>         ImplTranslateF (CallSiteImplRet blocks tops args ghosts)
<span class="lineno"> 5778 </span>         ext blocks tops rets where
<span class="lineno"> 5779 </span>  <span class="decl"><span class="nottickedoff">translateF mb_tgt = translate mb_tgt</span></span>
<span class="lineno"> 5780 </span>
<span class="lineno"> 5781 </span>
<span class="lineno"> 5782 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 5783 </span>         Translate (ImpTransInfo ext blocks tops rets ps) ctx
<span class="lineno"> 5784 </span>         (TypedJumpTarget blocks tops ps) OpenTerm where
<span class="lineno"> 5785 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt; [nuMP| TypedJumpTarget siteID _ _ mb_perms_in |]) =</span>
<span class="lineno"> 5786 </span><span class="spaces">    </span><span class="nottickedoff">do SomeTypedCallSite site &lt;-</span>
<span class="lineno"> 5787 </span><span class="spaces">         </span><span class="nottickedoff">lookupCallSite (mbLift siteID) &lt;$&gt; itiBlockMapTrans &lt;$&gt; ask</span>
<span class="lineno"> 5788 </span><span class="spaces">       </span><span class="nottickedoff">let CallSiteImpl mb_impl = typedCallSiteImpl site</span>
<span class="lineno"> 5789 </span><span class="spaces">       </span><span class="nottickedoff">translate $ flip fmap mb_perms_in $ \perms_in -&gt;</span>
<span class="lineno"> 5790 </span><span class="spaces">         </span><span class="nottickedoff">varSubst (permVarSubstOfNames $ distPermsVars perms_in) mb_impl</span></span>
<span class="lineno"> 5791 </span>
<span class="lineno"> 5792 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 5793 </span>         ImplTranslateF (TypedJumpTarget blocks tops) ext blocks tops rets where
<span class="lineno"> 5794 </span>  <span class="decl"><span class="nottickedoff">translateF mb_tgt = translate mb_tgt</span></span>
<span class="lineno"> 5795 </span>
<span class="lineno"> 5796 </span>
<span class="lineno"> 5797 </span>----------------------------------------------------------------------
<span class="lineno"> 5798 </span>-- * Translating Typed Crucible Statements
<span class="lineno"> 5799 </span>----------------------------------------------------------------------
<span class="lineno"> 5800 </span>
<span class="lineno"> 5801 </span>-- | Translate a 'TypedStmt' to a function on translation computations
<span class="lineno"> 5802 </span>translateStmt ::
<span class="lineno"> 5803 </span>  PermCheckExtC ext exprExt =&gt; ProgramLoc -&gt;
<span class="lineno"> 5804 </span>  Mb ctx (TypedStmt ext stmt_rets ps_in ps_out) -&gt;
<span class="lineno"> 5805 </span>  ImpTransM ext blocks tops rets ps_out (ctx :++: stmt_rets) OpenTerm -&gt;
<span class="lineno"> 5806 </span>  ImpTransM ext blocks tops rets ps_in ctx OpenTerm
<span class="lineno"> 5807 </span><span class="decl"><span class="nottickedoff">translateStmt loc mb_stmt m = case mbMatch mb_stmt of</span>
<span class="lineno"> 5808 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedSetReg tp e |] -&gt;</span>
<span class="lineno"> 5809 </span><span class="spaces">    </span><span class="nottickedoff">do tp_trans &lt;- translate tp</span>
<span class="lineno"> 5810 </span><span class="spaces">       </span><span class="nottickedoff">tp_ret &lt;- compReturnTypeM</span>
<span class="lineno"> 5811 </span><span class="spaces">       </span><span class="nottickedoff">etrans &lt;- tpTransM $ translate e</span>
<span class="lineno"> 5812 </span><span class="spaces">       </span><span class="nottickedoff">let ptrans = exprOutPerm e</span>
<span class="lineno"> 5813 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransSAWLetBindM tp_trans tp_ret etrans $</span>
<span class="lineno"> 5814 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: extPermTrans etrans ptrans) m</span>
<span class="lineno"> 5815 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5816 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedSetRegPermExpr _ e |] -&gt;</span>
<span class="lineno"> 5817 </span><span class="spaces">    </span><span class="nottickedoff">do etrans &lt;- tpTransM $ translate e</span>
<span class="lineno"> 5818 </span><span class="spaces">       </span><span class="nottickedoff">inExtTransM etrans $</span>
<span class="lineno"> 5819 </span><span class="spaces">         </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: PTrans_Eq (extMb e)) m</span>
<span class="lineno"> 5820 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5821 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME HERE: document this!</span>
<span class="lineno"> 5822 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedCall _freg fun_perm _ gexprs args |] -&gt;</span>
<span class="lineno"> 5823 </span><span class="spaces">    </span><span class="nottickedoff">do f_trans &lt;- getTopPermM</span>
<span class="lineno"> 5824 </span><span class="spaces">       </span><span class="nottickedoff">ectx_outer &lt;- itiExprCtx &lt;$&gt; ask</span>
<span class="lineno"> 5825 </span><span class="spaces">       </span><span class="nottickedoff">let rets = mbLift $ mbMapCl $(mkClosed [| funPermRets |]) fun_perm</span>
<span class="lineno"> 5826 </span><span class="spaces">       </span><span class="nottickedoff">let rets_prxs = cruCtxProxies rets</span>
<span class="lineno"> 5827 </span><span class="spaces">       </span><span class="nottickedoff">rets_trans &lt;- translateClosed rets</span>
<span class="lineno"> 5828 </span><span class="spaces">       </span><span class="nottickedoff">let perms_out =</span>
<span class="lineno"> 5829 </span><span class="spaces">             </span><span class="nottickedoff">mbCombine rets_prxs $ flip mbMapCl mb_stmt</span>
<span class="lineno"> 5830 </span><span class="spaces">             </span><span class="nottickedoff">($(mkClosed [| \prxs stmt -&gt; nuMulti prxs (typedStmtOut stmt) |])</span>
<span class="lineno"> 5831 </span><span class="spaces">              </span><span class="nottickedoff">`clApply` toClosed rets_prxs)</span>
<span class="lineno"> 5832 </span><span class="spaces">       </span><span class="nottickedoff">ectx_gexprs &lt;- translate gexprs</span>
<span class="lineno"> 5833 </span><span class="spaces">       </span><span class="nottickedoff">ectx_args &lt;- translate args</span>
<span class="lineno"> 5834 </span><span class="spaces">       </span><span class="nottickedoff">pctx_in &lt;- RL.tail &lt;$&gt; itiPermStack &lt;$&gt; ask</span>
<span class="lineno"> 5835 </span><span class="spaces">       </span><span class="nottickedoff">let (pctx_ghosts_args, _) =</span>
<span class="lineno"> 5836 </span><span class="spaces">             </span><span class="nottickedoff">RL.split (RL.append ectx_gexprs ectx_args) ectx_gexprs pctx_in</span>
<span class="lineno"> 5837 </span><span class="spaces">       </span><span class="nottickedoff">fret_tp &lt;-</span>
<span class="lineno"> 5838 </span><span class="spaces">         </span><span class="nottickedoff">openTermTypeTrans &lt;$&gt;</span>
<span class="lineno"> 5839 </span><span class="spaces">         </span><span class="nottickedoff">sigmaTypeTransM &quot;ret&quot; rets_trans</span>
<span class="lineno"> 5840 </span><span class="spaces">         </span><span class="nottickedoff">(\ectx -&gt; inExtMultiTransM ectx (translate perms_out))</span>
<span class="lineno"> 5841 </span><span class="spaces">       </span><span class="nottickedoff">let all_args =</span>
<span class="lineno"> 5842 </span><span class="spaces">             </span><span class="nottickedoff">exprCtxToTerms ectx_gexprs ++ exprCtxToTerms ectx_args ++</span>
<span class="lineno"> 5843 </span><span class="spaces">             </span><span class="nottickedoff">transTerms pctx_ghosts_args</span>
<span class="lineno"> 5844 </span><span class="spaces">           </span><span class="nottickedoff">fapp_trm = case f_trans of</span>
<span class="lineno"> 5845 </span><span class="spaces">             </span><span class="nottickedoff">PTrans_Fun _ f_trm -&gt; applyFunTrans f_trm all_args</span>
<span class="lineno"> 5846 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 5847 </span><span class="spaces">               </span><span class="nottickedoff">panic &quot;translateStmt&quot;</span>
<span class="lineno"> 5848 </span><span class="spaces">               </span><span class="nottickedoff">[&quot;TypedCall: unexpected function permission&quot;]</span>
<span class="lineno"> 5849 </span><span class="spaces">       </span><span class="nottickedoff">bindTransM fapp_trm fret_tp &quot;call_ret_val&quot; $ \ret_val -&gt;</span>
<span class="lineno"> 5850 </span><span class="spaces">         </span><span class="nottickedoff">sigmaElimTransM &quot;elim_call_ret_val&quot; rets_trans</span>
<span class="lineno"> 5851 </span><span class="spaces">         </span><span class="nottickedoff">(flip inExtMultiTransM (translate perms_out)) compReturnTypeTransM</span>
<span class="lineno"> 5852 </span><span class="spaces">         </span><span class="nottickedoff">(\rets_ectx pctx -&gt;</span>
<span class="lineno"> 5853 </span><span class="spaces">           </span><span class="nottickedoff">inExtMultiTransM rets_ectx $</span>
<span class="lineno"> 5854 </span><span class="spaces">           </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 5855 </span><span class="spaces">           </span><span class="nottickedoff">(\(vars :&gt;: _) -&gt;</span>
<span class="lineno"> 5856 </span><span class="spaces">             </span><span class="nottickedoff">RL.append</span>
<span class="lineno"> 5857 </span><span class="spaces">             </span><span class="nottickedoff">(fst (RL.split</span>
<span class="lineno"> 5858 </span><span class="spaces">                   </span><span class="nottickedoff">(RL.append ectx_gexprs ectx_args) ectx_gexprs vars)) $</span>
<span class="lineno"> 5859 </span><span class="spaces">             </span><span class="nottickedoff">suffixMembers ectx_outer rets_prxs)</span>
<span class="lineno"> 5860 </span><span class="spaces">           </span><span class="nottickedoff">(const pctx)</span>
<span class="lineno"> 5861 </span><span class="spaces">           </span><span class="nottickedoff">m)</span>
<span class="lineno"> 5862 </span><span class="spaces">         </span><span class="nottickedoff">ret_val</span>
<span class="lineno"> 5863 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5864 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME HERE: figure out why these asserts always translate to ite True</span>
<span class="lineno"> 5865 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedAssert e _ |] -&gt;</span>
<span class="lineno"> 5866 </span><span class="spaces">    </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ite&quot;</span>
<span class="lineno"> 5867 </span><span class="spaces">    </span><span class="nottickedoff">[compReturnTypeM, translate1 e, m,</span>
<span class="lineno"> 5868 </span><span class="spaces">     </span><span class="nottickedoff">mkErrorComp (&quot;Failed Assert at &quot; ++</span>
<span class="lineno"> 5869 </span><span class="spaces">                  </span><span class="nottickedoff">renderDoc (ppShortFileName (plSourceLoc loc)))]</span>
<span class="lineno"> 5870 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5871 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMStmt stmt |] -&gt; translateLLVMStmt stmt m</span></span>
<span class="lineno"> 5872 </span>
<span class="lineno"> 5873 </span>
<span class="lineno"> 5874 </span>-- | Translate a 'TypedStmt' to a function on translation computations
<span class="lineno"> 5875 </span>translateLLVMStmt ::
<span class="lineno"> 5876 </span>  Mb ctx (TypedLLVMStmt r ps_in ps_out) -&gt;
<span class="lineno"> 5877 </span>  ImpTransM ext blocks tops rets ps_out (ctx :&gt; r) OpenTerm -&gt;
<span class="lineno"> 5878 </span>  ImpTransM ext blocks tops rets ps_in ctx OpenTerm
<span class="lineno"> 5879 </span><span class="decl"><span class="nottickedoff">translateLLVMStmt mb_stmt m = case mbMatch mb_stmt of</span>
<span class="lineno"> 5880 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| ConstructLLVMWord (TypedReg x) |] -&gt;</span>
<span class="lineno"> 5881 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 5882 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: (PTrans_Eq $ extMb $</span>
<span class="lineno"> 5883 </span><span class="spaces">                                           </span><span class="nottickedoff">fmap (PExpr_LLVMWord . PExpr_Var) x)) m</span>
<span class="lineno"> 5884 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5885 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| AssertLLVMWord reg _ |] -&gt;</span>
<span class="lineno"> 5886 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM (ETrans_Term knownRepr $ natOpenTerm 0) $</span>
<span class="lineno"> 5887 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM ((:&gt;: Member_Base) . RL.tail)</span>
<span class="lineno"> 5888 </span><span class="spaces">    </span><span class="nottickedoff">((:&gt;: (PTrans_Eq $ fmap (const $ PExpr_Nat 0) $ extMb reg)) . RL.tail)</span>
<span class="lineno"> 5889 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5890 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5891 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| AssertLLVMPtr _ |] -&gt;</span>
<span class="lineno"> 5892 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_Unit $</span>
<span class="lineno"> 5893 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM RL.tail RL.tail m</span>
<span class="lineno"> 5894 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5895 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| DestructLLVMWord _ e |] -&gt;</span>
<span class="lineno"> 5896 </span><span class="spaces">    </span><span class="nottickedoff">translate e &gt;&gt;= \etrans -&gt;</span>
<span class="lineno"> 5897 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM etrans $</span>
<span class="lineno"> 5898 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM ((:&gt;: Member_Base) . RL.tail)</span>
<span class="lineno"> 5899 </span><span class="spaces">    </span><span class="nottickedoff">((:&gt;: (PTrans_Eq $ extMb e)) . RL.tail)</span>
<span class="lineno"> 5900 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5901 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5902 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| OffsetLLVMValue _ _ |] -&gt;</span>
<span class="lineno"> 5903 </span><span class="spaces">    </span><span class="nottickedoff">let mb_x_off =</span>
<span class="lineno"> 5904 </span><span class="spaces">          </span><span class="nottickedoff">mbMapCl $(mkClosed [| \(OffsetLLVMValue x off) -&gt;</span>
<span class="lineno"> 5905 </span><span class="spaces">                               </span><span class="nottickedoff">PExpr_LLVMOffset (typedRegVar x) off |])</span>
<span class="lineno"> 5906 </span><span class="spaces">          </span><span class="nottickedoff">mb_stmt in</span>
<span class="lineno"> 5907 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 5908 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: (PTrans_Eq $ extMb $ mb_x_off))</span>
<span class="lineno"> 5909 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5910 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5911 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMLoad _ (mb_fp :: LLVMFieldPerm w sz)</span>
<span class="lineno"> 5912 </span><span class="spaces">                       </span><span class="nottickedoff">(_ :: DistPerms ps) cur_perms |] -&gt;</span>
<span class="lineno"> 5913 </span><span class="spaces">    </span><span class="nottickedoff">let prx_l = mbLifetimeCurrentPermsProxies cur_perms</span>
<span class="lineno"> 5914 </span><span class="spaces">        </span><span class="nottickedoff">prx_ps :: Proxy (ps :&gt; LLVMPointerType w) = Proxy in</span>
<span class="lineno"> 5915 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 5916 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM</span>
<span class="lineno"> 5917 </span><span class="spaces">    </span><span class="nottickedoff">(\(RL.split prx_ps prx_l -&gt; (vars, vars_l)) -&gt;</span>
<span class="lineno"> 5918 </span><span class="spaces">      </span><span class="nottickedoff">RL.append (vars :&gt;: Member_Base) vars_l)</span>
<span class="lineno"> 5919 </span><span class="spaces">    </span><span class="nottickedoff">(\(RL.split prx_ps prx_l -&gt; (pctx :&gt;: p_ptr, pctx_l)) -&gt;</span>
<span class="lineno"> 5920 </span><span class="spaces">      </span><span class="nottickedoff">let (_, p_ret) =</span>
<span class="lineno"> 5921 </span><span class="spaces">            </span><span class="nottickedoff">unPTransLLVMField &quot;translateLLVMStmt: TypedLLVMLoad: expected field perm&quot;</span>
<span class="lineno"> 5922 </span><span class="spaces">            </span><span class="nottickedoff">(knownNat @sz) p_ptr in</span>
<span class="lineno"> 5923 </span><span class="spaces">      </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 5924 </span><span class="spaces">      </span><span class="nottickedoff">RL.append</span>
<span class="lineno"> 5925 </span><span class="spaces">      </span><span class="nottickedoff">(pctx :&gt;: PTrans_Conj [APTrans_LLVMField</span>
<span class="lineno"> 5926 </span><span class="spaces">                             </span><span class="nottickedoff">(mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5927 </span><span class="spaces">                              </span><span class="nottickedoff">mbMapCl $(mkClosed</span>
<span class="lineno"> 5928 </span><span class="spaces">                                        </span><span class="nottickedoff">[| \fp -&gt; nu $ \ret -&gt;</span>
<span class="lineno"> 5929 </span><span class="spaces">                                          </span><span class="nottickedoff">llvmFieldSetEqVar fp ret |]) mb_fp)</span>
<span class="lineno"> 5930 </span><span class="spaces">                             </span><span class="nottickedoff">(PTrans_Eq $ mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5931 </span><span class="spaces">                              </span><span class="nottickedoff">fmap (const $ nu $ \ret -&gt; PExpr_Var ret) mb_fp)]</span>
<span class="lineno"> 5932 </span><span class="spaces">       </span><span class="nottickedoff">:&gt;: p_ret) pctx_l)</span>
<span class="lineno"> 5933 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5934 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5935 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMStore _ (mb_fp :: LLVMFieldPerm w sz) mb_e</span>
<span class="lineno"> 5936 </span><span class="spaces">                        </span><span class="nottickedoff">(_ :: DistPerms ps) cur_perms |] -&gt;</span>
<span class="lineno"> 5937 </span><span class="spaces">    </span><span class="nottickedoff">let prx_l = mbLifetimeCurrentPermsProxies cur_perms</span>
<span class="lineno"> 5938 </span><span class="spaces">        </span><span class="nottickedoff">prx_ps :: Proxy (ps :&gt; LLVMPointerType w) = Proxy in</span>
<span class="lineno"> 5939 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 5940 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_Unit $</span>
<span class="lineno"> 5941 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM id</span>
<span class="lineno"> 5942 </span><span class="spaces">    </span><span class="nottickedoff">(\(RL.split prx_ps prx_l -&gt; (pctx :&gt;: _p_ptr, pctx_l)) -&gt;</span>
<span class="lineno"> 5943 </span><span class="spaces">      </span><span class="nottickedoff">RL.append</span>
<span class="lineno"> 5944 </span><span class="spaces">      </span><span class="nottickedoff">(pctx :&gt;: PTrans_Conj [APTrans_LLVMField</span>
<span class="lineno"> 5945 </span><span class="spaces">                             </span><span class="nottickedoff">(extMb $ mbMap2 (\fp e -&gt;</span>
<span class="lineno"> 5946 </span><span class="spaces">                                               </span><span class="nottickedoff">fp { llvmFieldContents =</span>
<span class="lineno"> 5947 </span><span class="spaces">                                                      </span><span class="nottickedoff">ValPerm_Eq e })</span>
<span class="lineno"> 5948 </span><span class="spaces">                              </span><span class="nottickedoff">mb_fp mb_e)</span>
<span class="lineno"> 5949 </span><span class="spaces">                             </span><span class="nottickedoff">(PTrans_Eq $ extMb mb_e)])</span>
<span class="lineno"> 5950 </span><span class="spaces">      </span><span class="nottickedoff">pctx_l)</span>
<span class="lineno"> 5951 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5952 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5953 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMAlloca _ (mb_fperm :: LLVMFramePerm w) mb_sz |] -&gt;</span>
<span class="lineno"> 5954 </span><span class="spaces">    </span><span class="nottickedoff">let sz = mbLift mb_sz</span>
<span class="lineno"> 5955 </span><span class="spaces">        </span><span class="nottickedoff">w :: Proxy w = Proxy in</span>
<span class="lineno"> 5956 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 5957 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 5958 </span><span class="spaces">    </span><span class="nottickedoff">translateClosed (llvmEmptyBlockPermOfSize w sz) &gt;&gt;= \ptrans_tp -&gt;</span>
<span class="lineno"> 5959 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base)</span>
<span class="lineno"> 5960 </span><span class="spaces">    </span><span class="nottickedoff">(\(pctx :&gt;: _) -&gt;</span>
<span class="lineno"> 5961 </span><span class="spaces">      </span><span class="nottickedoff">pctx</span>
<span class="lineno"> 5962 </span><span class="spaces">      </span><span class="nottickedoff">:&gt;: PTrans_Conj [APTrans_LLVMFrame $</span>
<span class="lineno"> 5963 </span><span class="spaces">                       </span><span class="nottickedoff">flip nuMultiWithElim1 (extMb mb_fperm) $</span>
<span class="lineno"> 5964 </span><span class="spaces">                       </span><span class="nottickedoff">\(_ :&gt;: ret) fperm -&gt; (PExpr_Var ret, sz):fperm]</span>
<span class="lineno"> 5965 </span><span class="spaces">      </span><span class="nottickedoff">-- the unitTermLike argument is because ptrans_tp is a memblock permission</span>
<span class="lineno"> 5966 </span><span class="spaces">      </span><span class="nottickedoff">-- with an empty shape; the empty shape expects a unit argument</span>
<span class="lineno"> 5967 </span><span class="spaces">      </span><span class="nottickedoff">:&gt;: typeTransF ptrans_tp [])</span>
<span class="lineno"> 5968 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5969 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5970 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMCreateFrame |] -&gt;</span>
<span class="lineno"> 5971 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 5972 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVMFrame $</span>
<span class="lineno"> 5973 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base)</span>
<span class="lineno"> 5974 </span><span class="spaces">    </span><span class="nottickedoff">(:&gt;: PTrans_Conj [APTrans_LLVMFrame $ fmap (const []) (extMb mb_stmt)])</span>
<span class="lineno"> 5975 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5976 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5977 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMDeleteFrame _ _ _ |] -&gt;</span>
<span class="lineno"> 5978 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_Unit $</span>
<span class="lineno"> 5979 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM (const MNil) (const MNil) m</span>
<span class="lineno"> 5980 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5981 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMLoadHandle _ tp _ |] -&gt;</span>
<span class="lineno"> 5982 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_Fun $</span>
<span class="lineno"> 5983 </span><span class="spaces">    </span><span class="nottickedoff">withPermStackM ((:&gt;: Member_Base) . RL.tail)</span>
<span class="lineno"> 5984 </span><span class="spaces">    </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 5985 </span><span class="spaces">        </span><span class="nottickedoff">(pctx :&gt;: PTrans_Conj [APTrans_LLVMFunPtr tp' ptrans])</span>
<span class="lineno"> 5986 </span><span class="spaces">          </span><span class="nottickedoff">| Just Refl &lt;- testEquality (mbLift tp) tp' -&gt;</span>
<span class="lineno"> 5987 </span><span class="spaces">            </span><span class="nottickedoff">pctx :&gt;: ptrans</span>
<span class="lineno"> 5988 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; error (&quot;translateLLVMStmt: TypedLLVMLoadHandle: &quot;</span>
<span class="lineno"> 5989 </span><span class="spaces">                    </span><span class="nottickedoff">++ &quot;unexpected permission stack&quot;))</span>
<span class="lineno"> 5990 </span><span class="spaces">    </span><span class="nottickedoff">m</span>
<span class="lineno"> 5991 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5992 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMResolveGlobal gsym (p :: ValuePerm (LLVMPointerType w))|] -&gt;</span>
<span class="lineno"> 5993 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 5994 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 5995 </span><span class="spaces">    </span><span class="nottickedoff">do env &lt;- infoEnv &lt;$&gt; ask</span>
<span class="lineno"> 5996 </span><span class="spaces">       </span><span class="nottickedoff">let w :: NatRepr w = knownRepr</span>
<span class="lineno"> 5997 </span><span class="spaces">       </span><span class="nottickedoff">case lookupGlobalSymbol env (mbLift gsym) w of</span>
<span class="lineno"> 5998 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5999 </span><span class="spaces">           </span><span class="nottickedoff">panic &quot;translateLLVMStmt&quot;</span>
<span class="lineno"> 6000 </span><span class="spaces">           </span><span class="nottickedoff">[&quot;TypedLLVMResolveGlobal: no translation of symbol &quot;</span>
<span class="lineno"> 6001 </span><span class="spaces">            </span><span class="nottickedoff">++ globalSymbolName (mbLift gsym)]</span>
<span class="lineno"> 6002 </span><span class="spaces">         </span><span class="nottickedoff">Just (_, GlobalTrans ts) -&gt;</span>
<span class="lineno"> 6003 </span><span class="spaces">           </span><span class="nottickedoff">do ptrans &lt;- translate (extMb p)</span>
<span class="lineno"> 6004 </span><span class="spaces">              </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: typeTransF ptrans ts) m</span>
<span class="lineno"> 6005 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6006 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| TypedLLVMIte _ mb_r1 _ _ |] -&gt;</span>
<span class="lineno"> 6007 </span><span class="spaces">    </span><span class="nottickedoff">inExtTransM ETrans_LLVM $</span>
<span class="lineno"> 6008 </span><span class="spaces">    </span><span class="nottickedoff">do b &lt;- translate1 $ extMb mb_r1</span>
<span class="lineno"> 6009 </span><span class="spaces">       </span><span class="nottickedoff">tptrans &lt;-</span>
<span class="lineno"> 6010 </span><span class="spaces">         </span><span class="nottickedoff">translate $ mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 6011 </span><span class="spaces">         </span><span class="nottickedoff">mbMapCl $(mkClosed</span>
<span class="lineno"> 6012 </span><span class="spaces">                   </span><span class="nottickedoff">[| \stmt -&gt; nu $ \ret -&gt;</span>
<span class="lineno"> 6013 </span><span class="spaces">                     </span><span class="nottickedoff">distPermsHeadPerm $ typedLLVMStmtOut stmt ret |])</span>
<span class="lineno"> 6014 </span><span class="spaces">         </span><span class="nottickedoff">mb_stmt</span>
<span class="lineno"> 6015 </span><span class="spaces">       </span><span class="nottickedoff">let t = applyGlobalTermLike &quot;Prelude.boolToEither&quot; [b]</span>
<span class="lineno"> 6016 </span><span class="spaces">       </span><span class="nottickedoff">withPermStackM (:&gt;: Member_Base) (:&gt;: typeTransF tptrans [t]) m</span></span>
<span class="lineno"> 6017 </span>
<span class="lineno"> 6018 </span>
<span class="lineno"> 6019 </span>----------------------------------------------------------------------
<span class="lineno"> 6020 </span>-- * Translating Sequences of Typed Crucible Statements
<span class="lineno"> 6021 </span>----------------------------------------------------------------------
<span class="lineno"> 6022 </span>
<span class="lineno"> 6023 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6024 </span>         Translate (ImpTransInfo ext blocks tops rets ps) ctx
<span class="lineno"> 6025 </span>         (TypedRet tops rets ps) OpenTerm where
<span class="lineno"> 6026 </span>  <span class="decl"><span class="nottickedoff">translate (mbMatch -&gt; [nuMP| TypedRet Refl mb_rets mb_rets_ns mb_perms |]) =</span>
<span class="lineno"> 6027 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 6028 </span><span class="spaces">       </span><span class="nottickedoff">let perms =</span>
<span class="lineno"> 6029 </span><span class="spaces">             </span><span class="nottickedoff">mbMap2</span>
<span class="lineno"> 6030 </span><span class="spaces">             </span><span class="nottickedoff">(\rets_ns ps -&gt; varSubst (permVarSubstOfNames rets_ns) ps)</span>
<span class="lineno"> 6031 </span><span class="spaces">             </span><span class="nottickedoff">mb_rets_ns mb_perms</span>
<span class="lineno"> 6032 </span><span class="spaces">       </span><span class="nottickedoff">() &lt;- assertPermStackEqM &quot;TypedRet&quot; perms</span>
<span class="lineno"> 6033 </span><span class="spaces">       </span><span class="nottickedoff">rets_trans &lt;- translate mb_rets</span>
<span class="lineno"> 6034 </span><span class="spaces">       </span><span class="nottickedoff">let rets_prxs = cruCtxProxies $ mbLift mb_rets</span>
<span class="lineno"> 6035 </span><span class="spaces">       </span><span class="nottickedoff">rets_ns_trans &lt;- translate mb_rets_ns</span>
<span class="lineno"> 6036 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- returnTypeM</span>
<span class="lineno"> 6037 </span><span class="spaces">       </span><span class="nottickedoff">retSOpenTerm ev ret_tp &lt;$&gt;</span>
<span class="lineno"> 6038 </span><span class="spaces">         </span><span class="nottickedoff">sigmaTransM &quot;r&quot; rets_trans</span>
<span class="lineno"> 6039 </span><span class="spaces">         </span><span class="nottickedoff">(flip inExtMultiTransM $</span>
<span class="lineno"> 6040 </span><span class="spaces">          </span><span class="nottickedoff">translate $ mbCombine rets_prxs mb_perms)</span>
<span class="lineno"> 6041 </span><span class="spaces">         </span><span class="nottickedoff">rets_ns_trans (itiPermStack &lt;$&gt; ask)</span></span>
<span class="lineno"> 6042 </span>
<span class="lineno"> 6043 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6044 </span>         ImplTranslateF (TypedRet tops rets) ext blocks tops rets where
<span class="lineno"> 6045 </span>  <span class="decl"><span class="nottickedoff">translateF mb_ret = translate mb_ret</span></span>
<span class="lineno"> 6046 </span>
<span class="lineno"> 6047 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6048 </span>         Translate (ImpTransInfo ext blocks tops rets ps) ctx
<span class="lineno"> 6049 </span>         (TypedTermStmt blocks tops rets ps) OpenTerm where
<span class="lineno"> 6050 </span>  <span class="decl"><span class="nottickedoff">translate mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 6051 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedJump impl_tgt |] -&gt; translate impl_tgt</span>
<span class="lineno"> 6052 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedBr reg impl_tgt1 impl_tgt2 |] -&gt;</span>
<span class="lineno"> 6053 </span><span class="spaces">      </span><span class="nottickedoff">applyGlobalTransM &quot;Prelude.ite&quot;</span>
<span class="lineno"> 6054 </span><span class="spaces">      </span><span class="nottickedoff">[compReturnTypeM, translate1 reg,</span>
<span class="lineno"> 6055 </span><span class="spaces">       </span><span class="nottickedoff">translate impl_tgt1, translate impl_tgt2]</span>
<span class="lineno"> 6056 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedReturn impl_ret |] -&gt; translate impl_ret</span>
<span class="lineno"> 6057 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedErrorStmt (Just str) _ |] -&gt;</span>
<span class="lineno"> 6058 </span><span class="spaces">      </span><span class="nottickedoff">mkErrorComp (&quot;Error: &quot; ++ mbLift str)</span>
<span class="lineno"> 6059 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedErrorStmt Nothing _ |] -&gt;</span>
<span class="lineno"> 6060 </span><span class="spaces">      </span><span class="nottickedoff">mkErrorComp &quot;Error (unknown message)&quot;</span></span>
<span class="lineno"> 6061 </span>
<span class="lineno"> 6062 </span>
<span class="lineno"> 6063 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6064 </span>         Translate (ImpTransInfo ext blocks tops rets ps) ctx
<span class="lineno"> 6065 </span>         (TypedStmtSeq ext blocks tops rets ps) OpenTerm where
<span class="lineno"> 6066 </span>  <span class="decl"><span class="nottickedoff">translate mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 6067 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedImplStmt impl_seq |] -&gt; translate impl_seq</span>
<span class="lineno"> 6068 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedConsStmt loc stmt pxys mb_seq |] -&gt;</span>
<span class="lineno"> 6069 </span><span class="spaces">      </span><span class="nottickedoff">translateStmt (mbLift loc) stmt (translate $ mbCombine (mbLift pxys) (_mbBinding &lt;$&gt; mb_seq))</span>
<span class="lineno"> 6070 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedTermStmt _ term_stmt |] -&gt; translate term_stmt</span></span>
<span class="lineno"> 6071 </span>
<span class="lineno"> 6072 </span>instance PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6073 </span>         ImplTranslateF (TypedStmtSeq
<span class="lineno"> 6074 </span>                         ext blocks tops rets) ext blocks tops rets where
<span class="lineno"> 6075 </span>  <span class="decl"><span class="nottickedoff">translateF mb_seq = translate mb_seq</span></span>
<span class="lineno"> 6076 </span>
<span class="lineno"> 6077 </span>
<span class="lineno"> 6078 </span>----------------------------------------------------------------------
<span class="lineno"> 6079 </span>-- * Translating CFGs
<span class="lineno"> 6080 </span>----------------------------------------------------------------------
<span class="lineno"> 6081 </span>
<span class="lineno"> 6082 </span>-- | An entrypoint over some regular and ghost arguments
<span class="lineno"> 6083 </span>data SomeTypedEntry ext blocks tops rets =
<span class="lineno"> 6084 </span>  forall ghosts args.
<span class="lineno"> 6085 </span>  SomeTypedEntry (TypedEntry TransPhase ext blocks tops rets args ghosts)
<span class="lineno"> 6086 </span>
<span class="lineno"> 6087 </span>-- | Get all entrypoints in a block map that will be translated to recursive
<span class="lineno"> 6088 </span>-- functions, which is all entrypoints with in-degree &gt; 1
<span class="lineno"> 6089 </span>typedBlockRecEntries :: TypedBlockMap TransPhase ext blocks tops rets -&gt;
<span class="lineno"> 6090 </span>                        [SomeTypedEntry ext blocks tops rets]
<span class="lineno"> 6091 </span><span class="decl"><span class="nottickedoff">typedBlockRecEntries =</span>
<span class="lineno"> 6092 </span><span class="spaces">  </span><span class="nottickedoff">concat . RL.mapToList (map (\(Some entry) -&gt;</span>
<span class="lineno"> 6093 </span><span class="spaces">                               </span><span class="nottickedoff">SomeTypedEntry entry)</span>
<span class="lineno"> 6094 </span><span class="spaces">                         </span><span class="nottickedoff">. filter (anyF typedEntryHasMultiInDegree)</span>
<span class="lineno"> 6095 </span><span class="spaces">                         </span><span class="nottickedoff">. (^. typedBlockEntries))</span></span>
<span class="lineno"> 6096 </span>
<span class="lineno"> 6097 </span>-- | Fold a function over each 'TypedEntry' in a 'TypedBlockMap' that
<span class="lineno"> 6098 </span>-- corresponds to a letrec-bound variable
<span class="lineno"> 6099 </span>foldBlockMapRec ::
<span class="lineno"> 6100 </span>  (forall args ghosts.
<span class="lineno"> 6101 </span>   TypedEntry TransPhase ext blocks tops rets args ghosts -&gt; b -&gt; b) -&gt;
<span class="lineno"> 6102 </span>  b -&gt; TypedBlockMap TransPhase ext blocks tops rets -&gt; b
<span class="lineno"> 6103 </span><span class="decl"><span class="nottickedoff">foldBlockMapRec f r =</span>
<span class="lineno"> 6104 </span><span class="spaces">  </span><span class="nottickedoff">foldr (\(SomeTypedEntry entry) -&gt; f entry) r . typedBlockRecEntries</span></span>
<span class="lineno"> 6105 </span>
<span class="lineno"> 6106 </span>-- | Map a function over each 'TypedEntry' in a 'TypedBlockMap' that
<span class="lineno"> 6107 </span>-- corresponds to a letrec-bound variable
<span class="lineno"> 6108 </span>mapBlockMapRecs ::
<span class="lineno"> 6109 </span>  (forall args ghosts.
<span class="lineno"> 6110 </span>   TypedEntry TransPhase ext blocks tops rets args ghosts -&gt; b) -&gt;
<span class="lineno"> 6111 </span>  TypedBlockMap TransPhase ext blocks tops rets -&gt; [b]
<span class="lineno"> 6112 </span><span class="decl"><span class="nottickedoff">mapBlockMapRecs f =</span>
<span class="lineno"> 6113 </span><span class="spaces">  </span><span class="nottickedoff">map (\(SomeTypedEntry entry) -&gt; f entry) . typedBlockRecEntries</span></span>
<span class="lineno"> 6114 </span>
<span class="lineno"> 6115 </span>-- | Build the type of the translation of a 'TypedEntry' to a function. This
<span class="lineno"> 6116 </span>-- type will pi-abstract over the real and ghost arguments, but have the
<span class="lineno"> 6117 </span>-- top-level arguments of the function free, and then form a function from the
<span class="lineno"> 6118 </span>-- translations of the input to the output permissions
<span class="lineno"> 6119 </span>translateEntryType :: TypedEntry TransPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 6120 </span>                      TypeTransM tops OpenTerm
<span class="lineno"> 6121 </span><span class="decl"><span class="nottickedoff">translateEntryType (TypedEntry {..}) =</span>
<span class="lineno"> 6122 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: we translate the return type here because it has only the tops and</span>
<span class="lineno"> 6123 </span><span class="spaces">  </span><span class="nottickedoff">-- rets free, not the args and ghosts</span>
<span class="lineno"> 6124 </span><span class="spaces">  </span><span class="nottickedoff">(translateRetType typedEntryRets typedEntryPermsOut) &gt;&gt;= \ret_tp -&gt;</span>
<span class="lineno"> 6125 </span><span class="spaces">  </span><span class="nottickedoff">piExprCtxApp typedEntryArgs $ piExprCtxApp typedEntryGhosts $</span>
<span class="lineno"> 6126 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 6127 </span><span class="spaces">     </span><span class="nottickedoff">ps_in_trans &lt;- translate typedEntryPermsIn</span>
<span class="lineno"> 6128 </span><span class="spaces">     </span><span class="nottickedoff">piTransM &quot;p&quot; ps_in_trans $ \_ -&gt; return $ specMTypeOpenTerm ev ret_tp</span></span>
<span class="lineno"> 6129 </span>
<span class="lineno"> 6130 </span>-- | Build the type description of the type returned by 'translateEntryType'
<span class="lineno"> 6131 </span>-- that is the type of the translation of a 'TypedEntry' to a function
<span class="lineno"> 6132 </span>translateEntryDesc :: TypedEntry TransPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 6133 </span>                      TypeTransM tops OpenTerm
<span class="lineno"> 6134 </span><span class="decl"><span class="nottickedoff">translateEntryDesc (TypedEntry {..}) =</span>
<span class="lineno"> 6135 </span><span class="spaces">  </span><span class="nottickedoff">descTransM $</span>
<span class="lineno"> 6136 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: we translate the return type here because it has only the tops and</span>
<span class="lineno"> 6137 </span><span class="spaces">  </span><span class="nottickedoff">-- rets free, not the args and ghosts</span>
<span class="lineno"> 6138 </span><span class="spaces">  </span><span class="nottickedoff">(translateRetTpDesc typedEntryRets typedEntryPermsOut) &gt;&gt;= \d_out -&gt;</span>
<span class="lineno"> 6139 </span><span class="spaces">  </span><span class="nottickedoff">inExtCtxDescTransM typedEntryArgs $ \args_kdescs -&gt;</span>
<span class="lineno"> 6140 </span><span class="spaces">  </span><span class="nottickedoff">inExtCtxDescTransM typedEntryGhosts $ \ghosts_kdescs -&gt;</span>
<span class="lineno"> 6141 </span><span class="spaces">  </span><span class="nottickedoff">do ds_in &lt;- translateDescs typedEntryPermsIn</span>
<span class="lineno"> 6142 </span><span class="spaces">     </span><span class="nottickedoff">return $</span>
<span class="lineno"> 6143 </span><span class="spaces">       </span><span class="nottickedoff">piTpDescMulti (args_kdescs ++ ghosts_kdescs) $ funTpDesc ds_in d_out</span></span>
<span class="lineno"> 6144 </span>
<span class="lineno"> 6145 </span>-- | Build a list of the types of all of the entrypoints in a 'TypedBlockMap'
<span class="lineno"> 6146 </span>-- that will be translated to recursive functions
<span class="lineno"> 6147 </span>translateBlockMapTypes :: TypedBlockMap TransPhase ext blocks tops rets -&gt;
<span class="lineno"> 6148 </span>                          TypeTransM tops [OpenTerm]
<span class="lineno"> 6149 </span><span class="decl"><span class="nottickedoff">translateBlockMapTypes blkMap =</span>
<span class="lineno"> 6150 </span><span class="spaces">  </span><span class="nottickedoff">sequence $ mapBlockMapRecs translateEntryType blkMap</span></span>
<span class="lineno"> 6151 </span>
<span class="lineno"> 6152 </span>-- | Build a list of the type descriptions of all of the entrypoints in a
<span class="lineno"> 6153 </span>-- 'TypedBlockMap' that will be translated to recursive functions
<span class="lineno"> 6154 </span>translateBlockMapDescs :: TypedBlockMap TransPhase ext blocks tops rets -&gt;
<span class="lineno"> 6155 </span>                          TypeTransM tops [OpenTerm]
<span class="lineno"> 6156 </span><span class="decl"><span class="nottickedoff">translateBlockMapDescs blkMap =</span>
<span class="lineno"> 6157 </span><span class="spaces">  </span><span class="nottickedoff">sequence $ mapBlockMapRecs translateEntryDesc blkMap</span></span>
<span class="lineno"> 6158 </span>
<span class="lineno"> 6159 </span>-- | Translate the function permission of a CFG to a type description that
<span class="lineno"> 6160 </span>-- pi-abstracts over the real and ghost arguments and then takes in the input
<span class="lineno"> 6161 </span>-- permissions, returning a tuple of the output permissions. This is the same as
<span class="lineno"> 6162 </span>-- the translation of its function permission to a type description.
<span class="lineno"> 6163 </span>translateCFGDesc :: TypedCFG ext blocks ghosts inits gouts ret -&gt;
<span class="lineno"> 6164 </span>                    TypeTransM ctx OpenTerm
<span class="lineno"> 6165 </span><span class="decl"><span class="nottickedoff">translateCFGDesc cfg =</span>
<span class="lineno"> 6166 </span><span class="spaces">  </span><span class="nottickedoff">nuMultiTransM (const $ tpcfgFunPerm cfg) &gt;&gt;=</span>
<span class="lineno"> 6167 </span><span class="spaces">  </span><span class="nottickedoff">descTransM . translateDesc</span></span>
<span class="lineno"> 6168 </span>
<span class="lineno"> 6169 </span>-- | Translate a 'TypedEntry' to a 'TypedEntryTrans' by associating a monadic
<span class="lineno"> 6170 </span>-- function with it if it has one, i.e., if its in-degree is greater than 1. The
<span class="lineno"> 6171 </span>-- state tracks all the @LetRecS@-bound functions for entrypoints that have not
<span class="lineno"> 6172 </span>-- already been used, so if this 'TypedEntry' does need a function, it should
<span class="lineno"> 6173 </span>-- take it from the head of that list.
<span class="lineno"> 6174 </span>translateTypedEntry ::
<span class="lineno"> 6175 </span>  Some (TypedEntry TransPhase ext blocks tops rets args) -&gt;
<span class="lineno"> 6176 </span>  StateT [OpenTerm] (TypeTransM tops) (Some
<span class="lineno"> 6177 </span>                                       (TypedEntryTrans ext blocks tops rets args))
<span class="lineno"> 6178 </span><span class="decl"><span class="nottickedoff">translateTypedEntry (Some entry) =</span>
<span class="lineno"> 6179 </span><span class="spaces">  </span><span class="nottickedoff">if typedEntryHasMultiInDegree entry then</span>
<span class="lineno"> 6180 </span><span class="spaces">    </span><span class="nottickedoff">do fs &lt;- get</span>
<span class="lineno"> 6181 </span><span class="spaces">       </span><span class="nottickedoff">let (f, fs') =</span>
<span class="lineno"> 6182 </span><span class="spaces">             </span><span class="nottickedoff">case fs of</span>
<span class="lineno"> 6183 </span><span class="spaces">               </span><span class="nottickedoff">[] -&gt; panic &quot;translateTypedEntry&quot; [&quot;Ran out of functions&quot;]</span>
<span class="lineno"> 6184 </span><span class="spaces">               </span><span class="nottickedoff">f_:fs'_ -&gt; (f_, fs'_)</span>
<span class="lineno"> 6185 </span><span class="spaces">       </span><span class="nottickedoff">put fs'</span>
<span class="lineno"> 6186 </span><span class="spaces">       </span><span class="nottickedoff">return (Some (TypedEntryTrans entry $ Just f))</span>
<span class="lineno"> 6187 </span><span class="spaces">  </span><span class="nottickedoff">else return $ Some (TypedEntryTrans entry Nothing)</span></span>
<span class="lineno"> 6188 </span>
<span class="lineno"> 6189 </span>-- | Translate a 'TypedBlock' to a 'TypedBlockTrans' by translating each
<span class="lineno"> 6190 </span>-- entrypoint in the block using 'translateTypedEntry'
<span class="lineno"> 6191 </span>translateTypedBlock ::
<span class="lineno"> 6192 </span>  TypedBlock TransPhase ext blocks tops rets args -&gt;
<span class="lineno"> 6193 </span>  StateT [OpenTerm] (TypeTransM tops) (TypedBlockTrans ext blocks tops rets args)
<span class="lineno"> 6194 </span><span class="decl"><span class="nottickedoff">translateTypedBlock blk =</span>
<span class="lineno"> 6195 </span><span class="spaces">  </span><span class="nottickedoff">TypedBlockTrans &lt;$&gt; mapM translateTypedEntry (blk ^. typedBlockEntries)</span></span>
<span class="lineno"> 6196 </span>
<span class="lineno"> 6197 </span>-- | Helper function to translate a 'TypedBlockMap' to a 'TypedBlockMapTrans' by
<span class="lineno"> 6198 </span>-- translating every entrypoint using 'translateTypedEntry'
<span class="lineno"> 6199 </span>translateTypedBlockMapH ::
<span class="lineno"> 6200 </span>  RAssign (TypedBlock TransPhase ext blocks tops rets) blks -&gt;
<span class="lineno"> 6201 </span>  StateT [OpenTerm] (TypeTransM tops) (RAssign
<span class="lineno"> 6202 </span>                                       (TypedBlockTrans ext blocks tops rets) blks)
<span class="lineno"> 6203 </span><span class="decl"><span class="nottickedoff">translateTypedBlockMapH MNil = return MNil</span>
<span class="lineno"> 6204 </span><span class="spaces"></span><span class="nottickedoff">translateTypedBlockMapH (blkMap :&gt;: blk) =</span>
<span class="lineno"> 6205 </span><span class="spaces">  </span><span class="nottickedoff">do blkMapTrans &lt;- translateTypedBlockMapH blkMap</span>
<span class="lineno"> 6206 </span><span class="spaces">     </span><span class="nottickedoff">blkTrans &lt;- translateTypedBlock blk</span>
<span class="lineno"> 6207 </span><span class="spaces">     </span><span class="nottickedoff">return (blkMapTrans :&gt;: blkTrans)</span></span>
<span class="lineno"> 6208 </span>
<span class="lineno"> 6209 </span>-- | Translate a 'TypedBlockMap' to a 'TypedBlockMapTrans' by translating every
<span class="lineno"> 6210 </span>-- entrypoint using 'translateTypedEntry', using the supplied SAW core terms as
<span class="lineno"> 6211 </span>-- the recursive functions for those entrypoints that have them
<span class="lineno"> 6212 </span>translateTypedBlockMap ::
<span class="lineno"> 6213 </span>  [OpenTerm] -&gt; TypedBlockMap TransPhase ext blocks tops rets -&gt;
<span class="lineno"> 6214 </span>  TypeTransM tops (TypedBlockMapTrans ext blocks tops rets)
<span class="lineno"> 6215 </span><span class="decl"><span class="nottickedoff">translateTypedBlockMap fs blkMap =</span>
<span class="lineno"> 6216 </span><span class="spaces">  </span><span class="nottickedoff">runStateT (translateTypedBlockMapH blkMap) fs &gt;&gt;= \case</span>
<span class="lineno"> 6217 </span><span class="spaces">  </span><span class="nottickedoff">(ret, []) -&gt; return ret</span>
<span class="lineno"> 6218 </span><span class="spaces">  </span><span class="nottickedoff">(_, _) -&gt; panic &quot;translateTypedBlockMap&quot; [&quot;Unused function indices&quot;]</span></span>
<span class="lineno"> 6219 </span>
<span class="lineno"> 6220 </span>-- | Lambda-abstract over monadic functions for all the entrypoints that have
<span class="lineno"> 6221 </span>-- one in a 'TypedBlockMap', whose types are given as the first argument, and
<span class="lineno"> 6222 </span>-- then use those functions to translate the block map to a 'TypedBlockMapTrans'
<span class="lineno"> 6223 </span>-- and pass it to the supplied function
<span class="lineno"> 6224 </span>lambdaBlockMap :: [OpenTerm] -&gt; TypedBlockMap TransPhase ext blocks tops rets -&gt;
<span class="lineno"> 6225 </span>                  (TypedBlockMapTrans ext blocks tops rets -&gt;
<span class="lineno"> 6226 </span>                   TypeTransM tops OpenTerm) -&gt;
<span class="lineno"> 6227 </span>                  TypeTransM tops OpenTerm
<span class="lineno"> 6228 </span><span class="decl"><span class="nottickedoff">lambdaBlockMap blk_tps blkMap f =</span>
<span class="lineno"> 6229 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTransM &quot;f_loop&quot; (openTermsTypeTrans blk_tps) $ \fs -&gt;</span>
<span class="lineno"> 6230 </span><span class="spaces">  </span><span class="nottickedoff">translateTypedBlockMap fs blkMap &gt;&gt;= f</span></span>
<span class="lineno"> 6231 </span>
<span class="lineno"> 6232 </span>
<span class="lineno"> 6233 </span>-- | Translate the typed statements of an entrypoint to a function
<span class="lineno"> 6234 </span>--
<span class="lineno"> 6235 </span>-- &gt; \arg1 ... argm ghost1 ... ghostk p1 ... pj -&gt; stmts_trans
<span class="lineno"> 6236 </span>--
<span class="lineno"> 6237 </span>-- over the local and ghost arguments and (the translations of) the input
<span class="lineno"> 6238 </span>-- permissions of the entrypoint, leaving the top-level variables free
<span class="lineno"> 6239 </span>translateEntryBody :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6240 </span>                      TypedBlockMapTrans ext blocks tops rets -&gt;
<span class="lineno"> 6241 </span>                      TypedEntry TransPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 6242 </span>                      TypeTransM tops OpenTerm
<span class="lineno"> 6243 </span><span class="decl"><span class="nottickedoff">translateEntryBody mapTrans entry =</span>
<span class="lineno"> 6244 </span><span class="spaces">  </span><span class="nottickedoff">lambdaExprCtxApp (typedEntryArgs entry) $</span>
<span class="lineno"> 6245 </span><span class="spaces">  </span><span class="nottickedoff">lambdaExprCtxApp (typedEntryGhosts entry) $</span>
<span class="lineno"> 6246 </span><span class="spaces">  </span><span class="nottickedoff">lambdaPermCtx (typedEntryPermsIn entry) $ \pctx -&gt;</span>
<span class="lineno"> 6247 </span><span class="spaces">  </span><span class="nottickedoff">do retType &lt;- translateEntryRetType entry</span>
<span class="lineno"> 6248 </span><span class="spaces">     </span><span class="nottickedoff">impTransM (RL.members pctx) pctx mapTrans retType $</span>
<span class="lineno"> 6249 </span><span class="spaces">       </span><span class="nottickedoff">translate $ _mbBinding $ typedEntryBody entry</span></span>
<span class="lineno"> 6250 </span>
<span class="lineno"> 6251 </span>-- | Translate all the entrypoints in a 'TypedBlockMap' that translate to
<span class="lineno"> 6252 </span>-- recursive functions into the bodies of those functions
<span class="lineno"> 6253 </span>translateBlockMapBodies :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6254 </span>                           TypedBlockMapTrans ext blocks tops rets -&gt;
<span class="lineno"> 6255 </span>                           TypedBlockMap TransPhase ext blocks tops rets -&gt;
<span class="lineno"> 6256 </span>                           TypeTransM tops [OpenTerm]
<span class="lineno"> 6257 </span><span class="decl"><span class="nottickedoff">translateBlockMapBodies mapTrans blkMap =</span>
<span class="lineno"> 6258 </span><span class="spaces">  </span><span class="nottickedoff">sequence $ mapBlockMapRecs (translateEntryBody mapTrans) blkMap</span></span>
<span class="lineno"> 6259 </span>
<span class="lineno"> 6260 </span>-- | Translate a CFG to a monadic function that takes all the top-level
<span class="lineno"> 6261 </span>-- arguments to that CFG and calls into its initial entrypoint
<span class="lineno"> 6262 </span>translateCFGInitBody ::
<span class="lineno"> 6263 </span>  PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6264 </span>  TypedBlockMapTrans ext blocks (ghosts :++: inits) (gouts :&gt; ret) -&gt;
<span class="lineno"> 6265 </span>  TypedCFG ext blocks ghosts inits gouts ret -&gt;
<span class="lineno"> 6266 </span>  PermTransCtx (ghosts :++: inits) (ghosts :++: inits) -&gt;
<span class="lineno"> 6267 </span>  TypeTransM (ghosts :++: inits) OpenTerm
<span class="lineno"> 6268 </span><span class="decl"><span class="nottickedoff">translateCFGInitBody mapTrans cfg pctx =</span>
<span class="lineno"> 6269 </span><span class="spaces">  </span><span class="nottickedoff">let fun_perm = tpcfgFunPerm cfg</span>
<span class="lineno"> 6270 </span><span class="spaces">      </span><span class="nottickedoff">h = tpcfgHandle cfg</span>
<span class="lineno"> 6271 </span><span class="spaces">      </span><span class="nottickedoff">inits = typedFnHandleArgs h</span>
<span class="lineno"> 6272 </span><span class="spaces">      </span><span class="nottickedoff">ghosts = typedFnHandleGhosts h</span>
<span class="lineno"> 6273 </span><span class="spaces">      </span><span class="nottickedoff">retTypes = typedFnHandleRetTypes h in</span>
<span class="lineno"> 6274 </span><span class="spaces">  </span><span class="nottickedoff">translateRetType retTypes (tpcfgOutputPerms cfg) &gt;&gt;= \retTypeTrans -&gt;</span>
<span class="lineno"> 6275 </span><span class="spaces">  </span><span class="nottickedoff">impTransM (RL.members pctx) pctx mapTrans retTypeTrans $</span>
<span class="lineno"> 6276 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6277 </span><span class="spaces">  </span><span class="nottickedoff">-- Extend the expr context to contain another copy of the initial arguments</span>
<span class="lineno"> 6278 </span><span class="spaces">  </span><span class="nottickedoff">-- inits, since the initial entrypoint for the entire function takes two</span>
<span class="lineno"> 6279 </span><span class="spaces">  </span><span class="nottickedoff">-- copies of inits, one to represent the top-level arguments and one to</span>
<span class="lineno"> 6280 </span><span class="spaces">  </span><span class="nottickedoff">-- represent the local arguments to the entrypoint, which just happen to be</span>
<span class="lineno"> 6281 </span><span class="spaces">  </span><span class="nottickedoff">-- the same as those top-level arguments and so get eq perms to relate them</span>
<span class="lineno"> 6282 </span><span class="spaces">  </span><span class="nottickedoff">inExtMultiTransCopyLastM ghosts (cruCtxProxies inits) $</span>
<span class="lineno"> 6283 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6284 </span><span class="spaces">  </span><span class="nottickedoff">-- Pass in all the terms in pctx to build pctx', which is the same permissions</span>
<span class="lineno"> 6285 </span><span class="spaces">  </span><span class="nottickedoff">-- as pctx except with all the eq permissions added to the end of the input</span>
<span class="lineno"> 6286 </span><span class="spaces">  </span><span class="nottickedoff">-- permissions by funPermToBlockInputs; these introduce no extra terms, so the</span>
<span class="lineno"> 6287 </span><span class="spaces">  </span><span class="nottickedoff">-- terms for the two are the same</span>
<span class="lineno"> 6288 </span><span class="spaces">  </span><span class="nottickedoff">translate (funPermToBlockInputs fun_perm) &gt;&gt;= \ps'_trans -&gt;</span>
<span class="lineno"> 6289 </span><span class="spaces">  </span><span class="nottickedoff">let pctx' = typeTransF ps'_trans $ transTerms pctx</span>
<span class="lineno"> 6290 </span><span class="spaces">      </span><span class="nottickedoff">all_px = RL.map (\_ -&gt; Proxy) pctx'</span>
<span class="lineno"> 6291 </span><span class="spaces">      </span><span class="nottickedoff">init_entry = lookupEntryTransCast (tpcfgEntryID cfg) CruCtxNil mapTrans in</span>
<span class="lineno"> 6292 </span><span class="spaces">  </span><span class="nottickedoff">withPermStackM (const $ RL.members pctx') (const pctx') $</span>
<span class="lineno"> 6293 </span><span class="spaces">  </span><span class="nottickedoff">translateCallEntry &quot;CFG&quot; init_entry</span>
<span class="lineno"> 6294 </span><span class="spaces">  </span><span class="nottickedoff">(nuMulti all_px $ \ns -&gt; fst $ RL.split pctx (cruCtxProxies inits) ns)</span>
<span class="lineno"> 6295 </span><span class="spaces">  </span><span class="nottickedoff">(nuMulti all_px $ \ns -&gt; snd $ RL.split pctx (cruCtxProxies inits) ns)</span>
<span class="lineno"> 6296 </span><span class="spaces">  </span><span class="nottickedoff">(nuMulti all_px $ const MNil)</span></span>
<span class="lineno"> 6297 </span>
<span class="lineno"> 6298 </span>
<span class="lineno"> 6299 </span>-- | Translate a CFG to a function that takes in values for its top-level
<span class="lineno"> 6300 </span>-- arguments (@ghosts@ and @inits@) along with all its input permissions and
<span class="lineno"> 6301 </span>-- returns a sigma of its output values and permissions. This assumes that SAW
<span class="lineno"> 6302 </span>-- core functions have been bound for the function itself and any other
<span class="lineno"> 6303 </span>-- functions it is mutually recursive with, and that these SAW core functions
<span class="lineno"> 6304 </span>-- are in the current permissions environment. That is, this translation is
<span class="lineno"> 6305 </span>-- happening for the body of a @LetRecS@ definition that has bound SAW core
<span class="lineno"> 6306 </span>-- functions for the function itself and all functions it is mutually recursive
<span class="lineno"> 6307 </span>-- with.
<span class="lineno"> 6308 </span>translateCFGBody :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 6309 </span>                    TypedCFG ext blocks ghosts inits gouts ret -&gt;
<span class="lineno"> 6310 </span>                    TypeTransM RNil OpenTerm
<span class="lineno"> 6311 </span><span class="decl"><span class="nottickedoff">translateCFGBody cfg =</span>
<span class="lineno"> 6312 </span><span class="spaces">  </span><span class="nottickedoff">let fun_perm = tpcfgFunPerm cfg</span>
<span class="lineno"> 6313 </span><span class="spaces">      </span><span class="nottickedoff">blkMap = tpcfgBlockMap cfg in</span>
<span class="lineno"> 6314 </span><span class="spaces">  </span><span class="nottickedoff">lambdaExprCtx (funPermTops fun_perm) $</span>
<span class="lineno"> 6315 </span><span class="spaces">  </span><span class="nottickedoff">lambdaPermCtx (funPermIns fun_perm) $ \pctx -&gt;</span>
<span class="lineno"> 6316 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 6317 </span><span class="spaces">     </span><span class="nottickedoff">blk_ds &lt;- translateBlockMapDescs $ tpcfgBlockMap cfg</span>
<span class="lineno"> 6318 </span><span class="spaces">     </span><span class="nottickedoff">blk_tps &lt;- translateBlockMapTypes $ tpcfgBlockMap cfg</span>
<span class="lineno"> 6319 </span><span class="spaces">     </span><span class="nottickedoff">ret_tp &lt;- translateRetType (funPermRets fun_perm) (funPermOuts fun_perm)</span>
<span class="lineno"> 6320 </span><span class="spaces">     </span><span class="nottickedoff">bodies &lt;-</span>
<span class="lineno"> 6321 </span><span class="spaces">       </span><span class="nottickedoff">lambdaBlockMap blk_tps blkMap $ \mapTrans -&gt;</span>
<span class="lineno"> 6322 </span><span class="spaces">       </span><span class="nottickedoff">tupleOpenTerm &lt;$&gt; translateBlockMapBodies mapTrans blkMap</span>
<span class="lineno"> 6323 </span><span class="spaces">     </span><span class="nottickedoff">body &lt;-</span>
<span class="lineno"> 6324 </span><span class="spaces">       </span><span class="nottickedoff">lambdaBlockMap blk_tps blkMap $ \mapTrans -&gt;</span>
<span class="lineno"> 6325 </span><span class="spaces">       </span><span class="nottickedoff">translateCFGInitBody mapTrans cfg pctx</span>
<span class="lineno"> 6326 </span><span class="spaces">     </span><span class="nottickedoff">return $ letRecSOpenTerm ev blk_ds ret_tp bodies body</span></span>
<span class="lineno"> 6327 </span>
<span class="lineno"> 6328 </span>
<span class="lineno"> 6329 </span>----------------------------------------------------------------------
<span class="lineno"> 6330 </span>-- * Translating Sets of CFGs
<span class="lineno"> 6331 </span>----------------------------------------------------------------------
<span class="lineno"> 6332 </span>
<span class="lineno"> 6333 </span>-- | An existentially quantified tuple of a 'TypedCFG', its 'GlobalSymbol', and
<span class="lineno"> 6334 </span>-- a 'String' name we want to translate it to
<span class="lineno"> 6335 </span>data SomeTypedCFG ext where
<span class="lineno"> 6336 </span>  SomeTypedCFG :: PermCheckExtC ext exprExt =&gt; GlobalSymbol -&gt; String -&gt;
<span class="lineno"> 6337 </span>                  TypedCFG ext blocks ghosts inits gouts ret -&gt;
<span class="lineno"> 6338 </span>                  SomeTypedCFG ext
<span class="lineno"> 6339 </span>
<span class="lineno"> 6340 </span>-- | Helper function to build an LLVM function permission from a 'FunPerm'
<span class="lineno"> 6341 </span>mkPtrFunPerm :: HasPtrWidth w =&gt; FunPerm ghosts args gouts ret -&gt;
<span class="lineno"> 6342 </span>                ValuePerm (LLVMPointerType w)
<span class="lineno"> 6343 </span><span class="decl"><span class="nottickedoff">mkPtrFunPerm fun_perm =</span>
<span class="lineno"> 6344 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $ ValPerm_Conj1 $ mkPermLLVMFunPtr ?ptrWidth fun_perm</span></span>
<span class="lineno"> 6345 </span>
<span class="lineno"> 6346 </span>-- | Extract the 'FunPerm' of a 'SomeTypedCFG' as a permission on LLVM function
<span class="lineno"> 6347 </span>-- pointer values
<span class="lineno"> 6348 </span>someTypedCFGPtrPerm :: HasPtrWidth w =&gt; SomeTypedCFG LLVM -&gt;
<span class="lineno"> 6349 </span>                       ValuePerm (LLVMPointerType w)
<span class="lineno"> 6350 </span><span class="decl"><span class="nottickedoff">someTypedCFGPtrPerm (SomeTypedCFG _ _ cfg) = mkPtrFunPerm $ tpcfgFunPerm cfg</span></span>
<span class="lineno"> 6351 </span>
<span class="lineno"> 6352 </span>-- | Apply 'translateCFGDesc' to the CFG in a 'SomeTypedCFG'
<span class="lineno"> 6353 </span>translateSomeCFGDesc :: SomeTypedCFG LLVM -&gt; TypeTransM ctx OpenTerm
<span class="lineno"> 6354 </span><span class="decl"><span class="nottickedoff">translateSomeCFGDesc (SomeTypedCFG _ _ cfg) = translateCFGDesc cfg</span></span>
<span class="lineno"> 6355 </span>
<span class="lineno"> 6356 </span>-- | Translate a CFG to its type as a specification function
<span class="lineno"> 6357 </span>translateSomeCFGType :: SomeTypedCFG LLVM -&gt; TypeTransM ctx OpenTerm
<span class="lineno"> 6358 </span><span class="decl"><span class="nottickedoff">translateSomeCFGType (SomeTypedCFG _ _ cfg) =</span>
<span class="lineno"> 6359 </span><span class="spaces">  </span><span class="nottickedoff">translateClosed (tpcfgFunPerm cfg)</span></span>
<span class="lineno"> 6360 </span>
<span class="lineno"> 6361 </span>-- | Apply 'translateCFGBody' to the CFG in a 'SomeTypedCFG'
<span class="lineno"> 6362 </span>translateSomeCFGBody :: SomeTypedCFG LLVM -&gt; TypeTransM RNil OpenTerm
<span class="lineno"> 6363 </span><span class="decl"><span class="nottickedoff">translateSomeCFGBody (SomeTypedCFG _ _ cfg) = translateCFGBody cfg</span></span>
<span class="lineno"> 6364 </span>
<span class="lineno"> 6365 </span>-- | Build an entry in a permissions environment that associates the symbol of a
<span class="lineno"> 6366 </span>-- 'SomeTypedCFG' with a function term
<span class="lineno"> 6367 </span>someTypedCFGFunEntry :: HasPtrWidth w =&gt; SomeTypedCFG LLVM -&gt; OpenTerm -&gt;
<span class="lineno"> 6368 </span>                        PermEnvGlobalEntry
<span class="lineno"> 6369 </span><span class="decl"><span class="nottickedoff">someTypedCFGFunEntry some_cfg@(SomeTypedCFG sym _ _) f =</span>
<span class="lineno"> 6370 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 6371 </span><span class="spaces">  </span><span class="nottickedoff">PermEnvGlobalEntry sym (someTypedCFGPtrPerm some_cfg)</span>
<span class="lineno"> 6372 </span><span class="spaces">  </span><span class="nottickedoff">(GlobalTrans [f])</span></span>
<span class="lineno"> 6373 </span>
<span class="lineno"> 6374 </span>-- | Build a lambda-abstraction that takes in function indexes for all the CFGs
<span class="lineno"> 6375 </span>-- in a list and then run the supplied computation with a 'PermEnv' that
<span class="lineno"> 6376 </span>-- includes translations of the symbols for these CFGs to their corresponding
<span class="lineno"> 6377 </span>-- lambda-bound function indexes in this lambda-abstraction
<span class="lineno"> 6378 </span>lambdaCFGPermEnv :: HasPtrWidth w =&gt; [SomeTypedCFG LLVM] -&gt;
<span class="lineno"> 6379 </span>                    TypeTransM ctx OpenTerm -&gt; TypeTransM ctx OpenTerm
<span class="lineno"> 6380 </span><span class="decl"><span class="nottickedoff">lambdaCFGPermEnv some_cfgs m =</span>
<span class="lineno"> 6381 </span><span class="spaces">  </span><span class="nottickedoff">mapM translateSomeCFGType some_cfgs &gt;&gt;= \tps -&gt;</span>
<span class="lineno"> 6382 </span><span class="spaces">  </span><span class="nottickedoff">lambdaTransM &quot;f&quot; (openTermsTypeTrans tps) $ \fs -&gt;</span>
<span class="lineno"> 6383 </span><span class="spaces">  </span><span class="nottickedoff">let entries = zipWith someTypedCFGFunEntry some_cfgs fs in</span>
<span class="lineno"> 6384 </span><span class="spaces">  </span><span class="nottickedoff">local (\info -&gt;</span>
<span class="lineno"> 6385 </span><span class="spaces">          </span><span class="nottickedoff">info { ttiPermEnv =</span>
<span class="lineno"> 6386 </span><span class="spaces">                   </span><span class="nottickedoff">permEnvAddGlobalSyms (ttiPermEnv info) entries }) m</span></span>
<span class="lineno"> 6387 </span>
<span class="lineno"> 6388 </span>-- | Translate a list of CFGs to a SAW core term of type @MultiFixBodies@ that
<span class="lineno"> 6389 </span>-- lambda-abstracts over function indexes for all the CFGs and returns a tuple
<span class="lineno"> 6390 </span>-- of their bodies as created by 'translateCFGBody'
<span class="lineno"> 6391 </span>translateCFGBodiesTerm :: HasPtrWidth w =&gt; [SomeTypedCFG LLVM] -&gt;
<span class="lineno"> 6392 </span>                          TypeTransM RNil OpenTerm
<span class="lineno"> 6393 </span><span class="decl"><span class="nottickedoff">translateCFGBodiesTerm some_cfgs =</span>
<span class="lineno"> 6394 </span><span class="spaces">  </span><span class="nottickedoff">lambdaCFGPermEnv some_cfgs (tupleOpenTerm &lt;$&gt;</span>
<span class="lineno"> 6395 </span><span class="spaces">                              </span><span class="nottickedoff">mapM translateSomeCFGBody some_cfgs)</span></span>
<span class="lineno"> 6396 </span>
<span class="lineno"> 6397 </span>-- | Build a @LetRecS@ term for the nth CFG in a list of CFGs that it is
<span class="lineno"> 6398 </span>-- potentially mutually recursive with those CFGs from a SAW core term of type
<span class="lineno"> 6399 </span>-- @MultiFixBodies@ that specifies how these corecursive functions are defined
<span class="lineno"> 6400 </span>-- in terms of themselves and each other
<span class="lineno"> 6401 </span>translateCFGFromBodies :: HasPtrWidth w =&gt; [SomeTypedCFG LLVM] -&gt; OpenTerm -&gt;
<span class="lineno"> 6402 </span>                          Int -&gt; TypeTransM RNil OpenTerm
<span class="lineno"> 6403 </span><span class="decl"><span class="nottickedoff">translateCFGFromBodies cfgs _ i</span>
<span class="lineno"> 6404 </span><span class="spaces">  </span><span class="nottickedoff">| i &gt;= length cfgs</span>
<span class="lineno"> 6405 </span><span class="spaces">  </span><span class="nottickedoff">= panic &quot;translateCFGFromBodies&quot; [&quot;Index out of bounds!&quot;]</span>
<span class="lineno"> 6406 </span><span class="spaces"></span><span class="nottickedoff">translateCFGFromBodies cfgs bodies i</span>
<span class="lineno"> 6407 </span><span class="spaces">  </span><span class="nottickedoff">| SomeTypedCFG _ _ cfg &lt;- cfgs!!i =</span>
<span class="lineno"> 6408 </span><span class="spaces">    </span><span class="nottickedoff">let fun_perm = tpcfgFunPerm cfg in</span>
<span class="lineno"> 6409 </span><span class="spaces">    </span><span class="nottickedoff">lambdaExprCtx (funPermTops fun_perm) $</span>
<span class="lineno"> 6410 </span><span class="spaces">    </span><span class="nottickedoff">lambdaPermCtx (funPermIns fun_perm) $ \pctx -&gt;</span>
<span class="lineno"> 6411 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- infoEvType &lt;$&gt; ask</span>
<span class="lineno"> 6412 </span><span class="spaces">       </span><span class="nottickedoff">ectx &lt;- infoCtx &lt;$&gt; ask</span>
<span class="lineno"> 6413 </span><span class="spaces">       </span><span class="nottickedoff">ds &lt;- mapM translateSomeCFGDesc cfgs</span>
<span class="lineno"> 6414 </span><span class="spaces">       </span><span class="nottickedoff">tps &lt;- mapM translateSomeCFGType cfgs</span>
<span class="lineno"> 6415 </span><span class="spaces">       </span><span class="nottickedoff">ret_tp &lt;- translateRetType (funPermRets fun_perm) (funPermOuts fun_perm)</span>
<span class="lineno"> 6416 </span><span class="spaces">       </span><span class="nottickedoff">specMTransM ret_tp $</span>
<span class="lineno"> 6417 </span><span class="spaces">         </span><span class="nottickedoff">do body &lt;-</span>
<span class="lineno"> 6418 </span><span class="spaces">              </span><span class="nottickedoff">lambdaTransM &quot;f&quot; (openTermsTypeTrans tps) $ \fs -&gt;</span>
<span class="lineno"> 6419 </span><span class="spaces">              </span><span class="nottickedoff">return $ applyOpenTermMulti (fs!!i) (transTerms ectx</span>
<span class="lineno"> 6420 </span><span class="spaces">                                                   </span><span class="nottickedoff">++ transTerms pctx)</span>
<span class="lineno"> 6421 </span><span class="spaces">            </span><span class="nottickedoff">return $ letRecSOpenTerm ev ds ret_tp bodies body</span></span>
<span class="lineno"> 6422 </span>
<span class="lineno"> 6423 </span>-- | Translate a list of CFGs for mutually recursive functions to: a list of
<span class="lineno"> 6424 </span>-- type descriptions for the CFGS; a SAW core term of type @MultiFixBodies@ that
<span class="lineno"> 6425 </span>-- defines these functions mutually in terms of themselves; and a function that
<span class="lineno"> 6426 </span>-- takes in such a @MultiFixBodies@ term and returns a list of SAW core types
<span class="lineno"> 6427 </span>-- and functions for these CFGs that are defined using the @MultiFixBodies@
<span class="lineno"> 6428 </span>-- term. This separation allows the caller to insert the @MultiFixBodies@ term
<span class="lineno"> 6429 </span>-- as a SAW core named definition and use the definition name in the
<span class="lineno"> 6430 </span>-- translations to functions.
<span class="lineno"> 6431 </span>translateCFGs :: HasPtrWidth w =&gt; PermEnv -&gt; ChecksFlag -&gt;
<span class="lineno"> 6432 </span>                 [SomeTypedCFG LLVM] -&gt;
<span class="lineno"> 6433 </span>                 ([OpenTerm], OpenTerm, OpenTerm -&gt; [(OpenTerm,OpenTerm)])
<span class="lineno"> 6434 </span><span class="decl"><span class="nottickedoff">translateCFGs env checks some_cfgs =</span>
<span class="lineno"> 6435 </span><span class="spaces">  </span><span class="nottickedoff">(runNilTypeTransM env checks (mapM translateSomeCFGDesc some_cfgs),</span>
<span class="lineno"> 6436 </span><span class="spaces">   </span><span class="nottickedoff">runNilTypeTransM env checks (translateCFGBodiesTerm some_cfgs),</span>
<span class="lineno"> 6437 </span><span class="spaces">   </span><span class="nottickedoff">\bodies -&gt;</span>
<span class="lineno"> 6438 </span><span class="spaces">   </span><span class="nottickedoff">runNilTypeTransM env checks</span>
<span class="lineno"> 6439 </span><span class="spaces">   </span><span class="nottickedoff">(zip &lt;$&gt; mapM translateSomeCFGType some_cfgs &lt;*&gt;</span>
<span class="lineno"> 6440 </span><span class="spaces">    </span><span class="nottickedoff">mapM (translateCFGFromBodies some_cfgs bodies) [0..(length some_cfgs-1)]))</span></span>
<span class="lineno"> 6441 </span>
<span class="lineno"> 6442 </span>
<span class="lineno"> 6443 </span>-- | An existentially quantified tuple of a 'CFG', its function permission, and
<span class="lineno"> 6444 </span>-- a 'String' name we want to translate it to
<span class="lineno"> 6445 </span>data SomeCFGAndPerm ext where
<span class="lineno"> 6446 </span>  SomeCFGAndPerm :: GlobalSymbol -&gt; String -&gt; CFG ext blocks inits ret -&gt;
<span class="lineno"> 6447 </span>                    FunPerm ghosts (CtxToRList inits) gouts ret -&gt;
<span class="lineno"> 6448 </span>                    SomeCFGAndPerm ext
<span class="lineno"> 6449 </span>
<span class="lineno"> 6450 </span>-- | Extract the 'GlobalSymbol' from a 'SomeCFGAndPerm'
<span class="lineno"> 6451 </span>someCFGAndPermSym :: SomeCFGAndPerm ext -&gt; GlobalSymbol
<span class="lineno"> 6452 </span><span class="decl"><span class="nottickedoff">someCFGAndPermSym (SomeCFGAndPerm sym _ _ _) = sym</span></span>
<span class="lineno"> 6453 </span>
<span class="lineno"> 6454 </span>-- | Extract the 'String' name from a 'SomeCFGAndPerm'
<span class="lineno"> 6455 </span>someCFGAndPermToName :: SomeCFGAndPerm ext -&gt; String
<span class="lineno"> 6456 </span><span class="decl"><span class="nottickedoff">someCFGAndPermToName (SomeCFGAndPerm _ nm _ _) = nm</span></span>
<span class="lineno"> 6457 </span>
<span class="lineno"> 6458 </span>-- | Map a 'SomeCFGAndPerm' to a 'PermEnvGlobalEntry' with no translation, i.e.,
<span class="lineno"> 6459 </span>-- with an 'error' term for the translation. This is used to type-check
<span class="lineno"> 6460 </span>-- functions that may call themselves before they have been translated.
<span class="lineno"> 6461 </span>someCFGAndPermGlobalEntry :: HasPtrWidth w =&gt; SomeCFGAndPerm ext -&gt;
<span class="lineno"> 6462 </span>                             PermEnvGlobalEntry
<span class="lineno"> 6463 </span><span class="decl"><span class="nottickedoff">someCFGAndPermGlobalEntry (SomeCFGAndPerm sym _ _ fun_perm) =</span>
<span class="lineno"> 6464 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 6465 </span><span class="spaces">  </span><span class="nottickedoff">PermEnvGlobalEntry sym (mkPtrFunPerm fun_perm) $</span>
<span class="lineno"> 6466 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;someCFGAndPermGlobalEntry&quot;</span>
<span class="lineno"> 6467 </span><span class="spaces">  </span><span class="nottickedoff">[&quot;Attempt to translate CFG during its own type-checking&quot;]</span></span>
<span class="lineno"> 6468 </span>
<span class="lineno"> 6469 </span>-- | Type-check a list of functions in the Heapster type system, translate each
<span class="lineno"> 6470 </span>-- to a spec definition bound to the SAW core 'String' name associated with it,
<span class="lineno"> 6471 </span>-- add these translations as function permissions in the current environment,
<span class="lineno"> 6472 </span>-- and return the list of type-checked CFGs
<span class="lineno"> 6473 </span>tcTranslateAddCFGs ::
<span class="lineno"> 6474 </span>  HasPtrWidth w =&gt; SharedContext -&gt; ModuleName -&gt; PermEnv -&gt; ChecksFlag -&gt;
<span class="lineno"> 6475 </span>  EndianForm -&gt; DebugLevel -&gt; [SomeCFGAndPerm LLVM] -&gt;
<span class="lineno"> 6476 </span>  IO (PermEnv, [SomeTypedCFG LLVM])
<span class="lineno"> 6477 </span>
<span class="lineno"> 6478 </span>-- NOTE: we add an explicit case for the empty list so we can take head of the
<span class="lineno"> 6479 </span>-- cfgs_and_perms list below and know it will succeeed
<span class="lineno"> 6480 </span><span class="decl"><span class="nottickedoff">tcTranslateAddCFGs _ _ env _ _ _ [] = return (env, [])</span>
<span class="lineno"> 6481 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6482 </span><span class="spaces"></span><span class="nottickedoff">tcTranslateAddCFGs sc mod_name env checks endianness dlevel cfgs_and_perms@(cfg_and_perm:_) =</span>
<span class="lineno"> 6483 </span><span class="spaces">  </span><span class="nottickedoff">do</span>
<span class="lineno"> 6484 </span><span class="spaces">    </span><span class="nottickedoff">-- First, we type-check all the CFGs, mapping them to SomeTypedCFGs; this</span>
<span class="lineno"> 6485 </span><span class="spaces">    </span><span class="nottickedoff">-- uses a temporary PermEnv where all the function symbols being</span>
<span class="lineno"> 6486 </span><span class="spaces">    </span><span class="nottickedoff">-- type-checked are assigned their permissions, but no translation yet</span>
<span class="lineno"> 6487 </span><span class="spaces">    </span><span class="nottickedoff">let tmp_env1 =</span>
<span class="lineno"> 6488 </span><span class="spaces">          </span><span class="nottickedoff">permEnvAddGlobalSyms env $</span>
<span class="lineno"> 6489 </span><span class="spaces">          </span><span class="nottickedoff">map someCFGAndPermGlobalEntry cfgs_and_perms</span>
<span class="lineno"> 6490 </span><span class="spaces">    </span><span class="nottickedoff">let tc_cfgs =</span>
<span class="lineno"> 6491 </span><span class="spaces">          </span><span class="nottickedoff">flip map cfgs_and_perms $ \(SomeCFGAndPerm gsym nm cfg fun_perm) -&gt;</span>
<span class="lineno"> 6492 </span><span class="spaces">          </span><span class="nottickedoff">SomeTypedCFG gsym nm $</span>
<span class="lineno"> 6493 </span><span class="spaces">          </span><span class="nottickedoff">debugTraceTraceLvl dlevel (&quot;Type-checking &quot; ++ show gsym) $</span>
<span class="lineno"> 6494 </span><span class="spaces">          </span><span class="nottickedoff">debugTrace verboseDebugLevel dlevel</span>
<span class="lineno"> 6495 </span><span class="spaces">          </span><span class="nottickedoff">(&quot;With type:\n&quot; ++ permPrettyString emptyPPInfo fun_perm) $</span>
<span class="lineno"> 6496 </span><span class="spaces">          </span><span class="nottickedoff">tcCFG ?ptrWidth tmp_env1 endianness dlevel fun_perm cfg</span>
<span class="lineno"> 6497 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6498 </span><span class="spaces">    </span><span class="nottickedoff">-- Next, translate those CFGs to a @MultiFixBodies@ term and a function from</span>
<span class="lineno"> 6499 </span><span class="spaces">    </span><span class="nottickedoff">-- that term to all the types and definitions for those CFGs</span>
<span class="lineno"> 6500 </span><span class="spaces">    </span><span class="nottickedoff">let (ds, bodies, trans_f) = translateCFGs env checks tc_cfgs</span>
<span class="lineno"> 6501 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6502 </span><span class="spaces">    </span><span class="nottickedoff">-- Insert a SAW core definition in the current SAW module for bodies</span>
<span class="lineno"> 6503 </span><span class="spaces">    </span><span class="nottickedoff">let ev = permEnvEventType env</span>
<span class="lineno"> 6504 </span><span class="spaces">    </span><span class="nottickedoff">let bodies_id =</span>
<span class="lineno"> 6505 </span><span class="spaces">          </span><span class="nottickedoff">mkSafeIdent mod_name (someCFGAndPermToName cfg_and_perm</span>
<span class="lineno"> 6506 </span><span class="spaces">                                </span><span class="nottickedoff">++ &quot;__bodies&quot;)</span>
<span class="lineno"> 6507 </span><span class="spaces">    </span><span class="nottickedoff">bodies_tp &lt;- completeOpenTerm sc $ multiFixBodiesOpenTerm ev ds</span>
<span class="lineno"> 6508 </span><span class="spaces">    </span><span class="nottickedoff">bodies_tm &lt;- completeOpenTerm sc bodies</span>
<span class="lineno"> 6509 </span><span class="spaces">    </span><span class="nottickedoff">scInsertDef sc mod_name bodies_id bodies_tp bodies_tm</span>
<span class="lineno"> 6510 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6511 </span><span class="spaces">    </span><span class="nottickedoff">-- Now insert SAW core definitions for the translations of all the CFGs,</span>
<span class="lineno"> 6512 </span><span class="spaces">    </span><span class="nottickedoff">-- putting them all into new entries for the permissions environment</span>
<span class="lineno"> 6513 </span><span class="spaces">    </span><span class="nottickedoff">new_entries &lt;-</span>
<span class="lineno"> 6514 </span><span class="spaces">      </span><span class="nottickedoff">zipWithM</span>
<span class="lineno"> 6515 </span><span class="spaces">      </span><span class="nottickedoff">(\(SomeTypedCFG sym nm cfg) (tp, f) -&gt;</span>
<span class="lineno"> 6516 </span><span class="spaces">        </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 6517 </span><span class="spaces">        </span><span class="nottickedoff">do tp_trm &lt;- completeOpenTerm sc tp</span>
<span class="lineno"> 6518 </span><span class="spaces">           </span><span class="nottickedoff">f_trm &lt;- completeOpenTerm sc f</span>
<span class="lineno"> 6519 </span><span class="spaces">           </span><span class="nottickedoff">let ident = mkSafeIdent mod_name nm</span>
<span class="lineno"> 6520 </span><span class="spaces">           </span><span class="nottickedoff">scInsertDef sc mod_name ident tp_trm f_trm</span>
<span class="lineno"> 6521 </span><span class="spaces">           </span><span class="nottickedoff">let perm = mkPtrFunPerm $ tpcfgFunPerm cfg</span>
<span class="lineno"> 6522 </span><span class="spaces">           </span><span class="nottickedoff">return $ PermEnvGlobalEntry sym perm (GlobalTrans</span>
<span class="lineno"> 6523 </span><span class="spaces">                                                 </span><span class="nottickedoff">[globalOpenTerm ident]))</span>
<span class="lineno"> 6524 </span><span class="spaces">      </span><span class="nottickedoff">tc_cfgs (trans_f $ globalOpenTerm bodies_id)</span>
<span class="lineno"> 6525 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6526 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, add the new entries to the environment and return the new</span>
<span class="lineno"> 6527 </span><span class="spaces">    </span><span class="nottickedoff">-- environment and the type-checked CFGs</span>
<span class="lineno"> 6528 </span><span class="spaces">    </span><span class="nottickedoff">return (permEnvAddGlobalSyms env new_entries, tc_cfgs)</span></span>
<span class="lineno"> 6529 </span>
<span class="lineno"> 6530 </span>
<span class="lineno"> 6531 </span>----------------------------------------------------------------------
<span class="lineno"> 6532 </span>-- * Top-level Entrypoints for Translating Other Things
<span class="lineno"> 6533 </span>----------------------------------------------------------------------
<span class="lineno"> 6534 </span>
<span class="lineno"> 6535 </span>-- | Translate a function permission to the type of the translation of a
<span class="lineno"> 6536 </span>-- function with that function permission
<span class="lineno"> 6537 </span>translateCompleteFunPerm :: SharedContext -&gt; PermEnv -&gt;
<span class="lineno"> 6538 </span>                            FunPerm ghosts args gouts ret -&gt; IO Term
<span class="lineno"> 6539 </span><span class="decl"><span class="nottickedoff">translateCompleteFunPerm sc env fun_perm =</span>
<span class="lineno"> 6540 </span><span class="spaces">  </span><span class="nottickedoff">completeNormOpenTerm sc $</span>
<span class="lineno"> 6541 </span><span class="spaces">  </span><span class="nottickedoff">runNilTypeTransM env noChecks (translateClosed fun_perm)</span></span>
<span class="lineno"> 6542 </span>
<span class="lineno"> 6543 </span>-- | Translate a 'TypeRepr' to the SAW core type it represents, raising an error
<span class="lineno"> 6544 </span>-- if it translates to more than one type
<span class="lineno"> 6545 </span>translateCompleteType :: SharedContext -&gt; PermEnv -&gt; TypeRepr tp -&gt; IO Term
<span class="lineno"> 6546 </span><span class="decl"><span class="nottickedoff">translateCompleteType sc env tp =</span>
<span class="lineno"> 6547 </span><span class="spaces">  </span><span class="nottickedoff">let ?ev = permEnvEventType env in</span>
<span class="lineno"> 6548 </span><span class="spaces">  </span><span class="nottickedoff">completeNormOpenTerm sc $ typeTransType1 $ fst $ translateType tp</span></span>
<span class="lineno"> 6549 </span>
<span class="lineno"> 6550 </span>-- | Translate a 'TypeRepr' within the given context of type arguments to the
<span class="lineno"> 6551 </span>-- SAW core type it represents
<span class="lineno"> 6552 </span>translateCompleteTypeInCtx :: SharedContext -&gt; PermEnv -&gt;
<span class="lineno"> 6553 </span>                              CruCtx args -&gt; Mb args (TypeRepr a) -&gt; IO Term
<span class="lineno"> 6554 </span><span class="decl"><span class="nottickedoff">translateCompleteTypeInCtx sc env args ret =</span>
<span class="lineno"> 6555 </span><span class="spaces">  </span><span class="nottickedoff">let ?ev = permEnvEventType env in</span>
<span class="lineno"> 6556 </span><span class="spaces">  </span><span class="nottickedoff">completeNormOpenTerm sc $ runNilTypeTransM env noChecks $</span>
<span class="lineno"> 6557 </span><span class="spaces">  </span><span class="nottickedoff">piExprCtx args (return $ typeTransType1 $ fst $ translateType $ mbLift ret)</span></span>
<span class="lineno"> 6558 </span>
<span class="lineno"> 6559 </span>-- | Translate a type-like construct to a type description of the type it
<span class="lineno"> 6560 </span>-- represents in a context of free deBruijn indices
<span class="lineno"> 6561 </span>translateCompleteDescInCtx :: TranslateDescs a =&gt; SharedContext -&gt; PermEnv -&gt;
<span class="lineno"> 6562 </span>                              CruCtx args -&gt; Mb args a -&gt; IO Term
<span class="lineno"> 6563 </span><span class="decl"><span class="nottickedoff">translateCompleteDescInCtx sc env args mb_a =</span>
<span class="lineno"> 6564 </span><span class="spaces">  </span><span class="nottickedoff">completeOpenTerm sc $ runNilTypeTransM env noChecks $ descTransM $</span>
<span class="lineno"> 6565 </span><span class="spaces">  </span><span class="nottickedoff">inCtxDescTransM args $ const $ translateDesc mb_a</span></span>
<span class="lineno"> 6566 </span>
<span class="lineno"> 6567 </span>-- | Translate an input list of 'ValuePerms' and an output 'ValuePerm' to a pure
<span class="lineno"> 6568 </span>-- SAW core function type, not in the @SpecM@ monad
<span class="lineno"> 6569 </span>translateCompletePureFunType :: SharedContext -&gt; PermEnv
<span class="lineno"> 6570 </span>                             -&gt; CruCtx ctx -- ^ Type arguments
<span class="lineno"> 6571 </span>                             -&gt; Mb ctx (ValuePerms args) -- ^ Input perms
<span class="lineno"> 6572 </span>                             -&gt; Mb ctx (ValuePerm ret) -- ^ Return type perm
<span class="lineno"> 6573 </span>                             -&gt; IO Term
<span class="lineno"> 6574 </span><span class="decl"><span class="nottickedoff">translateCompletePureFunType sc env ctx ps_in p_out =</span>
<span class="lineno"> 6575 </span><span class="spaces">  </span><span class="nottickedoff">completeNormOpenTerm sc $ runNilTypeTransM env noChecks $ piExprCtx ctx $</span>
<span class="lineno"> 6576 </span><span class="spaces">  </span><span class="nottickedoff">do tps_in &lt;- typeTransTypes &lt;$&gt; translate ps_in</span>
<span class="lineno"> 6577 </span><span class="spaces">     </span><span class="nottickedoff">tp_out &lt;- typeTransTupleType &lt;$&gt; translate p_out</span>
<span class="lineno"> 6578 </span><span class="spaces">     </span><span class="nottickedoff">return $ piOpenTermMulti (map (&quot;_&quot;,) tps_in) (const tp_out)</span></span>
<span class="lineno"> 6579 </span>
<span class="lineno"> 6580 </span>-- | Translate a context of arguments to the type
<span class="lineno"> 6581 </span>-- &gt; (arg1:tp1) -&gt; ... (argn:tpn) -&gt; sort 0
<span class="lineno"> 6582 </span>-- of a type-level function over those arguments
<span class="lineno"> 6583 </span>translateExprTypeFunType :: SharedContext -&gt; PermEnv -&gt; CruCtx ctx -&gt; IO Term
<span class="lineno"> 6584 </span><span class="decl"><span class="nottickedoff">translateExprTypeFunType sc env ctx =</span>
<span class="lineno"> 6585 </span><span class="spaces">  </span><span class="nottickedoff">completeOpenTerm sc $ runNilTypeTransM env noChecks $</span>
<span class="lineno"> 6586 </span><span class="spaces">  </span><span class="nottickedoff">piExprCtx ctx $ return $ sortOpenTerm $ mkSort 0</span></span>
<span class="lineno"> 6587 </span>
<span class="lineno"> 6588 </span>-- | Translate a context of Crucible types @(tp1,...,tpn)@ that translates to a
<span class="lineno"> 6589 </span>-- sequence @(k1,...,km)@ of kind descriptions plus a type description @d@ with
<span class="lineno"> 6590 </span>-- those arguments free (as type description @Tp_Var@ deBruijn variables, not as
<span class="lineno"> 6591 </span>-- SAW core free variables) into the type function that @d@ describes, which is:
<span class="lineno"> 6592 </span>--
<span class="lineno"> 6593 </span>-- &gt; \ (x1:kindElem k1) ... (xn:kindElem k2) -&gt; tpElemEnv ev [x1,...,xn] d
<span class="lineno"> 6594 </span>--
<span class="lineno"> 6595 </span>-- This is computed by the @pureTpElemTypeFun@ combinator in the @SpecM@ SAW
<span class="lineno"> 6596 </span>-- core module, so we just build this term by applying that combinator.
<span class="lineno"> 6597 </span>translateDescTypeFun :: SharedContext -&gt; PermEnv -&gt; CruCtx ctx -&gt;
<span class="lineno"> 6598 </span>                        OpenTerm -&gt; IO Term
<span class="lineno"> 6599 </span><span class="decl"><span class="nottickedoff">translateDescTypeFun sc env ctx d =</span>
<span class="lineno"> 6600 </span><span class="spaces">  </span><span class="nottickedoff">let ?ev = permEnvEventType env in</span>
<span class="lineno"> 6601 </span><span class="spaces">  </span><span class="nottickedoff">let klist = listOpenTerm (dataTypeOpenTerm</span>
<span class="lineno"> 6602 </span><span class="spaces">                            </span><span class="nottickedoff">&quot;SpecM.KindDesc&quot; []) (snd $ translateCruCtx ctx) in</span>
<span class="lineno"> 6603 </span><span class="spaces">  </span><span class="nottickedoff">completeNormOpenTerm sc $</span>
<span class="lineno"> 6604 </span><span class="spaces">  </span><span class="nottickedoff">applyGlobalOpenTerm &quot;SpecM.pureTpElemTypeFun&quot; [evTypeTerm ?ev, klist, d]</span></span>
<span class="lineno"> 6605 </span>
<span class="lineno"> 6606 </span>-- | Translate a context of arguments plus a type description @T@ that describes
<span class="lineno"> 6607 </span>-- the body of an inductive type over those arguments -- meaning that it uses
<span class="lineno"> 6608 </span>-- deBruijn index 0 for recursive occurrences of itself and the remaining
<span class="lineno"> 6609 </span>-- deBruijn indices for the arguments -- to the type-level function
<span class="lineno"> 6610 </span>--
<span class="lineno"> 6611 </span>-- &gt; \ arg1 -&gt; ... \argn -&gt; tpElemEnv (arg1, ..., argn) (Tp_Ind T)
<span class="lineno"> 6612 </span>--
<span class="lineno"> 6613 </span>-- that takes in the arguments and builds the inductive type
<span class="lineno"> 6614 </span>translateIndTypeFun :: SharedContext -&gt; PermEnv -&gt; CruCtx ctx -&gt; OpenTerm -&gt;
<span class="lineno"> 6615 </span>                       IO Term
<span class="lineno"> 6616 </span><span class="decl"><span class="nottickedoff">translateIndTypeFun sc env ctx d =</span>
<span class="lineno"> 6617 </span><span class="spaces">  </span><span class="nottickedoff">let ?ev = permEnvEventType env in</span>
<span class="lineno"> 6618 </span><span class="spaces">  </span><span class="nottickedoff">completeOpenTerm sc $ runNilTypeTransM env noChecks $</span>
<span class="lineno"> 6619 </span><span class="spaces">  </span><span class="nottickedoff">lambdaExprCtx ctx $</span>
<span class="lineno"> 6620 </span><span class="spaces">  </span><span class="nottickedoff">do args_tms &lt;- transTerms &lt;$&gt; infoCtx &lt;$&gt; ask</span>
<span class="lineno"> 6621 </span><span class="spaces">     </span><span class="nottickedoff">let ks = snd $ translateCruCtx ctx</span>
<span class="lineno"> 6622 </span><span class="spaces">     </span><span class="nottickedoff">return $ applyGlobalOpenTerm &quot;SpecM.tpElemEnv&quot;</span>
<span class="lineno"> 6623 </span><span class="spaces">       </span><span class="nottickedoff">[evTypeTerm (permEnvEventType env), tpEnvOpenTerm (zip ks args_tms),</span>
<span class="lineno"> 6624 </span><span class="spaces">        </span><span class="nottickedoff">ctorOpenTerm &quot;SpecM.IsData&quot; [], indTpDesc d]</span></span>

</pre>
</body>
</html>
