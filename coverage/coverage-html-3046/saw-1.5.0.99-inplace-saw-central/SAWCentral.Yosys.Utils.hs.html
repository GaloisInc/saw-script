<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Yosys.Utils
<span class="lineno">    3 </span>Description : Miscellaneous utilities used when working with HDL
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : sbreese
<span class="lineno">    6 </span>Stability   : experimental
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# Language CPP #-}
<span class="lineno">   10 </span>{-# Language TemplateHaskell #-}
<span class="lineno">   11 </span>{-# Language OverloadedStrings #-}
<span class="lineno">   12 </span>{-# Language LambdaCase #-}
<span class="lineno">   13 </span>{-# Language ViewPatterns #-}
<span class="lineno">   14 </span>{-# Language ScopedTypeVariables #-}
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>module SAWCentral.Yosys.Utils where
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>import Control.Monad (forM, foldM)
<span class="lineno">   19 </span>import Control.Exception (Exception, throwIO)
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>import Data.Bifunctor (bimap)
<span class="lineno">   22 </span>import Data.Char (digitToInt)
<span class="lineno">   23 </span>import qualified Data.List as List
<span class="lineno">   24 </span>import Data.Text (Text)
<span class="lineno">   25 </span>import qualified Data.Text as Text
<span class="lineno">   26 </span>import Data.Map (Map)
<span class="lineno">   27 </span>import qualified Data.Map as Map
<span class="lineno">   28 </span>import qualified Data.Graph as Graph
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>import Numeric.Natural (Natural)
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>import Text.Encoding.Z (zEncodeString)
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>import qualified SAWCore.SharedTerm as SC
<span class="lineno">   35 </span>import qualified CryptolSAWCore.TypedTerm as SC
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>import qualified Cryptol.TypeCheck.Type as C
<span class="lineno">   38 </span>import qualified Cryptol.Utils.Ident as C
<span class="lineno">   39 </span>import qualified Cryptol.Utils.RecordMap as C
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>reportBugText :: Text
<span class="lineno">   42 </span><span class="decl"><span class="nottickedoff">reportBugText = &quot;You should report this issue at: https://github.com/GaloisInc/saw-script/issues&quot;</span></span>
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>consultYosysManual :: Text
<span class="lineno">   45 </span><span class="decl"><span class="nottickedoff">consultYosysManual = &quot;More information is available in the Yosys manual, at: https://yosyshq.net/yosys/documentation.html&quot;</span></span>
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>-- | The name of a user-defined cell type.
<span class="lineno">   48 </span>type CellTypeName = Text
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>-- | The name of a cell instance.
<span class="lineno">   51 </span>type CellInstName = Text
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>-- | The name of an input or output port.
<span class="lineno">   54 </span>type PortName = Text
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>data YosysBitvecConsumer
<span class="lineno">   57 </span>  = YosysBitvecConsumerOutputPort PortName
<span class="lineno">   58 </span>  | YosysBitvecConsumerCell CellInstName PortName
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>data YosysError
<span class="lineno">   61 </span>  = YosysError Text
<span class="lineno">   62 </span>  | YosysErrorTypeError Text Text
<span class="lineno">   63 </span>  | YosysErrorNoSuchOutputBitvec Text YosysBitvecConsumer
<span class="lineno">   64 </span>  | YosysErrorNoSuchSubmodule CellTypeName CellInstName
<span class="lineno">   65 </span>  | YosysErrorUnsupportedFF Text
<span class="lineno">   66 </span>  | YosysErrorInvalidOverrideTarget
<span class="lineno">   67 </span>  | YosysErrorOverrideNameNotFound Text
<span class="lineno">   68 </span>  | YosysErrorInvalidStateFieldWidth Text
<span class="lineno">   69 </span>  | YosysErrorTransitionSystemMissingField Text
<span class="lineno">   70 </span>  | YosysErrorTransitionSystemBadType
<span class="lineno">   71 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Exception YosysError</span></span></span></span></span></span>
<span class="lineno">   72 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show YosysError</span></span></span></span> where
<span class="lineno">   73 </span>  <span class="decl"><span class="nottickedoff">show (YosysError msg) = Text.unpack $ &quot;Error: &quot; &lt;&gt; msg &lt;&gt; &quot;\n&quot; &lt;&gt; reportBugText</span>
<span class="lineno">   74 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorTypeError msg err) = Text.unpack $ mconcat</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: An internal term failed to type-check.\n&quot;</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This occured while &quot;, msg, &quot;.\n&quot;</span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;The type error was:\n&quot;, err</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">   81 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorNoSuchOutputBitvec bvec (YosysBitvecConsumerOutputPort onm)) = Text.unpack $ mconcat</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: Could not find the output bitvector &quot;, bvec</span>
<span class="lineno">   83 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;, which is connected to a module output port \&quot;&quot;, onm</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;\&quot;.\n&quot;</span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">   88 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorNoSuchOutputBitvec bvec (YosysBitvecConsumerCell cnm inm)) = Text.unpack $ mconcat</span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: Could not find the output bitvector &quot;, bvec</span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;, which is connected to the input \&quot;&quot;, inm</span>
<span class="lineno">   91 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;\&quot; of the cell with name \&quot;&quot;, cnm</span>
<span class="lineno">   92 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;\&quot;.\n&quot;</span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;It is possible that this represents an undetected cycle in the netgraph.\n&quot;</span>
<span class="lineno">   94 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">   95 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">   96 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorNoSuchSubmodule submoduleName cellName) =</span>
<span class="lineno">   97 </span><span class="spaces">    </span><span class="nottickedoff">Text.unpack $ mconcat</span>
<span class="lineno">   98 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;Error: Encountered a cell \&quot;&quot;</span>
<span class="lineno">   99 </span><span class="spaces">      </span><span class="nottickedoff">, cellName</span>
<span class="lineno">  100 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\&quot; with type \&quot;&quot;</span>
<span class="lineno">  101 </span><span class="spaces">      </span><span class="nottickedoff">, submoduleName</span>
<span class="lineno">  102 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\&quot;, but could not find a submodule named \&quot;&quot;</span>
<span class="lineno">  103 </span><span class="spaces">      </span><span class="nottickedoff">, submoduleName</span>
<span class="lineno">  104 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\&quot;.&quot;</span>
<span class="lineno">  105 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno">  106 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorUnsupportedFF mnm) = Text.unpack $ mconcat</span>
<span class="lineno">  107 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The circuit contains cells with type \&quot;&quot;, mnm, &quot;\&quot;.\n&quot;</span>
<span class="lineno">  108 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;These cells are not currently supported by SAW.\n&quot;</span>
<span class="lineno">  109 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;It may be helpful to replace certain stateful cells using the \&quot;memory\&quot;, \&quot;dffunmap\&quot;, and \&quot;async2sync\&quot; tactics within Yosys.\n&quot;</span>
<span class="lineno">  110 </span><span class="spaces">    </span><span class="nottickedoff">, consultYosysManual</span>
<span class="lineno">  111 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  112 </span><span class="spaces">  </span><span class="nottickedoff">show YosysErrorInvalidOverrideTarget = Text.unpack $ mconcat</span>
<span class="lineno">  113 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The first argument to \&quot;yosys_verify\&quot; could not be identified as a Yosys module.\n&quot;</span>
<span class="lineno">  114 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This argument should typically take the form {{ m.module_name }}, where \&quot;m\&quot; is a record term returned by \&quot;yosys_import\&quot;&quot;</span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  116 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorOverrideNameNotFound nm) = Text.unpack $ mconcat</span>
<span class="lineno">  117 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The name \&quot;&quot;, nm, &quot;\&quot; could not be found while applying overrides.\n&quot;</span>
<span class="lineno">  118 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  119 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  120 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  121 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorInvalidStateFieldWidth nm) = Text.unpack $ mconcat</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The state field \&quot;&quot;, nm, &quot;\&quot; has an invalid width.\n&quot;</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  124 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  125 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorTransitionSystemMissingField nm) = Text.unpack $ mconcat</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: While translating a sequential circuit to a Sally transition system, could not find the field \&quot;&quot;, nm, &quot;\&quot;.\n&quot;</span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  129 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  130 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="nottickedoff">show YosysErrorTransitionSystemBadType = Text.unpack $ mconcat</span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: While translating a sequential circuit to a Sally transition system, an intermediate What4 predicate was not a boolean.\n&quot;</span>
<span class="lineno">  133 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  134 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  135 </span><span class="spaces">    </span><span class="nottickedoff">]</span></span>
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>yosysError :: YosysError -&gt; IO a
<span class="lineno">  138 </span><span class="decl"><span class="nottickedoff">yosysError = throwIO</span></span>
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>mapForWithKeyM :: Monad m =&gt; Map k a -&gt; (k -&gt; a -&gt; m b) -&gt; m (Map k b)
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">mapForWithKeyM m f = sequence $ Map.mapWithKey f m</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>reverseTopSort :: Graph.Graph -&gt; [Graph.Vertex]
<span class="lineno">  144 </span><span class="decl"><span class="istickedoff">reverseTopSort =</span>
<span class="lineno">  145 </span><span class="spaces"></span><span class="istickedoff">#if MIN_VERSION_containers(6,4,1)</span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="istickedoff">Graph.reverseTopSort</span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="istickedoff">#else</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="istickedoff">reverse . Graph.topSort</span></span>
<span class="lineno">  149 </span>#endif
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- | Produce a SAWCore record type corresponding to a Cryptol record type with the given fields.
<span class="lineno">  152 </span>cryptolRecordType ::
<span class="lineno">  153 </span>  SC.SharedContext -&gt;
<span class="lineno">  154 </span>  Map Text SC.Term -&gt;
<span class="lineno">  155 </span>  IO SC.Term
<span class="lineno">  156 </span><span class="decl"><span class="istickedoff">cryptolRecordType sc fields =</span>
<span class="lineno">  157 </span><span class="spaces">  </span><span class="istickedoff">SC.scRecordType sc (C.canonicalFields $ C.recordFromFields $ Map.assocs fields)</span></span>
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>-- | Produce a SAWCore record corresponding to a Cryptol record with the given fields.
<span class="lineno">  160 </span>cryptolRecord ::
<span class="lineno">  161 </span>  SC.SharedContext -&gt;
<span class="lineno">  162 </span>  Map Text SC.Term -&gt;
<span class="lineno">  163 </span>  IO SC.Term
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">cryptolRecord sc fields =</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">SC.scRecordValue sc (C.canonicalFields $ C.recordFromFields $ Map.assocs fields)</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>-- | Produce a SAWCore record projection corresponding to a lookup in
<span class="lineno">  168 </span>-- a Cryptol record with the given fields.
<span class="lineno">  169 </span>cryptolRecordSelect ::
<span class="lineno">  170 </span>  SC.SharedContext -&gt;
<span class="lineno">  171 </span>  Map Text a -&gt;
<span class="lineno">  172 </span>  SC.Term -&gt;
<span class="lineno">  173 </span>  Text -&gt;
<span class="lineno">  174 </span>  IO SC.Term
<span class="lineno">  175 </span><span class="decl"><span class="istickedoff">cryptolRecordSelect sc _fields r nm =</span>
<span class="lineno">  176 </span><span class="spaces">  </span><span class="istickedoff">SC.scRecordSelect sc r nm</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- | Produce a SAWCore record projection corresponding to a lookup in a
<span class="lineno">  179 </span>-- Cryptol record. The record fields are inferred from the Cryptol
<span class="lineno">  180 </span>-- type attached to the `TypedTerm`.
<span class="lineno">  181 </span>cryptolRecordSelectTyped ::
<span class="lineno">  182 </span>  SC.SharedContext -&gt;
<span class="lineno">  183 </span>  SC.TypedTerm -&gt;
<span class="lineno">  184 </span>  Text -&gt;
<span class="lineno">  185 </span>  IO SC.TypedTerm
<span class="lineno">  186 </span><span class="decl"><span class="nottickedoff">cryptolRecordSelectTyped sc r nm =</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="nottickedoff">do fields &lt;-</span>
<span class="lineno">  188 </span><span class="spaces">       </span><span class="nottickedoff">Map.mapKeys C.identText . Map.fromList . C.canonicalFields &lt;$&gt;</span>
<span class="lineno">  189 </span><span class="spaces">       </span><span class="nottickedoff">case SC.ttType r of</span>
<span class="lineno">  190 </span><span class="spaces">         </span><span class="nottickedoff">SC.TypedTermSchema (C.Forall [] [] (C.TRec fs)) -&gt; pure fs</span>
<span class="lineno">  191 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; throwIO $ YosysError $ mconcat</span>
<span class="lineno">  192 </span><span class="spaces">           </span><span class="nottickedoff">[ &quot;Type\n&quot;</span>
<span class="lineno">  193 </span><span class="spaces">           </span><span class="nottickedoff">, Text.pack . show $ SC.ttType r</span>
<span class="lineno">  194 </span><span class="spaces">           </span><span class="nottickedoff">, &quot;\nis not a record type&quot;</span>
<span class="lineno">  195 </span><span class="spaces">           </span><span class="nottickedoff">]</span>
<span class="lineno">  196 </span><span class="spaces">     </span><span class="nottickedoff">cty &lt;-</span>
<span class="lineno">  197 </span><span class="spaces">       </span><span class="nottickedoff">case Map.lookup nm fields of</span>
<span class="lineno">  198 </span><span class="spaces">         </span><span class="nottickedoff">Just cty -&gt; pure cty</span>
<span class="lineno">  199 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; throwIO $ YosysError $ mconcat</span>
<span class="lineno">  200 </span><span class="spaces">           </span><span class="nottickedoff">[ &quot;Record type\n&quot;</span>
<span class="lineno">  201 </span><span class="spaces">           </span><span class="nottickedoff">, Text.pack . show $ SC.ttType r</span>
<span class="lineno">  202 </span><span class="spaces">           </span><span class="nottickedoff">, &quot;\ndoes not have field &quot;</span>
<span class="lineno">  203 </span><span class="spaces">           </span><span class="nottickedoff">, nm</span>
<span class="lineno">  204 </span><span class="spaces">           </span><span class="nottickedoff">]</span>
<span class="lineno">  205 </span><span class="spaces">     </span><span class="nottickedoff">t &lt;- cryptolRecordSelect sc fields (SC.ttTerm r) nm</span>
<span class="lineno">  206 </span><span class="spaces">     </span><span class="nottickedoff">pure $ SC.TypedTerm (SC.TypedTermSchema $ C.tMono cty) t</span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | Construct a SAWCore expression asserting equality between each
<span class="lineno">  209 </span>-- field of two records. Both records should be records corresponding
<span class="lineno">  210 </span>-- to the specified Cryptol record type.
<span class="lineno">  211 </span>eqBvRecords ::
<span class="lineno">  212 </span>  SC.SharedContext -&gt;
<span class="lineno">  213 </span>  C.Type -&gt;
<span class="lineno">  214 </span>  SC.Term -&gt;
<span class="lineno">  215 </span>  SC.Term -&gt;
<span class="lineno">  216 </span>  IO SC.Term
<span class="lineno">  217 </span><span class="decl"><span class="istickedoff">eqBvRecords sc cty a b =</span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">do fields &lt;-</span>
<span class="lineno">  219 </span><span class="spaces">       </span><span class="istickedoff">Map.mapKeys C.identText . Map.fromList . C.canonicalFields &lt;$&gt;</span>
<span class="lineno">  220 </span><span class="spaces">       </span><span class="istickedoff">case cty of</span>
<span class="lineno">  221 </span><span class="spaces">         </span><span class="istickedoff">C.TRec fs -&gt; pure fs</span>
<span class="lineno">  222 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwIO $ YosysError $ mconcat</span></span>
<span class="lineno">  223 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type\n&quot;</span></span>
<span class="lineno">  224 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ show cty</span></span>
<span class="lineno">  225 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nis not a record type&quot;</span></span>
<span class="lineno">  226 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  227 </span><span class="spaces">     </span><span class="istickedoff">eqs &lt;-</span>
<span class="lineno">  228 </span><span class="spaces">       </span><span class="istickedoff">forM (Map.assocs fields) $ \(nm, fcty) -&gt;</span>
<span class="lineno">  229 </span><span class="spaces">       </span><span class="istickedoff">do w &lt;-</span>
<span class="lineno">  230 </span><span class="spaces">            </span><span class="istickedoff">case fcty of</span>
<span class="lineno">  231 </span><span class="spaces">              </span><span class="istickedoff">C.TCon (C.TC C.TCSeq) [C.TCon (C.TC (C.TCNum wint)) [], C.TCon (C.TC C.TCBit) []] -&gt;</span>
<span class="lineno">  232 </span><span class="spaces">                </span><span class="istickedoff">SC.scNat sc $ fromIntegral wint</span>
<span class="lineno">  233 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwIO $  YosysError $ mconcat</span></span>
<span class="lineno">  234 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type\n&quot;</span></span>
<span class="lineno">  235 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ show fcty</span></span>
<span class="lineno">  236 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nis not a bitvector type&quot;</span></span>
<span class="lineno">  237 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  238 </span><span class="spaces">          </span><span class="istickedoff">fa &lt;- cryptolRecordSelect sc <span class="nottickedoff">fields</span> a nm</span>
<span class="lineno">  239 </span><span class="spaces">          </span><span class="istickedoff">fb &lt;- cryptolRecordSelect sc <span class="nottickedoff">fields</span> b nm</span>
<span class="lineno">  240 </span><span class="spaces">          </span><span class="istickedoff">SC.scBvEq sc w fa fb</span>
<span class="lineno">  241 </span><span class="spaces">     </span><span class="istickedoff">case eqs of</span>
<span class="lineno">  242 </span><span class="spaces">       </span><span class="istickedoff">[] -&gt;</span>
<span class="lineno">  243 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">throwIO $ YosysError $ mconcat</span></span>
<span class="lineno">  244 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record type\n&quot;</span></span>
<span class="lineno">  245 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ show cty</span></span>
<span class="lineno">  246 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nhas no fields&quot;</span></span>
<span class="lineno">  247 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  248 </span><span class="spaces">       </span><span class="istickedoff">(e:es) -&gt; foldM (\x y -&gt; SC.scAnd sc x y) e es</span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>-- | Encode the given string such that is a valid Cryptol identifier.
<span class="lineno">  251 </span>-- Since Yosys cell names often look like &quot;\42&quot;, this makes it much
<span class="lineno">  252 </span>-- easier to manipulate state records, which are keyed by cell name.
<span class="lineno">  253 </span>cellIdentifier :: CellInstName -&gt; Text
<span class="lineno">  254 </span><span class="decl"><span class="nottickedoff">cellIdentifier = Text.pack . zEncodeString . Text.unpack</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>textBinNat :: Text -&gt; Natural
<span class="lineno">  257 </span><span class="decl"><span class="istickedoff">textBinNat = fromIntegral . Text.foldl' (\a x -&gt; digitToInt x + a * 2) 0</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>-- | Build a SAWCore type corresponding to the Cryptol record type
<span class="lineno">  260 </span>-- with the given field types.
<span class="lineno">  261 </span>fieldsToType ::
<span class="lineno">  262 </span>  SC.SharedContext -&gt;
<span class="lineno">  263 </span>  Map Text (SC.Term, C.Type) -&gt;
<span class="lineno">  264 </span>  IO SC.Term
<span class="lineno">  265 </span><span class="decl"><span class="istickedoff">fieldsToType sc = cryptolRecordType sc . fmap fst</span></span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>-- | Build a Cryptol record type with the given field types
<span class="lineno">  268 </span>fieldsToCryptolType ::
<span class="lineno">  269 </span>  Map Text (SC.Term, C.Type) -&gt; IO C.Type
<span class="lineno">  270 </span><span class="decl"><span class="istickedoff">fieldsToCryptolType fields = pure . C.tRec . C.recordFromFields $ bimap C.mkIdent snd &lt;$&gt; Map.assocs fields</span></span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>-- | Given a bit pattern ([b]) and a term, construct a map associating
<span class="lineno">  273 </span>-- that output pattern with the term, and each bit of that pattern
<span class="lineno">  274 </span>-- with the corresponding bit of the term.
<span class="lineno">  275 </span>deriveTermsByIndices :: (Ord b) =&gt; SC.SharedContext -&gt; [b] -&gt; SC.Term -&gt; IO (Map [b] Preterm)
<span class="lineno">  276 </span><span class="decl"><span class="istickedoff">deriveTermsByIndices _sc rep t =</span>
<span class="lineno">  277 </span><span class="spaces">  </span><span class="istickedoff">do let len = length rep</span>
<span class="lineno">  278 </span><span class="spaces">     </span><span class="istickedoff">let bit i = PretermSlice (fromIntegral (len - 1 - i)) 1 (fromIntegral i) t</span>
<span class="lineno">  279 </span><span class="spaces">     </span><span class="istickedoff">let telems = map bit [0..len-1]</span>
<span class="lineno">  280 </span><span class="spaces">     </span><span class="istickedoff">pure . Map.fromList $ mconcat</span>
<span class="lineno">  281 </span><span class="spaces">       </span><span class="istickedoff">[ [(rep, PretermSlice 0 <span class="nottickedoff">(fromIntegral len)</span> 0 t)]</span>
<span class="lineno">  282 </span><span class="spaces">       </span><span class="istickedoff">, zip ((:[]) &lt;$&gt; rep) telems</span>
<span class="lineno">  283 </span><span class="spaces">       </span><span class="istickedoff">]</span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>--------------------------------------------------------------------------------
<span class="lineno">  286 </span>-- ** Pre-terms
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>data Preterm
<span class="lineno">  289 </span>  = PretermSlice Natural Natural Natural SC.Term
<span class="lineno">  290 </span>    -- ^ @PretermSlice i j k t@ selects bits @k..k+j-1@ from @t@.
<span class="lineno">  291 </span>  | PretermBvNat Natural Natural
<span class="lineno">  292 </span>    -- ^ @PretermBvNat n x@ is @x@ as an @n@-bit binary number.
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>widthPreterm :: Preterm -&gt; Natural
<span class="lineno">  295 </span><span class="decl"><span class="istickedoff">widthPreterm p =</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="istickedoff">case p of</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice _ j _ _ -&gt; j</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">PretermBvNat n _ -&gt; n</span></span>
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>-- | Rewrite the concatenation of two 'Preterm' expressions into a
<span class="lineno">  301 </span>-- single 'Preterm', if possible.
<span class="lineno">  302 </span>fusePreterm :: Preterm -&gt; Preterm -&gt; Maybe Preterm
<span class="lineno">  303 </span><span class="decl"><span class="istickedoff">fusePreterm (PretermSlice a b c t) (PretermSlice i j k t')</span>
<span class="lineno">  304 </span><span class="spaces">  </span><span class="istickedoff">| t == t' &amp;&amp; a + b == i &amp;&amp; c == j + k =</span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">Just (PretermSlice a (b + j) k t)</span>
<span class="lineno">  306 </span><span class="spaces"></span><span class="istickedoff">fusePreterm (PretermBvNat m x) (PretermBvNat n y) =</span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="istickedoff">Just (PretermBvNat (m + n) (x * 2^n + y))</span>
<span class="lineno">  308 </span><span class="spaces"></span><span class="istickedoff">fusePreterm _ _ = Nothing</span></span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>-- | Concatenate a 'Preterm' expression onto a list of 'Preterm's,
<span class="lineno">  311 </span>-- fusing expressions if possible.
<span class="lineno">  312 </span>consPreterm :: Preterm -&gt; [Preterm] -&gt; [Preterm]
<span class="lineno">  313 </span><span class="decl"><span class="istickedoff">consPreterm x [] = [x]</span>
<span class="lineno">  314 </span><span class="spaces"></span><span class="istickedoff">consPreterm x (y : ys) =</span>
<span class="lineno">  315 </span><span class="spaces">  </span><span class="istickedoff">case fusePreterm x y of</span>
<span class="lineno">  316 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; x : y : ys</span>
<span class="lineno">  317 </span><span class="spaces">    </span><span class="istickedoff">Just xy -&gt; xy : ys</span></span>
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>-- | Rewrite a sequence of 'Preterm' expressions, combining adjacent
<span class="lineno">  320 </span>-- expressions wherever possible.
<span class="lineno">  321 </span>fusePreterms :: [Preterm] -&gt; [Preterm]
<span class="lineno">  322 </span><span class="decl"><span class="istickedoff">fusePreterms = foldr consPreterm []</span></span>
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>-- | Build a 'SC.Term' from a 'Preterm'.
<span class="lineno">  325 </span>scPreterm :: SC.SharedContext -&gt; Preterm -&gt; IO SC.Term
<span class="lineno">  326 </span><span class="decl"><span class="istickedoff">scPreterm sc p =</span>
<span class="lineno">  327 </span><span class="spaces">  </span><span class="istickedoff">case p of</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice 0 _ 0 t -&gt;</span>
<span class="lineno">  329 </span><span class="spaces">      </span><span class="istickedoff">pure t</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice 0 j k t -&gt;</span>
<span class="lineno">  331 </span><span class="spaces">      </span><span class="istickedoff">do boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  332 </span><span class="spaces">         </span><span class="istickedoff">j' &lt;- SC.scNat sc j</span>
<span class="lineno">  333 </span><span class="spaces">         </span><span class="istickedoff">k' &lt;- SC.scNat sc k</span>
<span class="lineno">  334 </span><span class="spaces">         </span><span class="istickedoff">SC.scGlobalApply sc &quot;Prelude.take&quot; [boolty, j', k', t]</span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice i j 0 t -&gt;</span>
<span class="lineno">  336 </span><span class="spaces">      </span><span class="istickedoff">do boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  337 </span><span class="spaces">         </span><span class="istickedoff">i' &lt;- SC.scNat sc i</span>
<span class="lineno">  338 </span><span class="spaces">         </span><span class="istickedoff">j' &lt;- SC.scNat sc j</span>
<span class="lineno">  339 </span><span class="spaces">         </span><span class="istickedoff">SC.scGlobalApply sc &quot;Prelude.drop&quot; [boolty, i', j', t]</span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice i 1 k t -&gt;</span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff">do boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  342 </span><span class="spaces">         </span><span class="istickedoff">n' &lt;- SC.scNat sc (i + 1 + k)</span>
<span class="lineno">  343 </span><span class="spaces">         </span><span class="istickedoff">i' &lt;- SC.scNat sc i</span>
<span class="lineno">  344 </span><span class="spaces">         </span><span class="istickedoff">SC.scSingle sc boolty =&lt;&lt; SC.scAt sc n' boolty t i'</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice i j k t -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do boolty &lt;- SC.scBoolType sc</span></span>
<span class="lineno">  347 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">i' &lt;- SC.scNat sc i</span></span>
<span class="lineno">  348 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">j' &lt;- SC.scNat sc j</span></span>
<span class="lineno">  349 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">k' &lt;- SC.scNat sc k</span></span>
<span class="lineno">  350 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">SC.scSlice sc boolty i' j' k' t</span></span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">PretermBvNat i x -&gt;</span>
<span class="lineno">  352 </span><span class="spaces">      </span><span class="istickedoff">do i' &lt;- SC.scNat sc i</span>
<span class="lineno">  353 </span><span class="spaces">         </span><span class="istickedoff">x' &lt;- SC.scNat sc x</span>
<span class="lineno">  354 </span><span class="spaces">         </span><span class="istickedoff">SC.scBvNat sc i' x'</span></span>
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>-- | Build a 'SC.Term' from a concatenated sequence of 'Preterm's.
<span class="lineno">  357 </span>scPreterms :: SC.SharedContext -&gt; [Preterm] -&gt; IO SC.Term
<span class="lineno">  358 </span><span class="decl"><span class="istickedoff">scPreterms sc preterms = snd &lt;$&gt; go preterms</span>
<span class="lineno">  359 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">append :: (Natural, SC.Term) -&gt; (Natural, SC.Term) -&gt; IO (Natural, SC.Term)</span>
<span class="lineno">  361 </span><span class="spaces">    </span><span class="istickedoff">append (i, x) (j, y)</span>
<span class="lineno">  362 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">i == 0</span> = <span class="nottickedoff">pure (j, y)</span></span>
<span class="lineno">  363 </span><span class="spaces">      </span><span class="istickedoff">| j == 0 = pure (i, x)</span>
<span class="lineno">  364 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  365 </span><span class="spaces">        </span><span class="istickedoff">do i' &lt;- SC.scNat sc i</span>
<span class="lineno">  366 </span><span class="spaces">           </span><span class="istickedoff">j' &lt;- SC.scNat sc j</span>
<span class="lineno">  367 </span><span class="spaces">           </span><span class="istickedoff">boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  368 </span><span class="spaces">           </span><span class="istickedoff">t &lt;- SC.scAppend sc i' j' boolty x y</span>
<span class="lineno">  369 </span><span class="spaces">           </span><span class="istickedoff">pure (<span class="nottickedoff">i + j</span>, t)</span>
<span class="lineno">  370 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  371 </span><span class="spaces">    </span><span class="istickedoff">go :: [Preterm] -&gt; IO (Natural, SC.Term)</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="istickedoff">go [] =</span>
<span class="lineno">  373 </span><span class="spaces">      </span><span class="istickedoff">do z &lt;- SC.scNat sc 0</span>
<span class="lineno">  374 </span><span class="spaces">         </span><span class="istickedoff">t &lt;- SC.scBvNat sc z z</span>
<span class="lineno">  375 </span><span class="spaces">         </span><span class="istickedoff">pure (0, <span class="nottickedoff">t</span>)</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">go (p : ps) =</span>
<span class="lineno">  377 </span><span class="spaces">      </span><span class="istickedoff">do let i = widthPreterm p</span>
<span class="lineno">  378 </span><span class="spaces">         </span><span class="istickedoff">p' &lt;- scPreterm sc p</span>
<span class="lineno">  379 </span><span class="spaces">         </span><span class="istickedoff">let (ps1, ps2) = span ((==i) . widthPreterm) ps</span>
<span class="lineno">  380 </span><span class="spaces">         </span><span class="istickedoff">if length ps1 &gt; 1 then</span>
<span class="lineno">  381 </span><span class="spaces">           </span><span class="istickedoff">-- Use `join` to concatenate same-length preterms</span>
<span class="lineno">  382 </span><span class="spaces">           </span><span class="istickedoff">do i' &lt;- SC.scNat sc i</span>
<span class="lineno">  383 </span><span class="spaces">              </span><span class="istickedoff">boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  384 </span><span class="spaces">              </span><span class="istickedoff">ety &lt;- SC.scVecType sc i' boolty</span>
<span class="lineno">  385 </span><span class="spaces">              </span><span class="istickedoff">ps1' &lt;- traverse (scPreterm <span class="nottickedoff">sc</span>) ps1</span>
<span class="lineno">  386 </span><span class="spaces">              </span><span class="istickedoff">v &lt;- SC.scVector sc ety (p' : ps1')</span>
<span class="lineno">  387 </span><span class="spaces">              </span><span class="istickedoff">let len = List.genericLength ps1 + 1 :: Natural</span>
<span class="lineno">  388 </span><span class="spaces">              </span><span class="istickedoff">len' &lt;- SC.scNat sc len</span>
<span class="lineno">  389 </span><span class="spaces">              </span><span class="istickedoff">x &lt;- SC.scJoin sc len' i' boolty v</span>
<span class="lineno">  390 </span><span class="spaces">              </span><span class="istickedoff">(j, y) &lt;- go ps2</span>
<span class="lineno">  391 </span><span class="spaces">              </span><span class="istickedoff">append (len * i, x) (j, <span class="nottickedoff">y</span>)</span>
<span class="lineno">  392 </span><span class="spaces">           </span><span class="istickedoff">else</span>
<span class="lineno">  393 </span><span class="spaces">           </span><span class="istickedoff">do x &lt;- scPreterm sc p</span>
<span class="lineno">  394 </span><span class="spaces">              </span><span class="istickedoff">(j, y) &lt;- go ps</span>
<span class="lineno">  395 </span><span class="spaces">              </span><span class="istickedoff">append (i, x) (j, y)</span></span>

</pre>
</body>
</html>
