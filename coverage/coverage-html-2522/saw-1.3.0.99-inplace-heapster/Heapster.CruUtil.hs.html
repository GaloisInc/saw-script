<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    2 </span>{-# LANGUAGE EmptyCase #-}
<span class="lineno">    3 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    4 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">    5 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">    6 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    7 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">    8 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">    9 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   10 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   11 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   12 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   13 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   14 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   15 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   16 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   17 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">   18 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   19 </span>{-# LANGUAGE QuantifiedConstraints #-}
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>{-# OPTIONS_GHC -fno-warn-orphans #-}
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>module Heapster.CruUtil where
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>import Data.Text (Text)
<span class="lineno">   26 </span>import qualified Data.Text as Text
<span class="lineno">   27 </span>import Data.Reflection
<span class="lineno">   28 </span>import Data.List.NonEmpty (NonEmpty(..))
<span class="lineno">   29 </span>import Data.Functor.Constant
<span class="lineno">   30 </span>import Data.ByteString
<span class="lineno">   31 </span>import Numeric
<span class="lineno">   32 </span>import Numeric.Natural
<span class="lineno">   33 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   34 </span>import System.FilePath
<span class="lineno">   35 </span>import GHC.TypeNats (KnownNat, natVal)
<span class="lineno">   36 </span>import Data.Functor.Product
<span class="lineno">   37 </span>import Control.Lens hiding ((:&gt;), Index, Empty, ix, op)
<span class="lineno">   38 </span>import qualified Control.Monad.Fail as Fail
<span class="lineno">   39 </span>import Data.Binding.Hobbits
<span class="lineno">   40 </span>import qualified Data.Type.RList as RL
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import What4.ProgramLoc
<span class="lineno">   43 </span>import What4.Partial
<span class="lineno">   44 </span>import What4.Interface (StringLiteral(..))
<span class="lineno">   45 </span>import What4.Utils.Word16String (Word16String)
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>import Data.Parameterized.Context hiding ((:&gt;), empty, take, view)
<span class="lineno">   48 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">   49 </span>import Data.Parameterized.TraversableFC
<span class="lineno">   50 </span>import Data.Parameterized.BoolRepr
<span class="lineno">   51 </span>import Data.Parameterized.Nonce (Nonce)
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>-- import qualified Text.PrettyPrint.ANSI.Leijen as PP
<span class="lineno">   54 </span>import qualified Prettyprinter as PP
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import qualified Text.LLVM.AST as L
<span class="lineno">   57 </span>import Lang.Crucible.Types
<span class="lineno">   58 </span>import Lang.Crucible.FunctionHandle
<span class="lineno">   59 </span>import Lang.Crucible.CFG.Expr
<span class="lineno">   60 </span>import Lang.Crucible.CFG.Core hiding (App)
<span class="lineno">   61 </span>import qualified Lang.Crucible.CFG.Core as Core
<span class="lineno">   62 </span>import Lang.Crucible.LLVM.Bytes
<span class="lineno">   63 </span>import Lang.Crucible.LLVM.Errors
<span class="lineno">   64 </span>import Lang.Crucible.LLVM.Errors.MemoryError
<span class="lineno">   65 </span>import Lang.Crucible.LLVM.Extension
<span class="lineno">   66 </span>import Lang.Crucible.LLVM.MemModel
<span class="lineno">   67 </span>import Lang.Crucible.LLVM.Arch.X86
<span class="lineno">   68 </span>import Lang.Crucible.LLVM.DataLayout
<span class="lineno">   69 </span>import qualified Lang.Crucible.LLVM.Errors.Poison as Poison
<span class="lineno">   70 </span>import qualified Lang.Crucible.LLVM.Errors.UndefinedBehavior as UB
<span class="lineno">   71 </span>import SAWCore.Term.Functor
<span class="lineno">   72 </span>import SAWCore.OpenTerm
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>-- | The lens into an 'RAssign' associated with a 'Member' proof
<span class="lineno">   76 </span>--
<span class="lineno">   77 </span>-- FIXME HERE: this should go into Hobbits, possibly using
<span class="lineno">   78 </span>member :: Member ctx a -&gt; Lens' (RAssign f ctx) (f a)
<span class="lineno">   79 </span><span class="decl"><span class="nottickedoff">member memb = lens (RL.get memb) (flip (RL.set memb))</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-- | Traverse an 'RAssign' inside an 'Applicative'
<span class="lineno">   82 </span>--
<span class="lineno">   83 </span>-- FIXME HERE: move to Hobbits, renaming it just plain 'traverse'
<span class="lineno">   84 </span>traverseRAssign :: Applicative m =&gt; (forall x. f x -&gt; m (g x)) -&gt;
<span class="lineno">   85 </span>                   RAssign f c -&gt; m (RAssign g c)
<span class="lineno">   86 </span><span class="decl"><span class="nottickedoff">traverseRAssign _ MNil = pure MNil</span>
<span class="lineno">   87 </span><span class="spaces"></span><span class="nottickedoff">traverseRAssign f (xs :&gt;: x) = (:&gt;:) &lt;$&gt; traverseRAssign f xs &lt;*&gt; f x</span></span>
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>-- FIXME HERE: this should move to Hobbits
<span class="lineno">   90 </span>instance Closable a =&gt; Closable (Maybe a) where
<span class="lineno">   91 </span>  <span class="decl"><span class="nottickedoff">toClosed Nothing = $(mkClosed [| Nothing |])</span>
<span class="lineno">   92 </span><span class="spaces">  </span><span class="nottickedoff">toClosed (Just a) = $(mkClosed [| Just |]) `clApply` toClosed a</span></span>
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>-- FIXME HERE: this should move to Hobbits
<span class="lineno">   95 </span>instance (Closable a, Closable b) =&gt; Closable (a,b) where
<span class="lineno">   96 </span>  <span class="decl"><span class="nottickedoff">toClosed (a,b) =</span>
<span class="lineno">   97 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| (,) |]) `clApply` toClosed a `clApply` toClosed b</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>----------------------------------------------------------------------
<span class="lineno">  101 </span>-- * Helper Functions for 'NatRepr' and 'KnownNat'
<span class="lineno">  102 </span>----------------------------------------------------------------------
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- | A version of 'natVal' that takes a phantom argument with 2 applied type
<span class="lineno">  105 </span>-- functors instead of 1
<span class="lineno">  106 </span>natVal2 :: KnownNat w =&gt; f (g w) -&gt; Natural
<span class="lineno">  107 </span><span class="decl"><span class="nottickedoff">natVal2 (_ :: f (g w)) = natVal (Proxy :: Proxy w)</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>-- | A version of 'natVal' that takes a phantom argument with 3 applied type
<span class="lineno">  110 </span>-- functors instead of 1
<span class="lineno">  111 </span>natVal3 :: KnownNat w =&gt; f (g (h w)) -&gt; Natural
<span class="lineno">  112 </span><span class="decl"><span class="nottickedoff">natVal3 (_ :: f (g (h w))) = natVal (Proxy :: Proxy w)</span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- | A version of 'natVal' that takes a phantom argument with 4 applied type
<span class="lineno">  115 </span>-- functors instead of 1
<span class="lineno">  116 </span>natVal4 :: KnownNat w =&gt; f (g (h (i w))) -&gt; Natural
<span class="lineno">  117 </span><span class="decl"><span class="nottickedoff">natVal4 (_ :: f (g (h (i w)))) = natVal (Proxy :: Proxy w)</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>-- | A version of 'knownNat' that take a phantom argument
<span class="lineno">  120 </span>natRepr :: KnownNat w =&gt; f w -&gt; NatRepr w
<span class="lineno">  121 </span><span class="decl"><span class="nottickedoff">natRepr _ = knownNat</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>-- | A version of 'natRepr' that take a phantom argument with 2 applied type
<span class="lineno">  124 </span>-- functors instead of 1
<span class="lineno">  125 </span>natRepr2 :: KnownNat w =&gt; f (g w) -&gt; NatRepr w
<span class="lineno">  126 </span><span class="decl"><span class="nottickedoff">natRepr2 _ = knownNat</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- | A version of 'natRepr' that take a phantom argument with 3 applied type
<span class="lineno">  129 </span>-- functors instead of 1
<span class="lineno">  130 </span>natRepr3 :: KnownNat w =&gt; f (g (h w)) -&gt; NatRepr w
<span class="lineno">  131 </span><span class="decl"><span class="nottickedoff">natRepr3 _ = knownNat</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>-- | A version of 'natRepr' that take a phantom argument with 4 applied type
<span class="lineno">  134 </span>-- functors instead of 1
<span class="lineno">  135 </span>natRepr4 :: KnownNat w =&gt; f (g (h (i w))) -&gt; NatRepr w
<span class="lineno">  136 </span><span class="decl"><span class="nottickedoff">natRepr4 _ = knownNat</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | A 'NatRepr' for @1@
<span class="lineno">  139 </span>oneRepr :: NatRepr 1
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">oneRepr = knownRepr</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>-- | Convert an 'Integral' type to 'NatRepr' that is at least 1, if possible
<span class="lineno">  143 </span>someNatGeq1 :: Integral a =&gt; a -&gt; Maybe (Some (Product NatRepr (LeqProof 1)))
<span class="lineno">  144 </span><span class="decl"><span class="nottickedoff">someNatGeq1 i</span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="nottickedoff">| Just (Some w) &lt;- someNat i</span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="nottickedoff">, Left leq &lt;- decideLeq oneRepr w = Just (Some (Pair w leq))</span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="nottickedoff">someNatGeq1 _ = Nothing</span></span>
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>data SomeKnownNatGeq1 where
<span class="lineno">  150 </span>  SomeKnownNatGeq1 :: (KnownNat n, 1 &lt;= n) =&gt; NatRepr n -&gt; SomeKnownNatGeq1
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>someKnownNatGeq1 :: Integral a =&gt; a -&gt; Maybe SomeKnownNatGeq1
<span class="lineno">  153 </span><span class="decl"><span class="nottickedoff">someKnownNatGeq1 i</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="nottickedoff">| Just (Some (Pair w LeqProof)) &lt;- someNatGeq1 i</span>
<span class="lineno">  155 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ withKnownNat w (SomeKnownNatGeq1 w)</span>
<span class="lineno">  156 </span><span class="spaces"></span><span class="nottickedoff">someKnownNatGeq1 _ = Nothing</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>----------------------------------------------------------------------
<span class="lineno">  160 </span>-- * Building 'NuMatching' and 'Closable' Instances for Crucible Types
<span class="lineno">  161 </span>----------------------------------------------------------------------
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>-- | A reification of an object of type @a@ at type level
<span class="lineno">  164 </span>data ReifiesObj a = forall s. Reifies s a =&gt; ReifiesObj (Proxy s)
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall a. ReifiesObj a |])</span></span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- | Build a 'ReifiesObj' containing a value
<span class="lineno">  169 </span>mkReifiesObj :: a -&gt; ReifiesObj a
<span class="lineno">  170 </span><span class="decl"><span class="nottickedoff">mkReifiesObj a = reify a ReifiesObj</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>-- | Project out the value contained in a 'ReifiesObj'
<span class="lineno">  173 </span>projReifiesObj :: ReifiesObj a -&gt; a
<span class="lineno">  174 </span><span class="decl"><span class="nottickedoff">projReifiesObj (ReifiesObj prx) = reflect prx</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>instance NuMatching Ident where
<span class="lineno">  177 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>instance Closable Ident where
<span class="lineno">  180 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>instance Liftable Ident where
<span class="lineno">  183 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>instance NuMatching OpenTerm where
<span class="lineno">  186 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>instance NuMatching GlobalSymbol where
<span class="lineno">  189 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>instance Closable GlobalSymbol where
<span class="lineno">  192 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>instance Liftable GlobalSymbol where
<span class="lineno">  195 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>-- | This is copied from 'Lang.Crucible.LLVM.Types', as that module is hidden
<span class="lineno">  198 </span>globalSymbolName :: GlobalSymbol -&gt; String
<span class="lineno">  199 </span><span class="decl"><span class="nottickedoff">globalSymbolName (GlobalSymbol (L.Symbol str)) = str</span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>instance NuMatching (SymbolRepr tp) where
<span class="lineno">  202 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>instance NuMatching (BoolRepr tp) where
<span class="lineno">  205 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>instance Closable (BoolRepr tp) where
<span class="lineno">  208 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>instance Liftable (BoolRepr tp) where
<span class="lineno">  211 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>instance NuMatching (NatRepr tp) where
<span class="lineno">  214 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>instance Closable (NatRepr tp) where
<span class="lineno">  217 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>instance Liftable (NatRepr tp) where
<span class="lineno">  220 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>instance NuMatching (TypeRepr tp) where
<span class="lineno">  223 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>instance Closable (TypeRepr tp) where
<span class="lineno">  226 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  227 </span>
<span class="lineno">  228 </span>instance Liftable (TypeRepr tp) where
<span class="lineno">  229 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>  -- FIXME: we will need this instance when we define CruCtx via RAssign
<span class="lineno">  232 </span>{-
<span class="lineno">  233 </span>instance ClosableAny1 TypeRepr where
<span class="lineno">  234 </span>  closableAny1 _ = IsClosable
<span class="lineno">  235 </span>-}
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>instance NuMatching (BaseTypeRepr tp) where
<span class="lineno">  238 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>instance Closable (BaseTypeRepr tp) where
<span class="lineno">  241 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>instance Liftable (BaseTypeRepr tp) where
<span class="lineno">  244 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>-- NOTE: this is handled by the Assignment instance
<span class="lineno">  247 </span>-- instance NuMatching (CtxRepr ctx) where
<span class="lineno">  248 </span>--   nuMatchingProof = isoMbTypeRepr mkKnownReprObj getKnownReprObj
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>instance NuMatching (Index ctx a) where
<span class="lineno">  251 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>instance Closable (Index ctx a) where
<span class="lineno">  254 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>instance Liftable (Index ctx a) where
<span class="lineno">  257 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>instance NuMatching Text where
<span class="lineno">  260 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>instance Closable Text where
<span class="lineno">  263 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>instance Liftable Text where
<span class="lineno">  266 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>instance NuMatching ProgramLoc where
<span class="lineno">  269 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>instance Closable ProgramLoc where
<span class="lineno">  272 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>instance Liftable ProgramLoc where
<span class="lineno">  275 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>-- | Pretty-print a 'Position' with a \&quot;short\&quot; filename, without the path
<span class="lineno">  278 </span>ppShortFileName :: Position -&gt; PP.Doc ann
<span class="lineno">  279 </span><span class="decl"><span class="nottickedoff">ppShortFileName (SourcePos path l c) =</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="nottickedoff">PP.pretty (takeFileName $ Text.unpack path)</span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="nottickedoff">PP.&lt;&gt; PP.colon PP.&lt;&gt; PP.pretty l</span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="nottickedoff">PP.&lt;&gt; PP.colon PP.&lt;&gt; PP.pretty c</span>
<span class="lineno">  283 </span><span class="spaces"></span><span class="nottickedoff">ppShortFileName (BinaryPos path addr) =</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="nottickedoff">PP.pretty (takeFileName $ Text.unpack path) PP.&lt;&gt; PP.colon PP.&lt;&gt;</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="nottickedoff">PP.pretty &quot;0x&quot; PP.&lt;&gt; PP.pretty (showHex addr &quot;&quot;)</span>
<span class="lineno">  286 </span><span class="spaces"></span><span class="nottickedoff">ppShortFileName (OtherPos txt) = PP.pretty (Text.unpack txt)</span>
<span class="lineno">  287 </span><span class="spaces"></span><span class="nottickedoff">ppShortFileName InternalPos = PP.pretty &quot;internal&quot;</span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>instance NuMatching ByteString where
<span class="lineno">  290 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>instance NuMatching (MemoryError sym) where
<span class="lineno">  293 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>instance NuMatching MemoryErrorReason where
<span class="lineno">  296 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>instance NuMatching (FnHandle args ret) where
<span class="lineno">  299 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>instance NuMatching SomeHandle where
<span class="lineno">  302 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>instance NuMatching (FloatInfoRepr fi) where
<span class="lineno">  305 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>instance NuMatching RoundingMode where
<span class="lineno">  308 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>instance NuMatching EndianForm where
<span class="lineno">  311 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>instance Closable EndianForm where
<span class="lineno">  314 </span>  <span class="decl"><span class="nottickedoff">toClosed BigEndian = $(mkClosed [| BigEndian |])</span>
<span class="lineno">  315 </span><span class="spaces">  </span><span class="nottickedoff">toClosed LittleEndian = $(mkClosed [| LittleEndian |])</span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>instance Liftable EndianForm where
<span class="lineno">  318 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f. NuMatchingAny1 f =&gt; Some f |])</span></span></span>
<span class="lineno">  321 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f ctx . NuMatchingAny1 f =&gt; AssignView f ctx |])</span></span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>viewToAssign :: AssignView f ctx -&gt; Assignment f ctx
<span class="lineno">  324 </span><span class="decl"><span class="nottickedoff">viewToAssign AssignEmpty = Ctx.empty</span>
<span class="lineno">  325 </span><span class="spaces"></span><span class="nottickedoff">viewToAssign (AssignExtend asgn' f) = extend asgn' f</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>instance NuMatchingAny1 f =&gt; NuMatching (Assignment f ctx) where
<span class="lineno">  328 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof =</span>
<span class="lineno">  329 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: inefficient to map a whole Assignment step by step to ViewAssigns,</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="nottickedoff">-- freshen each element, and then map back to the Assignment again; maybe we</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="nottickedoff">-- need to figure out how to use the TraversableFC instance for Assignment</span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="nottickedoff">-- here?</span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="nottickedoff">isoMbTypeRepr viewAssign viewToAssign</span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>instance Closable (Assignment TypeRepr ctx) where
<span class="lineno">  336 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>instance Liftable (Assignment TypeRepr ctx) where
<span class="lineno">  339 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f tp. NuMatchingAny1 f =&gt; BaseTerm f tp |])</span></span></span>
<span class="lineno">  343 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall a. NuMatching a =&gt; NonEmpty a |])</span></span></span>
<span class="lineno">  344 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall p v. (NuMatching p, NuMatching v) =&gt; Partial p v |])</span></span></span>
<span class="lineno">  345 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| X86_80Val |])</span></span></span>
<span class="lineno">  346 </span>-- $(mkNuMatching [t| MemoryLoadError |]) -- NOTE: contains unexported types
<span class="lineno">  347 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall w. BV.BV w |])</span></span></span>
<span class="lineno">  348 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| Word16String |])</span></span></span>
<span class="lineno">  349 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall s. StringLiteral s |])</span></span></span>
<span class="lineno">  350 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall s. StringInfoRepr s |])</span></span></span>
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>#if __GLASGOW_HASKELL__ &gt;= 902
<span class="lineno">  353 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ext f tp.</span>
<span class="lineno">  354 </span><span class="spaces">                </span><span class="nottickedoff">(NuMatchingAny1 f, NuMatchingAny1 (ExprExtension ext f)) =&gt;</span>
<span class="lineno">  355 </span><span class="spaces">                </span><span class="nottickedoff">App ext f tp |])</span></span></span>
<span class="lineno">  356 </span>#else
<span class="lineno">  357 </span>-- See Note [QuantifiedConstraints + TypeFamilies trick]
<span class="lineno">  358 </span>$(mkNuMatching [t| forall ext f tp exprExt.
<span class="lineno">  359 </span>                ( NuMatchingAny1 f
<span class="lineno">  360 </span>                , exprExt ~ ExprExtension ext f, NuMatchingAny1 exprExt
<span class="lineno">  361 </span>                ) =&gt; App ext f tp |])
<span class="lineno">  362 </span>#endif
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| Bytes |])</span></span></span>
<span class="lineno">  365 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall v. NuMatching v =&gt; Field v |])</span></span></span>
<span class="lineno">  366 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| Alignment |])</span></span></span>
<span class="lineno">  367 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| UB.PtrComparisonOperator |])</span></span></span>
<span class="lineno">  368 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall v. NuMatching v =&gt; StorageTypeF v |])</span></span></span>
<span class="lineno">  369 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| StorageType |])</span></span></span>
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f. NuMatchingAny1 f =&gt; Poison.Poison f |])</span></span></span>
<span class="lineno">  372 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f. NuMatchingAny1 f =&gt; UB.UndefinedBehavior f |])</span></span></span>
<span class="lineno">  373 </span>-- $(mkNuMatching [t| forall f. NuMatchingAny1 f =&gt; BadBehavior f |])
<span class="lineno">  374 </span>-- $(mkNuMatching [t| forall f. NuMatchingAny1 f =&gt; LLVMSafetyAssertion f |])
<span class="lineno">  375 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f. NuMatchingAny1 f =&gt; LLVMSideCondition f |])</span></span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks tp. BlockID blocks tp |])</span></span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>-- FIXME: Hobbits mkNuMatching cannot handle empty types
<span class="lineno">  380 </span>-- $(mkNuMatching [t| forall f tp. EmptyExprExtension f tp |])
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>instance NuMatching (EmptyExprExtension f tp) where
<span class="lineno">  383 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| AVXOp1 |])</span></span></span>
<span class="lineno">  386 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f tp. NuMatchingAny1 f =&gt; ExtX86 f tp |])</span></span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>instance NuMatching (Nonce s tp) where
<span class="lineno">  389 </span>  <span class="decl"><span class="nottickedoff">nuMatchingProof = unsafeMbTypeRepr</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>instance Closable (Nonce s tp) where
<span class="lineno">  392 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>instance Liftable (Nonce s tp) where
<span class="lineno">  395 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  396 </span>
<span class="lineno">  397 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall tp. GlobalVar tp |])</span></span></span>
<span class="lineno">  398 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f tp. NuMatchingAny1 f =&gt;</span>
<span class="lineno">  399 </span><span class="spaces">                </span><span class="nottickedoff">LLVMExtensionExpr f tp |])</span></span></span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>{-
<span class="lineno">  402 </span>$(mkNuMatching [t| forall w f tp. NuMatchingAny1 f =&gt; LLVMStmt w f tp |])
<span class="lineno">  403 </span>-}
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>instance Closable (BV.BV w) where
<span class="lineno">  406 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>instance Liftable (BV.BV w) where
<span class="lineno">  409 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  410 </span>
<span class="lineno">  411 </span>instance Closable Bytes where
<span class="lineno">  412 </span>  <span class="decl"><span class="nottickedoff">toClosed (Bytes i) =</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| Bytes |]) `clApply` (toClosed i)</span></span>
<span class="lineno">  414 </span>
<span class="lineno">  415 </span>instance Liftable Bytes where
<span class="lineno">  416 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>instance Closable (StringLiteral si) where
<span class="lineno">  419 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>instance Liftable (StringLiteral si) where
<span class="lineno">  422 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>instance Closable (BadBehavior e) where
<span class="lineno">  425 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>-- instance NuMatchingAny1 e =&gt; Liftable (BadBehavior e) where
<span class="lineno">  428 </span>  -- mbLift = unClosed . mbLift . fmap toClosed
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>-- NOTE: Crucible objects can never contain any Hobbits names, but \&quot;proving\&quot;
<span class="lineno">  431 </span>-- that would require introspection of opaque types like 'Index' and 'Nonce',
<span class="lineno">  432 </span>-- and would also be inefficient, so we just use 'unsafeClose'
<span class="lineno">  433 </span>
<span class="lineno">  434 </span>instance Closable (Block ext cblocks ret args) where
<span class="lineno">  435 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>instance Closable (FnHandle args ret) where
<span class="lineno">  438 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>instance Liftable (FnHandle args ret) where
<span class="lineno">  441 </span>  <span class="decl"><span class="nottickedoff">mbLift fh = unClosed $ mbLift $ fmap toClosed fh</span></span>
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>instance Closable SomeHandle where
<span class="lineno">  444 </span>  <span class="decl"><span class="nottickedoff">toClosed = unsafeClose</span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>instance Liftable SomeHandle where
<span class="lineno">  447 </span>  <span class="decl"><span class="nottickedoff">mbLift fh = unClosed $ mbLift $ fmap toClosed fh</span></span>
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>-- | Close an assignment whose elements are all 'Closable'
<span class="lineno">  450 </span>closeAssign :: (forall a. f a -&gt; Closed (f a)) -&gt; Assignment f ctx -&gt;
<span class="lineno">  451 </span>               Closed (Assignment f ctx)
<span class="lineno">  452 </span><span class="decl"><span class="nottickedoff">closeAssign _ (viewAssign -&gt; AssignEmpty) = $(mkClosed [| Ctx.empty |])</span>
<span class="lineno">  453 </span><span class="spaces"></span><span class="nottickedoff">closeAssign f (viewAssign -&gt; AssignExtend asgn fa) =</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="nottickedoff">$(mkClosed [| Ctx.extend |]) `clApply` closeAssign f asgn `clApply` f fa</span></span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>----------------------------------------------------------------------
<span class="lineno">  458 </span>-- * Objects Associated with Crucible Types
<span class="lineno">  459 </span>----------------------------------------------------------------------
<span class="lineno">  460 </span>
<span class="lineno">  461 </span>-- FIXME HERE: replace all calls to show tp with our own type-printing function
<span class="lineno">  462 </span>-- that prints in the same format that we are parsing
<span class="lineno">  463 </span>
<span class="lineno">  464 </span>-- | An element of some representation type functor @f a@ along with a
<span class="lineno">  465 </span>-- 'TypeRepr' for @a@
<span class="lineno">  466 </span>data Typed f a = Typed { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedType</span></span></span> :: TypeRepr a, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedObj</span></span></span> :: f a }
<span class="lineno">  467 </span>
<span class="lineno">  468 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f a. NuMatching (f a) =&gt; Typed f a |])</span></span></span>
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>-- | Cast an existential 'Typed' to a particular type or raise an error
<span class="lineno">  471 </span>castTypedM :: Fail.MonadFail m =&gt; String -&gt; TypeRepr a -&gt; Some (Typed f) -&gt; m (f a)
<span class="lineno">  472 </span><span class="decl"><span class="nottickedoff">castTypedM _ tp (Some (Typed tp' f))</span>
<span class="lineno">  473 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp tp' = return f</span>
<span class="lineno">  474 </span><span class="spaces"></span><span class="nottickedoff">castTypedM str tp (Some (Typed tp' _)) =</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="nottickedoff">fail (&quot;Expected &quot; ++ str ++ &quot; of type &quot; ++ show tp</span>
<span class="lineno">  476 </span><span class="spaces">        </span><span class="nottickedoff">++ &quot;, found one of type &quot; ++ show tp')</span></span>
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>-- | A expression variable of some existentially quantified type
<span class="lineno">  479 </span>type TypedName = Some (Typed Name)
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>----------------------------------------------------------------------
<span class="lineno">  483 </span>-- * Contexts of Crucible Types
<span class="lineno">  484 </span>----------------------------------------------------------------------
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>-- | Convert a Crucible 'Ctx' to a Hobbits 'RList'
<span class="lineno">  487 </span>type family CtxToRList (ctx :: Ctx k) :: RList k where
<span class="lineno">  488 </span>  CtxToRList EmptyCtx = RNil
<span class="lineno">  489 </span>  CtxToRList (ctx' ::&gt; x) = CtxToRList ctx' :&gt; x
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>-- | Convert a Hobbits 'RList' to a Crucible 'Ctx'
<span class="lineno">  492 </span>type family RListToCtx (ctx :: RList k) :: Ctx k where
<span class="lineno">  493 </span>  RListToCtx RNil = EmptyCtx
<span class="lineno">  494 </span>  RListToCtx (ctx' :&gt; x) = RListToCtx ctx' ::&gt; x
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>-- | Convert a Crucible context of contexts to a Hobbits one
<span class="lineno">  497 </span>type family CtxCtxToRList (ctx :: Ctx (Ctx k)) :: RList (RList k) where
<span class="lineno">  498 </span>  CtxCtxToRList EmptyCtx = RNil
<span class="lineno">  499 </span>  CtxCtxToRList (ctx' ::&gt; c) = CtxCtxToRList ctx' :&gt; CtxToRList c
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>-- | Convert a Hobbits context of contexts to a Crucible one
<span class="lineno">  502 </span>type family RListToCtxCtx (ctx :: RList (RList k)) :: Ctx (Ctx k) where
<span class="lineno">  503 </span>  RListToCtxCtx RNil = EmptyCtx
<span class="lineno">  504 </span>  RListToCtxCtx (ctx' :&gt; c) = RListToCtxCtx ctx' ::&gt; RListToCtx c
<span class="lineno">  505 </span>
<span class="lineno">  506 </span>-- | Convert a Crucible 'Assignment' to a Hobbits 'RAssign'
<span class="lineno">  507 </span>assignToRList :: Assignment f ctx -&gt; RAssign f (CtxToRList ctx)
<span class="lineno">  508 </span><span class="decl"><span class="nottickedoff">assignToRList asgn = case viewAssign asgn of</span>
<span class="lineno">  509 </span><span class="spaces">  </span><span class="nottickedoff">AssignEmpty -&gt; MNil</span>
<span class="lineno">  510 </span><span class="spaces">  </span><span class="nottickedoff">AssignExtend asgn' f -&gt; assignToRList asgn' :&gt;: f</span></span>
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>-- | Invert 'assignToRList', converting a Hobbits 'RAssign' over a Hobbits
<span class="lineno">  513 </span>-- context generated by 'CtxToRList' back to a Crucible 'Assignment'
<span class="lineno">  514 </span>unAssignToRList :: Assignment prx ctx -&gt; RAssign f (CtxToRList ctx) -&gt;
<span class="lineno">  515 </span>                   Assignment f ctx
<span class="lineno">  516 </span><span class="decl"><span class="nottickedoff">unAssignToRList ctx fs =</span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="nottickedoff">let sz = Ctx.size ctx in</span>
<span class="lineno">  518 </span><span class="spaces">  </span><span class="nottickedoff">Ctx.generate sz $ \ix -&gt; RL.get (indexToMember sz ix) fs</span></span>
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>-- | Append two Hobbits 'RAssign's that have been generated by 'assignToRList'
<span class="lineno">  521 </span>assignToRListAppend :: Assignment prx1 ctx1 -&gt; Assignment prx2 ctx2 -&gt;
<span class="lineno">  522 </span>                       RAssign f (CtxToRList ctx1) -&gt;
<span class="lineno">  523 </span>                       RAssign f (CtxToRList ctx2) -&gt;
<span class="lineno">  524 </span>                       RAssign f (CtxToRList (ctx1 &lt;+&gt; ctx2))
<span class="lineno">  525 </span><span class="decl"><span class="nottickedoff">assignToRListAppend ctx1 ctx2 fs1 fs2 =</span>
<span class="lineno">  526 </span><span class="spaces">  </span><span class="nottickedoff">assignToRList (unAssignToRList ctx1 fs1 Ctx.&lt;++&gt; unAssignToRList ctx2 fs2)</span></span>
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>-- | Convert a Crucible 'Assignment' over a context of contexts to an 'RAssign'
<span class="lineno">  529 </span>-- over a right-list of right-lists
<span class="lineno">  530 </span>assignToRListRList :: (forall c. f c -&gt; g (CtxToRList c)) -&gt;
<span class="lineno">  531 </span>                      Assignment f ctx -&gt; RAssign g (CtxCtxToRList ctx)
<span class="lineno">  532 </span><span class="decl"><span class="nottickedoff">assignToRListRList f asgn = case viewAssign asgn of</span>
<span class="lineno">  533 </span><span class="spaces">  </span><span class="nottickedoff">AssignEmpty -&gt; MNil</span>
<span class="lineno">  534 </span><span class="spaces">  </span><span class="nottickedoff">AssignExtend asgn' x -&gt; assignToRListRList f asgn' :&gt;: f x</span></span>
<span class="lineno">  535 </span>
<span class="lineno">  536 </span>-- | Convert a Hobbits 'RAssign' to a Crucible 'Assignment'
<span class="lineno">  537 </span>rlistToAssign :: RAssign f ctx -&gt; Assignment f (RListToCtx ctx)
<span class="lineno">  538 </span><span class="decl"><span class="nottickedoff">rlistToAssign MNil = Ctx.empty</span>
<span class="lineno">  539 </span><span class="spaces"></span><span class="nottickedoff">rlistToAssign (rlist :&gt;: f) = extend (rlistToAssign rlist) f</span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>-- | Convert a Crucible 'Index' to a Hobbits 'Member'
<span class="lineno">  542 </span>indexToMember :: Size ctx -&gt; Index ctx tp -&gt; Member (CtxToRList ctx) tp
<span class="lineno">  543 </span><span class="decl"><span class="nottickedoff">indexToMember sz ix = case viewIndex sz ix of</span>
<span class="lineno">  544 </span><span class="spaces">  </span><span class="nottickedoff">IndexViewLast _ -&gt; Member_Base</span>
<span class="lineno">  545 </span><span class="spaces">  </span><span class="nottickedoff">IndexViewInit ix' -&gt; Member_Step $ indexToMember (decSize sz) ix'</span></span>
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>-- | Convert a Crucible 'Index' into a Crucible context of contexts into a
<span class="lineno">  548 </span>-- Hobbits 'Member' in the associated 'RList' of 'RList's
<span class="lineno">  549 </span>indexCtxToMember :: Size ctx -&gt; Index ctx c -&gt;
<span class="lineno">  550 </span>                    Member (CtxCtxToRList ctx) (CtxToRList c)
<span class="lineno">  551 </span><span class="decl"><span class="nottickedoff">indexCtxToMember sz ix = case viewIndex sz ix of</span>
<span class="lineno">  552 </span><span class="spaces">  </span><span class="nottickedoff">IndexViewLast _ -&gt; Member_Base</span>
<span class="lineno">  553 </span><span class="spaces">  </span><span class="nottickedoff">IndexViewInit ix' -&gt; Member_Step $ indexCtxToMember (decSize sz) ix'</span></span>
<span class="lineno">  554 </span>
<span class="lineno">  555 </span>-- | A data-level encapsulation of the 'KnownRepr' typeclass
<span class="lineno">  556 </span>data KnownReprObj f a = KnownRepr f a =&gt; KnownReprObj
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>-- | Build a 'KnownReprObj' using a phantom type
<span class="lineno">  559 </span>mkKnownReprObj :: KnownRepr f a =&gt; prx a -&gt; KnownReprObj f a
<span class="lineno">  560 </span><span class="decl"><span class="nottickedoff">mkKnownReprObj _ = KnownReprObj</span></span>
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>-- | Extract the representation in a 'KnownReprObj'
<span class="lineno">  563 </span>unKnownReprObj :: KnownReprObj f a -&gt; f a
<span class="lineno">  564 </span><span class="decl"><span class="nottickedoff">unKnownReprObj (KnownReprObj :: KnownReprObj f a) = knownRepr :: f a</span></span>
<span class="lineno">  565 </span>
<span class="lineno">  566 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall f a. KnownReprObj f a |])</span></span></span>
<span class="lineno">  567 </span>
<span class="lineno">  568 </span>instance Liftable (KnownReprObj f a) where
<span class="lineno">  569 </span>  <span class="decl"><span class="nottickedoff">mbLift (mbMatch -&gt; [nuMP| KnownReprObj |]) = KnownReprObj</span></span>
<span class="lineno">  570 </span>
<span class="lineno">  571 </span>instance LiftableAny1 (KnownReprObj f) where
<span class="lineno">  572 </span>  <span class="decl"><span class="nottickedoff">mbLiftAny1 = mbLift</span></span>
<span class="lineno">  573 </span>
<span class="lineno">  574 </span>instance Liftable a =&gt; LiftableAny1 (Constant a) where
<span class="lineno">  575 </span>  <span class="decl"><span class="nottickedoff">mbLiftAny1 = mbLift</span></span>
<span class="lineno">  576 </span>
<span class="lineno">  577 </span>instance Liftable a =&gt; Liftable (Constant a b) where
<span class="lineno">  578 </span>  <span class="decl"><span class="nottickedoff">mbLift (mbMatch -&gt; [nuMP| Data.Functor.Constant.Constant x |]) = Data.Functor.Constant.Constant (mbLift x)</span></span>
<span class="lineno">  579 </span>
<span class="lineno">  580 </span>instance (Liftable a, Liftable b, Liftable c) =&gt; Liftable (a,b,c) where
<span class="lineno">  581 </span>  <span class="decl"><span class="nottickedoff">mbLift (mbMatch -&gt; [nuMP| (x,y,z) |]) = (mbLift x, mbLift y, mbLift z)</span></span>
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>-- FIXME: this change for issue #28 requires ClosableAny1 to be exported from
<span class="lineno">  584 </span>-- Hobbits
<span class="lineno">  585 </span>{-
<span class="lineno">  586 </span>-- | A context of Crucible types
<span class="lineno">  587 </span>type CruCtx = RAssign TypeRepr
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>-- | Pattern for an empty 'CruCtx'
<span class="lineno">  590 </span>pattern CruCtxNil :: () =&gt; (ctx ~ RNil) =&gt; CruCtx ctx
<span class="lineno">  591 </span>pattern CruCtxNil = MNil
<span class="lineno">  592 </span>
<span class="lineno">  593 </span>-- | Pattern for a non-empty 'CruCtx'
<span class="lineno">  594 </span>pattern CruCtxCons :: () =&gt; (ctx ~ (ctx' :&gt; a)) =&gt;
<span class="lineno">  595 </span>                         CruCtx ctx' -&gt; TypeRepr a -&gt; CruCtx ctx
<span class="lineno">  596 </span>pattern CruCtxCons tps tp &lt;- tps :&gt;: tp
<span class="lineno">  597 </span>  where
<span class="lineno">  598 </span>    CruCtxCons tps tp = tps :&gt;: tp
<span class="lineno">  599 </span>-}
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>-- | A context of Crucible types
<span class="lineno">  602 </span>-- FIXME: should be defined in terms of 'RAssign' as above
<span class="lineno">  603 </span>data CruCtx ctx where
<span class="lineno">  604 </span>  CruCtxNil :: CruCtx RNil
<span class="lineno">  605 </span>  CruCtxCons :: CruCtx ctx -&gt; TypeRepr a -&gt; CruCtx (ctx :&gt; a)
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>-- $(mkNuMatching [t| forall a. CruType a |])
<span class="lineno">  608 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ctx. CruCtx ctx |])</span></span></span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>instance Liftable (CruCtx ctx) where
<span class="lineno">  611 </span>  <span class="decl"><span class="nottickedoff">mbLift mb_ctx = case mbMatch mb_ctx of</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| CruCtxNil |] -&gt; CruCtxNil</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| CruCtxCons ctx a |] -&gt; CruCtxCons (mbLift ctx) (mbLift a)</span></span>
<span class="lineno">  614 </span>
<span class="lineno">  615 </span>instance Closable (CruCtx ctx) where
<span class="lineno">  616 </span>  <span class="decl"><span class="nottickedoff">toClosed CruCtxNil = $(mkClosed [| CruCtxNil |])</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="nottickedoff">toClosed (CruCtxCons ctx a) =</span>
<span class="lineno">  618 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| CruCtxCons |]) `clApply` toClosed ctx `clApply` toClosed a</span></span>
<span class="lineno">  619 </span>
<span class="lineno">  620 </span>instance TestEquality CruCtx where
<span class="lineno">  621 </span>  <span class="decl"><span class="nottickedoff">testEquality CruCtxNil CruCtxNil = Just Refl</span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="nottickedoff">testEquality (CruCtxCons ctx1 tp1) (CruCtxCons ctx2 tp2)</span>
<span class="lineno">  623 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality ctx1 ctx2</span>
<span class="lineno">  624 </span><span class="spaces">    </span><span class="nottickedoff">, Just Refl &lt;- testEquality tp1 tp2</span>
<span class="lineno">  625 </span><span class="spaces">    </span><span class="nottickedoff">= Just Refl</span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="nottickedoff">testEquality _ _ = Nothing</span></span>
<span class="lineno">  627 </span>
<span class="lineno">  628 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (CruCtx ctx)</span></span> where
<span class="lineno">  629 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.list . helper where</span>
<span class="lineno">  630 </span><span class="spaces">    </span><span class="nottickedoff">helper :: CruCtx ctx' -&gt; [PP.Doc ann]</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="nottickedoff">helper CruCtxNil = []</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="nottickedoff">helper (CruCtxCons ctx tp) = helper ctx ++ [PP.pretty tp]</span></span>
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>instance KnownRepr CruCtx RNil where
<span class="lineno">  635 </span>  <span class="decl"><span class="nottickedoff">knownRepr = CruCtxNil</span></span>
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>instance (KnownRepr CruCtx tps, KnownRepr TypeRepr tp) =&gt;
<span class="lineno">  638 </span>         KnownRepr CruCtx (tps :&gt; tp) where
<span class="lineno">  639 </span>  <span class="decl"><span class="nottickedoff">knownRepr = CruCtxCons knownRepr knownRepr</span></span>
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>-- | Build a 'CruCtx' from a 'CtxRepr'
<span class="lineno">  642 </span>mkCruCtx :: CtxRepr ctx -&gt; CruCtx (CtxToRList ctx)
<span class="lineno">  643 </span><span class="decl"><span class="nottickedoff">mkCruCtx ctx = case viewAssign ctx of</span>
<span class="lineno">  644 </span><span class="spaces">  </span><span class="nottickedoff">AssignEmpty -&gt; CruCtxNil</span>
<span class="lineno">  645 </span><span class="spaces">  </span><span class="nottickedoff">AssignExtend ctx' tp -&gt; CruCtxCons (mkCruCtx ctx') tp</span></span>
<span class="lineno">  646 </span>
<span class="lineno">  647 </span>-- | Convert a 'CruCtx' to a 'CtxRepr'
<span class="lineno">  648 </span>cruCtxToRepr :: CruCtx ctx -&gt; CtxRepr (RListToCtx ctx)
<span class="lineno">  649 </span><span class="decl"><span class="nottickedoff">cruCtxToRepr CruCtxNil = Ctx.empty</span>
<span class="lineno">  650 </span><span class="spaces"></span><span class="nottickedoff">cruCtxToRepr (CruCtxCons ctx tp) = Ctx.extend (cruCtxToRepr ctx) tp</span></span>
<span class="lineno">  651 </span>
<span class="lineno">  652 </span>-- | Build a proof that calling 'cruCtxToRepr' followed by 'mkCruCtx' yields
<span class="lineno">  653 </span>-- equal types
<span class="lineno">  654 </span>cruCtxToReprEq :: CruCtx ctx -&gt; CtxToRList (RListToCtx ctx) :~: ctx
<span class="lineno">  655 </span><span class="decl"><span class="nottickedoff">cruCtxToReprEq CruCtxNil = Refl</span>
<span class="lineno">  656 </span><span class="spaces"></span><span class="nottickedoff">cruCtxToReprEq (CruCtxCons ctx _tp) =</span>
<span class="lineno">  657 </span><span class="spaces">  </span><span class="nottickedoff">case cruCtxToReprEq ctx of</span>
<span class="lineno">  658 </span><span class="spaces">    </span><span class="nottickedoff">Refl -&gt; Refl</span></span>
<span class="lineno">  659 </span>
<span class="lineno">  660 </span>-- | Build a proof that calling 'mkCruCtx' followed by 'cruCtxToRepr' yields
<span class="lineno">  661 </span>-- equal types
<span class="lineno">  662 </span>reprToCruCtxEq :: CtxRepr ctx -&gt; RListToCtx (CtxToRList ctx) :~: ctx
<span class="lineno">  663 </span><span class="decl"><span class="nottickedoff">reprToCruCtxEq (viewAssign -&gt; AssignEmpty) = Refl</span>
<span class="lineno">  664 </span><span class="spaces"></span><span class="nottickedoff">reprToCruCtxEq (viewAssign -&gt; AssignExtend ctx _) =</span>
<span class="lineno">  665 </span><span class="spaces">  </span><span class="nottickedoff">case reprToCruCtxEq ctx of</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="nottickedoff">Refl -&gt; Refl</span></span>
<span class="lineno">  667 </span>
<span class="lineno">  668 </span>-- | Build a proof that converting a Crucible context of contexts to a list of
<span class="lineno">  669 </span>-- lists and back again is the identity
<span class="lineno">  670 </span>reprReprToCruCtxCtxEq :: Assignment CtxRepr ctxs -&gt;
<span class="lineno">  671 </span>                         RListToCtxCtx (CtxCtxToRList ctxs) :~: ctxs
<span class="lineno">  672 </span><span class="decl"><span class="nottickedoff">reprReprToCruCtxCtxEq (viewAssign -&gt; AssignEmpty) = Refl</span>
<span class="lineno">  673 </span><span class="spaces"></span><span class="nottickedoff">reprReprToCruCtxCtxEq (viewAssign -&gt; AssignExtend ctxs ctx)</span>
<span class="lineno">  674 </span><span class="spaces">  </span><span class="nottickedoff">| (Refl, Refl) &lt;- (reprReprToCruCtxCtxEq ctxs, reprToCruCtxEq ctx) = Refl</span></span>
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>-- | Convert a 'CruCtx' to an assignment of 'TypeRepr's
<span class="lineno">  677 </span>--
<span class="lineno">  678 </span>-- FIXME: 'CruCtx' should just be defined as an assignment!
<span class="lineno">  679 </span>cruCtxToTypes :: CruCtx ctx -&gt; RAssign TypeRepr ctx
<span class="lineno">  680 </span><span class="decl"><span class="nottickedoff">cruCtxToTypes CruCtxNil = MNil</span>
<span class="lineno">  681 </span><span class="spaces"></span><span class="nottickedoff">cruCtxToTypes (CruCtxCons tps tp) = cruCtxToTypes tps :&gt;: tp</span></span>
<span class="lineno">  682 </span>
<span class="lineno">  683 </span>-- | Convert an assignment of 'TypeRepr's to a 'CruCtx'
<span class="lineno">  684 </span>--
<span class="lineno">  685 </span>-- FIXME: 'CruCtx' should just be defined as an assignment!
<span class="lineno">  686 </span>cruCtxOfTypes :: RAssign TypeRepr ctx -&gt; CruCtx ctx
<span class="lineno">  687 </span><span class="decl"><span class="nottickedoff">cruCtxOfTypes MNil = CruCtxNil</span>
<span class="lineno">  688 </span><span class="spaces"></span><span class="nottickedoff">cruCtxOfTypes (tps :&gt;: tp) = CruCtxCons (cruCtxOfTypes tps) tp</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (CruCtx ctx)</span></span></span></span> where
<span class="lineno">  691 </span>  <span class="decl"><span class="nottickedoff">show = show . cruCtxToRepr</span></span>
<span class="lineno">  692 </span>
<span class="lineno">  693 </span>-- | The empty context
<span class="lineno">  694 </span>emptyCruCtx :: CruCtx RNil
<span class="lineno">  695 </span><span class="decl"><span class="nottickedoff">emptyCruCtx = CruCtxNil</span></span>
<span class="lineno">  696 </span>
<span class="lineno">  697 </span>-- | Build a singleton crucible context
<span class="lineno">  698 </span>singletonCruCtx :: TypeRepr tp -&gt; CruCtx (RNil :&gt; tp)
<span class="lineno">  699 </span><span class="decl"><span class="nottickedoff">singletonCruCtx tp = CruCtxCons CruCtxNil tp</span></span>
<span class="lineno">  700 </span>
<span class="lineno">  701 </span>-- | Add an element to the end of a context
<span class="lineno">  702 </span>extCruCtx :: KnownRepr TypeRepr a =&gt; CruCtx ctx -&gt; CruCtx (ctx :&gt; a)
<span class="lineno">  703 </span><span class="decl"><span class="nottickedoff">extCruCtx ctx = CruCtxCons ctx knownRepr</span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>-- | Remove an element from the end of a context
<span class="lineno">  706 </span>unextCruCtx :: CruCtx (ctx :&gt; a) -&gt; CruCtx ctx
<span class="lineno">  707 </span><span class="decl"><span class="nottickedoff">unextCruCtx (CruCtxCons ctx _) = ctx</span></span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>-- | Append two contexts
<span class="lineno">  710 </span>appendCruCtx :: CruCtx ctx1 -&gt; CruCtx ctx2 -&gt; CruCtx (ctx1 :++: ctx2)
<span class="lineno">  711 </span><span class="decl"><span class="nottickedoff">appendCruCtx ctx1 CruCtxNil = ctx1</span>
<span class="lineno">  712 </span><span class="spaces"></span><span class="nottickedoff">appendCruCtx ctx1 (CruCtxCons ctx2 tp) = CruCtxCons (appendCruCtx ctx1 ctx2) tp</span></span>
<span class="lineno">  713 </span>
<span class="lineno">  714 </span>-- | Split a context in two
<span class="lineno">  715 </span>splitCruCtx :: prx1 ctx1 -&gt; RAssign prx2 ctx2 -&gt; CruCtx (ctx1 :++: ctx2) -&gt;
<span class="lineno">  716 </span>               (CruCtx ctx1, CruCtx ctx2)
<span class="lineno">  717 </span><span class="decl"><span class="nottickedoff">splitCruCtx _ MNil cru_ctx = (cru_ctx, CruCtxNil)</span>
<span class="lineno">  718 </span><span class="spaces"></span><span class="nottickedoff">splitCruCtx ctx1 (ctx2 :&gt;: _) (CruCtxCons cru_ctx tp) =</span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="nottickedoff">let (cru_ctx1, cru_ctx2) = splitCruCtx ctx1 ctx2 cru_ctx in</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="nottickedoff">(cru_ctx1, CruCtxCons cru_ctx2 tp)</span></span>
<span class="lineno">  721 </span>
<span class="lineno">  722 </span>-- | Build a 'RAssign' phantom argument from a context of Crucible types
<span class="lineno">  723 </span>cruCtxProxies :: CruCtx ctx -&gt; RAssign Proxy ctx
<span class="lineno">  724 </span><span class="decl"><span class="nottickedoff">cruCtxProxies CruCtxNil = MNil</span>
<span class="lineno">  725 </span><span class="spaces"></span><span class="nottickedoff">cruCtxProxies (CruCtxCons ctx _) = cruCtxProxies ctx :&gt;: Proxy</span></span>
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>-- | Compute the length of a 'CruCtx'
<span class="lineno">  728 </span>cruCtxLen :: CruCtx ctx -&gt; Int
<span class="lineno">  729 </span><span class="decl"><span class="nottickedoff">cruCtxLen CruCtxNil = 0</span>
<span class="lineno">  730 </span><span class="spaces"></span><span class="nottickedoff">cruCtxLen (CruCtxCons ctx _) = 1 + cruCtxLen ctx</span></span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>-- | Look up a type in a 'CruCtx'
<span class="lineno">  733 </span>cruCtxLookup :: CruCtx ctx -&gt; Member ctx a -&gt; TypeRepr a
<span class="lineno">  734 </span><span class="decl"><span class="nottickedoff">cruCtxLookup CruCtxNil m = case m of {}</span>
<span class="lineno">  735 </span><span class="spaces"></span><span class="nottickedoff">cruCtxLookup (CruCtxCons _ tp) Member_Base = tp</span>
<span class="lineno">  736 </span><span class="spaces"></span><span class="nottickedoff">cruCtxLookup (CruCtxCons ctx _) (Member_Step memb) = cruCtxLookup ctx memb</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>-- | Build a 'CruCtx' of the given length.
<span class="lineno">  739 </span>cruCtxReplicate :: NatRepr n -&gt; TypeRepr a -&gt; Some CruCtx
<span class="lineno">  740 </span><span class="decl"><span class="nottickedoff">cruCtxReplicate n tp =</span>
<span class="lineno">  741 </span><span class="spaces">  </span><span class="nottickedoff">case isZeroNat n of</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="nottickedoff">ZeroNat -&gt; Some CruCtxNil</span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="nottickedoff">NonZeroNat</span>
<span class="lineno">  744 </span><span class="spaces">      </span><span class="nottickedoff">| Some ctx &lt;- cruCtxReplicate (predNat n) tp</span>
<span class="lineno">  745 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; Some (CruCtxCons ctx tp)</span></span>
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>-- | A representation of a context of types as a sequence of 'KnownRepr'
<span class="lineno">  748 </span>-- instances
<span class="lineno">  749 </span>--
<span class="lineno">  750 </span>-- FIXME: this can go away when existentials take explicit 'TypeRepr's instead
<span class="lineno">  751 </span>-- of 'KnownRepr TypeRepr' instances, as per issue #79
<span class="lineno">  752 </span>type KnownCruCtx = RAssign (KnownReprObj TypeRepr)
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>-- | Convert a 'KnownCruCtx' to a 'CruCtx'
<span class="lineno">  755 </span>knownCtxToCruCtx :: KnownCruCtx ctx -&gt; CruCtx ctx
<span class="lineno">  756 </span><span class="decl"><span class="nottickedoff">knownCtxToCruCtx MNil = CruCtxNil</span>
<span class="lineno">  757 </span><span class="spaces"></span><span class="nottickedoff">knownCtxToCruCtx (ctx :&gt;: KnownReprObj) =</span>
<span class="lineno">  758 </span><span class="spaces">  </span><span class="nottickedoff">CruCtxCons (knownCtxToCruCtx ctx) knownRepr</span></span>
<span class="lineno">  759 </span>
<span class="lineno">  760 </span>
<span class="lineno">  761 </span>----------------------------------------------------------------------
<span class="lineno">  762 </span>-- * Misc Operations on Crucible Objects
<span class="lineno">  763 </span>----------------------------------------------------------------------
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>-- | Get all the registers used in a Crucible statement
<span class="lineno">  766 </span>stmtInputRegs :: TraverseExt ext =&gt; Stmt ext ctx ctx' -&gt; [Some (Reg ctx)]
<span class="lineno">  767 </span><span class="decl"><span class="nottickedoff">stmtInputRegs (SetReg _ (Core.App app)) = foldMapFC (\r -&gt; [Some r]) app</span>
<span class="lineno">  768 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (ExtendAssign s') = foldMapFC (\r -&gt; [Some r]) s'</span>
<span class="lineno">  769 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (CallHandle _ h _ args) =</span>
<span class="lineno">  770 </span><span class="spaces">  </span><span class="nottickedoff">Some h : foldMapFC (\r -&gt; [Some r]) args</span>
<span class="lineno">  771 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (Print msg) = [Some msg]</span>
<span class="lineno">  772 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (ReadGlobal _) = []</span>
<span class="lineno">  773 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (WriteGlobal _ r) = [Some r]</span>
<span class="lineno">  774 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (FreshConstant _ _) = []</span>
<span class="lineno">  775 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (FreshFloat _ _) = []</span>
<span class="lineno">  776 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (FreshNat _) = []</span>
<span class="lineno">  777 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (NewRefCell _ r) = [Some r]</span>
<span class="lineno">  778 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (NewEmptyRefCell _) = []</span>
<span class="lineno">  779 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (ReadRefCell r) = [Some r]</span>
<span class="lineno">  780 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (WriteRefCell r1 r2) = [Some r1, Some r2]</span>
<span class="lineno">  781 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (DropRefCell r) = [Some r]</span>
<span class="lineno">  782 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (Assert r1 r2) = [Some r1, Some r2]</span>
<span class="lineno">  783 </span><span class="spaces"></span><span class="nottickedoff">stmtInputRegs (Assume r1 r2) = [Some r1, Some r2]</span></span>
<span class="lineno">  784 </span>
<span class="lineno">  785 </span>-- | Get all the input and output registers of a Crucible statement
<span class="lineno">  786 </span>stmtOutputRegs :: TraverseExt ext =&gt; Size ctx' -&gt; Stmt ext ctx ctx' -&gt;
<span class="lineno">  787 </span>                  [Some (Reg ctx')]
<span class="lineno">  788 </span><span class="decl"><span class="nottickedoff">stmtOutputRegs sz (SetReg _ (Core.App app)) =</span>
<span class="lineno">  789 </span><span class="spaces">  </span><span class="nottickedoff">foldMapFC (\r -&gt; [Some $ extendReg r]) app ++ [Some $ Reg $ Ctx.lastIndex sz]</span>
<span class="lineno">  790 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs sz (ExtendAssign s') =</span>
<span class="lineno">  791 </span><span class="spaces">  </span><span class="nottickedoff">foldMapFC (\r -&gt; [Some $ extendReg r]) s' ++ [Some $ Reg $ Ctx.lastIndex sz]</span>
<span class="lineno">  792 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs sz (CallHandle _ h _ args) =</span>
<span class="lineno">  793 </span><span class="spaces">  </span><span class="nottickedoff">Some (extendReg h) : foldMapFC (\r -&gt; [Some $ extendReg r]) args</span>
<span class="lineno">  794 </span><span class="spaces">  </span><span class="nottickedoff">++ [Some $ Reg $ Ctx.lastIndex sz]</span>
<span class="lineno">  795 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (Print msg) = [Some msg]</span>
<span class="lineno">  796 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (ReadGlobal _) = []</span>
<span class="lineno">  797 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (WriteGlobal _ r) = [Some r]</span>
<span class="lineno">  798 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (FreshConstant _ _) = []</span>
<span class="lineno">  799 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (FreshFloat _ _) = []</span>
<span class="lineno">  800 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (FreshNat _) = []</span>
<span class="lineno">  801 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs sz (NewRefCell _ r) =</span>
<span class="lineno">  802 </span><span class="spaces">  </span><span class="nottickedoff">[Some $ extendReg r] ++ [Some $ Reg $ Ctx.lastIndex sz]</span>
<span class="lineno">  803 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (NewEmptyRefCell _) = []</span>
<span class="lineno">  804 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs sz (ReadRefCell r) =</span>
<span class="lineno">  805 </span><span class="spaces">  </span><span class="nottickedoff">[Some $ extendReg r] ++ [Some $ Reg $ Ctx.lastIndex sz]</span>
<span class="lineno">  806 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (WriteRefCell r1 r2) = [Some r1, Some r2]</span>
<span class="lineno">  807 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (DropRefCell r) = [Some r]</span>
<span class="lineno">  808 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (Assert r1 r2) = [Some r1, Some r2]</span>
<span class="lineno">  809 </span><span class="spaces"></span><span class="nottickedoff">stmtOutputRegs _ (Assume r1 r2) = [Some r1, Some r2]</span></span>
<span class="lineno">  810 </span>
<span class="lineno">  811 </span>-- | Get all the registers used in a Crucible 'JumpTarget'
<span class="lineno">  812 </span>jumpTargetRegs :: JumpTarget blocks ctx -&gt; [Some (Reg ctx)]
<span class="lineno">  813 </span><span class="decl"><span class="nottickedoff">jumpTargetRegs (JumpTarget _ _ regs) = foldMapFC (\r -&gt; [Some r]) regs</span></span>
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>-- | Get all the registers used in a Crucible 'SwitchTarget'
<span class="lineno">  816 </span>switchTargetRegs :: SwitchTarget blocks ctx tp -&gt; [Some (Reg ctx)]
<span class="lineno">  817 </span><span class="decl"><span class="nottickedoff">switchTargetRegs (SwitchTarget _ _ regs) = foldMapFC (\r -&gt; [Some r]) regs</span></span>
<span class="lineno">  818 </span>
<span class="lineno">  819 </span>-- | Get all the registers used in a Crucible termination statement
<span class="lineno">  820 </span>termStmtRegs :: TermStmt blocks ret ctx -&gt; [Some (Reg ctx)]
<span class="lineno">  821 </span><span class="decl"><span class="nottickedoff">termStmtRegs (Jump tgt) = jumpTargetRegs tgt</span>
<span class="lineno">  822 </span><span class="spaces"></span><span class="nottickedoff">termStmtRegs (Br cond tgt1 tgt2) =</span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="nottickedoff">Some cond : jumpTargetRegs tgt1 ++ jumpTargetRegs tgt2</span>
<span class="lineno">  824 </span><span class="spaces"></span><span class="nottickedoff">termStmtRegs (MaybeBranch _ cond stgt tgt) =</span>
<span class="lineno">  825 </span><span class="spaces">  </span><span class="nottickedoff">Some cond : switchTargetRegs stgt ++ jumpTargetRegs tgt</span>
<span class="lineno">  826 </span><span class="spaces"></span><span class="nottickedoff">termStmtRegs (VariantElim _ cond stgts) =</span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="nottickedoff">Some cond : foldMapFC switchTargetRegs stgts</span>
<span class="lineno">  828 </span><span class="spaces"></span><span class="nottickedoff">termStmtRegs (Return reg) = [Some reg]</span>
<span class="lineno">  829 </span><span class="spaces"></span><span class="nottickedoff">termStmtRegs (TailCall reg _ regs) =</span>
<span class="lineno">  830 </span><span class="spaces">  </span><span class="nottickedoff">Some reg : foldMapFC (\r -&gt; [Some r]) regs</span>
<span class="lineno">  831 </span><span class="spaces"></span><span class="nottickedoff">termStmtRegs (ErrorStmt reg) = [Some reg]</span></span>
<span class="lineno">  832 </span>
<span class="lineno">  833 </span>{-
<span class="lineno">  834 </span>Note [QuantifiedConstraints + TypeFamilies trick]
<span class="lineno">  835 </span>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineno">  836 </span>GHC 9.2 and later are reasonably adept and combining TypeFamilies with type
<span class="lineno">  837 </span>classes that have quantified superclasses. This is important, as there are
<span class="lineno">  838 </span>several places in heapster that require constraints of the form
<span class="lineno">  839 </span>`NuMatchingAny1 (ExprExtension ext f)`, where NuMatchingAny1 has a quantified
<span class="lineno">  840 </span>superclass and ExprExtension is a type family.
<span class="lineno">  841 </span>
<span class="lineno">  842 </span>Unfortunately, GHC 9.0 and earlier suffer from a bug where constraints of the
<span class="lineno">  843 </span>form `NuMatchingAny1 (ExprExtension ext f)`. See
<span class="lineno">  844 </span>https://gitlab.haskell.org/ghc/ghc/-/issues/14860. Thankfully, it is relatively
<span class="lineno">  845 </span>straightforward to work around the bug. Instead of writing instances like
<span class="lineno">  846 </span>these:
<span class="lineno">  847 </span>
<span class="lineno">  848 </span>  instance forall ext f.
<span class="lineno">  849 </span>           NuMatchingAny1 (ExprExtension ext f) =&gt;
<span class="lineno">  850 </span>           NuMatchingAny (Foo ext f tp)
<span class="lineno">  851 </span>
<span class="lineno">  852 </span>We instead write instances like these, introducing an intermediate `exprExt`
<span class="lineno">  853 </span>type variable that is used in conjunction with an equality constraint:
<span class="lineno">  854 </span>
<span class="lineno">  855 </span>  instance forall ext f exprExt.
<span class="lineno">  856 </span>           (exprExt ~ ExprExtension ext f, NuMatchingAny1 exprExt) =&gt;
<span class="lineno">  857 </span>           NuMatchingAny (Foo ext f tp)
<span class="lineno">  858 </span>
<span class="lineno">  859 </span>A bit tedious, but this version actually works on pre-9.2 GHCs, which is nice.
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>I have guarded each use of this trick with CPP so that we remember to remove
<span class="lineno">  862 </span>this workaround when we drop support for pre-9.2 GHCs.
<span class="lineno">  863 </span>-}

</pre>
</body>
</html>
