<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Crucible.LLVM.Setup.Value
<span class="lineno">    3 </span>Description : Data types and type family instances for LLVM-specific code
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : Ryan Scott &lt;rscott@galois.com&gt;
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>The module exists separately from &quot;SAWCentral.Crucible.LLVM.MethodSpecIR&quot;
<span class="lineno">    9 </span>primarily to avoid import cycles. You probably want to import
<span class="lineno">   10 </span>&quot;SAWCentral.Crucible.LLVM.MethodSpecIR&quot; (which re-exports everything from this
<span class="lineno">   11 </span>module, plus additional functionality) instead.
<span class="lineno">   12 </span>-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   15 </span>{-# LANGUAGE DeriveFunctor #-}
<span class="lineno">   16 </span>{-# LANGUAGE DoAndIfThenElse #-}
<span class="lineno">   17 </span>{-# LANGUAGE EmptyDataDecls #-}
<span class="lineno">   18 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   19 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   20 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   21 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   22 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   23 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   24 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">   25 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   26 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">   27 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">   28 </span>{-# LANGUAGE Rank2Types #-}
<span class="lineno">   29 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   30 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   31 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   32 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   33 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   34 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>module SAWCentral.Crucible.LLVM.Setup.Value
<span class="lineno">   37 </span>  ( LLVM
<span class="lineno">   38 </span>    -- * LLVMMethodId
<span class="lineno">   39 </span>  , LLVMMethodId(..)
<span class="lineno">   40 </span>  , llvmMethodParent
<span class="lineno">   41 </span>  , llvmMethodName
<span class="lineno">   42 </span>  , ppLLVMMethodId
<span class="lineno">   43 </span>    -- * LLVMAllocSpec
<span class="lineno">   44 </span>  , LLVMAllocSpec(..)
<span class="lineno">   45 </span>  , LLVMAllocSpecInit(..)
<span class="lineno">   46 </span>  , allocSpecType
<span class="lineno">   47 </span>  , allocSpecAlign
<span class="lineno">   48 </span>  , allocSpecMut
<span class="lineno">   49 </span>  , allocSpecMd
<span class="lineno">   50 </span>  , allocSpecBytes
<span class="lineno">   51 </span>  , allocSpecFresh
<span class="lineno">   52 </span>  , allocSpecInit
<span class="lineno">   53 </span>    -- * LLVMModule
<span class="lineno">   54 </span>  , LLVMModule -- abstract
<span class="lineno">   55 </span>  , modFilePath
<span class="lineno">   56 </span>  , modAST
<span class="lineno">   57 </span>  , modTrans
<span class="lineno">   58 </span>  , loadLLVMModule
<span class="lineno">   59 </span>  , showLLVMModule
<span class="lineno">   60 </span>    -- * CrucibleContext
<span class="lineno">   61 </span>  , LLVMCrucibleContext(..)
<span class="lineno">   62 </span>  , ccLLVMSimContext
<span class="lineno">   63 </span>  , ccLLVMModule
<span class="lineno">   64 </span>  , ccLLVMGlobals
<span class="lineno">   65 </span>  , ccBasicSS
<span class="lineno">   66 </span>  , ccBackend
<span class="lineno">   67 </span>    -- * PointsTo
<span class="lineno">   68 </span>  , LLVMPointsTo(..)
<span class="lineno">   69 </span>  , LLVMPointsToValue(..)
<span class="lineno">   70 </span>    -- * AllocGlobal
<span class="lineno">   71 </span>  , LLVMAllocGlobal(..)
<span class="lineno">   72 </span>  , ppAllocGlobal
<span class="lineno">   73 </span>    -- * ResolvedState
<span class="lineno">   74 </span>  , LLVMResolvedState(..)
<span class="lineno">   75 </span>  , ResolvedPath
<span class="lineno">   76 </span>  , ResolvedPathItem(..)
<span class="lineno">   77 </span>  , emptyResolvedState
<span class="lineno">   78 </span>  , rsAllocs
<span class="lineno">   79 </span>  , rsGlobals
<span class="lineno">   80 </span>    -- * @LLVMPtr@
<span class="lineno">   81 </span>  , LLVMPtr
<span class="lineno">   82 </span>  ) where
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>import           Control.Lens
<span class="lineno">   85 </span>import           Data.Map ( Map )
<span class="lineno">   86 </span>import qualified Data.Map as Map
<span class="lineno">   87 </span>import           Data.Maybe
<span class="lineno">   88 </span>import           Data.Sequence (Seq)
<span class="lineno">   89 </span>import           Data.Text (Text)
<span class="lineno">   90 </span>import qualified Data.Text as Text
<span class="lineno">   91 </span>import           Data.Type.Equality (TestEquality(..))
<span class="lineno">   92 </span>import           Data.Void (Void)
<span class="lineno">   93 </span>import qualified Prettyprinter as PPL
<span class="lineno">   94 </span>import qualified Text.LLVM.AST as L
<span class="lineno">   95 </span>import qualified Text.LLVM.PP as L
<span class="lineno">   96 </span>import qualified Text.PrettyPrint.HughesPJ as PP
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>import qualified Data.LLVM.BitCode as LLVM
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>import           Data.Parameterized.Some (Some(Some))
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>import           What4.ProgramLoc (ProgramLoc)
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>import qualified Lang.Crucible.FunctionHandle as Crucible (HandleAllocator)
<span class="lineno">  105 </span>import qualified Lang.Crucible.Simulator.ExecutionTree as Crucible (SimContext)
<span class="lineno">  106 </span>import qualified Lang.Crucible.Simulator.GlobalState as Crucible (SymGlobalState)
<span class="lineno">  107 </span>import qualified Lang.Crucible.LLVM.PrettyPrint as Crucible.LLVM
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>import           SAWCentral.Crucible.Common
<span class="lineno">  110 </span>import qualified SAWCentral.Crucible.Common.Setup.Value as Setup
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>import qualified SAWCentral.Crucible.LLVM.CrucibleLLVM as CL
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>import           SAWCentral.Proof (TheoremNonce)
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>import           SAWCore.Rewriter (Simpset)
<span class="lineno">  117 </span>import           SAWCore.SharedTerm
<span class="lineno">  118 </span>import           CryptolSAWCore.TypedTerm
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>--------------------------------------------------------------------------------
<span class="lineno">  121 </span>-- ** Language features
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>data LLVM (arch :: CL.LLVMArch)
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>type instance Setup.XSetupNull (LLVM _) = ()
<span class="lineno">  126 </span>-- 'True' if this is an LLVM packed struct, 'False' otherwise.
<span class="lineno">  127 </span>type instance Setup.XSetupStruct (LLVM _) = Bool
<span class="lineno">  128 </span>type instance Setup.XSetupEnum (LLVM _) = Void
<span class="lineno">  129 </span>type instance Setup.XSetupTuple (LLVM _) = Void
<span class="lineno">  130 </span>type instance Setup.XSetupSlice (LLVM _) = Void
<span class="lineno">  131 </span>type instance Setup.XSetupArray (LLVM _) = ()
<span class="lineno">  132 </span>type instance Setup.XSetupElem (LLVM _) = ()
<span class="lineno">  133 </span>type instance Setup.XSetupField (LLVM _) = ()
<span class="lineno">  134 </span>type instance Setup.XSetupCast (LLVM _) = L.Type
<span class="lineno">  135 </span>type instance Setup.XSetupUnion (LLVM _) = ()
<span class="lineno">  136 </span>type instance Setup.XSetupGlobal (LLVM _) = ()
<span class="lineno">  137 </span>type instance Setup.XSetupGlobalInitializer (LLVM _) = ()
<span class="lineno">  138 </span>type instance Setup.XSetupMux (LLVM _) = Void
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>type instance Setup.TypeName (LLVM arch) = CL.Ident
<span class="lineno">  141 </span>type instance Setup.ExtType (LLVM arch) = CL.MemType
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>--------------------------------------------------------------------------------
<span class="lineno">  144 </span>-- *** LLVMMethodId
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>data LLVMMethodId =
<span class="lineno">  147 </span>  LLVMMethodId
<span class="lineno">  148 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_llvmMethodName</span></span></span>   :: Text
<span class="lineno">  149 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_llvmMethodParent</span></span></span> :: Maybe Text -- ^ Something to do with breakpoints...
<span class="lineno">  150 </span>    } deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  151 </span>
<span class="lineno">  152 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''LLVMMethodId</span></span></span></span></span></span></span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>instance <span class="decl"><span class="nottickedoff">PPL.Pretty LLVMMethodId</span></span> where
<span class="lineno">  155 </span>  <span class="decl"><span class="istickedoff">pretty = PPL.pretty . view llvmMethodName</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>ppLLVMMethodId :: LLVMMethodId -&gt; Text
<span class="lineno">  158 </span><span class="decl"><span class="nottickedoff">ppLLVMMethodId = view llvmMethodName</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>type instance Setup.MethodId (LLVM _) = LLVMMethodId
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>--------------------------------------------------------------------------------
<span class="lineno">  163 </span>-- *** LLVMAllocSpec
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>-- | Allocation initialization policy
<span class="lineno">  166 </span>data LLVMAllocSpecInit
<span class="lineno">  167 </span>  = LLVMAllocSpecSymbolicInitialization
<span class="lineno">  168 </span>    -- ^ allocation is initialized with a fresh symbolic array of bytes
<span class="lineno">  169 </span>  | LLVMAllocSpecNoInitialization
<span class="lineno">  170 </span>    -- ^ allocation not initialized
<span class="lineno">  171 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>data LLVMAllocSpec =
<span class="lineno">  174 </span>  LLVMAllocSpec
<span class="lineno">  175 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allocSpecMut</span></span></span>   :: CL.Mutability
<span class="lineno">  176 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allocSpecType</span></span></span>  :: CL.MemType
<span class="lineno">  177 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allocSpecAlign</span></span></span> :: CL.Alignment
<span class="lineno">  178 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">_allocSpecBytes</span></span></span> :: Term
<span class="lineno">  179 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allocSpecMd</span></span></span>    :: Setup.ConditionMetadata
<span class="lineno">  180 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allocSpecFresh</span></span></span> :: Bool -- ^ Whether declared with @crucible_fresh_pointer@
<span class="lineno">  181 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_allocSpecInit</span></span></span> :: LLVMAllocSpecInit
<span class="lineno">  182 </span>    }
<span class="lineno">  183 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  184 </span>
<span class="lineno">  185 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''LLVMAllocSpec</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>type instance Setup.AllocSpec (LLVM _) = LLVMAllocSpec
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>--------------------------------------------------------------------------------
<span class="lineno">  190 </span>-- *** LLVMModule
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- | An 'LLVMModule' contains an LLVM module that has been parsed from
<span class="lineno">  193 </span>-- a bitcode file and translated to Crucible.
<span class="lineno">  194 </span>data LLVMModule arch =
<span class="lineno">  195 </span>  LLVMModule
<span class="lineno">  196 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_modFilePath</span></span></span> :: FilePath
<span class="lineno">  197 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">_modAST</span></span></span> :: L.Module
<span class="lineno">  198 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">_modTrans</span></span></span> :: CL.ModuleTranslation arch
<span class="lineno">  199 </span>  }
<span class="lineno">  200 </span>-- NOTE: Type 'LLVMModule' is exported as an abstract type, and we
<span class="lineno">  201 </span>-- maintain the invariant that the 'FilePath', 'Module', and
<span class="lineno">  202 </span>-- 'ModuleTranslation' fields are all consistent with each other;
<span class="lineno">  203 </span>-- 'loadLLVMModule' is the only function that is allowed to create
<span class="lineno">  204 </span>-- values of type 'LLVMModule'.
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>-- | The file path that the LLVM module was loaded from.
<span class="lineno">  207 </span>modFilePath :: LLVMModule arch -&gt; FilePath
<span class="lineno">  208 </span><span class="decl"><span class="nottickedoff">modFilePath = _modFilePath</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>-- | The parsed AST of the LLVM module.
<span class="lineno">  211 </span>modAST :: LLVMModule arch -&gt; L.Module
<span class="lineno">  212 </span><span class="decl"><span class="istickedoff">modAST = _modAST</span></span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>-- | The Crucible translation of an LLVM module.
<span class="lineno">  215 </span>modTrans :: LLVMModule arch -&gt; CL.ModuleTranslation arch
<span class="lineno">  216 </span><span class="decl"><span class="istickedoff">modTrans = _modTrans</span></span>
<span class="lineno">  217 </span>
<span class="lineno">  218 </span>-- | Load an LLVM module from the given bitcode file, then parse and
<span class="lineno">  219 </span>-- translate to Crucible.
<span class="lineno">  220 </span>loadLLVMModule ::
<span class="lineno">  221 </span>  (?transOpts :: CL.TranslationOptions) =&gt;
<span class="lineno">  222 </span>  FilePath -&gt;
<span class="lineno">  223 </span>  Crucible.HandleAllocator -&gt;
<span class="lineno">  224 </span>  IO (Either LLVM.Error (Some LLVMModule, Seq LLVM.ParseWarning))
<span class="lineno">  225 </span><span class="decl"><span class="istickedoff">loadLLVMModule file halloc =</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">do parseResult &lt;- LLVM.parseBitCodeFromFileWithWarnings file</span>
<span class="lineno">  227 </span><span class="spaces">     </span><span class="istickedoff">case parseResult of</span>
<span class="lineno">  228 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">return (Left err)</span></span>
<span class="lineno">  229 </span><span class="spaces">       </span><span class="istickedoff">Right (llvm_mod, warnings) -&gt;</span>
<span class="lineno">  230 </span><span class="spaces">         </span><span class="istickedoff">do memVar &lt;- CL.mkMemVar (Text.pack &quot;saw:llvm_memory&quot;) <span class="nottickedoff">halloc</span></span>
<span class="lineno">  231 </span><span class="spaces">            </span><span class="istickedoff">Some mtrans &lt;- CL.translateModule <span class="nottickedoff">halloc</span> memVar llvm_mod</span>
<span class="lineno">  232 </span><span class="spaces">            </span><span class="istickedoff">return (Right (Some (LLVMModule <span class="nottickedoff">file</span> llvm_mod mtrans), warnings))</span></span>
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>instance TestEquality LLVMModule where
<span class="lineno">  235 </span>  -- As 'LLVMModule' is an abstract type, we know that the values must
<span class="lineno">  236 </span>  -- have been created by a call to 'loadLLVMModule'. Furthermore each
<span class="lineno">  237 </span>  -- call to 'translateModule' generates a 'ModuleTranslation' that
<span class="lineno">  238 </span>  -- contains a fresh nonce; thus comparison of the 'modTrans' fields
<span class="lineno">  239 </span>  -- is sufficient to guarantee equality of two 'LLVMModule' values.
<span class="lineno">  240 </span>  <span class="decl"><span class="istickedoff">testEquality m1 m2 = testEquality (modTrans m1) (modTrans m2)</span></span>
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>type instance Setup.Codebase (LLVM arch) = LLVMModule arch
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>showLLVMModule :: LLVMModule arch -&gt; String
<span class="lineno">  245 </span><span class="decl"><span class="nottickedoff">showLLVMModule (LLVMModule name m _) =</span>
<span class="lineno">  246 </span><span class="spaces">  </span><span class="nottickedoff">unlines [ &quot;Module: &quot; ++ name</span>
<span class="lineno">  247 </span><span class="spaces">          </span><span class="nottickedoff">, &quot;Types:&quot;</span>
<span class="lineno">  248 </span><span class="spaces">          </span><span class="nottickedoff">, showParts (Crucible.LLVM.ppLLVMLatest L.ppTypeDecl) (L.modTypes m)</span>
<span class="lineno">  249 </span><span class="spaces">          </span><span class="nottickedoff">, &quot;Globals:&quot;</span>
<span class="lineno">  250 </span><span class="spaces">          </span><span class="nottickedoff">, showParts (Crucible.LLVM.ppLLVMLatest ppGlobal') (L.modGlobals m)</span>
<span class="lineno">  251 </span><span class="spaces">          </span><span class="nottickedoff">, &quot;External references:&quot;</span>
<span class="lineno">  252 </span><span class="spaces">          </span><span class="nottickedoff">, showParts Crucible.LLVM.ppDeclare (L.modDeclares m)</span>
<span class="lineno">  253 </span><span class="spaces">          </span><span class="nottickedoff">, &quot;Definitions:&quot;</span>
<span class="lineno">  254 </span><span class="spaces">          </span><span class="nottickedoff">, showParts (Crucible.LLVM.ppLLVMLatest ppDefine') (L.modDefines m)</span>
<span class="lineno">  255 </span><span class="spaces">          </span><span class="nottickedoff">]</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="nottickedoff">showParts pp xs = unlines $ map (show . PP.nest 2 . pp) xs</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="nottickedoff">ppGlobal' g =</span>
<span class="lineno">  259 </span><span class="spaces">      </span><span class="nottickedoff">L.ppSymbol (L.globalSym g) PP.&lt;+&gt; PP.char '=' PP.&lt;+&gt;</span>
<span class="lineno">  260 </span><span class="spaces">      </span><span class="nottickedoff">L.ppGlobalAttrs (isJust $ L.globalValue g) (L.globalAttrs g) PP.&lt;+&gt;</span>
<span class="lineno">  261 </span><span class="spaces">      </span><span class="nottickedoff">L.ppType (L.globalType g)</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="nottickedoff">ppDefine' d =</span>
<span class="lineno">  263 </span><span class="spaces">      </span><span class="nottickedoff">L.ppMaybe L.ppLinkage (L.defLinkage d) PP.&lt;+&gt;</span>
<span class="lineno">  264 </span><span class="spaces">      </span><span class="nottickedoff">L.ppType (L.defRetType d) PP.&lt;+&gt;</span>
<span class="lineno">  265 </span><span class="spaces">      </span><span class="nottickedoff">L.ppSymbol (L.defName d) PP.&lt;&gt;</span>
<span class="lineno">  266 </span><span class="spaces">      </span><span class="nottickedoff">L.ppArgList (L.defVarArgs d) (map (L.ppTyped L.ppIdent) (L.defArgs d)) PP.&lt;+&gt;</span>
<span class="lineno">  267 </span><span class="spaces">      </span><span class="nottickedoff">L.ppMaybe (\gc -&gt; PP.text &quot;gc&quot; PP.&lt;+&gt; L.ppGC gc) (L.defGC d)</span></span>
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>--------------------------------------------------------------------------------
<span class="lineno">  270 </span>-- ** CrucibleContext
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>type instance Setup.CrucibleContext (LLVM arch) = LLVMCrucibleContext arch
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>data LLVMCrucibleContext arch =
<span class="lineno">  275 </span>  LLVMCrucibleContext
<span class="lineno">  276 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">_ccLLVMModule</span></span></span>      :: LLVMModule arch
<span class="lineno">  277 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ccBackend</span></span></span>         :: SomeOnlineBackend
<span class="lineno">  278 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ccLLVMSimContext</span></span></span>  :: Crucible.SimContext (SAWCruciblePersonality Sym) Sym CL.LLVM
<span class="lineno">  279 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ccLLVMGlobals</span></span></span>     :: Crucible.SymGlobalState Sym
<span class="lineno">  280 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_ccBasicSS</span></span></span>         :: Simpset TheoremNonce
<span class="lineno">  281 </span>  }
<span class="lineno">  282 </span>
<span class="lineno">  283 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''LLVMCrucibleContext</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>--------------------------------------------------------------------------------
<span class="lineno">  286 </span>-- ** PointsTo
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>type instance Setup.PointsTo (LLVM arch) = LLVMPointsTo arch
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>data LLVMPointsTo arch
<span class="lineno">  291 </span>  = LLVMPointsTo Setup.ConditionMetadata (Maybe TypedTerm) (Setup.SetupValue (LLVM arch)) (LLVMPointsToValue arch)
<span class="lineno">  292 </span>    -- | A variant of 'LLVMPointsTo' tailored to the @llvm_points_to_bitfield@
<span class="lineno">  293 </span>    -- command, which doesn't quite fit into the 'LLVMPointsToValue' paradigm.
<span class="lineno">  294 </span>    -- The 'String' represents the name of the field within the bitfield.
<span class="lineno">  295 </span>  | LLVMPointsToBitfield Setup.ConditionMetadata (Setup.SetupValue (LLVM arch)) String (Setup.SetupValue (LLVM arch))
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>data LLVMPointsToValue arch
<span class="lineno">  298 </span>  = ConcreteSizeValue (Setup.SetupValue (LLVM arch))
<span class="lineno">  299 </span>  | SymbolicSizeValue TypedTerm TypedTerm
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>--------------------------------------------------------------------------------
<span class="lineno">  302 </span>-- ** AllocGlobal
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>type instance Setup.AllocGlobal (LLVM arch) = LLVMAllocGlobal arch
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>data LLVMAllocGlobal arch = LLVMAllocGlobal ProgramLoc L.Symbol
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>ppAllocGlobal :: LLVMAllocGlobal arch -&gt; PPL.Doc ann
<span class="lineno">  309 </span><span class="decl"><span class="nottickedoff">ppAllocGlobal (LLVMAllocGlobal _loc (L.Symbol name)) =</span>
<span class="lineno">  310 </span><span class="spaces">  </span><span class="nottickedoff">PPL.pretty &quot;allocate global&quot;</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="nottickedoff">PPL.&lt;+&gt; PPL.pretty name</span></span>
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>instance <span class="decl"><span class="nottickedoff">PPL.Pretty (LLVMAllocGlobal arch)</span></span> where
<span class="lineno">  314 </span>  <span class="decl"><span class="nottickedoff">pretty = ppAllocGlobal</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>--------------------------------------------------------------------------------
<span class="lineno">  317 </span>-- *** ResolvedState
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>type instance Setup.ResolvedState (LLVM arch) = LLVMResolvedState
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>data ResolvedPathItem
<span class="lineno">  322 </span>  = ResolvedField Text
<span class="lineno">  323 </span>  | ResolvedElem Int
<span class="lineno">  324 </span>  | ResolvedCast L.Type
<span class="lineno">  325 </span> deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>type ResolvedPath = [ResolvedPathItem]
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>-- | A datatype to keep track of which parts of the simulator state
<span class="lineno">  330 </span>-- have been initialized already. For each allocation unit or global,
<span class="lineno">  331 </span>-- we keep a list of element-paths that identify the initialized
<span class="lineno">  332 </span>-- sub-components.
<span class="lineno">  333 </span>--
<span class="lineno">  334 </span>-- Note that the data collected and maintained by this datatype
<span class="lineno">  335 </span>-- represents a \&quot;best-effort\&quot; check that attempts to prevent
<span class="lineno">  336 </span>-- the user from stating unsatisfiable method specifications.
<span class="lineno">  337 </span>--
<span class="lineno">  338 </span>-- It will not prevent all cases of overlapping points-to
<span class="lineno">  339 </span>-- specifications, especially in the presence of pointer casts.
<span class="lineno">  340 </span>-- A typical result of overlapping specifications will be
<span class="lineno">  341 </span>-- successful (vacuous) verifications of functions resulting in
<span class="lineno">  342 </span>-- overrides that cannot be used at call sites (as their
<span class="lineno">  343 </span>-- preconditions are unsatisfiable).
<span class="lineno">  344 </span>data LLVMResolvedState =
<span class="lineno">  345 </span>  ResolvedState
<span class="lineno">  346 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">_rsAllocs</span></span></span> :: Map Setup.AllocIndex [ResolvedPath]
<span class="lineno">  347 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">_rsGlobals</span></span></span> :: Map Text [ResolvedPath]
<span class="lineno">  348 </span>    }
<span class="lineno">  349 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>emptyResolvedState :: LLVMResolvedState
<span class="lineno">  352 </span><span class="decl"><span class="istickedoff">emptyResolvedState = ResolvedState Map.empty Map.empty</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''LLVMResolvedState</span></span></span></span></span></span></span>
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>--------------------------------------------------------------------------------
<span class="lineno">  357 </span>-- *** Pointers
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>type instance Setup.Pointer' (LLVM arch) Sym = LLVMPtr (CL.ArchWidth arch)
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>type LLVMPtr wptr = CL.LLVMPtr Sym wptr

</pre>
</body>
</html>
