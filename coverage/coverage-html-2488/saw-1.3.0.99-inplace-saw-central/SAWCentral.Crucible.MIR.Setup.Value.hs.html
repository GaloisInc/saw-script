<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Crucible.MIR.Setup.Value
<span class="lineno">    3 </span>Description : Data types and type family instances for MIR-specific code
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : Ryan Scott &lt;rscott@galois.com&gt;
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>The module exists separately from &quot;SAWCentral.Crucible.MIR.MethodSpecIR&quot;
<span class="lineno">    9 </span>primarily to avoid import cycles. You probably want to import
<span class="lineno">   10 </span>&quot;SAWCentral.Crucible.MIR.MethodSpecIR&quot; (which re-exports everything from this
<span class="lineno">   11 </span>module, plus additional functionality) instead.
<span class="lineno">   12 </span>-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>{-# Language DataKinds #-}
<span class="lineno">   15 </span>{-# Language GADTs #-}
<span class="lineno">   16 </span>{-# Language OverloadedStrings #-}
<span class="lineno">   17 </span>{-# Language RankNTypes #-}
<span class="lineno">   18 </span>{-# Language StandaloneDeriving #-}
<span class="lineno">   19 </span>{-# Language TemplateHaskell #-}
<span class="lineno">   20 </span>{-# Language TypeFamilies #-}
<span class="lineno">   21 </span>{-# Language TypeOperators #-}
<span class="lineno">   22 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>module SAWCentral.Crucible.MIR.Setup.Value
<span class="lineno">   25 </span>  ( -- * @MIRCrucibleContext@
<span class="lineno">   26 </span>    MIRCrucibleContext(..)
<span class="lineno">   27 </span>  , mccRustModule
<span class="lineno">   28 </span>  , mccBackend
<span class="lineno">   29 </span>  , mccSimContext
<span class="lineno">   30 </span>  , mccSymGlobalState
<span class="lineno">   31 </span>  , mccStaticInitializerMap
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>    -- * @MirStaticInitializerMap@
<span class="lineno">   34 </span>  , MirStaticInitializerMap
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>    -- * @MirPointsTo@
<span class="lineno">   37 </span>  , MirPointsTo(..)
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>    -- * @MirAllocSpec@
<span class="lineno">   40 </span>  , MirAllocSpec(..)
<span class="lineno">   41 </span>  , maConditionMetadata
<span class="lineno">   42 </span>  , maType
<span class="lineno">   43 </span>  , maPtrKind
<span class="lineno">   44 </span>  , maMutbl
<span class="lineno">   45 </span>  , maMirType
<span class="lineno">   46 </span>  , maLen
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>    -- * @MirPointer@
<span class="lineno">   49 </span>  , MirPointer(..)
<span class="lineno">   50 </span>  , mpType
<span class="lineno">   51 </span>  , mpKind
<span class="lineno">   52 </span>  , mpMutbl
<span class="lineno">   53 </span>  , mpMirType
<span class="lineno">   54 </span>  , mpRef
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>    -- * @MirPointerKind@
<span class="lineno">   57 </span>  , MirPointerKind(..)
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>    -- * @MirSetupEnum@
<span class="lineno">   60 </span>  , MirSetupEnum(..)
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>    -- * @MirSetupSlice@
<span class="lineno">   63 </span>  , MirSetupSlice(..)
<span class="lineno">   64 </span>  , MirSliceInfo(..)
<span class="lineno">   65 </span>  ) where
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>import Control.Lens (makeLenses)
<span class="lineno">   68 </span>import Data.Parameterized.Classes
<span class="lineno">   69 </span>import Data.Parameterized.Map (MapF)
<span class="lineno">   70 </span>import Data.Parameterized.Some
<span class="lineno">   71 </span>import Data.Text (Text)
<span class="lineno">   72 </span>import Data.Void (Void)
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>import Lang.Crucible.Simulator (GlobalVar, RegValue', SimContext, SymGlobalState)
<span class="lineno">   75 </span>import Lang.Crucible.Types
<span class="lineno">   76 </span>import Mir.DefId
<span class="lineno">   77 </span>import Mir.Generator
<span class="lineno">   78 </span>import Mir.Intrinsics
<span class="lineno">   79 </span>import qualified Mir.Mir as M
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>import           SAWCentral.Crucible.Common
<span class="lineno">   82 </span>import qualified SAWCentral.Crucible.Common.Setup.Value as MS
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>type instance MS.XSetupNull MIR = Void
<span class="lineno">   85 </span>type instance MS.XSetupGlobal MIR = ()
<span class="lineno">   86 </span>type instance MS.XSetupStruct MIR = M.Adt
<span class="lineno">   87 </span>type instance MS.XSetupEnum MIR = MirSetupEnum
<span class="lineno">   88 </span>type instance MS.XSetupTuple MIR = ()
<span class="lineno">   89 </span>type instance MS.XSetupSlice MIR = MirSetupSlice
<span class="lineno">   90 </span>-- The 'M.Ty' represents the type of array elements.
<span class="lineno">   91 </span>type instance MS.XSetupArray MIR = M.Ty
<span class="lineno">   92 </span>type instance MS.XSetupElem MIR = ()
<span class="lineno">   93 </span>type instance MS.XSetupField MIR = ()
<span class="lineno">   94 </span>-- The 'M.Ty' represents the pointee type after the cast.
<span class="lineno">   95 </span>-- See Note [Raw pointer casts].
<span class="lineno">   96 </span>type instance MS.XSetupCast MIR = M.Ty
<span class="lineno">   97 </span>type instance MS.XSetupUnion MIR = Void
<span class="lineno">   98 </span>type instance MS.XSetupGlobalInitializer MIR = ()
<span class="lineno">   99 </span>type instance MS.XSetupMux MIR = ()
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>type instance MS.TypeName MIR = Text
<span class="lineno">  102 </span>type instance MS.ExtType MIR = M.Ty
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>type instance MS.MethodId MIR = DefId
<span class="lineno">  105 </span>type instance MS.AllocSpec MIR = Some MirAllocSpec
<span class="lineno">  106 </span>type instance MS.PointsTo MIR = MirPointsTo
<span class="lineno">  107 </span>type instance MS.ResolvedState MIR = ()
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>type instance MS.Codebase MIR = CollectionState
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>data MIRCrucibleContext =
<span class="lineno">  112 </span>  MIRCrucibleContext
<span class="lineno">  113 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccRustModule</span></span></span>           :: RustModule
<span class="lineno">  114 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">_mccBackend</span></span></span>              :: SomeOnlineBackend
<span class="lineno">  115 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccSimContext</span></span></span>           :: SimContext (SAWCruciblePersonality Sym) Sym MIR
<span class="lineno">  116 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccSymGlobalState</span></span></span>       :: SymGlobalState Sym
<span class="lineno">  117 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccStaticInitializerMap</span></span></span> :: MirStaticInitializerMap
<span class="lineno">  118 </span>  }
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>type instance MS.CrucibleContext MIR = MIRCrucibleContext
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>type instance MS.Pointer' MIR sym = Some (MirPointer sym)
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- | A 'MirStaticInitializerMap' maps the 'GlobalVar's of each top-level static
<span class="lineno">  125 </span>-- value in a 'Mir.RustModule' to its initializer value (post-Crucible
<span class="lineno">  126 </span>-- translation). See @Note [Translating MIR statics in SAW]@ in
<span class="lineno">  127 </span>-- &quot;SAWCentral.Crucible.MIR.Builtins&quot; for more details on how this map is
<span class="lineno">  128 </span>-- created.
<span class="lineno">  129 </span>type MirStaticInitializerMap = MapF GlobalVar (RegValue' Sym)
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>-- | Unlike @LLVMPointsTo@ and @JVMPointsTo@, 'MirPointsTo' contains a /list/ of
<span class="lineno">  132 </span>-- 'MS.SetupValue's on the right-hand side. This is due to how slices are
<span class="lineno">  133 </span>-- represented in @crucible-mir-comp@, which stores the list of values
<span class="lineno">  134 </span>-- referenced by the slice. The @mir_points_to@ command, on the other hand,
<span class="lineno">  135 </span>-- always creates 'MirPointsTo' values with exactly one value in the list (see
<span class="lineno">  136 </span>-- the @firstPointsToReferent@ function in &quot;SAWCentral.Crucible.MIR.Override&quot;).
<span class="lineno">  137 </span>data MirPointsTo = MirPointsTo MS.ConditionMetadata (MS.SetupValue MIR) [MS.SetupValue MIR]
<span class="lineno">  138 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>data MirAllocSpec tp = MirAllocSpec
<span class="lineno">  141 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maConditionMetadata</span></span></span> :: MS.ConditionMetadata
<span class="lineno">  142 </span>    -- | TypeRepr of the /pointee/ type
<span class="lineno">  143 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maType</span></span></span> :: TypeRepr tp
<span class="lineno">  144 </span>    -- | Which kind of /pointer/
<span class="lineno">  145 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maPtrKind</span></span></span> :: MirPointerKind 
<span class="lineno">  146 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maMutbl</span></span></span> :: M.Mutability
<span class="lineno">  147 </span>    -- | MIR Ty of the /pointee/ type
<span class="lineno">  148 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maMirType</span></span></span> :: M.Ty
<span class="lineno">  149 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maLen</span></span></span> :: Int
<span class="lineno">  150 </span>    }
<span class="lineno">  151 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF MirAllocSpec</span></span></span></span></span></span> where
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>data MirPointer sym tp = MirPointer
<span class="lineno">  156 </span>    { -- | TypeRepr of the /pointee/ type
<span class="lineno">  157 </span>      <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpType</span></span></span> :: TypeRepr tp
<span class="lineno">  158 </span>      -- | Which kind of /pointer/
<span class="lineno">  159 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpKind</span></span></span> :: MirPointerKind
<span class="lineno">  160 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpMutbl</span></span></span> :: M.Mutability
<span class="lineno">  161 </span>      -- | MIR Ty of the /pointee/ type
<span class="lineno">  162 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpMirType</span></span></span> :: M.Ty
<span class="lineno">  163 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpRef</span></span></span> :: MirReferenceMux sym
<span class="lineno">  164 </span>    }
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | The kind of a MIR pointer.
<span class="lineno">  167 </span>data MirPointerKind
<span class="lineno">  168 </span>  = MirPointerRef -- ^ a reference
<span class="lineno">  169 </span>  | MirPointerRaw -- ^ a raw pointer
<span class="lineno">  170 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>-- | A enum-related MIR 'SetupValue'.
<span class="lineno">  173 </span>data MirSetupEnum where
<span class="lineno">  174 </span>  -- | A specific variant of an enum.
<span class="lineno">  175 </span>  MirSetupEnumVariant ::
<span class="lineno">  176 </span>       M.Adt
<span class="lineno">  177 </span>       -- ^ The enum type.
<span class="lineno">  178 </span>    -&gt; M.Variant
<span class="lineno">  179 </span>       -- ^ The variant to use.
<span class="lineno">  180 </span>    -&gt; Int
<span class="lineno">  181 </span>       -- ^ The index of the variant within the list of all the enum's variants.
<span class="lineno">  182 </span>       -- In most circumstances, this index will be the same as the discriminant
<span class="lineno">  183 </span>       -- value, but the index can be different if a variant uses an explicit
<span class="lineno">  184 </span>       -- value. For instance, in this example:
<span class="lineno">  185 </span>       --
<span class="lineno">  186 </span>       -- @
<span class="lineno">  187 </span>       -- enum A {
<span class="lineno">  188 </span>       --     A0,
<span class="lineno">  189 </span>       --     A1,
<span class="lineno">  190 </span>       -- }
<span class="lineno">  191 </span>       --
<span class="lineno">  192 </span>       -- enum B {
<span class="lineno">  193 </span>       --     B0 = 42,
<span class="lineno">  194 </span>       --     B1,
<span class="lineno">  195 </span>       -- }
<span class="lineno">  196 </span>       -- @
<span class="lineno">  197 </span>       --
<span class="lineno">  198 </span>       -- The indexes for @A0@ and @B0@ are both @0@, and the indexes for @A1@
<span class="lineno">  199 </span>       -- and @B1@ are both @1@. The discriminant values are different, however.
<span class="lineno">  200 </span>       -- The discriminants for @A0@ and @A1@ are @0@ and @1@, respectively,
<span class="lineno">  201 </span>       -- while the discriminants for @B0@ and @B1@ are @42@ and @43@,
<span class="lineno">  202 </span>       -- respectively.
<span class="lineno">  203 </span>       --
<span class="lineno">  204 </span>       -- Note that the index is accessible within the 'M.Variant' argument, but
<span class="lineno">  205 </span>       -- retrieving the information is somewhat involved. (See the
<span class="lineno">  206 </span>       -- implementation of @mir_enum_value@.) For this reason, we store this
<span class="lineno">  207 </span>       -- information separately in 'MirSetupEnumVariant' to make it easier to
<span class="lineno">  208 </span>       -- look up later.
<span class="lineno">  209 </span>    -&gt; [MS.SetupValue MIR]
<span class="lineno">  210 </span>       -- ^ The values of the variant's fields.
<span class="lineno">  211 </span>    -&gt; MirSetupEnum
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>  -- | A symbolic enum value, where the 'M.Adt' represents the enum type.
<span class="lineno">  214 </span>  -- This is only used in the implementation of @mir_fresh_expanded_value@.
<span class="lineno">  215 </span>  -- See @Note [Symbolic enums]@ for a more detailed explanation.
<span class="lineno">  216 </span>  --
<span class="lineno">  217 </span>  -- Note that @repr(transparent)@ enums never use 'MirSetupEnumSymbolic'.
<span class="lineno">  218 </span>  -- Instead, they are represented as a 'MirSetupEnumVariant' where the
<span class="lineno">  219 </span>  -- underlying variant field is symbolic. This makes it simpler to ensure that
<span class="lineno">  220 </span>  -- resolving a @repr(transparent@ enum value will yield a 'MIRVal' whose
<span class="lineno">  221 </span>  -- 'TypeShape' is 'TransparentShape'.
<span class="lineno">  222 </span>  MirSetupEnumSymbolic ::
<span class="lineno">  223 </span>       M.Adt
<span class="lineno">  224 </span>       -- ^ The enum type.
<span class="lineno">  225 </span>    -&gt; MS.SetupValue MIR
<span class="lineno">  226 </span>       -- ^ The symbolic discriminant value.
<span class="lineno">  227 </span>    -&gt; [[MS.SetupValue MIR]]
<span class="lineno">  228 </span>       -- ^ The symbolic values that are used for the fields in each variant.
<span class="lineno">  229 </span>       -- For instance, if one created a symbolic value of this type:
<span class="lineno">  230 </span>       --
<span class="lineno">  231 </span>       -- @
<span class="lineno">  232 </span>       -- enum E {
<span class="lineno">  233 </span>       --     E1(u16),
<span class="lineno">  234 </span>       --     E2(u32, u32),
<span class="lineno">  235 </span>       -- @
<span class="lineno">  236 </span>       --
<span class="lineno">  237 </span>       -- Then the list of fields would be @[[x], [y, z]]@, where @x: u16@
<span class="lineno">  238 </span>       -- are the fields of @E1@, and @y: u32@ and @z: u32@ are the fields of
<span class="lineno">  239 </span>       -- @E2@.
<span class="lineno">  240 </span>    -&gt; MirSetupEnum
<span class="lineno">  241 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>-- | A slice-related MIR 'SetupValue'. This is used to power the @mir_slice_*@
<span class="lineno">  244 </span>-- and @mir_str_slice_*@ family of SAWScript functions.
<span class="lineno">  245 </span>data MirSetupSlice
<span class="lineno">  246 </span>  = MirSetupSliceRaw (MS.SetupValue MIR) (MS.SetupValue MIR)
<span class="lineno">  247 </span>    -- ^ A \&quot;raw\&quot; slice constructed directly from a pointer and a length.
<span class="lineno">  248 </span>    -- Currently, this is only used by @crucible-mir-comp@. SAWScript offers no
<span class="lineno">  249 </span>    -- way to use this, although we may consider doing so in the future.
<span class="lineno">  250 </span>  | MirSetupSlice MirSliceInfo (MS.SetupValue MIR)
<span class="lineno">  251 </span>    -- ^ A slice of a reference to a contiguous sequence 'SetupValue'.
<span class="lineno">  252 </span>  | MirSetupSliceRange MirSliceInfo (MS.SetupValue MIR) Int Int
<span class="lineno">  253 </span>    -- ^ A slice of a reference to a contiguous sequence 'SetupValue', where the
<span class="lineno">  254 </span>    -- slice only covers the range specified by the given start and end values
<span class="lineno">  255 </span>    -- (the first and second 'Int', respectively). Currently, this only supports
<span class="lineno">  256 </span>    -- concrete ranges.
<span class="lineno">  257 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>-- | Are we dealing with an array slice (@[T]@) or a string slice (@str@)?
<span class="lineno">  260 </span>data MirSliceInfo
<span class="lineno">  261 </span>  = -- | @[T]@ (for some type @T@)
<span class="lineno">  262 </span>    MirArraySlice
<span class="lineno">  263 </span>  | -- | @str@
<span class="lineno">  264 </span>    MirStrSlice
<span class="lineno">  265 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  266 </span>
<span class="lineno">  267 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''MIRCrucibleContext</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  268 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''MirAllocSpec</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  269 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''MirPointer</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>{-
<span class="lineno">  272 </span>Note [Symbolic enums]
<span class="lineno">  273 </span>~~~~~~~~~~~~~~~~~~~~~
<span class="lineno">  274 </span>Creating a symbolic MIR enum value is not quite as straightforward as creating
<span class="lineno">  275 </span>symbolic versions of other compound types, mostly due to the atypical Crucible
<span class="lineno">  276 </span>representation that enums use. To recap, if we have an enum like this:
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>  enum E {
<span class="lineno">  279 </span>    E1(u16),
<span class="lineno">  280 </span>    E2(u32, u32),
<span class="lineno">  281 </span>  }
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>Then this will be implemented using (roughly) the following Crucible `Type`
<span class="lineno">  284 </span>under the hood:
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>  (BVType 64, VariantType [StructType [BVType 16], StructType [BVType 32, BVType 32]])
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>Where:
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>* The `BVType 64` is a /discriminant/, whose value indicates which variant is
<span class="lineno">  291 </span>  in use. For instance, a discriminant value of `0` indicates that the `E1`
<span class="lineno">  292 </span>  variant is in use, and a discriminant value of `1` indicates that the `E2`
<span class="lineno">  293 </span>  variant is in use.
<span class="lineno">  294 </span>* The `VariantType ...` indicates that there are two variants in this enum,
<span class="lineno">  295 </span>  where each variant is represented as a struct with the corresponding fields
<span class="lineno">  296 </span>  in that variant.
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>At simulation time, VariantTypes are represented as a sequence of
<span class="lineno">  299 </span>VariantBranches, where a VariantBranch is (roughly) a pair of:
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>* A (possibly symbolic) predicate indicating if that variant is being used, and
<span class="lineno">  302 </span>* A payload representing the fields of the enum. If the predicate does not
<span class="lineno">  303 </span>  hold, then the payload will likely be symbolic, since it does not matter what
<span class="lineno">  304 </span>  the payload value is in that case.
<span class="lineno">  305 </span>
<span class="lineno">  306 </span>OK, recap over. Let's get back to the original question: how do we make a
<span class="lineno">  307 </span>symbolic value of this type? A naïve first attempt is to generate fresh
<span class="lineno">  308 </span>symbolic values for everything. That is, a symbolic discriminant, as well as a
<span class="lineno">  309 </span>symbolic predicate and payload for each VariantBranch. While tempting, this
<span class="lineno">  310 </span>approach won't work. To see why, consider what happens when one pattern matches
<span class="lineno">  311 </span>on a symbolic enum value. For example, the `match` expression in this function:
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>  fn foo(x: E) -&gt; u32 {
<span class="lineno">  314 </span>      match x {
<span class="lineno">  315 </span>          E::E1(a) =&gt; bar(y),
<span class="lineno">  316 </span>          E::E2(b, c) =&gt; baz(b, c),
<span class="lineno">  317 </span>      }
<span class="lineno">  318 </span>  }
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>Would turn into the (roughly) following MIR:
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>  fn foo(x : E) -&gt; u32 {
<span class="lineno">  323 </span>      start_block: {
<span class="lineno">  324 </span>          discr = Discriminant(x, isize);
<span class="lineno">  325 </span>          switchint discr :isize [0, 1] -&gt; [e1_block, e2_block, fallthrough_block]
<span class="lineno">  326 </span>      }
<span class="lineno">  327 </span>      e1_block: {
<span class="lineno">  328 </span>          ... call bar() ...
<span class="lineno">  329 </span>      }
<span class="lineno">  330 </span>      e2_block: {
<span class="lineno">  331 </span>          ... call baz() ...
<span class="lineno">  332 </span>      }
<span class="lineno">  333 </span>      fallthrough_block: {
<span class="lineno">  334 </span>          unreachable;
<span class="lineno">  335 </span>      }
<span class="lineno">  336 </span>      ...
<span class="lineno">  337 </span>  }
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>Here, the `switchint discr` statement will check the value of `discr` (the
<span class="lineno">  340 </span>discriminant), and if it equals `0`, go to `e1_block`; if it equals `1`, go to
<span class="lineno">  341 </span>`e2_block`; and if it equals something else, go to `fallthrough_block`. In
<span class="lineno">  342 </span>normal circumstances, `discr` should only ever be equal to `0` or `1`, which
<span class="lineno">  343 </span>implies that `fallthrough_block` should never be accessible (as indicated by
<span class="lineno">  344 </span>its `unreachable` instruction).
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>Now consider what would happen if the discriminant were an unconstrained,
<span class="lineno">  347 </span>symbolic value. While a symbolic discriminant could be equal to `0` or `1`, it
<span class="lineno">  348 </span>could also be equal to any other value! This would spell disaster if Crucible
<span class="lineno">  349 </span>tried to perform a symbolic branch on, say, `discr == 2`, since that would
<span class="lineno">  350 </span>cause execution to reach `fallthrough_block` and crash. We want a symbolic
<span class="lineno">  351 </span>discriminant, but we don't want it to be /that/ symbolic!
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>For this reason, after we create a symbolic discriminant value, we also add a
<span class="lineno">  354 </span>Crucible assumption that the discriminant must be equal to one of the possible
<span class="lineno">  355 </span>enum variants' discriminants. In the example above, this means that we would
<span class="lineno">  356 </span>assume assume the following:
<span class="lineno">  357 </span>
<span class="lineno">  358 </span>  (discr == 0) \/ (discr == 1)
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>This way, symbolic execution will never reach `fallthrough_block`. This
<span class="lineno">  361 </span>Crucible assumption is created in
<span class="lineno">  362 </span>SAWCentral.Crucible.MIR.Builtins.constructExpandedSetupValue.goEnum`.
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>Similarly, we cannot make the VariantBranch predicates completely symbolic, as
<span class="lineno">  365 </span>whether a predicate holds or not depends on the value of the discriminant. For
<span class="lineno">  366 </span>this reason, we do not create fresh variables for each predicate, but instead
<span class="lineno">  367 </span>make each predicate the result of checking the discriminant against particular
<span class="lineno">  368 </span>values. For instance, the predicate for the `E1` VariantBranch is defined to be
<span class="lineno">  369 </span>`discr == 0`, and the predicate for the `E2` VariantBranch is defined to be
<span class="lineno">  370 </span>`discr == 1`. These predicates are defined in
<span class="lineno">  371 </span>`SAWCentral.Crucible.MIR.ResolveSetupValue.resolveSetupValue`, along with the
<span class="lineno">  372 </span>fields in the associated payloads.
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>Lastly, there are the payloads (i.e., the fields of each variant) in each
<span class="lineno">  375 </span>VariantBranch. These are created as completely symbolic values—the trick is to
<span class="lineno">  376 </span>only access the fields when the corresponding predicate holds. For example,
<span class="lineno">  377 </span>`SAWCentral.Crucible.MIR.Override.matchArg` (in the `MirSetupEnumSymbolic` case)
<span class="lineno">  378 </span>must be able to match two possibly symbolic enum values together, but it must
<span class="lineno">  379 </span>be careful to only match the fields in a variant if that VariantBranch's
<span class="lineno">  380 </span>predicate holds.
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>To make this a bit more specific, suppose we have two symbolic enum values
<span class="lineno">  383 </span>`enumA` and `enumA`, where:
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>* `enumA` has the discriminant value `discrA`, and
<span class="lineno">  386 </span>  `enumB` has the discriminant value `discrB`.
<span class="lineno">  387 </span>* `enumA` has the VariantBranches [(e1_pred_a, [e1_fld1_a]), (e2_pred_a, [e2_fld1_a, e2_fld2_a])], and
<span class="lineno">  388 </span>  `enumB` has the VariantBranches [(e1_pred_b, [e1_fld1_b]), (e2_pred_b, [e2_fld1_b, e2_fld2_b])].
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>We only want to match `e1_fld1_a` against `e1_fld1_b` if both enums are using
<span class="lineno">  391 </span>the `E1` variant, that is, if `e1_pred_a` and `e_pred_b` hold. To this end, the
<span class="lineno">  392 </span>`matchArg` function checks this by generating (roughly) the following
<span class="lineno">  393 </span>assertion:
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>  (discrA == discrB) /\
<span class="lineno">  396 </span>  (e1_pred_a ==&gt; (e1_fld1_a == e1_fld1_b))
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>(Note that instead of `e1_pred_a ==&gt; ...`, we could have alternatively used
<span class="lineno">  399 </span>`e1_pred_b ==&gt; ...`, `(discrA == 0) ==&gt; ...`, or `(discrB == 0) ==&gt; ...`. All
<span class="lineno">  400 </span>formulations are equivalent.)
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>Phew! Enums are surprisingly tricky.
<span class="lineno">  403 </span>-}
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>{-
<span class="lineno">  406 </span>Note [Raw pointer casts]
<span class="lineno">  407 </span>~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineno">  408 </span>Rust and crucible-mir allow casting the pointee type of raw pointers to
<span class="lineno">  409 </span>arbitrary types, as long as both the old and new pointer types have the same
<span class="lineno">  410 </span>representation (e.g. the old and new pointee types are both Sized). But when a
<span class="lineno">  411 </span>pointer is used to actually read from or write to some memory, the pointer's
<span class="lineno">  412 </span>pointee type must match the actual type inside the memory allocation. In other
<span class="lineno">  413 </span>words, a pointer to an allocation of type T can be passed around and stored as a
<span class="lineno">  414 </span>pointer to any other type, as long as it is casted back to *T when it is
<span class="lineno">  415 </span>actually used.
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>However, in SAW, this means we need the ability to describe a pointer which
<span class="lineno">  418 </span>points to an allocation of a different type, because this memory layout may
<span class="lineno">  419 </span>appear as the precondition or postcondition of a function, even if no Rust code
<span class="lineno">  420 </span>actually dereferences that pointer without casting it back.
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>We use mir_cast_raw_ptr/SetupCast to handle this mismatch between the static
<span class="lineno">  423 </span>pointee type of the pointer and the type of the allocation it is actually
<span class="lineno">  424 </span>pointing to. Since the purpose of SetupCast is basically to circumvent SAW's
<span class="lineno">  425 </span>SetupValue type system for raw pointers' pointee types, typeOfSetupValue on a
<span class="lineno">  426 </span>SetupCast naturally returns TyRawPtr with the post-cast pointee type. But as a
<span class="lineno">  427 </span>consequence, for raw pointers, the Mir.Ty/TypeShape inside SAW may not always be
<span class="lineno">  428 </span>correct with respect to the actual type inside the Crucible allocation. This is
<span class="lineno">  429 </span>tricky to deal with, so here is some analysis about which types are &quot;right&quot; and
<span class="lineno">  430 </span>&quot;wrong&quot;.
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>Since mir_alloc_raw_ptr returns a SetupVar directly, no cast can happen here,
<span class="lineno">  433 </span>and the MirAllocSpec created by it will always have the same pointee type as was
<span class="lineno">  434 </span>actually given to mir_alloc_raw_ptr. If this mir_alloc_raw_ptr is in the
<span class="lineno">  435 </span>precondition section, then the MirAllocSpec will always have the &quot;right&quot; pointee
<span class="lineno">  436 </span>type, because the Crucible allocation will be created by SAW according to the
<span class="lineno">  437 </span>MirAllocSpec. This happens in doAlloc, which returns a MirPointer containing the
<span class="lineno">  438 </span>Crucible MirReferenceMux, and here the pointee type stored in the MirPointer
<span class="lineno">  439 </span>will also be the &quot;right&quot; one with respect to the MirReferenceMux, because it is
<span class="lineno">  440 </span>obtained from the MirAllocSpec.
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>But if the mir_alloc_raw_ptr is in the postcondition, Crucible is the one that
<span class="lineno">  443 </span>is creating the allocation, as part of symbolic execution. Then at the end of
<span class="lineno">  444 </span>execution, SAW matches on it against the type that it thinks it should be (in
<span class="lineno">  445 </span>matchArg). For instance, if the pointer is the return value, then SAW will match
<span class="lineno">  446 </span>against the return type of the Rust function from the MIR. But if the function
<span class="lineno">  447 </span>is returning a casted pointer, this return type will be &quot;wrong&quot; with respect to
<span class="lineno">  448 </span>the type inside the Crucible reference. matchArg pairs these together in a
<span class="lineno">  449 </span>MirPointer, and we would like to keep the invariant that the MirPointer's
<span class="lineno">  450 </span>pointee type is always &quot;right&quot;. Therefore, if a cast is involved, we don't want
<span class="lineno">  451 </span>to look at the &quot;expected&quot; type given to matchArg. The only other place we might
<span class="lineno">  452 </span>get a type from is the pointee type in the MirAllocSpec, i.e. the type given to
<span class="lineno">  453 </span>mir_alloc_raw_ptr, so we look at that. But since we are in the postcondition, we
<span class="lineno">  454 </span>have no guarantee that that type is &quot;right&quot; either.
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>Fundamentally, pointer casting introduces some level of type unsafety, so we
<span class="lineno">  457 </span>just have to trust the user that the type they mir_alloc'd is the &quot;right&quot; type
<span class="lineno">  458 </span>(unless we want to actually inspect the Crucible MirReferenceMux from SAW, which
<span class="lineno">  459 </span>I'm not sure we want to do, and even then we only get back a Crucible TypeRepr,
<span class="lineno">  460 </span>not a MIR Ty). If there is no mir_points_to for that pointer, that is the best
<span class="lineno">  461 </span>we can do, but that's probably fine, since the pointee type is not that
<span class="lineno">  462 </span>important if the pointee is unspecified. (If the verification result is then
<span class="lineno">  463 </span>used as an override in a function that does use that pointer, the verification
<span class="lineno">  464 </span>of that function will fail.) But if there is a mir_points_to, we can cross-check
<span class="lineno">  465 </span>it with the type of the right hand side of mir_points_to. Since there would be a
<span class="lineno">  466 </span>Crucible error if the mir_points_to RHS is the wrong type (because the
<span class="lineno">  467 </span>Mir.readMirRefIO in learnPointsTo wouldn't find any MirReference with that type
<span class="lineno">  468 </span>in the mux tree), we can assume that if the poststate verification succeeds, the
<span class="lineno">  469 </span>mir_points_to RHS has the &quot;right&quot; type. Finally, it is possible that the user
<span class="lineno">  470 </span>still mir_alloc'd a pointer of the &quot;wrong&quot; type, and used mir_cast_raw_ptr when
<span class="lineno">  471 </span>passing it to mir_points_to. So we must check that mir_points_to does not
<span class="lineno">  472 </span>contain any casts on the left hand side. Once we do that, we know that the type
<span class="lineno">  473 </span>passed to mir_alloc is &quot;right&quot;.
<span class="lineno">  474 </span>
<span class="lineno">  475 </span>On the other hand, we cannot in general guarantee that the pointee type of a
<span class="lineno">  476 </span>pointer in a MIRVal always matches with the Crucible reference in the MIRVal.
<span class="lineno">  477 </span>For instance, a MIRVal is created when SAW receives the return value of a
<span class="lineno">  478 </span>function back from Crucible as a RegValue. That is paired with a TypeShape
<span class="lineno">  479 </span>derived from the declared return type of the Rust function in the MIR. There is
<span class="lineno">  480 </span>no way of telling from the MIR signature that that type might be &quot;wrong&quot; with
<span class="lineno">  481 </span>respect to the actual type of the allocation. So if the function returns a
<span class="lineno">  482 </span>casted pointer, the resulting MIRVal will have mismatched pointee types.
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>In summary:
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>- In a MirPointsTo, the pointee type of the left hand side always matches the
<span class="lineno">  487 </span>  type of the right hand side.
<span class="lineno">  488 </span>
<span class="lineno">  489 </span>- In a MirAllocSpec, the pointee type always matches the type which will be
<span class="lineno">  490 </span>  stored in the MirReferenceMux (except in the case of a postcondition
<span class="lineno">  491 </span>  mir_alloc_raw_ptr with no mir_points_to, in which case we assume that the user
<span class="lineno">  492 </span>  supplied the right type).
<span class="lineno">  493 </span>
<span class="lineno">  494 </span>- In a MirPointer, the pointee type always matches the type stored in the
<span class="lineno">  495 </span>  MirReferenceMux.
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>- In general, the pointee type of a pointer MIRVal does not necessarily match
<span class="lineno">  498 </span>  the type stored in the MirReferenceMux.
<span class="lineno">  499 </span>
<span class="lineno">  500 </span>With these invariants, we can make sure that when we create, read, or write
<span class="lineno">  501 </span>Crucible references from SAW, the TypeRepr's we pass are always &quot;right&quot;.
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>The only place we create references is the call to Mir.newMirRefIO in doAlloc.
<span class="lineno">  504 </span>The TypeRepr we pass is obtained from a MirAllocSpec, which always has the
<span class="lineno">  505 </span>&quot;right&quot; type, so this call is correctly typed.
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>The only place we read references is the call to Mir.readMirRefIO in
<span class="lineno">  508 </span>learnPointsTo. The TypeRepr and MirReferenceMux we pass to it are both derived
<span class="lineno">  509 </span>from the MIRVal returned from calling resolveSetupValueMIR on the left hand side
<span class="lineno">  510 </span>of a mir_points_to. resolveSetupValueMIR calls resolveSetupVal, which creates a
<span class="lineno">  511 </span>MIRVal from a MirPointer. Let's say that a data type containing both a pointee
<span class="lineno">  512 </span>type and a MirReferenceMux is &quot;consistent&quot; if the pointee type matches the type
<span class="lineno">  513 </span>stored in the MirReferenceMux. Since all MirPointer's are consistent, the MIRVal
<span class="lineno">  514 </span>resolved from the SetupVar is consistent too. And since there is no SetupCast on
<span class="lineno">  515 </span>the LHS of any mir_points_to, the MIRVal resolved from the overall LHS
<span class="lineno">  516 </span>SetupValue is also consistent. Hence the Mir.readMirRefIO call is correctly
<span class="lineno">  517 </span>typed.
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>We write to references with Mir.writeMirRefIO in doAlloc and doPointsTo. In
<span class="lineno">  520 </span>doAlloc, the MirReferenceMux we pass is the one we just got from
<span class="lineno">  521 </span>Mir.newMirRefIO, and the TypeRepr we pass is the same one we just passed to
<span class="lineno">  522 </span>Mir.newMirRefIO, so this call is correctly typed. (The CrucibleType type
<span class="lineno">  523 </span>parameter in writeMirRefIO guarantees that the pointee RegValue we are writing
<span class="lineno">  524 </span>always matches the TypeRepr we passed.) In doPointsTo, we obtain the TypeRepr
<span class="lineno">  525 </span>and MirReferenceMux from the MIRVal returned by calling resolveSetupVal on the
<span class="lineno">  526 </span>left hand side of a mir_points_to. By the same reasoning as above, the MIRVal is
<span class="lineno">  527 </span>consistent, so the writeMirRefIO call is correctly typed.
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>All of the above only applies to SAW, not crux-mir-comp, but there's no way of
<span class="lineno">  530 </span>constructing a SetupCast in crux-mir-comp yet, so we don't have to worry about
<span class="lineno">  531 </span>this for now...
<span class="lineno">  532 </span>-}

</pre>
</body>
</html>
