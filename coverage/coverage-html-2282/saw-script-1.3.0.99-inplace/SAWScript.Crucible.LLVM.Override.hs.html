<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Crucible.LLVM.Override
<span class="lineno">    3 </span>Description : Override matching and application for LLVM
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : atomb
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">   10 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   11 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   12 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   13 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   14 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   15 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   16 </span>{-# LANGUAGE MultiWayIf #-}
<span class="lineno">   17 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   18 </span>{-# LANGUAGE ParallelListComp #-}
<span class="lineno">   19 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   20 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   21 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   22 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   23 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   24 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   25 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   26 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   27 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   28 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   29 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>module SAWScript.Crucible.LLVM.Override
<span class="lineno">   32 </span>  ( OverrideMatcher
<span class="lineno">   33 </span>  , OverrideMatcher'(..)
<span class="lineno">   34 </span>  , runOverrideMatcher
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>  , setupValueSub
<span class="lineno">   37 </span>  , executeFreshPointer
<span class="lineno">   38 </span>  , osAsserts
<span class="lineno">   39 </span>  , termSub
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>  , learnCond
<span class="lineno">   42 </span>  , learnSetupCondition
<span class="lineno">   43 </span>  , executeSetupCondition
<span class="lineno">   44 </span>  , matchArg
<span class="lineno">   45 </span>  , matchPointsToValue
<span class="lineno">   46 </span>  , matchPointsToBitfieldValue
<span class="lineno">   47 </span>  , assertTermEqualities
<span class="lineno">   48 </span>  , methodSpecHandler
<span class="lineno">   49 </span>  , valueToSC
<span class="lineno">   50 </span>  , storePointsToValue
<span class="lineno">   51 </span>  , storePointsToBitfieldValue
<span class="lineno">   52 </span>  , doAllocSymInit
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>  , diffMemTypes
<span class="lineno">   55 </span>  , ppPointsToAsLLVMVal
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>  , enableSMTArrayMemoryModel
<span class="lineno">   58 </span>  ) where
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>import           Control.Lens ( _2 )
<span class="lineno">   61 </span>import           Control.Lens.At
<span class="lineno">   62 </span>import           Control.Lens.Each
<span class="lineno">   63 </span>import           Control.Lens.Fold
<span class="lineno">   64 </span>import           Control.Lens.Getter
<span class="lineno">   65 </span>import           Control.Lens.Lens
<span class="lineno">   66 </span>import           Control.Lens.Setter
<span class="lineno">   67 </span>import           Control.Exception as X
<span class="lineno">   68 </span>import           Control.Monad (filterM, foldM, forM, forM_, zipWithM)
<span class="lineno">   69 </span>import           Control.Monad.Except (runExcept)
<span class="lineno">   70 </span>import           Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   71 </span>import qualified Data.ByteString as BS
<span class="lineno">   72 </span>import           Data.Either (partitionEithers)
<span class="lineno">   73 </span>import           Data.Foldable (for_, traverse_, toList)
<span class="lineno">   74 </span>import           Data.List
<span class="lineno">   75 </span>import qualified Data.List.NonEmpty as NE
<span class="lineno">   76 </span>import           Data.IORef (IORef, modifyIORef)
<span class="lineno">   77 </span>import           Data.Map (Map)
<span class="lineno">   78 </span>import qualified Data.Map as Map
<span class="lineno">   79 </span>import           Data.Maybe
<span class="lineno">   80 </span>import           Data.Set (Set)
<span class="lineno">   81 </span>import qualified Data.Set as Set
<span class="lineno">   82 </span>import           Data.Text (Text, pack)
<span class="lineno">   83 </span>import qualified Data.Vector as V
<span class="lineno">   84 </span>import           Data.Void (absurd)
<span class="lineno">   85 </span>import           Numeric.Natural
<span class="lineno">   86 </span>import qualified Prettyprinter as PP
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>import qualified Text.LLVM.AST as L
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>import qualified Cryptol.TypeCheck.AST as Cryptol (Schema(..))
<span class="lineno">   91 </span>import qualified Cryptol.Eval.Type as Cryptol (TValue(..), evalType)
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>import qualified Lang.Crucible.Backend as Crucible
<span class="lineno">   94 </span>import qualified Lang.Crucible.CFG.Core as Crucible (TypeRepr(UnitRepr))
<span class="lineno">   95 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">   96 </span>import qualified Lang.Crucible.LLVM.Bytes as Crucible
<span class="lineno">   97 </span>import qualified Lang.Crucible.LLVM.DataLayout as Crucible
<span class="lineno">   98 </span>import qualified Lang.Crucible.LLVM.MemModel as Crucible
<span class="lineno">   99 </span>import qualified Lang.Crucible.LLVM.MemType as Crucible
<span class="lineno">  100 </span>import qualified Lang.Crucible.LLVM.Translation as Crucible
<span class="lineno">  101 </span>import qualified Lang.Crucible.Simulator.GlobalState as Crucible
<span class="lineno">  102 </span>import qualified Lang.Crucible.Simulator.OverrideSim as Crucible
<span class="lineno">  103 </span>import qualified Lang.Crucible.Simulator.RegMap as Crucible
<span class="lineno">  104 </span>import qualified Lang.Crucible.Simulator.SimError as Crucible
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>import qualified What4.BaseTypes as W4
<span class="lineno">  107 </span>import qualified What4.Config as W4
<span class="lineno">  108 </span>import qualified What4.Expr.Builder as W4
<span class="lineno">  109 </span>import qualified What4.Interface as W4
<span class="lineno">  110 </span>import qualified What4.LabeledPred as W4
<span class="lineno">  111 </span>import qualified What4.ProgramLoc as W4
<span class="lineno">  112 </span>import qualified What4.Symbol as W4
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>import qualified SAWScript.Crucible.LLVM.CrucibleLLVM as Crucible
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">  117 </span>import           Data.Parameterized.NatRepr
<span class="lineno">  118 </span>import           Data.Parameterized.Some (Some(..))
<span class="lineno">  119 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>import           Verifier.SAW.SharedTerm
<span class="lineno">  122 </span>import           Verifier.SAW.Recognizer
<span class="lineno">  123 </span>import           Verifier.SAW.TypedTerm
<span class="lineno">  124 </span>import           Verifier.SAW.Simulator.TermModel
<span class="lineno">  125 </span>import           Verifier.SAW.Simulator.What4.ReturnTrip (SAWCoreState(..), toSC, bindSAWTerm)
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>import           SAWScript.Crucible.Common
<span class="lineno">  128 </span>import           SAWScript.Crucible.Common.MethodSpec (SetupValue(..), PointsTo)
<span class="lineno">  129 </span>import qualified SAWScript.Crucible.Common.MethodSpec as MS
<span class="lineno">  130 </span>import           SAWScript.Crucible.Common.MethodSpec (AllocIndex(..), PrePost(..))
<span class="lineno">  131 </span>import           SAWScript.Crucible.Common.Override hiding (getSymInterface)
<span class="lineno">  132 </span>import qualified SAWScript.Crucible.Common.Override as Ov (getSymInterface)
<span class="lineno">  133 </span>import           SAWScript.Crucible.LLVM.MethodSpecIR
<span class="lineno">  134 </span>import           SAWScript.Crucible.LLVM.ResolveSetupValue
<span class="lineno">  135 </span>import           SAWScript.Crucible.LLVM.Setup.Value ()
<span class="lineno">  136 </span>import           SAWScript.Options
<span class="lineno">  137 </span>import           SAWScript.Panic
<span class="lineno">  138 </span>import           SAWScript.Utils (bullets, handleException)
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>type instance Pointer' (LLVM arch) Sym = LLVMPtr (Crucible.ArchWidth arch)
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>------------------------------------------------------------------------
<span class="lineno">  143 </span>-- Translating SAW values to Crucible values for good error messages
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>ppLLVMVal ::
<span class="lineno">  146 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  147 </span>  LLVMVal -&gt;
<span class="lineno">  148 </span>  OverrideMatcher (LLVM arch) w (PP.Doc ann)
<span class="lineno">  149 </span><span class="decl"><span class="istickedoff">ppLLVMVal cc val = do</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">sym &lt;- Ov.getSymInterface</span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="istickedoff">mem &lt;- readGlobal (Crucible.llvmMemVar (ccLLVMContext cc))</span>
<span class="lineno">  152 </span><span class="spaces">  </span><span class="istickedoff">-- TODO: remove viaShow when crucible switches to prettyprinter</span>
<span class="lineno">  153 </span><span class="spaces">  </span><span class="istickedoff">pure $ <span class="nottickedoff">PP.viaShow $ Crucible.ppLLVMValWithGlobals sym (Crucible.memImplSymbolMap mem) val</span></span></span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>-- | Resolve a 'SetupValue' into a 'LLVMVal' and pretty-print it
<span class="lineno">  156 </span>ppSetupValueAsLLVMVal ::
<span class="lineno">  157 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  158 </span>  Options              {- ^ output/verbosity options -} -&gt;
<span class="lineno">  159 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  160 </span>  SharedContext {- ^ context for constructing SAW terms -} -&gt;
<span class="lineno">  161 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ for name and typing environments -} -&gt;
<span class="lineno">  162 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno">  163 </span>  OverrideMatcher (LLVM arch) w (PP.Doc ann)
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">ppSetupValueAsLLVMVal opts cc sc spec setupval = do</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="istickedoff">(_memTy, llvmval) &lt;- resolveSetupValueLLVM <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec setupval</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="istickedoff">ppLLVMVal cc <span class="nottickedoff">llvmval</span></span></span>
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>-- | Try to translate the spec\'s 'SetupValue' into an 'LLVMVal', pretty-print
<span class="lineno">  169 </span>--   the 'LLVMVal'.
<span class="lineno">  170 </span>mkStructuralMismatch ::
<span class="lineno">  171 </span>  (Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  172 </span>  Options              {- ^ output/verbosity options -} -&gt;
<span class="lineno">  173 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  174 </span>  SharedContext {- ^ context for constructing SAW terms -} -&gt;
<span class="lineno">  175 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ for name and typing environments -} -&gt;
<span class="lineno">  176 </span>  Crucible.LLVMVal Sym {- ^ the value from the simulator -} -&gt;
<span class="lineno">  177 </span>  SetupValue (LLVM arch)           {- ^ the value from the spec -} -&gt;
<span class="lineno">  178 </span>  Crucible.MemType     {- ^ the expected type -} -&gt;
<span class="lineno">  179 </span>  OverrideMatcher (LLVM arch) w (OverrideFailureReason (LLVM arch))
<span class="lineno">  180 </span><span class="decl"><span class="istickedoff">mkStructuralMismatch _opts cc _sc spec llvmval setupval memTy =</span>
<span class="lineno">  181 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">tyEnv = MS.csAllocations spec</span></span>
<span class="lineno">  182 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno">  183 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">maybeMsgTy = either (const Nothing) Just $ runExcept (typeOfSetupValue cc tyEnv nameEnv setupval)</span></span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">in pure $ <span class="nottickedoff">StructuralMismatch</span></span>
<span class="lineno">  185 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(PP.pretty llvmval)</span></span>
<span class="lineno">  186 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(MS.ppSetupValue setupval)</span></span>
<span class="lineno">  187 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">maybeMsgTy</span></span>
<span class="lineno">  188 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">memTy</span></span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | Instead of using 'ppPointsTo', which prints 'SetupValue', translate
<span class="lineno">  191 </span>--   expressions to 'LLVMVal'.
<span class="lineno">  192 </span>ppPointsToAsLLVMVal ::
<span class="lineno">  193 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  194 </span>  Options              {- ^ output/verbosity options -} -&gt;
<span class="lineno">  195 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  196 </span>  SharedContext {- ^ context for constructing SAW terms -} -&gt;
<span class="lineno">  197 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ for name and typing environments -} -&gt;
<span class="lineno">  198 </span>  PointsTo (LLVM arch) -&gt;
<span class="lineno">  199 </span>  OverrideMatcher (LLVM arch) w (PP.Doc ann)
<span class="lineno">  200 </span><span class="decl"><span class="istickedoff">ppPointsToAsLLVMVal opts cc sc spec (LLVMPointsTo md cond ptr val) = do</span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">pretty1 &lt;- ppSetupValueAsLLVMVal <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec ptr</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">pretty2 = PP.pretty val</span></span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">pure $ <span class="nottickedoff">PP.vcat [ &quot;Pointer:&quot; PP.&lt;+&gt; pretty1</span></span>
<span class="lineno">  204 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">, &quot;Pointee:&quot; PP.&lt;+&gt; pretty2</span></span>
<span class="lineno">  205 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">, maybe PP.emptyDoc (\tt -&gt; &quot;Condition:&quot; PP.&lt;+&gt; MS.ppTypedTerm tt) cond</span></span>
<span class="lineno">  206 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">, &quot;Assertion made at:&quot; PP.&lt;+&gt;</span></span>
<span class="lineno">  207 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">PP.pretty (W4.plSourceLoc (MS.conditionLoc md))</span></span>
<span class="lineno">  208 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  209 </span><span class="spaces"></span><span class="istickedoff">ppPointsToAsLLVMVal opts cc sc spec (LLVMPointsToBitfield md ptr fieldName val) = <span class="nottickedoff">do</span></span>
<span class="lineno">  210 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">pretty1 &lt;- ppSetupValueAsLLVMVal opts cc sc spec ptr</span></span>
<span class="lineno">  211 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">let pretty2 = MS.ppSetupValue val</span></span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">pure $ PP.vcat [ &quot;Pointer (bitfield):&quot; PP.&lt;+&gt; pretty1 &lt;&gt; PP.pretty (&quot;.&quot; ++ fieldName)</span></span>
<span class="lineno">  213 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">, &quot;Pointee:&quot; PP.&lt;+&gt; pretty2</span></span>
<span class="lineno">  214 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">, &quot;Assertion made at:&quot; PP.&lt;+&gt;</span></span>
<span class="lineno">  215 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">PP.pretty (W4.plSourceLoc (MS.conditionLoc md))</span></span>
<span class="lineno">  216 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  217 </span>
<span class="lineno">  218 </span>-- | Create an error stating that the 'LLVMVal' was not equal to the 'SetupValue'
<span class="lineno">  219 </span>notEqual ::
<span class="lineno">  220 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  221 </span>  PrePost -&gt;
<span class="lineno">  222 </span>  Options              {- ^ output/verbosity options -} -&gt;
<span class="lineno">  223 </span>  W4.ProgramLoc        {- ^ where is the assertion from? -} -&gt;
<span class="lineno">  224 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  225 </span>  SharedContext {- ^ context for constructing SAW terms -} -&gt;
<span class="lineno">  226 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ for name and typing environments -} -&gt;
<span class="lineno">  227 </span>  SetupValue (LLVM arch)           {- ^ the value from the spec -} -&gt;
<span class="lineno">  228 </span>  Crucible.LLVMVal Sym {- ^ the value from the simulator -} -&gt;
<span class="lineno">  229 </span>  OverrideMatcher (LLVM arch) w Crucible.SimError
<span class="lineno">  230 </span><span class="decl"><span class="istickedoff">notEqual cond opts loc cc sc spec expected actual = do</span>
<span class="lineno">  231 </span><span class="spaces">  </span><span class="istickedoff">prettyLLVMVal      &lt;- ppLLVMVal cc <span class="nottickedoff">actual</span></span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="istickedoff">prettySetupLLVMVal &lt;- ppSetupValueAsLLVMVal <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> <span class="nottickedoff">spec</span> expected</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">let msg = unlines</span>
<span class="lineno">  234 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;Equality &quot; ++ <span class="nottickedoff">MS.stateCond cond</span></span>
<span class="lineno">  235 </span><span class="spaces">        </span><span class="istickedoff">, <span class="nottickedoff">&quot;Expected value (as a SAW value): &quot;</span></span>
<span class="lineno">  236 </span><span class="spaces">        </span><span class="istickedoff">, <span class="nottickedoff">show (MS.ppSetupValue expected)</span></span>
<span class="lineno">  237 </span><span class="spaces">        </span><span class="istickedoff">, <span class="nottickedoff">&quot;Expected value (as a Crucible value): &quot;</span></span>
<span class="lineno">  238 </span><span class="spaces">        </span><span class="istickedoff">, <span class="nottickedoff">show prettySetupLLVMVal</span></span>
<span class="lineno">  239 </span><span class="spaces">        </span><span class="istickedoff">, <span class="nottickedoff">&quot;Actual value: &quot;</span></span>
<span class="lineno">  240 </span><span class="spaces">        </span><span class="istickedoff">, <span class="nottickedoff">show prettyLLVMVal</span></span>
<span class="lineno">  241 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">pure $ Crucible.SimError loc $ Crucible.AssertFailureSimError msg &quot;&quot;</span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>------------------------------------------------------------------------
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>-- | Print a message about symbolic failure of an override's preconditions
<span class="lineno">  247 </span>--
<span class="lineno">  248 </span>-- TODO: Needs additional testing. Are these messages useful?
<span class="lineno">  249 </span>{-
<span class="lineno">  250 </span>ppSymbolicFailure ::
<span class="lineno">  251 </span>  (OverrideWithPreconditions (LLVM arch), [LabeledPred Sym]) -&gt;
<span class="lineno">  252 </span>  PP.Doc
<span class="lineno">  253 </span>ppSymbolicFailure = uncurry ppFailure
<span class="lineno">  254 </span>-}
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>-- | Pretty-print the arguments passed to an override
<span class="lineno">  257 </span>ppArgs ::
<span class="lineno">  258 </span>  forall arch args ann.
<span class="lineno">  259 </span>  (Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  260 </span>  Sym -&gt;
<span class="lineno">  261 </span>  LLVMCrucibleContext arch            {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  262 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ specification for current function override  -} -&gt;
<span class="lineno">  263 </span>  Crucible.RegMap Sym args            {- ^ arguments from the simulator -} -&gt;
<span class="lineno">  264 </span>  IO [PP.Doc ann]
<span class="lineno">  265 </span><span class="decl"><span class="istickedoff">ppArgs sym cc cs (Crucible.RegMap args) = do</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="istickedoff">let expectedArgTypes = map fst (Map.elems (cs ^. MS.csArgBindings))</span>
<span class="lineno">  267 </span><span class="spaces">  </span><span class="istickedoff">let aux memTy (Crucible.AnyValue tyrep val) =</span>
<span class="lineno">  268 </span><span class="spaces">        </span><span class="istickedoff">do storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno">  269 </span><span class="spaces">           </span><span class="istickedoff">llvmval &lt;- Crucible.packMemValue <span class="nottickedoff">sym</span> storTy tyrep val</span>
<span class="lineno">  270 </span><span class="spaces">           </span><span class="istickedoff">return (llvmval, <span class="nottickedoff">memTy</span>)</span>
<span class="lineno">  271 </span><span class="spaces">  </span><span class="istickedoff">case Crucible.lookupGlobal (Crucible.llvmMemVar (ccLLVMContext cc)) (cc^.ccLLVMGlobals) of</span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;Internal error: Couldn't find LLVM memory variable&quot;</span></span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">Just mem -&gt; do</span>
<span class="lineno">  274 </span><span class="spaces">      </span><span class="istickedoff">-- TODO: remove viaShow when crucible switches to prettyprinter</span>
<span class="lineno">  275 </span><span class="spaces">      </span><span class="istickedoff">map (PP.viaShow . Crucible.ppLLVMValWithGlobals <span class="nottickedoff">sym</span> (Crucible.memImplSymbolMap mem) . fst) &lt;$&gt;</span>
<span class="lineno">  276 </span><span class="spaces">        </span><span class="istickedoff">liftIO (zipWithM aux expectedArgTypes (assignmentToList args))</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>-- | This function is responsible for implementing the \&quot;override\&quot; behavior
<span class="lineno">  279 </span>--   of method specifications.  The main work done in this function to manage
<span class="lineno">  280 </span>--   the process of selecting between several possible different override
<span class="lineno">  281 </span>--   specifications that could apply.  We want a proof to succeed if _any_
<span class="lineno">  282 </span>--   choice of method spec allows the proof to go through, which is a slightly
<span class="lineno">  283 </span>--   awkward thing to fit into the symbolic simulation framework.
<span class="lineno">  284 </span>--
<span class="lineno">  285 </span>--   The main work of determining the preconditions, postconditions, memory
<span class="lineno">  286 </span>--   updates and return value for a single specification is done by
<span class="lineno">  287 </span>--   the @methodSpecHandler_prestate@ and @methodSpecHandler_poststate@ functions.
<span class="lineno">  288 </span>--
<span class="lineno">  289 </span>--   In a first phase, we attempt to apply the precondition portion of each of
<span class="lineno">  290 </span>--   the given method specifications.  Each of them that might apply generate
<span class="lineno">  291 </span>--   a substitution for the setup variables and a collection of preconditions
<span class="lineno">  292 </span>--   that guard the specification.  We use these preconditions to compute
<span class="lineno">  293 </span>--   a multiway symbolic branch, one for each override which might apply.
<span class="lineno">  294 </span>--
<span class="lineno">  295 </span>--   In the body of each of the individual branches, we compute the postcondition
<span class="lineno">  296 </span>--   actions of the corresponding method specification.  This will update memory
<span class="lineno">  297 </span>--   and compute function return values, in addition to assuming postcondition
<span class="lineno">  298 </span>--   predicates.
<span class="lineno">  299 </span>methodSpecHandler ::
<span class="lineno">  300 </span>  forall arch rtp args ret.
<span class="lineno">  301 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  302 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  303 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  304 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  305 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno">  306 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  307 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  308 </span>  ) =&gt;
<span class="lineno">  309 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  310 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  311 </span>  LLVMCrucibleContext arch     {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  312 </span>  IORef MetadataMap -&gt;
<span class="lineno">  313 </span>  NE.NonEmpty (MS.CrucibleMethodSpecIR (LLVM arch))
<span class="lineno">  314 </span>    {- ^ specification for current function override  -} -&gt;
<span class="lineno">  315 </span>  Crucible.FnHandle args ret {- ^ the handle for this function -} -&gt;
<span class="lineno">  316 </span>  Crucible.OverrideSim (SAWCruciblePersonality Sym) Sym Crucible.LLVM rtp args ret
<span class="lineno">  317 </span>     (Crucible.RegValue Sym ret)
<span class="lineno">  318 </span><span class="decl"><span class="istickedoff">methodSpecHandler opts sc cc mdMap css h =</span>
<span class="lineno">  319 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="istickedoff">let fnName = NE.head css ^. csName</span>
<span class="lineno">  322 </span><span class="spaces">  </span><span class="istickedoff">call_loc &lt;- liftIO $ W4.getCurrentProgramLoc sym</span>
<span class="lineno">  323 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ printOutLn opts Info $ unwords</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="istickedoff">[ &quot;Matching&quot;</span>
<span class="lineno">  325 </span><span class="spaces">    </span><span class="istickedoff">, show (length css)</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">, &quot;overrides of &quot;</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="istickedoff">, fnName</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">, &quot;...&quot;</span>
<span class="lineno">  329 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">Crucible.RegMap args &lt;- Crucible.getOverrideArgs</span>
<span class="lineno">  331 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  332 </span><span class="spaces">  </span><span class="istickedoff">-- First, run the precondition matcher phase.  Collect together a list of the results.</span>
<span class="lineno">  333 </span><span class="spaces">  </span><span class="istickedoff">-- For each override, this will either be an error message, or a matcher state and</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="istickedoff">-- a method spec.</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="istickedoff">prestates &lt;-</span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="istickedoff">do g0 &lt;- Crucible.readGlobals</span>
<span class="lineno">  337 </span><span class="spaces">       </span><span class="istickedoff">forM css $ \cs -&gt; liftIO $</span>
<span class="lineno">  338 </span><span class="spaces">         </span><span class="istickedoff">let initialFree = Set.fromList (map (ecVarIndex . tecExt)</span>
<span class="lineno">  339 </span><span class="spaces">                                           </span><span class="istickedoff">(view (MS.csPreState . MS.csFreshVars) cs))</span>
<span class="lineno">  340 </span><span class="spaces">          </span><span class="istickedoff">in runOverrideMatcher sym g0 Map.empty Map.empty initialFree <span class="nottickedoff">(view MS.csLoc cs)</span></span>
<span class="lineno">  341 </span><span class="spaces">                      </span><span class="istickedoff">(do methodSpecHandler_prestate <span class="nottickedoff">opts</span> sc cc args cs</span>
<span class="lineno">  342 </span><span class="spaces">                          </span><span class="istickedoff">return cs)</span>
<span class="lineno">  343 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  344 </span><span class="spaces">  </span><span class="istickedoff">-- Print a failure message if all overrides failed to match.  Otherwise, collect</span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">-- all the override states that might apply, and compute the conjunction of all</span>
<span class="lineno">  346 </span><span class="spaces">  </span><span class="istickedoff">-- the preconditions.  We'll use these to perform symbolic branches between the</span>
<span class="lineno">  347 </span><span class="spaces">  </span><span class="istickedoff">-- various overrides.</span>
<span class="lineno">  348 </span><span class="spaces">  </span><span class="istickedoff">branches &lt;-</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">let prettyError methodSpec failureReason = do</span>
<span class="lineno">  350 </span><span class="spaces">          </span><span class="istickedoff">prettyArgs &lt;- liftIO $ ppArgs <span class="nottickedoff">sym</span> cc methodSpec (Crucible.RegMap args)</span>
<span class="lineno">  351 </span><span class="spaces">          </span><span class="istickedoff">pure $</span>
<span class="lineno">  352 </span><span class="spaces">            </span><span class="istickedoff">PP.vcat</span>
<span class="lineno">  353 </span><span class="spaces">            </span><span class="istickedoff">[ MS.ppMethodSpec methodSpec</span>
<span class="lineno">  354 </span><span class="spaces">            </span><span class="istickedoff">, &quot;Arguments:&quot;</span>
<span class="lineno">  355 </span><span class="spaces">            </span><span class="istickedoff">, bullets '-' prettyArgs</span>
<span class="lineno">  356 </span><span class="spaces">            </span><span class="istickedoff">, ppOverrideFailure failureReason</span>
<span class="lineno">  357 </span><span class="spaces">            </span><span class="istickedoff">]</span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno">  359 </span><span class="spaces">      </span><span class="istickedoff">case partitionEithers (toList prestates) of</span>
<span class="lineno">  360 </span><span class="spaces">          </span><span class="istickedoff">(errs, []) -&gt; do</span>
<span class="lineno">  361 </span><span class="spaces">            </span><span class="istickedoff">msgs &lt;-</span>
<span class="lineno">  362 </span><span class="spaces">              </span><span class="istickedoff">mapM (\(cs, err) -&gt;</span>
<span class="lineno">  363 </span><span class="spaces">                      </span><span class="istickedoff">(&quot;*&quot; PP.&lt;&gt;) . PP.indent 2 &lt;$&gt; prettyError cs err)</span>
<span class="lineno">  364 </span><span class="spaces">                   </span><span class="istickedoff">(zip (toList css) errs)</span>
<span class="lineno">  365 </span><span class="spaces">            </span><span class="istickedoff">fail $ show $</span>
<span class="lineno">  366 </span><span class="spaces">              </span><span class="istickedoff">PP.vcat [&quot;All overrides failed during structural matching:&quot;, PP.vcat msgs]</span>
<span class="lineno">  367 </span><span class="spaces">          </span><span class="istickedoff">(_, ss) -&gt; liftIO $</span>
<span class="lineno">  368 </span><span class="spaces">            </span><span class="istickedoff">forM ss $ \(cs,st) -&gt;</span>
<span class="lineno">  369 </span><span class="spaces">              </span><span class="istickedoff">return (OverrideWithPreconditions (st^.osAsserts) cs st)</span>
<span class="lineno">  370 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  371 </span><span class="spaces">  </span><span class="istickedoff">-- Now we do a second phase of simple compatibility checking: we check to see</span>
<span class="lineno">  372 </span><span class="spaces">  </span><span class="istickedoff">-- if any of the preconditions of the various overrides are concretely false.</span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="istickedoff">-- If so, there's no use in branching on them with @symbolicBranches@.</span>
<span class="lineno">  374 </span><span class="spaces">  </span><span class="istickedoff">(true, false, unknown) &lt;- liftIO $ partitionOWPsConcrete sym branches</span>
<span class="lineno">  375 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  376 </span><span class="spaces">  </span><span class="istickedoff">-- Check if there is only a single override branch that might apply at this</span>
<span class="lineno">  377 </span><span class="spaces">  </span><span class="istickedoff">-- point.  If so, commit to it and handle that case specially. If there is</span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">-- more than one (or zero) branches that might apply, go to the general case.</span>
<span class="lineno">  379 </span><span class="spaces">  </span><span class="istickedoff">case true ++ unknown of</span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">[singleBranch] | <span class="tickonlyfalse">?singleOverrideSpecialCase</span> -&gt;</span>
<span class="lineno">  381 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">handleSingleOverrideBranch opts sc cc call_loc mdMap h singleBranch</span></span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; handleOverrideBranches opts sc cc call_loc css h branches (true, false, unknown)</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>handleSingleOverrideBranch :: forall arch rtp args ret.
<span class="lineno">  385 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  386 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  387 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  388 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  389 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  390 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  391 </span>  ) =&gt;
<span class="lineno">  392 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  393 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  394 </span>  LLVMCrucibleContext arch     {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  395 </span>  W4.ProgramLoc            {- ^ Location of the call site for error reporting-} -&gt;
<span class="lineno">  396 </span>  IORef MetadataMap -&gt;
<span class="lineno">  397 </span>  Crucible.FnHandle args ret {- ^ the handle for this function -} -&gt;
<span class="lineno">  398 </span>  OverrideWithPreconditions (LLVM arch) -&gt;
<span class="lineno">  399 </span>  Crucible.OverrideSim (SAWCruciblePersonality Sym) Sym Crucible.LLVM rtp args ret
<span class="lineno">  400 </span>     (Crucible.RegValue Sym ret)
<span class="lineno">  401 </span><span class="decl"><span class="nottickedoff">handleSingleOverrideBranch opts sc cc call_loc mdMap h (OverrideWithPreconditions preconds cs st) =</span>
<span class="lineno">  402 </span><span class="spaces">  </span><span class="nottickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno">  403 </span><span class="spaces">  </span><span class="nottickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  404 </span><span class="spaces">  </span><span class="nottickedoff">let fnName = cs ^. csName</span>
<span class="lineno">  405 </span><span class="spaces">  </span><span class="nottickedoff">let retTy = Crucible.handleReturnType h</span>
<span class="lineno">  406 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  407 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ printOutLn opts Info $ unwords</span>
<span class="lineno">  408 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Found a single potential override for&quot;</span>
<span class="lineno">  409 </span><span class="spaces">    </span><span class="nottickedoff">, fnName</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  411 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="nottickedoff">-- First assert the override preconditions</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ forM_ preconds $ \(md,W4.LabeledPred p r) -&gt;</span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="nottickedoff">do (ann,p') &lt;- W4.annotateTerm sym p</span>
<span class="lineno">  415 </span><span class="spaces">       </span><span class="nottickedoff">let caller = unwords [&quot;Override called from:&quot;, show (W4.plSourceLoc call_loc)]</span>
<span class="lineno">  416 </span><span class="spaces">       </span><span class="nottickedoff">let md' = md{ MS.conditionContext = MS.conditionContext md ++ caller }</span>
<span class="lineno">  417 </span><span class="spaces">       </span><span class="nottickedoff">modifyIORef mdMap (Map.insert ann md')</span>
<span class="lineno">  418 </span><span class="spaces">       </span><span class="nottickedoff">Crucible.addAssertion bak (Crucible.LabeledPred p' r)</span>
<span class="lineno">  419 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="nottickedoff">g &lt;- Crucible.readGlobals</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">res &lt;- liftIO $ runOverrideMatcher sym g</span>
<span class="lineno">  422 </span><span class="spaces">     </span><span class="nottickedoff">(st^.setupValueSub)</span>
<span class="lineno">  423 </span><span class="spaces">     </span><span class="nottickedoff">(st^.termSub)</span>
<span class="lineno">  424 </span><span class="spaces">     </span><span class="nottickedoff">(st^.osFree)</span>
<span class="lineno">  425 </span><span class="spaces">     </span><span class="nottickedoff">(st^.osLocation)</span>
<span class="lineno">  426 </span><span class="spaces">     </span><span class="nottickedoff">(methodSpecHandler_poststate opts sc cc retTy cs)</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="nottickedoff">case res of</span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="nottickedoff">Left (OF loc rsn)  -&gt;</span>
<span class="lineno">  429 </span><span class="spaces">      </span><span class="nottickedoff">-- TODO, better pretty printing for reasons</span>
<span class="lineno">  430 </span><span class="spaces">      </span><span class="nottickedoff">liftIO</span>
<span class="lineno">  431 </span><span class="spaces">        </span><span class="nottickedoff">$ Crucible.abortExecBecause</span>
<span class="lineno">  432 </span><span class="spaces">        </span><span class="nottickedoff">$ Crucible.AssertionFailure</span>
<span class="lineno">  433 </span><span class="spaces">        </span><span class="nottickedoff">$ Crucible.SimError loc</span>
<span class="lineno">  434 </span><span class="spaces">        </span><span class="nottickedoff">$ Crucible.AssertFailureSimError &quot;assumed false&quot; (show rsn)</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="nottickedoff">Right (ret,st') -&gt;</span>
<span class="lineno">  436 </span><span class="spaces">      </span><span class="nottickedoff">do liftIO $ forM_ (st'^.osAssumes) $ \(_md,asum) -&gt;</span>
<span class="lineno">  437 </span><span class="spaces">           </span><span class="nottickedoff">Crucible.addAssumption bak</span>
<span class="lineno">  438 </span><span class="spaces">            </span><span class="nottickedoff">$ Crucible.GenericAssumption (st^.osLocation) &quot;override postcondition&quot; asum</span>
<span class="lineno">  439 </span><span class="spaces">         </span><span class="nottickedoff">Crucible.writeGlobals (st'^.overrideGlobals)</span>
<span class="lineno">  440 </span><span class="spaces">         </span><span class="nottickedoff">Crucible.overrideReturn' (Crucible.RegEntry retTy ret)</span></span>
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>handleOverrideBranches :: forall arch rtp args ret.
<span class="lineno">  443 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  444 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  445 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  446 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  447 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  448 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  449 </span>  ) =&gt;
<span class="lineno">  450 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  451 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  452 </span>  LLVMCrucibleContext arch     {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  453 </span>  W4.ProgramLoc            {- ^ Location of the call site for error reporting-} -&gt;
<span class="lineno">  454 </span>  NE.NonEmpty (MS.CrucibleMethodSpecIR (LLVM arch))
<span class="lineno">  455 </span>    {- ^ specification for current function override  -} -&gt;
<span class="lineno">  456 </span>  Crucible.FnHandle args ret {- ^ the handle for this function -} -&gt;
<span class="lineno">  457 </span>  [OverrideWithPreconditions (LLVM arch)] -&gt;
<span class="lineno">  458 </span>  ([OverrideWithPreconditions (LLVM arch)],[OverrideWithPreconditions (LLVM arch)],[OverrideWithPreconditions (LLVM arch)]) -&gt;
<span class="lineno">  459 </span>  Crucible.OverrideSim (SAWCruciblePersonality Sym) Sym Crucible.LLVM rtp args ret
<span class="lineno">  460 </span>     (Crucible.RegValue Sym ret)
<span class="lineno">  461 </span>
<span class="lineno">  462 </span><span class="decl"><span class="istickedoff">handleOverrideBranches opts sc cc call_loc css h branches (true, false, unknown) =</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno">  464 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="istickedoff">let fnName = NE.head css ^. csName</span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="istickedoff">Crucible.RegMap args &lt;- Crucible.getOverrideArgs</span>
<span class="lineno">  467 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  468 </span><span class="spaces">  </span><span class="istickedoff">-- Collapse the preconditions to a single predicate</span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="istickedoff">branches' &lt;- liftIO $ forM (true ++ unknown) $</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">\(OverrideWithPreconditions preconds cs st) -&gt;</span>
<span class="lineno">  471 </span><span class="spaces">      </span><span class="istickedoff">W4.andAllOf sym (folded . _2 . W4.labeledPred) preconds &lt;&amp;&gt;</span>
<span class="lineno">  472 </span><span class="spaces">        </span><span class="istickedoff">\precond -&gt; (precond, cs, st)</span>
<span class="lineno">  473 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  474 </span><span class="spaces">  </span><span class="istickedoff">-- Now use crucible's symbolic branching machinery to select between the branches.</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">-- Essentially, we are doing an n-way if statement on the precondition predicates</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">-- for each override, and selecting the first one whose preconditions hold.</span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  478 </span><span class="spaces">  </span><span class="istickedoff">-- Then, in the body of the branch, we run the poststate handler to update the</span>
<span class="lineno">  479 </span><span class="spaces">  </span><span class="istickedoff">-- memory state, compute return values and compute postcondition predicates.</span>
<span class="lineno">  480 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  481 </span><span class="spaces">  </span><span class="istickedoff">-- For each override branch that doesn't fail outright, we assume the relevant</span>
<span class="lineno">  482 </span><span class="spaces">  </span><span class="istickedoff">-- postconditions, update the crucible global variable state, and return the</span>
<span class="lineno">  483 </span><span class="spaces">  </span><span class="istickedoff">-- computed return value.</span>
<span class="lineno">  484 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  485 </span><span class="spaces">  </span><span class="istickedoff">-- We add a final default branch that simply fails unless some previous override</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">-- branch has already succeeded.</span>
<span class="lineno">  487 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ printOutLn opts Info $ unwords</span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff">[ &quot;Branching on&quot;</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">, show (length branches')</span>
<span class="lineno">  490 </span><span class="spaces">    </span><span class="istickedoff">, &quot;override variants of&quot;</span>
<span class="lineno">  491 </span><span class="spaces">    </span><span class="istickedoff">, fnName</span>
<span class="lineno">  492 </span><span class="spaces">    </span><span class="istickedoff">, &quot;...&quot;</span>
<span class="lineno">  493 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  494 </span><span class="spaces">  </span><span class="istickedoff">let retTy = Crucible.handleReturnType h</span>
<span class="lineno">  495 </span><span class="spaces">  </span><span class="istickedoff">res &lt;- Crucible.regValue &lt;$&gt; Crucible.callOverride h</span>
<span class="lineno">  496 </span><span class="spaces">     </span><span class="istickedoff">(Crucible.mkOverride' &quot;overrideBranches&quot; <span class="nottickedoff">retTy</span></span>
<span class="lineno">  497 </span><span class="spaces">       </span><span class="istickedoff">(Crucible.symbolicBranches Crucible.emptyRegMap $</span>
<span class="lineno">  498 </span><span class="spaces">         </span><span class="istickedoff">[ ( precond</span>
<span class="lineno">  499 </span><span class="spaces">           </span><span class="istickedoff">, do g &lt;- Crucible.readGlobals</span>
<span class="lineno">  500 </span><span class="spaces">                </span><span class="istickedoff">res &lt;- liftIO $ runOverrideMatcher sym g</span>
<span class="lineno">  501 </span><span class="spaces">                   </span><span class="istickedoff">(st^.setupValueSub)</span>
<span class="lineno">  502 </span><span class="spaces">                   </span><span class="istickedoff">(st^.termSub)</span>
<span class="lineno">  503 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">(st^.osFree)</span></span>
<span class="lineno">  504 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">(st^.osLocation)</span></span>
<span class="lineno">  505 </span><span class="spaces">                   </span><span class="istickedoff">(methodSpecHandler_poststate <span class="nottickedoff">opts</span> sc cc retTy cs)</span>
<span class="lineno">  506 </span><span class="spaces">                </span><span class="istickedoff">case res of</span>
<span class="lineno">  507 </span><span class="spaces">                  </span><span class="istickedoff">Left (OF loc rsn)  -&gt;</span>
<span class="lineno">  508 </span><span class="spaces">                    </span><span class="istickedoff">-- TODO, better pretty printing for reasons</span>
<span class="lineno">  509 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">liftIO</span></span>
<span class="lineno">  510 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.abortExecBecause</span></span>
<span class="lineno">  511 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.AssertionFailure</span></span>
<span class="lineno">  512 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.SimError loc</span></span>
<span class="lineno">  513 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">$ Crucible.AssertFailureSimError &quot;assumed false&quot; (show rsn)</span></span>
<span class="lineno">  514 </span><span class="spaces">                  </span><span class="istickedoff">Right (ret,st') -&gt;</span>
<span class="lineno">  515 </span><span class="spaces">                    </span><span class="istickedoff">do liftIO $ forM_ (st'^.osAssumes) $ \(_md,asum) -&gt;</span>
<span class="lineno">  516 </span><span class="spaces">                         </span><span class="istickedoff">Crucible.addAssumption bak</span>
<span class="lineno">  517 </span><span class="spaces">                          </span><span class="istickedoff">$ Crucible.GenericAssumption <span class="nottickedoff">(st^.osLocation)</span> <span class="nottickedoff">&quot;override postcondition&quot;</span> asum</span>
<span class="lineno">  518 </span><span class="spaces">                       </span><span class="istickedoff">Crucible.writeGlobals (st'^.overrideGlobals)</span>
<span class="lineno">  519 </span><span class="spaces">                       </span><span class="istickedoff">Crucible.overrideReturn' (Crucible.RegEntry retTy ret)</span>
<span class="lineno">  520 </span><span class="spaces">           </span><span class="istickedoff">, Just (W4.plSourceLoc (cs ^. MS.csLoc))</span>
<span class="lineno">  521 </span><span class="spaces">           </span><span class="istickedoff">)</span>
<span class="lineno">  522 </span><span class="spaces">         </span><span class="istickedoff">| (precond, cs, st) &lt;- branches'</span>
<span class="lineno">  523 </span><span class="spaces">         </span><span class="istickedoff">] ++</span>
<span class="lineno">  524 </span><span class="spaces">         </span><span class="istickedoff">[ let e prettyArgs symFalse unsat = show $ PP.vcat $ concat</span>
<span class="lineno">  525 </span><span class="spaces">                 </span><span class="istickedoff">[ [ PP.pretty $</span>
<span class="lineno">  526 </span><span class="spaces">                     </span><span class="istickedoff">&quot;No override specification applies for &quot; ++ fnName ++ &quot;.&quot;</span>
<span class="lineno">  527 </span><span class="spaces">                   </span><span class="istickedoff">]</span>
<span class="lineno">  528 </span><span class="spaces">                 </span><span class="istickedoff">, [ &quot;Arguments:&quot;</span>
<span class="lineno">  529 </span><span class="spaces">                   </span><span class="istickedoff">, bullets '-' prettyArgs</span>
<span class="lineno">  530 </span><span class="spaces">                   </span><span class="istickedoff">]</span>
<span class="lineno">  531 </span><span class="spaces">                 </span><span class="istickedoff">, if | not (null false) -&gt;</span>
<span class="lineno">  532 </span><span class="spaces">                        </span><span class="istickedoff">[ PP.vcat</span>
<span class="lineno">  533 </span><span class="spaces">                          </span><span class="istickedoff">[ PP.pretty (unwords</span>
<span class="lineno">  534 </span><span class="spaces">                              </span><span class="istickedoff">[ &quot;The following overrides had some preconditions&quot;</span>
<span class="lineno">  535 </span><span class="spaces">                              </span><span class="istickedoff">, &quot;that failed concretely:&quot;</span>
<span class="lineno">  536 </span><span class="spaces">                              </span><span class="istickedoff">])</span>
<span class="lineno">  537 </span><span class="spaces">                          </span><span class="istickedoff">, bullets '-' (map ppConcreteFailure false)</span>
<span class="lineno">  538 </span><span class="spaces">                          </span><span class="istickedoff">]</span>
<span class="lineno">  539 </span><span class="spaces">                        </span><span class="istickedoff">]</span>
<span class="lineno">  540 </span><span class="spaces">                      </span><span class="istickedoff">-- See comment on ppSymbolicFailure: this needs more</span>
<span class="lineno">  541 </span><span class="spaces">                      </span><span class="istickedoff">-- examination to see if it's useful.</span>
<span class="lineno">  542 </span><span class="spaces">                      </span><span class="istickedoff">-- - | not (null symFalse) -&gt;</span>
<span class="lineno">  543 </span><span class="spaces">                      </span><span class="istickedoff">--   [ PP.text (unwords</span>
<span class="lineno">  544 </span><span class="spaces">                      </span><span class="istickedoff">--       [ &quot;The following overrides had some preconditions &quot;</span>
<span class="lineno">  545 </span><span class="spaces">                      </span><span class="istickedoff">--       , &quot;that failed symbolically:&quot;</span>
<span class="lineno">  546 </span><span class="spaces">                      </span><span class="istickedoff">--       ]) PP.&lt;$$&gt; bullets '-' (map ppSymbolicFailure symFalse)</span>
<span class="lineno">  547 </span><span class="spaces">                      </span><span class="istickedoff">--   ]</span>
<span class="lineno">  548 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  549 </span><span class="spaces">                      </span><span class="istickedoff">-- Note that we only print these in case no override had</span>
<span class="lineno">  550 </span><span class="spaces">                      </span><span class="istickedoff">-- individually (concretely or symbolically) false</span>
<span class="lineno">  551 </span><span class="spaces">                      </span><span class="istickedoff">-- preconditions.</span>
<span class="lineno">  552 </span><span class="spaces">                      </span><span class="istickedoff">| <span class="tickonlyfalse">not (null unsat) &amp;&amp; <span class="nottickedoff">null false &amp;&amp; null symFalse</span></span> -&gt;</span>
<span class="lineno">  553 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">[ PP.vcat</span></span>
<span class="lineno">  554 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty (unwords</span></span>
<span class="lineno">  555 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The conjunction of these overrides' preconditions&quot;</span></span>
<span class="lineno">  556 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, &quot;was unsatisfiable, meaning your override can never&quot;</span></span>
<span class="lineno">  557 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, &quot;apply. You probably have unintentionally specified&quot;</span></span>
<span class="lineno">  558 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">, &quot;mutually exclusive/inconsistent preconditions.&quot;</span></span>
<span class="lineno">  559 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">])</span></span>
<span class="lineno">  560 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, bullets '-' (unsat ^.. each . owpMethodSpec . to MS.ppMethodSpec)</span></span>
<span class="lineno">  561 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  562 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  563 </span><span class="spaces">                      </span><span class="istickedoff">| <span class="tickonlytrue">null false &amp;&amp; null symFalse</span> -&gt;</span>
<span class="lineno">  564 </span><span class="spaces">                        </span><span class="istickedoff">[ PP.pretty (unwords</span>
<span class="lineno">  565 </span><span class="spaces">                            </span><span class="istickedoff">[ &quot;No overrides had any single concretely or&quot;</span>
<span class="lineno">  566 </span><span class="spaces">                            </span><span class="istickedoff">, &quot;symbolically failing preconditions.&quot;</span>
<span class="lineno">  567 </span><span class="spaces">                            </span><span class="istickedoff">])</span>
<span class="lineno">  568 </span><span class="spaces">                        </span><span class="istickedoff">]</span>
<span class="lineno">  569 </span><span class="spaces">                      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno">  570 </span><span class="spaces">                 </span><span class="istickedoff">, if | <span class="tickonlytrue">simVerbose opts &lt; 3</span> -&gt;</span>
<span class="lineno">  571 </span><span class="spaces">                        </span><span class="istickedoff">[ PP.pretty $ unwords</span>
<span class="lineno">  572 </span><span class="spaces">                          </span><span class="istickedoff">[ &quot;Run SAW with --sim-verbose=3 to see a description&quot;</span>
<span class="lineno">  573 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;of each override.&quot;</span>
<span class="lineno">  574 </span><span class="spaces">                          </span><span class="istickedoff">]</span>
<span class="lineno">  575 </span><span class="spaces">                        </span><span class="istickedoff">]</span>
<span class="lineno">  576 </span><span class="spaces">                      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno">  577 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">[ PP.vcat</span></span>
<span class="lineno">  578 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Here are the descriptions of each override:&quot;</span></span>
<span class="lineno">  579 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, bullets '-'</span></span>
<span class="lineno">  580 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">(branches ^.. each . owpMethodSpec . to MS.ppMethodSpec)</span></span>
<span class="lineno">  581 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  582 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  583 </span><span class="spaces">                 </span><span class="istickedoff">]</span>
<span class="lineno">  584 </span><span class="spaces">           </span><span class="istickedoff">in ( W4.truePred sym</span>
<span class="lineno">  585 </span><span class="spaces">              </span><span class="istickedoff">, liftIO $ do</span>
<span class="lineno">  586 </span><span class="spaces">                  </span><span class="istickedoff">-- Now that we're failing, do the additional work of figuring out</span>
<span class="lineno">  587 </span><span class="spaces">                  </span><span class="istickedoff">-- if any overrides had symbolically false preconditions</span>
<span class="lineno">  588 </span><span class="spaces">                  </span><span class="istickedoff">symFalse &lt;- catMaybes &lt;$&gt; (forM unknown $ \owp -&gt;</span>
<span class="lineno">  589 </span><span class="spaces">                    </span><span class="istickedoff">findFalsePreconditions bak owp &lt;&amp;&gt;</span>
<span class="lineno">  590 </span><span class="spaces">                      </span><span class="istickedoff">\case</span>
<span class="lineno">  591 </span><span class="spaces">                        </span><span class="istickedoff">[] -&gt; Nothing</span>
<span class="lineno">  592 </span><span class="spaces">                        </span><span class="istickedoff">ps -&gt; <span class="nottickedoff">Just (owp, ps)</span>)</span>
<span class="lineno">  593 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  594 </span><span class="spaces">                  </span><span class="istickedoff">prettyArgs &lt;-</span>
<span class="lineno">  595 </span><span class="spaces">                    </span><span class="istickedoff">ppArgs <span class="nottickedoff">sym</span> cc (NE.head css) (Crucible.RegMap args)</span>
<span class="lineno">  596 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  597 </span><span class="spaces">                  </span><span class="istickedoff">unsat &lt;-</span>
<span class="lineno">  598 </span><span class="spaces">                    </span><span class="istickedoff">filterM</span>
<span class="lineno">  599 </span><span class="spaces">                      </span><span class="istickedoff">(unsatPreconditions bak (owpPreconditions . each . _2 . W4.labeledPred))</span>
<span class="lineno">  600 </span><span class="spaces">                      </span><span class="istickedoff">branches</span>
<span class="lineno">  601 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  602 </span><span class="spaces">                  </span><span class="istickedoff">Crucible.addFailedAssertion bak</span>
<span class="lineno">  603 </span><span class="spaces">                    </span><span class="istickedoff">(Crucible.GenericSimError (e prettyArgs symFalse unsat))</span>
<span class="lineno">  604 </span><span class="spaces">              </span><span class="istickedoff">, Just (W4.plSourceLoc call_loc)</span>
<span class="lineno">  605 </span><span class="spaces">              </span><span class="istickedoff">)</span>
<span class="lineno">  606 </span><span class="spaces">         </span><span class="istickedoff">]))</span>
<span class="lineno">  607 </span><span class="spaces">     </span><span class="istickedoff">(Crucible.RegMap args)</span>
<span class="lineno">  608 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ printOutLn opts Info $ unwords [&quot;Applied override!&quot;, fnName]</span>
<span class="lineno">  609 </span><span class="spaces">  </span><span class="istickedoff">return res</span></span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>------------------------------------------------------------------------
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>-- | Use a method spec to override the behavior of a function.
<span class="lineno">  614 </span>--   This function computes the pre-state portion of the override,
<span class="lineno">  615 </span>--   which involves reading values from arguments and memory and computing
<span class="lineno">  616 </span>--   substitutions for the setup value variables, and computing precondition
<span class="lineno">  617 </span>--   predicates.
<span class="lineno">  618 </span>methodSpecHandler_prestate ::
<span class="lineno">  619 </span>  forall arch ctx.
<span class="lineno">  620 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  621 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  622 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  623 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  624 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  625 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  626 </span>  ) =&gt;
<span class="lineno">  627 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  628 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  629 </span>  LLVMCrucibleContext arch     {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  630 </span>  Ctx.Assignment (Crucible.RegEntry Sym) ctx
<span class="lineno">  631 </span>                           {- ^ the arguments to the function -} -&gt;
<span class="lineno">  632 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ specification for current function override  -} -&gt;
<span class="lineno">  633 </span>  OverrideMatcher (LLVM arch) RO ()
<span class="lineno">  634 </span><span class="decl"><span class="istickedoff">methodSpecHandler_prestate opts sc cc args cs =</span>
<span class="lineno">  635 </span><span class="spaces">    </span><span class="istickedoff">do let expectedArgTypes = Map.elems (cs ^. MS.csArgBindings)</span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  637 </span><span class="spaces">       </span><span class="istickedoff">sym &lt;- Ov.getSymInterface</span>
<span class="lineno">  638 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  639 </span><span class="spaces">       </span><span class="istickedoff">let aux (memTy, setupVal) (Crucible.AnyValue tyrep val) =</span>
<span class="lineno">  640 </span><span class="spaces">             </span><span class="istickedoff">do storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno">  641 </span><span class="spaces">                </span><span class="istickedoff">pmv &lt;- Crucible.packMemValue <span class="nottickedoff">sym</span> storTy tyrep val</span>
<span class="lineno">  642 </span><span class="spaces">                </span><span class="istickedoff">return (pmv, memTy, setupVal)</span>
<span class="lineno">  643 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  644 </span><span class="spaces">       </span><span class="istickedoff">-- todo: fail if list lengths mismatch</span>
<span class="lineno">  645 </span><span class="spaces">       </span><span class="istickedoff">xs &lt;- liftIO (zipWithM aux expectedArgTypes (assignmentToList args))</span>
<span class="lineno">  646 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  647 </span><span class="spaces">       </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno">  648 </span><span class="spaces">                </span><span class="istickedoff">{ MS.conditionLoc  = cs ^. MS.csLoc</span>
<span class="lineno">  649 </span><span class="spaces">                </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">mempty</span> -- TODO? should `execute_func` track tags?</span>
<span class="lineno">  650 </span><span class="spaces">                </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;formal argument matching&quot;</span></span>
<span class="lineno">  651 </span><span class="spaces">                </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno">  652 </span><span class="spaces">                </span><span class="istickedoff">}</span>
<span class="lineno">  653 </span><span class="spaces">       </span><span class="istickedoff">sequence_ [ matchArg <span class="nottickedoff">opts</span> sc cc cs <span class="nottickedoff">PreState</span> md x y z | (x, y, z) &lt;- xs]</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  655 </span><span class="spaces">       </span><span class="istickedoff">learnCond <span class="nottickedoff">opts</span> sc cc cs PreState (cs ^. MS.csGlobalAllocs) Map.empty (cs ^. MS.csPreState)</span></span>
<span class="lineno">  656 </span>
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>-- | Use a method spec to override the behavior of a function.
<span class="lineno">  659 </span>--   This function computes the post-state portion of the override,
<span class="lineno">  660 </span>--   which involves writing values into memory, computing the return value,
<span class="lineno">  661 </span>--   and computing postcondition predicates.
<span class="lineno">  662 </span>methodSpecHandler_poststate ::
<span class="lineno">  663 </span>  forall arch ret.
<span class="lineno">  664 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  665 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno">  666 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  667 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  668 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  669 </span>  ) =&gt;
<span class="lineno">  670 </span>  Options                  {- ^ output/verbosity options                     -} -&gt;
<span class="lineno">  671 </span>  SharedContext            {- ^ context for constructing SAW terms           -} -&gt;
<span class="lineno">  672 </span>  LLVMCrucibleContext arch     {- ^ context for interacting with Crucible        -} -&gt;
<span class="lineno">  673 </span>  Crucible.TypeRepr ret    {- ^ type representation of function return value -} -&gt;
<span class="lineno">  674 </span>  MS.CrucibleMethodSpecIR (LLVM arch)     {- ^ specification for current function override  -} -&gt;
<span class="lineno">  675 </span>  OverrideMatcher (LLVM arch) RW (Crucible.RegValue Sym ret)
<span class="lineno">  676 </span><span class="decl"><span class="istickedoff">methodSpecHandler_poststate opts sc cc retTy cs =</span>
<span class="lineno">  677 </span><span class="spaces">  </span><span class="istickedoff">do executeCond <span class="nottickedoff">opts</span> sc cc cs (cs ^. MS.csPostState)</span>
<span class="lineno">  678 </span><span class="spaces">     </span><span class="istickedoff">computeReturnValue <span class="nottickedoff">opts</span> cc sc cs retTy (cs ^. MS.csRetValue)</span></span>
<span class="lineno">  679 </span>
<span class="lineno">  680 </span>-- learn pre/post condition
<span class="lineno">  681 </span>learnCond ::
<span class="lineno">  682 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  683 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  684 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  685 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  686 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  687 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  688 </span>  ) =&gt;
<span class="lineno">  689 </span>  Options -&gt;
<span class="lineno">  690 </span>  SharedContext -&gt;
<span class="lineno">  691 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  692 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  693 </span>  PrePost -&gt;
<span class="lineno">  694 </span>  [MS.AllocGlobal (LLVM arch)] -&gt;
<span class="lineno">  695 </span>  Map AllocIndex (MS.AllocSpec (LLVM arch)) -&gt;
<span class="lineno">  696 </span>  MS.StateSpec (LLVM arch) -&gt;
<span class="lineno">  697 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  698 </span><span class="decl"><span class="istickedoff">learnCond opts sc cc cs prepost globals extras ss =</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="istickedoff">do let loc = cs ^. MS.csLoc</span>
<span class="lineno">  700 </span><span class="spaces">     </span><span class="istickedoff">matchPointsTos <span class="nottickedoff">opts</span> sc cc cs prepost (ss ^. MS.csPointsTos)</span>
<span class="lineno">  701 </span><span class="spaces">     </span><span class="istickedoff">traverse_ (learnSetupCondition <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">cs</span> prepost) (ss ^. MS.csConditions)</span>
<span class="lineno">  702 </span><span class="spaces">     </span><span class="istickedoff">assertTermEqualities sc cc</span>
<span class="lineno">  703 </span><span class="spaces">     </span><span class="istickedoff">enforcePointerValidity sc cc ss</span>
<span class="lineno">  704 </span><span class="spaces">     </span><span class="istickedoff">enforceDisjointness sc cc loc globals extras ss</span>
<span class="lineno">  705 </span><span class="spaces">     </span><span class="istickedoff">enforceCompleteSubstitution loc ss</span></span>
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>assertTermEqualities ::
<span class="lineno">  709 </span>  (?w4EvalTactic :: W4EvalTactic) =&gt;
<span class="lineno">  710 </span>  SharedContext -&gt;
<span class="lineno">  711 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  712 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  713 </span><span class="decl"><span class="istickedoff">assertTermEqualities sc cc = do</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff">let sym = cc ^. ccSym</span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="istickedoff">let assertTermEquality (cond, t, md, e) = do</span>
<span class="lineno">  716 </span><span class="spaces">        </span><span class="istickedoff">p &lt;- instantiateExtResolveSAWPred sc cc t</span>
<span class="lineno">  717 </span><span class="spaces">        </span><span class="istickedoff">p' &lt;- liftIO $ W4.impliesPred sym cond p</span>
<span class="lineno">  718 </span><span class="spaces">        </span><span class="istickedoff">addAssert p' md e</span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="istickedoff">traverse_ assertTermEquality =&lt;&lt; OM (use termEqs)</span></span>
<span class="lineno">  720 </span>
<span class="lineno">  721 </span>
<span class="lineno">  722 </span>-- execute a pre/post condition
<span class="lineno">  723 </span>executeCond :: ( ?lc :: Crucible.TypeContext
<span class="lineno">  724 </span>               , ?memOpts :: Crucible.MemOptions
<span class="lineno">  725 </span>               , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  726 </span>               , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  727 </span>               , Crucible.HasLLVMAnn Sym
<span class="lineno">  728 </span>               )
<span class="lineno">  729 </span>            =&gt; Options
<span class="lineno">  730 </span>            -&gt; SharedContext
<span class="lineno">  731 </span>            -&gt; LLVMCrucibleContext arch
<span class="lineno">  732 </span>            -&gt; MS.CrucibleMethodSpecIR (LLVM arch)
<span class="lineno">  733 </span>            -&gt; MS.StateSpec (LLVM arch)
<span class="lineno">  734 </span>            -&gt; OverrideMatcher (LLVM arch) RW ()
<span class="lineno">  735 </span><span class="decl"><span class="istickedoff">executeCond opts sc cc cs ss = do</span>
<span class="lineno">  736 </span><span class="spaces">  </span><span class="istickedoff">refreshTerms sc ss</span>
<span class="lineno">  737 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  738 </span><span class="spaces">  </span><span class="istickedoff">traverse_ <span class="nottickedoff">(executeAllocation opts sc cc)</span> (Map.assocs (ss ^. MS.csAllocs))</span>
<span class="lineno">  739 </span><span class="spaces">  </span><span class="istickedoff">overwritten_allocs &lt;- invalidateMutableAllocs <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc cs</span>
<span class="lineno">  740 </span><span class="spaces">  </span><span class="istickedoff">traverse_</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">(executePointsTo <span class="nottickedoff">opts</span> sc cc cs overwritten_allocs)</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">(ss ^. MS.csPointsTos)</span>
<span class="lineno">  743 </span><span class="spaces">  </span><span class="istickedoff">traverse_ (executeSetupCondition <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">cs</span>) (ss ^. MS.csConditions)</span></span>
<span class="lineno">  744 </span>
<span class="lineno">  745 </span>------------------------------------------------------------------------
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>-- | Generate assertions that all of the memory regions matched by an
<span class="lineno">  748 </span>-- override's precondition are allocated, and meet the appropriate
<span class="lineno">  749 </span>-- requirements for alignment and mutability.
<span class="lineno">  750 </span>enforcePointerValidity ::
<span class="lineno">  751 </span>  (?lc :: Crucible.TypeContext, ?memOpts::Crucible.MemOptions, ?w4EvalTactic :: W4EvalTactic, ?checkAllocSymInit :: Bool, Crucible.HasPtrWidth (Crucible.ArchWidth arch), Crucible.HasLLVMAnn Sym) =&gt;
<span class="lineno">  752 </span>  SharedContext -&gt;
<span class="lineno">  753 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  754 </span>  MS.StateSpec (LLVM arch) -&gt;
<span class="lineno">  755 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  756 </span><span class="decl"><span class="istickedoff">enforcePointerValidity sc cc ss =</span>
<span class="lineno">  757 </span><span class="spaces">  </span><span class="istickedoff">do sym &lt;- Ov.getSymInterface</span>
<span class="lineno">  758 </span><span class="spaces">     </span><span class="istickedoff">sub &lt;- OM (use setupValueSub) -- Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch))</span>
<span class="lineno">  759 </span><span class="spaces">     </span><span class="istickedoff">let allocs = view MS.csAllocs ss -- Map AllocIndex LLVMAllocSpec</span>
<span class="lineno">  760 </span><span class="spaces">     </span><span class="istickedoff">let mems = Map.elems $ Map.intersectionWith (,) allocs sub</span>
<span class="lineno">  761 </span><span class="spaces">     </span><span class="istickedoff">let w = Crucible.PtrWidth</span>
<span class="lineno">  762 </span><span class="spaces">     </span><span class="istickedoff">let memVar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno">  763 </span><span class="spaces">     </span><span class="istickedoff">mem &lt;- readGlobal memVar</span>
<span class="lineno">  764 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  765 </span><span class="spaces">     </span><span class="istickedoff">sequence_</span>
<span class="lineno">  766 </span><span class="spaces">       </span><span class="istickedoff">[ do psz' &lt;- instantiateExtResolveSAWSymBV sc cc Crucible.PtrWidth psz</span>
<span class="lineno">  767 </span><span class="spaces">            </span><span class="istickedoff">c &lt;-</span>
<span class="lineno">  768 </span><span class="spaces">              </span><span class="istickedoff">liftIO $</span>
<span class="lineno">  769 </span><span class="spaces">              </span><span class="istickedoff">Crucible.isAllocatedAlignedPointer sym w alignment mut ptr (Just psz') mem</span>
<span class="lineno">  770 </span><span class="spaces">            </span><span class="istickedoff">let ploc = MS.conditionLoc allocMd</span>
<span class="lineno">  771 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  772 </span><span class="spaces">            </span><span class="istickedoff">let msg =</span>
<span class="lineno">  773 </span><span class="spaces">                  </span><span class="istickedoff">&quot;Pointer not valid:&quot;</span>
<span class="lineno">  774 </span><span class="spaces">                  </span><span class="istickedoff">++ &quot;\n  base = &quot; ++ show (Crucible.ppPtr ptr)</span>
<span class="lineno">  775 </span><span class="spaces">                  </span><span class="istickedoff">++ &quot;\n  size = &quot; ++ showTerm psz</span>
<span class="lineno">  776 </span><span class="spaces">                  </span><span class="istickedoff">++ &quot;\n  required alignment = &quot; ++ show (Crucible.fromAlignment alignment) ++ &quot;-byte&quot;</span>
<span class="lineno">  777 </span><span class="spaces">                  </span><span class="istickedoff">++ &quot;\n  required mutability = &quot; ++ show mut</span>
<span class="lineno">  778 </span><span class="spaces">            </span><span class="istickedoff">addAssert c <span class="nottickedoff">allocMd</span> $ Crucible.SimError ploc $</span>
<span class="lineno">  779 </span><span class="spaces">              </span><span class="istickedoff">Crucible.AssertFailureSimError msg &quot;&quot;</span>
<span class="lineno">  780 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  781 </span><span class="spaces">            </span><span class="istickedoff">case initialization of</span>
<span class="lineno">  782 </span><span class="spaces">              </span><span class="istickedoff">LLVMAllocSpecSymbolicInitialization</span>
<span class="lineno">  783 </span><span class="spaces">                </span><span class="istickedoff">| ?checkAllocSymInit -&gt;</span>
<span class="lineno">  784 </span><span class="spaces">                  </span><span class="istickedoff">do maybeOk &lt;- liftIO $ checkMemLoad sym mem ptr psz' alignment</span>
<span class="lineno">  785 </span><span class="spaces">                     </span><span class="istickedoff">let msg' = PP.vcat $ map (PP.pretty . unwords)</span>
<span class="lineno">  786 </span><span class="spaces">                           </span><span class="istickedoff">[ [ &quot;Memory region not initialized:&quot; ]</span>
<span class="lineno">  787 </span><span class="spaces">                           </span><span class="istickedoff">, [ &quot;  pointer =&quot;, show (Crucible.ppPtr ptr) ]</span>
<span class="lineno">  788 </span><span class="spaces">                           </span><span class="istickedoff">, [ &quot;  size =&quot;, showTerm psz ]</span>
<span class="lineno">  789 </span><span class="spaces">                           </span><span class="istickedoff">]</span>
<span class="lineno">  790 </span><span class="spaces">                     </span><span class="istickedoff">case maybeOk of</span>
<span class="lineno">  791 </span><span class="spaces">                       </span><span class="istickedoff">Just ok -&gt;</span>
<span class="lineno">  792 </span><span class="spaces">                         </span><span class="istickedoff">addAssert ok <span class="nottickedoff">allocMd</span> $ Crucible.SimError (MS.conditionLoc allocMd) $</span>
<span class="lineno">  793 </span><span class="spaces">                           </span><span class="istickedoff">Crucible.AssertFailureSimError (show msg') &quot;&quot;</span>
<span class="lineno">  794 </span><span class="spaces">                       </span><span class="istickedoff">Nothing -&gt; failure ploc (BadPointerLoad (Right msg') &quot;&quot;)</span>
<span class="lineno">  795 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  796 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  797 </span><span class="spaces">       </span><span class="istickedoff">| (LLVMAllocSpec mut _pty alignment psz allocMd fresh initialization, ptr) &lt;- mems</span>
<span class="lineno">  798 </span><span class="spaces">       </span><span class="istickedoff">, not fresh -- Fresh symbolic pointers are not assumed to be valid; don't check them</span>
<span class="lineno">  799 </span><span class="spaces">       </span><span class="istickedoff">]</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>checkMemLoad ::
<span class="lineno">  802 </span>  (?memOpts::Crucible.MemOptions, Crucible.IsSymInterface sym, Crucible.HasPtrWidth wptr, Crucible.HasLLVMAnn sym) =&gt;
<span class="lineno">  803 </span>  sym -&gt;
<span class="lineno">  804 </span>  Crucible.MemImpl sym -&gt;
<span class="lineno">  805 </span>  Crucible.LLVMPtr sym wptr -&gt;
<span class="lineno">  806 </span>  W4.SymBV sym wptr -&gt;
<span class="lineno">  807 </span>  Crucible.Alignment -&gt;
<span class="lineno">  808 </span>  IO (Maybe (W4.Pred sym))
<span class="lineno">  809 </span><span class="decl"><span class="istickedoff">checkMemLoad sym mem ptr sz align =</span>
<span class="lineno">  810 </span><span class="spaces">  </span><span class="istickedoff">case BV.asNatural &lt;$&gt; W4.asBV sz of</span>
<span class="lineno">  811 </span><span class="spaces">    </span><span class="istickedoff">Just n -&gt; do</span>
<span class="lineno">  812 </span><span class="spaces">      </span><span class="istickedoff">res &lt;- Crucible.loadRaw sym mem ptr (Crucible.arrayType n $ Crucible.bitvectorType 1) align</span>
<span class="lineno">  813 </span><span class="spaces">      </span><span class="istickedoff">case res of</span>
<span class="lineno">  814 </span><span class="spaces">        </span><span class="istickedoff">Crucible.NoErr pred_ _val -&gt; do</span>
<span class="lineno">  815 </span><span class="spaces">          </span><span class="istickedoff">return $ Just pred_</span>
<span class="lineno">  816 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; return Nothing</span>
<span class="lineno">  817 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  818 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">maybe_allocation_array &lt;- Crucible.asMemAllocationArrayStore sym Crucible.PtrWidth ptr (Crucible.memImplHeap mem)</span></span>
<span class="lineno">  819 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case maybe_allocation_array of</span></span>
<span class="lineno">  820 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just (ok, _arr, _sz) -&gt; return $ Just ok</span></span>
<span class="lineno">  821 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; return Nothing</span></span></span>
<span class="lineno">  822 </span>
<span class="lineno">  823 </span>------------------------------------------------------------------------
<span class="lineno">  824 </span>
<span class="lineno">  825 </span>-- | Generate assertions that all of the memory allocations matched by
<span class="lineno">  826 </span>-- an override's precondition are disjoint. Read-only allocations are
<span class="lineno">  827 </span>-- allowed to alias other read-only allocations, however.
<span class="lineno">  828 </span>enforceDisjointness ::
<span class="lineno">  829 </span>  (?lc :: Crucible.TypeContext, ?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  830 </span>  SharedContext -&gt;
<span class="lineno">  831 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  832 </span>  W4.ProgramLoc -&gt;
<span class="lineno">  833 </span>  [MS.AllocGlobal (LLVM arch)] -&gt;
<span class="lineno">  834 </span>  -- | Additional allocations to check disjointness from (from prestate)
<span class="lineno">  835 </span>  (Map AllocIndex (MS.AllocSpec (LLVM arch))) -&gt;
<span class="lineno">  836 </span>  MS.StateSpec (LLVM arch) -&gt;
<span class="lineno">  837 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  838 </span><span class="decl"><span class="istickedoff">enforceDisjointness sc cc loc globals extras ss =</span>
<span class="lineno">  839 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  840 </span><span class="spaces">  </span><span class="istickedoff">do let sym = backendGetSym bak</span>
<span class="lineno">  841 </span><span class="spaces">     </span><span class="istickedoff">sub &lt;- OM (use setupValueSub)</span>
<span class="lineno">  842 </span><span class="spaces">     </span><span class="istickedoff">mem &lt;- readGlobal $ Crucible.llvmMemVar $ ccLLVMContext cc</span>
<span class="lineno">  843 </span><span class="spaces">     </span><span class="istickedoff">-- every csAllocs entry should be present in sub</span>
<span class="lineno">  844 </span><span class="spaces">     </span><span class="istickedoff">let mems = Map.elems $ Map.intersectionWith (,) (view MS.csAllocs ss) sub</span>
<span class="lineno">  845 </span><span class="spaces">     </span><span class="istickedoff">let mems2 = Map.elems $ Map.intersectionWith (,) extras sub</span>
<span class="lineno">  846 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  847 </span><span class="spaces">     </span><span class="istickedoff">-- Ensure that all RW regions are disjoint from each other, and</span>
<span class="lineno">  848 </span><span class="spaces">     </span><span class="istickedoff">-- that all RW regions are disjoint from all RO regions.</span>
<span class="lineno">  849 </span><span class="spaces">     </span><span class="istickedoff">sequence_</span>
<span class="lineno">  850 </span><span class="spaces">        </span><span class="istickedoff">[ enforceDisjointAllocSpec sc cc sym loc p q</span>
<span class="lineno">  851 </span><span class="spaces">        </span><span class="istickedoff">| p : ps &lt;- tails mems</span>
<span class="lineno">  852 </span><span class="spaces">        </span><span class="istickedoff">, q &lt;- ps ++ mems2</span>
<span class="lineno">  853 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  854 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  855 </span><span class="spaces">     </span><span class="istickedoff">-- Ensure that all RW and RO regions are disjoint from mutable</span>
<span class="lineno">  856 </span><span class="spaces">     </span><span class="istickedoff">-- global regions.</span>
<span class="lineno">  857 </span><span class="spaces">     </span><span class="istickedoff">let resolveAllocGlobal g@(LLVMAllocGlobal _ nm) =</span>
<span class="lineno">  858 </span><span class="spaces">           </span><span class="istickedoff">do ptr &lt;- liftIO $ Crucible.doResolveGlobal <span class="nottickedoff">bak</span> mem nm</span>
<span class="lineno">  859 </span><span class="spaces">              </span><span class="istickedoff">pure (g, ptr)</span>
<span class="lineno">  860 </span><span class="spaces">     </span><span class="istickedoff">globals' &lt;- traverse resolveAllocGlobal globals</span>
<span class="lineno">  861 </span><span class="spaces">     </span><span class="istickedoff">sequence_</span>
<span class="lineno">  862 </span><span class="spaces">       </span><span class="istickedoff">[ enforceDisjointAllocGlobal sym loc p q</span>
<span class="lineno">  863 </span><span class="spaces">       </span><span class="istickedoff">| p &lt;- mems</span>
<span class="lineno">  864 </span><span class="spaces">       </span><span class="istickedoff">, q &lt;- globals'</span>
<span class="lineno">  865 </span><span class="spaces">       </span><span class="istickedoff">]</span></span>
<span class="lineno">  866 </span>
<span class="lineno">  867 </span>-- | Assert that two LLVM allocations are disjoint from each other, if
<span class="lineno">  868 </span>-- they need to be. If both allocations are read-only, then they need
<span class="lineno">  869 </span>-- not be disjoint. Similarly, fresh pointers need not be checked for
<span class="lineno">  870 </span>-- disjointness.
<span class="lineno">  871 </span>enforceDisjointAllocSpec ::
<span class="lineno">  872 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  873 </span>  SharedContext -&gt;
<span class="lineno">  874 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  875 </span>  Sym -&gt;
<span class="lineno">  876 </span>  W4.ProgramLoc -&gt;
<span class="lineno">  877 </span>  (LLVMAllocSpec, LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno">  878 </span>  (LLVMAllocSpec, LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno">  879 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  880 </span><span class="decl"><span class="istickedoff">enforceDisjointAllocSpec sc cc sym loc</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">(LLVMAllocSpec pmut _pty _palign psz pMd pfresh _p_sym_init, p)</span>
<span class="lineno">  882 </span><span class="spaces">  </span><span class="istickedoff">(LLVMAllocSpec qmut _qty _qalign qsz qMd qfresh _q_sym_init, q)</span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="istickedoff">| (pmut, qmut) == (Crucible.Immutable, Crucible.Immutable) =</span>
<span class="lineno">  884 </span><span class="spaces">    </span><span class="istickedoff">pure <span class="nottickedoff">()</span> -- Read-only allocations may alias each other</span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">pfresh || qfresh</span> =</span>
<span class="lineno">  886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure ()</span> -- Fresh pointers need not be disjoint</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">do liftIO $ W4.setCurrentProgramLoc sym (MS.conditionLoc pMd)</span>
<span class="lineno">  889 </span><span class="spaces">     </span><span class="istickedoff">psz' &lt;- instantiateExtResolveSAWSymBV sc cc Crucible.PtrWidth psz</span>
<span class="lineno">  890 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ W4.setCurrentProgramLoc sym (MS.conditionLoc qMd)</span>
<span class="lineno">  891 </span><span class="spaces">     </span><span class="istickedoff">qsz' &lt;- instantiateExtResolveSAWSymBV sc cc Crucible.PtrWidth qsz</span>
<span class="lineno">  892 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ W4.setCurrentProgramLoc sym loc</span>
<span class="lineno">  893 </span><span class="spaces">     </span><span class="istickedoff">c &lt;- liftIO $ Crucible.buildDisjointRegionsAssertion</span>
<span class="lineno">  894 </span><span class="spaces">       </span><span class="istickedoff">sym Crucible.PtrWidth</span>
<span class="lineno">  895 </span><span class="spaces">       </span><span class="istickedoff">p psz'</span>
<span class="lineno">  896 </span><span class="spaces">       </span><span class="istickedoff">q qsz'</span>
<span class="lineno">  897 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno">  898 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno">  899 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = mempty</span></span>
<span class="lineno">  900 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;memory disjointness&quot;</span></span>
<span class="lineno">  901 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno">  902 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  903 </span><span class="spaces">     </span><span class="istickedoff">let msg =</span>
<span class="lineno">  904 </span><span class="spaces">           </span><span class="istickedoff">&quot;Memory regions not disjoint:&quot;</span>
<span class="lineno">  905 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  (base=&quot; ++ show (Crucible.ppPtr p) ++ &quot;, size=&quot; ++ showTerm psz ++ &quot;)&quot;</span>
<span class="lineno">  906 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  from &quot; ++ ppProgramLoc (MS.conditionLoc pMd)</span>
<span class="lineno">  907 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  and &quot;</span>
<span class="lineno">  908 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  (base=&quot; ++ show (Crucible.ppPtr q) ++ &quot;, size=&quot; ++ showTerm qsz ++ &quot;)&quot;</span>
<span class="lineno">  909 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  from &quot; ++ ppProgramLoc (MS.conditionLoc qMd)</span>
<span class="lineno">  910 </span><span class="spaces">     </span><span class="istickedoff">addAssert c <span class="nottickedoff">md</span> $ Crucible.SimError loc $</span>
<span class="lineno">  911 </span><span class="spaces">       </span><span class="istickedoff">Crucible.AssertFailureSimError msg &quot;&quot;</span></span>
<span class="lineno">  912 </span>
<span class="lineno">  913 </span>-- | Assert that an LLVM allocation is disjoint from a global region.
<span class="lineno">  914 </span>enforceDisjointAllocGlobal ::
<span class="lineno">  915 </span>  Sym -&gt; W4.ProgramLoc -&gt;
<span class="lineno">  916 </span>  (LLVMAllocSpec, LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno">  917 </span>  (LLVMAllocGlobal arch, LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno">  918 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  919 </span><span class="decl"><span class="istickedoff">enforceDisjointAllocGlobal sym loc</span>
<span class="lineno">  920 </span><span class="spaces">  </span><span class="istickedoff">(LLVMAllocSpec _pmut _pty _palign psz pMd pfresh _p_sym_init, p)</span>
<span class="lineno">  921 </span><span class="spaces">  </span><span class="istickedoff">(LLVMAllocGlobal qloc (L.Symbol qname), q)</span>
<span class="lineno">  922 </span><span class="spaces">  </span><span class="istickedoff">| pfresh =</span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="istickedoff">pure <span class="nottickedoff">()</span> -- Fresh pointers need not be disjoint</span>
<span class="lineno">  924 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  925 </span><span class="spaces">  </span><span class="istickedoff">do let Crucible.LLVMPointer pblk _ = p</span>
<span class="lineno">  926 </span><span class="spaces">     </span><span class="istickedoff">let Crucible.LLVMPointer qblk _ = q</span>
<span class="lineno">  927 </span><span class="spaces">     </span><span class="istickedoff">c &lt;- liftIO $ W4.notPred sym =&lt;&lt; W4.natEq sym pblk qblk</span>
<span class="lineno">  928 </span><span class="spaces">     </span><span class="istickedoff">let msg =</span>
<span class="lineno">  929 </span><span class="spaces">           </span><span class="istickedoff">&quot;Memory regions not disjoint:&quot;</span>
<span class="lineno">  930 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  (base=&quot; ++ show (Crucible.ppPtr p) ++ &quot;, size=&quot; ++ showTerm psz ++ &quot;)&quot;</span>
<span class="lineno">  931 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  from &quot; ++ ppProgramLoc (MS.conditionLoc pMd)</span>
<span class="lineno">  932 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  and &quot;</span>
<span class="lineno">  933 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  global &quot; ++ show qname ++ &quot; (base=&quot; ++ show (Crucible.ppPtr q) ++ &quot;)&quot;</span>
<span class="lineno">  934 </span><span class="spaces">           </span><span class="istickedoff">++ &quot;\n  from &quot; ++ ppProgramLoc qloc</span>
<span class="lineno">  935 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno">  936 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc  = loc</span></span>
<span class="lineno">  937 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = mempty</span></span>
<span class="lineno">  938 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;global region disjointness&quot;</span></span>
<span class="lineno">  939 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno">  940 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno">  941 </span><span class="spaces">     </span><span class="istickedoff">addAssert c <span class="nottickedoff">md</span> $ Crucible.SimError loc $</span>
<span class="lineno">  942 </span><span class="spaces">       </span><span class="istickedoff">Crucible.AssertFailureSimError msg &quot;&quot;</span></span>
<span class="lineno">  943 </span>
<span class="lineno">  944 </span>ppProgramLoc :: W4.ProgramLoc -&gt; String
<span class="lineno">  945 </span><span class="decl"><span class="istickedoff">ppProgramLoc loc =</span>
<span class="lineno">  946 </span><span class="spaces">  </span><span class="istickedoff">show (W4.plFunction loc) ++ &quot; (&quot; ++ show (W4.plSourceLoc loc) ++ &quot;)&quot;</span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>------------------------------------------------------------------------
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>-- | For each points-to statement read the memory value through the
<span class="lineno">  951 </span>-- given pointer (lhs) and match the value against the given pattern
<span class="lineno">  952 </span>-- (rhs).  Statements are processed in dependency order: a points-to
<span class="lineno">  953 </span>-- statement cannot be executed until bindings for any/all lhs
<span class="lineno">  954 </span>-- variables exist.
<span class="lineno">  955 </span>matchPointsTos :: forall arch md.
<span class="lineno">  956 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  957 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno">  958 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  959 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  960 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  961 </span>  ) =&gt;
<span class="lineno">  962 </span>  Options          {- ^ saw script print out opts -} -&gt;
<span class="lineno">  963 </span>  SharedContext    {- ^ term construction context -} -&gt;
<span class="lineno">  964 </span>  LLVMCrucibleContext arch {- ^ simulator context     -} -&gt;
<span class="lineno">  965 </span>  MS.CrucibleMethodSpecIR (LLVM arch)                               -&gt;
<span class="lineno">  966 </span>  PrePost                                            -&gt;
<span class="lineno">  967 </span>  [PointsTo (LLVM arch)]       {- ^ points-tos                -} -&gt;
<span class="lineno">  968 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno">  969 </span><span class="decl"><span class="istickedoff">matchPointsTos opts sc cc spec prepost = go False []</span>
<span class="lineno">  970 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  971 </span><span class="spaces">    </span><span class="istickedoff">go ::</span>
<span class="lineno">  972 </span><span class="spaces">      </span><span class="istickedoff">Bool       {- progress indicator -} -&gt;</span>
<span class="lineno">  973 </span><span class="spaces">      </span><span class="istickedoff">[PointsTo (LLVM arch)] {- delayed conditions -} -&gt;</span>
<span class="lineno">  974 </span><span class="spaces">      </span><span class="istickedoff">[PointsTo (LLVM arch)] {- queued conditions  -} -&gt;</span>
<span class="lineno">  975 </span><span class="spaces">      </span><span class="istickedoff">OverrideMatcher (LLVM arch) md ()</span>
<span class="lineno">  976 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">-- all conditions processed, success</span>
<span class="lineno">  978 </span><span class="spaces">    </span><span class="istickedoff">go _ [] [] = return <span class="nottickedoff">()</span></span>
<span class="lineno">  979 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  980 </span><span class="spaces">    </span><span class="istickedoff">-- not all conditions processed, no progress, failure</span>
<span class="lineno">  981 </span><span class="spaces">    </span><span class="istickedoff">go False delayed [] = <span class="nottickedoff">failure (spec ^. MS.csLoc) (AmbiguousPointsTos delayed)</span></span>
<span class="lineno">  982 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">-- not all conditions processed, progress made, resume delayed conditions</span>
<span class="lineno">  984 </span><span class="spaces">    </span><span class="istickedoff">go True delayed [] = go False [] delayed</span>
<span class="lineno">  985 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  986 </span><span class="spaces">    </span><span class="istickedoff">-- progress the next points-to in the work queue</span>
<span class="lineno">  987 </span><span class="spaces">    </span><span class="istickedoff">go progress delayed (c:cs) =</span>
<span class="lineno">  988 </span><span class="spaces">      </span><span class="istickedoff">do ready &lt;- checkPointsTo c</span>
<span class="lineno">  989 </span><span class="spaces">         </span><span class="istickedoff">if ready then</span>
<span class="lineno">  990 </span><span class="spaces">           </span><span class="istickedoff">do err &lt;- learnPointsTo <span class="nottickedoff">opts</span> sc cc spec prepost c</span>
<span class="lineno">  991 </span><span class="spaces">              </span><span class="istickedoff">case err of</span>
<span class="lineno">  992 </span><span class="spaces">                </span><span class="istickedoff">Just msg -&gt; do</span>
<span class="lineno">  993 </span><span class="spaces">                  </span><span class="istickedoff">doc &lt;- ppPointsToAsLLVMVal <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec c</span>
<span class="lineno">  994 </span><span class="spaces">                  </span><span class="istickedoff">failure <span class="nottickedoff">(llvmPointsToProgramLoc c)</span> <span class="nottickedoff">(BadPointerLoad (Right doc) msg)</span></span>
<span class="lineno">  995 </span><span class="spaces">                </span><span class="istickedoff">Nothing  -&gt; go True delayed cs</span>
<span class="lineno">  996 </span><span class="spaces">         </span><span class="istickedoff">else</span>
<span class="lineno">  997 </span><span class="spaces">           </span><span class="istickedoff">do go progress (c:delayed) cs</span>
<span class="lineno">  998 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  999 </span><span class="spaces">    </span><span class="istickedoff">-- determine if a precondition is ready to be checked</span>
<span class="lineno"> 1000 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo :: PointsTo (LLVM arch) -&gt; OverrideMatcher (LLVM arch) md Bool</span>
<span class="lineno"> 1001 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo (LLVMPointsTo _loc _ p _) = checkSetupValue p</span>
<span class="lineno"> 1002 </span><span class="spaces">    </span><span class="istickedoff">checkPointsTo (LLVMPointsToBitfield _loc p _ _) = checkSetupValue p</span>
<span class="lineno"> 1003 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1004 </span><span class="spaces">    </span><span class="istickedoff">checkSetupValue :: SetupValue (LLVM arch) -&gt; OverrideMatcher (LLVM arch) md Bool</span>
<span class="lineno"> 1005 </span><span class="spaces">    </span><span class="istickedoff">checkSetupValue v =</span>
<span class="lineno"> 1006 </span><span class="spaces">      </span><span class="istickedoff">do m &lt;- OM (use setupValueSub)</span>
<span class="lineno"> 1007 </span><span class="spaces">         </span><span class="istickedoff">return (all (`Map.member` m) (setupVars v))</span>
<span class="lineno"> 1008 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff">-- Compute the set of variable identifiers in a 'SetupValue'</span>
<span class="lineno"> 1010 </span><span class="spaces">    </span><span class="istickedoff">setupVars :: SetupValue (LLVM arch) -&gt; Set AllocIndex</span>
<span class="lineno"> 1011 </span><span class="spaces">    </span><span class="istickedoff">setupVars v =</span>
<span class="lineno"> 1012 </span><span class="spaces">      </span><span class="istickedoff">case v of</span>
<span class="lineno"> 1013 </span><span class="spaces">        </span><span class="istickedoff">SetupVar i                 -&gt; Set.singleton i</span>
<span class="lineno"> 1014 </span><span class="spaces">        </span><span class="istickedoff">SetupStruct _ xs           -&gt; <span class="nottickedoff">foldMap setupVars xs</span></span>
<span class="lineno"> 1015 </span><span class="spaces">        </span><span class="istickedoff">SetupEnum  empty           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1016 </span><span class="spaces">        </span><span class="istickedoff">SetupTuple empty _         -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1017 </span><span class="spaces">        </span><span class="istickedoff">SetupSlice empty           -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1018 </span><span class="spaces">        </span><span class="istickedoff">SetupArray _ xs            -&gt; <span class="nottickedoff">foldMap setupVars xs</span></span>
<span class="lineno"> 1019 </span><span class="spaces">        </span><span class="istickedoff">SetupElem _ x _            -&gt; setupVars x</span>
<span class="lineno"> 1020 </span><span class="spaces">        </span><span class="istickedoff">SetupField _ x _           -&gt; setupVars x</span>
<span class="lineno"> 1021 </span><span class="spaces">        </span><span class="istickedoff">SetupCast _ x              -&gt; setupVars x</span>
<span class="lineno"> 1022 </span><span class="spaces">        </span><span class="istickedoff">SetupUnion _ x _           -&gt; setupVars x</span>
<span class="lineno"> 1023 </span><span class="spaces">        </span><span class="istickedoff">SetupTerm _                -&gt; <span class="nottickedoff">Set.empty</span></span>
<span class="lineno"> 1024 </span><span class="spaces">        </span><span class="istickedoff">SetupNull _                -&gt; <span class="nottickedoff">Set.empty</span></span>
<span class="lineno"> 1025 </span><span class="spaces">        </span><span class="istickedoff">SetupGlobal _ _            -&gt; Set.empty</span>
<span class="lineno"> 1026 </span><span class="spaces">        </span><span class="istickedoff">SetupGlobalInitializer _ _ -&gt; <span class="nottickedoff">Set.empty</span></span>
<span class="lineno"> 1027 </span><span class="spaces">        </span><span class="istickedoff">SetupMux empty _ _ _       -&gt; <span class="nottickedoff">absurd empty</span></span></span>
<span class="lineno"> 1028 </span>
<span class="lineno"> 1029 </span>
<span class="lineno"> 1030 </span>------------------------------------------------------------------------
<span class="lineno"> 1031 </span>
<span class="lineno"> 1032 </span>computeReturnValue ::
<span class="lineno"> 1033 </span>  (?lc :: Crucible.TypeContext, ?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 1034 </span>  Options               {- ^ saw script debug and print options     -} -&gt;
<span class="lineno"> 1035 </span>  LLVMCrucibleContext arch  {- ^ context of the crucible simulation     -} -&gt;
<span class="lineno"> 1036 </span>  SharedContext         {- ^ context for generating saw terms       -} -&gt;
<span class="lineno"> 1037 </span>  MS.CrucibleMethodSpecIR (LLVM arch)  {- ^ method specification                   -} -&gt;
<span class="lineno"> 1038 </span>  Crucible.TypeRepr ret {- ^ representation of function return type -} -&gt;
<span class="lineno"> 1039 </span>  Maybe (SetupValue (LLVM arch)) {- ^ optional symbolic return value -} -&gt;
<span class="lineno"> 1040 </span>  OverrideMatcher (LLVM arch) md (Crucible.RegValue Sym ret)
<span class="lineno"> 1041 </span>                        {- ^ concrete return value                  -}
<span class="lineno"> 1042 </span>
<span class="lineno"> 1043 </span><span class="decl"><span class="istickedoff">computeReturnValue _opts _cc _sc spec ty Nothing =</span>
<span class="lineno"> 1044 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno"> 1045 </span><span class="spaces">    </span><span class="istickedoff">Crucible.UnitRepr -&gt; return ()</span>
<span class="lineno"> 1046 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">failure (spec ^. MS.csLoc) (BadReturnSpecification (Some ty))</span></span>
<span class="lineno"> 1047 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1048 </span><span class="spaces"></span><span class="istickedoff">computeReturnValue opts cc sc spec ty (Just val) =</span>
<span class="lineno"> 1049 </span><span class="spaces">  </span><span class="istickedoff">do (_memTy, xval) &lt;- resolveSetupValue <span class="nottickedoff">opts</span> cc sc spec ty val</span>
<span class="lineno"> 1050 </span><span class="spaces">     </span><span class="istickedoff">return xval</span></span>
<span class="lineno"> 1051 </span>
<span class="lineno"> 1052 </span>
<span class="lineno"> 1053 </span>------------------------------------------------------------------------
<span class="lineno"> 1054 </span>
<span class="lineno"> 1055 </span>-- | Assign the given pointer value to the given allocation index in
<span class="lineno"> 1056 </span>-- the current substitution. If there is already a binding for this
<span class="lineno"> 1057 </span>-- index, then add a pointer-equality constraint.
<span class="lineno"> 1058 </span>assignVar ::
<span class="lineno"> 1059 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno"> 1060 </span>  LLVMCrucibleContext arch {- ^ context for interacting with Crucible -} -&gt;
<span class="lineno"> 1061 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 1062 </span>  AllocIndex      {- ^ variable index -} -&gt;
<span class="lineno"> 1063 </span>  LLVMPtr (Crucible.ArchWidth arch) {- ^ concrete value -} -&gt;
<span class="lineno"> 1064 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 1065 </span>
<span class="lineno"> 1066 </span><span class="decl"><span class="istickedoff">assignVar cc md var val =</span>
<span class="lineno"> 1067 </span><span class="spaces">  </span><span class="istickedoff">do let loc = MS.conditionLoc md</span>
<span class="lineno"> 1068 </span><span class="spaces">     </span><span class="istickedoff">old &lt;- OM (setupValueSub . at var &lt;&lt;.= Just val)</span>
<span class="lineno"> 1069 </span><span class="spaces">     </span><span class="istickedoff">for_ old $ \val' -&gt;</span>
<span class="lineno"> 1070 </span><span class="spaces">       </span><span class="istickedoff">do p &lt;- liftIO (equalValsPred cc (Crucible.ptrToPtrVal val') (Crucible.ptrToPtrVal val))</span>
<span class="lineno"> 1071 </span><span class="spaces">          </span><span class="istickedoff">let msg = unlines</span>
<span class="lineno"> 1072 </span><span class="spaces">                </span><span class="istickedoff">[ &quot;The following pointers had to alias, but they didn't:&quot;</span>
<span class="lineno"> 1073 </span><span class="spaces">                </span><span class="istickedoff">, &quot;  &quot; ++ show (Crucible.ppPtr val)</span>
<span class="lineno"> 1074 </span><span class="spaces">                </span><span class="istickedoff">, &quot;  &quot; ++ show (Crucible.ppPtr val')</span>
<span class="lineno"> 1075 </span><span class="spaces">                </span><span class="istickedoff">]</span>
<span class="lineno"> 1076 </span><span class="spaces">          </span><span class="istickedoff">addAssert p <span class="nottickedoff">md</span> $ Crucible.SimError loc $ Crucible.AssertFailureSimError msg &quot;&quot;</span></span>
<span class="lineno"> 1077 </span>
<span class="lineno"> 1078 </span>------------------------------------------------------------------------
<span class="lineno"> 1079 </span>
<span class="lineno"> 1080 </span>diffMemTypes ::
<span class="lineno"> 1081 </span>  Crucible.HasPtrWidth wptr =&gt;
<span class="lineno"> 1082 </span>  Crucible.MemType -&gt;
<span class="lineno"> 1083 </span>  Crucible.MemType -&gt;
<span class="lineno"> 1084 </span>  [([Maybe Int], Crucible.MemType, Crucible.MemType)]
<span class="lineno"> 1085 </span><span class="decl"><span class="istickedoff">diffMemTypes x0 y0 =</span>
<span class="lineno"> 1086 </span><span class="spaces">  </span><span class="istickedoff">let wptr :: Natural = fromIntegral (W4.natValue ?ptrWidth) in</span>
<span class="lineno"> 1087 </span><span class="spaces">  </span><span class="istickedoff">case (x0, y0) of</span>
<span class="lineno"> 1088 </span><span class="spaces">    </span><span class="istickedoff">-- Special case; consider a one-element struct to be compatible with</span>
<span class="lineno"> 1089 </span><span class="spaces">    </span><span class="istickedoff">-- the type of its field</span>
<span class="lineno"> 1090 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.StructType x, _)</span>
<span class="lineno"> 1091 </span><span class="spaces">      </span><span class="istickedoff">| V.length (Crucible.siFields x) == 1 -&gt; diffMemTypes (Crucible.fiType (V.head (Crucible.siFields x))) y0</span>
<span class="lineno"> 1092 </span><span class="spaces">    </span><span class="istickedoff">(_, Crucible.StructType y)</span>
<span class="lineno"> 1093 </span><span class="spaces">      </span><span class="istickedoff">| V.length (Crucible.siFields y) == 1 -&gt; diffMemTypes x0 (Crucible.fiType (V.head (Crucible.siFields y)))</span>
<span class="lineno"> 1094 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1095 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.IntType x, Crucible.IntType y) | x == y -&gt; []</span>
<span class="lineno"> 1096 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.FloatType, Crucible.FloatType) -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1097 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.DoubleType, Crucible.DoubleType) -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1098 </span><span class="spaces">    </span><span class="istickedoff">(_, _)</span>
<span class="lineno"> 1099 </span><span class="spaces">      </span><span class="istickedoff">| Crucible.isPointerMemType x0 &amp;&amp; Crucible.isPointerMemType y0 -&gt;</span>
<span class="lineno"> 1100 </span><span class="spaces">          </span><span class="istickedoff">[]</span>
<span class="lineno"> 1101 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.IntType w, _)</span>
<span class="lineno"> 1102 </span><span class="spaces">      </span><span class="istickedoff">| Crucible.isPointerMemType y0 &amp;&amp; w == wptr -&gt;</span>
<span class="lineno"> 1103 </span><span class="spaces">          </span><span class="istickedoff">[]</span>
<span class="lineno"> 1104 </span><span class="spaces">    </span><span class="istickedoff">(_, Crucible.IntType w)</span>
<span class="lineno"> 1105 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">Crucible.isPointerMemType x0 &amp;&amp; <span class="nottickedoff">w == wptr</span></span> -&gt;</span>
<span class="lineno"> 1106 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[]</span></span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.ArrayType xn xt, Crucible.ArrayType yn yt)</span>
<span class="lineno"> 1108 </span><span class="spaces">      </span><span class="istickedoff">| xn == yn -&gt;</span>
<span class="lineno"> 1109 </span><span class="spaces">        </span><span class="istickedoff">[ <span class="nottickedoff">(Nothing : path, l , r)</span> | (path, l, r) &lt;- diffMemTypes xt yt ]</span>
<span class="lineno"> 1110 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.VecType xn xt, Crucible.VecType yn yt)</span>
<span class="lineno"> 1111 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">xn == yn</span> -&gt;</span>
<span class="lineno"> 1112 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[ (Nothing : path, l , r) | (path, l, r) &lt;- diffMemTypes xt yt ]</span></span>
<span class="lineno"> 1113 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.StructType x, Crucible.StructType y)</span>
<span class="lineno"> 1114 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">V.map Crucible.fiOffset (Crucible.siFields x) ==</span></span>
<span class="lineno"> 1115 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue">V.map Crucible.fiOffset (Crucible.siFields y)</span> -&gt;</span>
<span class="lineno"> 1116 </span><span class="spaces">          </span><span class="istickedoff">let xts = Crucible.siFieldTypes x</span>
<span class="lineno"> 1117 </span><span class="spaces">              </span><span class="istickedoff">yts = Crucible.siFieldTypes y</span>
<span class="lineno"> 1118 </span><span class="spaces">          </span><span class="istickedoff">in diffMemTypesList <span class="nottickedoff">1</span> (V.toList (V.zip xts yts))</span>
<span class="lineno"> 1119 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; [([], <span class="nottickedoff">x0</span>, <span class="nottickedoff">y0</span>)]</span></span>
<span class="lineno"> 1120 </span>
<span class="lineno"> 1121 </span>diffMemTypesList ::
<span class="lineno"> 1122 </span>  Crucible.HasPtrWidth arch =&gt;
<span class="lineno"> 1123 </span>  Int -&gt;
<span class="lineno"> 1124 </span>  [(Crucible.MemType, Crucible.MemType)] -&gt;
<span class="lineno"> 1125 </span>  [([Maybe Int], Crucible.MemType, Crucible.MemType)]
<span class="lineno"> 1126 </span><span class="decl"><span class="istickedoff">diffMemTypesList _ [] = []</span>
<span class="lineno"> 1127 </span><span class="spaces"></span><span class="istickedoff">diffMemTypesList i ((x, y) : ts) =</span>
<span class="lineno"> 1128 </span><span class="spaces">  </span><span class="istickedoff">[ <span class="nottickedoff">(Just i : path, l , r)</span> | (path, l, r) &lt;- diffMemTypes x y ]</span>
<span class="lineno"> 1129 </span><span class="spaces">  </span><span class="istickedoff">++ diffMemTypesList <span class="nottickedoff">(i+1)</span> ts</span></span>
<span class="lineno"> 1130 </span>
<span class="lineno"> 1131 </span>
<span class="lineno"> 1132 </span>------------------------------------------------------------------------
<span class="lineno"> 1133 </span>
<span class="lineno"> 1134 </span>-- | Match the value of a function argument with a symbolic 'SetupValue'.
<span class="lineno"> 1135 </span>matchArg ::
<span class="lineno"> 1136 </span>  (?w4EvalTactic :: W4EvalTactic) =&gt;
<span class="lineno"> 1137 </span>  Options          {- ^ saw script print out opts -} -&gt;
<span class="lineno"> 1138 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno"> 1139 </span>  SharedContext      {- ^ context for constructing SAW terms    -} -&gt;
<span class="lineno"> 1140 </span>  LLVMCrucibleContext arch {- ^ context for interacting with Crucible -} -&gt;
<span class="lineno"> 1141 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ specification for current function override  -} -&gt;
<span class="lineno"> 1142 </span>  PrePost                                                          -&gt;
<span class="lineno"> 1143 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 1144 </span>  Crucible.LLVMVal Sym
<span class="lineno"> 1145 </span>                     {- ^ concrete simulation value             -} -&gt;
<span class="lineno"> 1146 </span>  Crucible.MemType   {- ^ expected memory type                  -} -&gt;
<span class="lineno"> 1147 </span>  SetupValue (LLVM arch)         {- ^ expected specification value          -} -&gt;
<span class="lineno"> 1148 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 1149 </span>
<span class="lineno"> 1150 </span><span class="decl"><span class="istickedoff">matchArg opts sc cc cs prepost md actual expectedTy expected =</span>
<span class="lineno"> 1151 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 1152 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno"> 1153 </span><span class="spaces">  </span><span class="istickedoff">mem &lt;- readGlobal $ Crucible.llvmMemVar $ ccLLVMContext cc</span>
<span class="lineno"> 1154 </span><span class="spaces">  </span><span class="istickedoff">case (actual, expectedTy, expected) of</span>
<span class="lineno"> 1155 </span><span class="spaces">    </span><span class="istickedoff">(_, _, SetupTerm expectedTT)</span>
<span class="lineno"> 1156 </span><span class="spaces">      </span><span class="istickedoff">| TypedTermSchema (Cryptol.Forall [] [] tyexpr) &lt;- ttType expectedTT</span>
<span class="lineno"> 1157 </span><span class="spaces">      </span><span class="istickedoff">, Right tval &lt;- Cryptol.evalType <span class="nottickedoff">mempty</span> tyexpr</span>
<span class="lineno"> 1158 </span><span class="spaces">        </span><span class="istickedoff">-&gt; do failMsg  &lt;- mkStructuralMismatch <span class="nottickedoff">opts</span> <span class="nottickedoff">cc</span> <span class="nottickedoff">sc</span> <span class="nottickedoff">cs</span> <span class="nottickedoff">actual</span> <span class="nottickedoff">expected</span> <span class="nottickedoff">expectedTy</span></span>
<span class="lineno"> 1159 </span><span class="spaces">              </span><span class="istickedoff">realTerm &lt;- valueToSC sym <span class="nottickedoff">md</span> <span class="nottickedoff">failMsg</span> tval actual</span>
<span class="lineno"> 1160 </span><span class="spaces">              </span><span class="istickedoff">instantiateExtMatchTerm sc md prepost realTerm (ttTerm expectedTT)</span>
<span class="lineno"> 1161 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1162 </span><span class="spaces">    </span><span class="istickedoff">-- match arrays point-wise</span>
<span class="lineno"> 1163 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.LLVMValArray _ xs, Crucible.ArrayType _len y, SetupArray () zs)</span>
<span class="lineno"> 1164 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">V.length xs &gt;= length zs</span> -&gt;</span>
<span class="lineno"> 1165 </span><span class="spaces">        </span><span class="istickedoff">sequence_</span>
<span class="lineno"> 1166 </span><span class="spaces">          </span><span class="istickedoff">[ matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">cs</span> <span class="nottickedoff">prepost</span> <span class="nottickedoff">md</span> x <span class="nottickedoff">y</span> z</span>
<span class="lineno"> 1167 </span><span class="spaces">          </span><span class="istickedoff">| (x, z) &lt;- zip (V.toList xs) zs ]</span>
<span class="lineno"> 1168 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1169 </span><span class="spaces">    </span><span class="istickedoff">-- LLVM string literals are syntactic shorthand for [&lt;N&gt; x i8] arrays,</span>
<span class="lineno"> 1170 </span><span class="spaces">    </span><span class="istickedoff">-- so we defer to the LLVMValArray case above.</span>
<span class="lineno"> 1171 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.LLVMValString xs, Crucible.ArrayType _len (Crucible.IntType 8), SetupArray () zs)</span>
<span class="lineno"> 1172 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">BS.length xs &gt;= length zs</span> -&gt;</span>
<span class="lineno"> 1173 </span><span class="spaces">        </span><span class="istickedoff">do explodedActual &lt;- liftIO $ Crucible.explodeStringValue sym xs</span>
<span class="lineno"> 1174 </span><span class="spaces">           </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">cs</span> <span class="nottickedoff">prepost</span> <span class="nottickedoff">md</span> explodedActual expectedTy expected</span>
<span class="lineno"> 1175 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1176 </span><span class="spaces">    </span><span class="istickedoff">-- match the fields of struct point-wise</span>
<span class="lineno"> 1177 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.LLVMValStruct xs, Crucible.StructType fields, SetupStruct _ zs) -&gt;</span>
<span class="lineno"> 1178 </span><span class="spaces">      </span><span class="istickedoff">sequence_</span>
<span class="lineno"> 1179 </span><span class="spaces">        </span><span class="istickedoff">[ matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">cs</span> <span class="nottickedoff">prepost</span> md x <span class="nottickedoff">y</span> z</span>
<span class="lineno"> 1180 </span><span class="spaces">        </span><span class="istickedoff">| ((_,x),y,z) &lt;- zip3 (V.toList xs)</span>
<span class="lineno"> 1181 </span><span class="spaces">                              </span><span class="istickedoff">(V.toList (<span class="nottickedoff">Crucible.fiType</span> &lt;$&gt; Crucible.siFields fields))</span>
<span class="lineno"> 1182 </span><span class="spaces">                              </span><span class="istickedoff">zs ]</span>
<span class="lineno"> 1183 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1184 </span><span class="spaces">    </span><span class="istickedoff">(_, _, SetupEnum empty) -&gt;</span>
<span class="lineno"> 1185 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1186 </span><span class="spaces">    </span><span class="istickedoff">(_, _, SetupTuple empty _) -&gt;</span>
<span class="lineno"> 1187 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1188 </span><span class="spaces">    </span><span class="istickedoff">(_, _, SetupSlice empty) -&gt;</span>
<span class="lineno"> 1189 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1190 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1191 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.LLVMValInt blk off, _, SetupElem () v i) | <span class="tickonlytrue">Crucible.isPointerMemType expectedTy</span> -&gt;</span>
<span class="lineno"> 1192 </span><span class="spaces">      </span><span class="istickedoff">do let tyenv = MS.csAllocations cs</span>
<span class="lineno"> 1193 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames cs</span></span>
<span class="lineno"> 1194 </span><span class="spaces">         </span><span class="istickedoff">delta &lt;- exceptToFail $ resolveSetupElemOffset <span class="nottickedoff">cc</span> tyenv <span class="nottickedoff">nameEnv</span> v i</span>
<span class="lineno"> 1195 </span><span class="spaces">         </span><span class="istickedoff">off' &lt;- liftIO $ W4.bvSub sym off</span>
<span class="lineno"> 1196 </span><span class="spaces">           </span><span class="istickedoff">=&lt;&lt; W4.bvLit sym (W4.bvWidth off) (Crucible.bytesToBV (W4.bvWidth off) delta)</span>
<span class="lineno"> 1197 </span><span class="spaces">         </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc <span class="nottickedoff">cs</span> <span class="nottickedoff">prepost</span> md (Crucible.LLVMValInt blk off') <span class="nottickedoff">expectedTy</span> v</span>
<span class="lineno"> 1198 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1199 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.LLVMValInt blk off, _, SetupField () v n) | <span class="tickonlytrue">Crucible.isPointerMemType expectedTy</span> -&gt;</span>
<span class="lineno"> 1200 </span><span class="spaces">      </span><span class="istickedoff">do let tyenv = MS.csAllocations cs</span>
<span class="lineno"> 1201 </span><span class="spaces">             </span><span class="istickedoff">nameEnv = MS.csTypeNames cs</span>
<span class="lineno"> 1202 </span><span class="spaces">         </span><span class="istickedoff">fld &lt;- exceptToFail $</span>
<span class="lineno"> 1203 </span><span class="spaces">                  </span><span class="istickedoff">do info &lt;- resolveSetupValueInfo cc <span class="nottickedoff">tyenv</span> nameEnv v</span>
<span class="lineno"> 1204 </span><span class="spaces">                     </span><span class="istickedoff">recoverStructFieldInfo <span class="nottickedoff">cc</span> tyenv <span class="nottickedoff">nameEnv</span> v info n</span>
<span class="lineno"> 1205 </span><span class="spaces">         </span><span class="istickedoff">let delta = fromIntegral $ Crucible.fiOffset fld</span>
<span class="lineno"> 1206 </span><span class="spaces">         </span><span class="istickedoff">off' &lt;- liftIO $ W4.bvSub sym off</span>
<span class="lineno"> 1207 </span><span class="spaces">                    </span><span class="istickedoff">=&lt;&lt; W4.bvLit sym (W4.bvWidth off) (Crucible.bytesToBV (W4.bvWidth off) delta)</span>
<span class="lineno"> 1208 </span><span class="spaces">         </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> cc <span class="nottickedoff">cs</span> <span class="nottickedoff">prepost</span> <span class="nottickedoff">md</span> (Crucible.LLVMValInt blk off') <span class="nottickedoff">expectedTy</span> v</span>
<span class="lineno"> 1209 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1210 </span><span class="spaces">    </span><span class="istickedoff">(_, _, SetupGlobalInitializer () _) -&gt; resolveAndMatch</span>
<span class="lineno"> 1211 </span><span class="spaces">    </span><span class="istickedoff">(_, _, SetupMux empty _ _ _)        -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 1212 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1213 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.LLVMValInt blk off, _, _) -&gt;</span>
<span class="lineno"> 1214 </span><span class="spaces">      </span><span class="istickedoff">case expected of</span>
<span class="lineno"> 1215 </span><span class="spaces">        </span><span class="istickedoff">SetupVar var | Just Refl &lt;- testEquality (W4.bvWidth off) Crucible.PtrWidth -&gt;</span>
<span class="lineno"> 1216 </span><span class="spaces">          </span><span class="istickedoff">do assignVar cc md var (Crucible.LLVMPointer blk off)</span>
<span class="lineno"> 1217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1218 </span><span class="spaces">        </span><span class="istickedoff">SetupNull () | Just Refl &lt;- <span class="nottickedoff">testEquality (W4.bvWidth off) Crucible.PtrWidth</span> -&gt;</span>
<span class="lineno"> 1219 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do p   &lt;- liftIO (Crucible.ptrIsNull sym Crucible.PtrWidth (Crucible.LLVMPointer blk off))</span></span>
<span class="lineno"> 1220 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">addAssert p md =&lt;&lt;</span></span>
<span class="lineno"> 1221 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">notEqual prepost opts loc cc sc cs expected actual</span></span>
<span class="lineno"> 1222 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1223 </span><span class="spaces">        </span><span class="istickedoff">SetupGlobal () name | Just Refl &lt;- <span class="nottickedoff">testEquality (W4.bvWidth off) Crucible.PtrWidth</span> -&gt;</span>
<span class="lineno"> 1224 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do ptr2 &lt;- liftIO $ Crucible.doResolveGlobal bak mem (L.Symbol name)</span></span>
<span class="lineno"> 1225 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">pred_ &lt;- liftIO $</span></span>
<span class="lineno"> 1226 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Crucible.ptrEq sym Crucible.PtrWidth (Crucible.LLVMPointer blk off) ptr2</span></span>
<span class="lineno"> 1227 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">addAssert pred_ md =&lt;&lt;</span></span>
<span class="lineno"> 1228 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">notEqual prepost opts loc cc sc cs expected actual</span></span>
<span class="lineno"> 1229 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1230 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">failure loc =&lt;&lt;</span></span>
<span class="lineno"> 1231 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">mkStructuralMismatch opts cc sc cs actual expected expectedTy</span></span>
<span class="lineno"> 1232 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1233 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">failure loc =&lt;&lt;</span></span>
<span class="lineno"> 1234 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">mkStructuralMismatch opts cc sc cs actual expected expectedTy</span></span>
<span class="lineno"> 1235 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1236 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1237 </span><span class="spaces">    </span><span class="istickedoff">loc = MS.conditionLoc md</span>
<span class="lineno"> 1238 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1239 </span><span class="spaces">    </span><span class="istickedoff">resolveAndMatch = do</span>
<span class="lineno"> 1240 </span><span class="spaces">      </span><span class="istickedoff">(ty, val) &lt;- resolveSetupValueLLVM <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> <span class="nottickedoff">cs</span> expected</span>
<span class="lineno"> 1241 </span><span class="spaces">      </span><span class="istickedoff">sym  &lt;- Ov.getSymInterface</span>
<span class="lineno"> 1242 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">diffMemTypes expectedTy ty /= []</span></span>
<span class="lineno"> 1243 </span><span class="spaces">      </span><span class="istickedoff">then <span class="nottickedoff">failure loc =&lt;&lt;</span></span>
<span class="lineno"> 1244 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">mkStructuralMismatch opts cc sc cs actual expected expectedTy</span></span>
<span class="lineno"> 1245 </span><span class="spaces">      </span><span class="istickedoff">else liftIO (Crucible.testEqual sym val actual) &gt;&gt;=</span>
<span class="lineno"> 1246 </span><span class="spaces">        </span><span class="istickedoff">\case</span>
<span class="lineno"> 1247 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">failure loc BadEqualityComparison</span></span>
<span class="lineno"> 1248 </span><span class="spaces">          </span><span class="istickedoff">Just pred_ -&gt;</span>
<span class="lineno"> 1249 </span><span class="spaces">            </span><span class="istickedoff">addAssert pred_ <span class="nottickedoff">md</span> =&lt;&lt;</span>
<span class="lineno"> 1250 </span><span class="spaces">              </span><span class="istickedoff">notEqual <span class="nottickedoff">prepost</span> <span class="nottickedoff">opts</span> loc cc <span class="nottickedoff">sc</span> <span class="nottickedoff">cs</span> expected <span class="nottickedoff">actual</span></span></span>
<span class="lineno"> 1251 </span>
<span class="lineno"> 1252 </span>------------------------------------------------------------------------
<span class="lineno"> 1253 </span>
<span class="lineno"> 1254 </span>zeroValueSC :: SharedContext -&gt; Crucible.StorageType -&gt; IO Term
<span class="lineno"> 1255 </span><span class="decl"><span class="istickedoff">zeroValueSC sc tp = case Crucible.storageTypeF tp of</span>
<span class="lineno"> 1256 </span><span class="spaces">  </span><span class="istickedoff">Crucible.Float -&gt; <span class="nottickedoff">fail &quot;zeroValueSC: float unsupported&quot;</span></span>
<span class="lineno"> 1257 </span><span class="spaces">  </span><span class="istickedoff">Crucible.Double -&gt; <span class="nottickedoff">fail &quot;zeroValueSC: double unsupported&quot;</span></span>
<span class="lineno"> 1258 </span><span class="spaces">  </span><span class="istickedoff">Crucible.X86_FP80 -&gt; <span class="nottickedoff">fail &quot;zeroValueSC: X86_FP80 unsupported&quot;</span></span>
<span class="lineno"> 1259 </span><span class="spaces">  </span><span class="istickedoff">Crucible.Bitvector bs -&gt;</span>
<span class="lineno"> 1260 </span><span class="spaces">    </span><span class="istickedoff">do n &lt;- scNat sc (Crucible.bytesToBits bs)</span>
<span class="lineno"> 1261 </span><span class="spaces">       </span><span class="istickedoff">z &lt;- scNat sc 0</span>
<span class="lineno"> 1262 </span><span class="spaces">       </span><span class="istickedoff">scBvNat sc n z</span>
<span class="lineno"> 1263 </span><span class="spaces">  </span><span class="istickedoff">Crucible.Array n tp' -&gt;</span>
<span class="lineno"> 1264 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do sctp &lt;- typeToSC sc tp'</span></span>
<span class="lineno"> 1265 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">v &lt;- zeroValueSC sc tp'</span></span>
<span class="lineno"> 1266 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">scVector sc sctp (replicate (fromIntegral n) v)</span></span>
<span class="lineno"> 1267 </span><span class="spaces">  </span><span class="istickedoff">Crucible.Struct fs -&gt;</span>
<span class="lineno"> 1268 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do tms &lt;- mapM (zeroValueSC sc . view Crucible.fieldVal) (V.toList fs)</span></span>
<span class="lineno"> 1269 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">scTuple sc tms</span></span></span>
<span class="lineno"> 1270 </span>
<span class="lineno"> 1271 </span>valueToSC ::
<span class="lineno"> 1272 </span>  Sym -&gt;
<span class="lineno"> 1273 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 1274 </span>  OverrideFailureReason (LLVM arch) -&gt;
<span class="lineno"> 1275 </span>  Cryptol.TValue -&gt;
<span class="lineno"> 1276 </span>  Crucible.LLVMVal Sym  -&gt;
<span class="lineno"> 1277 </span>  OverrideMatcher (LLVM arch) md Term
<span class="lineno"> 1278 </span><span class="decl"><span class="istickedoff">valueToSC sym _md _failMsg _ts (Crucible.LLVMValZero gtp)</span>
<span class="lineno"> 1279 </span><span class="spaces">  </span><span class="istickedoff">= liftIO $</span>
<span class="lineno"> 1280 </span><span class="spaces">     </span><span class="istickedoff">do st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno"> 1281 </span><span class="spaces">        </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno"> 1282 </span><span class="spaces">        </span><span class="istickedoff">zeroValueSC sc gtp</span>
<span class="lineno"> 1283 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1284 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym md failMsg (Cryptol.TVTuple tys) (Crucible.LLVMValStruct vals)</span>
<span class="lineno"> 1285 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">length tys == length vals</span></span>
<span class="lineno"> 1286 </span><span class="spaces">  </span><span class="istickedoff">= do terms &lt;- traverse (\(ty, tm) -&gt; valueToSC sym <span class="nottickedoff">md</span> <span class="nottickedoff">failMsg</span> ty (snd tm)) (zip tys (V.toList vals))</span>
<span class="lineno"> 1287 </span><span class="spaces">       </span><span class="istickedoff">st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno"> 1288 </span><span class="spaces">       </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno"> 1289 </span><span class="spaces">       </span><span class="istickedoff">liftIO (scTupleReduced sc terms)</span>
<span class="lineno"> 1290 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1291 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym md failMsg (Cryptol.TVSeq _n Cryptol.TVBit) (Crucible.LLVMValInt base off) =</span>
<span class="lineno"> 1292 </span><span class="spaces">  </span><span class="istickedoff">do let <span class="nottickedoff">loc = MS.conditionLoc md</span></span>
<span class="lineno"> 1293 </span><span class="spaces">     </span><span class="istickedoff">baseZero &lt;- liftIO (W4.natEq sym base =&lt;&lt; W4.natLit sym 0)</span>
<span class="lineno"> 1294 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno"> 1295 </span><span class="spaces">     </span><span class="istickedoff">offTm &lt;- liftIO (toSC <span class="nottickedoff">sym</span> st off)</span>
<span class="lineno"> 1296 </span><span class="spaces">     </span><span class="istickedoff">case W4.asConstantPred baseZero of</span>
<span class="lineno"> 1297 </span><span class="spaces">       </span><span class="istickedoff">Just True  -&gt; return offTm</span>
<span class="lineno"> 1298 </span><span class="spaces">       </span><span class="istickedoff">Just False -&gt; <span class="nottickedoff">failure loc failMsg</span></span>
<span class="lineno"> 1299 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">do addAssert baseZero md (Crucible.SimError loc (Crucible.GenericSimError &quot;Expected bitvector value, but found pointer&quot;))</span></span>
<span class="lineno"> 1300 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">return offTm</span></span>
<span class="lineno"> 1301 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1302 </span><span class="spaces"></span><span class="istickedoff">-- This is a case for pointers, when we opaque types in Cryptol to represent them...</span>
<span class="lineno"> 1303 </span><span class="spaces"></span><span class="istickedoff">-- valueToSC sym _tval (Crucible.LLVMValInt base off) =</span>
<span class="lineno"> 1304 </span><span class="spaces"></span><span class="istickedoff">--   do base' &lt;- Crucible.toSC sym base</span>
<span class="lineno"> 1305 </span><span class="spaces"></span><span class="istickedoff">--      off'  &lt;- Crucible.toSC sym off</span>
<span class="lineno"> 1306 </span><span class="spaces"></span><span class="istickedoff">--      sc    &lt;- Crucible.saw_ctx &lt;$&gt; sawCoreState sym</span>
<span class="lineno"> 1307 </span><span class="spaces"></span><span class="istickedoff">--      Just &lt;$&gt; scTuple sc [base', off']</span>
<span class="lineno"> 1308 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1309 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym md failMsg (Cryptol.TVSeq n cryty) (Crucible.LLVMValArray ty vals)</span>
<span class="lineno"> 1310 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">toInteger (length vals) == n</span></span>
<span class="lineno"> 1311 </span><span class="spaces">  </span><span class="istickedoff">= do terms &lt;- V.toList &lt;$&gt; traverse (valueToSC sym <span class="nottickedoff">md</span> <span class="nottickedoff">failMsg</span> cryty) vals</span>
<span class="lineno"> 1312 </span><span class="spaces">       </span><span class="istickedoff">st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno"> 1313 </span><span class="spaces">       </span><span class="istickedoff">let sc = saw_ctx st</span>
<span class="lineno"> 1314 </span><span class="spaces">       </span><span class="istickedoff">t &lt;- liftIO (typeToSC sc ty)</span>
<span class="lineno"> 1315 </span><span class="spaces">       </span><span class="istickedoff">liftIO (scVectorReduced sc t terms)</span>
<span class="lineno"> 1316 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1317 </span><span class="spaces"></span><span class="istickedoff">-- LLVM string literals are syntactic shorthand for [&lt;N&gt; x i8] arrays, so we</span>
<span class="lineno"> 1318 </span><span class="spaces"></span><span class="istickedoff">-- defer to the LLVMValArray case above.</span>
<span class="lineno"> 1319 </span><span class="spaces"></span><span class="istickedoff">valueToSC sym md failMsg tval@(Cryptol.TVSeq n (Cryptol.TVSeq 8 Cryptol.TVBit)) (Crucible.LLVMValString str)</span>
<span class="lineno"> 1320 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">toInteger (BS.length str) == n</span></span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="istickedoff">= do explodedVal &lt;- liftIO $ Crucible.explodeStringValue sym str</span>
<span class="lineno"> 1322 </span><span class="spaces">       </span><span class="istickedoff">valueToSC sym <span class="nottickedoff">md</span> <span class="nottickedoff">failMsg</span> tval explodedVal</span>
<span class="lineno"> 1323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1324 </span><span class="spaces"></span><span class="istickedoff">valueToSC _ _ _ _ Crucible.LLVMValFloat{} =</span>
<span class="lineno"> 1325 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">fail  &quot;valueToSC: Real not supported&quot;</span></span>
<span class="lineno"> 1326 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1327 </span><span class="spaces"></span><span class="istickedoff">valueToSC _sym md failMsg _tval _val =</span>
<span class="lineno"> 1328 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">failure (MS.conditionLoc md) failMsg</span></span></span>
<span class="lineno"> 1329 </span>
<span class="lineno"> 1330 </span>------------------------------------------------------------------------
<span class="lineno"> 1331 </span>
<span class="lineno"> 1332 </span>typeToSC :: SharedContext -&gt; Crucible.StorageType -&gt; IO Term
<span class="lineno"> 1333 </span><span class="decl"><span class="istickedoff">typeToSC sc t =</span>
<span class="lineno"> 1334 </span><span class="spaces">  </span><span class="istickedoff">case Crucible.storageTypeF t of</span>
<span class="lineno"> 1335 </span><span class="spaces">    </span><span class="istickedoff">Crucible.Bitvector sz -&gt; scBitvector sc (Crucible.bytesToBits sz)</span>
<span class="lineno"> 1336 </span><span class="spaces">    </span><span class="istickedoff">Crucible.Float -&gt; <span class="nottickedoff">fail &quot;typeToSC: float not supported&quot;</span></span>
<span class="lineno"> 1337 </span><span class="spaces">    </span><span class="istickedoff">Crucible.Double -&gt; <span class="nottickedoff">fail &quot;typeToSC: double not supported&quot;</span></span>
<span class="lineno"> 1338 </span><span class="spaces">    </span><span class="istickedoff">Crucible.X86_FP80 -&gt; <span class="nottickedoff">fail &quot;typeToSC: X86_FP80 not supported&quot;</span></span>
<span class="lineno"> 1339 </span><span class="spaces">    </span><span class="istickedoff">Crucible.Array sz ty -&gt;</span>
<span class="lineno"> 1340 </span><span class="spaces">      </span><span class="istickedoff">do n &lt;- scNat sc (fromIntegral sz)</span>
<span class="lineno"> 1341 </span><span class="spaces">         </span><span class="istickedoff">ty' &lt;- typeToSC sc ty</span>
<span class="lineno"> 1342 </span><span class="spaces">         </span><span class="istickedoff">scVecType sc n ty'</span>
<span class="lineno"> 1343 </span><span class="spaces">    </span><span class="istickedoff">Crucible.Struct fields -&gt;</span>
<span class="lineno"> 1344 </span><span class="spaces">      </span><span class="istickedoff">do fields' &lt;- V.toList &lt;$&gt; traverse (typeToSC sc . view Crucible.fieldVal) fields</span>
<span class="lineno"> 1345 </span><span class="spaces">         </span><span class="istickedoff">scTupleType sc fields'</span></span>
<span class="lineno"> 1346 </span>
<span class="lineno"> 1347 </span>------------------------------------------------------------------------
<span class="lineno"> 1348 </span>
<span class="lineno"> 1349 </span>-- | Use the current state to learn about variable assignments based on
<span class="lineno"> 1350 </span>-- preconditions for a procedure specification.
<span class="lineno"> 1351 </span>learnSetupCondition ::
<span class="lineno"> 1352 </span>  (?lc :: Crucible.TypeContext, ?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 1353 </span>  Options                    -&gt;
<span class="lineno"> 1354 </span>  SharedContext              -&gt;
<span class="lineno"> 1355 </span>  LLVMCrucibleContext arch       -&gt;
<span class="lineno"> 1356 </span>  MS.CrucibleMethodSpecIR (LLVM arch)       -&gt;
<span class="lineno"> 1357 </span>  PrePost                    -&gt;
<span class="lineno"> 1358 </span>  MS.SetupCondition (LLVM arch) -&gt;
<span class="lineno"> 1359 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 1360 </span><span class="decl"><span class="istickedoff">learnSetupCondition opts sc cc spec prepost cond =</span>
<span class="lineno"> 1361 </span><span class="spaces">  </span><span class="istickedoff">case cond of</span>
<span class="lineno"> 1362 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCond_Equal md val1 val2 -&gt; learnEqual <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">spec</span> md <span class="nottickedoff">prepost</span> val1 val2</span>
<span class="lineno"> 1363 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCond_Pred md tm         -&gt; learnPred sc cc md prepost (ttTerm tm)</span>
<span class="lineno"> 1364 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCond_Ghost md var val   -&gt; learnGhost sc md prepost var val</span></span>
<span class="lineno"> 1365 </span>
<span class="lineno"> 1366 </span>
<span class="lineno"> 1367 </span>------------------------------------------------------------------------
<span class="lineno"> 1368 </span>
<span class="lineno"> 1369 </span>-- | Process a &quot;points_to&quot; statement from the precondition section of
<span class="lineno"> 1370 </span>-- the CrucibleSetup block. First, load the value from the address
<span class="lineno"> 1371 </span>-- indicated by 'ptr', and then match it against the pattern 'val'.
<span class="lineno"> 1372 </span>--
<span class="lineno"> 1373 </span>-- Returns a string on failure describing a concrete memory load failure.
<span class="lineno"> 1374 </span>learnPointsTo ::
<span class="lineno"> 1375 </span>  forall arch md ann.
<span class="lineno"> 1376 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1377 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1378 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1379 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1380 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1381 </span>  ) =&gt;
<span class="lineno"> 1382 </span>  Options -&gt;
<span class="lineno"> 1383 </span>  SharedContext -&gt;
<span class="lineno"> 1384 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1385 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1386 </span>  PrePost -&gt;
<span class="lineno"> 1387 </span>  PointsTo (LLVM arch) -&gt;
<span class="lineno"> 1388 </span>  OverrideMatcher (LLVM arch) md (Maybe (PP.Doc ann))
<span class="lineno"> 1389 </span><span class="decl"><span class="istickedoff">learnPointsTo opts sc cc spec prepost (LLVMPointsTo md maybe_cond ptr val) =</span>
<span class="lineno"> 1390 </span><span class="spaces">  </span><span class="istickedoff">do (_memTy, ptr1) &lt;- resolveSetupValue <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec Crucible.PtrRepr ptr</span>
<span class="lineno"> 1391 </span><span class="spaces">     </span><span class="istickedoff">matchPointsToValue <span class="nottickedoff">opts</span> sc cc spec prepost md maybe_cond ptr1 val</span>
<span class="lineno"> 1392 </span><span class="spaces"></span><span class="istickedoff">learnPointsTo opts sc cc spec prepost (LLVMPointsToBitfield md ptr fieldName val) =</span>
<span class="lineno"> 1393 </span><span class="spaces">  </span><span class="istickedoff">do (bfIndex, ptr1) &lt;- resolveSetupValueBitfield <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec ptr fieldName</span>
<span class="lineno"> 1394 </span><span class="spaces">     </span><span class="istickedoff">matchPointsToBitfieldValue <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">spec</span> <span class="nottickedoff">prepost</span> md ptr1 bfIndex val</span></span>
<span class="lineno"> 1395 </span>
<span class="lineno"> 1396 </span>matchPointsToValue ::
<span class="lineno"> 1397 </span>  forall arch md ann.
<span class="lineno"> 1398 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1399 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1400 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1401 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1402 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1403 </span>  ) =&gt;
<span class="lineno"> 1404 </span>  Options -&gt;
<span class="lineno"> 1405 </span>  SharedContext -&gt;
<span class="lineno"> 1406 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1407 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1408 </span>  PrePost -&gt;
<span class="lineno"> 1409 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 1410 </span>  Maybe TypedTerm -&gt;
<span class="lineno"> 1411 </span>  LLVMPtr (Crucible.ArchWidth arch) -&gt;
<span class="lineno"> 1412 </span>  LLVMPointsToValue arch -&gt;
<span class="lineno"> 1413 </span>  OverrideMatcher (LLVM arch) md (Maybe (PP.Doc ann))
<span class="lineno"> 1414 </span><span class="decl"><span class="istickedoff">matchPointsToValue opts sc cc spec prepost md maybe_cond ptr val =</span>
<span class="lineno"> 1415 </span><span class="spaces">  </span><span class="istickedoff">do let tyenv = MS.csAllocations spec</span>
<span class="lineno"> 1416 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno"> 1417 </span><span class="spaces">         </span><span class="istickedoff">loc = MS.conditionLoc md</span>
<span class="lineno"> 1418 </span><span class="spaces">     </span><span class="istickedoff">sym    &lt;- Ov.getSymInterface</span>
<span class="lineno"> 1419 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1420 </span><span class="spaces">     </span><span class="istickedoff">mem    &lt;- readGlobal $ Crucible.llvmMemVar</span>
<span class="lineno"> 1421 </span><span class="spaces">                          </span><span class="istickedoff">$ ccLLVMContext cc</span>
<span class="lineno"> 1422 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1423 </span><span class="spaces">     </span><span class="istickedoff">let alignment = Crucible.noAlignment -- default to byte alignment (FIXME, see #338)</span>
<span class="lineno"> 1424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1425 </span><span class="spaces">     </span><span class="istickedoff">case val of</span>
<span class="lineno"> 1426 </span><span class="spaces">       </span><span class="istickedoff">ConcreteSizeValue val' -&gt;</span>
<span class="lineno"> 1427 </span><span class="spaces">         </span><span class="istickedoff">do memTy &lt;- exceptToFail $ typeOfSetupValue cc tyenv <span class="nottickedoff">nameEnv</span> val'</span>
<span class="lineno"> 1428 </span><span class="spaces">            </span><span class="istickedoff">-- In case the types are different (from llvm_points_to_untyped)</span>
<span class="lineno"> 1429 </span><span class="spaces">            </span><span class="istickedoff">-- then the load type should be determined by the rhs.</span>
<span class="lineno"> 1430 </span><span class="spaces">            </span><span class="istickedoff">storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno"> 1431 </span><span class="spaces">            </span><span class="istickedoff">res &lt;- liftIO $ Crucible.loadRaw sym mem ptr storTy alignment</span>
<span class="lineno"> 1432 </span><span class="spaces">            </span><span class="istickedoff">let badLoadSummary = summarizeBadLoad <span class="nottickedoff">cc</span> memTy prepost ptr</span>
<span class="lineno"> 1433 </span><span class="spaces">            </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1434 </span><span class="spaces">              </span><span class="istickedoff">Crucible.NoErr pred_ res_val -&gt; do</span>
<span class="lineno"> 1435 </span><span class="spaces">                </span><span class="istickedoff">-- If dealing with an `llvm_conditional_points_to` statement,</span>
<span class="lineno"> 1436 </span><span class="spaces">                </span><span class="istickedoff">-- convert the condition to a `Pred`. If dealing with an</span>
<span class="lineno"> 1437 </span><span class="spaces">                </span><span class="istickedoff">-- ordinary `llvm_points_to` statement, this condition will</span>
<span class="lineno"> 1438 </span><span class="spaces">                </span><span class="istickedoff">-- simply be `True`.</span>
<span class="lineno"> 1439 </span><span class="spaces">                </span><span class="istickedoff">cond' &lt;- case maybe_cond of</span>
<span class="lineno"> 1440 </span><span class="spaces">                  </span><span class="istickedoff">Just cond -&gt;</span>
<span class="lineno"> 1441 </span><span class="spaces">                    </span><span class="istickedoff">instantiateExtResolveSAWPred sc cc (ttTerm cond)</span>
<span class="lineno"> 1442 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1443 </span><span class="spaces">                    </span><span class="istickedoff">pure $ W4.truePred sym</span>
<span class="lineno"> 1444 </span><span class="spaces">                </span><span class="istickedoff">-- Next, construct an implication involving the condition and</span>
<span class="lineno"> 1445 </span><span class="spaces">                </span><span class="istickedoff">-- assert it.</span>
<span class="lineno"> 1446 </span><span class="spaces">                </span><span class="istickedoff">pred_' &lt;- liftIO $ W4.impliesPred sym cond' pred_</span>
<span class="lineno"> 1447 </span><span class="spaces">                </span><span class="istickedoff">addAssert pred_' <span class="nottickedoff">md</span> $ Crucible.SimError loc $</span>
<span class="lineno"> 1448 </span><span class="spaces">                  </span><span class="istickedoff">Crucible.AssertFailureSimError (show $ PP.vcat badLoadSummary) &quot;&quot;</span>
<span class="lineno"> 1449 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1450 </span><span class="spaces">                </span><span class="istickedoff">-- Finally, match the value that the pointer points to against</span>
<span class="lineno"> 1451 </span><span class="spaces">                </span><span class="istickedoff">-- the right-hand side value in the points_to statement. Make</span>
<span class="lineno"> 1452 </span><span class="spaces">                </span><span class="istickedoff">-- sure to execute this match with an extended path condition</span>
<span class="lineno"> 1453 </span><span class="spaces">                </span><span class="istickedoff">-- that takes the condition above into account. See also</span>
<span class="lineno"> 1454 </span><span class="spaces">                </span><span class="istickedoff">-- Note [oeConditionalPred] in SAWScript.Crucible.Common.Override.</span>
<span class="lineno"> 1455 </span><span class="spaces">                </span><span class="istickedoff">withConditionalPred cond' $</span>
<span class="lineno"> 1456 </span><span class="spaces">                  </span><span class="istickedoff">pure Nothing &lt;* matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">spec</span> prepost md res_val memTy val'</span>
<span class="lineno"> 1457 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1458 </span><span class="spaces">                </span><span class="istickedoff">pure $ Just $ <span class="nottickedoff">describeConcreteMemoryLoadFailure mem badLoadSummary ptr</span></span>
<span class="lineno"> 1459 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1460 </span><span class="spaces">       </span><span class="istickedoff">SymbolicSizeValue expected_arr_tm expected_sz_tm -&gt;</span>
<span class="lineno"> 1461 </span><span class="spaces">         </span><span class="istickedoff">do maybe_allocation_array &lt;- liftIO $</span>
<span class="lineno"> 1462 </span><span class="spaces">              </span><span class="istickedoff">Crucible.asMemAllocationArrayStore sym Crucible.PtrWidth ptr (Crucible.memImplHeap mem)</span>
<span class="lineno"> 1463 </span><span class="spaces">            </span><span class="istickedoff">let errMsg = PP.vcat $ map (PP.pretty . unwords)</span>
<span class="lineno"> 1464 </span><span class="spaces">                  </span><span class="istickedoff">[ [ &quot;When reading through pointer:&quot;, show (Crucible.ppPtr ptr) ]</span>
<span class="lineno"> 1465 </span><span class="spaces">                  </span><span class="istickedoff">, [ &quot;in the &quot;, MS.stateCond prepost, &quot;of an override&quot; ]</span>
<span class="lineno"> 1466 </span><span class="spaces">                  </span><span class="istickedoff">, [ &quot;Tried to read an array prefix of size:&quot;, show (MS.ppTypedTerm expected_sz_tm) ]</span>
<span class="lineno"> 1467 </span><span class="spaces">                  </span><span class="istickedoff">]</span>
<span class="lineno"> 1468 </span><span class="spaces">            </span><span class="istickedoff">case maybe_allocation_array of</span>
<span class="lineno"> 1469 </span><span class="spaces">              </span><span class="istickedoff">Just (ok, arr, sz)</span>
<span class="lineno"> 1470 </span><span class="spaces">                </span><span class="istickedoff">| Crucible.LLVMPointer _ off &lt;- ptr -&gt;</span>
<span class="lineno"> 1471 </span><span class="spaces">                </span><span class="istickedoff">do addAssert ok <span class="nottickedoff">md</span> $ Crucible.SimError loc $ Crucible.GenericSimError $ show errMsg</span>
<span class="lineno"> 1472 </span><span class="spaces">                   </span><span class="istickedoff">sub &lt;- OM (use <span class="nottickedoff">termSub</span>)</span>
<span class="lineno"> 1473 </span><span class="spaces">                   </span><span class="istickedoff">st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno"> 1474 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1475 </span><span class="spaces">                   </span><span class="istickedoff">ptr_width_tm &lt;- liftIO $ scNat sc $ natValue ?ptrWidth</span>
<span class="lineno"> 1476 </span><span class="spaces">                   </span><span class="istickedoff">off_type_tm &lt;- liftIO $ scBitvector sc $ natValue ?ptrWidth</span>
<span class="lineno"> 1477 </span><span class="spaces">                   </span><span class="istickedoff">off_tm &lt;- liftIO $ toSC <span class="nottickedoff">sym</span> st off</span>
<span class="lineno"> 1478 </span><span class="spaces">                   </span><span class="istickedoff">alloc_arr_tm &lt;- liftIO $ toSC <span class="nottickedoff">sym</span> st arr</span>
<span class="lineno"> 1479 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1480 </span><span class="spaces">                   </span><span class="istickedoff">arr_tm &lt;- liftIO $ case BV.asUnsigned &lt;$&gt; W4.asBV off of</span>
<span class="lineno"> 1481 </span><span class="spaces">                     </span><span class="istickedoff">Just 0 -&gt; return alloc_arr_tm</span>
<span class="lineno"> 1482 </span><span class="spaces">                     </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1483 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">do byte_width_tm &lt;- scNat sc 8</span></span>
<span class="lineno"> 1484 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">byte_type_tm &lt;- scBitvector sc 8</span></span>
<span class="lineno"> 1485 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 1486 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">zero_off_tm &lt;- scBvNat sc ptr_width_tm =&lt;&lt; scNat sc 0</span></span>
<span class="lineno"> 1487 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">zero_byte_tm &lt;- scBvNat sc byte_width_tm =&lt;&lt; scNat sc 0</span></span>
<span class="lineno"> 1488 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">zero_arr_const_tm &lt;- scArrayConstant sc off_type_tm byte_type_tm zero_byte_tm</span></span>
<span class="lineno"> 1489 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 1490 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">instantiated_expected_sz_tm &lt;- scInstantiateExt sc sub $ ttTerm expected_sz_tm</span></span>
<span class="lineno"> 1491 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">scArrayCopy sc ptr_width_tm byte_type_tm</span></span>
<span class="lineno"> 1492 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">zero_arr_const_tm -- dest array</span></span>
<span class="lineno"> 1493 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">zero_off_tm -- dest offset</span></span>
<span class="lineno"> 1494 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">alloc_arr_tm -- src array</span></span>
<span class="lineno"> 1495 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">off_tm -- src offset</span></span>
<span class="lineno"> 1496 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">instantiated_expected_sz_tm</span> -- length</span>
<span class="lineno"> 1497 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1498 </span><span class="spaces">                   </span><span class="istickedoff">instantiateExtMatchTerm sc <span class="nottickedoff">md</span> <span class="nottickedoff">prepost</span> arr_tm $ ttTerm expected_arr_tm</span>
<span class="lineno"> 1499 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1500 </span><span class="spaces">                   </span><span class="istickedoff">sz_tm &lt;- liftIO $ toSC <span class="nottickedoff">sym</span> st sz</span>
<span class="lineno"> 1501 </span><span class="spaces">                   </span><span class="istickedoff">expected_end_off_tm &lt;- liftIO $ scBvAdd sc ptr_width_tm off_tm $ ttTerm expected_sz_tm</span>
<span class="lineno"> 1502 </span><span class="spaces">                   </span><span class="istickedoff">inbounds_check_tm &lt;- liftIO $ scBvULe sc ptr_width_tm expected_end_off_tm sz_tm</span>
<span class="lineno"> 1503 </span><span class="spaces">                   </span><span class="istickedoff">learnPred sc cc md prepost inbounds_check_tm</span>
<span class="lineno"> 1504 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1505 </span><span class="spaces">                   </span><span class="istickedoff">return Nothing</span>
<span class="lineno"> 1506 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1507 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1508 </span><span class="spaces">                </span><span class="istickedoff">do sub &lt;- OM (use <span class="nottickedoff">termSub</span>)</span>
<span class="lineno"> 1509 </span><span class="spaces">                   </span><span class="istickedoff">modmap &lt;- liftIO $ scGetModuleMap sc</span>
<span class="lineno"> 1510 </span><span class="spaces">                   </span><span class="istickedoff">instantiated_expected_sz_tm &lt;- liftIO $ scInstantiateExt sc <span class="nottickedoff">sub</span> $ ttTerm expected_sz_tm</span>
<span class="lineno"> 1511 </span><span class="spaces">                   </span><span class="istickedoff">normalized_expected_sz_tm &lt;- liftIO $</span>
<span class="lineno"> 1512 </span><span class="spaces">                     </span><span class="istickedoff">normalizeSharedTerm sc modmap mempty <span class="nottickedoff">mempty</span> mempty instantiated_expected_sz_tm</span>
<span class="lineno"> 1513 </span><span class="spaces">                   </span><span class="istickedoff">case asUnsignedConcreteBv normalized_expected_sz_tm of</span>
<span class="lineno"> 1514 </span><span class="spaces">                     </span><span class="istickedoff">Just sz_nat -&gt;</span>
<span class="lineno"> 1515 </span><span class="spaces">                       </span><span class="istickedoff">do sz_bv &lt;- liftIO $</span>
<span class="lineno"> 1516 </span><span class="spaces">                            </span><span class="istickedoff">W4.bvLit sym Crucible.PtrWidth $ BV.mkBV Crucible.PtrWidth $ fromIntegral sz_nat</span>
<span class="lineno"> 1517 </span><span class="spaces">                          </span><span class="istickedoff">maybe_matching_array &lt;- liftIO $</span>
<span class="lineno"> 1518 </span><span class="spaces">                            </span><span class="istickedoff">Crucible.asMemMatchingArrayStore <span class="nottickedoff">sym</span> Crucible.PtrWidth ptr <span class="nottickedoff">sz_bv</span> (Crucible.memImplHeap mem)</span>
<span class="lineno"> 1519 </span><span class="spaces">                          </span><span class="istickedoff">res &lt;- case maybe_matching_array of</span>
<span class="lineno"> 1520 </span><span class="spaces">                            </span><span class="istickedoff">Just (ok, arr) -&gt; <span class="nottickedoff">return $ Right (ok, arr)</span></span>
<span class="lineno"> 1521 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt; liftIO $ Crucible.loadArrayConcreteSizeRaw sym mem ptr sz_nat alignment</span>
<span class="lineno"> 1522 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1523 </span><span class="spaces">                          </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1524 </span><span class="spaces">                            </span><span class="istickedoff">Right (ok, arr) -&gt;</span>
<span class="lineno"> 1525 </span><span class="spaces">                              </span><span class="istickedoff">do addAssert ok <span class="nottickedoff">md</span> $ Crucible.SimError loc $ Crucible.GenericSimError $ show errMsg</span>
<span class="lineno"> 1526 </span><span class="spaces">                                 </span><span class="istickedoff">st &lt;- liftIO (sawCoreState sym)</span>
<span class="lineno"> 1527 </span><span class="spaces">                                 </span><span class="istickedoff">arr_tm &lt;- liftIO $ toSC sym st arr</span>
<span class="lineno"> 1528 </span><span class="spaces">                                 </span><span class="istickedoff">instantiateExtMatchTerm sc <span class="nottickedoff">md</span> <span class="nottickedoff">prepost</span> arr_tm $ ttTerm expected_arr_tm</span>
<span class="lineno"> 1529 </span><span class="spaces">                                 </span><span class="istickedoff">return Nothing</span>
<span class="lineno"> 1530 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1531 </span><span class="spaces">                            </span><span class="istickedoff">Left{} -&gt; <span class="nottickedoff">return $ Just errMsg</span></span>
<span class="lineno"> 1532 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1533 </span><span class="spaces">                     </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return $ Just errMsg</span></span></span>
<span class="lineno"> 1534 </span>
<span class="lineno"> 1535 </span>
<span class="lineno"> 1536 </span>-- | Like 'matchPointsToValue', but specifically geared towards the needs
<span class="lineno"> 1537 </span>-- of fields within bitfields. In particular, this performs all of the
<span class="lineno"> 1538 </span>-- necessary bit-twiddling on the LHS (a bitfield) to extract the necessary
<span class="lineno"> 1539 </span>-- field and match it against the RHS.
<span class="lineno"> 1540 </span>matchPointsToBitfieldValue ::
<span class="lineno"> 1541 </span>  forall arch md ann.
<span class="lineno"> 1542 </span>  ( ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1543 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1544 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1545 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1546 </span>  ) =&gt;
<span class="lineno"> 1547 </span>  Options -&gt;
<span class="lineno"> 1548 </span>  SharedContext -&gt;
<span class="lineno"> 1549 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1550 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1551 </span>  PrePost -&gt;
<span class="lineno"> 1552 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 1553 </span>  LLVMPtr (Crucible.ArchWidth arch) -&gt;
<span class="lineno"> 1554 </span>  BitfieldIndex -&gt;
<span class="lineno"> 1555 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno"> 1556 </span>  OverrideMatcher (LLVM arch) md (Maybe (PP.Doc ann))
<span class="lineno"> 1557 </span><span class="decl"><span class="istickedoff">matchPointsToBitfieldValue opts sc cc spec prepost md ptr bfIndex val =</span>
<span class="lineno"> 1558 </span><span class="spaces">  </span><span class="istickedoff">do let loc = MS.conditionLoc md</span>
<span class="lineno"> 1559 </span><span class="spaces">     </span><span class="istickedoff">sym    &lt;- Ov.getSymInterface</span>
<span class="lineno"> 1560 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1561 </span><span class="spaces">     </span><span class="istickedoff">mem    &lt;- readGlobal $ Crucible.llvmMemVar</span>
<span class="lineno"> 1562 </span><span class="spaces">                          </span><span class="istickedoff">$ ccLLVMContext cc</span>
<span class="lineno"> 1563 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1564 </span><span class="spaces">     </span><span class="istickedoff">let alignment = Crucible.noAlignment -- default to byte alignment (FIXME, see #338)</span>
<span class="lineno"> 1565 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1566 </span><span class="spaces">     </span><span class="istickedoff">-- Unlike in matchPointsToValue, we compute the MemTy/StorageType not from</span>
<span class="lineno"> 1567 </span><span class="spaces">     </span><span class="istickedoff">-- the RHS value, but from the BitfieldIndex. This is because we need to</span>
<span class="lineno"> 1568 </span><span class="spaces">     </span><span class="istickedoff">-- load the entire bitfield, which can be larger than the size of the RHS</span>
<span class="lineno"> 1569 </span><span class="spaces">     </span><span class="istickedoff">-- value.</span>
<span class="lineno"> 1570 </span><span class="spaces">     </span><span class="istickedoff">let memTy = biBitfieldType bfIndex</span>
<span class="lineno"> 1571 </span><span class="spaces">     </span><span class="istickedoff">storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno"> 1572 </span><span class="spaces">     </span><span class="istickedoff">res &lt;- liftIO $ Crucible.loadRaw sym mem ptr storTy alignment</span>
<span class="lineno"> 1573 </span><span class="spaces">     </span><span class="istickedoff">let badLoadSummary = summarizeBadLoad <span class="nottickedoff">cc</span> <span class="nottickedoff">memTy</span> <span class="nottickedoff">prepost</span> ptr</span>
<span class="lineno"> 1574 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1575 </span><span class="spaces">       </span><span class="istickedoff">Crucible.NoErr pred_ res_val -&gt; do</span>
<span class="lineno"> 1576 </span><span class="spaces">         </span><span class="istickedoff">addAssert pred_ <span class="nottickedoff">md</span> $ Crucible.SimError loc $</span>
<span class="lineno"> 1577 </span><span class="spaces">           </span><span class="istickedoff">Crucible.AssertFailureSimError (show $ PP.vcat badLoadSummary) &quot;&quot;</span>
<span class="lineno"> 1578 </span><span class="spaces">         </span><span class="istickedoff">case res_val of</span>
<span class="lineno"> 1579 </span><span class="spaces">           </span><span class="istickedoff">-- This will only work if:</span>
<span class="lineno"> 1580 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno"> 1581 </span><span class="spaces">           </span><span class="istickedoff">-- * The bitfield is in fact a bitvector, and</span>
<span class="lineno"> 1582 </span><span class="spaces">           </span><span class="istickedoff">-- * The width of the RHS type is less than the width of the</span>
<span class="lineno"> 1583 </span><span class="spaces">           </span><span class="istickedoff">--   bitfield type.</span>
<span class="lineno"> 1584 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno"> 1585 </span><span class="spaces">           </span><span class="istickedoff">-- We check these criteria in this case.</span>
<span class="lineno"> 1586 </span><span class="spaces">           </span><span class="istickedoff">Crucible.LLVMValInt bfBlk bfBV</span>
<span class="lineno"> 1587 </span><span class="spaces">             </span><span class="istickedoff">|  let bfWidth = W4.bvWidth bfBV</span>
<span class="lineno"> 1588 </span><span class="spaces">             </span><span class="istickedoff">,  Some rhsWidth &lt;- mkNatRepr $ fromIntegral $ biFieldSize bfIndex</span>
<span class="lineno"> 1589 </span><span class="spaces">             </span><span class="istickedoff">-&gt; case (testLeq (knownNat @1) rhsWidth, testLeq (incNat rhsWidth) bfWidth) of</span>
<span class="lineno"> 1590 </span><span class="spaces">                  </span><span class="istickedoff">(Just LeqProof, Just LeqProof) -&gt;</span>
<span class="lineno"> 1591 </span><span class="spaces">                    </span><span class="istickedoff">do -- Here is where we perform the bit-twiddling needed</span>
<span class="lineno"> 1592 </span><span class="spaces">                       </span><span class="istickedoff">-- to match the RHS value against the field within the</span>
<span class="lineno"> 1593 </span><span class="spaces">                       </span><span class="istickedoff">-- bitfield. We will use this as a running example:</span>
<span class="lineno"> 1594 </span><span class="spaces">                       </span><span class="istickedoff">--</span>
<span class="lineno"> 1595 </span><span class="spaces">                       </span><span class="istickedoff">--   struct s {</span>
<span class="lineno"> 1596 </span><span class="spaces">                       </span><span class="istickedoff">--     int32_t w;</span>
<span class="lineno"> 1597 </span><span class="spaces">                       </span><span class="istickedoff">--     uint8_t x1:1;</span>
<span class="lineno"> 1598 </span><span class="spaces">                       </span><span class="istickedoff">--     uint8_t x2:2;</span>
<span class="lineno"> 1599 </span><span class="spaces">                       </span><span class="istickedoff">--     uint8_t y:1;</span>
<span class="lineno"> 1600 </span><span class="spaces">                       </span><span class="istickedoff">--     int32_t z;</span>
<span class="lineno"> 1601 </span><span class="spaces">                       </span><span class="istickedoff">--   };</span>
<span class="lineno"> 1602 </span><span class="spaces">                       </span><span class="istickedoff">--</span>
<span class="lineno"> 1603 </span><span class="spaces">                       </span><span class="istickedoff">-- Let us imagine that we are matching against the</span>
<span class="lineno"> 1604 </span><span class="spaces">                       </span><span class="istickedoff">-- `y` field. The bitfield (bfBV) will look something</span>
<span class="lineno"> 1605 </span><span class="spaces">                       </span><span class="istickedoff">-- like 0b????Y???, where `Y` denotes the value of the</span>
<span class="lineno"> 1606 </span><span class="spaces">                       </span><span class="istickedoff">-- `y` bit. Here, `bfWidth` (the width of the entire</span>
<span class="lineno"> 1607 </span><span class="spaces">                       </span><span class="istickedoff">-- bitfield in bits) is 8, and `rhsWidth` (the width of</span>
<span class="lineno"> 1608 </span><span class="spaces">                       </span><span class="istickedoff">-- the `y` field in bits) is 1.</span>
<span class="lineno"> 1609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1610 </span><span class="spaces">                       </span><span class="istickedoff">-- The offset (in bits) of the field within the</span>
<span class="lineno"> 1611 </span><span class="spaces">                       </span><span class="istickedoff">-- bitfield. For `y`, this is 3 (x1's offset is 0 and</span>
<span class="lineno"> 1612 </span><span class="spaces">                       </span><span class="istickedoff">-- `x2`'s offset is 1).</span>
<span class="lineno"> 1613 </span><span class="spaces">                       </span><span class="istickedoff">Some bfOffset &lt;- pure $ mkNatRepr $ fromIntegral</span>
<span class="lineno"> 1614 </span><span class="spaces">                                             </span><span class="istickedoff">$ biFieldOffset bfIndex</span>
<span class="lineno"> 1615 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1616 </span><span class="spaces">                       </span><span class="istickedoff">-- Next, convince the typechecker that</span>
<span class="lineno"> 1617 </span><span class="spaces">                       </span><span class="istickedoff">-- (bfOffset + rhsWidth) &lt;= bfWidth. This should always</span>
<span class="lineno"> 1618 </span><span class="spaces">                       </span><span class="istickedoff">-- be the case if the BitfieldIndex is constructed</span>
<span class="lineno"> 1619 </span><span class="spaces">                       </span><span class="istickedoff">-- correctly.</span>
<span class="lineno"> 1620 </span><span class="spaces">                       </span><span class="istickedoff">LeqProof &lt;- case testLeq (addNat bfOffset rhsWidth) bfWidth of</span>
<span class="lineno"> 1621 </span><span class="spaces">                         </span><span class="istickedoff">Just prf -&gt; pure prf</span>
<span class="lineno"> 1622 </span><span class="spaces">                         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic</span></span>
<span class="lineno"> 1623 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot;llvm_points_to_bitfield: Unexpected bitfield field offset&quot;</span></span>
<span class="lineno"> 1624 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Field offset: &quot; ++ show bfOffset</span></span>
<span class="lineno"> 1625 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">, &quot;RHS value width: &quot; ++ show rhsWidth</span></span>
<span class="lineno"> 1626 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bitvector width: &quot; ++ show bfWidth</span></span>
<span class="lineno"> 1627 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1628 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1629 </span><span class="spaces">                       </span><span class="istickedoff">-- Finally, select the subsequence of bits from the</span>
<span class="lineno"> 1630 </span><span class="spaces">                       </span><span class="istickedoff">-- bitfield corresponding to the field. In the `y`</span>
<span class="lineno"> 1631 </span><span class="spaces">                       </span><span class="istickedoff">-- example, the means selecting `0bY` from `0b????Y???`.</span>
<span class="lineno"> 1632 </span><span class="spaces">                       </span><span class="istickedoff">bfFieldBV &lt;- liftIO $ W4.bvSelect sym bfOffset rhsWidth bfBV</span>
<span class="lineno"> 1633 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1634 </span><span class="spaces">                       </span><span class="istickedoff">-- Match the selected field against the RHS value.</span>
<span class="lineno"> 1635 </span><span class="spaces">                       </span><span class="istickedoff">let field_val = Crucible.LLVMValInt bfBlk bfFieldBV</span>
<span class="lineno"> 1636 </span><span class="spaces">                       </span><span class="istickedoff">pure Nothing &lt;* matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">spec</span> <span class="nottickedoff">prepost</span> md field_val <span class="nottickedoff">memTy</span> val</span>
<span class="lineno"> 1637 </span><span class="spaces">                  </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1638 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1639 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_points_to_bitfield: RHS value's size must be less then or equal to bitfield's size&quot;</span></span>
<span class="lineno"> 1640 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bitvector width: &quot; ++ show bfWidth</span></span>
<span class="lineno"> 1641 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">, &quot;RHS value width: &quot; ++ show rhsWidth</span></span>
<span class="lineno"> 1642 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1643 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1644 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_points_to_bitfield: The bitfield must be a bitvector&quot;</span></span>
<span class="lineno"> 1645 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bitfield value: &quot; ++ show (Crucible.ppTermExpr res_val)</span></span>
<span class="lineno"> 1646 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1647 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1648 </span><span class="spaces">         </span><span class="istickedoff">-- When we have a concrete failure, we do a little more computation to</span>
<span class="lineno"> 1649 </span><span class="spaces">         </span><span class="istickedoff">-- try and find out why.</span>
<span class="lineno"> 1650 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">pure $ Just $ describeConcreteMemoryLoadFailure mem badLoadSummary ptr</span></span></span>
<span class="lineno"> 1651 </span>
<span class="lineno"> 1652 </span>-- | Give a general summary of why a call to 'Crucible.loadRaw' in
<span class="lineno"> 1653 </span>-- @matchPointsTo{Bitfield}Value@ failed. This is used for error-message
<span class="lineno"> 1654 </span>-- purposes.
<span class="lineno"> 1655 </span>summarizeBadLoad ::
<span class="lineno"> 1656 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1657 </span>  Crucible.MemType -&gt;
<span class="lineno"> 1658 </span>  PrePost -&gt;
<span class="lineno"> 1659 </span>  LLVMPtr wptr -&gt;
<span class="lineno"> 1660 </span>  [PP.Doc ann]
<span class="lineno"> 1661 </span><span class="decl"><span class="istickedoff">summarizeBadLoad cc memTy prepost ptr =</span>
<span class="lineno"> 1662 </span><span class="spaces"> </span><span class="istickedoff">let <span class="nottickedoff">dataLayout = Crucible.llvmDataLayout (ccTypeCtx cc)</span></span>
<span class="lineno"> 1663 </span><span class="spaces">     </span><span class="istickedoff">sz = Crucible.memTypeSize <span class="nottickedoff">dataLayout</span> memTy</span>
<span class="lineno"> 1664 </span><span class="spaces"> </span><span class="istickedoff">in map (PP.pretty . unwords)</span>
<span class="lineno"> 1665 </span><span class="spaces">    </span><span class="istickedoff">[ [ &quot;When reading through pointer:&quot;, show (Crucible.ppPtr ptr) ]</span>
<span class="lineno"> 1666 </span><span class="spaces">    </span><span class="istickedoff">, [ &quot;in the &quot;, MS.stateCond prepost, &quot;of an override&quot; ]</span>
<span class="lineno"> 1667 </span><span class="spaces">    </span><span class="istickedoff">, [ &quot;Tried to read something of size:&quot;</span>
<span class="lineno"> 1668 </span><span class="spaces">      </span><span class="istickedoff">, show (Crucible.bytesToInteger sz)</span>
<span class="lineno"> 1669 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno"> 1670 </span><span class="spaces">    </span><span class="istickedoff">, [ &quot;And type:&quot;, show (Crucible.ppMemType memTy) ]</span>
<span class="lineno"> 1671 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1672 </span>
<span class="lineno"> 1673 </span>-- | Give a summary of why a call to 'Crucible.loadRaw' in
<span class="lineno"> 1674 </span>-- @matchPointsTo{Bitfield}Value@ concretely failed. This is used for
<span class="lineno"> 1675 </span>-- error-message purposes.
<span class="lineno"> 1676 </span>describeConcreteMemoryLoadFailure ::
<span class="lineno"> 1677 </span>  Crucible.MemImpl Sym -&gt;
<span class="lineno"> 1678 </span>  [PP.Doc ann] {- A summary of why the load failed -} -&gt;
<span class="lineno"> 1679 </span>  LLVMPtr w -&gt;
<span class="lineno"> 1680 </span>  PP.Doc ann
<span class="lineno"> 1681 </span><span class="decl"><span class="nottickedoff">describeConcreteMemoryLoadFailure mem badLoadSummary ptr = do</span>
<span class="lineno"> 1682 </span><span class="spaces">  </span><span class="nottickedoff">let (blk, _offset) = Crucible.llvmPointerView ptr</span>
<span class="lineno"> 1683 </span><span class="spaces">  </span><span class="nottickedoff">PP.vcat . (badLoadSummary ++) $</span>
<span class="lineno"> 1684 </span><span class="spaces">    </span><span class="nottickedoff">case W4.asNat blk of</span>
<span class="lineno"> 1685 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; [&quot;&lt;Read from unknown allocation&gt;&quot;]</span>
<span class="lineno"> 1686 </span><span class="spaces">      </span><span class="nottickedoff">Just blk' -&gt;</span>
<span class="lineno"> 1687 </span><span class="spaces">        </span><span class="nottickedoff">let possibleAllocs =</span>
<span class="lineno"> 1688 </span><span class="spaces">              </span><span class="nottickedoff">Crucible.possibleAllocs blk' (Crucible.memImplHeap mem)</span>
<span class="lineno"> 1689 </span><span class="spaces">        </span><span class="nottickedoff">in [ PP.pretty $ unwords</span>
<span class="lineno"> 1690 </span><span class="spaces">             </span><span class="nottickedoff">[ &quot;Found&quot;</span>
<span class="lineno"> 1691 </span><span class="spaces">             </span><span class="nottickedoff">, show (length possibleAllocs)</span>
<span class="lineno"> 1692 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;possibly matching allocation(s):&quot;</span>
<span class="lineno"> 1693 </span><span class="spaces">             </span><span class="nottickedoff">]</span>
<span class="lineno"> 1694 </span><span class="spaces">           </span><span class="nottickedoff">, bullets '-' (map (PP.viaShow . Crucible.ppSomeAlloc) possibleAllocs)</span>
<span class="lineno"> 1695 </span><span class="spaces">             </span><span class="nottickedoff">-- TODO: remove 'viaShow' when crucible switches to prettyprinter</span>
<span class="lineno"> 1696 </span><span class="spaces">           </span><span class="nottickedoff">]</span></span>
<span class="lineno"> 1697 </span>        -- This information tends to be overwhelming, but might be useful?
<span class="lineno"> 1698 </span>        -- We should brainstorm about better ways of presenting it.
<span class="lineno"> 1699 </span>        -- PP.&lt;$$&gt; PP.text (unwords [ &quot;Here are the details on why reading&quot;
<span class="lineno"> 1700 </span>        --                          , &quot;from each matching write failed&quot;
<span class="lineno"> 1701 </span>        --                          ])
<span class="lineno"> 1702 </span>        -- PP.&lt;$$&gt; PP.text (show err)
<span class="lineno"> 1703 </span>
<span class="lineno"> 1704 </span>------------------------------------------------------------------------
<span class="lineno"> 1705 </span>
<span class="lineno"> 1706 </span>-- | Process an @llvm_equal@ statement from the precondition
<span class="lineno"> 1707 </span>-- section of the CrucibleSetup block.
<span class="lineno"> 1708 </span>learnEqual ::
<span class="lineno"> 1709 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 1710 </span>  Options                                          -&gt;
<span class="lineno"> 1711 </span>  SharedContext                                    -&gt;
<span class="lineno"> 1712 </span>  LLVMCrucibleContext arch                            -&gt;
<span class="lineno"> 1713 </span>  MS.CrucibleMethodSpecIR (LLVM arch)                             -&gt;
<span class="lineno"> 1714 </span>  MS.ConditionMetadata                             -&gt;
<span class="lineno"> 1715 </span>  PrePost                                          -&gt;
<span class="lineno"> 1716 </span>  SetupValue (LLVM arch)       {- ^ first value to compare  -} -&gt;
<span class="lineno"> 1717 </span>  SetupValue (LLVM arch)       {- ^ second value to compare -} -&gt;
<span class="lineno"> 1718 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 1719 </span><span class="decl"><span class="istickedoff">learnEqual opts sc cc spec md prepost v1 v2 = do</span>
<span class="lineno"> 1720 </span><span class="spaces">  </span><span class="istickedoff">(_, val1) &lt;- resolveSetupValueLLVM <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> <span class="nottickedoff">spec</span> v1</span>
<span class="lineno"> 1721 </span><span class="spaces">  </span><span class="istickedoff">(_, val2) &lt;- resolveSetupValueLLVM <span class="nottickedoff">opts</span> cc sc <span class="nottickedoff">spec</span> v2</span>
<span class="lineno"> 1722 </span><span class="spaces">  </span><span class="istickedoff">p         &lt;- liftIO (equalValsPred cc val1 val2)</span>
<span class="lineno"> 1723 </span><span class="spaces">  </span><span class="istickedoff">let name = &quot;equality &quot; ++ <span class="nottickedoff">MS.stateCond prepost</span></span>
<span class="lineno"> 1724 </span><span class="spaces">  </span><span class="istickedoff">let loc = MS.conditionLoc md</span>
<span class="lineno"> 1725 </span><span class="spaces">  </span><span class="istickedoff">addAssert p <span class="nottickedoff">md</span> (Crucible.SimError loc (Crucible.AssertFailureSimError name &quot;&quot;))</span></span>
<span class="lineno"> 1726 </span>
<span class="lineno"> 1727 </span>-- | Process an @llvm_precond@ statement from the precondition
<span class="lineno"> 1728 </span>-- section of the CrucibleSetup block.
<span class="lineno"> 1729 </span>learnPred ::
<span class="lineno"> 1730 </span>  (?w4EvalTactic :: W4EvalTactic) =&gt;
<span class="lineno"> 1731 </span>  SharedContext                                                       -&gt;
<span class="lineno"> 1732 </span>  LLVMCrucibleContext arch                                               -&gt;
<span class="lineno"> 1733 </span>  MS.ConditionMetadata                                                -&gt;
<span class="lineno"> 1734 </span>  PrePost                                                             -&gt;
<span class="lineno"> 1735 </span>  Term             {- ^ the precondition to learn                  -} -&gt;
<span class="lineno"> 1736 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 1737 </span><span class="decl"><span class="istickedoff">learnPred sc cc md prepost t =</span>
<span class="lineno"> 1738 </span><span class="spaces">  </span><span class="istickedoff">do p &lt;- instantiateExtResolveSAWPred sc cc t</span>
<span class="lineno"> 1739 </span><span class="spaces">     </span><span class="istickedoff">let loc = MS.conditionLoc md</span>
<span class="lineno"> 1740 </span><span class="spaces">     </span><span class="istickedoff">addAssert p md (Crucible.SimError loc (Crucible.AssertFailureSimError (MS.stateCond prepost) &quot;&quot;))</span></span>
<span class="lineno"> 1741 </span>
<span class="lineno"> 1742 </span>instantiateExtResolveSAWPred ::
<span class="lineno"> 1743 </span>  (?w4EvalTactic :: W4EvalTactic) =&gt;
<span class="lineno"> 1744 </span>  SharedContext -&gt;
<span class="lineno"> 1745 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1746 </span>  Term -&gt;
<span class="lineno"> 1747 </span>  OverrideMatcher (LLVM arch) md (W4.Pred Sym)
<span class="lineno"> 1748 </span><span class="decl"><span class="istickedoff">instantiateExtResolveSAWPred sc cc cond = do</span>
<span class="lineno"> 1749 </span><span class="spaces">  </span><span class="istickedoff">sub &lt;- OM (use termSub)</span>
<span class="lineno"> 1750 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ resolveSAWPred cc =&lt;&lt; scInstantiateExt sc sub cond</span></span>
<span class="lineno"> 1751 </span>
<span class="lineno"> 1752 </span>instantiateExtResolveSAWSymBV ::
<span class="lineno"> 1753 </span>  (?w4EvalTactic :: W4EvalTactic, 1 &lt;= w) =&gt;
<span class="lineno"> 1754 </span>  SharedContext -&gt;
<span class="lineno"> 1755 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1756 </span>  NatRepr w -&gt;
<span class="lineno"> 1757 </span>  Term -&gt;
<span class="lineno"> 1758 </span>  OverrideMatcher (LLVM arch) md (W4.SymBV Sym w)
<span class="lineno"> 1759 </span><span class="decl"><span class="istickedoff">instantiateExtResolveSAWSymBV sc cc w tm = do</span>
<span class="lineno"> 1760 </span><span class="spaces">  </span><span class="istickedoff">sub &lt;- OM (use termSub)</span>
<span class="lineno"> 1761 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ resolveSAWSymBV cc w =&lt;&lt; scInstantiateExt sc sub tm</span></span>
<span class="lineno"> 1762 </span>
<span class="lineno"> 1763 </span>------------------------------------------------------------------------
<span class="lineno"> 1764 </span>
<span class="lineno"> 1765 </span>-- | Invalidate all mutable memory that was allocated in the method spec
<span class="lineno"> 1766 </span>-- precondition, either through explicit calls to @llvm_alloc@ or to
<span class="lineno"> 1767 </span>-- @llvm_alloc_global@. As an optimization, a memory allocation that
<span class="lineno"> 1768 </span>-- is overwritten by a postcondition memory write is not invalidated.
<span class="lineno"> 1769 </span>-- Return a map containing the overwritten memory allocations.
<span class="lineno"> 1770 </span>invalidateMutableAllocs ::
<span class="lineno"> 1771 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1772 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1773 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1774 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1775 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1776 </span>  ) =&gt;
<span class="lineno"> 1777 </span>  Options -&gt;
<span class="lineno"> 1778 </span>  SharedContext -&gt;
<span class="lineno"> 1779 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1780 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1781 </span>  OverrideMatcher (LLVM arch) RW (Map (W4.SymNat Sym) Text)
<span class="lineno"> 1782 </span><span class="decl"><span class="istickedoff">invalidateMutableAllocs opts sc cc cs =</span>
<span class="lineno"> 1783 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 1784 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno"> 1785 </span><span class="spaces">  </span><span class="istickedoff">mem &lt;- readGlobal . Crucible.llvmMemVar $ ccLLVMContext cc</span>
<span class="lineno"> 1786 </span><span class="spaces">  </span><span class="istickedoff">sub &lt;- use setupValueSub</span>
<span class="lineno"> 1787 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1788 </span><span class="spaces">  </span><span class="istickedoff">let mutableAllocs =</span>
<span class="lineno"> 1789 </span><span class="spaces">        </span><span class="istickedoff">Map.filter (view isMut) $</span>
<span class="lineno"> 1790 </span><span class="spaces">        </span><span class="istickedoff">Map.filter (not . view allocSpecFresh) $</span>
<span class="lineno"> 1791 </span><span class="spaces">        </span><span class="istickedoff">cs ^. MS.csPreState . MS.csAllocs</span>
<span class="lineno"> 1792 </span><span class="spaces">      </span><span class="istickedoff">allocPtrs = catMaybes $ map</span>
<span class="lineno"> 1793 </span><span class="spaces">        </span><span class="istickedoff">(\case</span>
<span class="lineno"> 1794 </span><span class="spaces">          </span><span class="istickedoff">(ptr, spec)</span>
<span class="lineno"> 1795 </span><span class="spaces">            </span><span class="istickedoff">| Just sz &lt;- asUnsignedConcreteBv (_allocSpecBytes spec) -&gt;</span>
<span class="lineno"> 1796 </span><span class="spaces">              </span><span class="istickedoff">Just</span>
<span class="lineno"> 1797 </span><span class="spaces">                </span><span class="istickedoff">( ptr</span>
<span class="lineno"> 1798 </span><span class="spaces">                </span><span class="istickedoff">, fromIntegral sz</span>
<span class="lineno"> 1799 </span><span class="spaces">                </span><span class="istickedoff">, mconcat</span>
<span class="lineno"> 1800 </span><span class="spaces">                  </span><span class="istickedoff">[ &quot;state of memory allocated in precondition (at &quot;</span>
<span class="lineno"> 1801 </span><span class="spaces">                  </span><span class="istickedoff">, pack . show . W4.plSourceLoc . MS.conditionLoc</span>
<span class="lineno"> 1802 </span><span class="spaces">                      </span><span class="istickedoff">$ spec ^. allocSpecMd</span>
<span class="lineno"> 1803 </span><span class="spaces">                  </span><span class="istickedoff">, &quot;) not described in postcondition&quot;</span>
<span class="lineno"> 1804 </span><span class="spaces">                  </span><span class="istickedoff">]</span>
<span class="lineno"> 1805 </span><span class="spaces">                </span><span class="istickedoff">)</span>
<span class="lineno"> 1806 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; Nothing)</span>
<span class="lineno"> 1807 </span><span class="spaces">        </span><span class="istickedoff">(Map.elems (Map.intersectionWith (,) sub mutableAllocs))</span>
<span class="lineno"> 1808 </span><span class="spaces">      </span><span class="istickedoff">mtrans = ccLLVMModuleTrans cc</span>
<span class="lineno"> 1809 </span><span class="spaces">      </span><span class="istickedoff">gimap = view Crucible.globalInitMap mtrans</span>
<span class="lineno"> 1810 </span><span class="spaces">      </span><span class="istickedoff">mutableGlobals = cs ^. MS.csGlobalAllocs</span>
<span class="lineno"> 1811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1812 </span><span class="spaces">  </span><span class="istickedoff">globalPtrs &lt;- liftIO . fmap catMaybes . forM mutableGlobals $ \(LLVMAllocGlobal loc s@(L.Symbol st)) -&gt;</span>
<span class="lineno"> 1813 </span><span class="spaces">    </span><span class="istickedoff">case Map.lookup s gimap of</span>
<span class="lineno"> 1814 </span><span class="spaces">      </span><span class="istickedoff">Just (_, Right (mt, _)) -&gt; do</span>
<span class="lineno"> 1815 </span><span class="spaces">        </span><span class="istickedoff">ptr &lt;- Crucible.doResolveGlobal <span class="nottickedoff">bak</span> mem s</span>
<span class="lineno"> 1816 </span><span class="spaces">        </span><span class="istickedoff">pure $ Just</span>
<span class="lineno"> 1817 </span><span class="spaces">          </span><span class="istickedoff">( ptr</span>
<span class="lineno"> 1818 </span><span class="spaces">          </span><span class="istickedoff">, Crucible.memTypeSize <span class="nottickedoff">(Crucible.llvmDataLayout ?lc)</span> mt</span>
<span class="lineno"> 1819 </span><span class="spaces">          </span><span class="istickedoff">, mconcat</span>
<span class="lineno"> 1820 </span><span class="spaces">            </span><span class="istickedoff">[ &quot;state of mutable global variable \&quot;&quot;</span>
<span class="lineno"> 1821 </span><span class="spaces">            </span><span class="istickedoff">, pack st</span>
<span class="lineno"> 1822 </span><span class="spaces">            </span><span class="istickedoff">, &quot;\&quot; (allocated at &quot;</span>
<span class="lineno"> 1823 </span><span class="spaces">            </span><span class="istickedoff">, pack . show $ W4.plSourceLoc loc</span>
<span class="lineno"> 1824 </span><span class="spaces">            </span><span class="istickedoff">, &quot;) not described in postcondition&quot;</span>
<span class="lineno"> 1825 </span><span class="spaces">            </span><span class="istickedoff">]</span>
<span class="lineno"> 1826 </span><span class="spaces">          </span><span class="istickedoff">)</span>
<span class="lineno"> 1827 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno"> 1828 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1829 </span><span class="spaces">  </span><span class="istickedoff">-- set of (concrete base pointer, size) for each postcondition memory write</span>
<span class="lineno"> 1830 </span><span class="spaces">  </span><span class="istickedoff">postPtrs &lt;- Set.fromList &lt;$&gt; catMaybes &lt;$&gt; traverse</span>
<span class="lineno"> 1831 </span><span class="spaces">    </span><span class="istickedoff">(\case</span>
<span class="lineno"> 1832 </span><span class="spaces">      </span><span class="istickedoff">LLVMPointsTo _loc _cond ptr val -&gt; case val of</span>
<span class="lineno"> 1833 </span><span class="spaces">        </span><span class="istickedoff">ConcreteSizeValue val' -&gt; do</span>
<span class="lineno"> 1834 </span><span class="spaces">          </span><span class="istickedoff">(_, Crucible.LLVMPointer blk _) &lt;- resolveSetupValue <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> cs Crucible.PtrRepr ptr</span>
<span class="lineno"> 1835 </span><span class="spaces">          </span><span class="istickedoff">memTy &lt;- exceptToFail $</span>
<span class="lineno"> 1836 </span><span class="spaces">                     </span><span class="istickedoff">typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">(MS.csAllocations cs)</span> <span class="nottickedoff">(MS.csTypeNames cs)</span> val'</span>
<span class="lineno"> 1837 </span><span class="spaces">          </span><span class="istickedoff">sz &lt;- Crucible.storageTypeSize &lt;$&gt; Crucible.toStorableType memTy</span>
<span class="lineno"> 1838 </span><span class="spaces">          </span><span class="istickedoff">return $ Just (W4.asNat blk, sz)</span>
<span class="lineno"> 1839 </span><span class="spaces">        </span><span class="istickedoff">SymbolicSizeValue{} -&gt; return <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1840 </span><span class="spaces">      </span><span class="istickedoff">LLVMPointsToBitfield _loc ptr fieldName _val -&gt; do</span>
<span class="lineno"> 1841 </span><span class="spaces">        </span><span class="istickedoff">(bfIndex, Crucible.LLVMPointer blk _) &lt;-</span>
<span class="lineno"> 1842 </span><span class="spaces">          </span><span class="istickedoff">resolveSetupValueBitfield <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> cs ptr fieldName</span>
<span class="lineno"> 1843 </span><span class="spaces">        </span><span class="istickedoff">let memTy = biBitfieldType bfIndex</span>
<span class="lineno"> 1844 </span><span class="spaces">        </span><span class="istickedoff">storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno"> 1845 </span><span class="spaces">        </span><span class="istickedoff">let sz = Crucible.storageTypeSize storTy</span>
<span class="lineno"> 1846 </span><span class="spaces">        </span><span class="istickedoff">pure $ Just (W4.asNat blk, sz))</span>
<span class="lineno"> 1847 </span><span class="spaces">    </span><span class="istickedoff">(cs ^. MS.csPostState ^. MS.csPointsTos)</span>
<span class="lineno"> 1848 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1849 </span><span class="spaces">  </span><span class="istickedoff">-- partition allocations into those overwritten by a postcondition write</span>
<span class="lineno"> 1850 </span><span class="spaces">  </span><span class="istickedoff">-- and those not overwritten</span>
<span class="lineno"> 1851 </span><span class="spaces">  </span><span class="istickedoff">let (overwritten_ptrs, danglingPtrs) = partition</span>
<span class="lineno"> 1852 </span><span class="spaces">        </span><span class="istickedoff">(\((Crucible.LLVMPointer blk _), sz, _) -&gt;</span>
<span class="lineno"> 1853 </span><span class="spaces">          </span><span class="istickedoff">Set.member (W4.asNat blk, sz) postPtrs)</span>
<span class="lineno"> 1854 </span><span class="spaces">        </span><span class="istickedoff">(allocPtrs ++ globalPtrs)</span>
<span class="lineno"> 1855 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1856 </span><span class="spaces">  </span><span class="istickedoff">let overwritten_allocs = Map.fromList $ map</span>
<span class="lineno"> 1857 </span><span class="spaces">        </span><span class="istickedoff">(\((Crucible.LLVMPointer blk _), _, msg) -&gt; (blk, <span class="nottickedoff">msg</span>))</span>
<span class="lineno"> 1858 </span><span class="spaces">        </span><span class="istickedoff">overwritten_ptrs</span>
<span class="lineno"> 1859 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1860 </span><span class="spaces">  </span><span class="istickedoff">-- invalidate each allocation that is not overwritten by a postcondition write</span>
<span class="lineno"> 1861 </span><span class="spaces">  </span><span class="istickedoff">mem' &lt;- foldM (\m (ptr, sz, msg) -&gt;</span>
<span class="lineno"> 1862 </span><span class="spaces">                    </span><span class="istickedoff">liftIO $ Crucible.doInvalidate bak ?ptrWidth m ptr msg</span>
<span class="lineno"> 1863 </span><span class="spaces">                      </span><span class="istickedoff">=&lt;&lt; W4.bvLit sym ?ptrWidth (Crucible.bytesToBV ?ptrWidth sz)</span>
<span class="lineno"> 1864 </span><span class="spaces">                </span><span class="istickedoff">) mem danglingPtrs</span>
<span class="lineno"> 1865 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1866 </span><span class="spaces">  </span><span class="istickedoff">writeGlobal (Crucible.llvmMemVar $ ccLLVMContext cc) mem'</span>
<span class="lineno"> 1867 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1868 </span><span class="spaces">  </span><span class="istickedoff">return overwritten_allocs</span></span>
<span class="lineno"> 1869 </span>
<span class="lineno"> 1870 </span>------------------------------------------------------------------------
<span class="lineno"> 1871 </span>
<span class="lineno"> 1872 </span>-- | Perform an allocation as indicated by an @llvm_alloc@ or
<span class="lineno"> 1873 </span>-- @llvm_fresh_pointer@ statement from the postcondition section.
<span class="lineno"> 1874 </span>executeAllocation ::
<span class="lineno"> 1875 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1876 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1877 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1878 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1879 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1880 </span>  ) =&gt;
<span class="lineno"> 1881 </span>  Options                        -&gt;
<span class="lineno"> 1882 </span>  SharedContext -&gt;
<span class="lineno"> 1883 </span>  LLVMCrucibleContext arch          -&gt;
<span class="lineno"> 1884 </span>  (AllocIndex, LLVMAllocSpec) -&gt;
<span class="lineno"> 1885 </span>  OverrideMatcher (LLVM arch) RW ()
<span class="lineno"> 1886 </span><span class="decl"><span class="nottickedoff">executeAllocation opts sc cc (var, LLVMAllocSpec mut memTy alignment sz md fresh initialization)</span>
<span class="lineno"> 1887 </span><span class="spaces">  </span><span class="nottickedoff">| fresh =</span>
<span class="lineno"> 1888 </span><span class="spaces">  </span><span class="nottickedoff">do ptr &lt;- liftIO $ executeFreshPointer cc var</span>
<span class="lineno"> 1889 </span><span class="spaces">     </span><span class="nottickedoff">OM (setupValueSub %= Map.insert var ptr)</span>
<span class="lineno"> 1890 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise =</span>
<span class="lineno"> 1891 </span><span class="spaces">  </span><span class="nottickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 1892 </span><span class="spaces">     </span><span class="nottickedoff">{-</span>
<span class="lineno"> 1893 </span><span class="spaces">     </span><span class="nottickedoff">memTy &lt;- case Crucible.asMemType symTy of</span>
<span class="lineno"> 1894 </span><span class="spaces">                </span><span class="nottickedoff">Just memTy -&gt; return memTy</span>
<span class="lineno"> 1895 </span><span class="spaces">                </span><span class="nottickedoff">Nothing    -&gt; fail &quot;executAllocation: failed to resolve type&quot;</span>
<span class="lineno"> 1896 </span><span class="spaces">                </span><span class="nottickedoff">-}</span>
<span class="lineno"> 1897 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ printOutLn opts Debug $ unwords [&quot;executeAllocation:&quot;, show var, show memTy]</span>
<span class="lineno"> 1898 </span><span class="spaces">     </span><span class="nottickedoff">let memVar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno"> 1899 </span><span class="spaces">     </span><span class="nottickedoff">mem &lt;- readGlobal memVar</span>
<span class="lineno"> 1900 </span><span class="spaces">     </span><span class="nottickedoff">sz' &lt;- instantiateExtResolveSAWSymBV sc cc Crucible.PtrWidth sz</span>
<span class="lineno"> 1901 </span><span class="spaces">     </span><span class="nottickedoff">let loc = MS.conditionLoc md</span>
<span class="lineno"> 1902 </span><span class="spaces">     </span><span class="nottickedoff">let l = show (W4.plSourceLoc loc) ++ &quot; (Poststate)&quot;</span>
<span class="lineno"> 1903 </span><span class="spaces">     </span><span class="nottickedoff">(ptr, mem') &lt;- liftIO $ doAllocSymInit bak mem mut alignment sz' l initialization</span>
<span class="lineno"> 1904 </span><span class="spaces">     </span><span class="nottickedoff">writeGlobal memVar mem'</span>
<span class="lineno"> 1905 </span><span class="spaces">     </span><span class="nottickedoff">assignVar cc md var ptr</span></span>
<span class="lineno"> 1906 </span>
<span class="lineno"> 1907 </span>doAllocSymInit ::
<span class="lineno"> 1908 </span>  ( ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1909 </span>  , Crucible.IsSymInterface sym
<span class="lineno"> 1910 </span>  , Crucible.HasPtrWidth wptr
<span class="lineno"> 1911 </span>  , Crucible.HasLLVMAnn sym
<span class="lineno"> 1912 </span>  , IsSymBackend sym bak
<span class="lineno"> 1913 </span>  ) =&gt;
<span class="lineno"> 1914 </span>  bak -&gt;
<span class="lineno"> 1915 </span>  Crucible.MemImpl sym -&gt;
<span class="lineno"> 1916 </span>  Crucible.Mutability -&gt;
<span class="lineno"> 1917 </span>  Crucible.Alignment -&gt;
<span class="lineno"> 1918 </span>  W4.SymBV sym wptr {- ^ allocation size -} -&gt;
<span class="lineno"> 1919 </span>  String {- ^ source location for use in error messages -} -&gt;
<span class="lineno"> 1920 </span>  LLVMAllocSpecInit {- ^ allocation initialization policy -} -&gt;
<span class="lineno"> 1921 </span>  IO (Crucible.LLVMPtr sym wptr, Crucible.MemImpl sym)
<span class="lineno"> 1922 </span><span class="decl"><span class="istickedoff">doAllocSymInit bak mem mut alignment sz loc initialization  = do</span>
<span class="lineno"> 1923 </span><span class="spaces">  </span><span class="istickedoff">(ptr, mem') &lt;- Crucible.doMalloc bak Crucible.HeapAlloc mut loc mem sz alignment</span>
<span class="lineno"> 1924 </span><span class="spaces">  </span><span class="istickedoff">mem'' &lt;- case initialization of</span>
<span class="lineno"> 1925 </span><span class="spaces">    </span><span class="istickedoff">LLVMAllocSpecSymbolicInitialization -&gt; do</span>
<span class="lineno"> 1926 </span><span class="spaces">      </span><span class="istickedoff">arr &lt;- W4.freshConstant</span>
<span class="lineno"> 1927 </span><span class="spaces">        </span><span class="istickedoff">(backendGetSym bak)</span>
<span class="lineno"> 1928 </span><span class="spaces">        </span><span class="istickedoff">(W4.systemSymbol &quot;arr!&quot;)</span>
<span class="lineno"> 1929 </span><span class="spaces">        </span><span class="istickedoff">(W4.BaseArrayRepr (Ctx.singleton $ W4.BaseBVRepr ?ptrWidth) (W4.BaseBVRepr (W4.knownNat @8)))</span>
<span class="lineno"> 1930 </span><span class="spaces">      </span><span class="istickedoff">Crucible.doArrayConstStore bak mem' ptr alignment arr sz</span>
<span class="lineno"> 1931 </span><span class="spaces">    </span><span class="istickedoff">LLVMAllocSpecNoInitialization -&gt; return mem'</span>
<span class="lineno"> 1932 </span><span class="spaces">  </span><span class="istickedoff">return (ptr, mem'')</span></span>
<span class="lineno"> 1933 </span>
<span class="lineno"> 1934 </span>------------------------------------------------------------------------
<span class="lineno"> 1935 </span>
<span class="lineno"> 1936 </span>-- | Update the simulator state based on the postconditions from the
<span class="lineno"> 1937 </span>-- procedure specification.
<span class="lineno"> 1938 </span>executeSetupCondition ::
<span class="lineno"> 1939 </span>  (?lc :: Crucible.TypeContext, ?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 1940 </span>  Options                    -&gt;
<span class="lineno"> 1941 </span>  SharedContext              -&gt;
<span class="lineno"> 1942 </span>  LLVMCrucibleContext arch     -&gt;
<span class="lineno"> 1943 </span>  MS.CrucibleMethodSpecIR (LLVM arch)       -&gt;
<span class="lineno"> 1944 </span>  MS.SetupCondition (LLVM arch) -&gt;
<span class="lineno"> 1945 </span>  OverrideMatcher (LLVM arch) RW ()
<span class="lineno"> 1946 </span><span class="decl"><span class="istickedoff">executeSetupCondition opts sc cc spec =</span>
<span class="lineno"> 1947 </span><span class="spaces">  </span><span class="istickedoff">\case</span>
<span class="lineno"> 1948 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCond_Equal md val1 val2 -&gt;</span>
<span class="lineno"> 1949 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">executeEqual opts sc cc spec md val1 val2</span></span>
<span class="lineno"> 1950 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCond_Pred md tm -&gt; executePred sc cc <span class="nottickedoff">md</span> tm</span>
<span class="lineno"> 1951 </span><span class="spaces">    </span><span class="istickedoff">MS.SetupCond_Ghost md var val -&gt; executeGhost sc <span class="nottickedoff">md</span> var val</span></span>
<span class="lineno"> 1952 </span>
<span class="lineno"> 1953 </span>------------------------------------------------------------------------
<span class="lineno"> 1954 </span>
<span class="lineno"> 1955 </span>-- | Process a &quot;points_to&quot; statement from the postcondition section of
<span class="lineno"> 1956 </span>-- the CrucibleSetup block. First we compute the value indicated by
<span class="lineno"> 1957 </span>-- 'val', and then write it to the address indicated by 'ptr'.
<span class="lineno"> 1958 </span>executePointsTo ::
<span class="lineno"> 1959 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1960 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1961 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1962 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1963 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1964 </span>  ) =&gt;
<span class="lineno"> 1965 </span>  Options                    -&gt;
<span class="lineno"> 1966 </span>  SharedContext              -&gt;
<span class="lineno"> 1967 </span>  LLVMCrucibleContext arch     -&gt;
<span class="lineno"> 1968 </span>  MS.CrucibleMethodSpecIR (LLVM arch)       -&gt;
<span class="lineno"> 1969 </span>  Map (W4.SymNat Sym) Text -&gt;
<span class="lineno"> 1970 </span>  PointsTo (LLVM arch)       -&gt;
<span class="lineno"> 1971 </span>  OverrideMatcher (LLVM arch) RW ()
<span class="lineno"> 1972 </span><span class="decl"><span class="istickedoff">executePointsTo opts sc cc spec overwritten_allocs (LLVMPointsTo _loc cond ptr val) =</span>
<span class="lineno"> 1973 </span><span class="spaces">  </span><span class="istickedoff">do (_, ptr') &lt;- resolveSetupValue <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec Crucible.PtrRepr ptr</span>
<span class="lineno"> 1974 </span><span class="spaces">     </span><span class="istickedoff">let memVar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno"> 1975 </span><span class="spaces">     </span><span class="istickedoff">mem &lt;- readGlobal memVar</span>
<span class="lineno"> 1976 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1977 </span><span class="spaces">     </span><span class="istickedoff">-- In case the types are different (from llvm_points_to_untyped)</span>
<span class="lineno"> 1978 </span><span class="spaces">     </span><span class="istickedoff">-- then the load type should be determined by the rhs.</span>
<span class="lineno"> 1979 </span><span class="spaces">     </span><span class="istickedoff">m &lt;- OM (use <span class="nottickedoff">setupValueSub</span>)</span>
<span class="lineno"> 1980 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- OM (use termSub)</span>
<span class="lineno"> 1981 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">tyenv = MS.csAllocations spec</span></span>
<span class="lineno"> 1982 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno"> 1983 </span><span class="spaces">     </span><span class="istickedoff">val' &lt;- liftIO $ case val of</span>
<span class="lineno"> 1984 </span><span class="spaces">       </span><span class="istickedoff">ConcreteSizeValue val'' -&gt; ConcreteSizeValue &lt;$&gt; instantiateSetupValue sc s val''</span>
<span class="lineno"> 1985 </span><span class="spaces">       </span><span class="istickedoff">SymbolicSizeValue arr sz -&gt;</span>
<span class="lineno"> 1986 </span><span class="spaces">         </span><span class="istickedoff">SymbolicSizeValue &lt;$&gt; ttTermLens (scInstantiateExt sc s) arr &lt;*&gt; ttTermLens (scInstantiateExt <span class="nottickedoff">sc</span> s) sz</span>
<span class="lineno"> 1987 </span><span class="spaces">     </span><span class="istickedoff">cond' &lt;- mapM (instantiateExtResolveSAWPred sc cc . ttTerm) cond</span>
<span class="lineno"> 1988 </span><span class="spaces">     </span><span class="istickedoff">let Crucible.LLVMPointer blk _ = ptr'</span>
<span class="lineno"> 1989 </span><span class="spaces">     </span><span class="istickedoff">let invalidate_msg = Map.lookup blk overwritten_allocs</span>
<span class="lineno"> 1990 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1991 </span><span class="spaces">     </span><span class="istickedoff">mem' &lt;- liftIO $ storePointsToValue <span class="nottickedoff">opts</span> cc <span class="nottickedoff">m</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> mem cond' ptr' val' invalidate_msg</span>
<span class="lineno"> 1992 </span><span class="spaces">     </span><span class="istickedoff">writeGlobal memVar mem'</span>
<span class="lineno"> 1993 </span><span class="spaces"></span><span class="istickedoff">executePointsTo opts sc cc spec _overwritten_allocs (LLVMPointsToBitfield _loc ptr fieldName val) =</span>
<span class="lineno"> 1994 </span><span class="spaces">  </span><span class="istickedoff">do (bfIndex, ptr') &lt;- resolveSetupValueBitfield <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec ptr fieldName</span>
<span class="lineno"> 1995 </span><span class="spaces">     </span><span class="istickedoff">let memVar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno"> 1996 </span><span class="spaces">     </span><span class="istickedoff">mem &lt;- readGlobal memVar</span>
<span class="lineno"> 1997 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1998 </span><span class="spaces">     </span><span class="istickedoff">m &lt;- OM (use <span class="nottickedoff">setupValueSub</span>)</span>
<span class="lineno"> 1999 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- OM (use termSub)</span>
<span class="lineno"> 2000 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">tyenv = MS.csAllocations spec</span></span>
<span class="lineno"> 2001 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nameEnv = MS.csTypeNames spec</span></span>
<span class="lineno"> 2002 </span><span class="spaces">     </span><span class="istickedoff">val' &lt;- liftIO $ instantiateSetupValue sc s val</span>
<span class="lineno"> 2003 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2004 </span><span class="spaces">     </span><span class="istickedoff">mem' &lt;- liftIO $ storePointsToBitfieldValue <span class="nottickedoff">opts</span> cc <span class="nottickedoff">m</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> mem ptr' bfIndex val'</span>
<span class="lineno"> 2005 </span><span class="spaces">     </span><span class="istickedoff">writeGlobal memVar mem'</span></span>
<span class="lineno"> 2006 </span>
<span class="lineno"> 2007 </span>storePointsToValue ::
<span class="lineno"> 2008 </span>  ( ?memOpts :: Crucible.MemOptions
<span class="lineno"> 2009 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 2010 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 2011 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 2012 </span>  ) =&gt;
<span class="lineno"> 2013 </span>  Options -&gt;
<span class="lineno"> 2014 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2015 </span>  Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno"> 2016 </span>  Map AllocIndex (MS.AllocSpec (LLVM arch)) -&gt;
<span class="lineno"> 2017 </span>  Map AllocIndex (MS.TypeName (LLVM arch)) -&gt;
<span class="lineno"> 2018 </span>  Crucible.MemImpl Sym -&gt;
<span class="lineno"> 2019 </span>  Maybe (W4.Pred Sym) -&gt;
<span class="lineno"> 2020 </span>  LLVMPtr (Crucible.ArchWidth arch) -&gt;
<span class="lineno"> 2021 </span>  LLVMPointsToValue arch -&gt;
<span class="lineno"> 2022 </span>  Maybe Text -&gt;
<span class="lineno"> 2023 </span>  IO (Crucible.MemImpl Sym)
<span class="lineno"> 2024 </span><span class="decl"><span class="istickedoff">storePointsToValue opts cc env tyenv nameEnv base_mem maybe_cond ptr val maybe_invalidate_msg =</span>
<span class="lineno"> 2025 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 2026 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno"> 2027 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2028 </span><span class="spaces">  </span><span class="istickedoff">let alignment = Crucible.noAlignment -- default to byte alignment (FIXME, see #338)</span>
<span class="lineno"> 2029 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2030 </span><span class="spaces">  </span><span class="istickedoff">smt_array_memory_model_enabled &lt;- W4.getOpt</span>
<span class="lineno"> 2031 </span><span class="spaces">    </span><span class="istickedoff">=&lt;&lt; W4.getOptionSetting enableSMTArrayMemoryModel (W4.getConfiguration sym)</span>
<span class="lineno"> 2032 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2033 </span><span class="spaces">  </span><span class="istickedoff">let store_op = \mem -&gt; case val of</span>
<span class="lineno"> 2034 </span><span class="spaces">        </span><span class="istickedoff">ConcreteSizeValue val' -&gt; do</span>
<span class="lineno"> 2035 </span><span class="spaces">          </span><span class="istickedoff">memTy &lt;- exceptToFail $ typeOfSetupValue cc tyenv <span class="nottickedoff">nameEnv</span> val'</span>
<span class="lineno"> 2036 </span><span class="spaces">          </span><span class="istickedoff">storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno"> 2037 </span><span class="spaces">          </span><span class="istickedoff">case val' of</span>
<span class="lineno"> 2038 </span><span class="spaces">            </span><span class="istickedoff">SetupTerm tm</span>
<span class="lineno"> 2039 </span><span class="spaces">              </span><span class="istickedoff">| Crucible.storageTypeSize storTy &gt; 16</span>
<span class="lineno"> 2040 </span><span class="spaces">              </span><span class="istickedoff">, <span class="tickonlyfalse">smt_array_memory_model_enabled</span> -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 2041 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">arr_tm &lt;- memArrayToSawCoreTerm cc (Crucible.memEndian mem) tm</span></span>
<span class="lineno"> 2042 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">st &lt;- sawCoreState sym</span></span>
<span class="lineno"> 2043 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">arr &lt;- bindSAWTerm</span></span>
<span class="lineno"> 2044 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">sym st</span></span>
<span class="lineno"> 2045 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">(W4.BaseArrayRepr</span></span>
<span class="lineno"> 2046 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">(Ctx.singleton $ W4.BaseBVRepr ?ptrWidth)</span></span>
<span class="lineno"> 2047 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">(W4.BaseBVRepr (W4.knownNat @8)))</span></span>
<span class="lineno"> 2048 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">arr_tm</span></span>
<span class="lineno"> 2049 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">sz &lt;- W4.bvLit</span></span>
<span class="lineno"> 2050 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">sym</span></span>
<span class="lineno"> 2051 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">?ptrWidth</span></span>
<span class="lineno"> 2052 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">(Crucible.bytesToBV ?ptrWidth $ Crucible.storageTypeSize storTy)</span></span>
<span class="lineno"> 2053 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">Crucible.doArrayConstStore bak mem ptr alignment arr sz</span></span>
<span class="lineno"> 2054 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 2055 </span><span class="spaces">              </span><span class="istickedoff">val'' &lt;- X.handle <span class="nottickedoff">(handleException opts)</span> $</span>
<span class="lineno"> 2056 </span><span class="spaces">                </span><span class="istickedoff">resolveSetupVal cc <span class="nottickedoff">mem</span> env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val'</span>
<span class="lineno"> 2057 </span><span class="spaces">              </span><span class="istickedoff">Crucible.storeConstRaw bak mem ptr storTy alignment val''</span>
<span class="lineno"> 2058 </span><span class="spaces">        </span><span class="istickedoff">SymbolicSizeValue arr_tm sz_tm -&gt; do</span>
<span class="lineno"> 2059 </span><span class="spaces">          </span><span class="istickedoff">st &lt;- sawCoreState sym</span>
<span class="lineno"> 2060 </span><span class="spaces">          </span><span class="istickedoff">arr &lt;- bindSAWTerm</span>
<span class="lineno"> 2061 </span><span class="spaces">            </span><span class="istickedoff">sym st</span>
<span class="lineno"> 2062 </span><span class="spaces">            </span><span class="istickedoff">(W4.BaseArrayRepr</span>
<span class="lineno"> 2063 </span><span class="spaces">              </span><span class="istickedoff">(Ctx.singleton $ W4.BaseBVRepr ?ptrWidth)</span>
<span class="lineno"> 2064 </span><span class="spaces">              </span><span class="istickedoff">(W4.BaseBVRepr (W4.knownNat @8)))</span>
<span class="lineno"> 2065 </span><span class="spaces">            </span><span class="istickedoff">(ttTerm arr_tm)</span>
<span class="lineno"> 2066 </span><span class="spaces">          </span><span class="istickedoff">sz &lt;- resolveSAWSymBV cc ?ptrWidth $ ttTerm sz_tm</span>
<span class="lineno"> 2067 </span><span class="spaces">          </span><span class="istickedoff">Crucible.doArrayConstStore bak mem ptr alignment arr sz</span>
<span class="lineno"> 2068 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2069 </span><span class="spaces">  </span><span class="istickedoff">case maybe_cond of</span>
<span class="lineno"> 2070 </span><span class="spaces">    </span><span class="istickedoff">Just cond -&gt; case maybe_invalidate_msg of</span>
<span class="lineno"> 2071 </span><span class="spaces">      </span><span class="istickedoff">Just invalidate_msg -&gt; do</span>
<span class="lineno"> 2072 </span><span class="spaces">        </span><span class="istickedoff">let invalidate_op = \mem -&gt; do</span>
<span class="lineno"> 2073 </span><span class="spaces">              </span><span class="istickedoff">sz &lt;- case val of</span>
<span class="lineno"> 2074 </span><span class="spaces">                </span><span class="istickedoff">ConcreteSizeValue val' -&gt; do</span>
<span class="lineno"> 2075 </span><span class="spaces">                  </span><span class="istickedoff">memTy &lt;- exceptToFail $ typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val'</span>
<span class="lineno"> 2076 </span><span class="spaces">                  </span><span class="istickedoff">storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno"> 2077 </span><span class="spaces">                  </span><span class="istickedoff">W4.bvLit</span>
<span class="lineno"> 2078 </span><span class="spaces">                    </span><span class="istickedoff">sym</span>
<span class="lineno"> 2079 </span><span class="spaces">                    </span><span class="istickedoff">?ptrWidth</span>
<span class="lineno"> 2080 </span><span class="spaces">                    </span><span class="istickedoff">(Crucible.bytesToBV ?ptrWidth $ Crucible.storageTypeSize storTy)</span>
<span class="lineno"> 2081 </span><span class="spaces">                </span><span class="istickedoff">SymbolicSizeValue{} -&gt; <span class="nottickedoff">fail $ unwords</span></span>
<span class="lineno"> 2082 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[ &quot;internal error:&quot;</span></span>
<span class="lineno"> 2083 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, &quot;unsupported conditional invalidation of symbolic size points-to value&quot;</span></span>
<span class="lineno"> 2084 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, show (PP.pretty val)</span></span>
<span class="lineno"> 2085 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2086 </span><span class="spaces">              </span><span class="istickedoff">Crucible.doInvalidate bak ?ptrWidth mem ptr <span class="nottickedoff">invalidate_msg</span> sz</span>
<span class="lineno"> 2087 </span><span class="spaces">        </span><span class="istickedoff">Crucible.mergeWriteOperations bak base_mem cond store_op invalidate_op</span>
<span class="lineno"> 2088 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2089 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Crucible.doConditionalWriteOperation bak base_mem cond store_op</span></span>
<span class="lineno"> 2090 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; store_op base_mem</span></span>
<span class="lineno"> 2091 </span>
<span class="lineno"> 2092 </span>-- | Like 'storePointsToValue', but specifically geared towards the needs
<span class="lineno"> 2093 </span>-- of fields within bitfields. In particular, this performs all of the
<span class="lineno"> 2094 </span>-- necessary bit-twiddling on the LHS (a bitfield) to store the RHS value in
<span class="lineno"> 2095 </span>-- the right place in the bitfield.
<span class="lineno"> 2096 </span>storePointsToBitfieldValue ::
<span class="lineno"> 2097 </span>  ( ?memOpts :: Crucible.MemOptions
<span class="lineno"> 2098 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 2099 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 2100 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 2101 </span>  ) =&gt;
<span class="lineno"> 2102 </span>  Options -&gt;
<span class="lineno"> 2103 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2104 </span>  Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno"> 2105 </span>  Map AllocIndex (MS.AllocSpec (LLVM arch)) -&gt;
<span class="lineno"> 2106 </span>  Map AllocIndex (MS.TypeName (LLVM arch)) -&gt;
<span class="lineno"> 2107 </span>  Crucible.MemImpl Sym -&gt;
<span class="lineno"> 2108 </span>  LLVMPtr (Crucible.ArchWidth arch) -&gt;
<span class="lineno"> 2109 </span>  BitfieldIndex -&gt;
<span class="lineno"> 2110 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno"> 2111 </span>  IO (Crucible.MemImpl Sym)
<span class="lineno"> 2112 </span><span class="decl"><span class="istickedoff">storePointsToBitfieldValue opts cc env tyenv nameEnv base_mem ptr bfIndex val =</span>
<span class="lineno"> 2113 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 2114 </span><span class="spaces">  </span><span class="istickedoff">let sym = backendGetSym bak</span>
<span class="lineno"> 2115 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2116 </span><span class="spaces">  </span><span class="istickedoff">let alignment = Crucible.noAlignment -- default to byte alignment (FIXME, see #338)</span>
<span class="lineno"> 2117 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2118 </span><span class="spaces">  </span><span class="istickedoff">smt_array_memory_model_enabled &lt;- W4.getOpt</span>
<span class="lineno"> 2119 </span><span class="spaces">    </span><span class="istickedoff">=&lt;&lt; W4.getOptionSetting enableSMTArrayMemoryModel (W4.getConfiguration sym)</span>
<span class="lineno"> 2120 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2121 </span><span class="spaces">  </span><span class="istickedoff">-- Unlike in storePointsToValue, we compute the MemTy/StorageType not from</span>
<span class="lineno"> 2122 </span><span class="spaces">  </span><span class="istickedoff">-- the RHS value, but from the BitfieldIndex. This is because we need to</span>
<span class="lineno"> 2123 </span><span class="spaces">  </span><span class="istickedoff">-- load the entire bitfield, which can be larger than the size of the RHS</span>
<span class="lineno"> 2124 </span><span class="spaces">  </span><span class="istickedoff">-- value.</span>
<span class="lineno"> 2125 </span><span class="spaces">  </span><span class="istickedoff">let memTy = biBitfieldType bfIndex</span>
<span class="lineno"> 2126 </span><span class="spaces">  </span><span class="istickedoff">storTy &lt;- Crucible.toStorableType memTy</span>
<span class="lineno"> 2127 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2128 </span><span class="spaces">  </span><span class="istickedoff">case val of</span>
<span class="lineno"> 2129 </span><span class="spaces">    </span><span class="istickedoff">SetupTerm _tm</span>
<span class="lineno"> 2130 </span><span class="spaces">      </span><span class="istickedoff">| smt_array_memory_model_enabled -&gt;</span>
<span class="lineno"> 2131 </span><span class="spaces">        </span><span class="istickedoff">-- See #1540.</span>
<span class="lineno"> 2132 </span><span class="spaces">        </span><span class="istickedoff">fail $ unlines</span>
<span class="lineno"> 2133 </span><span class="spaces">          </span><span class="istickedoff">[ &quot;llvm_points_to_bitfield currently does not work in&quot;</span>
<span class="lineno"> 2134 </span><span class="spaces">          </span><span class="istickedoff">, &quot;combination with the enable_smt_array_memory_model option.&quot;</span>
<span class="lineno"> 2135 </span><span class="spaces">          </span><span class="istickedoff">]</span>
<span class="lineno"> 2136 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 2137 </span><span class="spaces">      </span><span class="istickedoff">-- Resolve the RHS value as an LLVMVal.</span>
<span class="lineno"> 2138 </span><span class="spaces">      </span><span class="istickedoff">rhsVal &lt;- X.handle <span class="nottickedoff">(handleException opts)</span> $</span>
<span class="lineno"> 2139 </span><span class="spaces">        </span><span class="istickedoff">resolveSetupVal cc <span class="nottickedoff">base_mem</span> <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 2140 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2141 </span><span class="spaces">      </span><span class="istickedoff">-- Load the bitfield that `ptr` points to.</span>
<span class="lineno"> 2142 </span><span class="spaces">      </span><span class="istickedoff">bfLoadedVal &lt;- Crucible.loadRaw sym base_mem ptr storTy alignment</span>
<span class="lineno"> 2143 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2144 </span><span class="spaces">      </span><span class="istickedoff">-- Assert that the bitfield was loaded successfully. If not, abort.</span>
<span class="lineno"> 2145 </span><span class="spaces">      </span><span class="istickedoff">let badLoadSummary = summarizeBadLoad <span class="nottickedoff">cc</span> <span class="nottickedoff">memTy</span> <span class="nottickedoff">PreState</span> <span class="nottickedoff">ptr</span></span>
<span class="lineno"> 2146 </span><span class="spaces">      </span><span class="istickedoff">bfVal &lt;- case bfLoadedVal of</span>
<span class="lineno"> 2147 </span><span class="spaces">        </span><span class="istickedoff">Crucible.NoErr p res_val -&gt; do</span>
<span class="lineno"> 2148 </span><span class="spaces">          </span><span class="istickedoff">let rsn = Crucible.AssertFailureSimError &quot;Error loading bitvector&quot; $</span>
<span class="lineno"> 2149 </span><span class="spaces">                    </span><span class="istickedoff">show badLoadSummary</span>
<span class="lineno"> 2150 </span><span class="spaces">          </span><span class="istickedoff">Crucible.assert bak p rsn</span>
<span class="lineno"> 2151 </span><span class="spaces">          </span><span class="istickedoff">pure res_val</span>
<span class="lineno"> 2152 </span><span class="spaces">        </span><span class="istickedoff">Crucible.Err _p -&gt;</span>
<span class="lineno"> 2153 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail $ show $ describeConcreteMemoryLoadFailure base_mem badLoadSummary ptr</span></span>
<span class="lineno"> 2154 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2155 </span><span class="spaces">      </span><span class="istickedoff">case (bfVal, rhsVal) of</span>
<span class="lineno"> 2156 </span><span class="spaces">        </span><span class="istickedoff">-- This will only work if:</span>
<span class="lineno"> 2157 </span><span class="spaces">        </span><span class="istickedoff">--</span>
<span class="lineno"> 2158 </span><span class="spaces">        </span><span class="istickedoff">-- * Both the bitfield and the RHS value are bitvectors, and</span>
<span class="lineno"> 2159 </span><span class="spaces">        </span><span class="istickedoff">-- * The width of the RHS type is less than or equal to the width</span>
<span class="lineno"> 2160 </span><span class="spaces">        </span><span class="istickedoff">--   of the bitfield type.</span>
<span class="lineno"> 2161 </span><span class="spaces">        </span><span class="istickedoff">--</span>
<span class="lineno"> 2162 </span><span class="spaces">        </span><span class="istickedoff">-- We check these criteria in this case.</span>
<span class="lineno"> 2163 </span><span class="spaces">        </span><span class="istickedoff">(Crucible.LLVMValInt bfBlk bfBV, Crucible.LLVMValInt _rhsBlk rhsBV)</span>
<span class="lineno"> 2164 </span><span class="spaces">          </span><span class="istickedoff">-&gt; let bfWidth = W4.bvWidth bfBV</span>
<span class="lineno"> 2165 </span><span class="spaces">                 </span><span class="istickedoff">rhsWidth = W4.bvWidth rhsBV in</span>
<span class="lineno"> 2166 </span><span class="spaces">             </span><span class="istickedoff">case testLeq (incNat rhsWidth) bfWidth of</span>
<span class="lineno"> 2167 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2168 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 2169 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_points_to_bitfield: RHS value's size must be less then or equal to bitfield's size&quot;</span></span>
<span class="lineno"> 2170 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bitvector width: &quot; ++ show bfWidth</span></span>
<span class="lineno"> 2171 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, &quot;RHS value width: &quot; ++ show rhsWidth</span></span>
<span class="lineno"> 2172 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2173 </span><span class="spaces">               </span><span class="istickedoff">Just LeqProof -&gt;</span>
<span class="lineno"> 2174 </span><span class="spaces">                 </span><span class="istickedoff">do -- Here is where we perform the bit-twiddling needed</span>
<span class="lineno"> 2175 </span><span class="spaces">                    </span><span class="istickedoff">-- to store the RHS value in the bitfield. We will use</span>
<span class="lineno"> 2176 </span><span class="spaces">                    </span><span class="istickedoff">-- this as a running example:</span>
<span class="lineno"> 2177 </span><span class="spaces">                    </span><span class="istickedoff">--</span>
<span class="lineno"> 2178 </span><span class="spaces">                    </span><span class="istickedoff">--   struct s {</span>
<span class="lineno"> 2179 </span><span class="spaces">                    </span><span class="istickedoff">--     int32_t w;</span>
<span class="lineno"> 2180 </span><span class="spaces">                    </span><span class="istickedoff">--     uint8_t x1:1;</span>
<span class="lineno"> 2181 </span><span class="spaces">                    </span><span class="istickedoff">--     uint8_t x2:2;</span>
<span class="lineno"> 2182 </span><span class="spaces">                    </span><span class="istickedoff">--     uint8_t y:1;</span>
<span class="lineno"> 2183 </span><span class="spaces">                    </span><span class="istickedoff">--     int32_t z;</span>
<span class="lineno"> 2184 </span><span class="spaces">                    </span><span class="istickedoff">--   };</span>
<span class="lineno"> 2185 </span><span class="spaces">                    </span><span class="istickedoff">--</span>
<span class="lineno"> 2186 </span><span class="spaces">                    </span><span class="istickedoff">-- Let us imagine that we are setting the `y` field to</span>
<span class="lineno"> 2187 </span><span class="spaces">                    </span><span class="istickedoff">-- be 1.</span>
<span class="lineno"> 2188 </span><span class="spaces">                    </span><span class="istickedoff">let -- The offset (in bits) of the field within the</span>
<span class="lineno"> 2189 </span><span class="spaces">                        </span><span class="istickedoff">-- bitfield. For `y`, this is 3 (x1's offset is 0</span>
<span class="lineno"> 2190 </span><span class="spaces">                        </span><span class="istickedoff">-- and `x2`'s offset is 1).</span>
<span class="lineno"> 2191 </span><span class="spaces">                        </span><span class="istickedoff">bfOffset   = biFieldOffset bfIndex</span>
<span class="lineno"> 2192 </span><span class="spaces">                        </span><span class="istickedoff">bfOffsetBV = BV.mkBV bfWidth $ fromIntegral bfOffset</span>
<span class="lineno"> 2193 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2194 </span><span class="spaces">                        </span><span class="istickedoff">-- A bitmask with the nth bit (zero-indexed) is</span>
<span class="lineno"> 2195 </span><span class="spaces">                        </span><span class="istickedoff">-- set, where n equals the size of the field</span>
<span class="lineno"> 2196 </span><span class="spaces">                        </span><span class="istickedoff">-- (in bits) within the bitfield. Since `y` is</span>
<span class="lineno"> 2197 </span><span class="spaces">                        </span><span class="istickedoff">-- 1-bit, this would make `fieldBitsBV` be</span>
<span class="lineno"> 2198 </span><span class="spaces">                        </span><span class="istickedoff">-- 0b00000010, or 2.</span>
<span class="lineno"> 2199 </span><span class="spaces">                        </span><span class="istickedoff">fieldBitsBV = BV.bit' bfWidth $</span>
<span class="lineno"> 2200 </span><span class="spaces">                                      </span><span class="istickedoff">fromIntegral $ biFieldSize bfIndex</span>
<span class="lineno"> 2201 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2202 </span><span class="spaces">                        </span><span class="istickedoff">-- A bitmask with the (n-1) least significant bits</span>
<span class="lineno"> 2203 </span><span class="spaces">                        </span><span class="istickedoff">-- set to 1, where n equals the value of</span>
<span class="lineno"> 2204 </span><span class="spaces">                        </span><span class="istickedoff">-- `fieldBitsBV`. For `y`, `leastBitsBV` would be</span>
<span class="lineno"> 2205 </span><span class="spaces">                        </span><span class="istickedoff">-- equal to 0b00000001, or 1.</span>
<span class="lineno"> 2206 </span><span class="spaces">                        </span><span class="istickedoff">leastBitsBV = BV.sub bfWidth fieldBitsBV (BV.one bfWidth)</span>
<span class="lineno"> 2207 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2208 </span><span class="spaces">                        </span><span class="istickedoff">-- A bitmask with the bits corresponding to the</span>
<span class="lineno"> 2209 </span><span class="spaces">                        </span><span class="istickedoff">-- field within the bitfield set to 1, and all</span>
<span class="lineno"> 2210 </span><span class="spaces">                        </span><span class="istickedoff">-- other bits are set to 0. For `y`, `bitmaskBV`</span>
<span class="lineno"> 2211 </span><span class="spaces">                        </span><span class="istickedoff">-- would be equal to 0b00001000, or 8.</span>
<span class="lineno"> 2212 </span><span class="spaces">                        </span><span class="istickedoff">bitmaskBV = BV.shl bfWidth leastBitsBV $ fromIntegral bfOffset</span>
<span class="lineno"> 2213 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2214 </span><span class="spaces">                        </span><span class="istickedoff">-- A bitmask with the bits corresponding to the</span>
<span class="lineno"> 2215 </span><span class="spaces">                        </span><span class="istickedoff">-- field within the bitfield set to 0, and all</span>
<span class="lineno"> 2216 </span><span class="spaces">                        </span><span class="istickedoff">-- other bits are set to 1. For `y`, `compBitmaskBV`</span>
<span class="lineno"> 2217 </span><span class="spaces">                        </span><span class="istickedoff">-- would be equal to 0b11110111, or 247.</span>
<span class="lineno"> 2218 </span><span class="spaces">                        </span><span class="istickedoff">compBitmaskBV = BV.complement bfWidth bitmaskBV</span>
<span class="lineno"> 2219 </span><span class="spaces">                    </span><span class="istickedoff">compBitmaskSymBV &lt;- W4.bvLit sym bfWidth compBitmaskBV</span>
<span class="lineno"> 2220 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2221 </span><span class="spaces">                    </span><span class="istickedoff">-- Clear all of the bits in the bitfield</span>
<span class="lineno"> 2222 </span><span class="spaces">                    </span><span class="istickedoff">-- corresponding to the field, leaving all other bits</span>
<span class="lineno"> 2223 </span><span class="spaces">                    </span><span class="istickedoff">-- unchanged. If the original bitvector was 0b????????,</span>
<span class="lineno"> 2224 </span><span class="spaces">                    </span><span class="istickedoff">-- then `bfBV'` is 0b????0???.</span>
<span class="lineno"> 2225 </span><span class="spaces">                    </span><span class="istickedoff">bfBV' &lt;- W4.bvAndBits sym bfBV compBitmaskSymBV</span>
<span class="lineno"> 2226 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2227 </span><span class="spaces">                    </span><span class="istickedoff">-- Zero-extend the RHS value to be the same width as</span>
<span class="lineno"> 2228 </span><span class="spaces">                    </span><span class="istickedoff">-- the bitfield. In our running example, we</span>
<span class="lineno"> 2229 </span><span class="spaces">                    </span><span class="istickedoff">-- zero-extend 0b1 (1) to 0b00000001.</span>
<span class="lineno"> 2230 </span><span class="spaces">                    </span><span class="istickedoff">rhsBV' &lt;- W4.bvZext sym bfWidth rhsBV</span>
<span class="lineno"> 2231 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2232 </span><span class="spaces">                    </span><span class="istickedoff">-- Left-shift the zero-extended RHS value such that</span>
<span class="lineno"> 2233 </span><span class="spaces">                    </span><span class="istickedoff">-- its contents are in the same position as the field</span>
<span class="lineno"> 2234 </span><span class="spaces">                    </span><span class="istickedoff">-- in the bitfield. In our running example, `rhsBV''`</span>
<span class="lineno"> 2235 </span><span class="spaces">                    </span><span class="istickedoff">-- is 0b00001000, or 8.</span>
<span class="lineno"> 2236 </span><span class="spaces">                    </span><span class="istickedoff">rhsBV'' &lt;- W4.bvShl sym rhsBV' =&lt;&lt; W4.bvLit sym bfWidth bfOffsetBV</span>
<span class="lineno"> 2237 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2238 </span><span class="spaces">                    </span><span class="istickedoff">-- Finally, set the bits in the bitfield to the RHS</span>
<span class="lineno"> 2239 </span><span class="spaces">                    </span><span class="istickedoff">-- value with a bitwise-XOR operation. (We could just as</span>
<span class="lineno"> 2240 </span><span class="spaces">                    </span><span class="istickedoff">-- well use bitwise-OR, but bitwise-XOR plays nicer with</span>
<span class="lineno"> 2241 </span><span class="spaces">                    </span><span class="istickedoff">-- how What4 represents bitvectors). In our running</span>
<span class="lineno"> 2242 </span><span class="spaces">                    </span><span class="istickedoff">-- example, `bfBV''` is 0b????1???.</span>
<span class="lineno"> 2243 </span><span class="spaces">                    </span><span class="istickedoff">bfBV'' &lt;- W4.bvXorBits sym bfBV' rhsBV''</span>
<span class="lineno"> 2244 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2245 </span><span class="spaces">                    </span><span class="istickedoff">-- Store the bitfield's value back to memory.</span>
<span class="lineno"> 2246 </span><span class="spaces">                    </span><span class="istickedoff">--</span>
<span class="lineno"> 2247 </span><span class="spaces">                    </span><span class="istickedoff">-- Bear in mind that this whole process is repeated once per</span>
<span class="lineno"> 2248 </span><span class="spaces">                    </span><span class="istickedoff">-- field, even if the fields all reside within the same</span>
<span class="lineno"> 2249 </span><span class="spaces">                    </span><span class="istickedoff">-- bitfield. See #1541 for an alternative approach that</span>
<span class="lineno"> 2250 </span><span class="spaces">                    </span><span class="istickedoff">-- would optimize this further.</span>
<span class="lineno"> 2251 </span><span class="spaces">                    </span><span class="istickedoff">let bfVal' = Crucible.LLVMValInt bfBlk bfBV''</span>
<span class="lineno"> 2252 </span><span class="spaces">                    </span><span class="istickedoff">Crucible.storeConstRaw bak base_mem ptr storTy alignment bfVal'</span>
<span class="lineno"> 2253 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 2254 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_points_to_bitfield: Both the bitfield and RHS value must be bitvectors&quot;</span></span>
<span class="lineno"> 2255 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bitfield value: &quot; ++ show (Crucible.ppTermExpr bfVal)</span></span>
<span class="lineno"> 2256 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, &quot;RHS value: &quot; ++ show (MS.ppSetupValue val)</span></span>
<span class="lineno"> 2257 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 2258 </span>
<span class="lineno"> 2259 </span>
<span class="lineno"> 2260 </span>------------------------------------------------------------------------
<span class="lineno"> 2261 </span>
<span class="lineno"> 2262 </span>
<span class="lineno"> 2263 </span>-- | Process an @llvm_equal@ statement from the postcondition
<span class="lineno"> 2264 </span>-- section of the CrucibleSetup block.
<span class="lineno"> 2265 </span>executeEqual ::
<span class="lineno"> 2266 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 2267 </span>  Options                                          -&gt;
<span class="lineno"> 2268 </span>  SharedContext                                    -&gt;
<span class="lineno"> 2269 </span>  LLVMCrucibleContext arch                           -&gt;
<span class="lineno"> 2270 </span>  MS.CrucibleMethodSpecIR (LLVM arch)                             -&gt;
<span class="lineno"> 2271 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 2272 </span>  SetupValue (LLVM arch)       {- ^ first value to compare  -} -&gt;
<span class="lineno"> 2273 </span>  SetupValue (LLVM arch)       {- ^ second value to compare -} -&gt;
<span class="lineno"> 2274 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 2275 </span><span class="decl"><span class="nottickedoff">executeEqual opts sc cc spec md v1 v2 = do</span>
<span class="lineno"> 2276 </span><span class="spaces">  </span><span class="nottickedoff">(_, val1) &lt;- resolveSetupValueLLVM opts cc sc spec v1</span>
<span class="lineno"> 2277 </span><span class="spaces">  </span><span class="nottickedoff">(_, val2) &lt;- resolveSetupValueLLVM opts cc sc spec v2</span>
<span class="lineno"> 2278 </span><span class="spaces">  </span><span class="nottickedoff">p         &lt;- liftIO (equalValsPred cc val1 val2)</span>
<span class="lineno"> 2279 </span><span class="spaces">  </span><span class="nottickedoff">addAssume p md</span></span>
<span class="lineno"> 2280 </span>
<span class="lineno"> 2281 </span>-- | Process an @llvm_postcond@ statement from the postcondition
<span class="lineno"> 2282 </span>-- section of the CrucibleSetup block.
<span class="lineno"> 2283 </span>executePred ::
<span class="lineno"> 2284 </span>  (?w4EvalTactic :: W4EvalTactic) =&gt;
<span class="lineno"> 2285 </span>  SharedContext -&gt;
<span class="lineno"> 2286 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2287 </span>  MS.ConditionMetadata -&gt;
<span class="lineno"> 2288 </span>  TypedTerm {- ^ the term to assert as a postcondition -} -&gt;
<span class="lineno"> 2289 </span>  OverrideMatcher (LLVM arch) md ()
<span class="lineno"> 2290 </span><span class="decl"><span class="istickedoff">executePred sc cc md tt =</span>
<span class="lineno"> 2291 </span><span class="spaces">  </span><span class="istickedoff">do p &lt;- instantiateExtResolveSAWPred sc cc (ttTerm tt)</span>
<span class="lineno"> 2292 </span><span class="spaces">     </span><span class="istickedoff">addAssume p <span class="nottickedoff">md</span></span></span>
<span class="lineno"> 2293 </span>
<span class="lineno"> 2294 </span>------------------------------------------------------------------------
<span class="lineno"> 2295 </span>
<span class="lineno"> 2296 </span>-- | Construct a completely symbolic pointer. This pointer could point to anything, or it could
<span class="lineno"> 2297 </span>-- be NULL.
<span class="lineno"> 2298 </span>executeFreshPointer ::
<span class="lineno"> 2299 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno"> 2300 </span>  LLVMCrucibleContext arch {-  Cruible context       -} -&gt;
<span class="lineno"> 2301 </span>  AllocIndex      {- ^ SetupVar allocation ID -} -&gt;
<span class="lineno"> 2302 </span>  IO (LLVMPtr (Crucible.ArchWidth arch)) {- ^ Symbolic pointer value -}
<span class="lineno"> 2303 </span><span class="decl"><span class="istickedoff">executeFreshPointer cc (AllocIndex i) =</span>
<span class="lineno"> 2304 </span><span class="spaces">  </span><span class="istickedoff">do let mkName base = W4.systemSymbol (base ++ show i ++ &quot;!&quot;)</span>
<span class="lineno"> 2305 </span><span class="spaces">         </span><span class="istickedoff">sym         = cc^.ccSym</span>
<span class="lineno"> 2306 </span><span class="spaces">     </span><span class="istickedoff">blk &lt;- W4.freshNat sym (mkName &quot;blk&quot;)</span>
<span class="lineno"> 2307 </span><span class="spaces">     </span><span class="istickedoff">off &lt;- W4.freshConstant sym (mkName &quot;off&quot;) (W4.BaseBVRepr Crucible.PtrWidth)</span>
<span class="lineno"> 2308 </span><span class="spaces">     </span><span class="istickedoff">return (Crucible.LLVMPointer blk off)</span></span>
<span class="lineno"> 2309 </span>
<span class="lineno"> 2310 </span>------------------------------------------------------------------------
<span class="lineno"> 2311 </span>
<span class="lineno"> 2312 </span>-- | Map the given substitution over all 'SetupTerm' constructors in
<span class="lineno"> 2313 </span>-- the given 'SetupValue'.
<span class="lineno"> 2314 </span>instantiateSetupValue ::
<span class="lineno"> 2315 </span>  SharedContext     -&gt;
<span class="lineno"> 2316 </span>  Map VarIndex Term -&gt;
<span class="lineno"> 2317 </span>  SetupValue (LLVM arch)        -&gt;
<span class="lineno"> 2318 </span>  IO (SetupValue (LLVM arch))
<span class="lineno"> 2319 </span><span class="decl"><span class="istickedoff">instantiateSetupValue sc s v =</span>
<span class="lineno"> 2320 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno"> 2321 </span><span class="spaces">    </span><span class="istickedoff">SetupVar{}               -&gt; return v</span>
<span class="lineno"> 2322 </span><span class="spaces">    </span><span class="istickedoff">SetupTerm tt             -&gt; SetupTerm     &lt;$&gt; doTerm tt</span>
<span class="lineno"> 2323 </span><span class="spaces">    </span><span class="istickedoff">SetupStruct p vs         -&gt; <span class="nottickedoff">SetupStruct p &lt;$&gt; mapM (instantiateSetupValue sc s) vs</span></span>
<span class="lineno"> 2324 </span><span class="spaces">    </span><span class="istickedoff">SetupArray () vs         -&gt; SetupArray () &lt;$&gt; mapM (instantiateSetupValue <span class="nottickedoff">sc</span> s) vs</span>
<span class="lineno"> 2325 </span><span class="spaces">    </span><span class="istickedoff">SetupElem{}              -&gt; return v</span>
<span class="lineno"> 2326 </span><span class="spaces">    </span><span class="istickedoff">SetupField{}             -&gt; return v</span>
<span class="lineno"> 2327 </span><span class="spaces">    </span><span class="istickedoff">SetupCast{}              -&gt; <span class="nottickedoff">return v</span></span>
<span class="lineno"> 2328 </span><span class="spaces">    </span><span class="istickedoff">SetupUnion{}             -&gt; <span class="nottickedoff">return v</span></span>
<span class="lineno"> 2329 </span><span class="spaces">    </span><span class="istickedoff">SetupNull{}              -&gt; <span class="nottickedoff">return v</span></span>
<span class="lineno"> 2330 </span><span class="spaces">    </span><span class="istickedoff">SetupGlobal{}            -&gt; return v</span>
<span class="lineno"> 2331 </span><span class="spaces">    </span><span class="istickedoff">SetupGlobalInitializer{} -&gt; return v</span>
<span class="lineno"> 2332 </span><span class="spaces">    </span><span class="istickedoff">SetupMux empty _ _ _     -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 2333 </span><span class="spaces">    </span><span class="istickedoff">SetupEnum  empty         -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 2334 </span><span class="spaces">    </span><span class="istickedoff">SetupTuple empty _       -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 2335 </span><span class="spaces">    </span><span class="istickedoff">SetupSlice empty         -&gt; <span class="nottickedoff">absurd empty</span></span>
<span class="lineno"> 2336 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2337 </span><span class="spaces">    </span><span class="istickedoff">doTerm (TypedTerm schema t) = TypedTerm schema &lt;$&gt; scInstantiateExt sc s t</span></span>
<span class="lineno"> 2338 </span>
<span class="lineno"> 2339 </span>------------------------------------------------------------------------
<span class="lineno"> 2340 </span>
<span class="lineno"> 2341 </span>resolveSetupValueLLVM ::
<span class="lineno"> 2342 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 2343 </span>  Options -&gt;
<span class="lineno"> 2344 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2345 </span>  SharedContext -&gt;
<span class="lineno"> 2346 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 2347 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno"> 2348 </span>  OverrideMatcher (LLVM arch) md (Crucible.MemType, LLVMVal)
<span class="lineno"> 2349 </span><span class="decl"><span class="istickedoff">resolveSetupValueLLVM opts cc sc spec sval =</span>
<span class="lineno"> 2350 </span><span class="spaces">  </span><span class="istickedoff">do m &lt;- OM (use setupValueSub)</span>
<span class="lineno"> 2351 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- OM (use termSub)</span>
<span class="lineno"> 2352 </span><span class="spaces">     </span><span class="istickedoff">mem &lt;- readGlobal (Crucible.llvmMemVar (ccLLVMContext cc))</span>
<span class="lineno"> 2353 </span><span class="spaces">     </span><span class="istickedoff">let tyenv = MS.csAllocations spec</span>
<span class="lineno"> 2354 </span><span class="spaces">         </span><span class="istickedoff">nameEnv = MS.csTypeNames spec</span>
<span class="lineno"> 2355 </span><span class="spaces">     </span><span class="istickedoff">memTy &lt;- exceptToFail $ typeOfSetupValue cc tyenv nameEnv sval</span>
<span class="lineno"> 2356 </span><span class="spaces">     </span><span class="istickedoff">sval' &lt;- liftIO $ instantiateSetupValue sc s sval</span>
<span class="lineno"> 2357 </span><span class="spaces">     </span><span class="istickedoff">lval  &lt;- liftIO $ resolveSetupVal cc mem m tyenv nameEnv sval' `X.catch` <span class="nottickedoff">handleException opts</span></span>
<span class="lineno"> 2358 </span><span class="spaces">     </span><span class="istickedoff">return (memTy, lval)</span></span>
<span class="lineno"> 2359 </span>
<span class="lineno"> 2360 </span>resolveSetupValue ::
<span class="lineno"> 2361 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 2362 </span>  Options -&gt;
<span class="lineno"> 2363 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2364 </span>  SharedContext -&gt;
<span class="lineno"> 2365 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 2366 </span>  Crucible.TypeRepr tp -&gt;
<span class="lineno"> 2367 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno"> 2368 </span>  OverrideMatcher (LLVM arch) md (Crucible.MemType, Crucible.RegValue Sym tp)
<span class="lineno"> 2369 </span><span class="decl"><span class="istickedoff">resolveSetupValue opts cc sc spec tp sval =</span>
<span class="lineno"> 2370 </span><span class="spaces">  </span><span class="istickedoff">do (memTy, lval) &lt;- resolveSetupValueLLVM <span class="nottickedoff">opts</span> cc sc spec sval</span>
<span class="lineno"> 2371 </span><span class="spaces">     </span><span class="istickedoff">sym &lt;- Ov.getSymInterface</span>
<span class="lineno"> 2372 </span><span class="spaces">     </span><span class="istickedoff">val &lt;- liftIO $ Crucible.unpackMemValue <span class="nottickedoff">sym</span> tp lval</span>
<span class="lineno"> 2373 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">memTy</span>, val)</span></span>
<span class="lineno"> 2374 </span>
<span class="lineno"> 2375 </span>-- | Like 'resolveSetupValueLLVM', but specifically geared towards the needs
<span class="lineno"> 2376 </span>-- of fields within bitfields. See the Haddocks for 'resolveSetupValBitfield'
<span class="lineno"> 2377 </span>-- for the salient details.
<span class="lineno"> 2378 </span>resolveSetupValueBitfieldLLVM ::
<span class="lineno"> 2379 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 2380 </span>  Options -&gt;
<span class="lineno"> 2381 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2382 </span>  SharedContext -&gt;
<span class="lineno"> 2383 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 2384 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno"> 2385 </span>  String -&gt;
<span class="lineno"> 2386 </span>  OverrideMatcher (LLVM arch) md (BitfieldIndex, LLVMVal)
<span class="lineno"> 2387 </span><span class="decl"><span class="istickedoff">resolveSetupValueBitfieldLLVM opts cc sc spec sval fieldName =</span>
<span class="lineno"> 2388 </span><span class="spaces">  </span><span class="istickedoff">do m &lt;- OM (use setupValueSub)</span>
<span class="lineno"> 2389 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- OM (use <span class="nottickedoff">termSub</span>)</span>
<span class="lineno"> 2390 </span><span class="spaces">     </span><span class="istickedoff">mem &lt;- readGlobal (Crucible.llvmMemVar (ccLLVMContext cc))</span>
<span class="lineno"> 2391 </span><span class="spaces">     </span><span class="istickedoff">let tyenv = MS.csAllocations spec</span>
<span class="lineno"> 2392 </span><span class="spaces">         </span><span class="istickedoff">nameEnv = MS.csTypeNames spec</span>
<span class="lineno"> 2393 </span><span class="spaces">     </span><span class="istickedoff">sval' &lt;- liftIO $ instantiateSetupValue <span class="nottickedoff">sc</span> <span class="nottickedoff">s</span> sval</span>
<span class="lineno"> 2394 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ resolveSetupValBitfield cc <span class="nottickedoff">mem</span> m tyenv nameEnv sval' fieldName `X.catch` <span class="nottickedoff">handleException opts</span></span></span>
<span class="lineno"> 2395 </span>
<span class="lineno"> 2396 </span>-- | Like 'resolveSetupValue', but specifically geared towards the needs
<span class="lineno"> 2397 </span>-- of fields within bitfields. Note that the LHS value must be a pointer, so
<span class="lineno"> 2398 </span>-- there is no need to pass a 'Crucible.TypeRepr' here. Moreover, the second
<span class="lineno"> 2399 </span>-- return value is always specialized to 'LLVMPtr'. See also the Haddocks for
<span class="lineno"> 2400 </span>-- 'resolveSetupValueBitfieldLLVM' for other differences.
<span class="lineno"> 2401 </span>resolveSetupValueBitfield ::
<span class="lineno"> 2402 </span>  (?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 2403 </span>  Options -&gt;
<span class="lineno"> 2404 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2405 </span>  SharedContext -&gt;
<span class="lineno"> 2406 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 2407 </span>  SetupValue (LLVM arch) -&gt;
<span class="lineno"> 2408 </span>  String -&gt;
<span class="lineno"> 2409 </span>  OverrideMatcher (LLVM arch) md (BitfieldIndex, LLVMPtr (Crucible.ArchWidth arch))
<span class="lineno"> 2410 </span><span class="decl"><span class="istickedoff">resolveSetupValueBitfield opts cc sc spec sval fieldName =</span>
<span class="lineno"> 2411 </span><span class="spaces">  </span><span class="istickedoff">do (bfIndex, lval) &lt;- resolveSetupValueBitfieldLLVM <span class="nottickedoff">opts</span> cc <span class="nottickedoff">sc</span> spec sval fieldName</span>
<span class="lineno"> 2412 </span><span class="spaces">     </span><span class="istickedoff">sym &lt;- Ov.getSymInterface</span>
<span class="lineno"> 2413 </span><span class="spaces">     </span><span class="istickedoff">val &lt;- liftIO $ Crucible.unpackMemValue <span class="nottickedoff">sym</span> Crucible.PtrRepr lval</span>
<span class="lineno"> 2414 </span><span class="spaces">     </span><span class="istickedoff">pure (bfIndex, val)</span></span>
<span class="lineno"> 2415 </span>
<span class="lineno"> 2416 </span>enableSMTArrayMemoryModel :: W4.ConfigOption W4.BaseBoolType
<span class="lineno"> 2417 </span><span class="decl"><span class="istickedoff">enableSMTArrayMemoryModel = (W4.configOption W4.knownRepr &quot;smt-array-memory-model&quot;)</span></span>

</pre>
</body>
</html>
