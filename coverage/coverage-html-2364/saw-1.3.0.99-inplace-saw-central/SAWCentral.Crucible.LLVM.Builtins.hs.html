<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Crucible.LLVM.Builtins
<span class="lineno">    3 </span>Description : Implementations of Crucible-related SAW-Script primitives.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : atomb
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE FlexibleContexts, FlexibleInstances, TypeSynonymInstances, MultiParamTypeClasses#-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   10 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   11 </span>{-# LANGUAGE EmptyCase #-}
<span class="lineno">   12 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   13 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   14 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   15 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   16 </span>{-# LANGUAGE ParallelListComp #-}
<span class="lineno">   17 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   18 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   19 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   20 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   21 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   22 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   23 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   24 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>module SAWCentral.Crucible.LLVM.Builtins
<span class="lineno">   29 </span>    ( show_cfg
<span class="lineno">   30 </span>    , llvm_execute_func
<span class="lineno">   31 </span>    , llvm_return
<span class="lineno">   32 </span>    , llvm_precond
<span class="lineno">   33 </span>    , llvm_postcond
<span class="lineno">   34 </span>    , llvm_assert
<span class="lineno">   35 </span>    , llvm_cfg
<span class="lineno">   36 </span>    , llvm_extract
<span class="lineno">   37 </span>    , llvm_compositional_extract
<span class="lineno">   38 </span>    , llvm_verify
<span class="lineno">   39 </span>    , llvm_refine_spec
<span class="lineno">   40 </span>    , llvm_array_size_profile
<span class="lineno">   41 </span>    , llvm_setup_with_tag
<span class="lineno">   42 </span>    , crucible_setup_val_to_typed_term
<span class="lineno">   43 </span>    , llvm_spec_size
<span class="lineno">   44 </span>    , llvm_spec_solvers
<span class="lineno">   45 </span>    , llvm_ghost_value
<span class="lineno">   46 </span>    , llvm_equal
<span class="lineno">   47 </span>    , llvm_points_to
<span class="lineno">   48 </span>    , llvm_conditional_points_to
<span class="lineno">   49 </span>    , llvm_points_to_at_type
<span class="lineno">   50 </span>    , llvm_conditional_points_to_at_type
<span class="lineno">   51 </span>    , llvm_points_to_internal
<span class="lineno">   52 </span>    , llvm_points_to_array_prefix
<span class="lineno">   53 </span>    , llvm_points_to_bitfield
<span class="lineno">   54 </span>    , llvm_fresh_pointer
<span class="lineno">   55 </span>    , llvm_unsafe_assume_spec
<span class="lineno">   56 </span>    , llvm_fresh_var
<span class="lineno">   57 </span>    , llvm_fresh_cryptol_var
<span class="lineno">   58 </span>    , llvm_alloc
<span class="lineno">   59 </span>    , llvm_alloc_aligned
<span class="lineno">   60 </span>    , llvm_alloc_readonly
<span class="lineno">   61 </span>    , llvm_alloc_readonly_aligned
<span class="lineno">   62 </span>    , llvm_alloc_with_size
<span class="lineno">   63 </span>    , llvm_alloc_sym_init
<span class="lineno">   64 </span>    , llvm_symbolic_alloc
<span class="lineno">   65 </span>    , llvm_alloc_global
<span class="lineno">   66 </span>    , llvm_fresh_expanded_val
<span class="lineno">   67 </span>    , llvm_sizeof
<span class="lineno">   68 </span>    , llvm_cast_pointer
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>    --
<span class="lineno">   71 </span>    -- These function are common to LLVM &amp; JVM implementation (not for external use)
<span class="lineno">   72 </span>    , setupArg
<span class="lineno">   73 </span>    , setupArgs
<span class="lineno">   74 </span>    , getGlobalPair
<span class="lineno">   75 </span>    , runCFG
<span class="lineno">   76 </span>    , baseCryptolType
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>    , displayVerifExceptionOpts
<span class="lineno">   79 </span>    , findDecl
<span class="lineno">   80 </span>    , findDefMaybeStatic
<span class="lineno">   81 </span>    , setupLLVMCrucibleContext
<span class="lineno">   82 </span>    , setupPrestateConditions
<span class="lineno">   83 </span>    , checkSpecReturnType
<span class="lineno">   84 </span>    , verifyPrestate
<span class="lineno">   85 </span>    , verifyPoststate
<span class="lineno">   86 </span>    , getPoststateObligations
<span class="lineno">   87 </span>    , withCfgAndBlockId
<span class="lineno">   88 </span>    , registerOverride
<span class="lineno">   89 </span>    , lookupMemGlobal
<span class="lineno">   90 </span>    ) where
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>import Prelude hiding (fail)
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>import qualified Control.Exception as X
<span class="lineno">   95 </span>import           Control.Lens
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>import           Control.Monad (foldM, forM, replicateM, unless, when)
<span class="lineno">   98 </span>import           Control.Monad.Fail (MonadFail(..))
<span class="lineno">   99 </span>import           Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">  100 </span>import           Control.Monad.Reader (runReaderT)
<span class="lineno">  101 </span>import           Control.Monad.State (MonadState(..), StateT(..), execStateT, gets)
<span class="lineno">  102 </span>import           Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">  103 </span>import qualified Data.Bimap as Bimap
<span class="lineno">  104 </span>import           Data.Char (isDigit)
<span class="lineno">  105 </span>import           Data.Foldable (for_, toList, fold)
<span class="lineno">  106 </span>import           Data.Functor (void)
<span class="lineno">  107 </span>import           Data.IORef
<span class="lineno">  108 </span>import           Data.List (find, nub, partition)
<span class="lineno">  109 </span>import           Data.List.Extra (nubOrd)
<span class="lineno">  110 </span>import qualified Data.List.NonEmpty as NE
<span class="lineno">  111 </span>import           Data.Maybe
<span class="lineno">  112 </span>import           Data.String
<span class="lineno">  113 </span>import           Data.Map (Map)
<span class="lineno">  114 </span>import qualified Data.Map as Map
<span class="lineno">  115 </span>import           Data.HashMap.Strict (HashMap)
<span class="lineno">  116 </span>import qualified Data.HashMap.Strict as HashMap
<span class="lineno">  117 </span>import qualified Data.Set as Set
<span class="lineno">  118 </span>import           Data.Sequence (Seq)
<span class="lineno">  119 </span>import qualified Data.Sequence as Seq
<span class="lineno">  120 </span>import           Data.Text (Text)
<span class="lineno">  121 </span>import qualified Data.Text as Text
<span class="lineno">  122 </span>import           Data.Time.Clock (getCurrentTime, diffUTCTime)
<span class="lineno">  123 </span>import qualified Data.Vector as V
<span class="lineno">  124 </span>import           Prettyprinter
<span class="lineno">  125 </span>import           System.IO
<span class="lineno">  126 </span>import qualified Text.LLVM.AST as L
<span class="lineno">  127 </span>import           Text.URI
<span class="lineno">  128 </span>import qualified Control.Monad.Trans.Maybe as MaybeT
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>-- parameterized-utils
<span class="lineno">  131 </span>import           Data.Parameterized.Classes
<span class="lineno">  132 </span>import           Data.Parameterized.Map (MapF)
<span class="lineno">  133 </span>import qualified Data.Parameterized.Map as MapF
<span class="lineno">  134 </span>import           Data.Parameterized.NatRepr
<span class="lineno">  135 </span>import           Data.Parameterized.Some
<span class="lineno">  136 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- cryptol
<span class="lineno">  139 </span>import qualified Cryptol.TypeCheck.Type as Cryptol
<span class="lineno">  140 </span>import qualified Cryptol.TypeCheck.PP as Cryptol
<span class="lineno">  141 </span>import qualified CryptolSAWCore.Cryptol as Cryptol
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- what4
<span class="lineno">  144 </span>import qualified What4.Concrete as W4
<span class="lineno">  145 </span>import qualified What4.Config as W4
<span class="lineno">  146 </span>import qualified What4.FunctionName as W4
<span class="lineno">  147 </span>import qualified What4.LabeledPred as W4
<span class="lineno">  148 </span>import qualified What4.ProgramLoc as W4
<span class="lineno">  149 </span>import qualified What4.Interface as W4
<span class="lineno">  150 </span>import qualified What4.Expr.Builder as W4
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- crucible
<span class="lineno">  153 </span>import qualified Lang.Crucible.Backend as Crucible
<span class="lineno">  154 </span>import qualified Lang.Crucible.Backend.Online as Crucible
<span class="lineno">  155 </span>import qualified Lang.Crucible.CFG.Core as Crucible
<span class="lineno">  156 </span>import qualified Lang.Crucible.CFG.Extension as Crucible
<span class="lineno">  157 </span>  (IsSyntaxExtension)
<span class="lineno">  158 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">  159 </span>import qualified Lang.Crucible.Simulator as Crucible
<span class="lineno">  160 </span>import qualified Lang.Crucible.Simulator.Breakpoint as Crucible
<span class="lineno">  161 </span>import qualified Lang.Crucible.Simulator.GlobalState as Crucible
<span class="lineno">  162 </span>import qualified Lang.Crucible.Simulator.PathSatisfiability as Crucible
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>-- crucible-llvm
<span class="lineno">  165 </span>import qualified Lang.Crucible.LLVM.ArraySizeProfile as Crucible
<span class="lineno">  166 </span>import qualified Lang.Crucible.LLVM.DataLayout as Crucible
<span class="lineno">  167 </span>import qualified Lang.Crucible.LLVM.Bytes as Crucible
<span class="lineno">  168 </span>import qualified Lang.Crucible.LLVM.Functions as Crucible
<span class="lineno">  169 </span>import qualified Lang.Crucible.LLVM.Intrinsics as Crucible
<span class="lineno">  170 </span>import qualified Lang.Crucible.LLVM.MemModel as Crucible
<span class="lineno">  171 </span>import qualified Lang.Crucible.LLVM.MemType as Crucible
<span class="lineno">  172 </span>import qualified Lang.Crucible.LLVM.PrettyPrint as Crucible
<span class="lineno">  173 </span>import           Lang.Crucible.LLVM.QQ( llvmOvr )
<span class="lineno">  174 </span>import qualified Lang.Crucible.LLVM.Translation as Crucible
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>import qualified SAWCentral.Crucible.LLVM.CrucibleLLVM as Crucible
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>-- parameterized-utils
<span class="lineno">  179 </span>import qualified Data.Parameterized.TraversableFC as Ctx
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>-- saw-core
<span class="lineno">  182 </span>import SAWCore.FiniteValue (ppFirstOrderValue)
<span class="lineno">  183 </span>import SAWCore.SharedTerm
<span class="lineno">  184 </span>import SAWCore.TypedAST
<span class="lineno">  185 </span>import SAWCore.Recognizer
<span class="lineno">  186 </span>import SAWCore.Term.Pretty (showTerm)
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>import SAWCoreWhat4.ReturnTrip
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- cryptol-saw-core
<span class="lineno">  191 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  192 </span>
<span class="lineno">  193 </span>-- saw-script
<span class="lineno">  194 </span>import SAWCentral.AST (Located(..), tMono, tTerm)
<span class="lineno">  195 </span>import SAWCentral.Builtins (ghost_value)
<span class="lineno">  196 </span>import SAWCentral.Proof
<span class="lineno">  197 </span>import SAWCentral.Prover.SolverStats
<span class="lineno">  198 </span>import SAWCentral.Prover.Versions
<span class="lineno">  199 </span>import SAWCentral.TopLevel
<span class="lineno">  200 </span>import SAWCentral.Value
<span class="lineno">  201 </span>import SAWCentral.Position
<span class="lineno">  202 </span>import SAWCentral.Exceptions
<span class="lineno">  203 </span>import SAWCentral.Options
<span class="lineno">  204 </span>import SAWCentral.Utils (neGroupOn, neNubOrd)
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>import qualified SAWCentral.Crucible.Common as Common
<span class="lineno">  207 </span>import           SAWCentral.Crucible.Common (Sym, SAWCruciblePersonality)
<span class="lineno">  208 </span>import           SAWCentral.Crucible.Common.MethodSpec (AllocIndex(..), nextAllocIndex, PrePost(..))
<span class="lineno">  209 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as MS
<span class="lineno">  210 </span>import           SAWCentral.Crucible.Common.MethodSpec (SetupValue(..))
<span class="lineno">  211 </span>import           SAWCentral.Crucible.Common.Override
<span class="lineno">  212 </span>import qualified SAWCentral.Crucible.Common.Setup.Builtins as Setup
<span class="lineno">  213 </span>import qualified SAWCentral.Crucible.Common.Setup.Type as Setup
<span class="lineno">  214 </span>import qualified SAWCentral.Crucible.Common.Vacuity as Vacuity
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>import SAWCentral.Crucible.LLVM.Override
<span class="lineno">  217 </span>import SAWCentral.Crucible.LLVM.ResolveSetupValue
<span class="lineno">  218 </span>import SAWCentral.Crucible.LLVM.MethodSpecIR
<span class="lineno">  219 </span>import SAWCentral.Panic (panic)
<span class="lineno">  220 </span>
<span class="lineno">  221 </span>type AssumptionReason = (MS.ConditionMetadata, String)
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>type MemImpl = Crucible.MemImpl Sym
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>data LLVMVerificationException
<span class="lineno">  226 </span>  = MultipleStaticFunctions L.Symbol
<span class="lineno">  227 </span>  | DefNotFound L.Symbol [L.Symbol]
<span class="lineno">  228 </span>  | DeclNotFound L.Symbol [L.Symbol]
<span class="lineno">  229 </span>  | SetupError SetupError
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>displayVerifExceptionOpts :: Options -&gt; LLVMVerificationException -&gt; String
<span class="lineno">  232 </span><span class="decl"><span class="istickedoff">displayVerifExceptionOpts _ (MultipleStaticFunctions (L.Symbol nm)) =</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">&quot;Multiple non-equal definitions for `&quot; ++ nm ++ &quot;`.&quot;</span></span>
<span class="lineno">  234 </span><span class="spaces"></span><span class="istickedoff">displayVerifExceptionOpts opts (DefNotFound (L.Symbol nm) nms) =</span>
<span class="lineno">  235 </span><span class="spaces">  </span><span class="istickedoff">unlines $</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="istickedoff">[ &quot;Could not find definition for function named `&quot; ++ nm ++ &quot;`.&quot;</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">] ++ if <span class="tickonlytrue">simVerbose opts &lt; 3</span></span>
<span class="lineno">  238 </span><span class="spaces">       </span><span class="istickedoff">then [ &quot;Run SAW with --sim-verbose=3 to see all function names&quot; ]</span>
<span class="lineno">  239 </span><span class="spaces">       </span><span class="istickedoff">else <span class="nottickedoff">&quot;Available function names:&quot; : map ((&quot;  &quot; ++) . show . Crucible.ppSymbol) nms</span></span>
<span class="lineno">  240 </span><span class="spaces"></span><span class="istickedoff">displayVerifExceptionOpts opts (DeclNotFound (L.Symbol nm) nms) =</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">unlines $</span></span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Could not find declaration for function named `&quot; ++ nm ++ &quot;`.&quot;</span></span>
<span class="lineno">  243 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">] ++ if simVerbose opts &lt; 3</span></span>
<span class="lineno">  244 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">then [ &quot;Run SAW with --sim-verbose=3 to see all function names&quot; ]</span></span>
<span class="lineno">  245 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">else &quot;Available function names:&quot; : map ((&quot;  &quot; ++) . show . Crucible.ppSymbol) nms</span></span>
<span class="lineno">  246 </span><span class="spaces"></span><span class="istickedoff">displayVerifExceptionOpts _ (SetupError e) =</span>
<span class="lineno">  247 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">&quot;Error during simulation setup: &quot; ++ show (ppSetupError e)</span></span></span>
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>show_cfg :: SAW_CFG -&gt; String
<span class="lineno">  250 </span><span class="decl"><span class="nottickedoff">show_cfg (LLVM_CFG (Crucible.AnyCFG cfg)) = show cfg</span>
<span class="lineno">  251 </span><span class="spaces"></span><span class="nottickedoff">show_cfg (JVM_CFG (Crucible.AnyCFG cfg)) = show cfg</span></span>
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>-- | Determines whether one LLVM symbol is equivalent to another except
<span class="lineno">  254 </span>-- for a numeric suffix. This can determine whether one symbol is the
<span class="lineno">  255 </span>-- disambiguated name of a duplicated static function.
<span class="lineno">  256 </span>matchingStatics :: L.Symbol -&gt; L.Symbol -&gt; Bool
<span class="lineno">  257 </span><span class="decl"><span class="istickedoff">matchingStatics (L.Symbol a) (L.Symbol b) = go a b</span>
<span class="lineno">  258 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">go [] [] = True</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">go (x:xs) (y:ys) = x == y &amp;&amp; go xs ys</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">go [] ('.':ds) = <span class="nottickedoff">all isDigit ds</span></span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">go ('.':ds) [] = all isDigit ds</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">go _ _ = False</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>findDefMaybeStatic :: L.Module -&gt; String -&gt; Either LLVMVerificationException (NE.NonEmpty L.Define)
<span class="lineno">  266 </span><span class="decl"><span class="istickedoff">findDefMaybeStatic llmod nm =</span>
<span class="lineno">  267 </span><span class="spaces">  </span><span class="istickedoff">case NE.nonEmpty (filter (\d -&gt; matchingStatics (L.defName d) nm') (L.modDefines llmod)) of</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; Left $ DefNotFound nm' $ <span class="nottickedoff">map L.defName $ L.modDefines llmod</span></span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">Just defs -&gt; Right defs</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff">nm' = fromString nm</span></span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>findDecl :: L.Module -&gt; String -&gt; Either LLVMVerificationException L.Declare
<span class="lineno">  274 </span><span class="decl"><span class="istickedoff">findDecl llmod nm =</span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="istickedoff">case find (\d -&gt; (L.decName d) == nm') (L.modDeclares llmod) of</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">Just decl -&gt; Right decl</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; Left $ <span class="nottickedoff">DeclNotFound nm' $ map L.decName $ L.modDeclares llmod</span></span>
<span class="lineno">  278 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">nm' = fromString nm</span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>resolveSpecName :: String -&gt; TopLevel (String, Maybe String)
<span class="lineno">  282 </span><span class="decl"><span class="istickedoff">resolveSpecName nm =</span>
<span class="lineno">  283 </span><span class="spaces">  </span><span class="istickedoff">if Crucible.testBreakpointFunction nm</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">then</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">let (fnName, fnSuffix) = break (== '#') nm</span>
<span class="lineno">  286 </span><span class="spaces">        </span><span class="istickedoff">parentName =</span>
<span class="lineno">  287 </span><span class="spaces">          </span><span class="istickedoff">case fnSuffix of</span>
<span class="lineno">  288 </span><span class="spaces">            </span><span class="istickedoff">_:parentName' -&gt; parentName'</span>
<span class="lineno">  289 </span><span class="spaces">            </span><span class="istickedoff">-- TODO: Give a proper error message here instead of panicking,</span>
<span class="lineno">  290 </span><span class="spaces">            </span><span class="istickedoff">-- and document __breakpoint__ naming requirements. See #2097.</span>
<span class="lineno">  291 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">panic &quot;resolveSpecName&quot; [</span></span>
<span class="lineno">  292 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;__breakpoint__ function not followed by #&lt;parent_name&gt;&quot;,</span></span>
<span class="lineno">  293 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;See https://github.com/GaloisInc/saw-script/issues/2097&quot;</span></span>
<span class="lineno">  294 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  295 </span><span class="spaces">    </span><span class="istickedoff">in</span>
<span class="lineno">  296 </span><span class="spaces">    </span><span class="istickedoff">return</span>
<span class="lineno">  297 </span><span class="spaces">      </span><span class="istickedoff">( fnName</span>
<span class="lineno">  298 </span><span class="spaces">      </span><span class="istickedoff">, Just parentName</span>
<span class="lineno">  299 </span><span class="spaces">      </span><span class="istickedoff">)</span>
<span class="lineno">  300 </span><span class="spaces">  </span><span class="istickedoff">else return (nm, Nothing)</span></span>
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>llvm_verify ::
<span class="lineno">  303 </span>  Some LLVMModule        -&gt;
<span class="lineno">  304 </span>  String                 -&gt;
<span class="lineno">  305 </span>  [SomeLLVM MS.ProvedSpec] -&gt;
<span class="lineno">  306 </span>  Bool                   -&gt;
<span class="lineno">  307 </span>  LLVMCrucibleSetupM ()      -&gt;
<span class="lineno">  308 </span>  ProofScript () -&gt;
<span class="lineno">  309 </span>  TopLevel (SomeLLVM MS.ProvedSpec)
<span class="lineno">  310 </span><span class="decl"><span class="istickedoff">llvm_verify (Some lm) nm lemmas checkSat setup tactic =</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="istickedoff">do start &lt;- io getCurrentTime</span>
<span class="lineno">  312 </span><span class="spaces">     </span><span class="istickedoff">lemmas' &lt;- checkModuleCompatibility lm lemmas</span>
<span class="lineno">  313 </span><span class="spaces">     </span><span class="istickedoff">withMethodSpec checkSat lm nm setup $ \cc method_spec -&gt;</span>
<span class="lineno">  314 </span><span class="spaces">       </span><span class="istickedoff">do (stats, vcs, _) &lt;- verifyMethodSpec cc method_spec lemmas' checkSat tactic Nothing</span>
<span class="lineno">  315 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">lemmaSet = Set.fromList (map (view MS.psSpecIdent) lemmas')</span></span>
<span class="lineno">  316 </span><span class="spaces">          </span><span class="istickedoff">end &lt;- io getCurrentTime</span>
<span class="lineno">  317 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">diff = diffUTCTime end start</span></span>
<span class="lineno">  318 </span><span class="spaces">          </span><span class="istickedoff">ps &lt;- io (MS.mkProvedSpec <span class="nottickedoff">MS.SpecProved</span> method_spec <span class="nottickedoff">stats</span> <span class="nottickedoff">vcs</span> <span class="nottickedoff">lemmaSet</span> <span class="nottickedoff">diff</span>)</span>
<span class="lineno">  319 </span><span class="spaces">          </span><span class="istickedoff">returnProof $ SomeLLVM ps</span></span>
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>llvm_refine_spec ::
<span class="lineno">  322 </span>  Some LLVMModule -&gt;
<span class="lineno">  323 </span>  String -&gt;
<span class="lineno">  324 </span>  [SomeLLVM MS.ProvedSpec] -&gt;
<span class="lineno">  325 </span>  LLVMCrucibleSetupM () -&gt;
<span class="lineno">  326 </span>  ProofScript () -&gt;
<span class="lineno">  327 </span>  TopLevel (SomeLLVM MS.ProvedSpec)
<span class="lineno">  328 </span><span class="decl"><span class="istickedoff">llvm_refine_spec (Some lm) nm lemmas setup tactic =</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="istickedoff">do start &lt;- io getCurrentTime</span>
<span class="lineno">  330 </span><span class="spaces">     </span><span class="istickedoff">lemmas' &lt;- checkModuleCompatibility lm lemmas</span>
<span class="lineno">  331 </span><span class="spaces">     </span><span class="istickedoff">withMethodSpec False lm nm setup $ \cc method_spec -&gt;</span>
<span class="lineno">  332 </span><span class="spaces">       </span><span class="istickedoff">do (stats, deps) &lt;- refineMethodSpec cc method_spec lemmas' tactic</span>
<span class="lineno">  333 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">lemmaSet = Set.fromList (map (view MS.psSpecIdent) lemmas')</span></span>
<span class="lineno">  334 </span><span class="spaces">          </span><span class="istickedoff">end &lt;- io getCurrentTime</span>
<span class="lineno">  335 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">diff = diffUTCTime end start</span></span>
<span class="lineno">  336 </span><span class="spaces">          </span><span class="istickedoff">ps &lt;- io (MS.mkProvedSpec <span class="nottickedoff">MS.SpecProved</span> <span class="nottickedoff">method_spec</span> <span class="nottickedoff">stats</span> <span class="nottickedoff">deps</span> <span class="nottickedoff">lemmaSet</span> <span class="nottickedoff">diff</span>)</span>
<span class="lineno">  337 </span><span class="spaces">          </span><span class="istickedoff">returnProof $ SomeLLVM <span class="nottickedoff">ps</span></span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>llvm_unsafe_assume_spec ::
<span class="lineno">  340 </span>  Some LLVMModule  -&gt;
<span class="lineno">  341 </span>  String          {- ^ Name of the function -} -&gt;
<span class="lineno">  342 </span>  LLVMCrucibleSetupM () {- ^ Boundary specification -} -&gt;
<span class="lineno">  343 </span>  TopLevel (SomeLLVM MS.ProvedSpec)
<span class="lineno">  344 </span><span class="decl"><span class="istickedoff">llvm_unsafe_assume_spec (Some lm) nm setup =</span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">withMethodSpec False lm nm setup $ \_ method_spec -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">  </span><span class="istickedoff">do printOutLnTop Info $</span>
<span class="lineno">  347 </span><span class="spaces">       </span><span class="istickedoff">unwords [&quot;Assume override&quot;, (method_spec ^. csName)]</span>
<span class="lineno">  348 </span><span class="spaces">     </span><span class="istickedoff">ps &lt;- io (MS.mkProvedSpec <span class="nottickedoff">MS.SpecAdmitted</span> method_spec <span class="nottickedoff">mempty</span> <span class="nottickedoff">mempty</span> <span class="nottickedoff">mempty</span> <span class="nottickedoff">0</span>)</span>
<span class="lineno">  349 </span><span class="spaces">     </span><span class="istickedoff">returnProof $ SomeLLVM ps</span></span>
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>llvm_array_size_profile ::
<span class="lineno">  352 </span>  ProofScript () -&gt;
<span class="lineno">  353 </span>  Some LLVMModule -&gt;
<span class="lineno">  354 </span>  String -&gt;
<span class="lineno">  355 </span>  [SomeLLVM MS.ProvedSpec] -&gt;
<span class="lineno">  356 </span>  LLVMCrucibleSetupM () -&gt;
<span class="lineno">  357 </span>  TopLevel [(String, [Crucible.FunctionProfile])]
<span class="lineno">  358 </span><span class="decl"><span class="nottickedoff">llvm_array_size_profile assume (Some lm) nm lemmas setup = do</span>
<span class="lineno">  359 </span><span class="spaces">  </span><span class="nottickedoff">cell &lt;- io $ newIORef (Map.empty :: Map Text.Text [Crucible.FunctionProfile])</span>
<span class="lineno">  360 </span><span class="spaces">  </span><span class="nottickedoff">lemmas' &lt;- checkModuleCompatibility lm lemmas</span>
<span class="lineno">  361 </span><span class="spaces">  </span><span class="nottickedoff">withMethodSpec False lm nm setup $ \cc ms -&gt; do</span>
<span class="lineno">  362 </span><span class="spaces">    </span><span class="nottickedoff">void . verifyMethodSpec cc ms lemmas' True assume $ Just cell</span>
<span class="lineno">  363 </span><span class="spaces">    </span><span class="nottickedoff">profiles &lt;- io $ readIORef cell</span>
<span class="lineno">  364 </span><span class="spaces">    </span><span class="nottickedoff">pure . fmap (\(fnm, prof) -&gt; (Text.unpack fnm, prof)) $ Map.toList profiles</span></span>
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>llvmURI :: String -&gt; URI
<span class="lineno">  367 </span><span class="decl"><span class="istickedoff">llvmURI symbol_name =</span>
<span class="lineno">  368 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe <span class="nottickedoff">(error $ unwords [&quot;mkLLVMName&quot;, &quot;Could not create LLVM symbol name&quot;, symbol_name])</span> $</span>
<span class="lineno">  369 </span><span class="spaces">  </span><span class="istickedoff">do sch &lt;- mkScheme &quot;llvm&quot;</span>
<span class="lineno">  370 </span><span class="spaces">     </span><span class="istickedoff">p   &lt;- mkPathPiece (Text.pack symbol_name)</span>
<span class="lineno">  371 </span><span class="spaces">     </span><span class="istickedoff">pure URI</span>
<span class="lineno">  372 </span><span class="spaces">       </span><span class="istickedoff">{ uriScheme = Just sch</span>
<span class="lineno">  373 </span><span class="spaces">       </span><span class="istickedoff">, uriAuthority = Left True -- absolute path</span>
<span class="lineno">  374 </span><span class="spaces">       </span><span class="istickedoff">, uriPath = Just (False, p NE.:| [])</span>
<span class="lineno">  375 </span><span class="spaces">       </span><span class="istickedoff">, uriQuery = []</span>
<span class="lineno">  376 </span><span class="spaces">       </span><span class="istickedoff">, uriFragment = Nothing</span>
<span class="lineno">  377 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>llvmNameInfo :: String -&gt; NameInfo
<span class="lineno">  380 </span><span class="decl"><span class="istickedoff">llvmNameInfo symbol_name = ImportedName (llvmURI symbol_name) [ Text.pack symbol_name ]</span></span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>llvm_compositional_extract ::
<span class="lineno">  383 </span>  Some LLVMModule -&gt;
<span class="lineno">  384 </span>  String -&gt;
<span class="lineno">  385 </span>  String -&gt;
<span class="lineno">  386 </span>  [SomeLLVM MS.ProvedSpec] -&gt;
<span class="lineno">  387 </span>  Bool {- ^ check sat -} -&gt;
<span class="lineno">  388 </span>  LLVMCrucibleSetupM () -&gt;
<span class="lineno">  389 </span>  ProofScript () -&gt;
<span class="lineno">  390 </span>  TopLevel (SomeLLVM MS.ProvedSpec)
<span class="lineno">  391 </span><span class="decl"><span class="istickedoff">llvm_compositional_extract (Some lm) nm func_name lemmas checkSat setup tactic =</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="istickedoff">do start &lt;- io getCurrentTime</span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="istickedoff">lemmas' &lt;- checkModuleCompatibility lm lemmas</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="istickedoff">withMethodSpec checkSat lm nm setup $ \cc method_spec -&gt;</span>
<span class="lineno">  395 </span><span class="spaces">       </span><span class="istickedoff">do let value_input_parameters = mapMaybe</span>
<span class="lineno">  396 </span><span class="spaces">                </span><span class="istickedoff">(\(_, setup_value) -&gt; setupValueAsExtCns setup_value)</span>
<span class="lineno">  397 </span><span class="spaces">                </span><span class="istickedoff">(Map.elems $ method_spec ^. MS.csArgBindings)</span>
<span class="lineno">  398 </span><span class="spaces">          </span><span class="istickedoff">let reference_input_parameters = mapMaybe</span>
<span class="lineno">  399 </span><span class="spaces">                </span><span class="istickedoff">(\case</span>
<span class="lineno">  400 </span><span class="spaces">                  </span><span class="istickedoff">LLVMPointsTo _ _ _ setup_value -&gt; llvmPointsToValueAsExtCns setup_value</span>
<span class="lineno">  401 </span><span class="spaces">                  </span><span class="istickedoff">LLVMPointsToBitfield _ _ _ val -&gt; <span class="nottickedoff">setupValueAsExtCns val</span>)</span>
<span class="lineno">  402 </span><span class="spaces">                </span><span class="istickedoff">(method_spec ^. MS.csPreState ^. MS.csPointsTos)</span>
<span class="lineno">  403 </span><span class="spaces">          </span><span class="istickedoff">let input_parameters = nub $ value_input_parameters ++ reference_input_parameters</span>
<span class="lineno">  404 </span><span class="spaces">          </span><span class="istickedoff">let pre_free_variables = Map.fromList $</span>
<span class="lineno">  405 </span><span class="spaces">                </span><span class="istickedoff">map (\x -&gt; (tecExt x, <span class="nottickedoff">x</span>)) $ method_spec ^. MS.csPreState ^. MS.csFreshVars</span>
<span class="lineno">  406 </span><span class="spaces">          </span><span class="istickedoff">let unsupported_input_parameters = Set.difference</span>
<span class="lineno">  407 </span><span class="spaces">                </span><span class="istickedoff">(Map.keysSet pre_free_variables)</span>
<span class="lineno">  408 </span><span class="spaces">                </span><span class="istickedoff">(Set.fromList input_parameters)</span>
<span class="lineno">  409 </span><span class="spaces">          </span><span class="istickedoff">when (not $ Set.null unsupported_input_parameters) $</span>
<span class="lineno">  410 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  411 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unsupported input parameters:&quot;</span></span>
<span class="lineno">  412 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, show unsupported_input_parameters</span></span>
<span class="lineno">  413 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;An input parameter must be bound by llvm_execute_func or llvm_points_to.&quot;</span></span>
<span class="lineno">  414 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  415 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  416 </span><span class="spaces">          </span><span class="istickedoff">let return_output_parameter =</span>
<span class="lineno">  417 </span><span class="spaces">                </span><span class="istickedoff">case method_spec ^. MS.csRetValue of</span>
<span class="lineno">  418 </span><span class="spaces">                  </span><span class="istickedoff">Just setup_value -&gt; setupValueAsExtCns setup_value</span>
<span class="lineno">  419 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; Nothing</span>
<span class="lineno">  420 </span><span class="spaces">          </span><span class="istickedoff">let reference_output_parameters =</span>
<span class="lineno">  421 </span><span class="spaces">                </span><span class="istickedoff">mapMaybe</span>
<span class="lineno">  422 </span><span class="spaces">                </span><span class="istickedoff">(\case</span>
<span class="lineno">  423 </span><span class="spaces">                  </span><span class="istickedoff">LLVMPointsTo _ _ _ setup_value -&gt; llvmPointsToValueAsExtCns setup_value</span>
<span class="lineno">  424 </span><span class="spaces">                  </span><span class="istickedoff">LLVMPointsToBitfield _ _ _ val -&gt; <span class="nottickedoff">setupValueAsExtCns val</span>)</span>
<span class="lineno">  425 </span><span class="spaces">                </span><span class="istickedoff">(method_spec ^. MS.csPostState ^. MS.csPointsTos)</span>
<span class="lineno">  426 </span><span class="spaces">          </span><span class="istickedoff">let output_parameters =</span>
<span class="lineno">  427 </span><span class="spaces">                </span><span class="istickedoff">nub $ filter (isNothing . (Map.!?) pre_free_variables) $</span>
<span class="lineno">  428 </span><span class="spaces">                </span><span class="istickedoff">maybeToList return_output_parameter ++ reference_output_parameters</span>
<span class="lineno">  429 </span><span class="spaces">          </span><span class="istickedoff">let post_free_variables =</span>
<span class="lineno">  430 </span><span class="spaces">                </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  431 </span><span class="spaces">                </span><span class="istickedoff">map (\x -&gt; (tecExt x, <span class="nottickedoff">x</span>)) $ method_spec ^. MS.csPostState ^. MS.csFreshVars</span>
<span class="lineno">  432 </span><span class="spaces">          </span><span class="istickedoff">let unsupported_output_parameters =</span>
<span class="lineno">  433 </span><span class="spaces">                </span><span class="istickedoff">Set.difference (Map.keysSet post_free_variables) (Set.fromList output_parameters)</span>
<span class="lineno">  434 </span><span class="spaces">          </span><span class="istickedoff">when (not $ Set.null unsupported_output_parameters) $</span>
<span class="lineno">  435 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno">  436 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unsupported output parameters:&quot;</span></span>
<span class="lineno">  437 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, show unsupported_output_parameters</span></span>
<span class="lineno">  438 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;An output parameter must be bound by llvm_return or llvm_points_to.&quot;</span></span>
<span class="lineno">  439 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  440 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  441 </span><span class="spaces">          </span><span class="istickedoff">(stats, vcs, post_override_state) &lt;-</span>
<span class="lineno">  442 </span><span class="spaces">            </span><span class="istickedoff">verifyMethodSpec cc method_spec lemmas' checkSat <span class="nottickedoff">tactic</span> Nothing</span>
<span class="lineno">  443 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  444 </span><span class="spaces">          </span><span class="istickedoff">shared_context &lt;- getSharedContext</span>
<span class="lineno">  445 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  446 </span><span class="spaces">          </span><span class="istickedoff">let output_values =</span>
<span class="lineno">  447 </span><span class="spaces">                </span><span class="istickedoff">map (((Map.!) $ post_override_state ^. termSub) . ecVarIndex) output_parameters</span>
<span class="lineno">  448 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  449 </span><span class="spaces">          </span><span class="istickedoff">extracted_func &lt;-</span>
<span class="lineno">  450 </span><span class="spaces">            </span><span class="istickedoff">io $ scAbstractExts shared_context input_parameters</span>
<span class="lineno">  451 </span><span class="spaces">            </span><span class="istickedoff">=&lt;&lt; scTuple shared_context output_values</span>
<span class="lineno">  452 </span><span class="spaces">          </span><span class="istickedoff">when ([] /= getAllExts extracted_func) $</span>
<span class="lineno">  453 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Non-functional simulation summary.&quot;</span></span>
<span class="lineno">  454 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  455 </span><span class="spaces">          </span><span class="istickedoff">let nmi = llvmNameInfo func_name</span>
<span class="lineno">  456 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  457 </span><span class="spaces">          </span><span class="istickedoff">extracted_func_const &lt;-</span>
<span class="lineno">  458 </span><span class="spaces">            </span><span class="istickedoff">io $ scConstant' shared_context nmi extracted_func</span>
<span class="lineno">  459 </span><span class="spaces">            </span><span class="istickedoff">=&lt;&lt; scTypeOf shared_context extracted_func</span>
<span class="lineno">  460 </span><span class="spaces">          </span><span class="istickedoff">input_terms &lt;- io $ traverse (scExtCns shared_context) input_parameters</span>
<span class="lineno">  461 </span><span class="spaces">          </span><span class="istickedoff">applied_extracted_func &lt;- io $ scApplyAll shared_context extracted_func_const input_terms</span>
<span class="lineno">  462 </span><span class="spaces">          </span><span class="istickedoff">applied_extracted_func_selectors &lt;-</span>
<span class="lineno">  463 </span><span class="spaces">            </span><span class="istickedoff">io $ forM [1 .. (length output_parameters)] $ \i -&gt;</span>
<span class="lineno">  464 </span><span class="spaces">            </span><span class="istickedoff">mkTypedTerm shared_context</span>
<span class="lineno">  465 </span><span class="spaces">              </span><span class="istickedoff">=&lt;&lt; scTupleSelector shared_context applied_extracted_func i (length output_parameters)</span>
<span class="lineno">  466 </span><span class="spaces">          </span><span class="istickedoff">let output_parameter_substitution =</span>
<span class="lineno">  467 </span><span class="spaces">                </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  468 </span><span class="spaces">                </span><span class="istickedoff">zip (map ecVarIndex output_parameters) (map ttTerm applied_extracted_func_selectors)</span>
<span class="lineno">  469 </span><span class="spaces">          </span><span class="istickedoff">let substitute_output_parameters =</span>
<span class="lineno">  470 </span><span class="spaces">                </span><span class="istickedoff">ttTermLens $ scInstantiateExt <span class="nottickedoff">shared_context</span> output_parameter_substitution</span>
<span class="lineno">  471 </span><span class="spaces">          </span><span class="istickedoff">let setup_value_substitute_output_parameter setup_value</span>
<span class="lineno">  472 </span><span class="spaces">                </span><span class="istickedoff">| SetupTerm term &lt;- setup_value = SetupTerm &lt;$&gt; substitute_output_parameters term</span>
<span class="lineno">  473 </span><span class="spaces">                </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">return $ setup_value</span></span>
<span class="lineno">  474 </span><span class="spaces">          </span><span class="istickedoff">let llvm_points_to_value_substitute_output_parameter = \case</span>
<span class="lineno">  475 </span><span class="spaces">                </span><span class="istickedoff">ConcreteSizeValue val -&gt; ConcreteSizeValue &lt;$&gt; setup_value_substitute_output_parameter val</span>
<span class="lineno">  476 </span><span class="spaces">                </span><span class="istickedoff">SymbolicSizeValue arr sz -&gt;</span>
<span class="lineno">  477 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">SymbolicSizeValue &lt;$&gt; substitute_output_parameters arr &lt;*&gt; substitute_output_parameters sz</span></span>
<span class="lineno">  478 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  479 </span><span class="spaces">          </span><span class="istickedoff">extracted_ret_value &lt;- liftIO $ mapM</span>
<span class="lineno">  480 </span><span class="spaces">            </span><span class="istickedoff">setup_value_substitute_output_parameter</span>
<span class="lineno">  481 </span><span class="spaces">            </span><span class="istickedoff">(method_spec ^. MS.csRetValue)</span>
<span class="lineno">  482 </span><span class="spaces">          </span><span class="istickedoff">extracted_post_state_points_tos &lt;- liftIO $ mapM</span>
<span class="lineno">  483 </span><span class="spaces">            </span><span class="istickedoff">(\case</span>
<span class="lineno">  484 </span><span class="spaces">              </span><span class="istickedoff">LLVMPointsTo x y z value -&gt;</span>
<span class="lineno">  485 </span><span class="spaces">                </span><span class="istickedoff">LLVMPointsTo <span class="nottickedoff">x</span> y z &lt;$&gt; llvm_points_to_value_substitute_output_parameter value</span>
<span class="lineno">  486 </span><span class="spaces">              </span><span class="istickedoff">LLVMPointsToBitfield x y z value -&gt;</span>
<span class="lineno">  487 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">LLVMPointsToBitfield x y z &lt;$&gt; setup_value_substitute_output_parameter value</span>)</span>
<span class="lineno">  488 </span><span class="spaces">            </span><span class="istickedoff">(method_spec ^. MS.csPostState ^. MS.csPointsTos)</span>
<span class="lineno">  489 </span><span class="spaces">          </span><span class="istickedoff">let extracted_method_spec = method_spec &amp;</span>
<span class="lineno">  490 </span><span class="spaces">                </span><span class="istickedoff">MS.csRetValue .~ extracted_ret_value &amp;</span>
<span class="lineno">  491 </span><span class="spaces">                </span><span class="istickedoff">MS.csPostState . MS.csPointsTos .~ extracted_post_state_points_tos</span>
<span class="lineno">  492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  493 </span><span class="spaces">          </span><span class="istickedoff">-- XXX could have a real position...</span>
<span class="lineno">  494 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">pos = PosInternal &quot;llvm_compositional_extract&quot;</span></span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="istickedoff">let func_name' = Text.pack func_name</span>
<span class="lineno">  496 </span><span class="spaces">          </span><span class="istickedoff">typed_extracted_func_const &lt;- io $ mkTypedTerm shared_context extracted_func_const</span>
<span class="lineno">  497 </span><span class="spaces">          </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  498 </span><span class="spaces">          </span><span class="istickedoff">rw' &lt;-</span>
<span class="lineno">  499 </span><span class="spaces">            </span><span class="istickedoff">liftIO $</span>
<span class="lineno">  500 </span><span class="spaces">            </span><span class="istickedoff">extendEnv <span class="nottickedoff">shared_context</span></span>
<span class="lineno">  501 </span><span class="spaces">              </span><span class="istickedoff">(Located func_name' func_name' <span class="nottickedoff">pos</span>)</span>
<span class="lineno">  502 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(tMono $ tTerm pos)</span></span>
<span class="lineno">  503 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">Nothing</span>             -- FUTURE: slot for doc string, could put something here</span>
<span class="lineno">  504 </span><span class="spaces">              </span><span class="istickedoff">(VTerm typed_extracted_func_const)</span>
<span class="lineno">  505 </span><span class="spaces">              </span><span class="istickedoff">rw</span>
<span class="lineno">  506 </span><span class="spaces">          </span><span class="istickedoff">putTopLevelRW rw'</span>
<span class="lineno">  507 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  508 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">lemmaSet = Set.fromList (map (view MS.psSpecIdent) lemmas')</span></span>
<span class="lineno">  509 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  510 </span><span class="spaces">          </span><span class="istickedoff">end &lt;- io getCurrentTime</span>
<span class="lineno">  511 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">diff = diffUTCTime end start</span></span>
<span class="lineno">  512 </span><span class="spaces">          </span><span class="istickedoff">ps &lt;- io (MS.mkProvedSpec <span class="nottickedoff">MS.SpecProved</span> extracted_method_spec <span class="nottickedoff">stats</span> <span class="nottickedoff">vcs</span> <span class="nottickedoff">lemmaSet</span> <span class="nottickedoff">diff</span>)</span>
<span class="lineno">  513 </span><span class="spaces">          </span><span class="istickedoff">returnProof (SomeLLVM ps)</span></span>
<span class="lineno">  514 </span>
<span class="lineno">  515 </span>setupValueAsExtCns :: SetupValue (LLVM arch) -&gt; Maybe (ExtCns Term)
<span class="lineno">  516 </span><span class="decl"><span class="istickedoff">setupValueAsExtCns =</span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="istickedoff">\case</span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="istickedoff">SetupTerm term -&gt; asExtCns $ ttTerm term</span>
<span class="lineno">  519 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>llvmPointsToValueAsExtCns :: LLVMPointsToValue arch -&gt; Maybe (ExtCns Term)
<span class="lineno">  522 </span><span class="decl"><span class="istickedoff">llvmPointsToValueAsExtCns =</span>
<span class="lineno">  523 </span><span class="spaces">  </span><span class="istickedoff">\case</span>
<span class="lineno">  524 </span><span class="spaces">    </span><span class="istickedoff">ConcreteSizeValue val -&gt; setupValueAsExtCns val</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="istickedoff">SymbolicSizeValue arr _sz -&gt; <span class="nottickedoff">asExtCns $ ttTerm arr</span></span></span>
<span class="lineno">  526 </span>
<span class="lineno">  527 </span>-- | Check that all the overrides/lemmas were actually from this module
<span class="lineno">  528 </span>checkModuleCompatibility ::
<span class="lineno">  529 </span>  LLVMModule arch -&gt;
<span class="lineno">  530 </span>  [SomeLLVM MS.ProvedSpec] -&gt;
<span class="lineno">  531 </span>  TopLevel [MS.ProvedSpec (LLVM arch)]
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">checkModuleCompatibility llvmModule = foldM step []</span>
<span class="lineno">  533 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff">step accum (SomeLLVM lemma) =</span>
<span class="lineno">  535 </span><span class="spaces">      </span><span class="istickedoff">case testEquality (lemma ^. MS.psSpec.MS.csCodebase) llvmModule of</span>
<span class="lineno">  536 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwTopLevel $ unlines</span></span>
<span class="lineno">  537 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Failed to apply an override that was verified against a&quot;</span></span>
<span class="lineno">  538 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;different LLVM module&quot;</span></span>
<span class="lineno">  539 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  540 </span><span class="spaces">        </span><span class="istickedoff">Just Refl -&gt; pure (lemma:accum)</span></span>
<span class="lineno">  541 </span>
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>-- -- | The real work of 'llvm_verify' and 'llvm_unsafe_assume_spec'.
<span class="lineno">  544 </span>withMethodSpec ::
<span class="lineno">  545 </span>  Bool {- ^ path sat -} -&gt;
<span class="lineno">  546 </span>  LLVMModule arch -&gt;
<span class="lineno">  547 </span>  String            {- ^ Name of the function -} -&gt;
<span class="lineno">  548 </span>  LLVMCrucibleSetupM () {- ^ Boundary specification -} -&gt;
<span class="lineno">  549 </span>  (( ?lc :: Crucible.TypeContext
<span class="lineno">  550 </span>   , ?memOpts::Crucible.MemOptions
<span class="lineno">  551 </span>   , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  552 </span>   , ?checkAllocSymInit :: Bool
<span class="lineno">  553 </span>   , ?singleOverrideSpecialCase :: Bool
<span class="lineno">  554 </span>   , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  555 </span>   , Crucible.HasLLVMAnn Sym
<span class="lineno">  556 </span>   ) =&gt;
<span class="lineno">  557 </span>     LLVMCrucibleContext arch -&gt;
<span class="lineno">  558 </span>     MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  559 </span>     TopLevel a) -&gt;
<span class="lineno">  560 </span>  TopLevel a
<span class="lineno">  561 </span><span class="decl"><span class="istickedoff">withMethodSpec pathSat lm nm setup action =</span>
<span class="lineno">  562 </span><span class="spaces">  </span><span class="istickedoff">do (nm', parent) &lt;- resolveSpecName nm</span>
<span class="lineno">  563 </span><span class="spaces">     </span><span class="istickedoff">let edef = findDefMaybeStatic (modAST lm) nm'</span>
<span class="lineno">  564 </span><span class="spaces">     </span><span class="istickedoff">let edecl = findDecl (modAST lm) nm'</span>
<span class="lineno">  565 </span><span class="spaces">     </span><span class="istickedoff">let mtrans = modTrans lm</span>
<span class="lineno">  566 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  567 </span><span class="spaces">     </span><span class="istickedoff">defOrDecls &lt;-</span>
<span class="lineno">  568 </span><span class="spaces">       </span><span class="istickedoff">case (edef, edecl) of</span>
<span class="lineno">  569 </span><span class="spaces">         </span><span class="istickedoff">(Right defs, _) -&gt; return (NE.map Left defs)</span>
<span class="lineno">  570 </span><span class="spaces">         </span><span class="istickedoff">(_, Right decl) -&gt; return (Right decl NE.:| [])</span>
<span class="lineno">  571 </span><span class="spaces">         </span><span class="istickedoff">(Left err, Left _) -&gt; throwTopLevel (displayVerifExceptionOpts opts err)</span>
<span class="lineno">  572 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  573 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = <span class="nottickedoff">mtrans ^. Crucible.transContext . Crucible.llvmTypeCtx</span></span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  575 </span><span class="spaces">     </span><span class="istickedoff">sosp &lt;- rwSingleOverrideSpecialCase &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  576 </span><span class="spaces">     </span><span class="istickedoff">let ?singleOverrideSpecialCase = sosp</span>
<span class="lineno">  577 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  578 </span><span class="spaces">     </span><span class="istickedoff">Crucible.llvmPtrWidth (mtrans ^. Crucible.transContext) $ \_ -&gt;</span>
<span class="lineno">  579 </span><span class="spaces">       </span><span class="istickedoff">fmap NE.head $ forM defOrDecls $ \defOrDecl -&gt;</span>
<span class="lineno">  580 </span><span class="spaces">         </span><span class="istickedoff">setupLLVMCrucibleContext pathSat lm $ \cc -&gt;</span>
<span class="lineno">  581 </span><span class="spaces">           </span><span class="istickedoff">do let sym = cc^.ccSym</span>
<span class="lineno">  582 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  583 </span><span class="spaces">              </span><span class="istickedoff">pos &lt;- getPosition</span>
<span class="lineno">  584 </span><span class="spaces">              </span><span class="istickedoff">let setupLoc = toW4Loc &quot;_SAW_LLVM_withMethodSpec&quot; pos</span>
<span class="lineno">  585 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  586 </span><span class="spaces">              </span><span class="istickedoff">let est0 =</span>
<span class="lineno">  587 </span><span class="spaces">                    </span><span class="istickedoff">case defOrDecl of</span>
<span class="lineno">  588 </span><span class="spaces">                      </span><span class="istickedoff">Left def -&gt; initialCrucibleSetupState cc def setupLoc parent</span>
<span class="lineno">  589 </span><span class="spaces">                      </span><span class="istickedoff">Right decl -&gt; initialCrucibleSetupStateDecl cc decl setupLoc parent</span>
<span class="lineno">  590 </span><span class="spaces">              </span><span class="istickedoff">st0 &lt;- either <span class="nottickedoff">(throwTopLevel . show . ppSetupError)</span> return est0</span>
<span class="lineno">  591 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  592 </span><span class="spaces">              </span><span class="istickedoff">-- execute commands of the method spec</span>
<span class="lineno">  593 </span><span class="spaces">              </span><span class="istickedoff">io $ W4.setCurrentProgramLoc sym <span class="nottickedoff">setupLoc</span></span>
<span class="lineno">  594 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  595 </span><span class="spaces">              </span><span class="istickedoff">methodSpec &lt;-</span>
<span class="lineno">  596 </span><span class="spaces">                </span><span class="istickedoff">view Setup.csMethodSpec &lt;$&gt;</span>
<span class="lineno">  597 </span><span class="spaces">                </span><span class="istickedoff">(execStateT</span>
<span class="lineno">  598 </span><span class="spaces">                   </span><span class="istickedoff">(runReaderT (runLLVMCrucibleSetupM setup)</span>
<span class="lineno">  599 </span><span class="spaces">                               </span><span class="istickedoff">(Setup.makeCrucibleSetupRO))</span>
<span class="lineno">  600 </span><span class="spaces">                     </span><span class="istickedoff">st0)</span>
<span class="lineno">  601 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  602 </span><span class="spaces">              </span><span class="istickedoff">io $ checkSpecArgumentTypes cc methodSpec</span>
<span class="lineno">  603 </span><span class="spaces">              </span><span class="istickedoff">io $ checkSpecReturnType <span class="nottickedoff">cc</span> methodSpec</span>
<span class="lineno">  604 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  605 </span><span class="spaces">              </span><span class="istickedoff">action cc methodSpec</span></span>
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>verifyMethodSpec ::
<span class="lineno">  608 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  609 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  610 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  611 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  612 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno">  613 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  614 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  615 </span>  ) =&gt;
<span class="lineno">  616 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  617 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  618 </span>  [MS.ProvedSpec (LLVM arch)] -&gt;
<span class="lineno">  619 </span>  Bool -&gt;
<span class="lineno">  620 </span>  ProofScript () -&gt;
<span class="lineno">  621 </span>  Maybe (IORef (Map Text.Text [Crucible.FunctionProfile])) -&gt;
<span class="lineno">  622 </span>  TopLevel (SolverStats, [MS.VCStats], OverrideState (LLVM arch))
<span class="lineno">  623 </span><span class="decl"><span class="istickedoff">verifyMethodSpec cc methodSpec lemmas checkSat tactic asp =</span>
<span class="lineno">  624 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="istickedoff">do printOutLnTop Info $</span>
<span class="lineno">  626 </span><span class="spaces">       </span><span class="istickedoff">unwords [&quot;Verifying&quot;, (methodSpec ^. csName) , &quot;...&quot;]</span>
<span class="lineno">  627 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  628 </span><span class="spaces">     </span><span class="istickedoff">let sym = cc^.ccSym</span>
<span class="lineno">  629 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  630 </span><span class="spaces">     </span><span class="istickedoff">profFile &lt;- rwProfilingFile &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  631 </span><span class="spaces">     </span><span class="istickedoff">(writeFinalProfile, pfs) &lt;- io $ Common.setupProfiling sym &quot;llvm_verify&quot; profFile</span>
<span class="lineno">  632 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  633 </span><span class="spaces">     </span><span class="istickedoff">-- set up the metadata map for tracking proof obligation metadata</span>
<span class="lineno">  634 </span><span class="spaces">     </span><span class="istickedoff">mdMap &lt;- io $ newIORef mempty</span>
<span class="lineno">  635 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  636 </span><span class="spaces">     </span><span class="istickedoff">-- set up the LLVM memory with a pristine heap</span>
<span class="lineno">  637 </span><span class="spaces">     </span><span class="istickedoff">let globals = cc^.ccLLVMGlobals</span>
<span class="lineno">  638 </span><span class="spaces">     </span><span class="istickedoff">let mvar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno">  639 </span><span class="spaces">     </span><span class="istickedoff">let mem0 = lookupMemGlobal mvar globals</span>
<span class="lineno">  640 </span><span class="spaces">     </span><span class="istickedoff">-- push a memory stack frame if starting from a breakpoint</span>
<span class="lineno">  641 </span><span class="spaces">     </span><span class="istickedoff">let mem = case methodSpec^.csParentName of</span>
<span class="lineno">  642 </span><span class="spaces">               </span><span class="istickedoff">Just parent -&gt; mem0</span>
<span class="lineno">  643 </span><span class="spaces">                 </span><span class="istickedoff">{ Crucible.memImplHeap = Crucible.pushStackFrameMem</span>
<span class="lineno">  644 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">(Text.pack $ mconcat [methodSpec ^. csName, &quot;#&quot;, parent])</span></span>
<span class="lineno">  645 </span><span class="spaces">                   </span><span class="istickedoff">(Crucible.memImplHeap mem0)</span>
<span class="lineno">  646 </span><span class="spaces">                 </span><span class="istickedoff">}</span>
<span class="lineno">  647 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; mem0</span>
<span class="lineno">  648 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  649 </span><span class="spaces">     </span><span class="istickedoff">let globals1 = Crucible.llvmGlobals mvar mem</span>
<span class="lineno">  650 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  651 </span><span class="spaces">     </span><span class="istickedoff">-- construct the initial state for verifications</span>
<span class="lineno">  652 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  653 </span><span class="spaces">     </span><span class="istickedoff">(args, assumes, env, globals2) &lt;-</span>
<span class="lineno">  654 </span><span class="spaces">       </span><span class="istickedoff">io $ verifyPrestate <span class="nottickedoff">opts</span> cc methodSpec globals1</span>
<span class="lineno">  655 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  656 </span><span class="spaces">     </span><span class="istickedoff">when (detectVacuity opts)</span>
<span class="lineno">  657 </span><span class="spaces">       </span><span class="istickedoff">$ Vacuity.checkAssumptionsForContradictions sym <span class="nottickedoff">methodSpec</span> tactic assumes</span>
<span class="lineno">  658 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  659 </span><span class="spaces">     </span><span class="istickedoff">-- save initial path conditions</span>
<span class="lineno">  660 </span><span class="spaces">     </span><span class="istickedoff">frameIdent &lt;- io $ Crucible.pushAssumptionFrame bak</span>
<span class="lineno">  661 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  662 </span><span class="spaces">     </span><span class="istickedoff">-- run the symbolic execution</span>
<span class="lineno">  663 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info $</span>
<span class="lineno">  664 </span><span class="spaces">       </span><span class="istickedoff">unwords [&quot;Simulating&quot;, (methodSpec ^. csName) , &quot;...&quot;]</span>
<span class="lineno">  665 </span><span class="spaces">     </span><span class="istickedoff">top_loc &lt;- toW4Loc &quot;llvm_verify&quot; &lt;$&gt; getPosition</span>
<span class="lineno">  666 </span><span class="spaces">     </span><span class="istickedoff">(ret, globals3, invSubst) &lt;-</span>
<span class="lineno">  667 </span><span class="spaces">       </span><span class="istickedoff">verifySimulate opts cc pfs methodSpec args assumes top_loc lemmas globals2 checkSat asp <span class="nottickedoff">mdMap</span></span>
<span class="lineno">  668 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  669 </span><span class="spaces">     </span><span class="istickedoff">-- collect the proof obligations</span>
<span class="lineno">  670 </span><span class="spaces">     </span><span class="istickedoff">(asserts, post_override_state) &lt;-</span>
<span class="lineno">  671 </span><span class="spaces">       </span><span class="istickedoff">verifyPoststate cc</span>
<span class="lineno">  672 </span><span class="spaces">       </span><span class="istickedoff">methodSpec env globals3 ret</span>
<span class="lineno">  673 </span><span class="spaces">       </span><span class="istickedoff">mdMap</span>
<span class="lineno">  674 </span><span class="spaces">       </span><span class="istickedoff">invSubst</span>
<span class="lineno">  675 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  676 </span><span class="spaces">     </span><span class="istickedoff">-- restore previous assumption state</span>
<span class="lineno">  677 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- io $ Crucible.popAssumptionFrame bak frameIdent</span>
<span class="lineno">  678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  679 </span><span class="spaces">     </span><span class="istickedoff">-- attempt to verify the proof obligations</span>
<span class="lineno">  680 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info $</span>
<span class="lineno">  681 </span><span class="spaces">       </span><span class="istickedoff">unwords [&quot;Checking proof obligations&quot;, (methodSpec ^. csName), &quot;...&quot;]</span>
<span class="lineno">  682 </span><span class="spaces">     </span><span class="istickedoff">(stats, vcstats) &lt;- verifyObligations cc methodSpec tactic assumes asserts</span>
<span class="lineno">  683 </span><span class="spaces">     </span><span class="istickedoff">io $ writeFinalProfile</span>
<span class="lineno">  684 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  685 </span><span class="spaces">     </span><span class="istickedoff">return ( <span class="nottickedoff">stats</span></span>
<span class="lineno">  686 </span><span class="spaces">            </span><span class="istickedoff">, <span class="nottickedoff">vcstats</span></span>
<span class="lineno">  687 </span><span class="spaces">            </span><span class="istickedoff">, post_override_state</span>
<span class="lineno">  688 </span><span class="spaces">            </span><span class="istickedoff">)</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>
<span class="lineno">  692 </span>
<span class="lineno">  693 </span>refineMethodSpec ::
<span class="lineno">  694 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno">  695 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno">  696 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  697 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno">  698 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno">  699 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  700 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  701 </span>  ) =&gt;
<span class="lineno">  702 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  703 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  704 </span>  [MS.ProvedSpec (LLVM arch)] -&gt;
<span class="lineno">  705 </span>  ProofScript () -&gt;
<span class="lineno">  706 </span>  TopLevel (SolverStats, [MS.VCStats])
<span class="lineno">  707 </span><span class="decl"><span class="istickedoff">refineMethodSpec cc methodSpec lemmas tactic =</span>
<span class="lineno">  708 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno">  709 </span><span class="spaces">  </span><span class="istickedoff">do let <span class="nottickedoff">sym = cc^.ccSym</span></span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  711 </span><span class="spaces">     </span><span class="istickedoff">let fnm = methodSpec ^. MS.csMethod</span>
<span class="lineno">  712 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  713 </span><span class="spaces">     </span><span class="istickedoff">let isRelevant lemma_spec =</span>
<span class="lineno">  714 </span><span class="spaces">           </span><span class="istickedoff">lemma_spec ^. MS.csMethod == fnm</span>
<span class="lineno">  715 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  716 </span><span class="spaces">     </span><span class="istickedoff">let (relevantLemmas, irrelevantLemmas) =</span>
<span class="lineno">  717 </span><span class="spaces">           </span><span class="istickedoff">partition isRelevant (map (view MS.psSpec) lemmas)</span>
<span class="lineno">  718 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  719 </span><span class="spaces">     </span><span class="istickedoff">relevantLemmas' &lt;-</span>
<span class="lineno">  720 </span><span class="spaces">        </span><span class="istickedoff">case relevantLemmas of</span>
<span class="lineno">  721 </span><span class="spaces">          </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">fail $ unlines $</span></span>
<span class="lineno">  722 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[ &quot;No relevant overrides included in specification refinement for &quot; ++ show (pretty fnm) ] ++</span></span>
<span class="lineno">  723 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">(if null irrelevantLemmas then [] else [ &quot;Overrides provided for irrelevant methods:&quot; ]) ++</span></span>
<span class="lineno">  724 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[ &quot; *  &quot; ++ show (pretty nm)</span></span>
<span class="lineno">  725 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">| nm &lt;- nubOrd $ map (view MS.csMethod) $ irrelevantLemmas</span></span>
<span class="lineno">  726 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  727 </span><span class="spaces">          </span><span class="istickedoff">(x:xs) -&gt; return (x NE.:| xs)</span>
<span class="lineno">  728 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  729 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info $</span>
<span class="lineno">  730 </span><span class="spaces">       </span><span class="istickedoff">unwords [&quot;Refining specification for&quot;, (methodSpec ^. csName) , &quot;...&quot;]</span>
<span class="lineno">  731 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  732 </span><span class="spaces">     </span><span class="istickedoff">unless (null irrelevantLemmas) $</span>
<span class="lineno">  733 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">printOutLnTop Warn $ unlines $</span></span>
<span class="lineno">  734 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Irrelevant overrides included in specification refinement for &quot; ++ show (pretty fnm) ] ++</span></span>
<span class="lineno">  735 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot; *  &quot; ++ show (pretty nm)</span></span>
<span class="lineno">  736 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">| nm &lt;- nubOrd $ map (view MS.csMethod) $ irrelevantLemmas</span></span>
<span class="lineno">  737 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  738 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  739 </span><span class="spaces">     </span><span class="istickedoff">profFile &lt;- rwProfilingFile &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  740 </span><span class="spaces">     </span><span class="istickedoff">(writeFinalProfile, pfs) &lt;- io $ Common.setupProfiling <span class="nottickedoff">sym</span> <span class="nottickedoff">&quot;llvm_refine_spec&quot;</span> profFile</span>
<span class="lineno">  741 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  742 </span><span class="spaces">     </span><span class="istickedoff">-- set up the metadata map for tracking proof obligation metadata</span>
<span class="lineno">  743 </span><span class="spaces">     </span><span class="istickedoff">mdMap &lt;- io $ newIORef <span class="nottickedoff">mempty</span></span>
<span class="lineno">  744 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  745 </span><span class="spaces">     </span><span class="istickedoff">-- set up the LLVM memory with a pristine heap</span>
<span class="lineno">  746 </span><span class="spaces">     </span><span class="istickedoff">let globals = cc^.ccLLVMGlobals</span>
<span class="lineno">  747 </span><span class="spaces">     </span><span class="istickedoff">let mvar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno">  748 </span><span class="spaces">     </span><span class="istickedoff">let mem = lookupMemGlobal mvar globals</span>
<span class="lineno">  749 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  750 </span><span class="spaces">     </span><span class="istickedoff">let globals1 = Crucible.llvmGlobals mvar mem</span>
<span class="lineno">  751 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  752 </span><span class="spaces">     </span><span class="istickedoff">-- construct the initial state for verifications</span>
<span class="lineno">  753 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  754 </span><span class="spaces">     </span><span class="istickedoff">(args, assumes, env, globals2) &lt;-</span>
<span class="lineno">  755 </span><span class="spaces">       </span><span class="istickedoff">io $ verifyPrestate <span class="nottickedoff">opts</span> cc methodSpec globals1</span>
<span class="lineno">  756 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  757 </span><span class="spaces">     </span><span class="istickedoff">when (detectVacuity opts)</span>
<span class="lineno">  758 </span><span class="spaces">       </span><span class="istickedoff">$ <span class="nottickedoff">Vacuity.checkAssumptionsForContradictions sym methodSpec tactic assumes</span></span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  760 </span><span class="spaces">     </span><span class="istickedoff">-- save initial path conditions</span>
<span class="lineno">  761 </span><span class="spaces">     </span><span class="istickedoff">frameIdent &lt;- io $ Crucible.pushAssumptionFrame bak</span>
<span class="lineno">  762 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  763 </span><span class="spaces">     </span><span class="istickedoff">-- run the symbolic execution</span>
<span class="lineno">  764 </span><span class="spaces">     </span><span class="istickedoff">top_loc &lt;- toW4Loc &quot;llvm_refine_spec&quot; &lt;$&gt; getPosition</span>
<span class="lineno">  765 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  766 </span><span class="spaces">     </span><span class="istickedoff">(ret, globals3) &lt;-</span>
<span class="lineno">  767 </span><span class="spaces">       </span><span class="istickedoff">io $ refineSimulate opts cc pfs methodSpec args assumes <span class="nottickedoff">top_loc</span> relevantLemmas' globals2 <span class="nottickedoff">mdMap</span></span>
<span class="lineno">  768 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  769 </span><span class="spaces">     </span><span class="istickedoff">-- collect the proof obligations</span>
<span class="lineno">  770 </span><span class="spaces">     </span><span class="istickedoff">(asserts, _post_override_state) &lt;-</span>
<span class="lineno">  771 </span><span class="spaces">       </span><span class="istickedoff">verifyPoststate cc</span>
<span class="lineno">  772 </span><span class="spaces">       </span><span class="istickedoff">methodSpec <span class="nottickedoff">env</span> globals3 ret</span>
<span class="lineno">  773 </span><span class="spaces">       </span><span class="istickedoff">mdMap</span>
<span class="lineno">  774 </span><span class="spaces">       </span><span class="istickedoff">MapF.empty</span>
<span class="lineno">  775 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  776 </span><span class="spaces">     </span><span class="istickedoff">-- restore previous assumption state</span>
<span class="lineno">  777 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- io $ Crucible.popAssumptionFrame bak frameIdent</span>
<span class="lineno">  778 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  779 </span><span class="spaces">     </span><span class="istickedoff">-- attempt to verify the proof obligations</span>
<span class="lineno">  780 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info $</span>
<span class="lineno">  781 </span><span class="spaces">       </span><span class="istickedoff">unwords [&quot;Checking proof obligations&quot;, (methodSpec ^. csName), &quot;...&quot;]</span>
<span class="lineno">  782 </span><span class="spaces">     </span><span class="istickedoff">(stats, vcstats) &lt;- verifyObligations cc methodSpec tactic assumes asserts</span>
<span class="lineno">  783 </span><span class="spaces">     </span><span class="istickedoff">io $ writeFinalProfile</span>
<span class="lineno">  784 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  785 </span><span class="spaces">     </span><span class="istickedoff">return ( <span class="nottickedoff">stats</span></span>
<span class="lineno">  786 </span><span class="spaces">            </span><span class="istickedoff">, <span class="nottickedoff">vcstats</span></span>
<span class="lineno">  787 </span><span class="spaces">            </span><span class="istickedoff">)</span></span>
<span class="lineno">  788 </span>
<span class="lineno">  789 </span>
<span class="lineno">  790 </span>verifyObligations :: LLVMCrucibleContext arch
<span class="lineno">  791 </span>                  -&gt; MS.CrucibleMethodSpecIR (LLVM arch)
<span class="lineno">  792 </span>                  -&gt; ProofScript ()
<span class="lineno">  793 </span>                  -&gt; [Crucible.LabeledPred Term AssumptionReason]
<span class="lineno">  794 </span>                  -&gt; [(String, MS.ConditionMetadata, Term)]
<span class="lineno">  795 </span>                  -&gt; TopLevel (SolverStats, [MS.VCStats])
<span class="lineno">  796 </span><span class="decl"><span class="istickedoff">verifyObligations cc mspec tactic assumes asserts =</span>
<span class="lineno">  797 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.ccSym</span>
<span class="lineno">  798 </span><span class="spaces">     </span><span class="istickedoff">st     &lt;- io $ Common.sawCoreState sym</span>
<span class="lineno">  799 </span><span class="spaces">     </span><span class="istickedoff">let sc  = saw_ctx st</span>
<span class="lineno">  800 </span><span class="spaces">     </span><span class="istickedoff">useSequentGoals &lt;- rwSequentGoals &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  801 </span><span class="spaces">     </span><span class="istickedoff">let assumeTerms = toListOf (folded . Crucible.labeledPred) assumes</span>
<span class="lineno">  802 </span><span class="spaces">     </span><span class="istickedoff">assume &lt;- io $ scAndList sc assumeTerms</span>
<span class="lineno">  803 </span><span class="spaces">     </span><span class="istickedoff">let nm  = mspec ^. csName</span>
<span class="lineno">  804 </span><span class="spaces">     </span><span class="istickedoff">outs &lt;-</span>
<span class="lineno">  805 </span><span class="spaces">       </span><span class="istickedoff">forM (zip [(0::Int)..] asserts) $ \(n, (msg, md, assert)) -&gt;</span>
<span class="lineno">  806 </span><span class="spaces">       </span><span class="istickedoff">do goal  &lt;- io $ scImplies sc assume assert</span>
<span class="lineno">  807 </span><span class="spaces">          </span><span class="istickedoff">goal' &lt;- io $ boolToProp sc [] goal</span>
<span class="lineno">  808 </span><span class="spaces">          </span><span class="istickedoff">sqt &lt;- if <span class="tickonlyfalse">useSequentGoals</span> then</span>
<span class="lineno">  809 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">io $ booleansToSequent sc assumeTerms [assert]</span></span>
<span class="lineno">  810 </span><span class="spaces">                 </span><span class="istickedoff">else</span>
<span class="lineno">  811 </span><span class="spaces">                    </span><span class="istickedoff">return (propToSequent goal')</span>
<span class="lineno">  812 </span><span class="spaces">          </span><span class="istickedoff">let ploc = MS.conditionLoc md</span>
<span class="lineno">  813 </span><span class="spaces">          </span><span class="istickedoff">let gloc = (unwords [show (W4.plSourceLoc ploc)</span>
<span class="lineno">  814 </span><span class="spaces">                             </span><span class="istickedoff">,&quot;in&quot;</span>
<span class="lineno">  815 </span><span class="spaces">                             </span><span class="istickedoff">, show (W4.plFunction ploc)]) ++</span>
<span class="lineno">  816 </span><span class="spaces">                     </span><span class="istickedoff">(if <span class="tickonlytrue">null (MS.conditionContext md)</span> then [] else</span>
<span class="lineno">  817 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;\n&quot; ++ MS.conditionContext md</span>)</span>
<span class="lineno">  818 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">goalname = concat [nm, &quot; (&quot;, takeWhile (/= '\n') msg, &quot;)&quot;]</span></span>
<span class="lineno">  819 </span><span class="spaces">              </span><span class="istickedoff">proofgoal = ProofGoal</span>
<span class="lineno">  820 </span><span class="spaces">                          </span><span class="istickedoff">{ goalNum  = n</span>
<span class="lineno">  821 </span><span class="spaces">                          </span><span class="istickedoff">, goalType = MS.conditionType md</span>
<span class="lineno">  822 </span><span class="spaces">                          </span><span class="istickedoff">, goalName = nm</span>
<span class="lineno">  823 </span><span class="spaces">                          </span><span class="istickedoff">, goalLoc  = gloc</span>
<span class="lineno">  824 </span><span class="spaces">                          </span><span class="istickedoff">, goalDesc = msg</span>
<span class="lineno">  825 </span><span class="spaces">                          </span><span class="istickedoff">, goalSequent = sqt</span>
<span class="lineno">  826 </span><span class="spaces">                          </span><span class="istickedoff">, goalTags = MS.conditionTags md</span>
<span class="lineno">  827 </span><span class="spaces">                          </span><span class="istickedoff">}</span>
<span class="lineno">  828 </span><span class="spaces">          </span><span class="istickedoff">res &lt;- runProofScript tactic goal' proofgoal <span class="nottickedoff">(Just ploc)</span></span>
<span class="lineno">  829 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">(Text.unwords</span></span>
<span class="lineno">  830 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">[&quot;LLVM verification condition&quot;, Text.pack (show n), Text.pack goalname])</span></span>
<span class="lineno">  831 </span><span class="spaces">                    </span><span class="istickedoff">False -- do not record this theorem in the database</span>
<span class="lineno">  832 </span><span class="spaces">                    </span><span class="istickedoff">useSequentGoals</span>
<span class="lineno">  833 </span><span class="spaces">          </span><span class="istickedoff">case res of</span>
<span class="lineno">  834 </span><span class="spaces">            </span><span class="istickedoff">ValidProof stats thm -&gt;</span>
<span class="lineno">  835 </span><span class="spaces">              </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, <span class="nottickedoff">MS.VCStats md stats (thmSummary thm) (thmNonce thm) (thmDepends thm) (thmElapsedTime thm)</span>)</span>
<span class="lineno">  836 </span><span class="spaces">            </span><span class="istickedoff">UnfinishedProof pst -&gt;</span>
<span class="lineno">  837 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">do printOutLnTop Info $ unwords [&quot;Subgoal failed:&quot;, nm, msg]</span></span>
<span class="lineno">  838 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">throwTopLevel $ &quot;Proof failed &quot; ++ show (length (psGoals pst)) ++ &quot; goals remaining.&quot;</span></span>
<span class="lineno">  839 </span><span class="spaces">            </span><span class="istickedoff">InvalidProof stats vals _pst -&gt;</span>
<span class="lineno">  840 </span><span class="spaces">              </span><span class="istickedoff">do printOutLnTop Info $ unwords [&quot;Subgoal failed:&quot;, nm, msg]</span>
<span class="lineno">  841 </span><span class="spaces">                 </span><span class="istickedoff">printOutLnTop Info (show stats)</span>
<span class="lineno">  842 </span><span class="spaces">                 </span><span class="istickedoff">printOutLnTop OnlyCounterExamples &quot;----------Counterexample----------&quot;</span>
<span class="lineno">  843 </span><span class="spaces">                 </span><span class="istickedoff">opts &lt;- rwPPOpts &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  844 </span><span class="spaces">                 </span><span class="istickedoff">if null vals then</span>
<span class="lineno">  845 </span><span class="spaces">                   </span><span class="istickedoff">printOutLnTop OnlyCounterExamples &quot;&lt;&lt;All settings of the symbolic variables constitute a counterexample&gt;&gt;&quot;</span>
<span class="lineno">  846 </span><span class="spaces">                 </span><span class="istickedoff">else</span>
<span class="lineno">  847 </span><span class="spaces">                   </span><span class="istickedoff">let showEC ec = Text.unpack (toShortName (ecName ec)) in</span>
<span class="lineno">  848 </span><span class="spaces">                   </span><span class="istickedoff">let showAssignment (ec, val) = &quot;  &quot; ++ showEC ec ++ &quot;: &quot; ++ show (ppFirstOrderValue opts val) in</span>
<span class="lineno">  849 </span><span class="spaces">                   </span><span class="istickedoff">mapM_ (printOutLnTop OnlyCounterExamples . showAssignment) vals</span>
<span class="lineno">  850 </span><span class="spaces">                 </span><span class="istickedoff">printOutLnTop OnlyCounterExamples &quot;----------------------------------&quot;</span>
<span class="lineno">  851 </span><span class="spaces">                 </span><span class="istickedoff">throwTopLevel &quot;Proof failed.&quot; -- Mirroring behavior of llvm_verify</span>
<span class="lineno">  852 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info $ unwords [&quot;Proof succeeded!&quot;, nm]</span>
<span class="lineno">  853 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  854 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">stats = mconcat (map fst outs)</span></span>
<span class="lineno">  855 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">vcstats = map snd outs</span></span>
<span class="lineno">  856 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, <span class="nottickedoff">vcstats</span>)</span></span>
<span class="lineno">  857 </span>
<span class="lineno">  858 </span>throwMethodSpec :: MS.CrucibleMethodSpecIR (LLVM arch) -&gt; String -&gt; IO a
<span class="lineno">  859 </span><span class="decl"><span class="nottickedoff">throwMethodSpec mspec msg = X.throw $ LLVMMethodSpecException (mspec ^. MS.csLoc) msg</span></span>
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>-- | Check that the specified arguments have the expected types.
<span class="lineno">  862 </span>--
<span class="lineno">  863 </span>-- The expected types are inferred from the LLVM module.
<span class="lineno">  864 </span>checkSpecArgumentTypes ::
<span class="lineno">  865 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno">  866 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  867 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  868 </span>  IO ()
<span class="lineno">  869 </span><span class="decl"><span class="istickedoff">checkSpecArgumentTypes cc mspec = mapM_ resolveArg [0..(nArgs-1)]</span>
<span class="lineno">  870 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  871 </span><span class="spaces">    </span><span class="istickedoff">nArgs = toInteger (length (mspec ^. MS.csArgs))</span>
<span class="lineno">  872 </span><span class="spaces">    </span><span class="istickedoff">tyenv = MS.csAllocations mspec</span>
<span class="lineno">  873 </span><span class="spaces">    </span><span class="istickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nm = mspec^.csName</span></span>
<span class="lineno">  875 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  876 </span><span class="spaces">    </span><span class="istickedoff">checkArgTy i mt mt' =</span>
<span class="lineno">  877 </span><span class="spaces">      </span><span class="istickedoff">do b &lt;- checkRegisterCompatibility mt mt'</span>
<span class="lineno">  878 </span><span class="spaces">         </span><span class="istickedoff">unless b $</span>
<span class="lineno">  879 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">throwMethodSpec mspec $ unlines</span></span>
<span class="lineno">  880 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type mismatch in argument &quot; ++ show i ++ &quot; when verifying &quot; ++ show nm</span></span>
<span class="lineno">  881 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;Argument is declared with type: &quot; ++ show mt</span></span>
<span class="lineno">  882 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;but provided argument has incompatible type: &quot; ++ show mt'</span></span>
<span class="lineno">  883 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: this may be because the signature of your &quot; ++</span></span>
<span class="lineno">  884 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">&quot;function changed during compilation. If using &quot; ++</span></span>
<span class="lineno">  885 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">&quot;Clang, check the signature in the disassembled &quot; ++</span></span>
<span class="lineno">  886 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">&quot;.ll file.&quot;</span></span>
<span class="lineno">  887 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  888 </span><span class="spaces">    </span><span class="istickedoff">resolveArg i =</span>
<span class="lineno">  889 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup i (mspec ^. MS.csArgBindings) of</span>
<span class="lineno">  890 </span><span class="spaces">        </span><span class="istickedoff">Just (mt, sv) -&gt; do</span>
<span class="lineno">  891 </span><span class="spaces">          </span><span class="istickedoff">mt' &lt;- exceptToFail (typeOfSetupValue cc tyenv nameEnv sv)</span>
<span class="lineno">  892 </span><span class="spaces">          </span><span class="istickedoff">checkArgTy <span class="nottickedoff">i</span> mt mt'</span>
<span class="lineno">  893 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwMethodSpec mspec $ unwords</span></span>
<span class="lineno">  894 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;Argument&quot;, show i, &quot;unspecified when verifying&quot;, show nm]</span></span></span>
<span class="lineno">  895 </span>
<span class="lineno">  896 </span>
<span class="lineno">  897 </span>-- | Check that the specified return value has the expected type.
<span class="lineno">  898 </span>--
<span class="lineno">  899 </span>-- The expected type is inferred from the LLVM module.
<span class="lineno">  900 </span>--
<span class="lineno">  901 </span>-- TODO: generalize, put in Setup.Builtins
<span class="lineno">  902 </span>checkSpecReturnType ::
<span class="lineno">  903 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno">  904 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  905 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  906 </span>  IO ()
<span class="lineno">  907 </span><span class="decl"><span class="istickedoff">checkSpecReturnType cc mspec =</span>
<span class="lineno">  908 </span><span class="spaces">  </span><span class="istickedoff">case (mspec ^. MS.csRetValue, mspec ^. MS.csRet) of</span>
<span class="lineno">  909 </span><span class="spaces">    </span><span class="istickedoff">(Just _, Nothing) -&gt;</span>
<span class="lineno">  910 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">throwMethodSpec mspec $ unlines</span></span>
<span class="lineno">  911 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return value specified, but function &quot; ++ mspec ^. csName ++</span></span>
<span class="lineno">  912 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">&quot; has void return type&quot;</span></span>
<span class="lineno">  913 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  914 </span><span class="spaces">    </span><span class="istickedoff">(Just sv, Just retTy) -&gt;</span>
<span class="lineno">  915 </span><span class="spaces">      </span><span class="istickedoff">do retTy' &lt;- exceptToFail $</span>
<span class="lineno">  916 </span><span class="spaces">           </span><span class="istickedoff">typeOfSetupValue <span class="nottickedoff">cc</span></span>
<span class="lineno">  917 </span><span class="spaces">             </span><span class="istickedoff">(MS.csAllocations mspec) -- map allocation indices to allocations</span>
<span class="lineno">  918 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(mspec ^. MS.csPreState . MS.csVarTypeNames)</span> -- map alloc indices to var names</span>
<span class="lineno">  919 </span><span class="spaces">             </span><span class="istickedoff">sv</span>
<span class="lineno">  920 </span><span class="spaces">         </span><span class="istickedoff">-- This check is too lax, see saw-script#443</span>
<span class="lineno">  921 </span><span class="spaces">         </span><span class="istickedoff">b &lt;- checkRegisterCompatibility retTy retTy'</span>
<span class="lineno">  922 </span><span class="spaces">         </span><span class="istickedoff">unless b $ <span class="nottickedoff">throwMethodSpec mspec $ unlines</span></span>
<span class="lineno">  923 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Incompatible types for return value when verifying &quot; ++ mspec^.csName</span></span>
<span class="lineno">  924 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected: &quot; ++ show retTy</span></span>
<span class="lineno">  925 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;but given value of type: &quot; ++ show retTy'</span></span>
<span class="lineno">  926 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="istickedoff">(Nothing, _) -&gt; return ()</span></span>
<span class="lineno">  928 </span>
<span class="lineno">  929 </span>-- | Evaluate the precondition part of a Crucible method spec:
<span class="lineno">  930 </span>--
<span class="lineno">  931 </span>-- * Allocate heap space for each 'llvm_alloc' statement.
<span class="lineno">  932 </span>--
<span class="lineno">  933 </span>-- * Record an equality precondition for each 'llvm_equal'
<span class="lineno">  934 </span>-- statement.
<span class="lineno">  935 </span>--
<span class="lineno">  936 </span>-- * Write to memory for each 'llvm_points_to' statement. (Writes
<span class="lineno">  937 </span>-- to already-initialized locations are transformed into equality
<span class="lineno">  938 </span>-- preconditions.)
<span class="lineno">  939 </span>--
<span class="lineno">  940 </span>-- * Evaluate the function arguments from the 'llvm_execute_func'
<span class="lineno">  941 </span>-- statement.
<span class="lineno">  942 </span>--
<span class="lineno">  943 </span>-- Returns a tuple of (arguments, preconditions, pointer values,
<span class="lineno">  944 </span>-- memory).
<span class="lineno">  945 </span>verifyPrestate ::
<span class="lineno">  946 </span>  ( ?memOpts :: Crucible.MemOptions
<span class="lineno">  947 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno">  948 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno">  949 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno">  950 </span>  ) =&gt;
<span class="lineno">  951 </span>  Options -&gt;
<span class="lineno">  952 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno">  953 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno">  954 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno">  955 </span>  IO ([(Crucible.MemType, LLVMVal)],
<span class="lineno">  956 </span>      [Crucible.LabeledPred Term AssumptionReason],
<span class="lineno">  957 </span>      Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch)),
<span class="lineno">  958 </span>      Crucible.SymGlobalState Sym)
<span class="lineno">  959 </span><span class="decl"><span class="istickedoff">verifyPrestate opts cc mspec globals =</span>
<span class="lineno">  960 </span><span class="spaces">  </span><span class="istickedoff">do let ?lc = <span class="nottickedoff">ccTypeCtx cc</span></span>
<span class="lineno">  961 </span><span class="spaces">     </span><span class="istickedoff">let sym = cc^.ccSym</span>
<span class="lineno">  962 </span><span class="spaces">     </span><span class="istickedoff">let prestateLoc = W4.mkProgramLoc &quot;_SAW_LLVM_verifyPrestate&quot; W4.InternalPos</span>
<span class="lineno">  963 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ W4.setCurrentProgramLoc sym prestateLoc</span>
<span class="lineno">  964 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  965 </span><span class="spaces">     </span><span class="istickedoff">let lvar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno">  966 </span><span class="spaces">     </span><span class="istickedoff">let mem = lookupMemGlobal lvar globals</span>
<span class="lineno">  967 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  968 </span><span class="spaces">     </span><span class="istickedoff">-- Allocate LLVM memory for each 'llvm_alloc'</span>
<span class="lineno">  969 </span><span class="spaces">     </span><span class="istickedoff">(env, mem') &lt;- runStateT</span>
<span class="lineno">  970 </span><span class="spaces">       </span><span class="istickedoff">(Map.traverseWithKey (doAlloc cc) (mspec ^. MS.csPreState . MS.csAllocs))</span>
<span class="lineno">  971 </span><span class="spaces">       </span><span class="istickedoff">mem</span>
<span class="lineno">  972 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  973 </span><span class="spaces">     </span><span class="istickedoff">mem'' &lt;- setupGlobalAllocs cc mspec mem'</span>
<span class="lineno">  974 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  975 </span><span class="spaces">     </span><span class="istickedoff">mem''' &lt;- setupPrePointsTos mspec <span class="nottickedoff">opts</span> cc env (mspec ^. MS.csPreState . MS.csPointsTos) mem''</span>
<span class="lineno">  976 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  977 </span><span class="spaces">     </span><span class="istickedoff">let globals1 = Crucible.insertGlobal lvar mem''' globals</span>
<span class="lineno">  978 </span><span class="spaces">     </span><span class="istickedoff">(globals2,cs) &lt;-</span>
<span class="lineno">  979 </span><span class="spaces">       </span><span class="istickedoff">setupPrestateConditions <span class="nottickedoff">mspec</span> cc <span class="nottickedoff">mem'''</span> <span class="nottickedoff">env</span> globals1 (mspec ^. MS.csPreState . MS.csConditions)</span>
<span class="lineno">  980 </span><span class="spaces">     </span><span class="istickedoff">args &lt;- resolveArguments cc <span class="nottickedoff">mem'''</span> mspec env</span>
<span class="lineno">  981 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  982 </span><span class="spaces">     </span><span class="istickedoff">return (args, cs, env, globals2)</span></span>
<span class="lineno">  983 </span>
<span class="lineno">  984 </span>-- | Check two MemTypes for register compatiblity.  This is a stricter
<span class="lineno">  985 </span>--   check than the memory compatiblity check that is done for points-to
<span class="lineno">  986 </span>--   assertions.
<span class="lineno">  987 </span>checkRegisterCompatibility ::
<span class="lineno">  988 </span>  (Crucible.HasPtrWidth wptr) =&gt;
<span class="lineno">  989 </span>  Crucible.MemType -&gt;
<span class="lineno">  990 </span>  Crucible.MemType -&gt;
<span class="lineno">  991 </span>  IO Bool
<span class="lineno">  992 </span><span class="decl"><span class="istickedoff">checkRegisterCompatibility mt mt' =</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="istickedoff">do st  &lt;- Crucible.toStorableType mt</span>
<span class="lineno">  994 </span><span class="spaces">     </span><span class="istickedoff">st' &lt;- Crucible.toStorableType mt'</span>
<span class="lineno">  995 </span><span class="spaces">     </span><span class="istickedoff">return (st == st')</span></span>
<span class="lineno">  996 </span>
<span class="lineno">  997 </span>resolveArguments ::
<span class="lineno">  998 </span>  (?lc :: Crucible.TypeContext, ?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno">  999 </span>  LLVMCrucibleContext arch       -&gt;
<span class="lineno"> 1000 </span>  Crucible.MemImpl Sym -&gt;
<span class="lineno"> 1001 </span>  MS.CrucibleMethodSpecIR (LLVM arch)       -&gt;
<span class="lineno"> 1002 </span>  Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno"> 1003 </span>  IO [(Crucible.MemType, LLVMVal)]
<span class="lineno"> 1004 </span><span class="decl"><span class="istickedoff">resolveArguments cc mem mspec env = mapM resolveArg [0..(nArgs-1)]</span>
<span class="lineno"> 1005 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1006 </span><span class="spaces">    </span><span class="istickedoff">nArgs = toInteger (length (mspec ^. MS.csArgs))</span>
<span class="lineno"> 1007 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">tyenv = MS.csAllocations mspec</span></span>
<span class="lineno"> 1008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nm = mspec^.csName</span></span>
<span class="lineno"> 1010 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1011 </span><span class="spaces">    </span><span class="istickedoff">resolveArg i =</span>
<span class="lineno"> 1012 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup i (mspec ^. MS.csArgBindings) of</span>
<span class="lineno"> 1013 </span><span class="spaces">        </span><span class="istickedoff">Just (mt, sv) -&gt; do</span>
<span class="lineno"> 1014 </span><span class="spaces">          </span><span class="istickedoff">v &lt;- resolveSetupVal cc <span class="nottickedoff">mem</span> env <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> sv</span>
<span class="lineno"> 1015 </span><span class="spaces">          </span><span class="istickedoff">return (<span class="nottickedoff">mt</span>, v)</span>
<span class="lineno"> 1016 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwMethodSpec mspec $ unwords</span></span>
<span class="lineno"> 1017 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;Argument&quot;, show i, &quot;unspecified when verifying&quot;, show nm]</span></span></span>
<span class="lineno"> 1018 </span>
<span class="lineno"> 1019 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1020 </span>
<span class="lineno"> 1021 </span>-- | For each &quot;llvm_global_alloc&quot; in the method specification, allocate and
<span class="lineno"> 1022 </span>-- register the appropriate memory.
<span class="lineno"> 1023 </span>setupGlobalAllocs :: forall arch.
<span class="lineno"> 1024 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1025 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1026 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1027 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1028 </span>  ) =&gt;
<span class="lineno"> 1029 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1030 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1031 </span>  MemImpl -&gt;
<span class="lineno"> 1032 </span>  IO MemImpl
<span class="lineno"> 1033 </span><span class="decl"><span class="istickedoff">setupGlobalAllocs cc mspec mem0 = foldM go mem0 $ mspec ^. MS.csGlobalAllocs</span>
<span class="lineno"> 1034 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1035 </span><span class="spaces">    </span><span class="istickedoff">sym = cc ^. ccSym</span>
<span class="lineno"> 1036 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1037 </span><span class="spaces">    </span><span class="istickedoff">go :: MemImpl -&gt; MS.AllocGlobal (LLVM arch) -&gt; IO MemImpl</span>
<span class="lineno"> 1038 </span><span class="spaces">    </span><span class="istickedoff">go mem (LLVMAllocGlobal _ symbol@(L.Symbol name)) = do</span>
<span class="lineno"> 1039 </span><span class="spaces">      </span><span class="istickedoff">let mtrans = ccLLVMModuleTrans cc</span>
<span class="lineno"> 1040 </span><span class="spaces">          </span><span class="istickedoff">gimap = view Crucible.globalInitMap mtrans</span>
<span class="lineno"> 1041 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup symbol gimap of</span>
<span class="lineno"> 1042 </span><span class="spaces">        </span><span class="istickedoff">Just (g, Right (mt, _)) -&gt; ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1043 </span><span class="spaces">          </span><span class="istickedoff">do when (L.gaConstant $ L.globalAttrs g) . <span class="nottickedoff">throwMethodSpec mspec</span> $ <span class="nottickedoff">mconcat</span></span>
<span class="lineno"> 1044 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Global variable \&quot;&quot;</span></span>
<span class="lineno"> 1045 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, name</span></span>
<span class="lineno"> 1046 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, &quot;\&quot; is not mutable&quot;</span></span>
<span class="lineno"> 1047 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1048 </span><span class="spaces">             </span><span class="istickedoff">let sz = Crucible.memTypeSize <span class="nottickedoff">(Crucible.llvmDataLayout ?lc)</span> mt</span>
<span class="lineno"> 1049 </span><span class="spaces">             </span><span class="istickedoff">sz' &lt;- W4.bvLit sym ?ptrWidth $ Crucible.bytesToBV ?ptrWidth sz</span>
<span class="lineno"> 1050 </span><span class="spaces">             </span><span class="istickedoff">alignment &lt;-</span>
<span class="lineno"> 1051 </span><span class="spaces">               </span><span class="istickedoff">case L.globalAlign g of</span>
<span class="lineno"> 1052 </span><span class="spaces">                 </span><span class="istickedoff">Just a | <span class="tickonlytrue">a &gt; 0</span> -&gt;</span>
<span class="lineno"> 1053 </span><span class="spaces">                   </span><span class="istickedoff">case Crucible.toAlignment $ Crucible.toBytes a of</span>
<span class="lineno"> 1054 </span><span class="spaces">                     </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwMethodSpec mspec $ mconcat</span></span>
<span class="lineno"> 1055 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Global variable \&quot;&quot;</span></span>
<span class="lineno"> 1056 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">, name</span></span>
<span class="lineno"> 1057 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">, &quot;\&quot; has invalid alignment: &quot;</span></span>
<span class="lineno"> 1058 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">, show a</span></span>
<span class="lineno"> 1059 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1060 </span><span class="spaces">                     </span><span class="istickedoff">Just al -&gt; return al</span>
<span class="lineno"> 1061 </span><span class="spaces">                 </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">pure $ Crucible.memTypeAlign (Crucible.llvmDataLayout ?lc) mt</span></span>
<span class="lineno"> 1062 </span><span class="spaces">             </span><span class="istickedoff">(ptr, mem') &lt;- Crucible.doMalloc bak Crucible.GlobalAlloc Crucible.Mutable name mem sz' alignment</span>
<span class="lineno"> 1063 </span><span class="spaces">             </span><span class="istickedoff">pure $ Crucible.registerGlobal mem' [symbol] ptr</span>
<span class="lineno"> 1064 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwMethodSpec mspec $ mconcat</span></span>
<span class="lineno"> 1065 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Global variable \&quot;&quot;</span></span>
<span class="lineno"> 1066 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, name</span></span>
<span class="lineno"> 1067 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;\&quot; does not exist&quot;</span></span>
<span class="lineno"> 1068 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1069 </span>
<span class="lineno"> 1070 </span>-- | For each points-to constraint in the pre-state section of the
<span class="lineno"> 1071 </span>-- function spec, write the given value to the address of the given
<span class="lineno"> 1072 </span>-- pointer.
<span class="lineno"> 1073 </span>setupPrePointsTos :: forall arch.
<span class="lineno"> 1074 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1075 </span>  , ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1076 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1077 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1078 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1079 </span>  ) =&gt;
<span class="lineno"> 1080 </span>  MS.CrucibleMethodSpecIR (LLVM arch)       -&gt;
<span class="lineno"> 1081 </span>  Options -&gt;
<span class="lineno"> 1082 </span>  LLVMCrucibleContext arch       -&gt;
<span class="lineno"> 1083 </span>  Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno"> 1084 </span>  [MS.PointsTo (LLVM arch)]                 -&gt;
<span class="lineno"> 1085 </span>  MemImpl                    -&gt;
<span class="lineno"> 1086 </span>  IO MemImpl
<span class="lineno"> 1087 </span><span class="decl"><span class="istickedoff">setupPrePointsTos mspec opts cc env pts mem0 = foldM go mem0 pts</span>
<span class="lineno"> 1088 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1089 </span><span class="spaces">    </span><span class="istickedoff">tyenv   = MS.csAllocations mspec</span>
<span class="lineno"> 1090 </span><span class="spaces">    </span><span class="istickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span>
<span class="lineno"> 1091 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1092 </span><span class="spaces">    </span><span class="istickedoff">go :: MemImpl -&gt; MS.PointsTo (LLVM arch) -&gt; IO MemImpl</span>
<span class="lineno"> 1093 </span><span class="spaces">    </span><span class="istickedoff">go mem (LLVMPointsTo _loc cond ptr val) =</span>
<span class="lineno"> 1094 </span><span class="spaces">      </span><span class="istickedoff">do ptr' &lt;- resolveSetupVal cc mem env tyenv nameEnv ptr</span>
<span class="lineno"> 1095 </span><span class="spaces">         </span><span class="istickedoff">ptr'' &lt;- unpackPtrVal ptr'</span>
<span class="lineno"> 1096 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1097 </span><span class="spaces">         </span><span class="istickedoff">cond' &lt;- mapM <span class="nottickedoff">(resolveSAWPred cc . ttTerm)</span> cond</span>
<span class="lineno"> 1098 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1099 </span><span class="spaces">         </span><span class="istickedoff">storePointsToValue <span class="nottickedoff">opts</span> cc env tyenv <span class="nottickedoff">nameEnv</span> mem cond' ptr'' val <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1100 </span><span class="spaces">    </span><span class="istickedoff">go mem (LLVMPointsToBitfield _loc ptr fieldName val) =</span>
<span class="lineno"> 1101 </span><span class="spaces">      </span><span class="istickedoff">do (bfIndex, ptr') &lt;- resolveSetupValBitfield cc <span class="nottickedoff">mem</span> env tyenv nameEnv ptr fieldName</span>
<span class="lineno"> 1102 </span><span class="spaces">         </span><span class="istickedoff">ptr'' &lt;- unpackPtrVal ptr'</span>
<span class="lineno"> 1103 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1104 </span><span class="spaces">         </span><span class="istickedoff">storePointsToBitfieldValue <span class="nottickedoff">opts</span> cc <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> mem ptr'' bfIndex val</span>
<span class="lineno"> 1105 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1106 </span><span class="spaces">    </span><span class="istickedoff">unpackPtrVal :: LLVMVal -&gt; IO (LLVMPtr (Crucible.ArchWidth arch))</span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff">unpackPtrVal (Crucible.LLVMValInt blk off)</span>
<span class="lineno"> 1108 </span><span class="spaces">        </span><span class="istickedoff">| Just Refl &lt;- testEquality (W4.bvWidth off) Crucible.PtrWidth</span>
<span class="lineno"> 1109 </span><span class="spaces">        </span><span class="istickedoff">= return (Crucible.LLVMPointer blk off)</span>
<span class="lineno"> 1110 </span><span class="spaces">    </span><span class="istickedoff">unpackPtrVal _ = <span class="nottickedoff">throwMethodSpec mspec &quot;Non-pointer value found in points-to assertion&quot;</span></span></span>
<span class="lineno"> 1111 </span>
<span class="lineno"> 1112 </span>-- | Sets up globals (ghost variable), and collects boolean terms
<span class="lineno"> 1113 </span>-- that should be assumed to be true.
<span class="lineno"> 1114 </span>setupPrestateConditions ::
<span class="lineno"> 1115 </span>  (?lc :: Crucible.TypeContext, ?w4EvalTactic :: W4EvalTactic, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 1116 </span>  MS.CrucibleMethodSpecIR (LLVM arch)        -&gt;
<span class="lineno"> 1117 </span>  LLVMCrucibleContext arch        -&gt;
<span class="lineno"> 1118 </span>  Crucible.MemImpl Sym -&gt;
<span class="lineno"> 1119 </span>  Map AllocIndex (LLVMPtr (Crucible.ArchWidth arch)) -&gt;
<span class="lineno"> 1120 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno"> 1121 </span>  [MS.SetupCondition (LLVM arch)]            -&gt;
<span class="lineno"> 1122 </span>  IO ( Crucible.SymGlobalState Sym, [Crucible.LabeledPred Term AssumptionReason]
<span class="lineno"> 1123 </span>     )
<span class="lineno"> 1124 </span><span class="decl"><span class="istickedoff">setupPrestateConditions mspec cc mem env = aux []</span>
<span class="lineno"> 1125 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">tyenv   = MS.csAllocations mspec</span></span>
<span class="lineno"> 1127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameEnv = mspec ^. MS.csPreState . MS.csVarTypeNames</span></span>
<span class="lineno"> 1128 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1129 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals [] = return (globals, acc)</span>
<span class="lineno"> 1130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1131 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals (MS.SetupCond_Equal md val1 val2 : xs) =</span>
<span class="lineno"> 1132 </span><span class="spaces">      </span><span class="istickedoff">do val1' &lt;- resolveSetupVal cc <span class="nottickedoff">mem</span> <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val1</span>
<span class="lineno"> 1133 </span><span class="spaces">         </span><span class="istickedoff">val2' &lt;- resolveSetupVal cc <span class="nottickedoff">mem</span> <span class="nottickedoff">env</span> <span class="nottickedoff">tyenv</span> <span class="nottickedoff">nameEnv</span> val2</span>
<span class="lineno"> 1134 </span><span class="spaces">         </span><span class="istickedoff">t     &lt;- assertEqualVals cc val1' val2'</span>
<span class="lineno"> 1135 </span><span class="spaces">         </span><span class="istickedoff">let lp = Crucible.LabeledPred t (<span class="nottickedoff">md</span>, <span class="nottickedoff">&quot;equality precondition&quot;</span>)</span>
<span class="lineno"> 1136 </span><span class="spaces">         </span><span class="istickedoff">aux (lp:acc) globals xs</span>
<span class="lineno"> 1137 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1138 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals (MS.SetupCond_Pred md tm : xs) =</span>
<span class="lineno"> 1139 </span><span class="spaces">      </span><span class="istickedoff">let lp = Crucible.LabeledPred (ttTerm tm) (md, &quot;precondition&quot;) in</span>
<span class="lineno"> 1140 </span><span class="spaces">      </span><span class="istickedoff">aux (lp:acc) globals xs</span>
<span class="lineno"> 1141 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1142 </span><span class="spaces">    </span><span class="istickedoff">aux acc globals (MS.SetupCond_Ghost _md var val : xs) =</span>
<span class="lineno"> 1143 </span><span class="spaces">      </span><span class="istickedoff">case val of</span>
<span class="lineno"> 1144 </span><span class="spaces">        </span><span class="istickedoff">TypedTerm (TypedTermSchema sch) tm -&gt;</span>
<span class="lineno"> 1145 </span><span class="spaces">          </span><span class="istickedoff">aux acc (Crucible.insertGlobal var (sch,tm) globals) xs</span>
<span class="lineno"> 1146 </span><span class="spaces">        </span><span class="istickedoff">TypedTerm tp _ -&gt;</span>
<span class="lineno"> 1147 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1148 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Setup term for global variable expected to have Cryptol schema type, but got&quot;</span></span>
<span class="lineno"> 1149 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, show (MS.ppTypedTermType tp)</span></span>
<span class="lineno"> 1150 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1151 </span>
<span class="lineno"> 1152 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1153 </span>
<span class="lineno"> 1154 </span>-- | Create a SAWCore formula asserting that two 'LLVMVal's are equal.
<span class="lineno"> 1155 </span>assertEqualVals ::
<span class="lineno"> 1156 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1157 </span>  LLVMVal -&gt;
<span class="lineno"> 1158 </span>  LLVMVal -&gt;
<span class="lineno"> 1159 </span>  IO Term
<span class="lineno"> 1160 </span><span class="decl"><span class="istickedoff">assertEqualVals cc v1 v2 =</span>
<span class="lineno"> 1161 </span><span class="spaces">  </span><span class="istickedoff">do let sym = cc^.ccSym</span>
<span class="lineno"> 1162 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- Common.sawCoreState sym</span>
<span class="lineno"> 1163 </span><span class="spaces">     </span><span class="istickedoff">toSC <span class="nottickedoff">sym</span> st =&lt;&lt; equalValsPred cc v1 v2</span></span>
<span class="lineno"> 1164 </span>
<span class="lineno"> 1165 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1166 </span>
<span class="lineno"> 1167 </span>-- TODO(langston): combine with/move to executeAllocation
<span class="lineno"> 1168 </span>doAlloc ::
<span class="lineno"> 1169 </span>  ( ?memOpts :: Crucible.MemOptions
<span class="lineno"> 1170 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1171 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1172 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1173 </span>  ) =&gt;
<span class="lineno"> 1174 </span>  LLVMCrucibleContext arch       -&gt;
<span class="lineno"> 1175 </span>  AllocIndex -&gt;
<span class="lineno"> 1176 </span>  LLVMAllocSpec -&gt;
<span class="lineno"> 1177 </span>  StateT MemImpl IO (LLVMPtr (Crucible.ArchWidth arch))
<span class="lineno"> 1178 </span><span class="decl"><span class="istickedoff">doAlloc cc i (LLVMAllocSpec mut _memTy alignment sz md fresh initialization)</span>
<span class="lineno"> 1179 </span><span class="spaces">  </span><span class="istickedoff">| fresh = liftIO $ executeFreshPointer cc i</span>
<span class="lineno"> 1180 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1181 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1182 </span><span class="spaces">  </span><span class="istickedoff">StateT $ \mem -&gt;</span>
<span class="lineno"> 1183 </span><span class="spaces">  </span><span class="istickedoff">do sz' &lt;- liftIO $ resolveSAWSymBV cc Crucible.PtrWidth sz</span>
<span class="lineno"> 1184 </span><span class="spaces">     </span><span class="istickedoff">let l = show (W4.plSourceLoc (MS.conditionLoc md))</span>
<span class="lineno"> 1185 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ doAllocSymInit bak mem mut alignment sz' l initialization</span></span>
<span class="lineno"> 1186 </span>
<span class="lineno"> 1187 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1188 </span>
<span class="lineno"> 1189 </span>lookupMemGlobal :: Crucible.GlobalVar tp -&gt; Crucible.SymGlobalState sym -&gt; Crucible.RegValue sym tp
<span class="lineno"> 1190 </span><span class="decl"><span class="istickedoff">lookupMemGlobal mvar globals =</span>
<span class="lineno"> 1191 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe</span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="istickedoff">-- this used to claim it happens in pushFreshReturnAddress from X86.hs,</span>
<span class="lineno"> 1193 </span><span class="spaces">    </span><span class="istickedoff">-- which seems to be possible but far from the only entry point...</span>
<span class="lineno"> 1194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(panic &quot;lookupMemGlobal&quot; [&quot;LLVM Memory global not found: &quot; &lt;&gt; Text.pack (show $ pretty mvar)])</span></span>
<span class="lineno"> 1195 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.lookupGlobal mvar globals)</span></span>
<span class="lineno"> 1196 </span>
<span class="lineno"> 1197 </span>ppAbortedResult :: LLVMCrucibleContext arch
<span class="lineno"> 1198 </span>                -&gt; Crucible.AbortedResult Sym a
<span class="lineno"> 1199 </span>                -&gt; Doc ann
<span class="lineno"> 1200 </span><span class="decl"><span class="istickedoff">ppAbortedResult cc = Common.ppAbortedResult (ppGlobalPair cc)</span></span>
<span class="lineno"> 1201 </span>
<span class="lineno"> 1202 </span>ppGlobalPair :: LLVMCrucibleContext arch
<span class="lineno"> 1203 </span>             -&gt; Crucible.GlobalPair Sym a
<span class="lineno"> 1204 </span>             -&gt; Doc ann
<span class="lineno"> 1205 </span><span class="decl"><span class="istickedoff">ppGlobalPair cc gp =</span>
<span class="lineno"> 1206 </span><span class="spaces">  </span><span class="istickedoff">let mvar = Crucible.llvmMemVar (ccLLVMContext cc)</span>
<span class="lineno"> 1207 </span><span class="spaces">      </span><span class="istickedoff">globals = gp ^. Crucible.gpGlobals in</span>
<span class="lineno"> 1208 </span><span class="spaces">  </span><span class="istickedoff">Crucible.ppMem $ Crucible.memImplHeap $ lookupMemGlobal mvar globals</span></span>
<span class="lineno"> 1209 </span>
<span class="lineno"> 1210 </span>
<span class="lineno"> 1211 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1212 </span>
<span class="lineno"> 1213 </span>registerOverride ::
<span class="lineno"> 1214 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1215 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno"> 1216 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1217 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno"> 1218 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno"> 1219 </span>  , Crucible.HasPtrWidth wptr
<span class="lineno"> 1220 </span>  , wptr ~ Crucible.ArchWidth arch
<span class="lineno"> 1221 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1222 </span>  ) =&gt;
<span class="lineno"> 1223 </span>  Options                    -&gt;
<span class="lineno"> 1224 </span>  LLVMCrucibleContext arch       -&gt;
<span class="lineno"> 1225 </span>  Crucible.SimContext (SAWCruciblePersonality Sym) Sym Crucible.LLVM -&gt;
<span class="lineno"> 1226 </span>  W4.ProgramLoc              -&gt;
<span class="lineno"> 1227 </span>  IORef MetadataMap -&gt;
<span class="lineno"> 1228 </span>  NE.NonEmpty (MS.CrucibleMethodSpecIR (LLVM arch))     -&gt;
<span class="lineno"> 1229 </span>  Crucible.OverrideSim (SAWCruciblePersonality Sym) Sym Crucible.LLVM rtp args ret (Crucible.SomeHandle)
<span class="lineno"> 1230 </span><span class="decl"><span class="istickedoff">registerOverride opts cc sim_ctx _top_loc mdMap cs =</span>
<span class="lineno"> 1231 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1232 </span><span class="spaces">  </span><span class="istickedoff">do let sym = Common.backendGetSym bak</span>
<span class="lineno"> 1233 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- saw_ctx &lt;$&gt; liftIO (Common.sawCoreState sym)</span>
<span class="lineno"> 1234 </span><span class="spaces">     </span><span class="istickedoff">let fstr = (NE.head cs)^.csName</span>
<span class="lineno"> 1235 </span><span class="spaces">         </span><span class="istickedoff">fsym = L.Symbol fstr</span>
<span class="lineno"> 1236 </span><span class="spaces">         </span><span class="istickedoff">llvmctx = ccLLVMContext cc</span>
<span class="lineno"> 1237 </span><span class="spaces">         </span><span class="istickedoff">mvar = Crucible.llvmMemVar llvmctx</span>
<span class="lineno"> 1238 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">halloc = Crucible.simHandleAllocator sim_ctx</span></span>
<span class="lineno"> 1239 </span><span class="spaces">         </span><span class="istickedoff">matches dec = matchingStatics (L.decName dec) fsym</span>
<span class="lineno"> 1240 </span><span class="spaces">     </span><span class="istickedoff">liftIO $</span>
<span class="lineno"> 1241 </span><span class="spaces">       </span><span class="istickedoff">printOutLn opts Info $ &quot;Registering overrides for `&quot; ++ fstr ++ &quot;`&quot;</span>
<span class="lineno"> 1242 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1243 </span><span class="spaces">     </span><span class="istickedoff">case filter matches (Crucible.allModuleDeclares (ccLLVMModuleAST cc)) of</span>
<span class="lineno"> 1244 </span><span class="spaces">       </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">fail $ &quot;Couldn't find declaration for `&quot; ++ fstr ++ &quot;` when registering override for it.&quot;</span></span>
<span class="lineno"> 1245 </span><span class="spaces">       </span><span class="istickedoff">(d:ds) -&gt;</span>
<span class="lineno"> 1246 </span><span class="spaces">         </span><span class="istickedoff">Crucible.llvmDeclToFunHandleRepr' d $ \argTypes retType -&gt;</span>
<span class="lineno"> 1247 </span><span class="spaces">           </span><span class="istickedoff">do let fn_name = W4.functionNameFromText $ Text.pack fstr</span>
<span class="lineno"> 1248 </span><span class="spaces">              </span><span class="istickedoff">h &lt;- liftIO $ Crucible.mkHandle' <span class="nottickedoff">halloc</span> fn_name argTypes retType</span>
<span class="lineno"> 1249 </span><span class="spaces">              </span><span class="istickedoff">Crucible.bindFnHandle h</span>
<span class="lineno"> 1250 </span><span class="spaces">                </span><span class="istickedoff">$ Crucible.UseOverride</span>
<span class="lineno"> 1251 </span><span class="spaces">                </span><span class="istickedoff">$ Crucible.mkOverride' fn_name retType</span>
<span class="lineno"> 1252 </span><span class="spaces">                </span><span class="istickedoff">$ methodSpecHandler opts sc cc <span class="nottickedoff">mdMap</span> cs h</span>
<span class="lineno"> 1253 </span><span class="spaces">              </span><span class="istickedoff">mem &lt;- Crucible.readGlobal mvar</span>
<span class="lineno"> 1254 </span><span class="spaces">              </span><span class="istickedoff">let bindPtr m decl =</span>
<span class="lineno"> 1255 </span><span class="spaces">                    </span><span class="istickedoff">do let declName = L.decName decl</span>
<span class="lineno"> 1256 </span><span class="spaces">                       </span><span class="istickedoff">printOutLn opts Info $ &quot;  variant `&quot; ++ show declName ++ &quot;`&quot;</span>
<span class="lineno"> 1257 </span><span class="spaces">                       </span><span class="istickedoff">Crucible.bindLLVMFunPtr <span class="nottickedoff">bak</span> declName h m</span>
<span class="lineno"> 1258 </span><span class="spaces">              </span><span class="istickedoff">mem' &lt;- liftIO $ foldM bindPtr mem (d:ds)</span>
<span class="lineno"> 1259 </span><span class="spaces">              </span><span class="istickedoff">Crucible.writeGlobal mvar mem'</span>
<span class="lineno"> 1260 </span><span class="spaces">              </span><span class="istickedoff">return (Crucible.SomeHandle h)</span></span>
<span class="lineno"> 1261 </span>
<span class="lineno"> 1262 </span>registerInvariantOverride ::
<span class="lineno"> 1263 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1264 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno"> 1265 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1266 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno"> 1267 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno"> 1268 </span>  , Crucible.HasPtrWidth (Crucible.ArchWidth arch)
<span class="lineno"> 1269 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1270 </span>  ) =&gt;
<span class="lineno"> 1271 </span>  Options -&gt;
<span class="lineno"> 1272 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1273 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 1274 </span>  IORef MetadataMap -&gt;
<span class="lineno"> 1275 </span>  HashMap Crucible.SomeHandle [Crucible.BreakpointName] -&gt;
<span class="lineno"> 1276 </span>  NE.NonEmpty (MS.CrucibleMethodSpecIR (LLVM arch)) -&gt;
<span class="lineno"> 1277 </span>  IO (Crucible.ExecutionFeature (SAWCruciblePersonality Sym) Sym Crucible.LLVM rtp)
<span class="lineno"> 1278 </span><span class="decl"><span class="istickedoff">registerInvariantOverride opts cc top_loc mdMap all_breakpoints cs =</span>
<span class="lineno"> 1279 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- saw_ctx &lt;$&gt; Common.sawCoreState (cc^.ccSym)</span>
<span class="lineno"> 1280 </span><span class="spaces">     </span><span class="istickedoff">let name = (NE.head cs) ^. csName</span>
<span class="lineno"> 1281 </span><span class="spaces">     </span><span class="istickedoff">parent &lt;-</span>
<span class="lineno"> 1282 </span><span class="spaces">       </span><span class="istickedoff">case neNubOrd $ fmap (view csParentName) cs of</span>
<span class="lineno"> 1283 </span><span class="spaces">         </span><span class="istickedoff">(Just unique_parent NE.:| []) -&gt; return unique_parent</span>
<span class="lineno"> 1284 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ &quot;Multiple parent functions for breakpoint: &quot; ++ name</span></span>
<span class="lineno"> 1285 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ printOutLn opts Info $ &quot;Registering breakpoint `&quot; ++ name ++ &quot;`&quot;</span>
<span class="lineno"> 1286 </span><span class="spaces">     </span><span class="istickedoff">withBreakpointCfgAndBlockId <span class="nottickedoff">opts</span> cc name parent $ \cfg breakpoint_block_id -&gt;</span>
<span class="lineno"> 1287 </span><span class="spaces">       </span><span class="istickedoff">do let breakpoint_name = Crucible.BreakpointName $ Text.pack name</span>
<span class="lineno"> 1288 </span><span class="spaces">          </span><span class="istickedoff">let h = Crucible.cfgHandle cfg</span>
<span class="lineno"> 1289 </span><span class="spaces">          </span><span class="istickedoff">let arg_types = Crucible.blockInputs $</span>
<span class="lineno"> 1290 </span><span class="spaces">                </span><span class="istickedoff">Crucible.getBlock breakpoint_block_id $</span>
<span class="lineno"> 1291 </span><span class="spaces">                </span><span class="istickedoff">Crucible.cfgBlockMap cfg</span>
<span class="lineno"> 1292 </span><span class="spaces">          </span><span class="istickedoff">let ret_type = Crucible.handleReturnType h</span>
<span class="lineno"> 1293 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">halloc = Crucible.simHandleAllocator (cc ^. ccLLVMSimContext)</span></span>
<span class="lineno"> 1294 </span><span class="spaces">          </span><span class="istickedoff">hInvariant &lt;- Crucible.mkHandle' <span class="nottickedoff">halloc</span> (W4.plFunction top_loc) arg_types ret_type</span>
<span class="lineno"> 1295 </span><span class="spaces">          </span><span class="istickedoff">Crucible.breakAndReturn</span>
<span class="lineno"> 1296 </span><span class="spaces">            </span><span class="istickedoff">cfg</span>
<span class="lineno"> 1297 </span><span class="spaces">            </span><span class="istickedoff">breakpoint_name</span>
<span class="lineno"> 1298 </span><span class="spaces">            </span><span class="istickedoff">arg_types</span>
<span class="lineno"> 1299 </span><span class="spaces">            </span><span class="istickedoff">ret_type</span>
<span class="lineno"> 1300 </span><span class="spaces">            </span><span class="istickedoff">(methodSpecHandler opts sc cc <span class="nottickedoff">mdMap</span> cs hInvariant)</span>
<span class="lineno"> 1301 </span><span class="spaces">            </span><span class="istickedoff">all_breakpoints</span></span>
<span class="lineno"> 1302 </span>
<span class="lineno"> 1303 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1304 </span>
<span class="lineno"> 1305 </span>withCfg ::
<span class="lineno"> 1306 </span>  (?lc :: Crucible.TypeContext, Crucible.HasPtrWidth (Crucible.ArchWidth arch), Crucible.HasLLVMAnn Sym) =&gt;
<span class="lineno"> 1307 </span>  Options -&gt;
<span class="lineno"> 1308 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1309 </span>  String -&gt;
<span class="lineno"> 1310 </span>  (forall blocks init ret . Crucible.CFG Crucible.LLVM blocks init ret -&gt; IO a) -&gt;
<span class="lineno"> 1311 </span>  IO a
<span class="lineno"> 1312 </span><span class="decl"><span class="istickedoff">withCfg opts context name k =</span>
<span class="lineno"> 1313 </span><span class="spaces">  </span><span class="istickedoff">do let function_id = L.Symbol name</span>
<span class="lineno"> 1314 </span><span class="spaces">     </span><span class="istickedoff">Crucible.getTranslatedCFG (ccLLVMModuleTrans context) function_id &gt;&gt;= \case</span>
<span class="lineno"> 1315 </span><span class="spaces">       </span><span class="istickedoff">Just (_, Crucible.AnyCFG cfg, warns) -&gt;</span>
<span class="lineno"> 1316 </span><span class="spaces">         </span><span class="istickedoff">do mapM_ (handleTranslationWarning opts) warns</span>
<span class="lineno"> 1317 </span><span class="spaces">            </span><span class="istickedoff">k cfg</span>
<span class="lineno"> 1318 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;Unexpected function name: &quot; ++ name</span></span></span>
<span class="lineno"> 1319 </span>
<span class="lineno"> 1320 </span>withCfgAndBlockId ::
<span class="lineno"> 1321 </span>  (?lc :: Crucible.TypeContext, Crucible.HasPtrWidth (Crucible.ArchWidth arch), Crucible.HasLLVMAnn Sym) =&gt;
<span class="lineno"> 1322 </span>  Options -&gt;
<span class="lineno"> 1323 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1324 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1325 </span>  (forall blocks init args ret . Crucible.CFG Crucible.LLVM blocks init ret -&gt; Crucible.BlockID blocks args -&gt; IO a) -&gt;
<span class="lineno"> 1326 </span>  IO a
<span class="lineno"> 1327 </span><span class="decl"><span class="istickedoff">withCfgAndBlockId opts context method_spec k =</span>
<span class="lineno"> 1328 </span><span class="spaces">  </span><span class="istickedoff">case method_spec ^. csParentName of</span>
<span class="lineno"> 1329 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; withCfg opts context (method_spec ^. csName) $ \cfg -&gt;</span>
<span class="lineno"> 1330 </span><span class="spaces">      </span><span class="istickedoff">k cfg (Crucible.cfgEntryBlockID cfg)</span>
<span class="lineno"> 1331 </span><span class="spaces">    </span><span class="istickedoff">Just parent -&gt; withBreakpointCfgAndBlockId <span class="nottickedoff">opts</span></span>
<span class="lineno"> 1332 </span><span class="spaces">      </span><span class="istickedoff">context</span>
<span class="lineno"> 1333 </span><span class="spaces">      </span><span class="istickedoff">(method_spec ^. csName)</span>
<span class="lineno"> 1334 </span><span class="spaces">      </span><span class="istickedoff">parent</span>
<span class="lineno"> 1335 </span><span class="spaces">      </span><span class="istickedoff">k</span></span>
<span class="lineno"> 1336 </span>
<span class="lineno"> 1337 </span>withBreakpointCfgAndBlockId ::
<span class="lineno"> 1338 </span>  (?lc :: Crucible.TypeContext, Crucible.HasPtrWidth (Crucible.ArchWidth arch), Crucible.HasLLVMAnn Sym) =&gt;
<span class="lineno"> 1339 </span>  Options -&gt;
<span class="lineno"> 1340 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1341 </span>  String -&gt;
<span class="lineno"> 1342 </span>  String -&gt;
<span class="lineno"> 1343 </span>  (forall blocks init args ret . Crucible.CFG Crucible.LLVM blocks init ret -&gt; Crucible.BlockID blocks args -&gt; IO a) -&gt;
<span class="lineno"> 1344 </span>  IO a
<span class="lineno"> 1345 </span><span class="decl"><span class="istickedoff">withBreakpointCfgAndBlockId opts context name parent k =</span>
<span class="lineno"> 1346 </span><span class="spaces">  </span><span class="istickedoff">do let breakpoint_name = Crucible.BreakpointName $ Text.pack name</span>
<span class="lineno"> 1347 </span><span class="spaces">     </span><span class="istickedoff">withCfg <span class="nottickedoff">opts</span> context parent $ \cfg -&gt;</span>
<span class="lineno"> 1348 </span><span class="spaces">       </span><span class="istickedoff">case Bimap.lookup breakpoint_name (Crucible.cfgBreakpoints cfg) of</span>
<span class="lineno"> 1349 </span><span class="spaces">         </span><span class="istickedoff">Just (Some breakpoint_block_id) -&gt; k cfg breakpoint_block_id</span>
<span class="lineno"> 1350 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;Unexpected breakpoint name: &quot; ++ name</span></span></span>
<span class="lineno"> 1351 </span>
<span class="lineno"> 1352 </span>-- | Simulate an LLVM function with Crucible as part of a 'llvm_verify' command,
<span class="lineno"> 1353 </span>-- making sure to install any overrides that the user supplies.
<span class="lineno"> 1354 </span>verifySimulate ::
<span class="lineno"> 1355 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1356 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno"> 1357 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1358 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno"> 1359 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno"> 1360 </span>  , Crucible.HasPtrWidth wptr
<span class="lineno"> 1361 </span>  , wptr ~ Crucible.ArchWidth arch
<span class="lineno"> 1362 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1363 </span>  ) =&gt;
<span class="lineno"> 1364 </span>  Options -&gt;
<span class="lineno"> 1365 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1366 </span>  [Crucible.GenericExecutionFeature Sym] -&gt;
<span class="lineno"> 1367 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1368 </span>  [(Crucible.MemType, LLVMVal)] -&gt;
<span class="lineno"> 1369 </span>  [Crucible.LabeledPred Term AssumptionReason] -&gt;
<span class="lineno"> 1370 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 1371 </span>  [MS.ProvedSpec (LLVM arch)] -&gt;
<span class="lineno"> 1372 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno"> 1373 </span>  Bool -&gt;
<span class="lineno"> 1374 </span>  Maybe (IORef (Map Text.Text [Crucible.FunctionProfile])) -&gt;
<span class="lineno"> 1375 </span>  IORef MetadataMap -&gt;
<span class="lineno"> 1376 </span>  TopLevel (Maybe (Crucible.MemType, LLVMVal), Crucible.SymGlobalState Sym, MapF (W4.SymFnWrapper Sym) (W4.SymFnWrapper Sym))
<span class="lineno"> 1377 </span><span class="decl"><span class="istickedoff">verifySimulate opts cc pfs mspec args assumes top_loc lemmas globals checkSat asp mdMap =</span>
<span class="lineno"> 1378 </span><span class="spaces">  </span><span class="istickedoff">io $ withCfgAndBlockId opts cc mspec $ \cfg entryId -&gt; ccWithBackend cc $ \bak -&gt; do</span>
<span class="lineno"> 1379 </span><span class="spaces">     </span><span class="istickedoff">let sym = cc^.ccSym</span>
<span class="lineno"> 1380 </span><span class="spaces">     </span><span class="istickedoff">let argTys = Crucible.blockInputs $</span>
<span class="lineno"> 1381 </span><span class="spaces">           </span><span class="istickedoff">Crucible.getBlock entryId $ Crucible.cfgBlockMap cfg</span>
<span class="lineno"> 1382 </span><span class="spaces">     </span><span class="istickedoff">let retTy = Crucible.handleReturnType $ Crucible.cfgHandle cfg</span>
<span class="lineno"> 1383 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1384 </span><span class="spaces">     </span><span class="istickedoff">args' &lt;- prepareArgs <span class="nottickedoff">sym</span> argTys (map snd args)</span>
<span class="lineno"> 1385 </span><span class="spaces">     </span><span class="istickedoff">let simCtx = cc^.ccLLVMSimContext</span>
<span class="lineno"> 1386 </span><span class="spaces">     </span><span class="istickedoff">psatf &lt;-</span>
<span class="lineno"> 1387 </span><span class="spaces">       </span><span class="istickedoff">Crucible.pathSatisfiabilityFeature sym</span>
<span class="lineno"> 1388 </span><span class="spaces">         </span><span class="istickedoff">(Crucible.considerSatisfiability bak)</span>
<span class="lineno"> 1389 </span><span class="spaces">     </span><span class="istickedoff">let patSatGenExecFeature = if checkSat then [psatf] else []</span>
<span class="lineno"> 1390 </span><span class="spaces">     </span><span class="istickedoff">when checkSat checkYicesVersion</span>
<span class="lineno"> 1391 </span><span class="spaces">     </span><span class="istickedoff">let (funcLemmas, invLemmas) =</span>
<span class="lineno"> 1392 </span><span class="spaces">           </span><span class="istickedoff">partition (isNothing . view csParentName)</span>
<span class="lineno"> 1393 </span><span class="spaces">                     </span><span class="istickedoff">(map (view MS.psSpec) lemmas)</span>
<span class="lineno"> 1394 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1395 </span><span class="spaces">     </span><span class="istickedoff">breakpoints &lt;-</span>
<span class="lineno"> 1396 </span><span class="spaces">       </span><span class="istickedoff">forM (neGroupOn (view csParentName) invLemmas) $ \specs -&gt;</span>
<span class="lineno"> 1397 </span><span class="spaces">       </span><span class="istickedoff">do let parent = fromJust $ (NE.head specs) ^. csParentName</span>
<span class="lineno"> 1398 </span><span class="spaces">          </span><span class="istickedoff">let breakpoint_names = nubOrd $</span>
<span class="lineno"> 1399 </span><span class="spaces">                </span><span class="istickedoff">map (Crucible.BreakpointName . Text.pack . view csName) (NE.toList specs)</span>
<span class="lineno"> 1400 </span><span class="spaces">          </span><span class="istickedoff">withCfg <span class="nottickedoff">opts</span> cc parent $ \parent_cfg -&gt;</span>
<span class="lineno"> 1401 </span><span class="spaces">            </span><span class="istickedoff">return</span>
<span class="lineno"> 1402 </span><span class="spaces">              </span><span class="istickedoff">( Crucible.SomeHandle (Crucible.cfgHandle parent_cfg)</span>
<span class="lineno"> 1403 </span><span class="spaces">              </span><span class="istickedoff">, breakpoint_names</span>
<span class="lineno"> 1404 </span><span class="spaces">              </span><span class="istickedoff">)</span>
<span class="lineno"> 1405 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1406 </span><span class="spaces">     </span><span class="istickedoff">invariantExecFeatures &lt;-</span>
<span class="lineno"> 1407 </span><span class="spaces">       </span><span class="istickedoff">mapM</span>
<span class="lineno"> 1408 </span><span class="spaces">       </span><span class="istickedoff">(registerInvariantOverride opts cc top_loc <span class="nottickedoff">mdMap</span> (HashMap.fromList breakpoints))</span>
<span class="lineno"> 1409 </span><span class="spaces">       </span><span class="istickedoff">(neGroupOn (view csName) invLemmas)</span>
<span class="lineno"> 1410 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1411 </span><span class="spaces">     </span><span class="istickedoff">additionalFeatures &lt;-</span>
<span class="lineno"> 1412 </span><span class="spaces">       </span><span class="istickedoff">mapM <span class="nottickedoff">(Crucible.arraySizeProfile (ccLLVMContext cc))</span> $ maybeToList asp</span>
<span class="lineno"> 1413 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1414 </span><span class="spaces">     </span><span class="istickedoff">let execFeatures =</span>
<span class="lineno"> 1415 </span><span class="spaces">           </span><span class="istickedoff">invariantExecFeatures ++</span>
<span class="lineno"> 1416 </span><span class="spaces">           </span><span class="istickedoff">map Crucible.genericToExecutionFeature (patSatGenExecFeature ++ pfs) ++</span>
<span class="lineno"> 1417 </span><span class="spaces">           </span><span class="istickedoff">additionalFeatures</span>
<span class="lineno"> 1418 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1419 </span><span class="spaces">     </span><span class="istickedoff">let initExecState =</span>
<span class="lineno"> 1420 </span><span class="spaces">           </span><span class="istickedoff">Crucible.InitialState simCtx globals Crucible.defaultAbortHandler retTy $</span>
<span class="lineno"> 1421 </span><span class="spaces">           </span><span class="istickedoff">Crucible.runOverrideSim retTy $</span>
<span class="lineno"> 1422 </span><span class="spaces">           </span><span class="istickedoff">do mapM_ (registerOverride opts cc <span class="nottickedoff">simCtx</span> <span class="nottickedoff">top_loc</span> <span class="nottickedoff">mdMap</span>)</span>
<span class="lineno"> 1423 </span><span class="spaces">                    </span><span class="istickedoff">(neGroupOn (view csName) funcLemmas)</span>
<span class="lineno"> 1424 </span><span class="spaces">              </span><span class="istickedoff">liftIO $</span>
<span class="lineno"> 1425 </span><span class="spaces">                </span><span class="istickedoff">for_ assumes $ \(Crucible.LabeledPred p (md, reason)) -&gt;</span>
<span class="lineno"> 1426 </span><span class="spaces">                  </span><span class="istickedoff">do expr &lt;- resolveSAWPred cc p</span>
<span class="lineno"> 1427 </span><span class="spaces">                     </span><span class="istickedoff">let <span class="nottickedoff">loc = MS.conditionLoc md</span></span>
<span class="lineno"> 1428 </span><span class="spaces">                     </span><span class="istickedoff">Crucible.addAssumption bak</span>
<span class="lineno"> 1429 </span><span class="spaces">                       </span><span class="istickedoff">(Crucible.GenericAssumption <span class="nottickedoff">loc</span> <span class="nottickedoff">reason</span> expr)</span>
<span class="lineno"> 1430 </span><span class="spaces">              </span><span class="istickedoff">Crucible.regValue &lt;$&gt; (Crucible.callBlock cfg entryId args')</span>
<span class="lineno"> 1431 </span><span class="spaces">     </span><span class="istickedoff">res &lt;- Crucible.executeCrucible execFeatures initExecState</span>
<span class="lineno"> 1432 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1433 </span><span class="spaces">       </span><span class="istickedoff">Crucible.FinishedResult _ partialResult -&gt;</span>
<span class="lineno"> 1434 </span><span class="spaces">         </span><span class="istickedoff">do Crucible.GlobalPair retval globals1 &lt;-</span>
<span class="lineno"> 1435 </span><span class="spaces">              </span><span class="istickedoff">getGlobalPair opts partialResult</span>
<span class="lineno"> 1436 </span><span class="spaces">            </span><span class="istickedoff">let ret_ty = mspec ^. MS.csRet</span>
<span class="lineno"> 1437 </span><span class="spaces">            </span><span class="istickedoff">retval' &lt;-</span>
<span class="lineno"> 1438 </span><span class="spaces">              </span><span class="istickedoff">case ret_ty of</span>
<span class="lineno"> 1439 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno"> 1440 </span><span class="spaces">                </span><span class="istickedoff">Just ret_mt -&gt;</span>
<span class="lineno"> 1441 </span><span class="spaces">                  </span><span class="istickedoff">do v &lt;- Crucible.packMemValue <span class="nottickedoff">sym</span></span>
<span class="lineno"> 1442 </span><span class="spaces">                            </span><span class="istickedoff">(fromMaybe <span class="nottickedoff">(error (&quot;Expected storable type:&quot; ++ show ret_ty))</span></span>
<span class="lineno"> 1443 </span><span class="spaces">                                 </span><span class="istickedoff">(Crucible.toStorableType ret_mt))</span>
<span class="lineno"> 1444 </span><span class="spaces">                            </span><span class="istickedoff">(Crucible.regType  retval)</span>
<span class="lineno"> 1445 </span><span class="spaces">                            </span><span class="istickedoff">(Crucible.regValue retval)</span>
<span class="lineno"> 1446 </span><span class="spaces">                     </span><span class="istickedoff">return (Just (<span class="nottickedoff">ret_mt</span>, v))</span>
<span class="lineno"> 1447 </span><span class="spaces">            </span><span class="istickedoff">return (retval', globals1, MapF.empty)</span>
<span class="lineno"> 1448 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1449 </span><span class="spaces">       </span><span class="istickedoff">Crucible.TimeoutResult _ -&gt; <span class="nottickedoff">fail $ &quot;Symbolic execution timed out&quot;</span></span>
<span class="lineno"> 1450 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1451 </span><span class="spaces">       </span><span class="istickedoff">Crucible.AbortedResult _ ar -&gt;</span>
<span class="lineno"> 1452 </span><span class="spaces">         </span><span class="istickedoff">do let resultDoc = ppAbortedResult cc ar</span>
<span class="lineno"> 1453 </span><span class="spaces">            </span><span class="istickedoff">fail $ unlines [ &quot;Symbolic execution failed.&quot;</span>
<span class="lineno"> 1454 </span><span class="spaces">                           </span><span class="istickedoff">, show resultDoc</span>
<span class="lineno"> 1455 </span><span class="spaces">                           </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1456 </span>
<span class="lineno"> 1457 </span>
<span class="lineno"> 1458 </span>refineSimulate ::
<span class="lineno"> 1459 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1460 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno"> 1461 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1462 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno"> 1463 </span>  , ?singleOverrideSpecialCase :: Bool
<span class="lineno"> 1464 </span>  , Crucible.HasPtrWidth wptr
<span class="lineno"> 1465 </span>  , wptr ~ Crucible.ArchWidth arch
<span class="lineno"> 1466 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1467 </span>  ) =&gt;
<span class="lineno"> 1468 </span>  Options -&gt;
<span class="lineno"> 1469 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 1470 </span>  [Crucible.GenericExecutionFeature Sym] -&gt;
<span class="lineno"> 1471 </span>  MS.CrucibleMethodSpecIR (LLVM arch) -&gt;
<span class="lineno"> 1472 </span>  [(Crucible.MemType, LLVMVal)] -&gt;
<span class="lineno"> 1473 </span>  [Crucible.LabeledPred Term AssumptionReason] -&gt;
<span class="lineno"> 1474 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 1475 </span>  NE.NonEmpty (MS.CrucibleMethodSpecIR (LLVM arch)) -&gt;
<span class="lineno"> 1476 </span>  Crucible.SymGlobalState Sym -&gt;
<span class="lineno"> 1477 </span>  IORef MetadataMap -&gt;
<span class="lineno"> 1478 </span>  IO (Maybe (Crucible.MemType, LLVMVal), Crucible.SymGlobalState Sym)
<span class="lineno"> 1479 </span><span class="decl"><span class="istickedoff">refineSimulate opts cc pfs mspec args assumes top_loc lemmas globals mdMap =</span>
<span class="lineno"> 1480 </span><span class="spaces">  </span><span class="istickedoff">let fstr = mspec^.csName</span>
<span class="lineno"> 1481 </span><span class="spaces">      </span><span class="istickedoff">fsym = L.Symbol fstr</span>
<span class="lineno"> 1482 </span><span class="spaces">      </span><span class="istickedoff">matches dec = matchingStatics (L.decName dec) fsym</span>
<span class="lineno"> 1483 </span><span class="spaces">      </span><span class="istickedoff">simCtx = cc^.ccLLVMSimContext</span>
<span class="lineno"> 1484 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">sym = cc^.ccSym</span></span>
<span class="lineno"> 1485 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1486 </span><span class="spaces">  </span><span class="istickedoff">case filter matches (Crucible.allModuleDeclares (ccLLVMModuleAST cc)) of</span>
<span class="lineno"> 1487 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">fail $ &quot;Couldn't find declaration for `&quot; ++ fstr ++ &quot;` when attempting specification refinement.&quot;</span></span>
<span class="lineno"> 1488 </span><span class="spaces">    </span><span class="istickedoff">(decl:_ds) -&gt;</span>
<span class="lineno"> 1489 </span><span class="spaces">      </span><span class="istickedoff">Crucible.llvmDeclToFunHandleRepr' decl $ \argTys retTy -&gt;</span>
<span class="lineno"> 1490 </span><span class="spaces">      </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1491 </span><span class="spaces">      </span><span class="istickedoff">do args' &lt;- prepareArgs <span class="nottickedoff">sym</span> argTys (map snd args)</span>
<span class="lineno"> 1492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1493 </span><span class="spaces">         </span><span class="istickedoff">let execFeatures =</span>
<span class="lineno"> 1494 </span><span class="spaces">               </span><span class="istickedoff">map <span class="nottickedoff">Crucible.genericToExecutionFeature</span> pfs</span>
<span class="lineno"> 1495 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1496 </span><span class="spaces">         </span><span class="istickedoff">let initExecState =</span>
<span class="lineno"> 1497 </span><span class="spaces">               </span><span class="istickedoff">Crucible.InitialState simCtx globals Crucible.defaultAbortHandler retTy $</span>
<span class="lineno"> 1498 </span><span class="spaces">               </span><span class="istickedoff">Crucible.runOverrideSim retTy $</span>
<span class="lineno"> 1499 </span><span class="spaces">               </span><span class="istickedoff">do Crucible.SomeHandle h &lt;- registerOverride opts cc <span class="nottickedoff">simCtx</span> <span class="nottickedoff">top_loc</span> <span class="nottickedoff">mdMap</span> lemmas</span>
<span class="lineno"> 1500 </span><span class="spaces">                  </span><span class="istickedoff">case (testEquality argTys (Crucible.handleArgTypes h),</span>
<span class="lineno"> 1501 </span><span class="spaces">                        </span><span class="istickedoff">testEquality retTy (Crucible.handleReturnType h)) of</span>
<span class="lineno"> 1502 </span><span class="spaces">                    </span><span class="istickedoff">(Nothing, _) -&gt;</span>
<span class="lineno"> 1503 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;refineSimulate&quot; [</span></span>
<span class="lineno"> 1504 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Argument type mismatch when refining specification for &quot; &lt;&gt;</span></span>
<span class="lineno"> 1505 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">Text.pack fstr,</span></span>
<span class="lineno"> 1506 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Argument types: &quot; &lt;&gt; Text.pack (show argTys),</span></span>
<span class="lineno"> 1507 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Handle: &quot; &lt;&gt; Text.pack (show h)</span></span>
<span class="lineno"> 1508 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1509 </span><span class="spaces">                    </span><span class="istickedoff">(_, Nothing) -&gt;</span>
<span class="lineno"> 1510 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;refineSimulate&quot; [</span></span>
<span class="lineno"> 1511 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Return type mismatch when refining specification for &quot; &lt;&gt;</span></span>
<span class="lineno"> 1512 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">Text.pack fstr,</span></span>
<span class="lineno"> 1513 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Return type: &quot; &lt;&gt; Text.pack (show retTy),</span></span>
<span class="lineno"> 1514 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&quot;Handle: &quot; &lt;&gt; Text.pack (show h)</span></span>
<span class="lineno"> 1515 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1516 </span><span class="spaces">                    </span><span class="istickedoff">(Just Refl, Just Refl) -&gt;</span>
<span class="lineno"> 1517 </span><span class="spaces">                      </span><span class="istickedoff">do liftIO $</span>
<span class="lineno"> 1518 </span><span class="spaces">                          </span><span class="istickedoff">for_ assumes $ \(Crucible.LabeledPred p (md, reason)) -&gt;</span>
<span class="lineno"> 1519 </span><span class="spaces">                           </span><span class="istickedoff">do expr &lt;- resolveSAWPred cc p</span>
<span class="lineno"> 1520 </span><span class="spaces">                              </span><span class="istickedoff">let <span class="nottickedoff">loc = MS.conditionLoc md</span></span>
<span class="lineno"> 1521 </span><span class="spaces">                              </span><span class="istickedoff">Crucible.addAssumption bak</span>
<span class="lineno"> 1522 </span><span class="spaces">                                </span><span class="istickedoff">(Crucible.GenericAssumption <span class="nottickedoff">loc</span> <span class="nottickedoff">reason</span> expr)</span>
<span class="lineno"> 1523 </span><span class="spaces">                         </span><span class="istickedoff">Crucible.regValue &lt;$&gt; (Crucible.callFnVal (Crucible.HandleFnVal h) args')</span>
<span class="lineno"> 1524 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1525 </span><span class="spaces">         </span><span class="istickedoff">res &lt;- Crucible.executeCrucible execFeatures initExecState</span>
<span class="lineno"> 1526 </span><span class="spaces">         </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1527 </span><span class="spaces">           </span><span class="istickedoff">Crucible.FinishedResult _ partialResult -&gt;</span>
<span class="lineno"> 1528 </span><span class="spaces">             </span><span class="istickedoff">do Crucible.GlobalPair retval globals1 &lt;-</span>
<span class="lineno"> 1529 </span><span class="spaces">                  </span><span class="istickedoff">getGlobalPair opts partialResult</span>
<span class="lineno"> 1530 </span><span class="spaces">                </span><span class="istickedoff">let ret_ty = mspec ^. MS.csRet</span>
<span class="lineno"> 1531 </span><span class="spaces">                </span><span class="istickedoff">retval' &lt;-</span>
<span class="lineno"> 1532 </span><span class="spaces">                  </span><span class="istickedoff">case ret_ty of</span>
<span class="lineno"> 1533 </span><span class="spaces">                    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 1534 </span><span class="spaces">                    </span><span class="istickedoff">Just ret_mt -&gt;</span>
<span class="lineno"> 1535 </span><span class="spaces">                      </span><span class="istickedoff">do v &lt;- Crucible.packMemValue <span class="nottickedoff">sym</span></span>
<span class="lineno"> 1536 </span><span class="spaces">                                </span><span class="istickedoff">(fromMaybe <span class="nottickedoff">(error (&quot;Expected storable type:&quot; ++ show ret_ty))</span></span>
<span class="lineno"> 1537 </span><span class="spaces">                                     </span><span class="istickedoff">(Crucible.toStorableType ret_mt))</span>
<span class="lineno"> 1538 </span><span class="spaces">                                </span><span class="istickedoff">(Crucible.regType  retval)</span>
<span class="lineno"> 1539 </span><span class="spaces">                                </span><span class="istickedoff">(Crucible.regValue retval)</span>
<span class="lineno"> 1540 </span><span class="spaces">                         </span><span class="istickedoff">return (Just (<span class="nottickedoff">ret_mt</span>, v))</span>
<span class="lineno"> 1541 </span><span class="spaces">                </span><span class="istickedoff">return (retval', globals1)</span>
<span class="lineno"> 1542 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1543 </span><span class="spaces">           </span><span class="istickedoff">Crucible.TimeoutResult _ -&gt; <span class="nottickedoff">fail $ &quot;Symbolic execution timed out&quot;</span></span>
<span class="lineno"> 1544 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1545 </span><span class="spaces">           </span><span class="istickedoff">Crucible.AbortedResult _ ar -&gt;</span>
<span class="lineno"> 1546 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">do let resultDoc = ppAbortedResult cc ar</span></span>
<span class="lineno"> 1547 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;Symbolic execution failed.&quot;</span></span>
<span class="lineno"> 1548 </span><span class="spaces">                               </span><span class="istickedoff"><span class="nottickedoff">, show resultDoc</span></span>
<span class="lineno"> 1549 </span><span class="spaces">                               </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1550 </span>
<span class="lineno"> 1551 </span>
<span class="lineno"> 1552 </span>prepareArgs ::
<span class="lineno"> 1553 </span>  Sym -&gt;
<span class="lineno"> 1554 </span>  Ctx.Assignment Crucible.TypeRepr xs -&gt;
<span class="lineno"> 1555 </span>  [LLVMVal] -&gt;
<span class="lineno"> 1556 </span>  IO (Crucible.RegMap Sym xs)
<span class="lineno"> 1557 </span><span class="decl"><span class="istickedoff">prepareArgs sym ctx x =</span>
<span class="lineno"> 1558 </span><span class="spaces">  </span><span class="istickedoff">Crucible.RegMap &lt;$&gt;</span>
<span class="lineno"> 1559 </span><span class="spaces">  </span><span class="istickedoff">Ctx.traverseWithIndex (\idx tr -&gt;</span>
<span class="lineno"> 1560 </span><span class="spaces">    </span><span class="istickedoff">do v &lt;- Crucible.unpackMemValue <span class="nottickedoff">sym</span> tr (x !! Ctx.indexVal idx)</span>
<span class="lineno"> 1561 </span><span class="spaces">       </span><span class="istickedoff">return (Crucible.RegEntry tr v))</span>
<span class="lineno"> 1562 </span><span class="spaces">  </span><span class="istickedoff">ctx</span></span>
<span class="lineno"> 1563 </span>
<span class="lineno"> 1564 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1565 </span>
<span class="lineno"> 1566 </span>verifyPoststate ::
<span class="lineno"> 1567 </span>  ( ?lc :: Crucible.TypeContext
<span class="lineno"> 1568 </span>  , ?memOpts::Crucible.MemOptions
<span class="lineno"> 1569 </span>  , ?w4EvalTactic :: W4EvalTactic
<span class="lineno"> 1570 </span>  , ?checkAllocSymInit :: Bool
<span class="lineno"> 1571 </span>  , Crucible.HasPtrWidth wptr
<span class="lineno"> 1572 </span>  , wptr ~ Crucible.ArchWidth arch
<span class="lineno"> 1573 </span>  , Crucible.HasLLVMAnn Sym
<span class="lineno"> 1574 </span>  ) =&gt;
<span class="lineno"> 1575 </span>  LLVMCrucibleContext arch {- ^ crucible context -} -&gt;
<span class="lineno"> 1576 </span>  MS.CrucibleMethodSpecIR (LLVM arch) {- ^ specification -} -&gt;
<span class="lineno"> 1577 </span>  Map AllocIndex (LLVMPtr wptr) {- ^ allocation substitution -} -&gt;
<span class="lineno"> 1578 </span>  Crucible.SymGlobalState Sym {- ^ global variables -} -&gt;
<span class="lineno"> 1579 </span>  Maybe (Crucible.MemType, LLVMVal) {- ^ optional return value -} -&gt;
<span class="lineno"> 1580 </span>  IORef MetadataMap {- ^ metadata map -} -&gt;
<span class="lineno"> 1581 </span>  MapF (W4.SymFnWrapper Sym) (W4.SymFnWrapper Sym) {- ^ invariant substitution -} -&gt;
<span class="lineno"> 1582 </span>  TopLevel ([(String, MS.ConditionMetadata, Term)], OverrideState (LLVM arch))
<span class="lineno"> 1583 </span>    {- ^ generated labels and verification conditions -}
<span class="lineno"> 1584 </span><span class="decl"><span class="istickedoff">verifyPoststate cc mspec env0 globals ret mdMap invSubst =</span>
<span class="lineno"> 1585 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1586 </span><span class="spaces">  </span><span class="istickedoff">do poststateLoc &lt;- toW4Loc &quot;_SAW_LLVM_verifyPoststate&quot; &lt;$&gt; getPosition</span>
<span class="lineno"> 1587 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1588 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1589 </span><span class="spaces">     </span><span class="istickedoff">io $ W4.setCurrentProgramLoc sym poststateLoc</span>
<span class="lineno"> 1590 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1591 </span><span class="spaces">     </span><span class="istickedoff">-- This discards all the obligations generated during</span>
<span class="lineno"> 1592 </span><span class="spaces">     </span><span class="istickedoff">-- symbolic execution itself, i.e., which are not directly</span>
<span class="lineno"> 1593 </span><span class="spaces">     </span><span class="istickedoff">-- generated from specification postconditions. This</span>
<span class="lineno"> 1594 </span><span class="spaces">     </span><span class="istickedoff">-- is, in general, unsound.</span>
<span class="lineno"> 1595 </span><span class="spaces">     </span><span class="istickedoff">skipSafetyProofs &lt;- gets rwSkipSafetyProofs</span>
<span class="lineno"> 1596 </span><span class="spaces">     </span><span class="istickedoff">when skipSafetyProofs <span class="nottickedoff">(io (Crucible.clearProofObligations bak))</span></span>
<span class="lineno"> 1597 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1598 </span><span class="spaces">     </span><span class="istickedoff">let ecs0 = Map.fromList</span>
<span class="lineno"> 1599 </span><span class="spaces">           </span><span class="istickedoff">[ (ecVarIndex ec, ec)</span>
<span class="lineno"> 1600 </span><span class="spaces">           </span><span class="istickedoff">| tt &lt;- mspec ^. MS.csPreState . MS.csFreshVars</span>
<span class="lineno"> 1601 </span><span class="spaces">           </span><span class="istickedoff">, let ec = tecExt tt ]</span>
<span class="lineno"> 1602 </span><span class="spaces">     </span><span class="istickedoff">terms0 &lt;- io $ traverse (scExtCns sc) ecs0</span>
<span class="lineno"> 1603 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1604 </span><span class="spaces">     </span><span class="istickedoff">let initialFree =</span>
<span class="lineno"> 1605 </span><span class="spaces">           </span><span class="istickedoff">Set.fromList</span>
<span class="lineno"> 1606 </span><span class="spaces">           </span><span class="istickedoff">(map (ecVarIndex . tecExt) (view (MS.csPostState . MS.csFreshVars) mspec))</span>
<span class="lineno"> 1607 </span><span class="spaces">     </span><span class="istickedoff">matchPost &lt;-</span>
<span class="lineno"> 1608 </span><span class="spaces">       </span><span class="istickedoff">io $</span>
<span class="lineno"> 1609 </span><span class="spaces">       </span><span class="istickedoff">runOverrideMatcher sym globals env0 terms0 initialFree <span class="nottickedoff">poststateLoc</span> $</span>
<span class="lineno"> 1610 </span><span class="spaces">       </span><span class="istickedoff">do matchResult <span class="nottickedoff">opts</span> sc</span>
<span class="lineno"> 1611 </span><span class="spaces">          </span><span class="istickedoff">learnCond <span class="nottickedoff">opts</span> sc cc mspec PostState</span>
<span class="lineno"> 1612 </span><span class="spaces">            </span><span class="istickedoff">(mspec ^. MS.csGlobalAllocs)</span>
<span class="lineno"> 1613 </span><span class="spaces">            </span><span class="istickedoff">(mspec ^. MS.csPreState . MS.csAllocs)</span>
<span class="lineno"> 1614 </span><span class="spaces">            </span><span class="istickedoff">(mspec ^. MS.csPostState)</span>
<span class="lineno"> 1615 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1616 </span><span class="spaces">     </span><span class="istickedoff">st &lt;-</span>
<span class="lineno"> 1617 </span><span class="spaces">       </span><span class="istickedoff">case matchPost of</span>
<span class="lineno"> 1618 </span><span class="spaces">         </span><span class="istickedoff">Left err      -&gt; <span class="nottickedoff">throwTopLevel (show err)</span></span>
<span class="lineno"> 1619 </span><span class="spaces">         </span><span class="istickedoff">Right (_, st) -&gt; return st</span>
<span class="lineno"> 1620 </span><span class="spaces">     </span><span class="istickedoff">io $ for_ (view osAsserts st) $ \(md,W4.LabeledPred p r) -&gt;</span>
<span class="lineno"> 1621 </span><span class="spaces">       </span><span class="istickedoff">do (ann,p') &lt;- W4.annotateTerm sym p</span>
<span class="lineno"> 1622 </span><span class="spaces">          </span><span class="istickedoff">modifyIORef mdMap (Map.insert ann md)</span>
<span class="lineno"> 1623 </span><span class="spaces">          </span><span class="istickedoff">Crucible.addAssertion bak (Crucible.LabeledPred p' r)</span>
<span class="lineno"> 1624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1625 </span><span class="spaces">     </span><span class="istickedoff">sc_obligations &lt;- io $ getPoststateObligations sc bak mdMap invSubst</span>
<span class="lineno"> 1626 </span><span class="spaces">     </span><span class="istickedoff">return (sc_obligations, st)</span>
<span class="lineno"> 1627 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1628 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1629 </span><span class="spaces">    </span><span class="istickedoff">sym = cc^.ccSym</span>
<span class="lineno"> 1630 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1631 </span><span class="spaces">    </span><span class="istickedoff">matchResult opts sc =</span>
<span class="lineno"> 1632 </span><span class="spaces">      </span><span class="istickedoff">case (ret, mspec ^. MS.csRetValue) of</span>
<span class="lineno"> 1633 </span><span class="spaces">        </span><span class="istickedoff">(Just (rty,r), Just expect) -&gt;</span>
<span class="lineno"> 1634 </span><span class="spaces">          </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 1635 </span><span class="spaces">                   </span><span class="istickedoff">{ MS.conditionLoc = mspec ^. MS.csLoc</span>
<span class="lineno"> 1636 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionTags = mempty -- TODO? should `llvm_return` track tags?</span>
<span class="lineno"> 1637 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionType = &quot;return value matching&quot;</span>
<span class="lineno"> 1638 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionContext = &quot;&quot;</span>
<span class="lineno"> 1639 </span><span class="spaces">                   </span><span class="istickedoff">} in</span>
<span class="lineno"> 1640 </span><span class="spaces">          </span><span class="istickedoff">matchArg <span class="nottickedoff">opts</span> sc cc <span class="nottickedoff">mspec</span> PostState md r <span class="nottickedoff">rty</span> expect</span>
<span class="lineno"> 1641 </span><span class="spaces">        </span><span class="istickedoff">(Nothing     , Just _ )     -&gt;</span>
<span class="lineno"> 1642 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail &quot;verifyPoststate: unexpected llvm_return specification&quot;</span></span>
<span class="lineno"> 1643 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span></span>
<span class="lineno"> 1644 </span>
<span class="lineno"> 1645 </span>-- | Translate the proof obligations from the Crucible backend into SAWCore
<span class="lineno"> 1646 </span>-- terms. For each proof oblication, return a triple consisting of the error
<span class="lineno"> 1647 </span>-- message, the metadata, and the SAWCore. For each proof obligation, substitute
<span class="lineno"> 1648 </span>-- the uninterpreted invariants with their definitions.
<span class="lineno"> 1649 </span>getPoststateObligations ::
<span class="lineno"> 1650 </span>  Crucible.IsSymBackend Sym bak =&gt;
<span class="lineno"> 1651 </span>  SharedContext -&gt;
<span class="lineno"> 1652 </span>  bak -&gt;
<span class="lineno"> 1653 </span>  IORef MetadataMap -&gt;
<span class="lineno"> 1654 </span>  MapF (W4.SymFnWrapper Sym) (W4.SymFnWrapper Sym) {- ^ invariant substitution -} -&gt;
<span class="lineno"> 1655 </span>  IO [(String, MS.ConditionMetadata, Term)]
<span class="lineno"> 1656 </span><span class="decl"><span class="istickedoff">getPoststateObligations sc bak mdMap invSubst =</span>
<span class="lineno"> 1657 </span><span class="spaces">  </span><span class="istickedoff">do obligations &lt;- maybe [] Crucible.goalsToList &lt;$&gt; Crucible.getProofObligations bak</span>
<span class="lineno"> 1658 </span><span class="spaces">     </span><span class="istickedoff">Crucible.clearProofObligations bak</span>
<span class="lineno"> 1659 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1660 </span><span class="spaces">     </span><span class="istickedoff">finalMdMap &lt;- readIORef mdMap</span>
<span class="lineno"> 1661 </span><span class="spaces">     </span><span class="istickedoff">mapM (verifyObligation finalMdMap) obligations</span>
<span class="lineno"> 1662 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1663 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1664 </span><span class="spaces">    </span><span class="istickedoff">sym = Crucible.backendGetSym bak</span>
<span class="lineno"> 1665 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1666 </span><span class="spaces">    </span><span class="istickedoff">verifyObligation finalMdMap (Crucible.ProofGoal hyps (Crucible.LabeledPred concl err@(Crucible.SimError loc _))) =</span>
<span class="lineno"> 1667 </span><span class="spaces">      </span><span class="istickedoff">do st &lt;- Common.sawCoreState sym</span>
<span class="lineno"> 1668 </span><span class="spaces">         </span><span class="istickedoff">hypTerm &lt;- toSC <span class="nottickedoff">sym</span> st =&lt;&lt; W4.substituteSymFns <span class="nottickedoff">sym</span> invSubst =&lt;&lt; Crucible.assumptionsPred sym hyps</span>
<span class="lineno"> 1669 </span><span class="spaces">         </span><span class="istickedoff">conclTerm &lt;- toSC <span class="nottickedoff">sym</span> st =&lt;&lt; W4.substituteSymFns <span class="nottickedoff">sym</span> invSubst concl</span>
<span class="lineno"> 1670 </span><span class="spaces">         </span><span class="istickedoff">obligation &lt;- scImplies sc hypTerm conclTerm</span>
<span class="lineno"> 1671 </span><span class="spaces">         </span><span class="istickedoff">let <span class="nottickedoff">defaultMd = MS.ConditionMetadata</span></span>
<span class="lineno"> 1672 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno"> 1673 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = mempty</span></span>
<span class="lineno"> 1674 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;safety assertion&quot;</span></span>
<span class="lineno"> 1675 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno"> 1676 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 1677 </span><span class="spaces">         </span><span class="istickedoff">let md = fromMaybe <span class="nottickedoff">defaultMd</span> $</span>
<span class="lineno"> 1678 </span><span class="spaces">                    </span><span class="istickedoff">do ann &lt;- W4.getAnnotation <span class="nottickedoff">sym</span> concl</span>
<span class="lineno"> 1679 </span><span class="spaces">                       </span><span class="istickedoff">Map.lookup ann finalMdMap</span>
<span class="lineno"> 1680 </span><span class="spaces">         </span><span class="istickedoff">return (show err, md, obligation)</span></span>
<span class="lineno"> 1681 </span>
<span class="lineno"> 1682 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1683 </span>
<span class="lineno"> 1684 </span>setupLLVMCrucibleContext ::
<span class="lineno"> 1685 </span>  Bool {- ^ enable path sat checking -} -&gt;
<span class="lineno"> 1686 </span>  LLVMModule arch -&gt;
<span class="lineno"> 1687 </span>  ((?lc :: Crucible.TypeContext, ?memOpts::Crucible.MemOptions, ?w4EvalTactic :: W4EvalTactic, ?checkAllocSymInit :: Bool, Crucible.HasPtrWidth (Crucible.ArchWidth arch), Crucible.HasLLVMAnn Sym) =&gt;
<span class="lineno"> 1688 </span>   LLVMCrucibleContext arch -&gt; TopLevel a) -&gt;
<span class="lineno"> 1689 </span>  TopLevel a
<span class="lineno"> 1690 </span><span class="decl"><span class="istickedoff">setupLLVMCrucibleContext pathSat lm action =</span>
<span class="lineno"> 1691 </span><span class="spaces">  </span><span class="istickedoff">do halloc &lt;- getHandleAlloc</span>
<span class="lineno"> 1692 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1693 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1694 </span><span class="spaces">     </span><span class="istickedoff">basic_ss &lt;- getBasicSS</span>
<span class="lineno"> 1695 </span><span class="spaces">     </span><span class="istickedoff">let llvm_mod = modAST lm</span>
<span class="lineno"> 1696 </span><span class="spaces">     </span><span class="istickedoff">let mtrans = modTrans lm</span>
<span class="lineno"> 1697 </span><span class="spaces">     </span><span class="istickedoff">let ctx = mtrans^.Crucible.transContext</span>
<span class="lineno"> 1698 </span><span class="spaces">     </span><span class="istickedoff">smt_array_memory_model_enabled &lt;- gets rwSMTArrayMemoryModel</span>
<span class="lineno"> 1699 </span><span class="spaces">     </span><span class="istickedoff">crucible_assert_then_assume_enabled &lt;- gets rwCrucibleAssertThenAssume</span>
<span class="lineno"> 1700 </span><span class="spaces">     </span><span class="istickedoff">what4HashConsing &lt;- gets rwWhat4HashConsing</span>
<span class="lineno"> 1701 </span><span class="spaces">     </span><span class="istickedoff">what4PushMuxOps &lt;- gets rwWhat4PushMuxOps</span>
<span class="lineno"> 1702 </span><span class="spaces">     </span><span class="istickedoff">laxPointerOrdering &lt;- gets rwLaxPointerOrdering</span>
<span class="lineno"> 1703 </span><span class="spaces">     </span><span class="istickedoff">laxLoadsAndStores &lt;- gets rwLaxLoadsAndStores</span>
<span class="lineno"> 1704 </span><span class="spaces">     </span><span class="istickedoff">noSatisfyingWriteFreshConstant &lt;- gets rwNoSatisfyingWriteFreshConstant</span>
<span class="lineno"> 1705 </span><span class="spaces">     </span><span class="istickedoff">pathSatSolver &lt;- gets rwPathSatSolver</span>
<span class="lineno"> 1706 </span><span class="spaces">     </span><span class="istickedoff">what4Eval &lt;- gets rwWhat4Eval</span>
<span class="lineno"> 1707 </span><span class="spaces">     </span><span class="istickedoff">allocSymInitCheck &lt;- gets rwAllocSymInitCheck</span>
<span class="lineno"> 1708 </span><span class="spaces">     </span><span class="istickedoff">crucibleTimeout &lt;- gets rwCrucibleTimeout</span>
<span class="lineno"> 1709 </span><span class="spaces">     </span><span class="istickedoff">Crucible.llvmPtrWidth ctx $ \wptr -&gt;</span>
<span class="lineno"> 1710 </span><span class="spaces">       </span><span class="istickedoff">Crucible.withPtrWidth wptr $</span>
<span class="lineno"> 1711 </span><span class="spaces">       </span><span class="istickedoff">do let ?lc = ctx^.Crucible.llvmTypeCtx</span>
<span class="lineno"> 1712 </span><span class="spaces">          </span><span class="istickedoff">let ?memOpts = Crucible.defaultMemOptions</span>
<span class="lineno"> 1713 </span><span class="spaces">                          </span><span class="istickedoff">{ Crucible.laxPointerOrdering = laxPointerOrdering</span>
<span class="lineno"> 1714 </span><span class="spaces">                          </span><span class="istickedoff">, Crucible.laxLoadsAndStores = laxLoadsAndStores</span>
<span class="lineno"> 1715 </span><span class="spaces">                          </span><span class="istickedoff">, Crucible.noSatisfyingWriteFreshConstant = noSatisfyingWriteFreshConstant</span>
<span class="lineno"> 1716 </span><span class="spaces">                          </span><span class="istickedoff">}</span>
<span class="lineno"> 1717 </span><span class="spaces">          </span><span class="istickedoff">let ?intrinsicsOpts = Crucible.defaultIntrinsicsOptions</span>
<span class="lineno"> 1718 </span><span class="spaces">          </span><span class="istickedoff">let ?recordLLVMAnnotation = \_ _ _ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1719 </span><span class="spaces">          </span><span class="istickedoff">let ?w4EvalTactic = W4EvalTactic { doW4Eval = what4Eval }</span>
<span class="lineno"> 1720 </span><span class="spaces">          </span><span class="istickedoff">let ?checkAllocSymInit = allocSymInitCheck</span>
<span class="lineno"> 1721 </span><span class="spaces">          </span><span class="istickedoff">cc &lt;-</span>
<span class="lineno"> 1722 </span><span class="spaces">            </span><span class="istickedoff">io $</span>
<span class="lineno"> 1723 </span><span class="spaces">            </span><span class="istickedoff">do let verbosity = simVerbose opts</span>
<span class="lineno"> 1724 </span><span class="spaces">               </span><span class="istickedoff">sym &lt;- Common.newSAWCoreExprBuilder sc <span class="nottickedoff">False</span></span>
<span class="lineno"> 1725 </span><span class="spaces">               </span><span class="istickedoff">Common.SomeOnlineBackend bak &lt;-</span>
<span class="lineno"> 1726 </span><span class="spaces">                 </span><span class="istickedoff">Common.newSAWCoreBackendWithTimeout pathSatSolver sym crucibleTimeout</span>
<span class="lineno"> 1727 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1728 </span><span class="spaces">               </span><span class="istickedoff">let cfg = W4.getConfiguration sym</span>
<span class="lineno"> 1729 </span><span class="spaces">               </span><span class="istickedoff">verbSetting &lt;- W4.getOptionSetting W4.verbosity cfg</span>
<span class="lineno"> 1730 </span><span class="spaces">               </span><span class="istickedoff">_ &lt;- W4.setOpt verbSetting (toInteger verbosity)</span>
<span class="lineno"> 1731 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1732 </span><span class="spaces">               </span><span class="istickedoff">cacheTermsSetting &lt;- W4.getOptionSetting W4.cacheTerms cfg</span>
<span class="lineno"> 1733 </span><span class="spaces">               </span><span class="istickedoff">_ &lt;- W4.setOpt cacheTermsSetting what4HashConsing</span>
<span class="lineno"> 1734 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1735 </span><span class="spaces">               </span><span class="istickedoff">pushMuxOpsSetting &lt;- W4.getOptionSetting W4.pushMuxOpsOption cfg</span>
<span class="lineno"> 1736 </span><span class="spaces">               </span><span class="istickedoff">_ &lt;- W4.setOpt pushMuxOpsSetting what4PushMuxOps</span>
<span class="lineno"> 1737 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1738 </span><span class="spaces">               </span><span class="istickedoff">-- enable online solver interactions if path sat checking is on</span>
<span class="lineno"> 1739 </span><span class="spaces">               </span><span class="istickedoff">enableOnlineSetting &lt;- W4.getOptionSetting Crucible.enableOnlineBackend cfg</span>
<span class="lineno"> 1740 </span><span class="spaces">               </span><span class="istickedoff">_ &lt;- W4.setOpt enableOnlineSetting pathSat</span>
<span class="lineno"> 1741 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1742 </span><span class="spaces">               </span><span class="istickedoff">W4.extendConfig</span>
<span class="lineno"> 1743 </span><span class="spaces">                 </span><span class="istickedoff">[ W4.opt</span>
<span class="lineno"> 1744 </span><span class="spaces">                     </span><span class="istickedoff">enableSMTArrayMemoryModel</span>
<span class="lineno"> 1745 </span><span class="spaces">                     </span><span class="istickedoff">(W4.ConcreteBool smt_array_memory_model_enabled)</span>
<span class="lineno"> 1746 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">(&quot;Enable SMT array memory model&quot; :: Text.Text)</span></span>
<span class="lineno"> 1747 </span><span class="spaces">                 </span><span class="istickedoff">]</span>
<span class="lineno"> 1748 </span><span class="spaces">                 </span><span class="istickedoff">cfg</span>
<span class="lineno"> 1749 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1750 </span><span class="spaces">               </span><span class="istickedoff">crucible_assert_then_assume_option_setting &lt;- W4.getOptionSetting</span>
<span class="lineno"> 1751 </span><span class="spaces">                 </span><span class="istickedoff">Crucible.assertThenAssumeConfigOption</span>
<span class="lineno"> 1752 </span><span class="spaces">                 </span><span class="istickedoff">cfg</span>
<span class="lineno"> 1753 </span><span class="spaces">               </span><span class="istickedoff">_ &lt;- W4.setOpt</span>
<span class="lineno"> 1754 </span><span class="spaces">                 </span><span class="istickedoff">crucible_assert_then_assume_option_setting</span>
<span class="lineno"> 1755 </span><span class="spaces">                 </span><span class="istickedoff">crucible_assert_then_assume_enabled</span>
<span class="lineno"> 1756 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1757 </span><span class="spaces">               </span><span class="istickedoff">let bindings = Crucible.fnBindingsFromList []</span>
<span class="lineno"> 1758 </span><span class="spaces">               </span><span class="istickedoff">let simctx   = Crucible.initSimContext bak</span>
<span class="lineno"> 1759 </span><span class="spaces">                                 </span><span class="istickedoff">intrinsics halloc stdout</span>
<span class="lineno"> 1760 </span><span class="spaces">                                 </span><span class="istickedoff">bindings (Crucible.llvmExtensionImpl ?memOpts)</span>
<span class="lineno"> 1761 </span><span class="spaces">                                 </span><span class="istickedoff">Common.SAWCruciblePersonality</span>
<span class="lineno"> 1762 </span><span class="spaces">               </span><span class="istickedoff">mem &lt;- Crucible.populateConstGlobals bak (view Crucible.globalInitMap mtrans)</span>
<span class="lineno"> 1763 </span><span class="spaces">                        </span><span class="istickedoff">=&lt;&lt; Crucible.initializeMemoryConstGlobals bak ctx llvm_mod</span>
<span class="lineno"> 1764 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1765 </span><span class="spaces">               </span><span class="istickedoff">let globals  = Crucible.llvmGlobals (Crucible.llvmMemVar ctx) mem</span>
<span class="lineno"> 1766 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1767 </span><span class="spaces">               </span><span class="istickedoff">let setupMem =</span>
<span class="lineno"> 1768 </span><span class="spaces">                     </span><span class="istickedoff">do -- register all the functions defined in the LLVM module</span>
<span class="lineno"> 1769 </span><span class="spaces">                        </span><span class="istickedoff">Crucible.registerLazyModule (handleTranslationWarning opts) mtrans</span>
<span class="lineno"> 1770 </span><span class="spaces">                        </span><span class="istickedoff">-- register the callable override functions</span>
<span class="lineno"> 1771 </span><span class="spaces">                        </span><span class="istickedoff">_ &lt;- Crucible.register_llvm_overrides llvm_mod saw_llvm_overrides saw_llvm_overrides ctx</span>
<span class="lineno"> 1772 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1773 </span><span class="spaces">                        </span><span class="istickedoff">pure ()</span>
<span class="lineno"> 1774 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1775 </span><span class="spaces">               </span><span class="istickedoff">let initExecState =</span>
<span class="lineno"> 1776 </span><span class="spaces">                     </span><span class="istickedoff">Crucible.InitialState simctx globals Crucible.defaultAbortHandler Crucible.UnitRepr $</span>
<span class="lineno"> 1777 </span><span class="spaces">                     </span><span class="istickedoff">Crucible.runOverrideSim Crucible.UnitRepr setupMem</span>
<span class="lineno"> 1778 </span><span class="spaces">               </span><span class="istickedoff">res &lt;- Crucible.executeCrucible [] initExecState</span>
<span class="lineno"> 1779 </span><span class="spaces">               </span><span class="istickedoff">(lglobals, lsimctx) &lt;-</span>
<span class="lineno"> 1780 </span><span class="spaces">                   </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1781 </span><span class="spaces">                     </span><span class="istickedoff">Crucible.FinishedResult st (Crucible.TotalRes gp) -&gt; return (gp^.Crucible.gpGlobals, st)</span>
<span class="lineno"> 1782 </span><span class="spaces">                     </span><span class="istickedoff">Crucible.FinishedResult st (Crucible.PartialRes _ _ gp _) -&gt;</span>
<span class="lineno"> 1783 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">return (gp^.Crucible.gpGlobals, st)</span></span>
<span class="lineno"> 1784 </span><span class="spaces">                     </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;simulator initialization failed!&quot;</span></span>
<span class="lineno"> 1785 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1786 </span><span class="spaces">               </span><span class="istickedoff">return</span>
<span class="lineno"> 1787 </span><span class="spaces">                  </span><span class="istickedoff">LLVMCrucibleContext{ _ccLLVMModule = lm</span>
<span class="lineno"> 1788 </span><span class="spaces">                                     </span><span class="istickedoff">, _ccBackend = Common.SomeOnlineBackend bak</span>
<span class="lineno"> 1789 </span><span class="spaces">                                     </span><span class="istickedoff">, _ccLLVMSimContext = lsimctx</span>
<span class="lineno"> 1790 </span><span class="spaces">                                     </span><span class="istickedoff">, _ccLLVMGlobals = lglobals</span>
<span class="lineno"> 1791 </span><span class="spaces">                                     </span><span class="istickedoff">, _ccBasicSS = basic_ss</span>
<span class="lineno"> 1792 </span><span class="spaces">                                     </span><span class="istickedoff">}</span>
<span class="lineno"> 1793 </span><span class="spaces">          </span><span class="istickedoff">action cc</span></span>
<span class="lineno"> 1794 </span>
<span class="lineno"> 1795 </span>
<span class="lineno"> 1796 </span>handleTranslationWarning :: Options -&gt; Crucible.LLVMTranslationWarning -&gt; IO ()
<span class="lineno"> 1797 </span><span class="decl"><span class="istickedoff">handleTranslationWarning opts (Crucible.LLVMTranslationWarning s p msg) =</span>
<span class="lineno"> 1798 </span><span class="spaces">  </span><span class="istickedoff">printOutLn opts Warn $ unwords</span>
<span class="lineno"> 1799 </span><span class="spaces">    </span><span class="istickedoff">[ &quot;LLVM bitcode translation warning&quot;</span>
<span class="lineno"> 1800 </span><span class="spaces">    </span><span class="istickedoff">, show (Crucible.ppSymbol s)</span>
<span class="lineno"> 1801 </span><span class="spaces">    </span><span class="istickedoff">, show p</span>
<span class="lineno"> 1802 </span><span class="spaces">    </span><span class="istickedoff">, Text.unpack msg</span>
<span class="lineno"> 1803 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1804 </span>
<span class="lineno"> 1805 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1806 </span>
<span class="lineno"> 1807 </span>saw_llvm_overrides ::
<span class="lineno"> 1808 </span>  ( Crucible.IsSymInterface sym, Crucible.HasLLVMAnn sym, Crucible.HasPtrWidth wptr ) =&gt;
<span class="lineno"> 1809 </span>  [Crucible.OverrideTemplate p sym ext arch]
<span class="lineno"> 1810 </span><span class="decl"><span class="istickedoff">saw_llvm_overrides =</span>
<span class="lineno"> 1811 </span><span class="spaces">  </span><span class="istickedoff">[ Crucible.basic_llvm_override saw_assert_override</span>
<span class="lineno"> 1812 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1813 </span>
<span class="lineno"> 1814 </span>saw_assert_override ::
<span class="lineno"> 1815 </span>  ( Crucible.IsSymInterface sym, Crucible.HasLLVMAnn sym, Crucible.HasPtrWidth wptr ) =&gt;
<span class="lineno"> 1816 </span>  Crucible.LLVMOverride p sym ext
<span class="lineno"> 1817 </span>    (Crucible.EmptyCtx Crucible.::&gt; Crucible.BVType 32)
<span class="lineno"> 1818 </span>    Crucible.UnitType
<span class="lineno"> 1819 </span><span class="decl"><span class="istickedoff">saw_assert_override =</span>
<span class="lineno"> 1820 </span><span class="spaces">  </span><span class="istickedoff">[llvmOvr|<span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"> void @saw_assert( i32 ) |]</span></span></span></span></span></span>
<span class="lineno"> 1821 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(\_memOps (Ctx.Empty Ctx.:&gt; p) -&gt;</span></span>
<span class="lineno"> 1822 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">Crucible.ovrWithBackend $ \bak -&gt;</span></span>
<span class="lineno"> 1823 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">do let sym = Crucible.backendGetSym bak</span></span>
<span class="lineno"> 1824 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let msg = Crucible.GenericSimError &quot;saw_assert&quot;</span></span>
<span class="lineno"> 1825 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftIO $</span></span>
<span class="lineno"> 1826 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do loc &lt;- W4.getCurrentProgramLoc sym</span></span>
<span class="lineno"> 1827 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">cond &lt;- W4.bvIsNonzero sym (Crucible.regValue p)</span></span>
<span class="lineno"> 1828 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">putStrLn $ unlines [&quot;SAW assert!&quot;, show loc, show (W4.printSymExpr cond)]</span></span>
<span class="lineno"> 1829 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">Crucible.addDurableAssertion bak (Crucible.LabeledPred cond (Crucible.SimError loc msg))</span></span>
<span class="lineno"> 1830 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">Crucible.addAssumption bak (Crucible.GenericAssumption loc &quot;crucible_assume&quot; cond)</span></span>
<span class="lineno"> 1831 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">)</span></span></span>
<span class="lineno"> 1832 </span>
<span class="lineno"> 1833 </span>baseCryptolType :: Crucible.BaseTypeRepr tp -&gt; Maybe Cryptol.Type
<span class="lineno"> 1834 </span><span class="decl"><span class="istickedoff">baseCryptolType bt =</span>
<span class="lineno"> 1835 </span><span class="spaces">  </span><span class="istickedoff">case bt of</span>
<span class="lineno"> 1836 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseBoolRepr -&gt; <span class="nottickedoff">pure $ Cryptol.tBit</span></span>
<span class="lineno"> 1837 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseBVRepr w -&gt; pure $ Cryptol.tWord (Cryptol.tNum (natValue w))</span>
<span class="lineno"> 1838 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseIntegerRepr -&gt; <span class="nottickedoff">pure $ Cryptol.tInteger</span></span>
<span class="lineno"> 1839 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseArrayRepr {} -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1840 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseFloatRepr _ -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1841 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseStringRepr _ -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1842 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseComplexRepr  -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1843 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseRealRepr     -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1844 </span><span class="spaces">    </span><span class="istickedoff">Crucible.BaseStructRepr ts -&gt;</span>
<span class="lineno"> 1845 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Cryptol.tTuple &lt;$&gt; baseCryptolTypes ts</span></span>
<span class="lineno"> 1846 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1847 </span><span class="spaces">    </span><span class="istickedoff">baseCryptolTypes :: Ctx.Assignment Crucible.BaseTypeRepr args -&gt; Maybe [Cryptol.Type]</span>
<span class="lineno"> 1848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">baseCryptolTypes Ctx.Empty = pure []</span></span>
<span class="lineno"> 1849 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">baseCryptolTypes (xs Ctx.:&gt; x) =</span></span>
<span class="lineno"> 1850 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do ts &lt;- baseCryptolTypes xs</span></span>
<span class="lineno"> 1851 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">t &lt;- baseCryptolType x</span></span>
<span class="lineno"> 1852 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">pure (ts ++ [t])</span></span></span>
<span class="lineno"> 1853 </span>
<span class="lineno"> 1854 </span>setupArg ::
<span class="lineno"> 1855 </span>  forall tp.
<span class="lineno"> 1856 </span>  SharedContext -&gt;
<span class="lineno"> 1857 </span>  Sym -&gt;
<span class="lineno"> 1858 </span>  IORef (Seq TypedExtCns) -&gt;
<span class="lineno"> 1859 </span>  Crucible.TypeRepr tp -&gt;
<span class="lineno"> 1860 </span>  IO (Crucible.RegEntry Sym tp)
<span class="lineno"> 1861 </span><span class="decl"><span class="istickedoff">setupArg sc sym ecRef tp = do</span>
<span class="lineno"> 1862 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- Common.sawCoreState sym</span>
<span class="lineno"> 1863 </span><span class="spaces">  </span><span class="istickedoff">case (Crucible.asBaseType tp, tp) of</span>
<span class="lineno"> 1864 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.AsBaseType btp, _) -&gt;</span>
<span class="lineno"> 1865 </span><span class="spaces">      </span><span class="istickedoff">do cty &lt;-</span>
<span class="lineno"> 1866 </span><span class="spaces">           </span><span class="istickedoff">case baseCryptolType btp of</span>
<span class="lineno"> 1867 </span><span class="spaces">             </span><span class="istickedoff">Just cty -&gt; pure cty</span>
<span class="lineno"> 1868 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1869 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">fail $ unwords [&quot;Unsupported type for Crucible extraction:&quot;, show btp]</span></span>
<span class="lineno"> 1870 </span><span class="spaces">         </span><span class="istickedoff">sc_tp &lt;- baseSCType <span class="nottickedoff">sym</span> sc btp</span>
<span class="lineno"> 1871 </span><span class="spaces">         </span><span class="istickedoff">t     &lt;- freshGlobal cty sc_tp</span>
<span class="lineno"> 1872 </span><span class="spaces">         </span><span class="istickedoff">elt   &lt;- bindSAWTerm sym st btp t</span>
<span class="lineno"> 1873 </span><span class="spaces">         </span><span class="istickedoff">return (Crucible.RegEntry tp elt)</span>
<span class="lineno"> 1874 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1875 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.NotBaseType, Crucible.LLVMPointerRepr w) -&gt;</span>
<span class="lineno"> 1876 </span><span class="spaces">      </span><span class="istickedoff">do let cty = Cryptol.tWord (Cryptol.tNum (natValue w))</span>
<span class="lineno"> 1877 </span><span class="spaces">         </span><span class="istickedoff">sc_tp &lt;- scBitvector sc (natValue w)</span>
<span class="lineno"> 1878 </span><span class="spaces">         </span><span class="istickedoff">t     &lt;- freshGlobal cty sc_tp</span>
<span class="lineno"> 1879 </span><span class="spaces">         </span><span class="istickedoff">elt   &lt;- bindSAWTerm sym st (Crucible.BaseBVRepr w) t</span>
<span class="lineno"> 1880 </span><span class="spaces">         </span><span class="istickedoff">elt'  &lt;- Crucible.llvmPointer_bv sym elt</span>
<span class="lineno"> 1881 </span><span class="spaces">         </span><span class="istickedoff">return (Crucible.RegEntry tp elt')</span>
<span class="lineno"> 1882 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1883 </span><span class="spaces">    </span><span class="istickedoff">(Crucible.NotBaseType, _) -&gt;</span>
<span class="lineno"> 1884 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail $ unwords [&quot;Crucible extraction currently only supports Crucible base types&quot;, show tp]</span></span>
<span class="lineno"> 1885 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1886 </span><span class="spaces">    </span><span class="istickedoff">freshGlobal cty sc_tp =</span>
<span class="lineno"> 1887 </span><span class="spaces">      </span><span class="istickedoff">do ecs &lt;- readIORef ecRef</span>
<span class="lineno"> 1888 </span><span class="spaces">         </span><span class="istickedoff">let len = Seq.length ecs</span>
<span class="lineno"> 1889 </span><span class="spaces">         </span><span class="istickedoff">ec &lt;- scFreshEC sc (&quot;arg_&quot; &lt;&gt; Text.pack (show len)) sc_tp</span>
<span class="lineno"> 1890 </span><span class="spaces">         </span><span class="istickedoff">writeIORef ecRef (ecs Seq.|&gt; TypedExtCns cty ec)</span>
<span class="lineno"> 1891 </span><span class="spaces">         </span><span class="istickedoff">scFlatTermF sc (ExtCns ec)</span></span>
<span class="lineno"> 1892 </span>
<span class="lineno"> 1893 </span>setupArgs ::
<span class="lineno"> 1894 </span>  SharedContext -&gt;
<span class="lineno"> 1895 </span>  Sym -&gt;
<span class="lineno"> 1896 </span>  Crucible.FnHandle init ret -&gt;
<span class="lineno"> 1897 </span>  IO (Seq TypedExtCns, Crucible.RegMap Sym init)
<span class="lineno"> 1898 </span><span class="decl"><span class="istickedoff">setupArgs sc sym fn =</span>
<span class="lineno"> 1899 </span><span class="spaces">  </span><span class="istickedoff">do ecRef  &lt;- newIORef Seq.empty</span>
<span class="lineno"> 1900 </span><span class="spaces">     </span><span class="istickedoff">regmap &lt;- Crucible.RegMap &lt;$&gt; Ctx.traverseFC (setupArg sc sym ecRef) (Crucible.handleArgTypes fn)</span>
<span class="lineno"> 1901 </span><span class="spaces">     </span><span class="istickedoff">ecs    &lt;- readIORef ecRef</span>
<span class="lineno"> 1902 </span><span class="spaces">     </span><span class="istickedoff">return (ecs, regmap)</span></span>
<span class="lineno"> 1903 </span>
<span class="lineno"> 1904 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1905 </span>
<span class="lineno"> 1906 </span>getGlobalPair ::
<span class="lineno"> 1907 </span>  Options -&gt;
<span class="lineno"> 1908 </span>  Crucible.PartialResult sym ext v -&gt;
<span class="lineno"> 1909 </span>  IO (Crucible.GlobalPair sym v)
<span class="lineno"> 1910 </span><span class="decl"><span class="istickedoff">getGlobalPair opts pr =</span>
<span class="lineno"> 1911 </span><span class="spaces">  </span><span class="istickedoff">case pr of</span>
<span class="lineno"> 1912 </span><span class="spaces">    </span><span class="istickedoff">Crucible.TotalRes gp -&gt; return gp</span>
<span class="lineno"> 1913 </span><span class="spaces">    </span><span class="istickedoff">Crucible.PartialRes _ _ gp _ -&gt; do</span>
<span class="lineno"> 1914 </span><span class="spaces">      </span><span class="istickedoff">printOutLn opts Info &quot;Symbolic simulation completed with side conditions.&quot;</span>
<span class="lineno"> 1915 </span><span class="spaces">      </span><span class="istickedoff">return gp</span></span>
<span class="lineno"> 1916 </span>
<span class="lineno"> 1917 </span>runCFG ::
<span class="lineno"> 1918 </span>  (Crucible.IsSyntaxExtension ext, Crucible.IsSymInterface sym) =&gt;
<span class="lineno"> 1919 </span>  Crucible.SimContext p sym ext -&gt;
<span class="lineno"> 1920 </span>  Crucible.SymGlobalState sym -&gt;
<span class="lineno"> 1921 </span>  Crucible.FnHandle args a -&gt;
<span class="lineno"> 1922 </span>  Crucible.CFG ext blocks init a -&gt;
<span class="lineno"> 1923 </span>  Crucible.RegMap sym init -&gt;
<span class="lineno"> 1924 </span>  IO (Crucible.ExecResult p sym ext (Crucible.RegEntry sym a))
<span class="lineno"> 1925 </span><span class="decl"><span class="istickedoff">runCFG simCtx globals h cfg args =</span>
<span class="lineno"> 1926 </span><span class="spaces">  </span><span class="istickedoff">do let initExecState =</span>
<span class="lineno"> 1927 </span><span class="spaces">           </span><span class="istickedoff">Crucible.InitialState simCtx globals Crucible.defaultAbortHandler (Crucible.handleReturnType h) $</span>
<span class="lineno"> 1928 </span><span class="spaces">           </span><span class="istickedoff">Crucible.runOverrideSim (Crucible.handleReturnType h)</span>
<span class="lineno"> 1929 </span><span class="spaces">                    </span><span class="istickedoff">(Crucible.regValue &lt;$&gt; (Crucible.callCFG cfg args))</span>
<span class="lineno"> 1930 </span><span class="spaces">     </span><span class="istickedoff">Crucible.executeCrucible [] initExecState</span></span>
<span class="lineno"> 1931 </span>
<span class="lineno"> 1932 </span>extractFromLLVMCFG ::
<span class="lineno"> 1933 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno"> 1934 </span>  Options -&gt; SharedContext -&gt; LLVMCrucibleContext arch -&gt; Crucible.AnyCFG Crucible.LLVM -&gt; IO TypedTerm
<span class="lineno"> 1935 </span><span class="decl"><span class="istickedoff">extractFromLLVMCFG opts sc cc (Crucible.AnyCFG cfg) =</span>
<span class="lineno"> 1936 </span><span class="spaces">  </span><span class="istickedoff">ccWithBackend cc $ \bak -&gt;</span>
<span class="lineno"> 1937 </span><span class="spaces">  </span><span class="istickedoff">do let sym = Common.backendGetSym bak</span>
<span class="lineno"> 1938 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- Common.sawCoreState sym</span>
<span class="lineno"> 1939 </span><span class="spaces">     </span><span class="istickedoff">let h   = Crucible.cfgHandle cfg</span>
<span class="lineno"> 1940 </span><span class="spaces">     </span><span class="istickedoff">(ecs, args) &lt;- setupArgs sc sym h</span>
<span class="lineno"> 1941 </span><span class="spaces">     </span><span class="istickedoff">let simCtx  = cc^.ccLLVMSimContext</span>
<span class="lineno"> 1942 </span><span class="spaces">     </span><span class="istickedoff">let globals = cc^.ccLLVMGlobals</span>
<span class="lineno"> 1943 </span><span class="spaces">     </span><span class="istickedoff">res &lt;- runCFG simCtx globals h cfg args</span>
<span class="lineno"> 1944 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1945 </span><span class="spaces">       </span><span class="istickedoff">Crucible.FinishedResult _ pr -&gt;</span>
<span class="lineno"> 1946 </span><span class="spaces">         </span><span class="istickedoff">do gp &lt;- getGlobalPair <span class="nottickedoff">opts</span> pr</span>
<span class="lineno"> 1947 </span><span class="spaces">            </span><span class="istickedoff">let regv = gp^.Crucible.gpValue</span>
<span class="lineno"> 1948 </span><span class="spaces">                </span><span class="istickedoff">rt = Crucible.regType regv</span>
<span class="lineno"> 1949 </span><span class="spaces">                </span><span class="istickedoff">rv = Crucible.regValue regv</span>
<span class="lineno"> 1950 </span><span class="spaces">            </span><span class="istickedoff">tt &lt;-</span>
<span class="lineno"> 1951 </span><span class="spaces">              </span><span class="istickedoff">case rt of</span>
<span class="lineno"> 1952 </span><span class="spaces">                </span><span class="istickedoff">Crucible.LLVMPointerRepr w -&gt;</span>
<span class="lineno"> 1953 </span><span class="spaces">                  </span><span class="istickedoff">do bv &lt;- Crucible.projectLLVM_bv bak rv</span>
<span class="lineno"> 1954 </span><span class="spaces">                     </span><span class="istickedoff">t &lt;- toSC <span class="nottickedoff">sym</span> st bv</span>
<span class="lineno"> 1955 </span><span class="spaces">                     </span><span class="istickedoff">let cty = Cryptol.tWord (Cryptol.tNum (natValue w))</span>
<span class="lineno"> 1956 </span><span class="spaces">                     </span><span class="istickedoff">pure $ TypedTerm (TypedTermSchema (Cryptol.tMono cty)) t</span>
<span class="lineno"> 1957 </span><span class="spaces">                </span><span class="istickedoff">Crucible.BVRepr w -&gt;</span>
<span class="lineno"> 1958 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">do t &lt;- toSC sym st rv</span></span>
<span class="lineno"> 1959 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">let cty = Cryptol.tWord (Cryptol.tNum (natValue w))</span></span>
<span class="lineno"> 1960 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">pure $ TypedTerm (TypedTermSchema (Cryptol.tMono cty)) t</span></span>
<span class="lineno"> 1961 </span><span class="spaces">                </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ unwords [&quot;Unexpected return type:&quot;, show rt]</span></span>
<span class="lineno"> 1962 </span><span class="spaces">            </span><span class="istickedoff">tt' &lt;- abstractTypedExts sc (toList ecs) tt</span>
<span class="lineno"> 1963 </span><span class="spaces">            </span><span class="istickedoff">pure tt'</span>
<span class="lineno"> 1964 </span><span class="spaces">       </span><span class="istickedoff">Crucible.AbortedResult _ ar -&gt;</span>
<span class="lineno"> 1965 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">do let resultDoc = ppAbortedResult cc ar</span></span>
<span class="lineno"> 1966 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;Symbolic execution failed.&quot;</span></span>
<span class="lineno"> 1967 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">, show resultDoc</span></span>
<span class="lineno"> 1968 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1969 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1970 </span><span class="spaces">       </span><span class="istickedoff">Crucible.TimeoutResult _ -&gt;</span>
<span class="lineno"> 1971 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Symbolic execution timed out.&quot;</span></span></span>
<span class="lineno"> 1972 </span>
<span class="lineno"> 1973 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1974 </span>
<span class="lineno"> 1975 </span>llvm_extract ::
<span class="lineno"> 1976 </span>  Some LLVMModule -&gt;
<span class="lineno"> 1977 </span>  String -&gt;
<span class="lineno"> 1978 </span>  TopLevel TypedTerm
<span class="lineno"> 1979 </span><span class="decl"><span class="istickedoff">llvm_extract (Some lm) fn_name =</span>
<span class="lineno"> 1980 </span><span class="spaces">  </span><span class="istickedoff">do let <span class="nottickedoff">ctx = modTrans lm ^. Crucible.transContext</span></span>
<span class="lineno"> 1981 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = <span class="nottickedoff">ctx^.Crucible.llvmTypeCtx</span></span>
<span class="lineno"> 1982 </span><span class="spaces">     </span><span class="istickedoff">let edef = findDefMaybeStatic (modAST lm) fn_name</span>
<span class="lineno"> 1983 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1984 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1985 </span><span class="spaces">     </span><span class="istickedoff">case edef of</span>
<span class="lineno"> 1986 </span><span class="spaces">       </span><span class="istickedoff">Right defs -&gt;</span>
<span class="lineno"> 1987 </span><span class="spaces">         </span><span class="istickedoff">do let defTypes =</span>
<span class="lineno"> 1988 </span><span class="spaces">                  </span><span class="istickedoff">fold $</span>
<span class="lineno"> 1989 </span><span class="spaces">                  </span><span class="istickedoff">NE.map (map L.typedType . L.defArgs) defs &lt;&gt;</span>
<span class="lineno"> 1990 </span><span class="spaces">                  </span><span class="istickedoff">NE.map (\d -&gt; [L.defRetType d]) defs</span>
<span class="lineno"> 1991 </span><span class="spaces">            </span><span class="istickedoff">when (any L.isPointer defTypes) $</span>
<span class="lineno"> 1992 </span><span class="spaces">              </span><span class="istickedoff">throwTopLevel &quot;Pointer types are not supported by `llvm_extract`.&quot;</span>
<span class="lineno"> 1993 </span><span class="spaces">            </span><span class="istickedoff">when (any L.isAlias defTypes) $</span>
<span class="lineno"> 1994 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">throwTopLevel &quot;Type aliases are not supported by `llvm_extract`.&quot;</span></span>
<span class="lineno"> 1995 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">throwTopLevel (displayVerifExceptionOpts opts err)</span></span>
<span class="lineno"> 1996 </span><span class="spaces">     </span><span class="istickedoff">setupLLVMCrucibleContext False lm $ \cc -&gt;</span>
<span class="lineno"> 1997 </span><span class="spaces">       </span><span class="istickedoff">io (Crucible.getTranslatedCFG (ccLLVMModuleTrans cc) (fromString fn_name)) &gt;&gt;= \case</span>
<span class="lineno"> 1998 </span><span class="spaces">         </span><span class="istickedoff">Nothing  -&gt; <span class="nottickedoff">throwTopLevel $ unwords [&quot;function&quot;, fn_name, &quot;not found&quot;]</span></span>
<span class="lineno"> 1999 </span><span class="spaces">         </span><span class="istickedoff">Just (_,cfg,warns) -&gt;</span>
<span class="lineno"> 2000 </span><span class="spaces">           </span><span class="istickedoff">do io $ mapM_ <span class="nottickedoff">(handleTranslationWarning opts)</span> warns</span>
<span class="lineno"> 2001 </span><span class="spaces">              </span><span class="istickedoff">io $ extractFromLLVMCFG <span class="nottickedoff">opts</span> sc cc cfg</span></span>
<span class="lineno"> 2002 </span>
<span class="lineno"> 2003 </span>llvm_cfg ::
<span class="lineno"> 2004 </span>  Some LLVMModule -&gt;
<span class="lineno"> 2005 </span>  String -&gt;
<span class="lineno"> 2006 </span>  TopLevel SAW_CFG
<span class="lineno"> 2007 </span><span class="decl"><span class="nottickedoff">llvm_cfg (Some lm) fn_name =</span>
<span class="lineno"> 2008 </span><span class="spaces">  </span><span class="nottickedoff">do let ctx = modTrans lm ^. Crucible.transContext</span>
<span class="lineno"> 2009 </span><span class="spaces">     </span><span class="nottickedoff">let ?lc = ctx^.Crucible.llvmTypeCtx</span>
<span class="lineno"> 2010 </span><span class="spaces">     </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 2011 </span><span class="spaces">     </span><span class="nottickedoff">setupLLVMCrucibleContext False lm $ \cc -&gt;</span>
<span class="lineno"> 2012 </span><span class="spaces">       </span><span class="nottickedoff">io (Crucible.getTranslatedCFG (ccLLVMModuleTrans cc) (fromString fn_name)) &gt;&gt;= \case</span>
<span class="lineno"> 2013 </span><span class="spaces">         </span><span class="nottickedoff">Nothing  -&gt; throwTopLevel $ unwords [&quot;function&quot;, fn_name, &quot;not found&quot;]</span>
<span class="lineno"> 2014 </span><span class="spaces">         </span><span class="nottickedoff">Just (_,cfg,warns) -&gt;</span>
<span class="lineno"> 2015 </span><span class="spaces">           </span><span class="nottickedoff">do io $ mapM_ (handleTranslationWarning opts) warns</span>
<span class="lineno"> 2016 </span><span class="spaces">              </span><span class="nottickedoff">return (LLVM_CFG cfg)</span></span>
<span class="lineno"> 2017 </span>
<span class="lineno"> 2018 </span>--------------------------------------------------------------------------------
<span class="lineno"> 2019 </span>--------------------------------------------------------------------------------
<span class="lineno"> 2020 </span>
<span class="lineno"> 2021 </span>showMemTypeDiff :: ([Maybe Int], Crucible.MemType, Crucible.MemType) -&gt; String
<span class="lineno"> 2022 </span><span class="decl"><span class="istickedoff">showMemTypeDiff (path, l, r) = showPath path</span>
<span class="lineno"> 2023 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">showStep Nothing  = &quot;element type&quot;</span></span>
<span class="lineno"> 2025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">showStep (Just i) = &quot;field &quot; ++ show i</span></span>
<span class="lineno"> 2026 </span><span class="spaces">    </span><span class="istickedoff">showPath []       = &quot;&quot;</span>
<span class="lineno"> 2027 </span><span class="spaces">    </span><span class="istickedoff">showPath [x]      = <span class="nottickedoff">unlines [showStep x ++ &quot;:&quot;, &quot;  &quot; ++ show l, &quot;  &quot; ++ show r]</span></span>
<span class="lineno"> 2028 </span><span class="spaces">    </span><span class="istickedoff">showPath (x : xs) = <span class="nottickedoff">showStep x ++ &quot; -&gt; &quot; ++ showPath xs</span></span></span>
<span class="lineno"> 2029 </span>
<span class="lineno"> 2030 </span>-- | Succeed if the types have compatible memory layouts. Otherwise,
<span class="lineno"> 2031 </span>-- fail with a detailed message indicating how the types differ.
<span class="lineno"> 2032 </span>checkMemTypeCompatibility ::
<span class="lineno"> 2033 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno"> 2034 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 2035 </span>  Crucible.MemType -&gt;
<span class="lineno"> 2036 </span>  Crucible.MemType -&gt;
<span class="lineno"> 2037 </span>  CrucibleSetup (LLVM arch) ()
<span class="lineno"> 2038 </span><span class="decl"><span class="istickedoff">checkMemTypeCompatibility loc t1 t2 =</span>
<span class="lineno"> 2039 </span><span class="spaces">  </span><span class="istickedoff">case diffMemTypes t1 t2 of</span>
<span class="lineno"> 2040 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 2041 </span><span class="spaces">    </span><span class="istickedoff">diffs -&gt;</span>
<span class="lineno"> 2042 </span><span class="spaces">      </span><span class="istickedoff">throwCrucibleSetup loc $ unlines $</span>
<span class="lineno"> 2043 </span><span class="spaces">      </span><span class="istickedoff">[&quot;types not memory-compatible:&quot;, show t1, show t2]</span>
<span class="lineno"> 2044 </span><span class="spaces">      </span><span class="istickedoff">++ map showMemTypeDiff diffs</span></span>
<span class="lineno"> 2045 </span>
<span class="lineno"> 2046 </span>--------------------------------------------------------------------------------
<span class="lineno"> 2047 </span>-- Setup builtins
<span class="lineno"> 2048 </span>
<span class="lineno"> 2049 </span>llvm_assert :: TypedTerm -&gt; LLVMCrucibleSetupM ()
<span class="lineno"> 2050 </span><span class="decl"><span class="istickedoff">llvm_assert term =</span>
<span class="lineno"> 2051 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2052 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position <span class="nottickedoff">&quot;llvm_assert&quot;</span></span>
<span class="lineno"> 2053 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2054 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno"> 2055 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno"> 2056 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = tags</span></span>
<span class="lineno"> 2057 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;specification assertion&quot;</span></span>
<span class="lineno"> 2058 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno"> 2059 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 2060 </span><span class="spaces">     </span><span class="istickedoff">Setup.addCondition (MS.SetupCond_Pred <span class="nottickedoff">md</span> term)</span></span>
<span class="lineno"> 2061 </span>
<span class="lineno"> 2062 </span>llvm_precond :: TypedTerm -&gt; LLVMCrucibleSetupM ()
<span class="lineno"> 2063 </span><span class="decl"><span class="istickedoff">llvm_precond term =</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2065 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position &quot;llvm_precond&quot;</span>
<span class="lineno"> 2066 </span><span class="spaces">     </span><span class="istickedoff">Setup.crucible_precond loc term</span></span>
<span class="lineno"> 2067 </span>
<span class="lineno"> 2068 </span>llvm_postcond :: TypedTerm -&gt; LLVMCrucibleSetupM ()
<span class="lineno"> 2069 </span><span class="decl"><span class="istickedoff">llvm_postcond term =</span>
<span class="lineno"> 2070 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2071 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position &quot;llvm_postcond&quot;</span>
<span class="lineno"> 2072 </span><span class="spaces">     </span><span class="istickedoff">Setup.crucible_postcond loc term</span></span>
<span class="lineno"> 2073 </span>
<span class="lineno"> 2074 </span>llvm_return ::
<span class="lineno"> 2075 </span>  AllLLVM MS.SetupValue -&gt;
<span class="lineno"> 2076 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2077 </span><span class="decl"><span class="istickedoff">llvm_return val =</span>
<span class="lineno"> 2078 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2079 </span><span class="spaces">  </span><span class="istickedoff">do Setup.crucible_return (getAllLLVM val)</span></span>
<span class="lineno"> 2080 </span>
<span class="lineno"> 2081 </span>llvm_execute_func ::
<span class="lineno"> 2082 </span>  [AllLLVM MS.SetupValue] -&gt;
<span class="lineno"> 2083 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2084 </span><span class="decl"><span class="istickedoff">llvm_execute_func args =</span>
<span class="lineno"> 2085 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $ Setup.crucible_execute_func (map (\a -&gt; getAllLLVM a) args)</span></span>
<span class="lineno"> 2086 </span>
<span class="lineno"> 2087 </span>getLLVMCrucibleContext :: CrucibleSetup (LLVM arch) (LLVMCrucibleContext arch)
<span class="lineno"> 2088 </span><span class="decl"><span class="istickedoff">getLLVMCrucibleContext = view Setup.csCrucibleContext &lt;$&gt; get</span></span>
<span class="lineno"> 2089 </span>
<span class="lineno"> 2090 </span>-- | Returns Cryptol type of actual type if it is an array or primitive
<span class="lineno"> 2091 </span>-- type, or an appropriately-sized bit vector for pointer types.
<span class="lineno"> 2092 </span>cryptolTypeOfActual :: Crucible.DataLayout -&gt; Crucible.MemType -&gt; Maybe Cryptol.Type
<span class="lineno"> 2093 </span><span class="decl"><span class="istickedoff">cryptolTypeOfActual dl mt =</span>
<span class="lineno"> 2094 </span><span class="spaces">  </span><span class="istickedoff">case mt of</span>
<span class="lineno"> 2095 </span><span class="spaces">    </span><span class="istickedoff">Crucible.IntType w -&gt;</span>
<span class="lineno"> 2096 </span><span class="spaces">      </span><span class="istickedoff">return $ Cryptol.tWord (Cryptol.tNum w)</span>
<span class="lineno"> 2097 </span><span class="spaces">    </span><span class="istickedoff">Crucible.FloatType -&gt;</span>
<span class="lineno"> 2098 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Nothing</span> -- FIXME: update when Cryptol gets float types</span>
<span class="lineno"> 2099 </span><span class="spaces">    </span><span class="istickedoff">Crucible.DoubleType -&gt;</span>
<span class="lineno"> 2100 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Nothing</span> -- FIXME: update when Cryptol gets float types</span>
<span class="lineno"> 2101 </span><span class="spaces">    </span><span class="istickedoff">Crucible.ArrayType n ty -&gt;</span>
<span class="lineno"> 2102 </span><span class="spaces">      </span><span class="istickedoff">do cty &lt;- cryptolTypeOfActual <span class="nottickedoff">dl</span> ty</span>
<span class="lineno"> 2103 </span><span class="spaces">         </span><span class="istickedoff">return $ Cryptol.tSeq (Cryptol.tNum n) cty</span>
<span class="lineno"> 2104 </span><span class="spaces">    </span><span class="istickedoff">Crucible.PtrType _ -&gt;</span>
<span class="lineno"> 2105 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return cryptolPtrType</span></span>
<span class="lineno"> 2106 </span><span class="spaces">    </span><span class="istickedoff">Crucible.PtrOpaqueType -&gt;</span>
<span class="lineno"> 2107 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return cryptolPtrType</span></span>
<span class="lineno"> 2108 </span><span class="spaces">    </span><span class="istickedoff">Crucible.StructType si -&gt;</span>
<span class="lineno"> 2109 </span><span class="spaces">      </span><span class="istickedoff">do let memtypes = V.toList (Crucible.siFieldTypes si)</span>
<span class="lineno"> 2110 </span><span class="spaces">         </span><span class="istickedoff">ctys &lt;- traverse (cryptolTypeOfActual <span class="nottickedoff">dl</span>) memtypes</span>
<span class="lineno"> 2111 </span><span class="spaces">         </span><span class="istickedoff">case ctys of</span>
<span class="lineno"> 2112 </span><span class="spaces">           </span><span class="istickedoff">[cty] -&gt; return cty</span>
<span class="lineno"> 2113 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; return $ Cryptol.tTuple ctys</span>
<span class="lineno"> 2114 </span><span class="spaces">    </span><span class="istickedoff">Crucible.X86_FP80Type -&gt;</span>
<span class="lineno"> 2115 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2116 </span><span class="spaces">    </span><span class="istickedoff">Crucible.VecType{} -&gt;</span>
<span class="lineno"> 2117 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2118 </span><span class="spaces">    </span><span class="istickedoff">Crucible.MetadataType -&gt;</span>
<span class="lineno"> 2119 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2120 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2121 </span><span class="spaces">    </span><span class="istickedoff">cryptolPtrType :: Cryptol.Type</span>
<span class="lineno"> 2122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">cryptolPtrType = Cryptol.tWord (Cryptol.tNum (Crucible.ptrBitwidth dl))</span></span></span>
<span class="lineno"> 2123 </span>
<span class="lineno"> 2124 </span>-- | Generate a fresh variable term. The name will be used when
<span class="lineno"> 2125 </span>-- pretty-printing the variable in debug output.
<span class="lineno"> 2126 </span>llvm_fresh_var ::
<span class="lineno"> 2127 </span>  Text                    {- ^ variable name    -} -&gt;
<span class="lineno"> 2128 </span>  L.Type                  {- ^ variable type    -} -&gt;
<span class="lineno"> 2129 </span>  LLVMCrucibleSetupM TypedTerm {- ^ fresh typed term -}
<span class="lineno"> 2130 </span><span class="decl"><span class="istickedoff">llvm_fresh_var name lty =</span>
<span class="lineno"> 2131 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2132 </span><span class="spaces">  </span><span class="istickedoff">do cctx &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2133 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = ccTypeCtx cctx</span>
<span class="lineno"> 2134 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position <span class="nottickedoff">&quot;llvm_fresh_var&quot;</span></span>
<span class="lineno"> 2135 </span><span class="spaces">     </span><span class="istickedoff">lty' &lt;- memTypeForLLVMType <span class="nottickedoff">loc</span> lty</span>
<span class="lineno"> 2136 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- lift $ lift getSharedContext</span>
<span class="lineno"> 2137 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">dl = Crucible.llvmDataLayout (ccTypeCtx cctx)</span></span>
<span class="lineno"> 2138 </span><span class="spaces">     </span><span class="istickedoff">case cryptolTypeOfActual <span class="nottickedoff">dl</span> lty' of</span>
<span class="lineno"> 2139 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ &quot;Unsupported type in llvm_fresh_var: &quot; ++ show (Crucible.ppType lty)</span></span>
<span class="lineno"> 2140 </span><span class="spaces">       </span><span class="istickedoff">Just cty -&gt; Setup.freshVariable sc name cty</span></span>
<span class="lineno"> 2141 </span>
<span class="lineno"> 2142 </span>llvm_fresh_cryptol_var ::
<span class="lineno"> 2143 </span>  Text -&gt;
<span class="lineno"> 2144 </span>  Cryptol.Schema -&gt;
<span class="lineno"> 2145 </span>  LLVMCrucibleSetupM TypedTerm
<span class="lineno"> 2146 </span><span class="decl"><span class="istickedoff">llvm_fresh_cryptol_var name s =</span>
<span class="lineno"> 2147 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2148 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position <span class="nottickedoff">&quot;llvm_fresh_var&quot;</span></span>
<span class="lineno"> 2149 </span><span class="spaces">     </span><span class="istickedoff">case s of</span>
<span class="lineno"> 2150 </span><span class="spaces">       </span><span class="istickedoff">Cryptol.Forall [] [] ty -&gt;</span>
<span class="lineno"> 2151 </span><span class="spaces">         </span><span class="istickedoff">do sc &lt;- lift $ lift getSharedContext</span>
<span class="lineno"> 2152 </span><span class="spaces">            </span><span class="istickedoff">Setup.freshVariable sc name ty</span>
<span class="lineno"> 2153 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 2154 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">throwCrucibleSetup loc $ &quot;Unsupported polymorphic Cryptol type schema: &quot; ++ show s</span></span></span>
<span class="lineno"> 2155 </span>
<span class="lineno"> 2156 </span>-- | Use the given LLVM type to compute a setup value that
<span class="lineno"> 2157 </span>-- covers expands all of the struct, array, and pointer
<span class="lineno"> 2158 </span>-- components of the LLVM type. Only the primitive types
<span class="lineno"> 2159 </span>-- suitable for import as SAW core terms will be matched
<span class="lineno"> 2160 </span>-- against fresh variables.
<span class="lineno"> 2161 </span>llvm_fresh_expanded_val ::
<span class="lineno"> 2162 </span>  L.Type         {- ^ variable type          -} -&gt;
<span class="lineno"> 2163 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2164 </span>                 {- ^ elaborated setup value -}
<span class="lineno"> 2165 </span><span class="decl"><span class="istickedoff">llvm_fresh_expanded_val lty =</span>
<span class="lineno"> 2166 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2167 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- lift $ lift getSharedContext</span>
<span class="lineno"> 2168 </span><span class="spaces">     </span><span class="istickedoff">cctx &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2169 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = <span class="nottickedoff">ccTypeCtx cctx</span></span>
<span class="lineno"> 2170 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position <span class="nottickedoff">&quot;llvm_fresh_expanded_val&quot;</span></span>
<span class="lineno"> 2171 </span><span class="spaces">     </span><span class="istickedoff">lty' &lt;- memTypeForLLVMType <span class="nottickedoff">loc</span> lty</span>
<span class="lineno"> 2172 </span><span class="spaces">     </span><span class="istickedoff">constructExpandedSetupValue <span class="nottickedoff">cctx</span> sc <span class="nottickedoff">loc</span> lty'</span></span>
<span class="lineno"> 2173 </span>
<span class="lineno"> 2174 </span>-- | See 'llvm_fresh_expanded_val'
<span class="lineno"> 2175 </span>--
<span class="lineno"> 2176 </span>-- This is the recursively-called worker function.
<span class="lineno"> 2177 </span>constructExpandedSetupValue ::
<span class="lineno"> 2178 </span>  (?lc :: Crucible.TypeContext, Crucible.HasPtrWidth (Crucible.ArchWidth arch)) =&gt;
<span class="lineno"> 2179 </span>  LLVMCrucibleContext arch -&gt;
<span class="lineno"> 2180 </span>  SharedContext -&gt;
<span class="lineno"> 2181 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 2182 </span>  Crucible.MemType {- ^ LLVM mem type -} -&gt;
<span class="lineno"> 2183 </span>  CrucibleSetup (LLVM arch) (AllLLVM SetupValue)
<span class="lineno"> 2184 </span><span class="decl"><span class="istickedoff">constructExpandedSetupValue cc sc loc t =</span>
<span class="lineno"> 2185 </span><span class="spaces">  </span><span class="istickedoff">case t of</span>
<span class="lineno"> 2186 </span><span class="spaces">    </span><span class="istickedoff">Crucible.IntType w -&gt;</span>
<span class="lineno"> 2187 </span><span class="spaces">      </span><span class="istickedoff">do let cty = Cryptol.tWord (Cryptol.tNum w)</span>
<span class="lineno"> 2188 </span><span class="spaces">         </span><span class="istickedoff">fv &lt;- Setup.freshVariable sc &quot;&quot; cty</span>
<span class="lineno"> 2189 </span><span class="spaces">         </span><span class="istickedoff">pure $ mkAllLLVM (SetupTerm fv)</span>
<span class="lineno"> 2190 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2191 </span><span class="spaces">    </span><span class="istickedoff">Crucible.StructType si -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno"> 2192 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fields &lt;- toList &lt;$&gt;</span></span>
<span class="lineno"> 2193 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">traverse (constructExpandedSetupValue cc sc loc)</span></span>
<span class="lineno"> 2194 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">(Crucible.siFieldTypes si)</span></span>
<span class="lineno"> 2195 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">-- FIXME: should this always be unpacked?</span></span>
<span class="lineno"> 2196 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pure $ mkAllLLVM $ SetupStruct False $ map (\a -&gt; getAllLLVM a) fields</span></span>
<span class="lineno"> 2197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2198 </span><span class="spaces">    </span><span class="istickedoff">Crucible.PtrType symTy -&gt;</span>
<span class="lineno"> 2199 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case Crucible.asMemType symTy of</span></span>
<span class="lineno"> 2200 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Right memTy -&gt; constructFreshPointer (symTypeAlias symTy) loc memTy</span></span>
<span class="lineno"> 2201 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Left err -&gt; throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 2202 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[ &quot;lhs not a valid pointer type: &quot; ++ show symTy</span></span>
<span class="lineno"> 2203 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, &quot;Details:&quot;</span></span>
<span class="lineno"> 2204 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, err</span></span>
<span class="lineno"> 2205 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2206 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2207 </span><span class="spaces">    </span><span class="istickedoff">Crucible.ArrayType n memTy -&gt; do</span>
<span class="lineno"> 2208 </span><span class="spaces">      </span><span class="istickedoff">elements_ &lt;-</span>
<span class="lineno"> 2209 </span><span class="spaces">        </span><span class="istickedoff">replicateM (fromIntegral n) (constructExpandedSetupValue <span class="nottickedoff">cc</span> sc <span class="nottickedoff">loc</span> memTy)</span>
<span class="lineno"> 2210 </span><span class="spaces">      </span><span class="istickedoff">pure $ mkAllLLVM $ SetupArray () $ map (\a -&gt; getAllLLVM a) elements_</span>
<span class="lineno"> 2211 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2212 </span><span class="spaces">    </span><span class="istickedoff">Crucible.FloatType      -&gt; <span class="nottickedoff">failUnsupportedType &quot;Float&quot;</span></span>
<span class="lineno"> 2213 </span><span class="spaces">    </span><span class="istickedoff">Crucible.DoubleType     -&gt; <span class="nottickedoff">failUnsupportedType &quot;Double&quot;</span></span>
<span class="lineno"> 2214 </span><span class="spaces">    </span><span class="istickedoff">Crucible.MetadataType   -&gt; <span class="nottickedoff">failUnsupportedType &quot;Metadata&quot;</span></span>
<span class="lineno"> 2215 </span><span class="spaces">    </span><span class="istickedoff">Crucible.VecType{}      -&gt; <span class="nottickedoff">failUnsupportedType &quot;Vec&quot;</span></span>
<span class="lineno"> 2216 </span><span class="spaces">    </span><span class="istickedoff">Crucible.X86_FP80Type{} -&gt; <span class="nottickedoff">failUnsupportedType &quot;X86_FP80&quot;</span></span>
<span class="lineno"> 2217 </span><span class="spaces">    </span><span class="istickedoff">-- See https://github.com/GaloisInc/saw-script/issues/1879 for why it is</span>
<span class="lineno"> 2218 </span><span class="spaces">    </span><span class="istickedoff">-- tricky to support opaque pointers here.</span>
<span class="lineno"> 2219 </span><span class="spaces">    </span><span class="istickedoff">Crucible.PtrOpaqueType  -&gt;</span>
<span class="lineno"> 2220 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;constructExpandedSetupValue&quot; [</span></span>
<span class="lineno"> 2221 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;llvm_fresh_expanded_val does not support opaque pointers&quot;,</span></span>
<span class="lineno"> 2222 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Please report this at: https://github.com/GaloisInc/saw-script/issues/1879&quot;</span></span>
<span class="lineno"> 2223 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2224 </span><span class="spaces">  </span><span class="istickedoff">where <span class="nottickedoff">failUnsupportedType tyName = throwCrucibleSetup loc $ unwords</span></span>
<span class="lineno"> 2225 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;llvm_fresh_expanded_var: &quot; ++ tyName ++ &quot; not supported&quot;]</span></span></span>
<span class="lineno"> 2226 </span>
<span class="lineno"> 2227 </span>
<span class="lineno"> 2228 </span>memTypeForLLVMType ::
<span class="lineno"> 2229 </span>  (?lc :: Crucible.TypeContext) =&gt;
<span class="lineno"> 2230 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 2231 </span>  L.Type -&gt;
<span class="lineno"> 2232 </span>  CrucibleSetup arch Crucible.MemType
<span class="lineno"> 2233 </span><span class="decl"><span class="istickedoff">memTypeForLLVMType loc lty =</span>
<span class="lineno"> 2234 </span><span class="spaces">  </span><span class="istickedoff">case Crucible.liftMemType lty of</span>
<span class="lineno"> 2235 </span><span class="spaces">    </span><span class="istickedoff">Right m -&gt; return m</span>
<span class="lineno"> 2236 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 2237 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;unsupported type: &quot; ++ show (Crucible.ppType lty)</span></span>
<span class="lineno"> 2238 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Details:&quot;</span></span>
<span class="lineno"> 2239 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, err</span></span>
<span class="lineno"> 2240 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 2241 </span>
<span class="lineno"> 2242 </span>llvm_sizeof ::
<span class="lineno"> 2243 </span>  Some LLVMModule -&gt;
<span class="lineno"> 2244 </span>  L.Type -&gt;
<span class="lineno"> 2245 </span>  TopLevel Integer
<span class="lineno"> 2246 </span><span class="decl"><span class="istickedoff">llvm_sizeof (Some lm) lty =</span>
<span class="lineno"> 2247 </span><span class="spaces">  </span><span class="istickedoff">do let mtrans = modTrans lm</span>
<span class="lineno"> 2248 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = mtrans ^. Crucible.transContext . Crucible.llvmTypeCtx</span>
<span class="lineno"> 2249 </span><span class="spaces">     </span><span class="istickedoff">let dl = Crucible.llvmDataLayout ?lc</span>
<span class="lineno"> 2250 </span><span class="spaces">     </span><span class="istickedoff">case Crucible.liftMemType lty of</span>
<span class="lineno"> 2251 </span><span class="spaces">       </span><span class="istickedoff">Right mty -&gt; pure (Crucible.bytesToInteger (Crucible.memTypeSize dl mty))</span>
<span class="lineno"> 2252 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt; fail $ unlines</span>
<span class="lineno"> 2253 </span><span class="spaces">         </span><span class="istickedoff">[ &quot;llvm_sizeof: Unsupported type: &quot; ++ show (Crucible.ppType lty)</span>
<span class="lineno"> 2254 </span><span class="spaces">         </span><span class="istickedoff">, &quot;Details:&quot;</span>
<span class="lineno"> 2255 </span><span class="spaces">         </span><span class="istickedoff">, err</span>
<span class="lineno"> 2256 </span><span class="spaces">         </span><span class="istickedoff">]</span></span>
<span class="lineno"> 2257 </span>
<span class="lineno"> 2258 </span>llvmTypeAlias :: L.Type -&gt; Maybe Crucible.Ident
<span class="lineno"> 2259 </span><span class="decl"><span class="istickedoff">llvmTypeAlias (L.Alias i) = Just i</span>
<span class="lineno"> 2260 </span><span class="spaces"></span><span class="istickedoff">llvmTypeAlias _ = Nothing</span></span>
<span class="lineno"> 2261 </span>
<span class="lineno"> 2262 </span>symTypeAlias :: Crucible.SymType -&gt; Maybe Crucible.Ident
<span class="lineno"> 2263 </span><span class="decl"><span class="nottickedoff">symTypeAlias (Crucible.Alias i) = Just i</span>
<span class="lineno"> 2264 </span><span class="spaces"></span><span class="nottickedoff">symTypeAlias _ = Nothing</span></span>
<span class="lineno"> 2265 </span>
<span class="lineno"> 2266 </span>-- | Does the hard work for 'llvm_alloc', 'llvm_alloc_with_size',
<span class="lineno"> 2267 </span>--   'llvm_alloc_readonly', etc.
<span class="lineno"> 2268 </span>llvm_alloc_internal ::
<span class="lineno"> 2269 </span>  L.Type  -&gt;
<span class="lineno"> 2270 </span>  LLVMAllocSpec  -&gt;
<span class="lineno"> 2271 </span>  CrucibleSetup (LLVM arch) (AllLLVM SetupValue)
<span class="lineno"> 2272 </span><span class="decl"><span class="istickedoff">llvm_alloc_internal lty spec =</span>
<span class="lineno"> 2273 </span><span class="spaces">  </span><span class="istickedoff">do cctx &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2274 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = <span class="nottickedoff">ccTypeCtx cctx</span></span>
<span class="lineno"> 2275 </span><span class="spaces">     </span><span class="istickedoff">let ?dl = <span class="nottickedoff">Crucible.llvmDataLayout ?lc</span></span>
<span class="lineno"> 2276 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- Setup.csVarCounter &lt;&lt;%= nextAllocIndex</span>
<span class="lineno"> 2277 </span><span class="spaces">     </span><span class="istickedoff">Setup.currentState . MS.csAllocs . at n ?= spec</span>
<span class="lineno"> 2278 </span><span class="spaces">     </span><span class="istickedoff">-- TODO: refactor</span>
<span class="lineno"> 2279 </span><span class="spaces">     </span><span class="istickedoff">case llvmTypeAlias lty of</span>
<span class="lineno"> 2280 </span><span class="spaces">       </span><span class="istickedoff">Just i -&gt; Setup.currentState . MS.csVarTypeNames.at n ?= i</span>
<span class="lineno"> 2281 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 2282 </span><span class="spaces">     </span><span class="istickedoff">return (mkAllLLVM (SetupVar n))</span></span>
<span class="lineno"> 2283 </span>
<span class="lineno"> 2284 </span>llvm_alloc_with_mutability_and_size ::
<span class="lineno"> 2285 </span>  Crucible.Mutability    -&gt;
<span class="lineno"> 2286 </span>  Maybe (Crucible.Bytes) -&gt;
<span class="lineno"> 2287 </span>  Maybe Crucible.Alignment -&gt;
<span class="lineno"> 2288 </span>  LLVMAllocSpecInit -&gt;
<span class="lineno"> 2289 </span>  L.Type           -&gt;
<span class="lineno"> 2290 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2291 </span><span class="decl"><span class="istickedoff">llvm_alloc_with_mutability_and_size mut sz alignment initialization lty =</span>
<span class="lineno"> 2292 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2293 </span><span class="spaces">  </span><span class="istickedoff">do cctx &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2294 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position &quot;llvm_alloc&quot;</span>
<span class="lineno"> 2295 </span><span class="spaces">     </span><span class="istickedoff">memTy &lt;- memTypeForLLVMType <span class="nottickedoff">loc</span> lty</span>
<span class="lineno"> 2296 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- lift $ lift getOptions</span>
<span class="lineno"> 2297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2298 </span><span class="spaces">     </span><span class="istickedoff">let lc = ccTypeCtx cctx</span>
<span class="lineno"> 2299 </span><span class="spaces">     </span><span class="istickedoff">let dl = Crucible.llvmDataLayout lc</span>
<span class="lineno"> 2300 </span><span class="spaces">     </span><span class="istickedoff">let memTySize = Crucible.memTypeSize dl memTy</span>
<span class="lineno"> 2301 </span><span class="spaces">     </span><span class="istickedoff">let memTyAlign = Crucible.memTypeAlign dl memTy</span>
<span class="lineno"> 2302 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2303 </span><span class="spaces">     </span><span class="istickedoff">sz' &lt;-</span>
<span class="lineno"> 2304 </span><span class="spaces">       </span><span class="istickedoff">case sz of</span>
<span class="lineno"> 2305 </span><span class="spaces">         </span><span class="istickedoff">Just sz_ -&gt;</span>
<span class="lineno"> 2306 </span><span class="spaces">           </span><span class="istickedoff">do when (sz_ &lt; memTySize) $ <span class="nottickedoff">throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 2307 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ &quot;User error: manually-specified allocation size was less than needed&quot;</span></span>
<span class="lineno"> 2308 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Needed for this type: &quot; ++ show memTySize</span></span>
<span class="lineno"> 2309 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Specified: &quot; ++ show sz_</span></span>
<span class="lineno"> 2310 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2311 </span><span class="spaces">              </span><span class="istickedoff">pure sz_</span>
<span class="lineno"> 2312 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; pure (Crucible.toBytes memTySize)</span>
<span class="lineno"> 2313 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2314 </span><span class="spaces">     </span><span class="istickedoff">sz'' &lt;- liftIO $ scPtrWidthBvNat cctx sz'</span>
<span class="lineno"> 2315 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2316 </span><span class="spaces">     </span><span class="istickedoff">alignment' &lt;-</span>
<span class="lineno"> 2317 </span><span class="spaces">       </span><span class="istickedoff">case alignment of</span>
<span class="lineno"> 2318 </span><span class="spaces">         </span><span class="istickedoff">Just a -&gt;</span>
<span class="lineno"> 2319 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">do when (a &lt; memTyAlign) $ liftIO $ printOutLn opts Info $ unlines</span></span>
<span class="lineno"> 2320 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Warning: manually-specified alignment was less than default for type&quot;</span></span>
<span class="lineno"> 2321 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Allocation type: &quot; ++ show memTy</span></span>
<span class="lineno"> 2322 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Default alignment for type: &quot; ++ show (Crucible.fromAlignment memTyAlign) ++ &quot;-byte&quot;</span></span>
<span class="lineno"> 2323 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, &quot;Specified alignment: &quot; ++ show (Crucible.fromAlignment a) ++ &quot;-byte&quot;</span></span>
<span class="lineno"> 2324 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2325 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">pure a</span></span>
<span class="lineno"> 2326 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; pure $! memTyAlign</span>
<span class="lineno"> 2327 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2328 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2329 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 2330 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 2331 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 2332 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;fresh allocation&quot;</span></span>
<span class="lineno"> 2333 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 2334 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 2335 </span><span class="spaces">     </span><span class="istickedoff">llvm_alloc_internal lty $</span>
<span class="lineno"> 2336 </span><span class="spaces">       </span><span class="istickedoff">LLVMAllocSpec</span>
<span class="lineno"> 2337 </span><span class="spaces">       </span><span class="istickedoff">{ _allocSpecMut = mut</span>
<span class="lineno"> 2338 </span><span class="spaces">       </span><span class="istickedoff">, _allocSpecType = memTy</span>
<span class="lineno"> 2339 </span><span class="spaces">       </span><span class="istickedoff">, _allocSpecAlign = alignment'</span>
<span class="lineno"> 2340 </span><span class="spaces">       </span><span class="istickedoff">, _allocSpecBytes = sz''</span>
<span class="lineno"> 2341 </span><span class="spaces">       </span><span class="istickedoff">, _allocSpecMd = md</span>
<span class="lineno"> 2342 </span><span class="spaces">       </span><span class="istickedoff">, _allocSpecFresh = False</span>
<span class="lineno"> 2343 </span><span class="spaces">       </span><span class="istickedoff">, _allocSpecInit = initialization</span>
<span class="lineno"> 2344 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno"> 2345 </span>
<span class="lineno"> 2346 </span>llvm_alloc ::
<span class="lineno"> 2347 </span>  L.Type         -&gt;
<span class="lineno"> 2348 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2349 </span><span class="decl"><span class="istickedoff">llvm_alloc =</span>
<span class="lineno"> 2350 </span><span class="spaces">  </span><span class="istickedoff">llvm_alloc_with_mutability_and_size Crucible.Mutable Nothing Nothing LLVMAllocSpecNoInitialization</span></span>
<span class="lineno"> 2351 </span>
<span class="lineno"> 2352 </span>llvm_alloc_aligned ::
<span class="lineno"> 2353 </span>  Int            -&gt;
<span class="lineno"> 2354 </span>  L.Type         -&gt;
<span class="lineno"> 2355 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2356 </span><span class="decl"><span class="nottickedoff">llvm_alloc_aligned =</span>
<span class="lineno"> 2357 </span><span class="spaces">  </span><span class="nottickedoff">llvm_alloc_aligned_with_mutability Crucible.Mutable</span></span>
<span class="lineno"> 2358 </span>
<span class="lineno"> 2359 </span>llvm_alloc_readonly ::
<span class="lineno"> 2360 </span>  L.Type         -&gt;
<span class="lineno"> 2361 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2362 </span><span class="decl"><span class="istickedoff">llvm_alloc_readonly =</span>
<span class="lineno"> 2363 </span><span class="spaces">  </span><span class="istickedoff">llvm_alloc_with_mutability_and_size Crucible.Immutable Nothing Nothing LLVMAllocSpecNoInitialization</span></span>
<span class="lineno"> 2364 </span>
<span class="lineno"> 2365 </span>llvm_alloc_readonly_aligned ::
<span class="lineno"> 2366 </span>  Int            -&gt;
<span class="lineno"> 2367 </span>  L.Type         -&gt;
<span class="lineno"> 2368 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2369 </span><span class="decl"><span class="nottickedoff">llvm_alloc_readonly_aligned =</span>
<span class="lineno"> 2370 </span><span class="spaces">  </span><span class="nottickedoff">llvm_alloc_aligned_with_mutability Crucible.Immutable</span></span>
<span class="lineno"> 2371 </span>
<span class="lineno"> 2372 </span>llvm_alloc_aligned_with_mutability ::
<span class="lineno"> 2373 </span>  Crucible.Mutability -&gt;
<span class="lineno"> 2374 </span>  Int -&gt;
<span class="lineno"> 2375 </span>  L.Type -&gt;
<span class="lineno"> 2376 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2377 </span><span class="decl"><span class="nottickedoff">llvm_alloc_aligned_with_mutability mut n lty =</span>
<span class="lineno"> 2378 </span><span class="spaces">  </span><span class="nottickedoff">do alignment &lt;- LLVMCrucibleSetupM $ coerceAlignment n</span>
<span class="lineno"> 2379 </span><span class="spaces">     </span><span class="nottickedoff">llvm_alloc_with_mutability_and_size</span>
<span class="lineno"> 2380 </span><span class="spaces">       </span><span class="nottickedoff">mut</span>
<span class="lineno"> 2381 </span><span class="spaces">       </span><span class="nottickedoff">Nothing</span>
<span class="lineno"> 2382 </span><span class="spaces">       </span><span class="nottickedoff">(Just alignment)</span>
<span class="lineno"> 2383 </span><span class="spaces">       </span><span class="nottickedoff">LLVMAllocSpecNoInitialization</span>
<span class="lineno"> 2384 </span><span class="spaces">       </span><span class="nottickedoff">lty</span></span>
<span class="lineno"> 2385 </span>
<span class="lineno"> 2386 </span>coerceAlignment :: Int -&gt; CrucibleSetup (LLVM arch) Crucible.Alignment
<span class="lineno"> 2387 </span><span class="decl"><span class="istickedoff">coerceAlignment n =</span>
<span class="lineno"> 2388 </span><span class="spaces">  </span><span class="istickedoff">case Crucible.toAlignment (Crucible.toBytes n) of</span>
<span class="lineno"> 2389 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2390 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do loc &lt;- getW4Position &quot;llvm_alloc_aligned_with_mutability&quot;</span></span>
<span class="lineno"> 2391 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">throwCrucibleSetup loc $ unwords</span></span>
<span class="lineno"> 2392 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_alloc_aligned/llvm_alloc_readonly_aligned:&quot;</span></span>
<span class="lineno"> 2393 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, &quot;invalid non-power-of-2 alignment:&quot;</span></span>
<span class="lineno"> 2394 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, show n</span></span>
<span class="lineno"> 2395 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2396 </span><span class="spaces">    </span><span class="istickedoff">Just alignment -&gt; return alignment</span></span>
<span class="lineno"> 2397 </span>
<span class="lineno"> 2398 </span>llvm_alloc_with_size ::
<span class="lineno"> 2399 </span>  Int {-^ allocation size (in bytes) -} -&gt;
<span class="lineno"> 2400 </span>  L.Type         -&gt;
<span class="lineno"> 2401 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2402 </span><span class="decl"><span class="istickedoff">llvm_alloc_with_size sz lty =</span>
<span class="lineno"> 2403 </span><span class="spaces">  </span><span class="istickedoff">llvm_alloc_with_mutability_and_size</span>
<span class="lineno"> 2404 </span><span class="spaces">    </span><span class="istickedoff">Crucible.Mutable</span>
<span class="lineno"> 2405 </span><span class="spaces">    </span><span class="istickedoff">(Just (Crucible.toBytes sz))</span>
<span class="lineno"> 2406 </span><span class="spaces">    </span><span class="istickedoff">Nothing</span>
<span class="lineno"> 2407 </span><span class="spaces">    </span><span class="istickedoff">LLVMAllocSpecNoInitialization</span>
<span class="lineno"> 2408 </span><span class="spaces">    </span><span class="istickedoff">lty</span></span>
<span class="lineno"> 2409 </span>
<span class="lineno"> 2410 </span>llvm_alloc_sym_init :: L.Type -&gt; LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2411 </span><span class="decl"><span class="istickedoff">llvm_alloc_sym_init =</span>
<span class="lineno"> 2412 </span><span class="spaces">  </span><span class="istickedoff">llvm_alloc_with_mutability_and_size Crucible.Mutable Nothing Nothing LLVMAllocSpecSymbolicInitialization</span></span>
<span class="lineno"> 2413 </span>
<span class="lineno"> 2414 </span>llvm_symbolic_alloc ::
<span class="lineno"> 2415 </span>  Bool -&gt;
<span class="lineno"> 2416 </span>  Int -&gt;
<span class="lineno"> 2417 </span>  Term -&gt;
<span class="lineno"> 2418 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2419 </span><span class="decl"><span class="istickedoff">llvm_symbolic_alloc ro align_bytes sz =</span>
<span class="lineno"> 2420 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2421 </span><span class="spaces">  </span><span class="istickedoff">do alignment &lt;- coerceAlignment align_bytes</span>
<span class="lineno"> 2422 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position &quot;llvm_symbolic_alloc&quot;</span>
<span class="lineno"> 2423 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- lift $ lift getSharedContext</span>
<span class="lineno"> 2424 </span><span class="spaces">     </span><span class="istickedoff">sz_ty &lt;- liftIO $ Cryptol.scCryptolType sc =&lt;&lt; scTypeOf sc sz</span>
<span class="lineno"> 2425 </span><span class="spaces">     </span><span class="istickedoff">case sz_ty of</span>
<span class="lineno"> 2426 </span><span class="spaces">       </span><span class="istickedoff">Just (Right tp)</span>
<span class="lineno"> 2427 </span><span class="spaces">         </span><span class="istickedoff">| <span class="tickonlytrue">Just 64 == asCryptolBVType tp</span> -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 2428 </span><span class="spaces">         </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ unwords</span></span>
<span class="lineno"> 2429 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_symbolic_alloc:&quot;</span></span>
<span class="lineno"> 2430 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;unexpected type of size term, expected [64], found&quot;</span></span>
<span class="lineno"> 2431 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, Cryptol.pretty tp</span></span>
<span class="lineno"> 2432 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2433 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ unwords</span></span>
<span class="lineno"> 2434 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_symbolic_alloc:&quot;</span></span>
<span class="lineno"> 2435 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;unexpected term, expected term of type [64], but got&quot;</span></span>
<span class="lineno"> 2436 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, showTerm sz</span></span>
<span class="lineno"> 2437 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2438 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2439 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2440 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 2441 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 2442 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 2443 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;fresh symbolic allocation&quot;</span></span>
<span class="lineno"> 2444 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 2445 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 2446 </span><span class="spaces">     </span><span class="istickedoff">let spec = LLVMAllocSpec</span>
<span class="lineno"> 2447 </span><span class="spaces">           </span><span class="istickedoff">{ _allocSpecMut = if <span class="tickonlyfalse">ro</span> then <span class="nottickedoff">Crucible.Immutable</span> else Crucible.Mutable</span>
<span class="lineno"> 2448 </span><span class="spaces">           </span><span class="istickedoff">, _allocSpecType = <span class="nottickedoff">Crucible.i8p</span></span>
<span class="lineno"> 2449 </span><span class="spaces">           </span><span class="istickedoff">, _allocSpecAlign = alignment</span>
<span class="lineno"> 2450 </span><span class="spaces">           </span><span class="istickedoff">, _allocSpecBytes = sz</span>
<span class="lineno"> 2451 </span><span class="spaces">           </span><span class="istickedoff">, _allocSpecMd = md</span>
<span class="lineno"> 2452 </span><span class="spaces">           </span><span class="istickedoff">, _allocSpecFresh = False</span>
<span class="lineno"> 2453 </span><span class="spaces">           </span><span class="istickedoff">, _allocSpecInit = LLVMAllocSpecNoInitialization</span>
<span class="lineno"> 2454 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno"> 2455 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- Setup.csVarCounter &lt;&lt;%= nextAllocIndex</span>
<span class="lineno"> 2456 </span><span class="spaces">     </span><span class="istickedoff">Setup.currentState . MS.csAllocs . at n ?= spec</span>
<span class="lineno"> 2457 </span><span class="spaces">     </span><span class="istickedoff">return $ mkAllLLVM $ SetupVar n</span></span>
<span class="lineno"> 2458 </span>
<span class="lineno"> 2459 </span>asCryptolBVType :: Cryptol.Type -&gt; Maybe Integer
<span class="lineno"> 2460 </span><span class="decl"><span class="istickedoff">asCryptolBVType ty</span>
<span class="lineno"> 2461 </span><span class="spaces">  </span><span class="istickedoff">| Just (n, ety) &lt;- Cryptol.tIsSeq ty</span>
<span class="lineno"> 2462 </span><span class="spaces">  </span><span class="istickedoff">, <span class="tickonlytrue">Cryptol.tIsBit ety</span> =</span>
<span class="lineno"> 2463 </span><span class="spaces">    </span><span class="istickedoff">Cryptol.tIsNum n</span>
<span class="lineno"> 2464 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 2465 </span>
<span class="lineno"> 2466 </span>llvm_alloc_global ::
<span class="lineno"> 2467 </span>  String         -&gt;
<span class="lineno"> 2468 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2469 </span><span class="decl"><span class="istickedoff">llvm_alloc_global name =</span>
<span class="lineno"> 2470 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2471 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position &quot;llvm_alloc_global&quot;</span>
<span class="lineno"> 2472 </span><span class="spaces">     </span><span class="istickedoff">Setup.addAllocGlobal . LLVMAllocGlobal loc $ L.Symbol name</span></span>
<span class="lineno"> 2473 </span>
<span class="lineno"> 2474 </span>llvm_fresh_pointer ::
<span class="lineno"> 2475 </span>  L.Type         -&gt;
<span class="lineno"> 2476 </span>  LLVMCrucibleSetupM (AllLLVM SetupValue)
<span class="lineno"> 2477 </span><span class="decl"><span class="istickedoff">llvm_fresh_pointer lty =</span>
<span class="lineno"> 2478 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2479 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- getW4Position <span class="nottickedoff">&quot;llvm_fresh_pointer&quot;</span></span>
<span class="lineno"> 2480 </span><span class="spaces">     </span><span class="istickedoff">memTy &lt;- memTypeForLLVMType <span class="nottickedoff">loc</span> lty</span>
<span class="lineno"> 2481 </span><span class="spaces">     </span><span class="istickedoff">constructFreshPointer (llvmTypeAlias lty) <span class="nottickedoff">loc</span> memTy</span></span>
<span class="lineno"> 2482 </span>
<span class="lineno"> 2483 </span>llvm_cast_pointer :: AllLLVM SetupValue -&gt; L.Type -&gt; AllLLVM SetupValue
<span class="lineno"> 2484 </span><span class="decl"><span class="istickedoff">llvm_cast_pointer ptr lty = mkAllLLVM (SetupCast lty (getAllLLVM ptr))</span></span>
<span class="lineno"> 2485 </span>
<span class="lineno"> 2486 </span>constructFreshPointer ::
<span class="lineno"> 2487 </span>  Crucible.HasPtrWidth (Crucible.ArchWidth arch) =&gt;
<span class="lineno"> 2488 </span>  Maybe Crucible.Ident -&gt;
<span class="lineno"> 2489 </span>  W4.ProgramLoc -&gt;
<span class="lineno"> 2490 </span>  Crucible.MemType -&gt;
<span class="lineno"> 2491 </span>  CrucibleSetup (LLVM arch) (AllLLVM SetupValue)
<span class="lineno"> 2492 </span><span class="decl"><span class="istickedoff">constructFreshPointer mid loc memTy =</span>
<span class="lineno"> 2493 </span><span class="spaces">  </span><span class="istickedoff">do cctx &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2494 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = <span class="nottickedoff">ccTypeCtx cctx</span></span>
<span class="lineno"> 2495 </span><span class="spaces">     </span><span class="istickedoff">let ?dl = <span class="nottickedoff">Crucible.llvmDataLayout ?lc</span></span>
<span class="lineno"> 2496 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- Setup.csVarCounter &lt;&lt;%= nextAllocIndex</span>
<span class="lineno"> 2497 </span><span class="spaces">     </span><span class="istickedoff">sz &lt;- liftIO $ scPtrWidthBvNat cctx $ Crucible.memTypeSize <span class="nottickedoff">?dl</span> memTy</span>
<span class="lineno"> 2498 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">alignment = Crucible.memTypeAlign ?dl memTy</span></span>
<span class="lineno"> 2499 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2500 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">md = MS.ConditionMetadata</span></span>
<span class="lineno"> 2501 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">{ MS.conditionLoc = loc</span></span>
<span class="lineno"> 2502 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionTags = tags</span></span>
<span class="lineno"> 2503 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionType = &quot;fresh pointer&quot;</span></span>
<span class="lineno"> 2504 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, MS.conditionContext = &quot;&quot;</span></span>
<span class="lineno"> 2505 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 2506 </span><span class="spaces">     </span><span class="istickedoff">Setup.currentState . MS.csAllocs . at n ?=</span>
<span class="lineno"> 2507 </span><span class="spaces">       </span><span class="istickedoff">LLVMAllocSpec { _allocSpecMut = <span class="nottickedoff">Crucible.Mutable</span></span>
<span class="lineno"> 2508 </span><span class="spaces">                     </span><span class="istickedoff">, _allocSpecType = <span class="nottickedoff">memTy</span></span>
<span class="lineno"> 2509 </span><span class="spaces">                     </span><span class="istickedoff">, _allocSpecAlign = <span class="nottickedoff">alignment</span></span>
<span class="lineno"> 2510 </span><span class="spaces">                     </span><span class="istickedoff">, _allocSpecBytes = <span class="nottickedoff">sz</span></span>
<span class="lineno"> 2511 </span><span class="spaces">                     </span><span class="istickedoff">, _allocSpecMd = <span class="nottickedoff">md</span></span>
<span class="lineno"> 2512 </span><span class="spaces">                     </span><span class="istickedoff">, _allocSpecFresh = True</span>
<span class="lineno"> 2513 </span><span class="spaces">                     </span><span class="istickedoff">, _allocSpecInit = <span class="nottickedoff">LLVMAllocSpecNoInitialization</span></span>
<span class="lineno"> 2514 </span><span class="spaces">                     </span><span class="istickedoff">}</span>
<span class="lineno"> 2515 </span><span class="spaces">     </span><span class="istickedoff">-- TODO: refactor</span>
<span class="lineno"> 2516 </span><span class="spaces">     </span><span class="istickedoff">case mid of</span>
<span class="lineno"> 2517 </span><span class="spaces">       </span><span class="istickedoff">Just i -&gt; <span class="nottickedoff">Setup.currentState . MS.csVarTypeNames.at n ?= i</span></span>
<span class="lineno"> 2518 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 2519 </span><span class="spaces">     </span><span class="istickedoff">return (mkAllLLVM (SetupVar n))</span></span>
<span class="lineno"> 2520 </span>
<span class="lineno"> 2521 </span>llvm_points_to ::
<span class="lineno"> 2522 </span>  Bool {- ^ whether to check type compatibility -} -&gt;
<span class="lineno"> 2523 </span>  AllLLVM SetupValue     -&gt;
<span class="lineno"> 2524 </span>  AllLLVM SetupValue     -&gt;
<span class="lineno"> 2525 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2526 </span><span class="decl"><span class="istickedoff">llvm_points_to typed =</span>
<span class="lineno"> 2527 </span><span class="spaces">  </span><span class="istickedoff">llvm_points_to_internal (shouldCheckAgainstPointerType typed) Nothing</span></span>
<span class="lineno"> 2528 </span>
<span class="lineno"> 2529 </span>llvm_conditional_points_to ::
<span class="lineno"> 2530 </span>  Bool {- ^ whether to check type compatibility -} -&gt;
<span class="lineno"> 2531 </span>  TypedTerm -&gt;
<span class="lineno"> 2532 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2533 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2534 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2535 </span><span class="decl"><span class="istickedoff">llvm_conditional_points_to typed cond =</span>
<span class="lineno"> 2536 </span><span class="spaces">  </span><span class="istickedoff">llvm_points_to_internal (shouldCheckAgainstPointerType typed) (Just cond)</span></span>
<span class="lineno"> 2537 </span>
<span class="lineno"> 2538 </span>llvm_points_to_at_type ::
<span class="lineno"> 2539 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2540 </span>  L.Type             -&gt;
<span class="lineno"> 2541 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2542 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2543 </span><span class="decl"><span class="istickedoff">llvm_points_to_at_type ptr ty val =</span>
<span class="lineno"> 2544 </span><span class="spaces">  </span><span class="istickedoff">llvm_points_to_internal (Just (Setup.CheckAgainstCastedType ty)) Nothing ptr val</span></span>
<span class="lineno"> 2545 </span>
<span class="lineno"> 2546 </span>llvm_conditional_points_to_at_type ::
<span class="lineno"> 2547 </span>  TypedTerm -&gt;
<span class="lineno"> 2548 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2549 </span>  L.Type             -&gt;
<span class="lineno"> 2550 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2551 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2552 </span><span class="decl"><span class="nottickedoff">llvm_conditional_points_to_at_type cond ptr ty val =</span>
<span class="lineno"> 2553 </span><span class="spaces">  </span><span class="nottickedoff">llvm_points_to_internal (Just (Setup.CheckAgainstCastedType ty)) (Just cond) ptr val</span></span>
<span class="lineno"> 2554 </span>
<span class="lineno"> 2555 </span>-- | If the argument is @True@, check the type of the RHS value against the
<span class="lineno"> 2556 </span>-- type that the LHS points to (i.e., @'Just' 'CheckAgainstPointerType'@).
<span class="lineno"> 2557 </span>-- Otherwise, don't check the type of the RHS value at all (i.e., 'Nothing').
<span class="lineno"> 2558 </span>shouldCheckAgainstPointerType :: Bool -&gt; Maybe (Setup.CheckPointsToType ty)
<span class="lineno"> 2559 </span><span class="decl"><span class="istickedoff">shouldCheckAgainstPointerType b = if b then Just Setup.CheckAgainstPointerType else Nothing</span></span>
<span class="lineno"> 2560 </span>
<span class="lineno"> 2561 </span>llvm_points_to_internal ::
<span class="lineno"> 2562 </span>  Maybe (Setup.CheckPointsToType L.Type)
<span class="lineno"> 2563 </span>  {- ^ If 'Just', check the type of the RHS value.
<span class="lineno"> 2564 </span>       If 'Nothing', don't check the type of the RHS value at all. -} -&gt;
<span class="lineno"> 2565 </span>  Maybe TypedTerm -&gt;
<span class="lineno"> 2566 </span>  AllLLVM SetupValue {- ^ lhs pointer -} -&gt;
<span class="lineno"> 2567 </span>  AllLLVM SetupValue {- ^ rhs value -} -&gt;
<span class="lineno"> 2568 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2569 </span><span class="decl"><span class="istickedoff">llvm_points_to_internal mbCheckType cond (getAllLLVM -&gt; ptr) (getAllLLVM -&gt; val) =</span>
<span class="lineno"> 2570 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2571 </span><span class="spaces">  </span><span class="istickedoff">do cc &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2572 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position &quot;llvm_points_to&quot;</span>
<span class="lineno"> 2573 </span><span class="spaces">     </span><span class="istickedoff">Crucible.llvmPtrWidth (ccLLVMContext cc) $ \wptr -&gt; Crucible.withPtrWidth wptr $</span>
<span class="lineno"> 2574 </span><span class="spaces">       </span><span class="istickedoff">do st &lt;- lift get</span>
<span class="lineno"> 2575 </span><span class="spaces">          </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 2576 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 2577 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2578 </span><span class="spaces">          </span><span class="istickedoff">let <span class="nottickedoff">path = []</span></span>
<span class="lineno"> 2579 </span><span class="spaces">          </span><span class="istickedoff">lhsTy &lt;- llvm_points_to_check_lhs_validity ptr <span class="nottickedoff">loc</span> <span class="nottickedoff">path</span></span>
<span class="lineno"> 2580 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2581 </span><span class="spaces">          </span><span class="istickedoff">valTy &lt;- exceptToFail $ typeOfSetupValue cc env <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 2582 </span><span class="spaces">          </span><span class="istickedoff">case mbCheckType of</span>
<span class="lineno"> 2583 </span><span class="spaces">            </span><span class="istickedoff">Nothing                                -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 2584 </span><span class="spaces">            </span><span class="istickedoff">Just Setup.CheckAgainstPointerType     -&gt; checkMemTypeCompatibility loc lhsTy valTy</span>
<span class="lineno"> 2585 </span><span class="spaces">            </span><span class="istickedoff">Just (Setup.CheckAgainstCastedType ty) -&gt; do</span>
<span class="lineno"> 2586 </span><span class="spaces">              </span><span class="istickedoff">ty' &lt;- memTypeForLLVMType <span class="nottickedoff">loc</span> ty</span>
<span class="lineno"> 2587 </span><span class="spaces">              </span><span class="istickedoff">checkMemTypeCompatibility loc ty' valTy</span>
<span class="lineno"> 2588 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2589 </span><span class="spaces">          </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2590 </span><span class="spaces">          </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 2591 </span><span class="spaces">                   </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 2592 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 2593 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;LLVM points-to&quot;</span></span>
<span class="lineno"> 2594 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 2595 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 2596 </span><span class="spaces">          </span><span class="istickedoff">Setup.addPointsTo (LLVMPointsTo md cond ptr $ ConcreteSizeValue val)</span></span>
<span class="lineno"> 2597 </span>
<span class="lineno"> 2598 </span>-- | Like 'llvm_points_to_internal', but specifically geared towards the needs
<span class="lineno"> 2599 </span>-- of fields within bitfields. In particular, rather than checking
<span class="lineno"> 2600 </span>-- 'Crucible.MemType' compatibility against the type that that LHS points to,
<span class="lineno"> 2601 </span>-- which corresponds to the overall bitfield type, this checks compatibility
<span class="lineno"> 2602 </span>-- against the type of the field /within/ the bitfield, which is often a
<span class="lineno"> 2603 </span>-- smaller type.
<span class="lineno"> 2604 </span>llvm_points_to_bitfield ::
<span class="lineno"> 2605 </span>  AllLLVM SetupValue {- ^ lhs pointer -} -&gt;
<span class="lineno"> 2606 </span>  String             {- ^ name of field in bitfield -} -&gt;
<span class="lineno"> 2607 </span>  AllLLVM SetupValue {- ^ rhs value -} -&gt;
<span class="lineno"> 2608 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2609 </span><span class="decl"><span class="istickedoff">llvm_points_to_bitfield (getAllLLVM -&gt; ptr) fieldName (getAllLLVM -&gt; val) =</span>
<span class="lineno"> 2610 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2611 </span><span class="spaces">  </span><span class="istickedoff">do cc &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2612 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position &quot;llvm_points_to_bitfield&quot;</span>
<span class="lineno"> 2613 </span><span class="spaces">     </span><span class="istickedoff">Crucible.llvmPtrWidth (ccLLVMContext cc) $ \wptr -&gt; Crucible.withPtrWidth <span class="nottickedoff">wptr</span> $</span>
<span class="lineno"> 2614 </span><span class="spaces">       </span><span class="istickedoff">do st &lt;- get</span>
<span class="lineno"> 2615 </span><span class="spaces">          </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 2616 </span><span class="spaces">              </span><span class="istickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 2617 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2618 </span><span class="spaces">          </span><span class="istickedoff">-- NB: Don't use [] for the path here. It's perfectly acceptable to</span>
<span class="lineno"> 2619 </span><span class="spaces">          </span><span class="istickedoff">-- have multiple llvm_points_to_bitfield statements on the same</span>
<span class="lineno"> 2620 </span><span class="spaces">          </span><span class="istickedoff">-- pointer provided that the field names are different, so we use</span>
<span class="lineno"> 2621 </span><span class="spaces">          </span><span class="istickedoff">-- the field name as the path.</span>
<span class="lineno"> 2622 </span><span class="spaces">          </span><span class="istickedoff">let path = [ResolvedField fieldName]</span>
<span class="lineno"> 2623 </span><span class="spaces">          </span><span class="istickedoff">_ &lt;- llvm_points_to_check_lhs_validity ptr loc path</span>
<span class="lineno"> 2624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2625 </span><span class="spaces">          </span><span class="istickedoff">bfIndex &lt;- exceptToFail $ resolveSetupBitfield cc env nameEnv ptr fieldName</span>
<span class="lineno"> 2626 </span><span class="spaces">          </span><span class="istickedoff">let lhsFieldTy = Crucible.IntType $ fromIntegral $ biFieldSize bfIndex</span>
<span class="lineno"> 2627 </span><span class="spaces">          </span><span class="istickedoff">valTy &lt;- exceptToFail $ typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val</span>
<span class="lineno"> 2628 </span><span class="spaces">          </span><span class="istickedoff">-- Currently, we require the type of the RHS value to precisely match</span>
<span class="lineno"> 2629 </span><span class="spaces">          </span><span class="istickedoff">-- the type of the field within the bitfield. One could imagine</span>
<span class="lineno"> 2630 </span><span class="spaces">          </span><span class="istickedoff">-- having finer-grained control over this (e.g.,</span>
<span class="lineno"> 2631 </span><span class="spaces">          </span><span class="istickedoff">-- llvm_points_to_bitfield_at_type or llvm_points_to_bitfield_untyped),</span>
<span class="lineno"> 2632 </span><span class="spaces">          </span><span class="istickedoff">-- but no one has asked for this yet.</span>
<span class="lineno"> 2633 </span><span class="spaces">          </span><span class="istickedoff">checkMemTypeCompatibility loc lhsFieldTy valTy</span>
<span class="lineno"> 2634 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2635 </span><span class="spaces">          </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2636 </span><span class="spaces">          </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 2637 </span><span class="spaces">                   </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 2638 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 2639 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;LLVM points-to (bitfield)&quot;</span></span>
<span class="lineno"> 2640 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 2641 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 2642 </span><span class="spaces">          </span><span class="istickedoff">Setup.addPointsTo (LLVMPointsToBitfield md ptr fieldName val)</span></span>
<span class="lineno"> 2643 </span>
<span class="lineno"> 2644 </span>-- | Perform a set of validity checks that are shared in common between
<span class="lineno"> 2645 </span>-- 'llvm_points_to_internal' and 'llvm_points_to_bitfield':
<span class="lineno"> 2646 </span>--
<span class="lineno"> 2647 </span>-- * Check that there are no dupplicate points-to preconditions on the LHS
<span class="lineno"> 2648 </span>--   pointer with the supplied path.
<span class="lineno"> 2649 </span>--
<span class="lineno"> 2650 </span>-- * Check that the LHS is in fact a valid pointer type.
<span class="lineno"> 2651 </span>--
<span class="lineno"> 2652 </span>-- Returns the 'Crucible.MemType' that the LHS points to.
<span class="lineno"> 2653 </span>llvm_points_to_check_lhs_validity ::
<span class="lineno"> 2654 </span>  SetupValue (LLVM arch) {- ^ lhs pointer -} -&gt;
<span class="lineno"> 2655 </span>  W4.ProgramLoc {- ^ the location in the program -} -&gt;
<span class="lineno"> 2656 </span>  ResolvedPath {- ^ the path from the pointer to the pointee -} -&gt;
<span class="lineno"> 2657 </span>  Setup.CrucibleSetupT (LLVM arch) TopLevel Crucible.MemType
<span class="lineno"> 2658 </span><span class="decl"><span class="istickedoff">llvm_points_to_check_lhs_validity ptr loc path =</span>
<span class="lineno"> 2659 </span><span class="spaces">  </span><span class="istickedoff">do cc &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2660 </span><span class="spaces">     </span><span class="istickedoff">let ?lc = ccTypeCtx cc</span>
<span class="lineno"> 2661 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 2662 </span><span class="spaces">     </span><span class="istickedoff">let rs = st ^. Setup.csResolvedState</span>
<span class="lineno"> 2663 </span><span class="spaces">     </span><span class="istickedoff">if st ^. Setup.csPrePost == PreState &amp;&amp; testResolved ptr path rs</span>
<span class="lineno"> 2664 </span><span class="spaces">       </span><span class="istickedoff">then throwCrucibleSetup loc &quot;Multiple points-to preconditions on same pointer&quot;</span>
<span class="lineno"> 2665 </span><span class="spaces">       </span><span class="istickedoff">else Setup.csResolvedState %= markResolved ptr path</span>
<span class="lineno"> 2666 </span><span class="spaces">     </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 2667 </span><span class="spaces">         </span><span class="istickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 2668 </span><span class="spaces">     </span><span class="istickedoff">ptrTy &lt;- exceptToFail $ typeOfSetupValue cc env nameEnv ptr</span>
<span class="lineno"> 2669 </span><span class="spaces">     </span><span class="istickedoff">case ptrTy of</span>
<span class="lineno"> 2670 </span><span class="spaces">       </span><span class="istickedoff">Crucible.PtrType symTy -&gt;</span>
<span class="lineno"> 2671 </span><span class="spaces">         </span><span class="istickedoff">case Crucible.asMemType symTy of</span>
<span class="lineno"> 2672 </span><span class="spaces">           </span><span class="istickedoff">Right lhsTy -&gt; return lhsTy</span>
<span class="lineno"> 2673 </span><span class="spaces">           </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 2674 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">[ &quot;lhs not a valid pointer type: &quot; ++ show ptrTy</span></span>
<span class="lineno"> 2675 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, &quot;Details:&quot;</span></span>
<span class="lineno"> 2676 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, err</span></span>
<span class="lineno"> 2677 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2678 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2679 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ &quot;lhs not a pointer type: &quot; ++ show ptrTy</span></span></span>
<span class="lineno"> 2680 </span>
<span class="lineno"> 2681 </span>llvm_setup_with_tag ::
<span class="lineno"> 2682 </span>  String -&gt;
<span class="lineno"> 2683 </span>  LLVMCrucibleSetupM () -&gt;
<span class="lineno"> 2684 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2685 </span><span class="decl"><span class="istickedoff">llvm_setup_with_tag tag m =</span>
<span class="lineno"> 2686 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM (Setup.setupWithTag tag (runLLVMCrucibleSetupM m))</span></span>
<span class="lineno"> 2687 </span>
<span class="lineno"> 2688 </span>llvm_points_to_array_prefix ::
<span class="lineno"> 2689 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2690 </span>  TypedTerm -&gt;
<span class="lineno"> 2691 </span>  TypedTerm -&gt;
<span class="lineno"> 2692 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2693 </span><span class="decl"><span class="istickedoff">llvm_points_to_array_prefix (getAllLLVM -&gt; ptr) arr sz =</span>
<span class="lineno"> 2694 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2695 </span><span class="spaces">  </span><span class="istickedoff">do cc &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2696 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position &quot;llvm_points_to_array_prefix&quot;</span>
<span class="lineno"> 2697 </span><span class="spaces">     </span><span class="istickedoff">case ttType sz of</span>
<span class="lineno"> 2698 </span><span class="spaces">       </span><span class="istickedoff">TypedTermSchema (Cryptol.Forall [] [] ty)</span>
<span class="lineno"> 2699 </span><span class="spaces">         </span><span class="istickedoff">| Just 64 == asCryptolBVType ty -&gt;</span>
<span class="lineno"> 2700 </span><span class="spaces">           </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno"> 2701 </span><span class="spaces">         </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 2702 </span><span class="spaces">           </span><span class="istickedoff">throwCrucibleSetup loc $ unwords</span>
<span class="lineno"> 2703 </span><span class="spaces">              </span><span class="istickedoff">[ &quot;llvm_points_to_array_prefix:&quot;</span>
<span class="lineno"> 2704 </span><span class="spaces">              </span><span class="istickedoff">, &quot;unexpected type of size term, expected [64], found&quot;</span>
<span class="lineno"> 2705 </span><span class="spaces">              </span><span class="istickedoff">, Cryptol.pretty ty</span>
<span class="lineno"> 2706 </span><span class="spaces">              </span><span class="istickedoff">]</span>
<span class="lineno"> 2707 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ unwords</span></span>
<span class="lineno"> 2708 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[ &quot;llvm_points_to_array_prefix:&quot;</span></span>
<span class="lineno"> 2709 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, &quot;unexpected size term, expected term of type [64], but got&quot;</span></span>
<span class="lineno"> 2710 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">, showTerm (ttTerm sz)</span></span>
<span class="lineno"> 2711 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2712 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2713 </span><span class="spaces">     </span><span class="istickedoff">Crucible.llvmPtrWidth (ccLLVMContext cc) $ \wptr -&gt; Crucible.withPtrWidth <span class="nottickedoff">wptr</span> $</span>
<span class="lineno"> 2714 </span><span class="spaces">       </span><span class="istickedoff">do let ?lc = <span class="nottickedoff">ccTypeCtx cc</span></span>
<span class="lineno"> 2715 </span><span class="spaces">          </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 2716 </span><span class="spaces">          </span><span class="istickedoff">let rs = st ^. Setup.csResolvedState</span>
<span class="lineno"> 2717 </span><span class="spaces">          </span><span class="istickedoff">if <span class="tickonlyfalse">st ^. Setup.csPrePost == PreState &amp;&amp; testResolved ptr <span class="nottickedoff">[]</span> rs</span></span>
<span class="lineno"> 2718 </span><span class="spaces">            </span><span class="istickedoff">then <span class="nottickedoff">throwCrucibleSetup loc &quot;Multiple points-to preconditions on same pointer&quot;</span></span>
<span class="lineno"> 2719 </span><span class="spaces">            </span><span class="istickedoff">else Setup.csResolvedState %= markResolved ptr <span class="nottickedoff">[]</span></span>
<span class="lineno"> 2720 </span><span class="spaces">          </span><span class="istickedoff">let env = MS.csAllocations (st ^. Setup.csMethodSpec)</span>
<span class="lineno"> 2721 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 2722 </span><span class="spaces">          </span><span class="istickedoff">ptrTy &lt;- exceptToFail $ typeOfSetupValue <span class="nottickedoff">cc</span> env <span class="nottickedoff">nameEnv</span> ptr</span>
<span class="lineno"> 2723 </span><span class="spaces">          </span><span class="istickedoff">_ &lt;- case ptrTy of</span>
<span class="lineno"> 2724 </span><span class="spaces">            </span><span class="istickedoff">Crucible.PtrType symTy -&gt;</span>
<span class="lineno"> 2725 </span><span class="spaces">              </span><span class="istickedoff">case Crucible.asMemType symTy of</span>
<span class="lineno"> 2726 </span><span class="spaces">                </span><span class="istickedoff">Right lhsTy -&gt; return <span class="nottickedoff">lhsTy</span></span>
<span class="lineno"> 2727 </span><span class="spaces">                </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 2728 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">[ &quot;lhs not a valid pointer type: &quot; ++ show ptrTy</span></span>
<span class="lineno"> 2729 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, &quot;Details:&quot;</span></span>
<span class="lineno"> 2730 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, err</span></span>
<span class="lineno"> 2731 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2732 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2733 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwCrucibleSetup loc $ &quot;lhs not a pointer type: &quot; ++ show ptrTy</span></span>
<span class="lineno"> 2734 </span><span class="spaces">          </span><span class="istickedoff">tags &lt;- view <span class="nottickedoff">Setup.croTags</span></span>
<span class="lineno"> 2735 </span><span class="spaces">          </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 2736 </span><span class="spaces">                   </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 2737 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionTags = <span class="nottickedoff">tags</span></span>
<span class="lineno"> 2738 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionType = <span class="nottickedoff">&quot;LLVM points-to (array prefix)&quot;</span></span>
<span class="lineno"> 2739 </span><span class="spaces">                   </span><span class="istickedoff">, MS.conditionContext = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 2740 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 2741 </span><span class="spaces">          </span><span class="istickedoff">Setup.addPointsTo (LLVMPointsTo md Nothing ptr $ SymbolicSizeValue arr sz)</span></span>
<span class="lineno"> 2742 </span>
<span class="lineno"> 2743 </span>llvm_equal ::
<span class="lineno"> 2744 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2745 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2746 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2747 </span><span class="decl"><span class="istickedoff">llvm_equal (getAllLLVM -&gt; val1) (getAllLLVM -&gt; val2) =</span>
<span class="lineno"> 2748 </span><span class="spaces">  </span><span class="istickedoff">LLVMCrucibleSetupM $</span>
<span class="lineno"> 2749 </span><span class="spaces">  </span><span class="istickedoff">do cc &lt;- getLLVMCrucibleContext</span>
<span class="lineno"> 2750 </span><span class="spaces">     </span><span class="istickedoff">loc &lt;- getW4Position &quot;llvm_equal&quot;</span>
<span class="lineno"> 2751 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- get</span>
<span class="lineno"> 2752 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">env = MS.csAllocations (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 2753 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">nameEnv = MS.csTypeNames (st ^. Setup.csMethodSpec)</span></span>
<span class="lineno"> 2754 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- exceptToFail $ typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val1</span>
<span class="lineno"> 2755 </span><span class="spaces">     </span><span class="istickedoff">ty2 &lt;- exceptToFail $ typeOfSetupValue <span class="nottickedoff">cc</span> <span class="nottickedoff">env</span> <span class="nottickedoff">nameEnv</span> val2</span>
<span class="lineno"> 2756 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2757 </span><span class="spaces">     </span><span class="istickedoff">b &lt;- liftIO $ checkRegisterCompatibility ty1 ty2</span>
<span class="lineno"> 2758 </span><span class="spaces">     </span><span class="istickedoff">unless b $ <span class="nottickedoff">throwCrucibleSetup loc $ unlines</span></span>
<span class="lineno"> 2759 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Incompatible types when asserting equality:&quot;</span></span>
<span class="lineno"> 2760 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, show ty1</span></span>
<span class="lineno"> 2761 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, show ty2</span></span>
<span class="lineno"> 2762 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2763 </span><span class="spaces">     </span><span class="istickedoff">Setup.crucible_equal loc val1 val2</span></span>
<span class="lineno"> 2764 </span>
<span class="lineno"> 2765 </span>llvm_ghost_value ::
<span class="lineno"> 2766 </span>  MS.GhostGlobal -&gt;
<span class="lineno"> 2767 </span>  TypedTerm -&gt;
<span class="lineno"> 2768 </span>  LLVMCrucibleSetupM ()
<span class="lineno"> 2769 </span><span class="decl"><span class="istickedoff">llvm_ghost_value ghost val = LLVMCrucibleSetupM $</span>
<span class="lineno"> 2770 </span><span class="spaces">  </span><span class="istickedoff">ghost_value ghost val</span></span>
<span class="lineno"> 2771 </span>
<span class="lineno"> 2772 </span>llvm_spec_solvers :: SomeLLVM MS.ProvedSpec -&gt; [String]
<span class="lineno"> 2773 </span><span class="decl"><span class="nottickedoff">llvm_spec_solvers (SomeLLVM ps) =</span>
<span class="lineno"> 2774 </span><span class="spaces">  </span><span class="nottickedoff">Set.toList $ solverStatsSolvers $ view MS.psSolverStats $ ps</span></span>
<span class="lineno"> 2775 </span>
<span class="lineno"> 2776 </span>llvm_spec_size :: SomeLLVM MS.ProvedSpec -&gt; Integer
<span class="lineno"> 2777 </span><span class="decl"><span class="nottickedoff">llvm_spec_size (SomeLLVM mir) =</span>
<span class="lineno"> 2778 </span><span class="spaces">  </span><span class="nottickedoff">solverStatsGoalSize $ mir ^. MS.psSolverStats</span></span>
<span class="lineno"> 2779 </span>
<span class="lineno"> 2780 </span>crucible_setup_val_to_typed_term ::
<span class="lineno"> 2781 </span>  AllLLVM SetupValue -&gt;
<span class="lineno"> 2782 </span>  TopLevel TypedTerm
<span class="lineno"> 2783 </span><span class="decl"><span class="nottickedoff">crucible_setup_val_to_typed_term (getAllLLVM -&gt; sval) =</span>
<span class="lineno"> 2784 </span><span class="spaces">  </span><span class="nottickedoff">do opts &lt;- getOptions</span>
<span class="lineno"> 2785 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2786 </span><span class="spaces">     </span><span class="nottickedoff">mtt &lt;- io $ MaybeT.runMaybeT $ MS.setupToTypedTerm opts sc sval</span>
<span class="lineno"> 2787 </span><span class="spaces">     </span><span class="nottickedoff">case mtt of</span>
<span class="lineno"> 2788 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; throwTopLevel $ &quot;Could not convert a setup value to a term: &quot; ++ show sval</span>
<span class="lineno"> 2789 </span><span class="spaces">       </span><span class="nottickedoff">Just tt -&gt; return tt</span></span>

</pre>
</body>
</html>
