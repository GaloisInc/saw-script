<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# OPTIONS_GHC -Wall #-}
<span class="lineno">    2 </span>{-# LANGUAGE DoAndIfThenElse #-}
<span class="lineno">    3 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    4 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">    5 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">    6 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    7 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    8 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    9 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>{- |
<span class="lineno">   12 </span>Module      : CryptolSAWCore.Cryptol
<span class="lineno">   13 </span>Copyright   : Galois, Inc. 2012-2025
<span class="lineno">   14 </span>License     : BSD3
<span class="lineno">   15 </span>Maintainer  : huffman@galois.com
<span class="lineno">   16 </span>Stability   : experimental
<span class="lineno">   17 </span>Portability : non-portable (language extensions)
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>This module \'imports\' various Cryptol elements (Name,Expr,...),
<span class="lineno">   20 </span>translating each to the comparable element of SAWCore.
<span class="lineno">   21 </span>-}
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>module CryptolSAWCore.Cryptol
<span class="lineno">   24 </span>  ( scCryptolType
<span class="lineno">   25 </span>  , Env(..)
<span class="lineno">   26 </span>  , emptyEnv
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>  , isErasedProp
<span class="lineno">   29 </span>  , proveProp
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>  , ImportPrimitiveOptions(..)
<span class="lineno">   32 </span>  , importName
<span class="lineno">   33 </span>  , importExpr
<span class="lineno">   34 </span>  , importTopLevelDeclGroups
<span class="lineno">   35 </span>  , importDeclGroups
<span class="lineno">   36 </span>  , importType
<span class="lineno">   37 </span>  , importKind
<span class="lineno">   38 </span>  , importSchema
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>  , defaultPrimitiveOptions
<span class="lineno">   41 </span>  , genCodeForNominalTypes
<span class="lineno">   42 </span>  , exportValueWithSchema
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>  ) where
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>import Control.Monad (foldM, forM, join, when, unless)
<span class="lineno">   47 </span>import Control.Exception (catch, SomeException)
<span class="lineno">   48 </span>import Data.Bifunctor (first)
<span class="lineno">   49 </span>import qualified Data.Foldable as Fold
<span class="lineno">   50 </span>import Data.List (elemIndex)
<span class="lineno">   51 </span>import Data.List.NonEmpty (NonEmpty(..))
<span class="lineno">   52 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   53 </span>import qualified Data.IntTrie as IntTrie
<span class="lineno">   54 </span>import Data.Map (Map)
<span class="lineno">   55 </span>import qualified Data.Map as Map
<span class="lineno">   56 </span>import Data.Text (Text)
<span class="lineno">   57 </span>import qualified Data.Text as Text
<span class="lineno">   58 </span>import qualified Data.Vector as Vector
<span class="lineno">   59 </span>import GHC.Stack
<span class="lineno">   60 </span>import Prelude ()
<span class="lineno">   61 </span>import Prelude.Compat
<span class="lineno">   62 </span>import Text.URI
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- cryptol
<span class="lineno">   65 </span>import qualified Cryptol.Eval.Type as TV
<span class="lineno">   66 </span>import qualified Cryptol.Backend.Monad as V
<span class="lineno">   67 </span>import qualified Cryptol.Backend.SeqMap as V
<span class="lineno">   68 </span>import qualified Cryptol.Backend.WordValue as V
<span class="lineno">   69 </span>import qualified Cryptol.Eval.Value as V
<span class="lineno">   70 </span>import qualified Cryptol.Eval.Concrete as V
<span class="lineno">   71 </span>import Cryptol.Eval.Type (evalValType)
<span class="lineno">   72 </span>import qualified Cryptol.TypeCheck.AST as C
<span class="lineno">   73 </span>import qualified Cryptol.TypeCheck.Solver.InfNat as C (Nat'(..))
<span class="lineno">   74 </span>import qualified Cryptol.TypeCheck.Subst as C (Subst, apSubst, listSubst, singleTParamSubst)
<span class="lineno">   75 </span>import qualified Cryptol.ModuleSystem.Name as C
<span class="lineno">   76 </span>  (asPrim, nameUnique, nameIdent, nameInfo, NameInfo(..), asLocal)
<span class="lineno">   77 </span>import qualified Cryptol.Utils.Ident as C
<span class="lineno">   78 </span>  ( Ident, PrimIdent(..)
<span class="lineno">   79 </span>  , prelPrim, floatPrim, arrayPrim, suiteBPrim, primeECPrim
<span class="lineno">   80 </span>  , identText, interactiveName
<span class="lineno">   81 </span>  , ModPath(..), modPathSplit, ogModule, ogFromParam, Namespace(NSValue)
<span class="lineno">   82 </span>  , modNameChunksText
<span class="lineno">   83 </span>  )
<span class="lineno">   84 </span>import qualified Cryptol.Utils.RecordMap as C
<span class="lineno">   85 </span>import Cryptol.TypeCheck.Type as C (NominalType(..))
<span class="lineno">   86 </span>import Cryptol.TypeCheck.TypeOf (fastTypeOf, fastSchemaOf)
<span class="lineno">   87 </span>import qualified Cryptol.Utils.PP as PP
<span class="lineno">   88 </span>import Cryptol.Utils.PP (pretty, pp)
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>-- saw-core
<span class="lineno">   91 </span>import qualified SAWCore.Simulator.Concrete as SC
<span class="lineno">   92 </span>import qualified SAWCore.Simulator.Value as SC
<span class="lineno">   93 </span>import SAWCore.Prim (BitVector(..))
<span class="lineno">   94 </span>import SAWCore.SharedTerm
<span class="lineno">   95 </span>import SAWCore.SCTypeCheck               as SC
<span class="lineno">   96 </span>import SAWCore.Simulator.MonadLazy (force)
<span class="lineno">   97 </span>import SAWCore.TypedAST (mkSort, FieldName, LocalName)
<span class="lineno">   98 </span>import SAWCore.Name (preludeName)
<span class="lineno">   99 </span>import SAWCore.Term.Pretty (showTerm)
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- local modules:
<span class="lineno">  102 </span>import CryptolSAWCore.Panic
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- Type-check the Prelude, Cryptol, SpecM, and CryptolM modules at compile time
<span class="lineno">  105 </span>import Language.Haskell.TH
<span class="lineno">  106 </span>import CryptolSAWCore.Prelude
<span class="lineno">  107 </span>import CryptolSAWCore.PreludeM
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>$(runIO (mkSharedContext &gt;&gt;= \sc -&gt;
<span class="lineno">  110 </span>          scLoadPreludeModule sc &gt;&gt; scLoadCryptolModule sc &gt;&gt;
<span class="lineno">  111 </span>          scLoadSpecMModule sc &gt;&gt; scLoadCryptolMModule sc &gt;&gt; return []))
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>--------------------------------------------------------------------------------
<span class="lineno">  115 </span>-- | Type Environments
<span class="lineno">  116 </span>--   SharedTerms are paired with a deferred shift amount for loose variables
<span class="lineno">  117 </span>data Env = Env
<span class="lineno">  118 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">envT</span></span></span> :: Map Int    (Term, Int) -- ^ Type variables are referenced by unique id
<span class="lineno">  119 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envE</span></span></span> :: Map C.Name (Term, Int) -- ^ Term variables are referenced by name
<span class="lineno">  120 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envP</span></span></span> :: Map C.Prop (Term, [FieldName], Int)
<span class="lineno">  121 </span>              -- ^ Bound propositions are referenced implicitly by their types
<span class="lineno">  122 </span>              --   The actual class dictionary we need is obtained by applying the
<span class="lineno">  123 </span>              --   given field selectors (in reverse order!) to the term.
<span class="lineno">  124 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envC</span></span></span> :: Map C.Name C.Schema    -- ^ Cryptol type environment
<span class="lineno">  125 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">envS</span></span></span> :: [Term]                 -- ^ SAWCore bound variable environment (for type checking)
<span class="lineno">  126 </span>              -- FIXME: assuming this environment is to be indexed by De Bruijn indexes?
<span class="lineno">  127 </span>              -- FIXME: this field appears to be never read
<span class="lineno">  128 </span>              --   - verify and remove if so.
<span class="lineno">  129 </span>              --   - guessing that this would be useful if we want to do a SAWCore type check
<span class="lineno">  130 </span>              --     on an expression with free vars (which would be in this @envS@).
<span class="lineno">  131 </span>              -- FIXME: if this remains, use Vector instead.
<span class="lineno">  132 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">envRefPrims</span></span></span> :: Map C.PrimIdent C.Expr
<span class="lineno">  133 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">envPrims</span></span></span> :: Map C.PrimIdent Term -- ^ Translations for other primitives
<span class="lineno">  134 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">envPrimTypes</span></span></span> :: Map C.PrimIdent Term -- ^ Translations for primitive types
<span class="lineno">  135 </span>  }
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>emptyEnv :: Env
<span class="lineno">  138 </span><span class="decl"><span class="istickedoff">emptyEnv =</span>
<span class="lineno">  139 </span><span class="spaces">  </span><span class="istickedoff">Env Map.empty Map.empty Map.empty Map.empty <span class="nottickedoff">[]</span> <span class="nottickedoff">Map.empty</span> <span class="nottickedoff">Map.empty</span> <span class="nottickedoff">Map.empty</span></span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- FIXME: Regarding De Bruijn indices and documenting the use of
<span class="lineno">  142 </span>--   - are there abstractions (better abstractions) for managing them?
<span class="lineno">  143 </span>--   - should they really belong in this module?
<span class="lineno">  144 </span>--   - The term 'lift' is highly overused, how about another term?
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>-- FIXME: Can we define the terminology here (or elsewhere):
<span class="lineno">  147 </span>--   - loose = ?  same as free?
<span class="lineno">  148 </span>--   - 'dangling bound variables' = ??
<span class="lineno">  149 </span>--   - 'deferred shift amount' = ??
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- FIXME: A small effort has been made in this module to document the assumptions
<span class="lineno">  152 </span>-- regarding the De Bruijn assumptions/conventions of the generated SAWCore.
<span class="lineno">  153 </span>-- More of this would be desirable.
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>liftTerm :: (Term, Int) -&gt; (Term, Int)
<span class="lineno">  156 </span><span class="decl"><span class="istickedoff">liftTerm (t, j) = (t, j + 1)</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>liftProp :: (Term, [FieldName], Int) -&gt; (Term, [FieldName], Int)
<span class="lineno">  159 </span><span class="decl"><span class="istickedoff">liftProp (t, fns, j) = (t, fns, j + 1)</span></span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>-- | Increment dangling bound variables of various sorts in environment.
<span class="lineno">  162 </span>liftEnv :: Env -&gt; Env
<span class="lineno">  163 </span><span class="decl"><span class="istickedoff">liftEnv env =</span>
<span class="lineno">  164 </span><span class="spaces">  </span><span class="istickedoff">Env { envT = fmap liftTerm (envT env)</span>
<span class="lineno">  165 </span><span class="spaces">      </span><span class="istickedoff">, envE = fmap liftTerm (envE env)</span>
<span class="lineno">  166 </span><span class="spaces">      </span><span class="istickedoff">, envP = fmap liftProp (envP env)</span>
<span class="lineno">  167 </span><span class="spaces">      </span><span class="istickedoff">, envC = envC env</span>
<span class="lineno">  168 </span><span class="spaces">      </span><span class="istickedoff">, envS = <span class="nottickedoff">envS env</span></span>
<span class="lineno">  169 </span><span class="spaces">      </span><span class="istickedoff">, envRefPrims = <span class="nottickedoff">envRefPrims env</span></span>
<span class="lineno">  170 </span><span class="spaces">      </span><span class="istickedoff">, envPrims = <span class="nottickedoff">envPrims env</span></span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="istickedoff">, envPrimTypes = <span class="nottickedoff">envPrimTypes env</span></span>
<span class="lineno">  172 </span><span class="spaces">      </span><span class="istickedoff">}</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>bindTParam :: SharedContext -&gt; C.TParam -&gt; Env -&gt; IO Env
<span class="lineno">  175 </span><span class="decl"><span class="istickedoff">bindTParam sc tp env = do</span>
<span class="lineno">  176 </span><span class="spaces">  </span><span class="istickedoff">let env' = liftEnv env</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- scLocalVar sc 0</span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="istickedoff">k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">return $ env' { envT = Map.insert (C.tpUnique tp) (v, 0) (envT env')</span>
<span class="lineno">  180 </span><span class="spaces">                </span><span class="istickedoff">, envS = <span class="nottickedoff">k : envS env</span></span>
<span class="lineno">  181 </span><span class="spaces">                </span><span class="istickedoff">}</span></span>
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>-- | bindName - bind name in appropriate environments to De Bruijn index 0.
<span class="lineno">  184 </span>bindName :: SharedContext -&gt; C.Name -&gt; C.Schema -&gt; Env -&gt; IO Env
<span class="lineno">  185 </span><span class="decl"><span class="istickedoff">bindName sc name schema env = do</span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">let env' = liftEnv env</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- scLocalVar sc 0</span>
<span class="lineno">  188 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- importSchema sc env schema</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="istickedoff">return $ env' { envE = Map.insert name (v, 0) (envE env')</span>
<span class="lineno">  190 </span><span class="spaces">                </span><span class="istickedoff">, envC = Map.insert name schema (envC env')</span>
<span class="lineno">  191 </span><span class="spaces">                </span><span class="istickedoff">, envS = <span class="nottickedoff">t : envS env'</span></span>
<span class="lineno">  192 </span><span class="spaces">                </span><span class="istickedoff">}</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>bindProp :: SharedContext -&gt; C.Prop -&gt; Env -&gt; IO Env
<span class="lineno">  195 </span><span class="decl"><span class="istickedoff">bindProp sc prop env = do</span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="istickedoff">let env' = liftEnv env</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- scLocalVar sc 0</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff">k &lt;- scSort sc (mkSort 0)</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">return $ env' { envP = insertSupers prop [] v (envP env')</span>
<span class="lineno">  200 </span><span class="spaces">                </span><span class="istickedoff">, envS = <span class="nottickedoff">k : envS env'</span></span>
<span class="lineno">  201 </span><span class="spaces">                </span><span class="istickedoff">}</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>-- | When we insert a non-erasable prop into the environment, make
<span class="lineno">  204 </span>--   sure to also insert all its superclasses.  We arrange it so
<span class="lineno">  205 </span>--   that every class dictionary contains the implementation of its
<span class="lineno">  206 </span>--   superclass dictionaries, which can be extracted via field projections.
<span class="lineno">  207 </span>insertSupers ::
<span class="lineno">  208 </span>  C.Prop -&gt;
<span class="lineno">  209 </span>  [FieldName] {- Field names to project the associated class (in reverse order) -} -&gt;
<span class="lineno">  210 </span>  Term -&gt;
<span class="lineno">  211 </span>  Map C.Prop (Term, [FieldName], Int) -&gt;
<span class="lineno">  212 </span>  Map C.Prop (Term, [FieldName], Int)
<span class="lineno">  213 </span><span class="decl"><span class="istickedoff">insertSupers prop fs v m</span>
<span class="lineno">  214 </span><span class="spaces">  </span><span class="istickedoff">-- If the prop is already in the map, stop</span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="istickedoff">| Just _ &lt;- Map.lookup prop m = <span class="nottickedoff">m</span></span>
<span class="lineno">  216 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  217 </span><span class="spaces">  </span><span class="istickedoff">-- Insert the prop and check if it has any superclasses that also need to be added</span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Map.insert (normalizeProp prop) (v, fs, 0) $ go prop</span>
<span class="lineno">  219 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  220 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  221 </span><span class="spaces"> </span><span class="istickedoff">super p f t = insertSupers (C.TCon (C.PC p) [t]) (f:fs) v</span>
<span class="lineno">  222 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  223 </span><span class="spaces"> </span><span class="istickedoff">go (C.TCon (C.PC p) [t]) =</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">case p of</span>
<span class="lineno">  225 </span><span class="spaces">      </span><span class="istickedoff">C.PRing      -&gt; super C.PZero <span class="nottickedoff">&quot;ringZero&quot;</span> t m</span>
<span class="lineno">  226 </span><span class="spaces">      </span><span class="istickedoff">C.PLogic     -&gt; <span class="nottickedoff">super C.PZero &quot;logicZero&quot; t m</span></span>
<span class="lineno">  227 </span><span class="spaces">      </span><span class="istickedoff">C.PField     -&gt; <span class="nottickedoff">super C.PRing &quot;fieldRing&quot; t m</span></span>
<span class="lineno">  228 </span><span class="spaces">      </span><span class="istickedoff">C.PIntegral  -&gt; super C.PRing &quot;integralRing&quot; t m</span>
<span class="lineno">  229 </span><span class="spaces">      </span><span class="istickedoff">C.PRound     -&gt; <span class="nottickedoff">super C.PField &quot;roundField&quot; t . super C.PCmp &quot;roundCmp&quot; t $ m</span></span>
<span class="lineno">  230 </span><span class="spaces">      </span><span class="istickedoff">C.PCmp       -&gt; super C.PEq &quot;cmpEq&quot; t m</span>
<span class="lineno">  231 </span><span class="spaces">      </span><span class="istickedoff">C.PSignedCmp -&gt; super C.PEq <span class="nottickedoff">&quot;signedCmpEq&quot;</span> <span class="nottickedoff">t</span> m</span>
<span class="lineno">  232 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; m</span>
<span class="lineno">  233 </span><span class="spaces"> </span><span class="istickedoff">go _ = m</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>-- | We normalize the first argument of 'Literal' class constraints
<span class="lineno">  237 </span>-- arbitrarily to 'inf', so that we can ignore that parameter when
<span class="lineno">  238 </span>-- matching dictionaries.
<span class="lineno">  239 </span>normalizeProp :: C.Prop -&gt; C.Prop
<span class="lineno">  240 </span><span class="decl"><span class="istickedoff">normalizeProp prop</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff">| Just (_, a) &lt;- C.pIsLiteral prop = C.pLiteral C.tInf a</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">| Just (_, a) &lt;- C.pIsLiteralLessThan prop = C.pLiteralLessThan C.tInf a</span>
<span class="lineno">  243 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = prop</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>--------------------------------------------------------------------------------
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>importKind :: SharedContext -&gt; C.Kind -&gt; IO Term
<span class="lineno">  249 </span><span class="decl"><span class="istickedoff">importKind sc kind =</span>
<span class="lineno">  250 </span><span class="spaces">  </span><span class="istickedoff">case kind of</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">C.KType       -&gt; scISort sc (mkSort 0)</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">C.KNum        -&gt; scDataTypeApp sc &quot;Cryptol.Num&quot; []</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">C.KProp       -&gt; <span class="nottickedoff">scSort sc (mkSort 0)</span></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">(C.:-&gt;) k1 k2 -&gt; <span class="nottickedoff">join $ scFun sc &lt;$&gt; importKind sc k1 &lt;*&gt; importKind sc k2</span></span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>importTFun :: SharedContext -&gt; C.TFun -&gt; IO Term
<span class="lineno">  257 </span><span class="decl"><span class="istickedoff">importTFun sc tf =</span>
<span class="lineno">  258 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">C.TCWidth         -&gt; scGlobalDef sc &quot;Cryptol.tcWidth&quot;</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">C.TCAdd           -&gt; scGlobalDef sc &quot;Cryptol.tcAdd&quot;</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">C.TCSub           -&gt; scGlobalDef sc &quot;Cryptol.tcSub&quot;</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">C.TCMul           -&gt; scGlobalDef sc &quot;Cryptol.tcMul&quot;</span>
<span class="lineno">  263 </span><span class="spaces">    </span><span class="istickedoff">C.TCDiv           -&gt; scGlobalDef sc &quot;Cryptol.tcDiv&quot;</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">C.TCMod           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcMod&quot;</span></span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">C.TCExp           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcExp&quot;</span></span>
<span class="lineno">  266 </span><span class="spaces">    </span><span class="istickedoff">C.TCMin           -&gt; scGlobalDef sc &quot;Cryptol.tcMin&quot;</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">C.TCMax           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcMax&quot;</span></span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">C.TCCeilDiv       -&gt; scGlobalDef sc &quot;Cryptol.tcCeilDiv&quot;</span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">C.TCCeilMod       -&gt; scGlobalDef sc &quot;Cryptol.tcCeilMod&quot;</span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="istickedoff">C.TCLenFromThenTo -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.tcLenFromThenTo&quot;</span></span></span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>-- | Precondition: @not ('isErasedProp' pc)@.
<span class="lineno">  273 </span>importPC :: SharedContext -&gt; C.PC -&gt; IO Term
<span class="lineno">  274 </span><span class="decl"><span class="istickedoff">importPC sc pc =</span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="istickedoff">case pc of</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="istickedoff">C.PEqual           -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PEqual&quot;]</span></span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">C.PNeq             -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PNeq&quot;]</span></span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">C.PGeq             -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PGeq&quot;]</span></span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">C.PFin             -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PFin&quot;]</span></span>
<span class="lineno">  280 </span><span class="spaces">    </span><span class="istickedoff">C.PHas _           -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PHas&quot;]</span></span>
<span class="lineno">  281 </span><span class="spaces">    </span><span class="istickedoff">C.PPrime           -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PPrime&quot;]</span></span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="istickedoff">C.PZero            -&gt; scGlobalDef sc &quot;Cryptol.PZero&quot;</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">C.PLogic           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PLogic&quot;</span></span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff">C.PRing            -&gt; scGlobalDef sc &quot;Cryptol.PRing&quot;</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">C.PIntegral        -&gt; scGlobalDef sc &quot;Cryptol.PIntegral&quot;</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">C.PField           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PField&quot;</span></span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">C.PRound           -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PRound&quot;</span></span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">C.PEq              -&gt; scGlobalDef sc &quot;Cryptol.PEq&quot;</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">C.PCmp             -&gt; scGlobalDef sc &quot;Cryptol.PCmp&quot;</span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="istickedoff">C.PSignedCmp       -&gt; scGlobalDef sc &quot;Cryptol.PSignedCmp&quot;</span>
<span class="lineno">  291 </span><span class="spaces">    </span><span class="istickedoff">C.PLiteral         -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PLiteral&quot;</span></span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="istickedoff">C.PLiteralLessThan -&gt; <span class="nottickedoff">scGlobalDef sc &quot;Cryptol.PLiteralLessThan&quot;</span></span>
<span class="lineno">  293 </span><span class="spaces">    </span><span class="istickedoff">C.PAnd             -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PAnd&quot;]</span></span>
<span class="lineno">  294 </span><span class="spaces">    </span><span class="istickedoff">C.PTrue            -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PTrue&quot;]</span></span>
<span class="lineno">  295 </span><span class="spaces">    </span><span class="istickedoff">C.PFLiteral        -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PFLiteral&quot;]</span></span>
<span class="lineno">  296 </span><span class="spaces">    </span><span class="istickedoff">C.PValidFloat      -&gt; <span class="nottickedoff">panic &quot;importPC&quot; [&quot;found PValidFloat&quot;]</span></span></span>
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>-- | Translate size types to SAW values of type Num, value types to SAW types of sort 0.
<span class="lineno">  299 </span>importType :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Type -&gt; IO Term
<span class="lineno">  300 </span><span class="decl"><span class="istickedoff">importType sc env ty =</span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">C.TVar tvar -&gt;</span>
<span class="lineno">  303 </span><span class="spaces">      </span><span class="istickedoff">case tvar of</span>
<span class="lineno">  304 </span><span class="spaces">        </span><span class="istickedoff">C.TVFree{} {- Int Kind (Set TVar) Doc -} -&gt;</span>
<span class="lineno">  305 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importType&quot; [</span></span>
<span class="lineno">  306 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;TVFree in TVar is not supported: &quot; &lt;&gt; Text.pack (pretty ty)</span></span>
<span class="lineno">  307 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">C.TVBound v -&gt; case Map.lookup (C.tpUnique v) (envT env) of</span>
<span class="lineno">  309 </span><span class="spaces">            </span><span class="istickedoff">Just (t, j) -&gt; incVars sc 0 j t</span>
<span class="lineno">  310 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  311 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importType&quot; [</span></span>
<span class="lineno">  312 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;found TVar that's TVBound but doesn't exist: &quot; &lt;&gt; Text.pack (show $ pp v)</span></span>
<span class="lineno">  313 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">C.TUser _ _ t  -&gt; go t -- look through type synonyms</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="istickedoff">C.TRec fm -&gt;</span>
<span class="lineno">  316 </span><span class="spaces">      </span><span class="istickedoff">importType sc env (C.tTuple (map snd (C.canonicalFields fm)))</span>
<span class="lineno">  317 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  318 </span><span class="spaces">    </span><span class="istickedoff">C.TNominal nt ts -&gt;</span>
<span class="lineno">  319 </span><span class="spaces">      </span><span class="istickedoff">do let <span class="nottickedoff">s = C.listSubst (zip (map C.TVBound (C.ntParams nt)) ts)</span></span>
<span class="lineno">  320 </span><span class="spaces">         </span><span class="istickedoff">let n = C.ntName nt</span>
<span class="lineno">  321 </span><span class="spaces">         </span><span class="istickedoff">case ntDef nt of</span>
<span class="lineno">  322 </span><span class="spaces">           </span><span class="istickedoff">C.Struct stru -&gt; go (plainSubst <span class="nottickedoff">s</span> (C.TRec (C.ntFields stru)))</span>
<span class="lineno">  323 </span><span class="spaces">           </span><span class="istickedoff">C.Enum {} -&gt;</span>
<span class="lineno">  324 </span><span class="spaces">             </span><span class="istickedoff">-- The (parameterized) type should be in the sc env,</span>
<span class="lineno">  325 </span><span class="spaces">             </span><span class="istickedoff">-- just apply types to it:</span>
<span class="lineno">  326 </span><span class="spaces">             </span><span class="istickedoff">scGlobalApply sc (identOfEnumType n) =&lt;&lt; traverse go ts</span>
<span class="lineno">  327 </span><span class="spaces">           </span><span class="istickedoff">C.Abstract</span>
<span class="lineno">  328 </span><span class="spaces">             </span><span class="istickedoff">| Just prim' &lt;- <span class="nottickedoff">C.asPrim n</span></span>
<span class="lineno">  329 </span><span class="spaces">             </span><span class="istickedoff">, Just t &lt;- <span class="nottickedoff">Map.lookup prim' (envPrimTypes env)</span> -&gt;</span>
<span class="lineno">  330 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">scApplyAllBeta sc t =&lt;&lt; traverse go ts</span></span>
<span class="lineno">  331 </span><span class="spaces">             </span><span class="istickedoff">| <span class="nottickedoff">True</span> -&gt; <span class="nottickedoff">panic &quot;importType&quot; [</span></span>
<span class="lineno">  332 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot;Unknown primitive type: &quot; &lt;&gt; Text.pack (show n),</span></span>
<span class="lineno">  333 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot;Full type: &quot; &lt;&gt; Text.pack (pretty ty)</span></span>
<span class="lineno">  334 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  335 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="istickedoff">C.TCon tcon tyargs -&gt;</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="istickedoff">case tcon of</span>
<span class="lineno">  338 </span><span class="spaces">        </span><span class="istickedoff">C.TC tc -&gt;</span>
<span class="lineno">  339 </span><span class="spaces">          </span><span class="istickedoff">case tc of</span>
<span class="lineno">  340 </span><span class="spaces">            </span><span class="istickedoff">C.TCNum n    -&gt; scCtorApp sc &quot;Cryptol.TCNum&quot; =&lt;&lt; sequence [scNat sc (fromInteger n)]</span>
<span class="lineno">  341 </span><span class="spaces">            </span><span class="istickedoff">C.TCInf      -&gt; scCtorApp sc &quot;Cryptol.TCInf&quot; []</span>
<span class="lineno">  342 </span><span class="spaces">            </span><span class="istickedoff">C.TCBit      -&gt; scBoolType sc</span>
<span class="lineno">  343 </span><span class="spaces">            </span><span class="istickedoff">C.TCInteger  -&gt; scIntegerType sc</span>
<span class="lineno">  344 </span><span class="spaces">            </span><span class="istickedoff">C.TCIntMod   -&gt; scGlobalApply sc &quot;Cryptol.IntModNum&quot; =&lt;&lt; traverse go tyargs</span>
<span class="lineno">  345 </span><span class="spaces">            </span><span class="istickedoff">C.TCFloat    -&gt; <span class="nottickedoff">scGlobalApply sc &quot;Cryptol.TCFloat&quot;   =&lt;&lt; traverse go tyargs</span></span>
<span class="lineno">  346 </span><span class="spaces">            </span><span class="istickedoff">C.TCArray    -&gt; do a &lt;- go (tyargs !! 0)</span>
<span class="lineno">  347 </span><span class="spaces">                               </span><span class="istickedoff">b &lt;- go (tyargs !! 1)</span>
<span class="lineno">  348 </span><span class="spaces">                               </span><span class="istickedoff">scArrayType sc a b</span>
<span class="lineno">  349 </span><span class="spaces">            </span><span class="istickedoff">C.TCRational -&gt; <span class="nottickedoff">scGlobalApply sc &quot;Cryptol.Rational&quot; []</span></span>
<span class="lineno">  350 </span><span class="spaces">            </span><span class="istickedoff">C.TCSeq      -&gt; scGlobalApply sc &quot;Cryptol.seq&quot; =&lt;&lt; traverse go tyargs</span>
<span class="lineno">  351 </span><span class="spaces">            </span><span class="istickedoff">C.TCFun      -&gt; do a &lt;- go (tyargs !! 0)</span>
<span class="lineno">  352 </span><span class="spaces">                               </span><span class="istickedoff">b &lt;- go (tyargs !! 1)</span>
<span class="lineno">  353 </span><span class="spaces">                               </span><span class="istickedoff">scFun sc a b</span>
<span class="lineno">  354 </span><span class="spaces">            </span><span class="istickedoff">C.TCTuple _n -&gt; scTupleType sc =&lt;&lt; traverse go tyargs</span>
<span class="lineno">  355 </span><span class="spaces">        </span><span class="istickedoff">C.PC pc -&gt;</span>
<span class="lineno">  356 </span><span class="spaces">          </span><span class="istickedoff">case pc of</span>
<span class="lineno">  357 </span><span class="spaces">            </span><span class="istickedoff">C.PLiteral -&gt; -- we omit first argument to class Literal</span>
<span class="lineno">  358 </span><span class="spaces">              </span><span class="istickedoff">do a &lt;- go (tyargs !! 1)</span>
<span class="lineno">  359 </span><span class="spaces">                 </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteral&quot; [a]</span>
<span class="lineno">  360 </span><span class="spaces">            </span><span class="istickedoff">C.PLiteralLessThan -&gt; -- we omit first argument to class LiteralLessThan</span>
<span class="lineno">  361 </span><span class="spaces">              </span><span class="istickedoff">do a &lt;- go (tyargs !! 1)</span>
<span class="lineno">  362 </span><span class="spaces">                 </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralLessThan&quot; [a]</span>
<span class="lineno">  363 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  364 </span><span class="spaces">              </span><span class="istickedoff">do pc' &lt;- importPC sc pc</span>
<span class="lineno">  365 </span><span class="spaces">                 </span><span class="istickedoff">tyargs' &lt;- traverse go tyargs</span>
<span class="lineno">  366 </span><span class="spaces">                 </span><span class="istickedoff">scApplyAll sc pc' tyargs'</span>
<span class="lineno">  367 </span><span class="spaces">        </span><span class="istickedoff">C.TF tf -&gt;</span>
<span class="lineno">  368 </span><span class="spaces">          </span><span class="istickedoff">do tf' &lt;- importTFun sc tf</span>
<span class="lineno">  369 </span><span class="spaces">             </span><span class="istickedoff">tyargs' &lt;- traverse go tyargs</span>
<span class="lineno">  370 </span><span class="spaces">             </span><span class="istickedoff">scApplyAll sc tf' tyargs'</span>
<span class="lineno">  371 </span><span class="spaces">        </span><span class="istickedoff">C.TError _k -&gt;</span>
<span class="lineno">  372 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importType&quot; [&quot;found TError&quot;]</span></span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="istickedoff">go = importType sc env</span></span>
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>isErasedProp :: C.Prop -&gt; Bool
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">isErasedProp prop =</span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">case prop of</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PZero           ) _ -&gt; False</span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PLogic          ) _ -&gt; False</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PRing           ) _ -&gt; False</span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PIntegral       ) _ -&gt; False</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PField          ) _ -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PRound          ) _ -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  385 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PEq             ) _ -&gt; False</span>
<span class="lineno">  386 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PCmp            ) _ -&gt; False</span>
<span class="lineno">  387 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PSignedCmp      ) _ -&gt; False</span>
<span class="lineno">  388 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PLiteral        ) _ -&gt; False</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PLiteralLessThan) _ -&gt; False</span>
<span class="lineno">  390 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; True</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>-- | Translate a 'Prop' containing a numeric constraint to a 'Term' that tests
<span class="lineno">  393 </span>-- if the 'Prop' holds. This function will 'panic' for 'Prop's that are not
<span class="lineno">  394 </span>-- numeric constraints, such as @Integral@. In other words, this function
<span class="lineno">  395 </span>-- supports the same set of 'Prop's that constraint guards do.
<span class="lineno">  396 </span>importNumericConstraintAsBool :: SharedContext -&gt; Env -&gt; C.Prop -&gt; IO Term
<span class="lineno">  397 </span><span class="decl"><span class="istickedoff">importNumericConstraintAsBool sc env prop =</span>
<span class="lineno">  398 </span><span class="spaces">  </span><span class="istickedoff">case prop of</span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PEqual) [lhs, rhs] -&gt; eqTerm lhs rhs</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PNeq) [lhs, rhs] -&gt; eqTerm lhs rhs &gt;&gt;= scNot sc</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PGeq) [lhs, rhs] -&gt; do</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="istickedoff">-- Convert 'lhs &gt;= rhs' into '(rhs &lt; lhs) \/ (rhs == lhs)'</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="istickedoff">lhs' &lt;- importType sc env lhs</span>
<span class="lineno">  404 </span><span class="spaces">      </span><span class="istickedoff">rhs' &lt;- importType sc env rhs</span>
<span class="lineno">  405 </span><span class="spaces">      </span><span class="istickedoff">lt &lt;- scGlobalApply sc &quot;Cryptol.tcLt&quot; [rhs', lhs']</span>
<span class="lineno">  406 </span><span class="spaces">      </span><span class="istickedoff">eq &lt;- scGlobalApply sc &quot;Cryptol.tcEqual&quot; [rhs', lhs']</span>
<span class="lineno">  407 </span><span class="spaces">      </span><span class="istickedoff">scOr sc lt eq</span>
<span class="lineno">  408 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PFin) [x] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  409 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">x' &lt;- importType sc env x</span></span>
<span class="lineno">  410 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.tcFin&quot; [x']</span></span>
<span class="lineno">  411 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PAnd) [lhs, rhs] -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  412 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">lhs' &lt;- importType sc env lhs</span></span>
<span class="lineno">  413 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">rhs' &lt;- importType sc env rhs</span></span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">scAnd sc lhs' rhs'</span></span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.PC C.PTrue) [] -&gt; <span class="nottickedoff">scBool sc True</span></span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">C.TCon (C.TError _) _ -&gt; <span class="nottickedoff">scBool sc False</span></span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="istickedoff">C.TUser _ _ t -&gt; importNumericConstraintAsBool sc env t</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  419 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importNumericConstraintAsBool&quot; [</span></span>
<span class="lineno">  420 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Called with non-numeric constraint: &quot; &lt;&gt; Text.pack (pretty prop)</span></span>
<span class="lineno">  421 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  422 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="istickedoff">-- | Construct a term for equality of two types</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">eqTerm :: C.Type -&gt; C.Type -&gt; IO Term</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">eqTerm lhs rhs = do</span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="istickedoff">lhs' &lt;- importType sc env lhs</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="istickedoff">rhs' &lt;- importType sc <span class="nottickedoff">env</span> rhs</span>
<span class="lineno">  428 </span><span class="spaces">      </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.tcEqual&quot; [lhs', rhs']</span></span>
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>importPropsType :: SharedContext -&gt; Env -&gt; [C.Prop] -&gt; C.Type -&gt; IO Term
<span class="lineno">  431 </span><span class="decl"><span class="istickedoff">importPropsType sc env [] ty = importType sc env ty</span>
<span class="lineno">  432 </span><span class="spaces"></span><span class="istickedoff">importPropsType sc env (prop : props) ty</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="istickedoff">| isErasedProp prop = importPropsType sc env props ty</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">do p &lt;- importType sc env prop</span>
<span class="lineno">  436 </span><span class="spaces">       </span><span class="istickedoff">t &lt;- importPropsType sc env props ty</span>
<span class="lineno">  437 </span><span class="spaces">       </span><span class="istickedoff">scFun sc p t</span></span>
<span class="lineno">  438 </span>
<span class="lineno">  439 </span>nameToLocalName :: C.Name -&gt; LocalName
<span class="lineno">  440 </span><span class="decl"><span class="istickedoff">nameToLocalName = C.identText . C.nameIdent</span></span>
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>nameToFieldName :: C.Name -&gt; FieldName
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">nameToFieldName = C.identText . C.nameIdent</span></span>
<span class="lineno">  444 </span>
<span class="lineno">  445 </span>tparamToLocalName :: C.TParam -&gt; LocalName
<span class="lineno">  446 </span><span class="decl"><span class="istickedoff">tparamToLocalName tp = maybe (Text.pack (&quot;u&quot; ++ show (C.tpUnique tp))) nameToLocalName (C.tpName tp)</span></span>
<span class="lineno">  447 </span>
<span class="lineno">  448 </span>importPolyType :: SharedContext -&gt; Env -&gt; [C.TParam] -&gt; [C.Prop] -&gt; C.Type -&gt; IO Term
<span class="lineno">  449 </span><span class="decl"><span class="istickedoff">importPolyType sc env [] props ty = importPropsType sc env props ty</span>
<span class="lineno">  450 </span><span class="spaces"></span><span class="istickedoff">importPolyType sc env (tp : tps) props ty =</span>
<span class="lineno">  451 </span><span class="spaces">  </span><span class="istickedoff">do k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno">  452 </span><span class="spaces">     </span><span class="istickedoff">env' &lt;- bindTParam sc tp env</span>
<span class="lineno">  453 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- importPolyType sc env' tps props ty</span>
<span class="lineno">  454 </span><span class="spaces">     </span><span class="istickedoff">scPi sc (tparamToLocalName tp) k t</span></span>
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>importSchema :: SharedContext -&gt; Env -&gt; C.Schema -&gt; IO Term
<span class="lineno">  457 </span><span class="decl"><span class="istickedoff">importSchema sc env (C.Forall tparams props ty) = importPolyType sc env tparams props ty</span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>-- entry point
<span class="lineno">  460 </span>proveProp :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Prop -&gt; IO Term
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">proveProp sc env prop = provePropRec sc env prop prop</span></span>
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>-- internal recursive version
<span class="lineno">  464 </span>--
<span class="lineno">  465 </span>-- (we carry around the original prop when recursing as &quot;prop0&quot;, in
<span class="lineno">  466 </span>-- case we get stuck and need to bail out, at which point we want to
<span class="lineno">  467 </span>-- be able to print it)
<span class="lineno">  468 </span>provePropRec :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Prop -&gt; C.Prop -&gt; IO Term
<span class="lineno">  469 </span><span class="decl"><span class="istickedoff">provePropRec sc env prop0 prop =</span>
<span class="lineno">  470 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup (normalizeProp prop) (envP env) of</span>
<span class="lineno">  471 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">-- Class dictionary was provided as an argument</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">Just (prf, fs, j) -&gt;</span>
<span class="lineno">  474 </span><span class="spaces">       </span><span class="istickedoff">do -- shift deBruijn indicies by j</span>
<span class="lineno">  475 </span><span class="spaces">          </span><span class="istickedoff">v &lt;- incVars sc 0 j prf</span>
<span class="lineno">  476 </span><span class="spaces">          </span><span class="istickedoff">-- apply field projections as necessary to compute superclasses</span>
<span class="lineno">  477 </span><span class="spaces">          </span><span class="istickedoff">-- NB: reverse the order of the fields</span>
<span class="lineno">  478 </span><span class="spaces">          </span><span class="istickedoff">foldM (scRecordSelect sc) v (reverse fs)</span>
<span class="lineno">  479 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">-- Class dictionary not provided, compute it from the structure of types</span>
<span class="lineno">  481 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">case prop of</span>
<span class="lineno">  483 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero Bit</span>
<span class="lineno">  484 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  485 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PZeroBit&quot; []</span>
<span class="lineno">  486 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero Integer</span>
<span class="lineno">  487 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  488 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PZeroInteger&quot; []</span>
<span class="lineno">  489 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero (Z n)</span>
<span class="lineno">  490 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  491 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  492 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PZeroIntModNum&quot; [n']</span></span>
<span class="lineno">  493 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero Rational</span>
<span class="lineno">  494 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  495 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PZeroRational&quot; []</span></span>
<span class="lineno">  496 </span><span class="spaces">        </span><span class="istickedoff">-- instance Zero [n]</span>
<span class="lineno">  497 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  498 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  499 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PZeroSeqBool&quot; [n']</span>
<span class="lineno">  500 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Zero (Float e p)</span>
<span class="lineno">  501 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  502 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  503 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  504 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PZeroFloat&quot; [e', p']</span></span>
<span class="lineno">  505 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero a) =&gt; Zero [n]a</span>
<span class="lineno">  506 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  507 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  508 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc env a</span>
<span class="lineno">  509 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pZero a)</span>
<span class="lineno">  510 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PZeroSeq&quot; [n', a', pa]</span>
<span class="lineno">  511 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero b) =&gt; Zero (a -&gt; b)</span>
<span class="lineno">  512 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsFun -&gt; Just (a, b)))</span>
<span class="lineno">  513 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a' &lt;- importType sc env a</span></span>
<span class="lineno">  514 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- importType sc env b</span></span>
<span class="lineno">  515 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pZero b)</span></span>
<span class="lineno">  516 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PZeroFun&quot; [a', b', pb]</span></span>
<span class="lineno">  517 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero a, Zero b, ...) =&gt; Zero (a, b, ...)</span>
<span class="lineno">  518 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsTuple -&gt; Just ts))</span>
<span class="lineno">  519 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do ps &lt;- traverse (provePropRec sc env <span class="nottickedoff">prop0</span> . C.pZero) ts</span>
<span class="lineno">  520 </span><span class="spaces">                </span><span class="istickedoff">scTuple sc ps</span>
<span class="lineno">  521 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Zero a, Zero b, ...) =&gt; Zero { x : a, y : b, ... }</span>
<span class="lineno">  522 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsZero -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  523 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do provePropRec sc env <span class="nottickedoff">prop0</span> (C.pZero (C.tTuple (map snd (C.canonicalFields fm))))</span>
<span class="lineno">  524 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  525 </span><span class="spaces">        </span><span class="istickedoff">-- instance Logic Bit</span>
<span class="lineno">  526 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  527 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PLogicBit&quot; []</span>
<span class="lineno">  528 </span><span class="spaces">        </span><span class="istickedoff">-- instance Logic [n]</span>
<span class="lineno">  529 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  530 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  531 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLogicSeqBool&quot; [n']</span>
<span class="lineno">  532 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic a) =&gt; Logic [n]a</span>
<span class="lineno">  533 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  534 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  535 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc <span class="nottickedoff">env</span> a</span>
<span class="lineno">  536 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pLogic a)</span>
<span class="lineno">  537 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLogicSeq&quot; [n', a', pa]</span>
<span class="lineno">  538 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic b) =&gt; Logic (a -&gt; b)</span>
<span class="lineno">  539 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsFun -&gt; Just (a, b)))</span>
<span class="lineno">  540 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a' &lt;- importType sc env a</span></span>
<span class="lineno">  541 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- importType sc env b</span></span>
<span class="lineno">  542 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pLogic b)</span></span>
<span class="lineno">  543 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLogicFun&quot; [a', b', pb]</span></span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">-- instance Logic ()</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  546 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLogicUnit&quot; []</span></span>
<span class="lineno">  547 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic a, Logic b) =&gt; Logic (a, b)</span>
<span class="lineno">  548 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  549 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pLogic t)</span></span>
<span class="lineno">  550 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  551 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  552 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  553 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pLogic t)</span></span>
<span class="lineno">  554 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pLogic (C.tTuple ts))</span></span>
<span class="lineno">  555 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLogicPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  556 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Logic a, Logic b, ...) =&gt; instance Logic { x : a, y : b, ... }</span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLogic -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  558 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pLogic (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  559 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  560 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring Integer</span>
<span class="lineno">  561 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  562 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PRingInteger&quot; []</span>
<span class="lineno">  563 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring (Z n)</span>
<span class="lineno">  564 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  565 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  566 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PRingIntModNum&quot; [n']</span>
<span class="lineno">  567 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring Rational</span>
<span class="lineno">  568 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  569 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PRingRational&quot; []</span></span>
<span class="lineno">  570 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; Ring [n]</span>
<span class="lineno">  571 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  572 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  573 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PRingSeqBool&quot; [n']</span>
<span class="lineno">  574 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Ring (Float e p)</span>
<span class="lineno">  575 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  576 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  577 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  578 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRingFloat&quot; [e', p']</span></span>
<span class="lineno">  579 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring a) =&gt; Ring [n]a</span>
<span class="lineno">  580 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  581 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  582 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc env a</span>
<span class="lineno">  583 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env prop0 (C.pRing a)</span>
<span class="lineno">  584 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PRingSeq&quot; [n', a', pa]</span>
<span class="lineno">  585 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring b) =&gt; Ring (a -&gt; b)</span>
<span class="lineno">  586 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsFun -&gt; Just (a, b)))</span>
<span class="lineno">  587 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a' &lt;- importType sc env a</span></span>
<span class="lineno">  588 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b' &lt;- importType sc env b</span></span>
<span class="lineno">  589 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pRing b)</span></span>
<span class="lineno">  590 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRingFun&quot; [a', b', pb]</span></span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="istickedoff">-- instance Ring ()</span>
<span class="lineno">  592 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  593 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PRingUnit&quot; []</span></span>
<span class="lineno">  594 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring a, Ring b) =&gt; Ring (a, b)</span>
<span class="lineno">  595 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  596 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pRing t)</span></span>
<span class="lineno">  597 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  598 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  599 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  600 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pRing t)</span></span>
<span class="lineno">  601 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pRing (C.tTuple ts))</span></span>
<span class="lineno">  602 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRingPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  603 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Ring a, Ring b, ...) =&gt; instance Ring { x : a, y : b, ... }</span>
<span class="lineno">  604 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRing -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  605 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pRing (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  606 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  607 </span><span class="spaces">        </span><span class="istickedoff">-- instance Integral Integer</span>
<span class="lineno">  608 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsIntegral -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  609 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PIntegralInteger&quot; []</span>
<span class="lineno">  610 </span><span class="spaces">        </span><span class="istickedoff">-- instance Integral [n]</span>
<span class="lineno">  611 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsIntegral -&gt; Just (C.tIsSeq -&gt; (Just (n, C.tIsBit -&gt; True))))</span>
<span class="lineno">  612 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  613 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PIntegralSeqBool&quot; [n']</span>
<span class="lineno">  614 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  615 </span><span class="spaces">        </span><span class="istickedoff">-- instance Field Rational</span>
<span class="lineno">  616 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsField -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  617 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PFieldRational&quot; []</span></span>
<span class="lineno">  618 </span><span class="spaces">        </span><span class="istickedoff">-- instance (prime p) =&gt; Field (Z p)</span>
<span class="lineno">  619 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsField -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  620 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  621 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PFieldIntModNum&quot; [n']</span></span>
<span class="lineno">  622 </span><span class="spaces">        </span><span class="istickedoff">-- instance (ValidFloat e p) =&gt; Field (Float e p)</span>
<span class="lineno">  623 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsField -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  624 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  625 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  626 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PFieldFloat&quot; [e', p']</span></span>
<span class="lineno">  627 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  628 </span><span class="spaces">        </span><span class="istickedoff">-- instance Round Rational</span>
<span class="lineno">  629 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRound -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  630 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PRoundRational&quot; []</span></span>
<span class="lineno">  631 </span><span class="spaces">        </span><span class="istickedoff">-- instance (ValidFloat e p) =&gt; Round (Float e p)</span>
<span class="lineno">  632 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsRound -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  633 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  634 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  635 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PRoundFloat&quot; [e', p']</span></span>
<span class="lineno">  636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  637 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq Bit</span>
<span class="lineno">  638 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  639 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PEqBit&quot; []</span>
<span class="lineno">  640 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq Integer</span>
<span class="lineno">  641 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  642 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PEqInteger&quot; []</span>
<span class="lineno">  643 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq (Z n)</span>
<span class="lineno">  644 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  645 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  646 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqIntModNum&quot; [n']</span>
<span class="lineno">  647 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq Rational</span>
<span class="lineno">  648 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  649 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PEqRational&quot; []</span></span>
<span class="lineno">  650 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq (Float e p)</span>
<span class="lineno">  651 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  652 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  653 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  654 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PEqFloat&quot; [e', p']</span></span>
<span class="lineno">  655 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; Eq [n]</span>
<span class="lineno">  656 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  657 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  658 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqSeqBool&quot; [n']</span>
<span class="lineno">  659 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, Eq a) =&gt; Eq [n]a</span>
<span class="lineno">  660 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  661 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  662 </span><span class="spaces">                </span><span class="istickedoff">a' &lt;- importType sc <span class="nottickedoff">env</span> a</span>
<span class="lineno">  663 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq a)</span>
<span class="lineno">  664 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqSeq&quot; [n', a', pa]</span>
<span class="lineno">  665 </span><span class="spaces">        </span><span class="istickedoff">-- instance Eq ()</span>
<span class="lineno">  666 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  667 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PEqUnit&quot; []</span>
<span class="lineno">  668 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Eq a, Eq b) =&gt; Eq (a, b)</span>
<span class="lineno">  669 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  670 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq t)</span>
<span class="lineno">  671 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  672 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do a &lt;- importType sc <span class="nottickedoff">env</span> t</span>
<span class="lineno">  673 </span><span class="spaces">                </span><span class="istickedoff">b &lt;- importType sc <span class="nottickedoff">env</span> (C.tTuple ts)</span>
<span class="lineno">  674 </span><span class="spaces">                </span><span class="istickedoff">pa &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq t)</span>
<span class="lineno">  675 </span><span class="spaces">                </span><span class="istickedoff">pb &lt;- provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq (C.tTuple ts))</span>
<span class="lineno">  676 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PEqPair&quot; [a, b, pa, pb]</span>
<span class="lineno">  677 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Eq a, Eq b, ...) =&gt; instance Eq { x : a, y : b, ... }</span>
<span class="lineno">  678 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsEq -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  679 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do provePropRec sc env <span class="nottickedoff">prop0</span> (C.pEq (C.tTuple (map snd (C.canonicalFields fm))))</span>
<span class="lineno">  680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  681 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp Bit</span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsBit -&gt; True))</span>
<span class="lineno">  683 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PCmpBit&quot; []</span></span>
<span class="lineno">  684 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp Integer</span>
<span class="lineno">  685 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsInteger -&gt; True))</span>
<span class="lineno">  686 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PCmpInteger&quot; []</span>
<span class="lineno">  687 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp Rational</span>
<span class="lineno">  688 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsRational -&gt; True))</span>
<span class="lineno">  689 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PCmpRational&quot; []</span></span>
<span class="lineno">  690 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp (Float e p)</span>
<span class="lineno">  691 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  692 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  693 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  694 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PCmpFloat&quot; [e', p']</span></span>
<span class="lineno">  695 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; Cmp [n]</span>
<span class="lineno">  696 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  697 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  698 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PCmpSeqBool&quot; [n']</span>
<span class="lineno">  699 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, Cmp a) =&gt; Cmp [n]a</span>
<span class="lineno">  700 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  701 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  702 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">a' &lt;- importType sc env a</span></span>
<span class="lineno">  703 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pCmp a)</span></span>
<span class="lineno">  704 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PCmpSeq&quot; [n', a', pa]</span></span>
<span class="lineno">  705 </span><span class="spaces">        </span><span class="istickedoff">-- instance Cmp ()</span>
<span class="lineno">  706 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  707 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PCmpUnit&quot; []</span></span>
<span class="lineno">  708 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Cmp a, Cmp b) =&gt; Cmp (a, b)</span>
<span class="lineno">  709 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  710 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pCmp t)</span></span>
<span class="lineno">  711 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  712 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  713 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  714 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pCmp t)</span></span>
<span class="lineno">  715 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pCmp (C.tTuple ts))</span></span>
<span class="lineno">  716 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PCmpPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  717 </span><span class="spaces">        </span><span class="istickedoff">-- instance (Cmp a, Cmp b, ...) =&gt; instance Cmp { x : a, y : b, ... }</span>
<span class="lineno">  718 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsCmp -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  719 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pCmp (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  720 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  721 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n) =&gt; SignedCmp [n]</span>
<span class="lineno">  722 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  723 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  724 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PSignedCmpSeqBool&quot; [n']</span>
<span class="lineno">  725 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, SignedCmp a) =&gt; SignedCmp [n]a</span>
<span class="lineno">  726 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsSeq -&gt; Just (n, a)))</span>
<span class="lineno">  727 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  728 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">a' &lt;- importType sc env a</span></span>
<span class="lineno">  729 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pSignedCmp a)</span></span>
<span class="lineno">  730 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PSignedCmpSeq&quot; [n', a', pa]</span></span>
<span class="lineno">  731 </span><span class="spaces">        </span><span class="istickedoff">-- instance SignedCmp ()</span>
<span class="lineno">  732 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsTuple -&gt; Just []))</span>
<span class="lineno">  733 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PSignedCmpUnit&quot; []</span></span>
<span class="lineno">  734 </span><span class="spaces">        </span><span class="istickedoff">-- instance (SignedCmp a, SignedCmp b) =&gt; SignedCmp (a, b)</span>
<span class="lineno">  735 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsTuple -&gt; Just [t]))</span>
<span class="lineno">  736 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pSignedCmp t)</span></span>
<span class="lineno">  737 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsTuple -&gt; Just (t : ts)))</span>
<span class="lineno">  738 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do a &lt;- importType sc env t</span></span>
<span class="lineno">  739 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">b &lt;- importType sc env (C.tTuple ts)</span></span>
<span class="lineno">  740 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pa &lt;- provePropRec sc env prop0 (C.pSignedCmp t)</span></span>
<span class="lineno">  741 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pb &lt;- provePropRec sc env prop0 (C.pSignedCmp (C.tTuple ts))</span></span>
<span class="lineno">  742 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PSignedCmpPair&quot; [a, b, pa, pb]</span></span>
<span class="lineno">  743 </span><span class="spaces">        </span><span class="istickedoff">-- instance (SignedCmp a, SignedCmp b, ...) =&gt; instance SignedCmp { x : a, y : b, ... }</span>
<span class="lineno">  744 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsSignedCmp -&gt; Just (C.tIsRec -&gt; Just fm))</span>
<span class="lineno">  745 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do provePropRec sc env prop0 (C.pSignedCmp (C.tTuple (map snd (C.canonicalFields fm))))</span></span>
<span class="lineno">  746 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  747 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Bit</span>
<span class="lineno">  748 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsBit -&gt; True))</span>
<span class="lineno">  749 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PLiteralBit&quot; []</span>
<span class="lineno">  750 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Integer</span>
<span class="lineno">  751 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsInteger -&gt; True))</span>
<span class="lineno">  752 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do scGlobalApply sc &quot;Cryptol.PLiteralInteger&quot; []</span>
<span class="lineno">  753 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val (Z n)</span>
<span class="lineno">  754 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  755 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  756 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralIntModNum&quot; [n']</span>
<span class="lineno">  757 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Rational</span>
<span class="lineno">  758 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsRational -&gt; True))</span>
<span class="lineno">  759 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralRational&quot; []</span></span>
<span class="lineno">  760 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, n &gt;= width val) =&gt; Literal val [n]</span>
<span class="lineno">  761 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  762 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc env n</span>
<span class="lineno">  763 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralSeqBool&quot; [n']</span>
<span class="lineno">  764 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Literal val (Float e p) (with extra constraints)</span>
<span class="lineno">  765 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteral -&gt; Just (_, C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  766 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  767 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  768 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLiteralFloat&quot; [e', p']</span></span>
<span class="lineno">  769 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  770 </span><span class="spaces">        </span><span class="istickedoff">-- instance (2 &gt;= val) =&gt; LiteralLessThan val Bit</span>
<span class="lineno">  771 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsBit -&gt; True))</span>
<span class="lineno">  772 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralBit&quot; []</span></span>
<span class="lineno">  773 </span><span class="spaces">        </span><span class="istickedoff">-- instance LiteralLessThan val Integer</span>
<span class="lineno">  774 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsInteger -&gt; True))</span>
<span class="lineno">  775 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralInteger&quot; []</span></span>
<span class="lineno">  776 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, n &gt;= 1, n &gt;= val) LiteralLessThan val (Z n)</span>
<span class="lineno">  777 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsIntMod -&gt; Just n))</span>
<span class="lineno">  778 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do n' &lt;- importType sc env n</span></span>
<span class="lineno">  779 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLiteralIntModNum&quot; [n']</span></span>
<span class="lineno">  780 </span><span class="spaces">        </span><span class="istickedoff">-- instance Literal val Rational</span>
<span class="lineno">  781 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsRational -&gt; True))</span>
<span class="lineno">  782 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do scGlobalApply sc &quot;Cryptol.PLiteralRational&quot; []</span></span>
<span class="lineno">  783 </span><span class="spaces">        </span><span class="istickedoff">-- instance (fin n, n &gt;= lg2 val) =&gt; Literal val [n]</span>
<span class="lineno">  784 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsSeq -&gt; Just (n, C.tIsBit -&gt; True)))</span>
<span class="lineno">  785 </span><span class="spaces">          </span><span class="istickedoff">-&gt; do n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno">  786 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.PLiteralSeqBool&quot; [n']</span>
<span class="lineno">  787 </span><span class="spaces">        </span><span class="istickedoff">-- instance ValidFloat e p =&gt; Literal val (Float e p) (with extra constraints)</span>
<span class="lineno">  788 </span><span class="spaces">        </span><span class="istickedoff">(C.pIsLiteralLessThan -&gt; Just (_, C.tIsFloat -&gt; Just (e, p)))</span>
<span class="lineno">  789 </span><span class="spaces">          </span><span class="istickedoff">-&gt; <span class="nottickedoff">do e' &lt;- importType sc env e</span></span>
<span class="lineno">  790 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- importType sc env p</span></span>
<span class="lineno">  791 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.PLiteralFloat&quot; [e', p']</span></span>
<span class="lineno">  792 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  793 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno">  794 </span><span class="spaces">            </span><span class="istickedoff">let prop0' = &quot;   &quot; &lt;&gt; Text.pack (pretty prop0)</span>
<span class="lineno">  795 </span><span class="spaces">                </span><span class="istickedoff">prop' = &quot;   &quot; &lt;&gt; Text.pack (pretty prop)</span>
<span class="lineno">  796 </span><span class="spaces">                </span><span class="istickedoff">env' = map (\p -&gt; &quot;   &quot; &lt;&gt; Text.pack (pretty p)) $ Map.keys $ envP env</span>
<span class="lineno">  797 </span><span class="spaces">                </span><span class="istickedoff">message = [</span>
<span class="lineno">  798 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Cannot find or infer typeclass instance&quot;,</span>
<span class="lineno">  799 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Property needed:&quot;,</span>
<span class="lineno">  800 </span><span class="spaces">                    </span><span class="istickedoff">prop',</span>
<span class="lineno">  801 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Original property:&quot;,</span>
<span class="lineno">  802 </span><span class="spaces">                    </span><span class="istickedoff">prop0',</span>
<span class="lineno">  803 </span><span class="spaces">                    </span><span class="istickedoff">&quot;Available propositions in the environment:&quot;</span>
<span class="lineno">  804 </span><span class="spaces">                 </span><span class="istickedoff">] ++ env'</span>
<span class="lineno">  805 </span><span class="spaces">            </span><span class="istickedoff">panic &quot;proveProp&quot; message</span></span>
<span class="lineno">  806 </span>
<span class="lineno">  807 </span>importPrimitive :: SharedContext -&gt; ImportPrimitiveOptions -&gt; Env -&gt; C.Name -&gt; C.Schema -&gt; IO Term
<span class="lineno">  808 </span><span class="decl"><span class="istickedoff">importPrimitive sc primOpts env n sch</span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="istickedoff">-- lookup primitive in the main primitive lookup table</span>
<span class="lineno">  810 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- C.asPrim n, Just term &lt;- Map.lookup nm allPrims = term sc</span>
<span class="lineno">  811 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff">-- lookup primitive in the main reference implementation lookup table</span>
<span class="lineno">  813 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- C.asPrim n, Just expr &lt;- Map.lookup nm (envRefPrims env) =</span>
<span class="lineno">  814 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- importSchema sc env sch</span>
<span class="lineno">  815 </span><span class="spaces">         </span><span class="istickedoff">e &lt;- importExpr sc env expr</span>
<span class="lineno">  816 </span><span class="spaces">         </span><span class="istickedoff">nmi &lt;- importName n</span>
<span class="lineno">  817 </span><span class="spaces">         </span><span class="istickedoff">scConstant' sc nmi e t</span>
<span class="lineno">  818 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  819 </span><span class="spaces">  </span><span class="istickedoff">-- lookup primitive in the extra primitive lookup table</span>
<span class="lineno">  820 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- <span class="nottickedoff">C.asPrim n</span>, Just t &lt;- <span class="nottickedoff">Map.lookup nm (envPrims env)</span> = <span class="nottickedoff">return t</span></span>
<span class="lineno">  821 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  822 </span><span class="spaces">  </span><span class="istickedoff">-- Optionally, create an opaque constant representing the primitive</span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="istickedoff">-- if it doesn't match one of the ones we know about.</span>
<span class="lineno">  824 </span><span class="spaces">  </span><span class="istickedoff">| Just _ &lt;- <span class="nottickedoff">C.asPrim n</span>, <span class="nottickedoff">allowUnknownPrimitives primOpts</span> =</span>
<span class="lineno">  825 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">importOpaque sc env n sch</span></span>
<span class="lineno">  826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff">-- Panic if we don't know the given primitive (TODO? probably shouldn't be a panic)</span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="istickedoff">| Just nm &lt;- <span class="nottickedoff">C.asPrim n</span> =</span>
<span class="lineno">  829 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importPrimitive&quot; [&quot;Unknown Cryptol primitive name: &quot; &lt;&gt; Text.pack (show nm)]</span></span>
<span class="lineno">  830 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> =</span>
<span class="lineno">  832 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importPrimitive&quot; [&quot;Improper Cryptol primitive name: &quot; &lt;&gt; Text.pack (show n)]</span></span></span>
<span class="lineno">  833 </span>
<span class="lineno">  834 </span>-- | Create an opaque constant with the given name and schema
<span class="lineno">  835 </span>importOpaque :: SharedContext -&gt; Env -&gt; C.Name -&gt; C.Schema -&gt; IO Term
<span class="lineno">  836 </span><span class="decl"><span class="istickedoff">importOpaque sc env n sch = do</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- importSchema sc <span class="nottickedoff">env</span> sch</span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="istickedoff">nmi &lt;- importName n</span>
<span class="lineno">  839 </span><span class="spaces">  </span><span class="istickedoff">scOpaqueConstant sc nmi t</span></span>
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>importConstant :: SharedContext -&gt; Env -&gt; C.Name -&gt; C.Schema -&gt; Term -&gt; IO Term
<span class="lineno">  842 </span><span class="decl"><span class="istickedoff">importConstant sc env n sch rhs = do</span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="istickedoff">nmi &lt;- importName n</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- importSchema sc env sch</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff">scConstant' sc nmi rhs t</span></span>
<span class="lineno">  846 </span>
<span class="lineno">  847 </span>allPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  848 </span><span class="decl"><span class="istickedoff">allPrims = prelPrims &lt;&gt; arrayPrims &lt;&gt; floatPrims &lt;&gt; suiteBPrims &lt;&gt; primeECPrims</span></span>
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>prelPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  851 </span><span class="decl"><span class="istickedoff">prelPrims =</span>
<span class="lineno">  852 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  853 </span><span class="spaces">  </span><span class="istickedoff">first C.prelPrim &lt;$&gt;</span>
<span class="lineno">  854 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;True&quot;,         flip scBool True)</span>
<span class="lineno">  855 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;False&quot;,        flip scBool False)</span>
<span class="lineno">  856 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;number&quot;,       flip scGlobalDef &quot;Cryptol.ecNumber&quot;)      -- Converts a numeric type into its corresponding value.</span>
<span class="lineno">  857 </span><span class="spaces">     </span><span class="istickedoff">--                                                        -- {val, a} (Literal val a) =&gt; a</span>
<span class="lineno">  858 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  859 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromZ&quot;,        flip scGlobalDef &quot;Cryptol.ecFromZ&quot;)       -- {n} (fin n, n &gt;= 1) =&gt; Z n -&gt; Integer</span>
<span class="lineno">  860 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  861 </span><span class="spaces">    </span><span class="istickedoff">-- -- Zero</span>
<span class="lineno">  862 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;zero&quot;,         flip scGlobalDef &quot;Cryptol.ecZero&quot;)        -- {a} (Zero a) =&gt; a</span>
<span class="lineno">  863 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  864 </span><span class="spaces">    </span><span class="istickedoff">-- -- Logic</span>
<span class="lineno">  865 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&amp;&amp;&quot;,           flip scGlobalDef &quot;Cryptol.ecAnd&quot;)         -- {a} (Logic a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  866 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;||&quot;,           flip scGlobalDef &quot;Cryptol.ecOr&quot;)          -- {a} (Logic a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;^&quot;,            flip scGlobalDef &quot;Cryptol.ecXor&quot;)         -- {a} (Logic a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  868 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;complement&quot;,   flip scGlobalDef &quot;Cryptol.ecCompl&quot;)       -- {a} (Logic a) =&gt; a -&gt; a</span>
<span class="lineno">  869 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  870 </span><span class="spaces">    </span><span class="istickedoff">-- -- Ring</span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromInteger&quot;,  flip scGlobalDef &quot;Cryptol.ecFromInteger&quot;) -- {a} (Ring a) =&gt; Integer -&gt; a</span>
<span class="lineno">  872 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;+&quot;,            flip scGlobalDef &quot;Cryptol.ecPlus&quot;)        -- {a} (Ring a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  873 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;-&quot;,            flip scGlobalDef &quot;Cryptol.ecMinus&quot;)       -- {a} (Ring a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  874 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;*&quot;,            flip scGlobalDef &quot;Cryptol.ecMul&quot;)         -- {a} (Ring a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  875 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;negate&quot;,       flip scGlobalDef &quot;Cryptol.ecNeg&quot;)         -- {a} (Ring a) =&gt; a -&gt; a</span>
<span class="lineno">  876 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  877 </span><span class="spaces">    </span><span class="istickedoff">-- -- Integral</span>
<span class="lineno">  878 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;toInteger&quot;,    flip scGlobalDef &quot;Cryptol.ecToInteger&quot;)   -- {a} (Integral a) =&gt; a -&gt; Integer</span>
<span class="lineno">  879 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;/&quot;,            flip scGlobalDef &quot;Cryptol.ecDiv&quot;)         -- {a} (Integral a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  880 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;%&quot;,            flip scGlobalDef &quot;Cryptol.ecMod&quot;)         -- {a} (Integral a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;^^&quot;,           flip scGlobalDef &quot;Cryptol.ecExp&quot;)         -- {a} (Ring a, Integral b) =&gt; a -&gt; b -&gt; a</span>
<span class="lineno">  882 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;infFrom&quot;,      flip scGlobalDef &quot;Cryptol.ecInfFrom&quot;)     -- {a} (Integral a) =&gt; a -&gt; [inf]a</span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;infFromThen&quot;,  flip scGlobalDef &quot;Cryptol.ecInfFromThen&quot;) -- {a} (Integral a) =&gt; a -&gt; a -&gt; [inf]a</span>
<span class="lineno">  884 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  885 </span><span class="spaces">    </span><span class="istickedoff">-- -- Field</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;recip&quot;,        flip scGlobalDef &quot;Cryptol.ecRecip&quot;)       -- {a} (Field a) =&gt; a -&gt; a</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;/.&quot;,           flip scGlobalDef &quot;Cryptol.ecFieldDiv&quot;)    -- {a} (Field a) =&gt; a -&gt; a -&gt; a</span>
<span class="lineno">  888 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  889 </span><span class="spaces">    </span><span class="istickedoff">-- -- Round</span>
<span class="lineno">  890 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ceiling&quot;,      flip scGlobalDef &quot;Cryptol.ecCeiling&quot;)     -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  891 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;floor&quot;,        flip scGlobalDef &quot;Cryptol.ecFloor&quot;)       -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  892 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;trunc&quot;,        flip scGlobalDef &quot;Cryptol.ecTruncate&quot;)    -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  893 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;roundAway&quot;,    flip scGlobalDef &quot;Cryptol.ecRoundAway&quot;)   -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;roundToEven&quot;,  flip scGlobalDef &quot;Cryptol.ecRoundToEven&quot;) -- {a} (Round a) =&gt; a -&gt; Integer</span>
<span class="lineno">  895 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  896 </span><span class="spaces">    </span><span class="istickedoff">-- -- Eq</span>
<span class="lineno">  897 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;==&quot;,           flip scGlobalDef &quot;Cryptol.ecEq&quot;)          -- {a} (Eq a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;!=&quot;,           flip scGlobalDef &quot;Cryptol.ecNotEq&quot;)       -- {a} (Eq a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  899 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  900 </span><span class="spaces">    </span><span class="istickedoff">-- -- Cmp</span>
<span class="lineno">  901 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;&quot;,            flip scGlobalDef &quot;Cryptol.ecLt&quot;)          -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  902 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&quot;,            flip scGlobalDef &quot;Cryptol.ecGt&quot;)          -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  903 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;=&quot;,           flip scGlobalDef &quot;Cryptol.ecLtEq&quot;)        -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  904 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;=&quot;,           flip scGlobalDef &quot;Cryptol.ecGtEq&quot;)        -- {a} (Cmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  905 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  906 </span><span class="spaces">    </span><span class="istickedoff">-- -- SignedCmp</span>
<span class="lineno">  907 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;$&quot;,           flip scGlobalDef &quot;Cryptol.ecSLt&quot;)         -- {a} (SignedCmp a) =&gt; a -&gt; a -&gt; Bit</span>
<span class="lineno">  908 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  909 </span><span class="spaces">    </span><span class="istickedoff">-- -- Bitvector primitives</span>
<span class="lineno">  910 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;/$&quot;,           flip scGlobalDef &quot;Cryptol.ecSDiv&quot;)        -- {n} (fin n, n&gt;=1) =&gt; [n] -&gt; [n] -&gt; [n]</span>
<span class="lineno">  911 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;%$&quot;,           flip scGlobalDef &quot;Cryptol.ecSMod&quot;)        -- {n} (fin n, n&gt;=1) =&gt; [n] -&gt; [n] -&gt; [n]</span>
<span class="lineno">  912 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;lg2&quot;,          flip scGlobalDef &quot;Cryptol.ecLg2&quot;)         -- {n} (fin n) =&gt; [n] -&gt; [n]</span>
<span class="lineno">  913 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&gt;$&quot;,          flip scGlobalDef &quot;Cryptol.ecSShiftR&quot;)     -- {n, ix} (fin n, n &gt;= 1, Integral ix) =&gt; [n] -&gt; ix -&gt; [n]</span>
<span class="lineno">  914 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;toSignedInteger&quot;,</span>
<span class="lineno">  915 </span><span class="spaces">                     </span><span class="istickedoff">flip scGlobalDef &quot;Cryptol.toSignedInteger&quot;) -- {n} (fin n, n &gt;= 1) =&gt; [n] -&gt; Integer</span>
<span class="lineno">  916 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  917 </span><span class="spaces">    </span><span class="istickedoff">-- -- Rational primitives</span>
<span class="lineno">  918 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ratio&quot;,        flip scGlobalDef &quot;Cryptol.ecRatio&quot;)       -- Integer -&gt; Integer -&gt; Rational</span>
<span class="lineno">  919 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  920 </span><span class="spaces">    </span><span class="istickedoff">-- -- FLiteral</span>
<span class="lineno">  921 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fraction&quot;,     flip scGlobalDef &quot;Cryptol.ecFraction&quot;)    -- {m, n, r, a} FLiteral m n r a =&gt; a</span>
<span class="lineno">  922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="istickedoff">-- -- Shifts/rotates</span>
<span class="lineno">  924 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;&lt;&quot;,           flip scGlobalDef &quot;Cryptol.ecShiftL&quot;)      -- {n, ix, a} (Integral ix, Zero a) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  925 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&gt;&quot;,           flip scGlobalDef &quot;Cryptol.ecShiftR&quot;)      -- {n, ix, a} (Integral ix, Zero a) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  926 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&lt;&lt;&lt;&quot;,          flip scGlobalDef &quot;Cryptol.ecRotL&quot;)        -- {n, ix, a} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  927 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;&gt;&gt;&gt;&quot;,          flip scGlobalDef &quot;Cryptol.ecRotR&quot;)        -- {n, ix, a} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; [n]a</span>
<span class="lineno">  928 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  929 </span><span class="spaces">    </span><span class="istickedoff">-- -- Sequences primitives</span>
<span class="lineno">  930 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;#&quot;,            flip scGlobalDef &quot;Cryptol.ecCat&quot;)         -- {a,b,d} (fin a) =&gt; [a] d -&gt; [b] d -&gt; [a + b] d</span>
<span class="lineno">  931 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;take&quot;,         flip scGlobalDef &quot;Cryptol.ecTake&quot;)        -- {front, back, a} [front + back]a -&gt; [front]a</span>
<span class="lineno">  932 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;drop&quot;,         flip scGlobalDef &quot;Cryptol.ecDrop&quot;)        -- {front, back, a} (fin front) =&gt; [front + back]a -&gt; [back]a</span>
<span class="lineno">  933 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;join&quot;,         flip scGlobalDef &quot;Cryptol.ecJoin&quot;)        -- {a,b,c} (fin b) =&gt; [a][b]c -&gt; [a * b]c</span>
<span class="lineno">  934 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;split&quot;,        flip scGlobalDef &quot;Cryptol.ecSplit&quot;)       -- {a,b,c} (fin b) =&gt; [a * b] c -&gt; [a][b] c</span>
<span class="lineno">  935 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;reverse&quot;,      flip scGlobalDef &quot;Cryptol.ecReverse&quot;)     -- {a,b} (fin a) =&gt; [a] b -&gt; [a] b</span>
<span class="lineno">  936 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;transpose&quot;,    flip scGlobalDef &quot;Cryptol.ecTranspose&quot;)   -- {a,b,c} [a][b]c -&gt; [b][a]c</span>
<span class="lineno">  937 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;@&quot;,            flip scGlobalDef &quot;Cryptol.ecAt&quot;)          -- {n, a, ix} (Integral ix) =&gt; [n]a -&gt; ix -&gt; a</span>
<span class="lineno">  938 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;!&quot;,            flip scGlobalDef &quot;Cryptol.ecAtBack&quot;)      -- {n, a, ix} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; a</span>
<span class="lineno">  939 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;update&quot;,       flip scGlobalDef &quot;Cryptol.ecUpdate&quot;)      -- {n, a, ix} (Integral ix) =&gt; [n]a -&gt; ix -&gt; a -&gt; [n]a</span>
<span class="lineno">  940 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;updateEnd&quot;,    flip scGlobalDef &quot;Cryptol.ecUpdateEnd&quot;)   -- {n, a, ix} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; a -&gt; [n]a</span>
<span class="lineno">  941 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  942 </span><span class="spaces">    </span><span class="istickedoff">-- -- Enumerations</span>
<span class="lineno">  943 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromTo&quot;,         flip scGlobalDef &quot;Cryptol.ecFromTo&quot;)</span>
<span class="lineno">  944 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromTo : {first, last, bits, a}</span>
<span class="lineno">  945 </span><span class="spaces">                                  </span><span class="istickedoff">--           ( fin last, fin bits, last &gt;== first,</span>
<span class="lineno">  946 </span><span class="spaces">                                  </span><span class="istickedoff">--             Literal first a, Literal last a)</span>
<span class="lineno">  947 </span><span class="spaces">                                  </span><span class="istickedoff">--        =&gt; [1 + (last - first)]a</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToLessThan&quot;, flip scGlobalDef &quot;Cryptol.ecFromToLessThan&quot;)</span>
<span class="lineno">  949 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToLessThan : {first, bound, a}</span>
<span class="lineno">  950 </span><span class="spaces">                                  </span><span class="istickedoff">--                   ( fin first, bound &gt;= first,</span>
<span class="lineno">  951 </span><span class="spaces">                                  </span><span class="istickedoff">--                     LiteralLessThan bound a)</span>
<span class="lineno">  952 </span><span class="spaces">                                  </span><span class="istickedoff">--                =&gt; [bound - first]a</span>
<span class="lineno">  953 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromThenTo&quot;,     flip scGlobalDef &quot;Cryptol.ecFromThenTo&quot;)</span>
<span class="lineno">  954 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromThenTo : {first, next, last, a, len}</span>
<span class="lineno">  955 </span><span class="spaces">                                  </span><span class="istickedoff">--              ( fin first, fin next, fin last</span>
<span class="lineno">  956 </span><span class="spaces">                                  </span><span class="istickedoff">--              , Literal first a, Literal next a, Literal last a</span>
<span class="lineno">  957 </span><span class="spaces">                                  </span><span class="istickedoff">--              , first != next</span>
<span class="lineno">  958 </span><span class="spaces">                                  </span><span class="istickedoff">--              , lengthFromThenTo first next last == len) =&gt; [len]a</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToBy&quot;,       flip scGlobalDef &quot;Cryptol.ecFromToBy&quot;)</span>
<span class="lineno">  960 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToBy : {first, last, stride, a}</span>
<span class="lineno">  961 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin last, fin stride, stride &gt;= 1, last &gt;= first, Literal last a) =&gt;</span>
<span class="lineno">  962 </span><span class="spaces">                                  </span><span class="istickedoff">--   [1 + (last - first)/stride]a</span>
<span class="lineno">  963 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToByLessThan&quot;, flip scGlobalDef &quot;Cryptol.ecFromToByLessThan&quot;)</span>
<span class="lineno">  964 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToByLessThan : {first, bound, stride, a}</span>
<span class="lineno">  965 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin first, fin stride, stride &gt;= 1, bound &gt;= first, LiteralLessThan bound a) =&gt;</span>
<span class="lineno">  966 </span><span class="spaces">                                  </span><span class="istickedoff">--   [(bound - first)/^stride]a</span>
<span class="lineno">  967 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToDownBy&quot;, flip scGlobalDef &quot;Cryptol.ecFromToDownBy&quot;)</span>
<span class="lineno">  968 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToDownBy : {first, last, stride, a}</span>
<span class="lineno">  969 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin first, fin stride, stride &gt;= 1, first &gt;= last, Literal first a) =&gt;</span>
<span class="lineno">  970 </span><span class="spaces">                                  </span><span class="istickedoff">--   [1 + (first - last)/stride]a</span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fromToDownByGreaterThan&quot;, flip scGlobalDef &quot;Cryptol.ecFromToDownByGreaterThan&quot;)</span>
<span class="lineno">  972 </span><span class="spaces">                                  </span><span class="istickedoff">-- fromToDownByGreaterThan : {first, bound, stride, a}</span>
<span class="lineno">  973 </span><span class="spaces">                                  </span><span class="istickedoff">--   (fin first, fin stride, stride &gt;= 1, first &gt;= bound, Literal first a) =&gt;</span>
<span class="lineno">  974 </span><span class="spaces">                                  </span><span class="istickedoff">--   [(first - bound)/^stride]a</span>
<span class="lineno">  975 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  976 </span><span class="spaces">    </span><span class="istickedoff">-- Evaluation primitives: deepseq, parmap</span>
<span class="lineno">  977 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;deepseq&quot;,      flip scGlobalDef &quot;Cryptol.ecDeepseq&quot;)     -- {a, b} (Eq b) =&gt; a -&gt; b -&gt; b</span>
<span class="lineno">  978 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;parmap&quot;,       flip scGlobalDef &quot;Cryptol.ecParmap&quot;)      -- {a, b, n} (Eq b, fin n) =&gt; (a -&gt; b) -&gt; [n]a -&gt; [n]b</span>
<span class="lineno">  979 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;foldl&quot;,        flip scGlobalDef &quot;Cryptol.ecFoldl&quot;)       -- {n, a, b} (fin n) =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; a</span>
<span class="lineno">  980 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;foldl'&quot;,       flip scGlobalDef &quot;Cryptol.ecFoldlPrime&quot;)  -- {n, a, b} (fin n, Eq a) =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; a</span>
<span class="lineno">  981 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;scanl&quot;,        flip scGlobalDef &quot;Cryptol.ecScanl&quot;)       -- {n, a, b}  (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; [1+n]a</span>
<span class="lineno">  982 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;error&quot;,        flip scGlobalDef &quot;Cryptol.ecError&quot;)       -- {at,len} (fin len) =&gt; [len][8] -&gt; at -- Run-time error</span>
<span class="lineno">  983 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;random&quot;,       flip scGlobalDef &quot;Cryptol.ecRandom&quot;)      -- {a} =&gt; [32] -&gt; a -- Random values</span>
<span class="lineno">  984 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;trace&quot;,        flip scGlobalDef &quot;Cryptol.ecTrace&quot;)       -- {n,a,b} [n][8] -&gt; a -&gt; b -&gt; b</span>
<span class="lineno">  985 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  986 </span>
<span class="lineno">  987 </span>arrayPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno">  988 </span><span class="decl"><span class="istickedoff">arrayPrims =</span>
<span class="lineno">  989 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno">  990 </span><span class="spaces">  </span><span class="istickedoff">first C.arrayPrim &lt;$&gt;</span>
<span class="lineno">  991 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;arrayConstant&quot;, flip scGlobalDef &quot;Cryptol.ecArrayConstant&quot;) -- {a,b} b -&gt; Array a b</span>
<span class="lineno">  992 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayLookup&quot;,   flip scGlobalDef &quot;Cryptol.ecArrayLookup&quot;) -- {a,b} Array a b -&gt; a -&gt; b</span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayUpdate&quot;,   flip scGlobalDef &quot;Cryptol.ecArrayUpdate&quot;) -- {a,b} Array a b -&gt; a -&gt; b -&gt; Array a b</span>
<span class="lineno">  994 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayCopy&quot;, flip scGlobalDef &quot;Cryptol.ecArrayCopy&quot;) -- {n,a} Array [n] a -&gt; [n] -&gt; Array [n] a -&gt; [n] -&gt; [n] -&gt; Array [n] a</span>
<span class="lineno">  995 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayEq&quot;, flip scGlobalDef &quot;Cryptol.ecArrayEq&quot;)     -- {a, b} (Array a b) -&gt; (Array a b) -&gt; Bool</span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arraySet&quot;, flip scGlobalDef &quot;Cryptol.ecArraySet&quot;) -- {n,a} Array [n] a -&gt; [n] -&gt; a -&gt; [n] -&gt; Array [n] a</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;arrayRangeEqual&quot;, flip scGlobalDef &quot;Cryptol.ecArrayRangeEq&quot;) -- {n,a} Array [n] a -&gt; [n] -&gt; Array [n] a -&gt; [n] -&gt; [n] -&gt; Bit</span>
<span class="lineno">  998 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  999 </span>
<span class="lineno"> 1000 </span>floatPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno"> 1001 </span><span class="decl"><span class="istickedoff">floatPrims =</span>
<span class="lineno"> 1002 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno"> 1003 </span><span class="spaces">  </span><span class="istickedoff">first C.floatPrim &lt;$&gt;</span>
<span class="lineno"> 1004 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;fpNaN&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpNaN&quot;</span>)</span>
<span class="lineno"> 1005 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpPosInf&quot;,       <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpPosInf&quot;</span>)</span>
<span class="lineno"> 1006 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpFromBits&quot;,     <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpFromBits&quot;</span>)</span>
<span class="lineno"> 1007 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpToBits&quot;,       <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpToBits&quot;</span>)</span>
<span class="lineno"> 1008 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;=.=&quot;,            <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpEq&quot;</span>)</span>
<span class="lineno"> 1009 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpAdd&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpAdd&quot;</span>)</span>
<span class="lineno"> 1010 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpSub&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpSub&quot;</span>)</span>
<span class="lineno"> 1011 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpMul&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpMul&quot;</span>)</span>
<span class="lineno"> 1012 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpDiv&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpDiv&quot;</span>)</span>
<span class="lineno"> 1013 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpToRational&quot;,   <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpToRational&quot;</span>)</span>
<span class="lineno"> 1014 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpFromRational&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ecFpFromRational&quot;</span>)</span>
<span class="lineno"> 1015 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsNaN&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsNaN&quot;</span>)</span>
<span class="lineno"> 1016 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsInf&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsInf&quot;</span>)</span>
<span class="lineno"> 1017 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsZero&quot;,       <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsZero&quot;</span>)</span>
<span class="lineno"> 1018 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsNeg&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsNeg&quot;</span>)</span>
<span class="lineno"> 1019 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsNormal&quot;,     <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsNormal&quot;</span>)</span>
<span class="lineno"> 1020 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpIsSubnormal&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpIsSubnormal&quot;</span>)</span>
<span class="lineno"> 1021 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpFMA&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpFMA&quot;</span>)</span>
<span class="lineno"> 1022 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpAbs&quot;,          <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpAbs&quot;</span>)</span>
<span class="lineno"> 1023 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;fpSqrt&quot;,         <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.fpSqrt&quot;</span>)</span>
<span class="lineno"> 1024 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1025 </span>
<span class="lineno"> 1026 </span>suiteBPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno"> 1027 </span><span class="decl"><span class="istickedoff">suiteBPrims =</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno"> 1029 </span><span class="spaces">  </span><span class="istickedoff">first C.suiteBPrim &lt;$&gt;</span>
<span class="lineno"> 1030 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;AESEncRound&quot;,      <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESEncRound&quot;</span>)</span>
<span class="lineno"> 1031 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESEncFinalRound&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESEncFinalRound&quot;</span>)</span>
<span class="lineno"> 1032 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESDecRound&quot;,      <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESDecRound&quot;</span>)</span>
<span class="lineno"> 1033 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESDecFinalRound&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESDecFinalRound&quot;</span>)</span>
<span class="lineno"> 1034 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESInvMixColumns&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESInvMixColumns&quot;</span>)</span>
<span class="lineno"> 1035 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;AESKeyExpand&quot;,     <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.AESKeyExpand&quot;</span>)</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_224&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_224&quot;</span>)</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_256&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_256&quot;</span>)</span>
<span class="lineno"> 1038 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_384&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_384&quot;</span>)</span>
<span class="lineno"> 1039 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;processSHA2_512&quot;,  <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.processSHA2_512&quot;</span>)</span>
<span class="lineno"> 1040 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1041 </span>
<span class="lineno"> 1042 </span>primeECPrims :: Map C.PrimIdent (SharedContext -&gt; IO Term)
<span class="lineno"> 1043 </span><span class="decl"><span class="istickedoff">primeECPrims =</span>
<span class="lineno"> 1044 </span><span class="spaces">  </span><span class="istickedoff">Map.fromList $</span>
<span class="lineno"> 1045 </span><span class="spaces">  </span><span class="istickedoff">first C.primeECPrim &lt;$&gt;</span>
<span class="lineno"> 1046 </span><span class="spaces">  </span><span class="istickedoff">[ (&quot;ec_double&quot;,      <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_double&quot;</span>)</span>
<span class="lineno"> 1047 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ec_add_nonzero&quot;, <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_add_nonzero&quot;</span>)</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ec_mult&quot;,        <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_mult&quot;</span>)</span>
<span class="lineno"> 1049 </span><span class="spaces">  </span><span class="istickedoff">, (&quot;ec_twin_mult&quot;,   <span class="nottickedoff">flip scGlobalDef &quot;Cryptol.ec_twin_mult&quot;</span>)</span>
<span class="lineno"> 1050 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1051 </span>
<span class="lineno"> 1052 </span>-- | Convert a Cryptol expression to a SAWCore term. Calling
<span class="lineno"> 1053 </span>-- 'scTypeOf' on the result of @'importExpr' sc env expr@ must yield a
<span class="lineno"> 1054 </span>-- type that is equivalent (i.e. convertible) with the one returned by
<span class="lineno"> 1055 </span>-- @'importSchema' sc env ('fastTypeOf' ('envC' env) expr)@.
<span class="lineno"> 1056 </span>importExpr :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Expr -&gt; IO Term
<span class="lineno"> 1057 </span><span class="decl"><span class="istickedoff">importExpr sc env expr =</span>
<span class="lineno"> 1058 </span><span class="spaces">  </span><span class="istickedoff">case expr of</span>
<span class="lineno"> 1059 </span><span class="spaces">    </span><span class="istickedoff">C.EList es t -&gt;</span>
<span class="lineno"> 1060 </span><span class="spaces">      </span><span class="istickedoff">do t' &lt;- importType sc env t</span>
<span class="lineno"> 1061 </span><span class="spaces">         </span><span class="istickedoff">es' &lt;- traverse (importExpr' sc env (C.tMono t)) es</span>
<span class="lineno"> 1062 </span><span class="spaces">         </span><span class="istickedoff">scVector sc t' es'</span>
<span class="lineno"> 1063 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1064 </span><span class="spaces">    </span><span class="istickedoff">C.ETuple es -&gt;</span>
<span class="lineno"> 1065 </span><span class="spaces">      </span><span class="istickedoff">do es' &lt;- traverse (importExpr sc env) es</span>
<span class="lineno"> 1066 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1067 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1068 </span><span class="spaces">    </span><span class="istickedoff">C.ERec fm -&gt;</span>
<span class="lineno"> 1069 </span><span class="spaces">      </span><span class="istickedoff">do es' &lt;- traverse (importExpr sc env . snd) (C.canonicalFields fm)</span>
<span class="lineno"> 1070 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1071 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1072 </span><span class="spaces">    </span><span class="istickedoff">C.ESel e sel -&gt;</span>
<span class="lineno"> 1073 </span><span class="spaces">      </span><span class="istickedoff">-- Elimination for tuple/record/list</span>
<span class="lineno"> 1074 </span><span class="spaces">      </span><span class="istickedoff">case sel of</span>
<span class="lineno"> 1075 </span><span class="spaces">        </span><span class="istickedoff">C.TupleSel i _maybeLen -&gt;</span>
<span class="lineno"> 1076 </span><span class="spaces">          </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1077 </span><span class="spaces">             </span><span class="istickedoff">let t = fastTypeOf (envC env) e</span>
<span class="lineno"> 1078 </span><span class="spaces">             </span><span class="istickedoff">case C.tIsTuple t of</span>
<span class="lineno"> 1079 </span><span class="spaces">               </span><span class="istickedoff">Just ts -&gt; scTupleSelector sc e' (i+1) (length ts)</span>
<span class="lineno"> 1080 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1081 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid tuple selector: &quot; &lt;&gt; Text.pack (show i),</span></span>
<span class="lineno"> 1082 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t)</span></span>
<span class="lineno"> 1083 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1084 </span><span class="spaces">        </span><span class="istickedoff">C.RecordSel x _ -&gt;</span>
<span class="lineno"> 1085 </span><span class="spaces">          </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1086 </span><span class="spaces">             </span><span class="istickedoff">let t = fastTypeOf (envC env) e</span>
<span class="lineno"> 1087 </span><span class="spaces">             </span><span class="istickedoff">case C.tNoUser t of</span>
<span class="lineno"> 1088 </span><span class="spaces">               </span><span class="istickedoff">C.TRec fm -&gt;</span>
<span class="lineno"> 1089 </span><span class="spaces">                 </span><span class="istickedoff">do i &lt;- the</span>
<span class="lineno"> 1090 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">(&quot;Expected field &quot; &lt;&gt; Text.pack (show x) &lt;&gt; &quot; in normal RecordSel&quot;)</span></span>
<span class="lineno"> 1091 </span><span class="spaces">                      </span><span class="istickedoff">(elemIndex x (map fst (C.canonicalFields fm)))</span>
<span class="lineno"> 1092 </span><span class="spaces">                    </span><span class="istickedoff">scTupleSelector sc e' (i+1) (length (C.canonicalFields fm))</span>
<span class="lineno"> 1093 </span><span class="spaces">               </span><span class="istickedoff">C.TNominal nt _args -&gt;</span>
<span class="lineno"> 1094 </span><span class="spaces">                 </span><span class="istickedoff">do let fs = case C.ntDef nt of</span>
<span class="lineno"> 1095 </span><span class="spaces">                               </span><span class="istickedoff">C.Struct s -&gt; C.ntFields s</span>
<span class="lineno"> 1096 </span><span class="spaces">                               </span><span class="istickedoff">C.Enum {} -&gt;</span>
<span class="lineno"> 1097 </span><span class="spaces">                                 </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1098 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">&quot;Select from enum&quot;,</span></span>
<span class="lineno"> 1099 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t)</span></span>
<span class="lineno"> 1100 </span><span class="spaces">                                 </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1101 </span><span class="spaces">                               </span><span class="istickedoff">C.Abstract -&gt;</span>
<span class="lineno"> 1102 </span><span class="spaces">                                 </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1103 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">&quot;Select from abstract type&quot;,</span></span>
<span class="lineno"> 1104 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t)</span></span>
<span class="lineno"> 1105 </span><span class="spaces">                                 </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1106 </span><span class="spaces">                    </span><span class="istickedoff">i &lt;- the <span class="nottickedoff">(&quot;Expected field &quot; &lt;&gt; Text.pack (show x) &lt;&gt; &quot; in Newtype Record Sel&quot;)</span></span>
<span class="lineno"> 1107 </span><span class="spaces">                          </span><span class="istickedoff">(elemIndex x (map fst (C.canonicalFields fs)))</span>
<span class="lineno"> 1108 </span><span class="spaces">                    </span><span class="istickedoff">scTupleSelector sc e' (i+1) (length (C.canonicalFields fs))</span>
<span class="lineno"> 1109 </span><span class="spaces">               </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1110 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Invalid record selector: &quot; &lt;&gt; Text.pack (pretty x),</span></span>
<span class="lineno"> 1111 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t)</span></span>
<span class="lineno"> 1112 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1113 </span><span class="spaces">        </span><span class="istickedoff">C.ListSel i _maybeLen -&gt;</span>
<span class="lineno"> 1114 </span><span class="spaces">          </span><span class="istickedoff">do let t = fastTypeOf (envC env) e</span>
<span class="lineno"> 1115 </span><span class="spaces">             </span><span class="istickedoff">(n, a) &lt;-</span>
<span class="lineno"> 1116 </span><span class="spaces">               </span><span class="istickedoff">case C.tIsSeq t of</span>
<span class="lineno"> 1117 </span><span class="spaces">                 </span><span class="istickedoff">Just (n, a) -&gt; return (n, a)</span>
<span class="lineno"> 1118 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1119 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">&quot;ListSel: not a list type&quot;,</span></span>
<span class="lineno"> 1120 </span><span class="spaces">                                </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t)</span></span>
<span class="lineno"> 1121 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1122 </span><span class="spaces">             </span><span class="istickedoff">a' &lt;- importType sc <span class="nottickedoff">env</span> a</span>
<span class="lineno"> 1123 </span><span class="spaces">             </span><span class="istickedoff">n' &lt;- importType sc <span class="nottickedoff">env</span> n</span>
<span class="lineno"> 1124 </span><span class="spaces">             </span><span class="istickedoff">e' &lt;- importExpr <span class="nottickedoff">sc</span> env e</span>
<span class="lineno"> 1125 </span><span class="spaces">             </span><span class="istickedoff">i' &lt;- scNat sc (fromIntegral i)</span>
<span class="lineno"> 1126 </span><span class="spaces">             </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.eListSel&quot; [a', n', e', i']</span>
<span class="lineno"> 1127 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1128 </span><span class="spaces">    </span><span class="istickedoff">C.ESet _ e1 sel e2 -&gt;</span>
<span class="lineno"> 1129 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case sel of</span></span>
<span class="lineno"> 1130 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TupleSel i _maybeLen -&gt;</span></span>
<span class="lineno"> 1131 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do e1' &lt;- importExpr sc env e1</span></span>
<span class="lineno"> 1132 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">e2' &lt;- importExpr sc env e2</span></span>
<span class="lineno"> 1133 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let t1 = fastTypeOf (envC env) e1</span></span>
<span class="lineno"> 1134 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">case C.tIsTuple t1 of</span></span>
<span class="lineno"> 1135 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno"> 1136 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1137 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;ESet/TupleSel: not a tuple type&quot;,</span></span>
<span class="lineno"> 1138 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t1)</span></span>
<span class="lineno"> 1139 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1140 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Just ts -&gt;</span></span>
<span class="lineno"> 1141 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do ts' &lt;- traverse (importType sc env) ts</span></span>
<span class="lineno"> 1142 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let t2' = ts' !! i</span></span>
<span class="lineno"> 1143 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">f &lt;- scGlobalApply sc &quot;Cryptol.const&quot; [t2', t2', e2']</span></span>
<span class="lineno"> 1144 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">g &lt;- tupleUpdate sc f i ts'</span></span>
<span class="lineno"> 1145 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">scApply sc g e1'</span></span>
<span class="lineno"> 1146 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.RecordSel x _ -&gt;</span></span>
<span class="lineno"> 1147 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do e1' &lt;- importExpr sc env e1</span></span>
<span class="lineno"> 1148 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">e2' &lt;- importExpr sc env e2</span></span>
<span class="lineno"> 1149 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let t1 = fastTypeOf (envC env) e1</span></span>
<span class="lineno"> 1150 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">case C.tIsRec t1 of</span></span>
<span class="lineno"> 1151 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno"> 1152 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1153 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;ESet/RecordSel: not a record type&quot;,</span></span>
<span class="lineno"> 1154 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t1)</span></span>
<span class="lineno"> 1155 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1156 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Just tm -&gt;</span></span>
<span class="lineno"> 1157 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do i &lt;- the (&quot;Expected a field &quot; &lt;&gt; Text.pack (show x) &lt;&gt; &quot; RecordSel&quot;)</span></span>
<span class="lineno"> 1158 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">(elemIndex x (map fst (C.canonicalFields tm)))</span></span>
<span class="lineno"> 1159 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">ts' &lt;- traverse (importType sc env . snd) (C.canonicalFields tm)</span></span>
<span class="lineno"> 1160 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">let t2' = ts' !! i</span></span>
<span class="lineno"> 1161 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">f &lt;- scGlobalApply sc &quot;Cryptol.const&quot; [t2', t2', e2']</span></span>
<span class="lineno"> 1162 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">g &lt;- tupleUpdate sc f i ts'</span></span>
<span class="lineno"> 1163 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">scApply sc g e1'</span></span>
<span class="lineno"> 1164 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.ListSel _i _maybeLen -&gt;</span></span>
<span class="lineno"> 1165 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1166 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;ListSel is unsupported in ESet:&quot;,</span></span>
<span class="lineno"> 1167 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty expr)</span></span>
<span class="lineno"> 1168 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1169 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1170 </span><span class="spaces">    </span><span class="istickedoff">C.EIf e1 e2 e3 -&gt;</span>
<span class="lineno"> 1171 </span><span class="spaces">      </span><span class="istickedoff">do let ty = fastTypeOf (envC env) e2</span>
<span class="lineno"> 1172 </span><span class="spaces">         </span><span class="istickedoff">ty' &lt;- importType sc env ty</span>
<span class="lineno"> 1173 </span><span class="spaces">         </span><span class="istickedoff">e1' &lt;- importExpr sc env e1</span>
<span class="lineno"> 1174 </span><span class="spaces">         </span><span class="istickedoff">e2' &lt;- importExpr sc env e2</span>
<span class="lineno"> 1175 </span><span class="spaces">         </span><span class="istickedoff">e3' &lt;- importExpr' sc env (C.tMono ty) e3</span>
<span class="lineno"> 1176 </span><span class="spaces">         </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [ty', e1', e2', e3']</span>
<span class="lineno"> 1177 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1178 </span><span class="spaces">    </span><span class="istickedoff">C.EComp len eltty e mss -&gt;</span>
<span class="lineno"> 1179 </span><span class="spaces">      </span><span class="istickedoff">importComp sc env len eltty e mss</span>
<span class="lineno"> 1180 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1181 </span><span class="spaces">    </span><span class="istickedoff">C.EVar qname -&gt;</span>
<span class="lineno"> 1182 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup qname (envE env) of</span>
<span class="lineno"> 1183 </span><span class="spaces">        </span><span class="istickedoff">Just (e', j) -&gt; incVars sc 0 j e'</span>
<span class="lineno"> 1184 </span><span class="spaces">        </span><span class="istickedoff">Nothing      -&gt; <span class="nottickedoff">panic &quot;importExpr&quot; [&quot;Unknown variable: &quot; &lt;&gt; Text.pack (show qname)]</span></span>
<span class="lineno"> 1185 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1186 </span><span class="spaces">    </span><span class="istickedoff">C.ETAbs tp e -&gt;</span>
<span class="lineno"> 1187 </span><span class="spaces">      </span><span class="istickedoff">do env' &lt;- bindTParam sc tp env</span>
<span class="lineno"> 1188 </span><span class="spaces">         </span><span class="istickedoff">k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno"> 1189 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr sc env' e</span>
<span class="lineno"> 1190 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (tparamToLocalName tp) k e'</span>
<span class="lineno"> 1191 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="istickedoff">C.ETApp e t -&gt;</span>
<span class="lineno"> 1193 </span><span class="spaces">      </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1194 </span><span class="spaces">         </span><span class="istickedoff">t' &lt;- importType sc env t</span>
<span class="lineno"> 1195 </span><span class="spaces">         </span><span class="istickedoff">scApply sc e' t'</span>
<span class="lineno"> 1196 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1197 </span><span class="spaces">    </span><span class="istickedoff">C.EApp e1 e2 -&gt;</span>
<span class="lineno"> 1198 </span><span class="spaces">      </span><span class="istickedoff">do e1' &lt;- importExpr sc env e1</span>
<span class="lineno"> 1199 </span><span class="spaces">         </span><span class="istickedoff">let t1 = fastTypeOf (envC env) e1</span>
<span class="lineno"> 1200 </span><span class="spaces">         </span><span class="istickedoff">t1a &lt;-</span>
<span class="lineno"> 1201 </span><span class="spaces">           </span><span class="istickedoff">case C.tIsFun t1 of</span>
<span class="lineno"> 1202 </span><span class="spaces">             </span><span class="istickedoff">Just (a, _) -&gt; return a</span>
<span class="lineno"> 1203 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1204 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1205 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">&quot;EApp: expected function type&quot;,</span></span>
<span class="lineno"> 1206 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">&quot;Type: &quot; &lt;&gt; Text.pack (pretty t1)</span></span>
<span class="lineno"> 1207 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1208 </span><span class="spaces">         </span><span class="istickedoff">e2' &lt;- importExpr' sc env (C.tMono t1a) e2</span>
<span class="lineno"> 1209 </span><span class="spaces">         </span><span class="istickedoff">scApply sc e1' e2'</span>
<span class="lineno"> 1210 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1211 </span><span class="spaces">    </span><span class="istickedoff">C.EAbs x t e -&gt;</span>
<span class="lineno"> 1212 </span><span class="spaces">      </span><span class="istickedoff">do t' &lt;- importType sc env t</span>
<span class="lineno"> 1213 </span><span class="spaces">         </span><span class="istickedoff">env' &lt;- bindName sc x (C.tMono t) env</span>
<span class="lineno"> 1214 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr sc env' e</span>
<span class="lineno"> 1215 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (nameToLocalName x) t' e'</span>
<span class="lineno"> 1216 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1217 </span><span class="spaces">    </span><span class="istickedoff">C.EProofAbs prop e</span>
<span class="lineno"> 1218 </span><span class="spaces">      </span><span class="istickedoff">| isErasedProp prop -&gt; importExpr sc env e</span>
<span class="lineno"> 1219 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1220 </span><span class="spaces">        </span><span class="istickedoff">do p' &lt;- importType sc env prop</span>
<span class="lineno"> 1221 </span><span class="spaces">           </span><span class="istickedoff">env' &lt;- bindProp sc prop env</span>
<span class="lineno"> 1222 </span><span class="spaces">           </span><span class="istickedoff">e' &lt;- importExpr sc env' e</span>
<span class="lineno"> 1223 </span><span class="spaces">           </span><span class="istickedoff">scLambda sc &quot;_P&quot; p' e'</span>
<span class="lineno"> 1224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1225 </span><span class="spaces">    </span><span class="istickedoff">C.EProofApp e -&gt;</span>
<span class="lineno"> 1226 </span><span class="spaces">      </span><span class="istickedoff">case fastSchemaOf (envC env) e of</span>
<span class="lineno"> 1227 </span><span class="spaces">        </span><span class="istickedoff">C.Forall [] (p : _ps) _ty</span>
<span class="lineno"> 1228 </span><span class="spaces">          </span><span class="istickedoff">| isErasedProp p -&gt; importExpr sc env e</span>
<span class="lineno"> 1229 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1230 </span><span class="spaces">            </span><span class="istickedoff">do e' &lt;- importExpr sc env e</span>
<span class="lineno"> 1231 </span><span class="spaces">               </span><span class="istickedoff">prf &lt;- proveProp sc env p</span>
<span class="lineno"> 1232 </span><span class="spaces">               </span><span class="istickedoff">scApply sc e' prf</span>
<span class="lineno"> 1233 </span><span class="spaces">        </span><span class="istickedoff">s -&gt;</span>
<span class="lineno"> 1234 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr&quot; [</span></span>
<span class="lineno"> 1235 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;EProofApp: invalid type&quot;,</span></span>
<span class="lineno"> 1236 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expr: &quot; &lt;&gt; Text.pack (pretty expr),</span></span>
<span class="lineno"> 1237 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Schema: &quot; &lt;&gt; Text.pack (pretty s)</span></span>
<span class="lineno"> 1238 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1239 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1240 </span><span class="spaces">    </span><span class="istickedoff">C.EWhere e dgs -&gt;</span>
<span class="lineno"> 1241 </span><span class="spaces">      </span><span class="istickedoff">do env' &lt;- importDeclGroups sc env dgs</span>
<span class="lineno"> 1242 </span><span class="spaces">         </span><span class="istickedoff">importExpr sc env' e</span>
<span class="lineno"> 1243 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1244 </span><span class="spaces">    </span><span class="istickedoff">C.ELocated _ e -&gt;</span>
<span class="lineno"> 1245 </span><span class="spaces">      </span><span class="istickedoff">importExpr sc env e</span>
<span class="lineno"> 1246 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1247 </span><span class="spaces">    </span><span class="istickedoff">C.EPropGuards arms typ -&gt; do</span>
<span class="lineno"> 1248 </span><span class="spaces">      </span><span class="istickedoff">-- Convert prop guards to nested if-then-elses</span>
<span class="lineno"> 1249 </span><span class="spaces">      </span><span class="istickedoff">typ' &lt;- importType sc env typ</span>
<span class="lineno"> 1250 </span><span class="spaces">      </span><span class="istickedoff">errMsg &lt;- scString sc &quot;No constraints satisfied in constraint guard&quot;</span>
<span class="lineno"> 1251 </span><span class="spaces">      </span><span class="istickedoff">err &lt;- scGlobalApply sc &quot;Prelude.error&quot; [typ', errMsg]</span>
<span class="lineno"> 1252 </span><span class="spaces">      </span><span class="istickedoff">-- NOTE: Must use a right fold to maintain order of prop guards in</span>
<span class="lineno"> 1253 </span><span class="spaces">      </span><span class="istickedoff">-- generated if-then-else</span>
<span class="lineno"> 1254 </span><span class="spaces">      </span><span class="istickedoff">Fold.foldrM (propGuardToIte typ') err arms</span>
<span class="lineno"> 1255 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1256 </span><span class="spaces">    </span><span class="istickedoff">C.ECase s alts dflt -&gt; do</span>
<span class="lineno"> 1257 </span><span class="spaces">      </span><span class="istickedoff">let ty = fastTypeOf (envC env) expr</span>
<span class="lineno"> 1258 </span><span class="spaces">          </span><span class="istickedoff">-- need the type of whole expression as a type-arg in SAWCore</span>
<span class="lineno"> 1259 </span><span class="spaces">      </span><span class="istickedoff">importCase sc env ty s alts dflt</span>
<span class="lineno"> 1260 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1261 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1262 </span><span class="spaces">    </span><span class="istickedoff">-- XXX find this a better name</span>
<span class="lineno"> 1263 </span><span class="spaces">    </span><span class="istickedoff">the :: Text -&gt; Maybe a -&gt; IO a</span>
<span class="lineno"> 1264 </span><span class="spaces">    </span><span class="istickedoff">the what = maybe <span class="nottickedoff">(panic &quot;importExpr&quot; [&quot;Internal type error&quot;, what])</span> return</span>
<span class="lineno"> 1265 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1266 </span><span class="spaces">    </span><span class="istickedoff">-- | Translate an erased 'Prop' to a term and return the conjunction of the</span>
<span class="lineno"> 1267 </span><span class="spaces">    </span><span class="istickedoff">-- translated term and 'mt' if 'mt' is 'Just'. Otherwise, return the</span>
<span class="lineno"> 1268 </span><span class="spaces">    </span><span class="istickedoff">-- translated 'Prop'.  This function is intended to be used in a fold,</span>
<span class="lineno"> 1269 </span><span class="spaces">    </span><span class="istickedoff">-- taking a 'Maybe' in the first argument to avoid creating an unnecessary</span>
<span class="lineno"> 1270 </span><span class="spaces">    </span><span class="istickedoff">-- conjunction over singleton lists.</span>
<span class="lineno"> 1271 </span><span class="spaces">    </span><span class="istickedoff">conjoinErasedProps :: Maybe Term -&gt; C.Prop -&gt; IO (Maybe Term)</span>
<span class="lineno"> 1272 </span><span class="spaces">    </span><span class="istickedoff">conjoinErasedProps mt p = do</span>
<span class="lineno"> 1273 </span><span class="spaces">      </span><span class="istickedoff">p' &lt;- importNumericConstraintAsBool sc env p</span>
<span class="lineno"> 1274 </span><span class="spaces">      </span><span class="istickedoff">case mt of</span>
<span class="lineno"> 1275 </span><span class="spaces">        </span><span class="istickedoff">Just t -&gt; Just &lt;$&gt; scAnd sc t p'</span>
<span class="lineno"> 1276 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; pure $ Just p'</span>
<span class="lineno"> 1277 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1278 </span><span class="spaces">    </span><span class="istickedoff">-- | A helper function to be used in a fold converting a prop guard to an</span>
<span class="lineno"> 1279 </span><span class="spaces">    </span><span class="istickedoff">-- if-then-else. In order, the arguments of the function are:</span>
<span class="lineno"> 1280 </span><span class="spaces">    </span><span class="istickedoff">-- 1. The type of the prop guard</span>
<span class="lineno"> 1281 </span><span class="spaces">    </span><span class="istickedoff">-- 2. An arm of the prop guard</span>
<span class="lineno"> 1282 </span><span class="spaces">    </span><span class="istickedoff">-- 3. A term representing the else branch of the if-then-else</span>
<span class="lineno"> 1283 </span><span class="spaces">    </span><span class="istickedoff">propGuardToIte :: Term -&gt; ([C.Prop], C.Expr) -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 1284 </span><span class="spaces">    </span><span class="istickedoff">propGuardToIte typ (props, body) falseBranch = do</span>
<span class="lineno"> 1285 </span><span class="spaces">      </span><span class="istickedoff">mCondition &lt;- Fold.foldlM conjoinErasedProps Nothing props</span>
<span class="lineno"> 1286 </span><span class="spaces">      </span><span class="istickedoff">condition &lt;- maybe (scBool sc True) pure mCondition</span>
<span class="lineno"> 1287 </span><span class="spaces">      </span><span class="istickedoff">trueBranch &lt;- importExpr sc env body</span>
<span class="lineno"> 1288 </span><span class="spaces">      </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [typ, condition, trueBranch, falseBranch]</span></span>
<span class="lineno"> 1289 </span>
<span class="lineno"> 1290 </span>
<span class="lineno"> 1291 </span>-- | Convert a Cryptol expression with the given type schema to a
<span class="lineno"> 1292 </span>-- SAWCore term. Calling 'scTypeOf' on the result of @'importExpr''
<span class="lineno"> 1293 </span>-- sc env schema expr@ must yield a type that is equivalent (i.e.
<span class="lineno"> 1294 </span>-- convertible) with the one returned by @'importSchema' sc env
<span class="lineno"> 1295 </span>-- schema@.
<span class="lineno"> 1296 </span>--
<span class="lineno"> 1297 </span>-- Essentially, this function should be used when the expression's type is known
<span class="lineno"> 1298 </span>-- (such as with a type annotation), and 'importExpr' should be used when the
<span class="lineno"> 1299 </span>-- type must be inferred.
<span class="lineno"> 1300 </span>importExpr' :: HasCallStack =&gt; SharedContext -&gt; Env -&gt; C.Schema -&gt; C.Expr -&gt; IO Term
<span class="lineno"> 1301 </span><span class="decl"><span class="istickedoff">importExpr' sc env schema expr =</span>
<span class="lineno"> 1302 </span><span class="spaces">  </span><span class="istickedoff">case expr of</span>
<span class="lineno"> 1303 </span><span class="spaces">    </span><span class="istickedoff">C.ETuple es -&gt;</span>
<span class="lineno"> 1304 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- the <span class="nottickedoff">&quot;Expected a mono type in ETuple&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1305 </span><span class="spaces">         </span><span class="istickedoff">ts &lt;- the <span class="nottickedoff">&quot;Expected a tuple type in ETuple&quot;</span> (C.tIsTuple ty)</span>
<span class="lineno"> 1306 </span><span class="spaces">         </span><span class="istickedoff">es' &lt;- sequence (zipWith go ts es)</span>
<span class="lineno"> 1307 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1308 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1309 </span><span class="spaces">    </span><span class="istickedoff">C.ERec fm -&gt;</span>
<span class="lineno"> 1310 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- the <span class="nottickedoff">&quot;Expected a mono type in ERec&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1311 </span><span class="spaces">         </span><span class="istickedoff">tm &lt;- the <span class="nottickedoff">&quot;Expected a record type in ERec&quot;</span> (C.tIsRec ty)</span>
<span class="lineno"> 1312 </span><span class="spaces">         </span><span class="istickedoff">es' &lt;- sequence (zipWith go (map snd (C.canonicalFields tm)) (map snd (C.canonicalFields fm)))</span>
<span class="lineno"> 1313 </span><span class="spaces">         </span><span class="istickedoff">scTuple sc es'</span>
<span class="lineno"> 1314 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1315 </span><span class="spaces">    </span><span class="istickedoff">C.EIf e1 e2 e3 -&gt;</span>
<span class="lineno"> 1316 </span><span class="spaces">      </span><span class="istickedoff">do ty  &lt;- the <span class="nottickedoff">&quot;Expected a mono type in EIf&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1317 </span><span class="spaces">         </span><span class="istickedoff">ty' &lt;- importType sc env ty</span>
<span class="lineno"> 1318 </span><span class="spaces">         </span><span class="istickedoff">e1' &lt;- importExpr sc env e1</span>
<span class="lineno"> 1319 </span><span class="spaces">         </span><span class="istickedoff">e2' &lt;- importExpr' sc env schema e2</span>
<span class="lineno"> 1320 </span><span class="spaces">         </span><span class="istickedoff">e3' &lt;- importExpr' sc env schema e3</span>
<span class="lineno"> 1321 </span><span class="spaces">         </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [ty', e1', e2', e3']</span>
<span class="lineno"> 1322 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1323 </span><span class="spaces">    </span><span class="istickedoff">C.ETAbs tp e -&gt;</span>
<span class="lineno"> 1324 </span><span class="spaces">      </span><span class="istickedoff">do schema' &lt;-</span>
<span class="lineno"> 1325 </span><span class="spaces">           </span><span class="istickedoff">case schema of</span>
<span class="lineno"> 1326 </span><span class="spaces">             </span><span class="istickedoff">C.Forall (tp1 : tparams) props ty -&gt;</span>
<span class="lineno"> 1327 </span><span class="spaces">               </span><span class="istickedoff">let s = C.singleTParamSubst tp1 (C.TVar (C.TVBound tp))</span>
<span class="lineno"> 1328 </span><span class="spaces">               </span><span class="istickedoff">in return (C.Forall tparams (map (plainSubst s) props) (plainSubst s ty))</span>
<span class="lineno"> 1329 </span><span class="spaces">             </span><span class="istickedoff">C.Forall [] _ _ -&gt;</span>
<span class="lineno"> 1330 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr'&quot; [</span></span>
<span class="lineno"> 1331 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">&quot;Unexpected empty params in type abstraction (ETAbs)&quot;,</span></span>
<span class="lineno"> 1332 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (show expr)</span></span>
<span class="lineno"> 1333 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1334 </span><span class="spaces">         </span><span class="istickedoff">env' &lt;- bindTParam sc tp env</span>
<span class="lineno"> 1335 </span><span class="spaces">         </span><span class="istickedoff">k &lt;- importKind sc (C.tpKind tp)</span>
<span class="lineno"> 1336 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr' sc env' schema' e</span>
<span class="lineno"> 1337 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (tparamToLocalName tp) k e'</span>
<span class="lineno"> 1338 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1339 </span><span class="spaces">    </span><span class="istickedoff">C.EAbs x _ e -&gt;</span>
<span class="lineno"> 1340 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- the <span class="nottickedoff">&quot;expected a mono schema in EAbs&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1341 </span><span class="spaces">         </span><span class="istickedoff">(a, b) &lt;- the <span class="nottickedoff">&quot;expected a function type in EAbs&quot;</span> (C.tIsFun ty)</span>
<span class="lineno"> 1342 </span><span class="spaces">         </span><span class="istickedoff">a' &lt;- importType sc env a</span>
<span class="lineno"> 1343 </span><span class="spaces">         </span><span class="istickedoff">env' &lt;- bindName sc x (C.tMono a) env</span>
<span class="lineno"> 1344 </span><span class="spaces">         </span><span class="istickedoff">e' &lt;- importExpr' sc env' (C.tMono b) e</span>
<span class="lineno"> 1345 </span><span class="spaces">         </span><span class="istickedoff">scLambda sc (nameToLocalName x) a' e'</span>
<span class="lineno"> 1346 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1347 </span><span class="spaces">    </span><span class="istickedoff">C.EProofAbs _ e -&gt;</span>
<span class="lineno"> 1348 </span><span class="spaces">      </span><span class="istickedoff">do (prop, schema') &lt;-</span>
<span class="lineno"> 1349 </span><span class="spaces">           </span><span class="istickedoff">case schema of</span>
<span class="lineno"> 1350 </span><span class="spaces">             </span><span class="istickedoff">C.Forall [] (p : ps) ty -&gt; return (p, C.Forall [] ps ty)</span>
<span class="lineno"> 1351 </span><span class="spaces">             </span><span class="istickedoff">C.Forall as ps _ -&gt;</span>
<span class="lineno"> 1352 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">let nas = Text.pack $ show $ length as</span></span>
<span class="lineno"> 1353 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">nps = Text.pack $ show $ length ps</span></span>
<span class="lineno"> 1354 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">in</span></span>
<span class="lineno"> 1355 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importExpr'&quot; [</span></span>
<span class="lineno"> 1356 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Internal type error: unexpected schema in EProofAbs&quot;,</span></span>
<span class="lineno"> 1357 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;   Found &quot; &lt;&gt; nas &lt;&gt; &quot; variables, expected none&quot;,</span></span>
<span class="lineno"> 1358 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;   Found &quot; &lt;&gt; nps &lt;&gt; &quot; predicates, expected at least one&quot;,</span></span>
<span class="lineno"> 1359 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Schema: &quot; &lt;&gt; Text.pack (pretty schema)</span></span>
<span class="lineno"> 1360 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1361 </span><span class="spaces">         </span><span class="istickedoff">if isErasedProp prop</span>
<span class="lineno"> 1362 </span><span class="spaces">           </span><span class="istickedoff">then importExpr' sc env schema' e</span>
<span class="lineno"> 1363 </span><span class="spaces">           </span><span class="istickedoff">else do p' &lt;- importType sc env prop</span>
<span class="lineno"> 1364 </span><span class="spaces">                   </span><span class="istickedoff">env' &lt;- bindProp sc prop env</span>
<span class="lineno"> 1365 </span><span class="spaces">                   </span><span class="istickedoff">e' &lt;- importExpr' sc env' schema' e</span>
<span class="lineno"> 1366 </span><span class="spaces">                   </span><span class="istickedoff">scLambda sc &quot;_P&quot; p' e'</span>
<span class="lineno"> 1367 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1368 </span><span class="spaces">    </span><span class="istickedoff">C.EWhere e dgs -&gt;</span>
<span class="lineno"> 1369 </span><span class="spaces">      </span><span class="istickedoff">do env' &lt;- importDeclGroups sc env dgs</span>
<span class="lineno"> 1370 </span><span class="spaces">         </span><span class="istickedoff">importExpr' sc env' schema e</span>
<span class="lineno"> 1371 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1372 </span><span class="spaces">    </span><span class="istickedoff">C.ELocated _ e -&gt;</span>
<span class="lineno"> 1373 </span><span class="spaces">      </span><span class="istickedoff">importExpr' sc env schema e</span>
<span class="lineno"> 1374 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1375 </span><span class="spaces">    </span><span class="istickedoff">C.ECase     {} -&gt; fallback</span>
<span class="lineno"> 1376 </span><span class="spaces">    </span><span class="istickedoff">C.EList     {} -&gt; fallback</span>
<span class="lineno"> 1377 </span><span class="spaces">    </span><span class="istickedoff">C.ESel      {} -&gt; fallback</span>
<span class="lineno"> 1378 </span><span class="spaces">    </span><span class="istickedoff">C.ESet      {} -&gt; <span class="nottickedoff">fallback</span></span>
<span class="lineno"> 1379 </span><span class="spaces">    </span><span class="istickedoff">C.EComp     {} -&gt; fallback</span>
<span class="lineno"> 1380 </span><span class="spaces">    </span><span class="istickedoff">C.EVar      {} -&gt; fallback</span>
<span class="lineno"> 1381 </span><span class="spaces">    </span><span class="istickedoff">C.EApp      {} -&gt; fallback</span>
<span class="lineno"> 1382 </span><span class="spaces">    </span><span class="istickedoff">C.ETApp     {} -&gt; fallback</span>
<span class="lineno"> 1383 </span><span class="spaces">    </span><span class="istickedoff">C.EProofApp {} -&gt; fallback</span>
<span class="lineno"> 1384 </span><span class="spaces">    </span><span class="istickedoff">C.EPropGuards {} -&gt; fallback</span>
<span class="lineno"> 1385 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1386 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1387 </span><span class="spaces">    </span><span class="istickedoff">go :: C.Type -&gt; C.Expr -&gt; IO Term</span>
<span class="lineno"> 1388 </span><span class="spaces">    </span><span class="istickedoff">go t = importExpr' sc env (C.tMono t)</span>
<span class="lineno"> 1389 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1390 </span><span class="spaces">    </span><span class="istickedoff">-- XXX find this a better name</span>
<span class="lineno"> 1391 </span><span class="spaces">    </span><span class="istickedoff">the :: Text -&gt; Maybe a -&gt; IO a</span>
<span class="lineno"> 1392 </span><span class="spaces">    </span><span class="istickedoff">the what = maybe <span class="nottickedoff">(panic &quot;importExpr&quot; [&quot;Internal type error&quot;, what])</span> return</span>
<span class="lineno"> 1393 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1394 </span><span class="spaces">    </span><span class="istickedoff">fallback :: IO Term</span>
<span class="lineno"> 1395 </span><span class="spaces">    </span><span class="istickedoff">fallback =</span>
<span class="lineno"> 1396 </span><span class="spaces">      </span><span class="istickedoff">do let t1 = fastTypeOf (envC env) expr</span>
<span class="lineno"> 1397 </span><span class="spaces">         </span><span class="istickedoff">t2 &lt;- the <span class="nottickedoff">&quot;fallback: schema is not mono&quot;</span> (C.isMono schema)</span>
<span class="lineno"> 1398 </span><span class="spaces">         </span><span class="istickedoff">expr' &lt;- importExpr sc env expr</span>
<span class="lineno"> 1399 </span><span class="spaces">         </span><span class="istickedoff">coerceTerm sc env t1 t2 expr'</span></span>
<span class="lineno"> 1400 </span>
<span class="lineno"> 1401 </span>tupleUpdate :: SharedContext -&gt; Term -&gt; Int -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1402 </span><span class="decl"><span class="nottickedoff">tupleUpdate _ f 0 [_] = return f</span>
<span class="lineno"> 1403 </span><span class="spaces"></span><span class="nottickedoff">tupleUpdate sc f 0 (a : ts) =</span>
<span class="lineno"> 1404 </span><span class="spaces">  </span><span class="nottickedoff">do b &lt;- scTupleType sc ts</span>
<span class="lineno"> 1405 </span><span class="spaces">     </span><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.updFst&quot; [a, b, f]</span>
<span class="lineno"> 1406 </span><span class="spaces"></span><span class="nottickedoff">tupleUpdate sc f n (a : ts) =</span>
<span class="lineno"> 1407 </span><span class="spaces">  </span><span class="nottickedoff">do g &lt;- tupleUpdate sc f (n - 1) ts</span>
<span class="lineno"> 1408 </span><span class="spaces">     </span><span class="nottickedoff">b &lt;- scTupleType sc ts</span>
<span class="lineno"> 1409 </span><span class="spaces">     </span><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.updSnd&quot; [a, b, g]</span>
<span class="lineno"> 1410 </span><span class="spaces"></span><span class="nottickedoff">tupleUpdate _ _ _ [] = panic &quot;tupleUpdate&quot; [&quot;empty tuple&quot;]</span></span>
<span class="lineno"> 1411 </span>
<span class="lineno"> 1412 </span>-- | Apply a substitution to a type *without* simplifying
<span class="lineno"> 1413 </span>-- constraints like @Ring [n]a@ to @Ring a@. (This is in contrast to
<span class="lineno"> 1414 </span>-- 'apSubst', which performs simplifications wherever possible.)
<span class="lineno"> 1415 </span>plainSubst :: C.Subst -&gt; C.Type -&gt; C.Type
<span class="lineno"> 1416 </span><span class="decl"><span class="istickedoff">plainSubst s ty =</span>
<span class="lineno"> 1417 </span><span class="spaces">  </span><span class="istickedoff">case ty of</span>
<span class="lineno"> 1418 </span><span class="spaces">    </span><span class="istickedoff">C.TCon tc ts   -&gt; C.TCon tc (map (plainSubst s) ts)</span>
<span class="lineno"> 1419 </span><span class="spaces">    </span><span class="istickedoff">C.TUser f ts t -&gt; C.TUser f (map <span class="nottickedoff">(plainSubst s)</span> ts) (plainSubst s t)</span>
<span class="lineno"> 1420 </span><span class="spaces">    </span><span class="istickedoff">C.TRec fs      -&gt; C.TRec (fmap (plainSubst s) fs)</span>
<span class="lineno"> 1421 </span><span class="spaces">    </span><span class="istickedoff">C.TVar x       -&gt; C.apSubst s (C.TVar x)</span>
<span class="lineno"> 1422 </span><span class="spaces">    </span><span class="istickedoff">C.TNominal nt ts -&gt; C.TNominal nt (fmap (plainSubst s) ts)</span></span>
<span class="lineno"> 1423 </span>
<span class="lineno"> 1424 </span>
<span class="lineno"> 1425 </span>-- | Generate a URI representing a cryptol name from a sequence of
<span class="lineno"> 1426 </span>--   name parts representing the fully-qualified name.  If a \&quot;unique\&quot;
<span class="lineno"> 1427 </span>--   value is given, this represents a dynamically bound name in
<span class="lineno"> 1428 </span>--   the \&quot;\&lt;interactive\&gt;\&quot; pseudo-module, and the unique value will
<span class="lineno"> 1429 </span>--   be incorporated into the name as a fragment identifier.
<span class="lineno"> 1430 </span>--   At least one name component must be supplied.
<span class="lineno"> 1431 </span>--
<span class="lineno"> 1432 </span>--   Some examples:
<span class="lineno"> 1433 </span>--
<span class="lineno"> 1434 </span>--   * @Cryptol::foldl@ ---&gt; @cryptol:\/Cryptol\/foldl@
<span class="lineno"> 1435 </span>--   * @MyModule::SubModule::name@ ---&gt; @cryptol:\/MyModule\/SubModule\/name@
<span class="lineno"> 1436 </span>--   * @\&lt;interactive\&gt;::f@ ---&gt; @cryptol:f#1234@
<span class="lineno"> 1437 </span>--
<span class="lineno"> 1438 </span>--   In the above example, 1234 is the unique integer value provided with the name.
<span class="lineno"> 1439 </span>
<span class="lineno"> 1440 </span>cryptolURI ::
<span class="lineno"> 1441 </span>  [Text] {- ^ Name components  -} -&gt;
<span class="lineno"> 1442 </span>  Maybe Int {- ^ unique integer for dynamic names -} -&gt;
<span class="lineno"> 1443 </span>  URI
<span class="lineno"> 1444 </span><span class="decl"><span class="istickedoff">cryptolURI [] _ = <span class="nottickedoff">panic &quot;cryptolURI&quot; [&quot;Could not make URI from empty path&quot;]</span></span>
<span class="lineno"> 1445 </span><span class="spaces"></span><span class="istickedoff">cryptolURI (p:ps) Nothing =</span>
<span class="lineno"> 1446 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe <span class="nottickedoff">(panic &quot;cryptolURI&quot; [&quot;Could not make URI from path: &quot; &lt;&gt; Text.pack (show (p:ps))])</span> $</span>
<span class="lineno"> 1447 </span><span class="spaces">  </span><span class="istickedoff">do sch &lt;- mkScheme &quot;cryptol&quot;</span>
<span class="lineno"> 1448 </span><span class="spaces">     </span><span class="istickedoff">path' &lt;- mapM mkPathPiece (p:|ps)</span>
<span class="lineno"> 1449 </span><span class="spaces">     </span><span class="istickedoff">pure URI</span>
<span class="lineno"> 1450 </span><span class="spaces">       </span><span class="istickedoff">{ uriScheme = Just sch</span>
<span class="lineno"> 1451 </span><span class="spaces">       </span><span class="istickedoff">, uriAuthority = Left True -- absolute path</span>
<span class="lineno"> 1452 </span><span class="spaces">       </span><span class="istickedoff">, uriPath = Just (False, path')</span>
<span class="lineno"> 1453 </span><span class="spaces">       </span><span class="istickedoff">, uriQuery = []</span>
<span class="lineno"> 1454 </span><span class="spaces">       </span><span class="istickedoff">, uriFragment = Nothing</span>
<span class="lineno"> 1455 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno"> 1456 </span><span class="spaces"></span><span class="istickedoff">cryptolURI (p:ps) (Just uniq) =</span>
<span class="lineno"> 1457 </span><span class="spaces">  </span><span class="istickedoff">fromMaybe <span class="nottickedoff">(panic &quot;cryptolURI&quot; [&quot;Could not make URI from path: &quot; &lt;&gt; Text.pack (show (p:ps)), &quot;Fragment: &quot; &lt;&gt; Text.pack (show uniq)])</span> $</span>
<span class="lineno"> 1458 </span><span class="spaces">  </span><span class="istickedoff">do sch &lt;- mkScheme &quot;cryptol&quot;</span>
<span class="lineno"> 1459 </span><span class="spaces">     </span><span class="istickedoff">path' &lt;- mapM mkPathPiece (p:|ps)</span>
<span class="lineno"> 1460 </span><span class="spaces">     </span><span class="istickedoff">frag &lt;- mkFragment (Text.pack (show uniq))</span>
<span class="lineno"> 1461 </span><span class="spaces">     </span><span class="istickedoff">pure URI</span>
<span class="lineno"> 1462 </span><span class="spaces">       </span><span class="istickedoff">{ uriScheme = Just sch</span>
<span class="lineno"> 1463 </span><span class="spaces">       </span><span class="istickedoff">, uriAuthority = Left False -- relative path</span>
<span class="lineno"> 1464 </span><span class="spaces">       </span><span class="istickedoff">, uriPath = Just (False, path')</span>
<span class="lineno"> 1465 </span><span class="spaces">       </span><span class="istickedoff">, uriQuery = []</span>
<span class="lineno"> 1466 </span><span class="spaces">       </span><span class="istickedoff">, uriFragment = Just frag</span>
<span class="lineno"> 1467 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1468 </span>
<span class="lineno"> 1469 </span>
<span class="lineno"> 1470 </span>importName :: C.Name -&gt; IO NameInfo
<span class="lineno"> 1471 </span><span class="decl"><span class="istickedoff">importName cnm =</span>
<span class="lineno"> 1472 </span><span class="spaces">  </span><span class="istickedoff">case C.nameInfo cnm of</span>
<span class="lineno"> 1473 </span><span class="spaces">    </span><span class="istickedoff">C.LocalName {} -&gt; <span class="nottickedoff">fail (&quot;Cannot import non-top-level name: &quot; ++ show cnm)</span></span>
<span class="lineno"> 1474 </span><span class="spaces">    </span><span class="istickedoff">C.GlobalName _ns og</span>
<span class="lineno"> 1475 </span><span class="spaces">      </span><span class="istickedoff">| C.ogModule og == C.TopModule C.interactiveName -&gt;</span>
<span class="lineno"> 1476 </span><span class="spaces">          </span><span class="istickedoff">let shortNm = C.identText (C.nameIdent cnm)</span>
<span class="lineno"> 1477 </span><span class="spaces">              </span><span class="istickedoff">aliases = [shortNm]</span>
<span class="lineno"> 1478 </span><span class="spaces">              </span><span class="istickedoff">uri = cryptolURI [shortNm] (Just (C.nameUnique cnm))</span>
<span class="lineno"> 1479 </span><span class="spaces">           </span><span class="istickedoff">in pure (ImportedName uri aliases)</span>
<span class="lineno"> 1480 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1481 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1482 </span><span class="spaces">          </span><span class="istickedoff">let (topMod, nested) = C.modPathSplit (C.ogModule og)</span>
<span class="lineno"> 1483 </span><span class="spaces">              </span><span class="istickedoff">topChunks = C.modNameChunksText topMod</span>
<span class="lineno"> 1484 </span><span class="spaces">              </span><span class="istickedoff">modNms    = topChunks ++ map C.identText nested</span>
<span class="lineno"> 1485 </span><span class="spaces">              </span><span class="istickedoff">-- If the name came from a module parameter, add the module</span>
<span class="lineno"> 1486 </span><span class="spaces">              </span><span class="istickedoff">-- parameter identifier to distinguish between names that have the</span>
<span class="lineno"> 1487 </span><span class="spaces">              </span><span class="istickedoff">-- same identifier but come from different module parameters (see</span>
<span class="lineno"> 1488 </span><span class="spaces">              </span><span class="istickedoff">-- #1892)</span>
<span class="lineno"> 1489 </span><span class="spaces">              </span><span class="istickedoff">ifaceNms  = case C.ogFromParam og of</span>
<span class="lineno"> 1490 </span><span class="spaces">                            </span><span class="istickedoff">Just i  -&gt; [C.identText i]</span>
<span class="lineno"> 1491 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt; []</span>
<span class="lineno"> 1492 </span><span class="spaces">              </span><span class="istickedoff">shortNm   = C.identText (C.nameIdent cnm)</span>
<span class="lineno"> 1493 </span><span class="spaces">              </span><span class="istickedoff">nmParts   = modNms ++ ifaceNms ++ [shortNm]</span>
<span class="lineno"> 1494 </span><span class="spaces">              </span><span class="istickedoff">longNm    = Text.intercalate &quot;::&quot; nmParts</span>
<span class="lineno"> 1495 </span><span class="spaces">              </span><span class="istickedoff">aliases   = [shortNm, longNm]</span>
<span class="lineno"> 1496 </span><span class="spaces">              </span><span class="istickedoff">uri       = cryptolURI nmParts Nothing</span>
<span class="lineno"> 1497 </span><span class="spaces">           </span><span class="istickedoff">in pure (ImportedName uri aliases)</span></span>
<span class="lineno"> 1498 </span>
<span class="lineno"> 1499 </span>-- | Currently this imports declaration groups by inlining all the
<span class="lineno"> 1500 </span>-- definitions. (With subterm sharing, this is not as bad as it might
<span class="lineno"> 1501 </span>-- seem.) We might want to think about generating let or where
<span class="lineno"> 1502 </span>-- expressions instead.
<span class="lineno"> 1503 </span>--
<span class="lineno"> 1504 </span>-- For Cryptol @foreign@ declarations, we import them as regular
<span class="lineno"> 1505 </span>-- Cryptol expressions if a Cryptol implementation exists, and as an
<span class="lineno"> 1506 </span>-- opaque constant otherwise.
<span class="lineno"> 1507 </span>importDeclGroup :: DeclGroupOptions -&gt; SharedContext -&gt; Env -&gt; C.DeclGroup -&gt; IO Env
<span class="lineno"> 1508 </span>
<span class="lineno"> 1509 </span><span class="decl"><span class="istickedoff">importDeclGroup declOpts sc env (C.Recursive decls) =</span>
<span class="lineno"> 1510 </span><span class="spaces">  </span><span class="istickedoff">case decls of</span>
<span class="lineno"> 1511 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1512 </span><span class="spaces">    </span><span class="istickedoff">[decl] -&gt;</span>
<span class="lineno"> 1513 </span><span class="spaces">      </span><span class="istickedoff">case C.dDefinition decl of</span>
<span class="lineno"> 1514 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1515 </span><span class="spaces">        </span><span class="istickedoff">C.DPrim -&gt;</span>
<span class="lineno"> 1516 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot; [</span></span>
<span class="lineno"> 1517 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;Primitive declarations cannot be recursive (single decl): &quot; &lt;&gt; Text.pack (show (C.dName decl)),</span></span>
<span class="lineno"> 1518 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1519 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1520 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1521 </span><span class="spaces">        </span><span class="istickedoff">C.DForeign _ mexpr -&gt;</span>
<span class="lineno"> 1522 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case mexpr of</span></span>
<span class="lineno"> 1523 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; panicForeignNoExpr decl</span></span>
<span class="lineno"> 1524 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Just expr -&gt; addExpr expr</span></span>
<span class="lineno"> 1525 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1526 </span><span class="spaces">        </span><span class="istickedoff">C.DExpr expr -&gt; addExpr expr</span>
<span class="lineno"> 1527 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1528 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 1529 </span><span class="spaces">      </span><span class="istickedoff">addExpr expr = do</span>
<span class="lineno"> 1530 </span><span class="spaces">        </span><span class="istickedoff">env1 &lt;- bindName sc (C.dName decl) (C.dSignature decl) env</span>
<span class="lineno"> 1531 </span><span class="spaces">        </span><span class="istickedoff">t' &lt;- importSchema sc env (C.dSignature decl)</span>
<span class="lineno"> 1532 </span><span class="spaces">        </span><span class="istickedoff">e' &lt;- importExpr' sc env1 (C.dSignature decl) expr</span>
<span class="lineno"> 1533 </span><span class="spaces">        </span><span class="istickedoff">let x = nameToLocalName (C.dName decl)</span>
<span class="lineno"> 1534 </span><span class="spaces">        </span><span class="istickedoff">f' &lt;- scLambda sc x t' e'</span>
<span class="lineno"> 1535 </span><span class="spaces">        </span><span class="istickedoff">rhs &lt;- scGlobalApply sc &quot;Prelude.fix&quot; [t', f']</span>
<span class="lineno"> 1536 </span><span class="spaces">        </span><span class="istickedoff">rhs' &lt;- case declOpts of</span>
<span class="lineno"> 1537 </span><span class="spaces">                  </span><span class="istickedoff">TopLevelDeclGroup _ -&gt;</span>
<span class="lineno"> 1538 </span><span class="spaces">                    </span><span class="istickedoff">do nmi &lt;- importName (C.dName decl)</span>
<span class="lineno"> 1539 </span><span class="spaces">                       </span><span class="istickedoff">scConstant' sc nmi rhs t'</span>
<span class="lineno"> 1540 </span><span class="spaces">                  </span><span class="istickedoff">NestedDeclGroup -&gt; return rhs</span>
<span class="lineno"> 1541 </span><span class="spaces">        </span><span class="istickedoff">let env' = env { envE = Map.insert (C.dName decl) (rhs', 0) (envE env)</span>
<span class="lineno"> 1542 </span><span class="spaces">                       </span><span class="istickedoff">, envC = Map.insert (C.dName decl) (C.dSignature decl) (envC env) }</span>
<span class="lineno"> 1543 </span><span class="spaces">        </span><span class="istickedoff">return env'</span>
<span class="lineno"> 1544 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1545 </span><span class="spaces">    </span><span class="istickedoff">-- - A group of mutually-recursive declarations -</span>
<span class="lineno"> 1546 </span><span class="spaces">    </span><span class="istickedoff">-- We handle this by &quot;tupling up&quot; all the declarations using a record and</span>
<span class="lineno"> 1547 </span><span class="spaces">    </span><span class="istickedoff">-- taking the fixpoint at this record type.  The desired declarations are</span>
<span class="lineno"> 1548 </span><span class="spaces">    </span><span class="istickedoff">-- then achieved by projecting the field names from this record.</span>
<span class="lineno"> 1549 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1550 </span><span class="spaces">      </span><span class="istickedoff">-- build the environment for the declaration bodies</span>
<span class="lineno"> 1551 </span><span class="spaces">      </span><span class="istickedoff">let dm = Map.fromList [ (C.dName d, d) | d &lt;- decls ]</span>
<span class="lineno"> 1552 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1553 </span><span class="spaces">      </span><span class="istickedoff">-- grab a reference to the outermost variable; this will be the record in the body</span>
<span class="lineno"> 1554 </span><span class="spaces">      </span><span class="istickedoff">-- of the lambda we build later</span>
<span class="lineno"> 1555 </span><span class="spaces">      </span><span class="istickedoff">v0 &lt;- scLocalVar sc 0</span>
<span class="lineno"> 1556 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1557 </span><span class="spaces">      </span><span class="istickedoff">-- build a list of projections from a record variable</span>
<span class="lineno"> 1558 </span><span class="spaces">      </span><span class="istickedoff">vm &lt;- traverse (scRecordSelect sc v0 . nameToFieldName . C.dName) dm</span>
<span class="lineno"> 1559 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1560 </span><span class="spaces">      </span><span class="istickedoff">-- the types of the declarations</span>
<span class="lineno"> 1561 </span><span class="spaces">      </span><span class="istickedoff">tm &lt;- traverse (importSchema sc env . C.dSignature) dm</span>
<span class="lineno"> 1562 </span><span class="spaces">      </span><span class="istickedoff">-- the type of the recursive record</span>
<span class="lineno"> 1563 </span><span class="spaces">      </span><span class="istickedoff">rect &lt;- scRecordType sc (Map.assocs $ Map.mapKeys nameToFieldName tm)</span>
<span class="lineno"> 1564 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1565 </span><span class="spaces">      </span><span class="istickedoff">let env1 = liftEnv env</span>
<span class="lineno"> 1566 </span><span class="spaces">      </span><span class="istickedoff">let env2 = env1 { envE = Map.union (fmap (\v -&gt; (v, 0)) vm) (envE env1)</span>
<span class="lineno"> 1567 </span><span class="spaces">                      </span><span class="istickedoff">, envC = Map.union (fmap C.dSignature dm) (envC env1)</span>
<span class="lineno"> 1568 </span><span class="spaces">                      </span><span class="istickedoff">, envS = <span class="nottickedoff">rect : envS env1</span> }</span>
<span class="lineno"> 1569 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1570 </span><span class="spaces">      </span><span class="istickedoff">let extractDeclExpr decl =</span>
<span class="lineno"> 1571 </span><span class="spaces">            </span><span class="istickedoff">case C.dDefinition decl of</span>
<span class="lineno"> 1572 </span><span class="spaces">              </span><span class="istickedoff">C.DExpr expr -&gt; importExpr' sc env2 (C.dSignature decl) expr</span>
<span class="lineno"> 1573 </span><span class="spaces">              </span><span class="istickedoff">C.DForeign _ mexpr -&gt;</span>
<span class="lineno"> 1574 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">case mexpr of</span></span>
<span class="lineno"> 1575 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; panicForeignNoExpr decl</span></span>
<span class="lineno"> 1576 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Just expr -&gt;</span></span>
<span class="lineno"> 1577 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">importExpr' sc env2 (C.dSignature decl) expr</span></span>
<span class="lineno"> 1578 </span><span class="spaces">              </span><span class="istickedoff">C.DPrim -&gt;</span>
<span class="lineno"> 1579 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot; [</span></span>
<span class="lineno"> 1580 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Primitive declarations cannot be recursive (multiple decls): &quot; &lt;&gt;</span></span>
<span class="lineno"> 1581 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show (C.dName decl)),</span></span>
<span class="lineno"> 1582 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1583 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1584 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1585 </span><span class="spaces">      </span><span class="istickedoff">-- the raw imported bodies of the declarations</span>
<span class="lineno"> 1586 </span><span class="spaces">      </span><span class="istickedoff">em &lt;- traverse extractDeclExpr dm</span>
<span class="lineno"> 1587 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1588 </span><span class="spaces">      </span><span class="istickedoff">-- the body of the recursive record</span>
<span class="lineno"> 1589 </span><span class="spaces">      </span><span class="istickedoff">recv &lt;- scRecord sc (Map.mapKeys nameToFieldName em)</span>
<span class="lineno"> 1590 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1591 </span><span class="spaces">      </span><span class="istickedoff">-- build a lambda from the record body...</span>
<span class="lineno"> 1592 </span><span class="spaces">      </span><span class="istickedoff">f &lt;- scLambda sc &quot;fixRecord&quot; rect recv</span>
<span class="lineno"> 1593 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1594 </span><span class="spaces">      </span><span class="istickedoff">-- and take its fixpoint</span>
<span class="lineno"> 1595 </span><span class="spaces">      </span><span class="istickedoff">rhs &lt;- scGlobalApply sc &quot;Prelude.fix&quot; [rect, f]</span>
<span class="lineno"> 1596 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1597 </span><span class="spaces">      </span><span class="istickedoff">-- finally, build projections from the fixed record to shove into the environment</span>
<span class="lineno"> 1598 </span><span class="spaces">      </span><span class="istickedoff">-- if toplevel, then wrap each binding with a Constant constructor</span>
<span class="lineno"> 1599 </span><span class="spaces">      </span><span class="istickedoff">let mkRhs d t =</span>
<span class="lineno"> 1600 </span><span class="spaces">            </span><span class="istickedoff">do let s = nameToFieldName (C.dName d)</span>
<span class="lineno"> 1601 </span><span class="spaces">               </span><span class="istickedoff">r &lt;- scRecordSelect sc rhs s</span>
<span class="lineno"> 1602 </span><span class="spaces">               </span><span class="istickedoff">case declOpts of</span>
<span class="lineno"> 1603 </span><span class="spaces">                 </span><span class="istickedoff">TopLevelDeclGroup _ -&gt;</span>
<span class="lineno"> 1604 </span><span class="spaces">                   </span><span class="istickedoff">do nmi &lt;- importName (C.dName d)</span>
<span class="lineno"> 1605 </span><span class="spaces">                      </span><span class="istickedoff">scConstant' sc nmi r t</span>
<span class="lineno"> 1606 </span><span class="spaces">                 </span><span class="istickedoff">NestedDeclGroup -&gt; <span class="nottickedoff">return r</span></span>
<span class="lineno"> 1607 </span><span class="spaces">      </span><span class="istickedoff">rhss &lt;- sequence (Map.intersectionWith mkRhs dm tm)</span>
<span class="lineno"> 1608 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1609 </span><span class="spaces">      </span><span class="istickedoff">let env' = env { envE = Map.union (fmap (\v -&gt; (v, 0)) rhss) (envE env)</span>
<span class="lineno"> 1610 </span><span class="spaces">                     </span><span class="istickedoff">, envC = Map.union (fmap C.dSignature dm) (envC env)</span>
<span class="lineno"> 1611 </span><span class="spaces">                     </span><span class="istickedoff">}</span>
<span class="lineno"> 1612 </span><span class="spaces">      </span><span class="istickedoff">return env'</span>
<span class="lineno"> 1613 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1614 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1615 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">panicForeignNoExpr decl = panic &quot;importDeclGroup&quot; [</span></span>
<span class="lineno"> 1616 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;Foreign declaration without Cryptol body in recursive group: &quot; &lt;&gt;</span></span>
<span class="lineno"> 1617 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show (C.dName decl)),</span></span>
<span class="lineno"> 1618 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1620 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1621 </span><span class="spaces"></span><span class="istickedoff">importDeclGroup declOpts sc env (C.NonRecursive decl) = do</span>
<span class="lineno"> 1622 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1623 </span><span class="spaces">  </span><span class="istickedoff">rhs &lt;- case C.dDefinition decl of</span>
<span class="lineno"> 1624 </span><span class="spaces">    </span><span class="istickedoff">C.DForeign _ mexpr</span>
<span class="lineno"> 1625 </span><span class="spaces">      </span><span class="istickedoff">| TopLevelDeclGroup _ &lt;- declOpts -&gt;</span>
<span class="lineno"> 1626 </span><span class="spaces">        </span><span class="istickedoff">case mexpr of</span>
<span class="lineno"> 1627 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; importOpaque sc <span class="nottickedoff">env</span> (C.dName decl) (C.dSignature decl)</span>
<span class="lineno"> 1628 </span><span class="spaces">          </span><span class="istickedoff">Just expr -&gt; do</span>
<span class="lineno"> 1629 </span><span class="spaces">            </span><span class="istickedoff">rhs &lt;- importExpr' sc env (C.dSignature decl) expr</span>
<span class="lineno"> 1630 </span><span class="spaces">            </span><span class="istickedoff">importConstant sc env (C.dName decl) (C.dSignature decl) rhs</span>
<span class="lineno"> 1631 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno"> 1632 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot; [</span></span>
<span class="lineno"> 1633 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Foreign declarations only allowed at top level: &quot; &lt;&gt;</span></span>
<span class="lineno"> 1634 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show (C.dName decl))</span></span>
<span class="lineno"> 1635 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1636 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1637 </span><span class="spaces">    </span><span class="istickedoff">C.DPrim</span>
<span class="lineno"> 1638 </span><span class="spaces">      </span><span class="istickedoff">| TopLevelDeclGroup primOpts &lt;- declOpts -&gt;</span>
<span class="lineno"> 1639 </span><span class="spaces">        </span><span class="istickedoff">importPrimitive sc <span class="nottickedoff">primOpts</span> env (C.dName decl) (C.dSignature decl)</span>
<span class="lineno"> 1640 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno"> 1641 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importDeclGroup&quot; [</span></span>
<span class="lineno"> 1642 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Primitive declarations only allowed at top-level: &quot; &lt;&gt;</span></span>
<span class="lineno"> 1643 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show (C.dName decl))</span></span>
<span class="lineno"> 1644 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1645 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1646 </span><span class="spaces">    </span><span class="istickedoff">C.DExpr expr -&gt; do</span>
<span class="lineno"> 1647 </span><span class="spaces">      </span><span class="istickedoff">rhs &lt;- importExpr' sc env (C.dSignature decl) expr</span>
<span class="lineno"> 1648 </span><span class="spaces">      </span><span class="istickedoff">case declOpts of</span>
<span class="lineno"> 1649 </span><span class="spaces">        </span><span class="istickedoff">TopLevelDeclGroup _ -&gt;</span>
<span class="lineno"> 1650 </span><span class="spaces">          </span><span class="istickedoff">importConstant sc env (C.dName decl) (C.dSignature decl) rhs</span>
<span class="lineno"> 1651 </span><span class="spaces">        </span><span class="istickedoff">NestedDeclGroup -&gt; return rhs</span>
<span class="lineno"> 1652 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1653 </span><span class="spaces">  </span><span class="istickedoff">pure env { envE = Map.insert (C.dName decl) (rhs, 0) (envE env)</span>
<span class="lineno"> 1654 </span><span class="spaces">           </span><span class="istickedoff">, envC = Map.insert (C.dName decl) (C.dSignature decl) (envC env)</span>
<span class="lineno"> 1655 </span><span class="spaces">           </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1656 </span>
<span class="lineno"> 1657 </span>
<span class="lineno"> 1658 </span>data ImportPrimitiveOptions =
<span class="lineno"> 1659 </span>  ImportPrimitiveOptions
<span class="lineno"> 1660 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">allowUnknownPrimitives</span></span></span> :: Bool
<span class="lineno"> 1661 </span>    -- ^ Should unknown primitives be translated as fresh external constants?
<span class="lineno"> 1662 </span>  }
<span class="lineno"> 1663 </span>
<span class="lineno"> 1664 </span>defaultPrimitiveOptions :: ImportPrimitiveOptions
<span class="lineno"> 1665 </span><span class="decl"><span class="nottickedoff">defaultPrimitiveOptions =</span>
<span class="lineno"> 1666 </span><span class="spaces">  </span><span class="nottickedoff">ImportPrimitiveOptions</span>
<span class="lineno"> 1667 </span><span class="spaces">  </span><span class="nottickedoff">{ allowUnknownPrimitives = True</span>
<span class="lineno"> 1668 </span><span class="spaces">  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 1669 </span>
<span class="lineno"> 1670 </span>data DeclGroupOptions
<span class="lineno"> 1671 </span>  = TopLevelDeclGroup ImportPrimitiveOptions
<span class="lineno"> 1672 </span>  | NestedDeclGroup
<span class="lineno"> 1673 </span>
<span class="lineno"> 1674 </span>importDeclGroups :: SharedContext -&gt; Env -&gt; [C.DeclGroup] -&gt; IO Env
<span class="lineno"> 1675 </span><span class="decl"><span class="istickedoff">importDeclGroups sc = foldM (importDeclGroup NestedDeclGroup sc)</span></span>
<span class="lineno"> 1676 </span>
<span class="lineno"> 1677 </span>importTopLevelDeclGroups :: SharedContext -&gt; ImportPrimitiveOptions -&gt; Env -&gt; [C.DeclGroup] -&gt; IO Env
<span class="lineno"> 1678 </span><span class="decl"><span class="istickedoff">importTopLevelDeclGroups sc primOpts = foldM (importDeclGroup (TopLevelDeclGroup <span class="nottickedoff">primOpts</span>) sc)</span></span>
<span class="lineno"> 1679 </span>
<span class="lineno"> 1680 </span>coerceTerm :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Type -&gt; Term -&gt; IO Term
<span class="lineno"> 1681 </span><span class="decl"><span class="istickedoff">coerceTerm sc env t1 t2 e</span>
<span class="lineno"> 1682 </span><span class="spaces">  </span><span class="istickedoff">| t1 == t2 = do return e</span>
<span class="lineno"> 1683 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1684 </span><span class="spaces">    </span><span class="istickedoff">do t1' &lt;- importType sc env t1</span>
<span class="lineno"> 1685 </span><span class="spaces">       </span><span class="istickedoff">t2' &lt;- importType sc env t2</span>
<span class="lineno"> 1686 </span><span class="spaces">       </span><span class="istickedoff">q &lt;- proveEq sc env t1 t2</span>
<span class="lineno"> 1687 </span><span class="spaces">       </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.coerce&quot; [t1', t2', q, e]</span></span>
<span class="lineno"> 1688 </span>
<span class="lineno"> 1689 </span>proveEq :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Type -&gt; IO Term
<span class="lineno"> 1690 </span><span class="decl"><span class="istickedoff">proveEq sc env t1 t2</span>
<span class="lineno"> 1691 </span><span class="spaces">  </span><span class="istickedoff">| t1 == t2 =</span>
<span class="lineno"> 1692 </span><span class="spaces">    </span><span class="istickedoff">do s &lt;- scSort sc (mkSort 0)</span>
<span class="lineno"> 1693 </span><span class="spaces">       </span><span class="istickedoff">t' &lt;- importType sc env t1</span>
<span class="lineno"> 1694 </span><span class="spaces">       </span><span class="istickedoff">scCtorApp sc &quot;Prelude.Refl&quot; [s, t']</span>
<span class="lineno"> 1695 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1696 </span><span class="spaces">    </span><span class="istickedoff">case (tNoUser t1, tNoUser t2) of</span>
<span class="lineno"> 1697 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsSeq -&gt; Just (n1, a1), C.tIsSeq -&gt; Just (n2, a2)) -&gt;</span>
<span class="lineno"> 1698 </span><span class="spaces">        </span><span class="istickedoff">do n1' &lt;- importType sc env n1</span>
<span class="lineno"> 1699 </span><span class="spaces">           </span><span class="istickedoff">n2' &lt;- importType sc env n2</span>
<span class="lineno"> 1700 </span><span class="spaces">           </span><span class="istickedoff">a1' &lt;- importType sc env a1</span>
<span class="lineno"> 1701 </span><span class="spaces">           </span><span class="istickedoff">a2' &lt;- importType sc env a2</span>
<span class="lineno"> 1702 </span><span class="spaces">           </span><span class="istickedoff">num &lt;- scDataTypeApp sc &quot;Cryptol.Num&quot; []</span>
<span class="lineno"> 1703 </span><span class="spaces">           </span><span class="istickedoff">nEq &lt;- if n1 == n2</span>
<span class="lineno"> 1704 </span><span class="spaces">                  </span><span class="istickedoff">then scCtorApp sc &quot;Prelude.Refl&quot; [num, n1']</span>
<span class="lineno"> 1705 </span><span class="spaces">                  </span><span class="istickedoff">else scGlobalApply sc &quot;Prelude.unsafeAssert&quot; [num, n1', n2']</span>
<span class="lineno"> 1706 </span><span class="spaces">           </span><span class="istickedoff">aEq &lt;- proveEq sc env a1 a2</span>
<span class="lineno"> 1707 </span><span class="spaces">           </span><span class="istickedoff">if a1 == a2</span>
<span class="lineno"> 1708 </span><span class="spaces">             </span><span class="istickedoff">then scGlobalApply sc &quot;Cryptol.seq_cong1&quot; [n1', n2', a1', nEq]</span>
<span class="lineno"> 1709 </span><span class="spaces">             </span><span class="istickedoff">else scGlobalApply sc &quot;Cryptol.seq_cong&quot; [n1', n2', a1', a2', nEq, aEq]</span>
<span class="lineno"> 1710 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsIntMod -&gt; Just n1, C.tIsIntMod -&gt; Just n2) -&gt;</span>
<span class="lineno"> 1711 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do n1' &lt;- importType sc env n1</span></span>
<span class="lineno"> 1712 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">n2' &lt;- importType sc env n2</span></span>
<span class="lineno"> 1713 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">num &lt;- scDataTypeApp sc &quot;Cryptol.Num&quot; []</span></span>
<span class="lineno"> 1714 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">nEq &lt;- if n1 == n2</span></span>
<span class="lineno"> 1715 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">then scCtorApp sc &quot;Prelude.Refl&quot; [num, n1']</span></span>
<span class="lineno"> 1716 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">else scGlobalApply sc &quot;Prelude.unsafeAssert&quot; [num, n1', n2']</span></span>
<span class="lineno"> 1717 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.IntModNum_cong&quot; [n1', n2', nEq]</span></span>
<span class="lineno"> 1718 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsFun -&gt; Just (a1, b1), C.tIsFun -&gt; Just (a2, b2)) -&gt;</span>
<span class="lineno"> 1719 </span><span class="spaces">        </span><span class="istickedoff">do a1' &lt;- importType sc env a1</span>
<span class="lineno"> 1720 </span><span class="spaces">           </span><span class="istickedoff">a2' &lt;- importType sc env a2</span>
<span class="lineno"> 1721 </span><span class="spaces">           </span><span class="istickedoff">b1' &lt;- importType sc env b1</span>
<span class="lineno"> 1722 </span><span class="spaces">           </span><span class="istickedoff">b2' &lt;- importType sc env b2</span>
<span class="lineno"> 1723 </span><span class="spaces">           </span><span class="istickedoff">aEq &lt;- proveEq sc env a1 a2</span>
<span class="lineno"> 1724 </span><span class="spaces">           </span><span class="istickedoff">bEq &lt;- proveEq sc env b1 b2</span>
<span class="lineno"> 1725 </span><span class="spaces">           </span><span class="istickedoff">scGlobalApply sc &quot;Cryptol.fun_cong&quot; [a1', a2', b1', b2', aEq, bEq]</span>
<span class="lineno"> 1726 </span><span class="spaces">      </span><span class="istickedoff">(tIsPair -&gt; Just (a1, b1), tIsPair -&gt; Just (a2, b2)) -&gt;</span>
<span class="lineno"> 1727 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do a1' &lt;- importType sc env a1</span></span>
<span class="lineno"> 1728 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">a2' &lt;- importType sc env a2</span></span>
<span class="lineno"> 1729 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">b1' &lt;- importType sc env b1</span></span>
<span class="lineno"> 1730 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">b2' &lt;- importType sc env b2</span></span>
<span class="lineno"> 1731 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">aEq &lt;- proveEq sc env a1 a2</span></span>
<span class="lineno"> 1732 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">bEq &lt;- proveEq sc env b1 b2</span></span>
<span class="lineno"> 1733 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">if b1 == b2</span></span>
<span class="lineno"> 1734 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">then scGlobalApply sc &quot;Cryptol.pair_cong1&quot; [a1', a2', b1', aEq]</span></span>
<span class="lineno"> 1735 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">else if a1 == a2</span></span>
<span class="lineno"> 1736 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">then scGlobalApply sc &quot;Cryptol.pair_cong2&quot; [a1', b1', b2', bEq]</span></span>
<span class="lineno"> 1737 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">else scGlobalApply sc &quot;Cryptol.pair_cong&quot; [a1', a2', b1', b2', aEq, bEq]</span></span>
<span class="lineno"> 1738 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsRec -&gt; Just tm1, C.tIsRec -&gt; Just tm2)</span>
<span class="lineno"> 1739 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">map fst (C.canonicalFields tm1) == map fst (C.canonicalFields tm2)</span> -&gt;</span>
<span class="lineno"> 1740 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">proveEq sc env (C.tTuple (map snd (C.canonicalFields tm1))) (C.tTuple (map snd (C.canonicalFields tm2)))</span></span>
<span class="lineno"> 1741 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1742 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsNominal -&gt; Just (C.NominalType{C.ntDef=C.Enum _},_),</span>
<span class="lineno"> 1743 </span><span class="spaces">       </span><span class="istickedoff">C.tIsNominal -&gt; Just (C.NominalType{C.ntDef=C.Enum _},_)) -&gt;</span>
<span class="lineno"> 1744 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;proveEq&quot; [</span></span>
<span class="lineno"> 1745 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Enum types unsupported.&quot;,</span></span>
<span class="lineno"> 1746 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Found: &quot; &lt;&gt; Text.pack (pretty t1) &lt;&gt; &quot; and &quot; &lt;&gt; Text.pack (pretty t2)</span></span>
<span class="lineno"> 1747 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1748 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1749 </span><span class="spaces">        </span><span class="istickedoff">-- XXX: add a case for `enum`</span>
<span class="lineno"> 1750 </span><span class="spaces">        </span><span class="istickedoff">-- 1. Match constructors by names, and prove fields as tuples</span>
<span class="lineno"> 1751 </span><span class="spaces">        </span><span class="istickedoff">-- 2. We need some way to combine the proofs of equality of</span>
<span class="lineno"> 1752 </span><span class="spaces">        </span><span class="istickedoff">-- the fields, into a proof for equality of the whole type</span>
<span class="lineno"> 1753 </span><span class="spaces">        </span><span class="istickedoff">-- for sums</span>
<span class="lineno"> 1754 </span><span class="spaces">        </span><span class="istickedoff">--</span>
<span class="lineno"> 1755 </span><span class="spaces">        </span><span class="istickedoff">-- XXX: Response to above: Not sure what purpose of `proveEq`</span>
<span class="lineno"> 1756 </span><span class="spaces">        </span><span class="istickedoff">-- is, but wouldn't Enum types have name (not structural)</span>
<span class="lineno"> 1757 </span><span class="spaces">        </span><span class="istickedoff">-- equality?</span>
<span class="lineno"> 1758 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1759 </span><span class="spaces">      </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno"> 1760 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;proveEq&quot; [</span></span>
<span class="lineno"> 1761 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Internal type error:&quot;,</span></span>
<span class="lineno"> 1762 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;t1: &quot; &lt;&gt; Text.pack (pretty t1),</span></span>
<span class="lineno"> 1763 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;t2: &quot; &lt;&gt; Text.pack (pretty t2)</span></span>
<span class="lineno"> 1764 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno"> 1765 </span>
<span class="lineno"> 1766 </span>
<span class="lineno"> 1767 </span>-- | Resolve user types (type aliases and newtypes) to their simpler SAW-compatible forms.
<span class="lineno"> 1768 </span>tNoUser :: C.Type -&gt; C.Type
<span class="lineno"> 1769 </span><span class="decl"><span class="istickedoff">tNoUser initialTy =</span>
<span class="lineno"> 1770 </span><span class="spaces">  </span><span class="istickedoff">case C.tNoUser initialTy of</span>
<span class="lineno"> 1771 </span><span class="spaces">    </span><span class="istickedoff">C.TNominal nt params</span>
<span class="lineno"> 1772 </span><span class="spaces">      </span><span class="istickedoff">| C.Struct fs &lt;- <span class="nottickedoff">C.ntDef nt</span> -&gt;</span>
<span class="lineno"> 1773 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">if null params then</span></span>
<span class="lineno"> 1774 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">C.TRec (C.ntFields fs)</span></span>
<span class="lineno"> 1775 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">else</span></span>
<span class="lineno"> 1776 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">-- XXX: We should instantiate, see #2019</span></span>
<span class="lineno"> 1777 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;tNoUser&quot; [</span></span>
<span class="lineno"> 1778 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Nominal type with parameters: &quot; &lt;&gt; Text.pack (pretty initialTy)</span></span>
<span class="lineno"> 1779 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1780 </span><span class="spaces">    </span><span class="istickedoff">t -&gt; t</span></span>
<span class="lineno"> 1781 </span>
<span class="lineno"> 1782 </span>
<span class="lineno"> 1783 </span>-- | Deconstruct a Cryptol tuple type as a pair according to the
<span class="lineno"> 1784 </span>-- SAWCore tuple type encoding.
<span class="lineno"> 1785 </span>tIsPair :: C.Type -&gt; Maybe (C.Type, C.Type)
<span class="lineno"> 1786 </span><span class="decl"><span class="nottickedoff">tIsPair t =</span>
<span class="lineno"> 1787 </span><span class="spaces">  </span><span class="nottickedoff">do ts &lt;- C.tIsTuple t</span>
<span class="lineno"> 1788 </span><span class="spaces">     </span><span class="nottickedoff">case ts of</span>
<span class="lineno"> 1789 </span><span class="spaces">       </span><span class="nottickedoff">[] -&gt; Nothing</span>
<span class="lineno"> 1790 </span><span class="spaces">       </span><span class="nottickedoff">[t1, t2] -&gt; Just (t1, t2)</span>
<span class="lineno"> 1791 </span><span class="spaces">       </span><span class="nottickedoff">t1 : ts' -&gt; Just (t1, C.tTuple ts')</span></span>
<span class="lineno"> 1792 </span>
<span class="lineno"> 1793 </span>
<span class="lineno"> 1794 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1795 </span>-- List comprehensions
<span class="lineno"> 1796 </span>
<span class="lineno"> 1797 </span>importComp :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Type -&gt; C.Expr -&gt; [[C.Match]] -&gt; IO Term
<span class="lineno"> 1798 </span><span class="decl"><span class="istickedoff">importComp sc env lenT elemT expr mss =</span>
<span class="lineno"> 1799 </span><span class="spaces">  </span><span class="istickedoff">do let zipAll [] = <span class="nottickedoff">panic &quot;importComp&quot; [&quot;zero-branch list comprehension&quot;]</span></span>
<span class="lineno"> 1800 </span><span class="spaces">         </span><span class="istickedoff">zipAll [branch] =</span>
<span class="lineno"> 1801 </span><span class="spaces">           </span><span class="istickedoff">do (xs, len, ty, args) &lt;- importMatches sc env branch</span>
<span class="lineno"> 1802 </span><span class="spaces">              </span><span class="istickedoff">m &lt;- importType sc env len</span>
<span class="lineno"> 1803 </span><span class="spaces">              </span><span class="istickedoff">a &lt;- importType sc env ty</span>
<span class="lineno"> 1804 </span><span class="spaces">              </span><span class="istickedoff">return (xs, m, a, [args], len)</span>
<span class="lineno"> 1805 </span><span class="spaces">         </span><span class="istickedoff">zipAll (branch : branches) =</span>
<span class="lineno"> 1806 </span><span class="spaces">           </span><span class="istickedoff">do (xs, len, ty, args) &lt;- importMatches sc env branch</span>
<span class="lineno"> 1807 </span><span class="spaces">              </span><span class="istickedoff">m &lt;- importType sc env len</span>
<span class="lineno"> 1808 </span><span class="spaces">              </span><span class="istickedoff">a &lt;- importType sc env ty</span>
<span class="lineno"> 1809 </span><span class="spaces">              </span><span class="istickedoff">(ys, n, b, argss, len') &lt;- zipAll branches</span>
<span class="lineno"> 1810 </span><span class="spaces">              </span><span class="istickedoff">ab &lt;- scTupleType sc [a, b]</span>
<span class="lineno"> 1811 </span><span class="spaces">              </span><span class="istickedoff">if len == len' then</span>
<span class="lineno"> 1812 </span><span class="spaces">                </span><span class="istickedoff">do zs &lt;- scGlobalApply sc &quot;Cryptol.seqZipSame&quot; [a, b, m, xs, ys]</span>
<span class="lineno"> 1813 </span><span class="spaces">                   </span><span class="istickedoff">return (zs, m, ab, args : argss, len)</span>
<span class="lineno"> 1814 </span><span class="spaces">              </span><span class="istickedoff">else</span>
<span class="lineno"> 1815 </span><span class="spaces">                </span><span class="istickedoff">do zs &lt;- scGlobalApply sc &quot;Cryptol.seqZip&quot; [a, b, m, n, xs, ys]</span>
<span class="lineno"> 1816 </span><span class="spaces">                   </span><span class="istickedoff">mn &lt;- scGlobalApply sc &quot;Cryptol.tcMin&quot; [m, n]</span>
<span class="lineno"> 1817 </span><span class="spaces">                   </span><span class="istickedoff">return (zs, mn, ab, args : argss, C.tMin len len')</span>
<span class="lineno"> 1818 </span><span class="spaces">     </span><span class="istickedoff">(xs, n, a, argss, lenT') &lt;- zipAll mss</span>
<span class="lineno"> 1819 </span><span class="spaces">     </span><span class="istickedoff">f &lt;- lambdaTuples sc env elemT expr argss</span>
<span class="lineno"> 1820 </span><span class="spaces">     </span><span class="istickedoff">b &lt;- importType sc env elemT</span>
<span class="lineno"> 1821 </span><span class="spaces">     </span><span class="istickedoff">ys &lt;- scGlobalApply sc &quot;Cryptol.seqMap&quot; [a, b, n, f, xs]</span>
<span class="lineno"> 1822 </span><span class="spaces">     </span><span class="istickedoff">-- The resulting type might not match the annotation, so we coerce</span>
<span class="lineno"> 1823 </span><span class="spaces">     </span><span class="istickedoff">coerceTerm sc env (C.tSeq lenT' elemT) (C.tSeq lenT elemT) ys</span></span>
<span class="lineno"> 1824 </span>
<span class="lineno"> 1825 </span>lambdaTuples :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Expr -&gt; [[(C.Name, C.Type)]] -&gt; IO Term
<span class="lineno"> 1826 </span><span class="decl"><span class="istickedoff">lambdaTuples sc env _ty expr [] = importExpr sc env expr</span>
<span class="lineno"> 1827 </span><span class="spaces"></span><span class="istickedoff">lambdaTuples sc env ty expr (args : argss) =</span>
<span class="lineno"> 1828 </span><span class="spaces">  </span><span class="istickedoff">do f &lt;- lambdaTuple sc env ty expr argss args</span>
<span class="lineno"> 1829 </span><span class="spaces">     </span><span class="istickedoff">if null args || null argss</span>
<span class="lineno"> 1830 </span><span class="spaces">       </span><span class="istickedoff">then return f</span>
<span class="lineno"> 1831 </span><span class="spaces">       </span><span class="istickedoff">else do a &lt;- importType sc env (tNestedTuple (map snd args))</span>
<span class="lineno"> 1832 </span><span class="spaces">               </span><span class="istickedoff">b &lt;- importType sc env (tNestedTuple (map (tNestedTuple . map snd) argss))</span>
<span class="lineno"> 1833 </span><span class="spaces">               </span><span class="istickedoff">c &lt;- importType sc env ty</span>
<span class="lineno"> 1834 </span><span class="spaces">               </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.uncurry&quot; [a, b, c, f]</span></span>
<span class="lineno"> 1835 </span>
<span class="lineno"> 1836 </span>lambdaTuple :: SharedContext -&gt; Env -&gt; C.Type -&gt; C.Expr -&gt; [[(C.Name, C.Type)]] -&gt; [(C.Name, C.Type)] -&gt; IO Term
<span class="lineno"> 1837 </span><span class="decl"><span class="istickedoff">lambdaTuple sc env ty expr argss [] = lambdaTuples sc env ty expr argss</span>
<span class="lineno"> 1838 </span><span class="spaces"></span><span class="istickedoff">lambdaTuple sc env ty expr argss ((x, t) : args) =</span>
<span class="lineno"> 1839 </span><span class="spaces">  </span><span class="istickedoff">do a &lt;- importType sc env t</span>
<span class="lineno"> 1840 </span><span class="spaces">     </span><span class="istickedoff">env' &lt;- bindName sc x (C.Forall [] [] t) env</span>
<span class="lineno"> 1841 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- lambdaTuple sc env' ty expr argss args</span>
<span class="lineno"> 1842 </span><span class="spaces">     </span><span class="istickedoff">f &lt;- scLambda sc (nameToLocalName x) a e</span>
<span class="lineno"> 1843 </span><span class="spaces">     </span><span class="istickedoff">if null args</span>
<span class="lineno"> 1844 </span><span class="spaces">        </span><span class="istickedoff">then return f</span>
<span class="lineno"> 1845 </span><span class="spaces">        </span><span class="istickedoff">else do b &lt;- importType sc env (tNestedTuple (map snd args))</span>
<span class="lineno"> 1846 </span><span class="spaces">                </span><span class="istickedoff">let <span class="nottickedoff">tuple = tNestedTuple (map (tNestedTuple . map snd) argss)</span></span>
<span class="lineno"> 1847 </span><span class="spaces">                </span><span class="istickedoff">c &lt;- importType sc env (if <span class="tickonlytrue">null argss</span> then ty else <span class="nottickedoff">C.tFun tuple ty</span>)</span>
<span class="lineno"> 1848 </span><span class="spaces">                </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.uncurry&quot; [a, b, c, f]</span></span>
<span class="lineno"> 1849 </span>
<span class="lineno"> 1850 </span>tNestedTuple :: [C.Type] -&gt; C.Type
<span class="lineno"> 1851 </span><span class="decl"><span class="istickedoff">tNestedTuple [] = <span class="nottickedoff">C.tTuple []</span></span>
<span class="lineno"> 1852 </span><span class="spaces"></span><span class="istickedoff">tNestedTuple [t] = t</span>
<span class="lineno"> 1853 </span><span class="spaces"></span><span class="istickedoff">tNestedTuple (t : ts) = C.tTuple [t, tNestedTuple ts]</span></span>
<span class="lineno"> 1854 </span>
<span class="lineno"> 1855 </span>
<span class="lineno"> 1856 </span>-- | Returns the shared term, length type, element tuple type, bound
<span class="lineno"> 1857 </span>-- variables.
<span class="lineno"> 1858 </span>--
<span class="lineno"> 1859 </span>-- XXX: clean up the cutpaste
<span class="lineno"> 1860 </span>importMatches :: SharedContext -&gt; Env -&gt; [C.Match]
<span class="lineno"> 1861 </span>              -&gt; IO (Term, C.Type, C.Type, [(C.Name, C.Type)])
<span class="lineno"> 1862 </span><span class="decl"><span class="istickedoff">importMatches _sc _env [] =</span>
<span class="lineno"> 1863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [&quot;empty comprehension branch&quot;]</span></span>
<span class="lineno"> 1864 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1865 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env [C.From name _len _eltty expr] = do</span>
<span class="lineno"> 1866 </span><span class="spaces">  </span><span class="istickedoff">(len, ty) &lt;- case C.tIsSeq (fastTypeOf (envC env) expr) of</span>
<span class="lineno"> 1867 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; return x</span>
<span class="lineno"> 1868 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1869 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1870 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Type mismatch (From): &quot; &lt;&gt; Text.pack (show (fastTypeOf (envC env) expr)),</span></span>
<span class="lineno"> 1871 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty expr)</span></span>
<span class="lineno"> 1872 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1873 </span><span class="spaces">  </span><span class="istickedoff">xs &lt;- importExpr sc env expr</span>
<span class="lineno"> 1874 </span><span class="spaces">  </span><span class="istickedoff">return (xs, len, ty, [(name, ty)])</span>
<span class="lineno"> 1875 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1876 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env (C.From name _len _eltty expr : matches) = do</span>
<span class="lineno"> 1877 </span><span class="spaces">  </span><span class="istickedoff">(len1, ty1) &lt;- case C.tIsSeq (fastTypeOf (envC env) expr) of</span>
<span class="lineno"> 1878 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; return x</span>
<span class="lineno"> 1879 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1880 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1881 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Type mismatch (From): &quot; &lt;&gt; Text.pack (show (fastTypeOf (envC env) expr)),</span></span>
<span class="lineno"> 1882 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty expr)</span></span>
<span class="lineno"> 1883 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1884 </span><span class="spaces">  </span><span class="istickedoff">m &lt;- importType sc env len1</span>
<span class="lineno"> 1885 </span><span class="spaces">  </span><span class="istickedoff">a &lt;- importType sc env ty1</span>
<span class="lineno"> 1886 </span><span class="spaces">  </span><span class="istickedoff">xs &lt;- importExpr sc env expr</span>
<span class="lineno"> 1887 </span><span class="spaces">  </span><span class="istickedoff">env' &lt;- bindName sc name (C.Forall [] [] ty1) env</span>
<span class="lineno"> 1888 </span><span class="spaces">  </span><span class="istickedoff">(body, len2, ty2, args) &lt;- importMatches sc env' matches</span>
<span class="lineno"> 1889 </span><span class="spaces">  </span><span class="istickedoff">n &lt;- importType sc env len2</span>
<span class="lineno"> 1890 </span><span class="spaces">  </span><span class="istickedoff">b &lt;- importType sc env ty2</span>
<span class="lineno"> 1891 </span><span class="spaces">  </span><span class="istickedoff">f &lt;- scLambda sc (nameToLocalName name) a body</span>
<span class="lineno"> 1892 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- scGlobalApply sc &quot;Cryptol.from&quot; [a, b, m, n, xs, f]</span>
<span class="lineno"> 1893 </span><span class="spaces">  </span><span class="istickedoff">return (result, C.tMul len1 len2, C.tTuple [ty1, ty2], (name, ty1) : args)</span>
<span class="lineno"> 1894 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1895 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env [C.Let decl]</span>
<span class="lineno"> 1896 </span><span class="spaces">  </span><span class="istickedoff">| C.DPrim &lt;- C.dDefinition decl =</span>
<span class="lineno"> 1897 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1898 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">&quot;Primitive declarations not allowed in 'let':&quot; &lt;&gt; Text.pack (show (C.dName decl)),</span></span>
<span class="lineno"> 1899 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1900 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1901 </span><span class="spaces">  </span><span class="istickedoff">| C.DExpr expr &lt;- C.dDefinition decl = do</span>
<span class="lineno"> 1902 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- importExpr sc env expr</span>
<span class="lineno"> 1903 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- case C.dSignature decl of</span>
<span class="lineno"> 1904 </span><span class="spaces">              </span><span class="istickedoff">C.Forall [] [] ty1 -&gt; return ty1</span>
<span class="lineno"> 1905 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1906 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;Unimplemented: polymorphic Let&quot;,</span></span>
<span class="lineno"> 1907 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1908 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1909 </span><span class="spaces">     </span><span class="istickedoff">a &lt;- importType sc env ty1</span>
<span class="lineno"> 1910 </span><span class="spaces">     </span><span class="istickedoff">result &lt;- scGlobalApply sc &quot;Prelude.single&quot; [a, e]</span>
<span class="lineno"> 1911 </span><span class="spaces">     </span><span class="istickedoff">return (result, C.tOne, ty1, [(C.dName decl, ty1)])</span>
<span class="lineno"> 1912 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1913 </span><span class="spaces"></span><span class="istickedoff">importMatches sc env (C.Let decl : matches) =</span>
<span class="lineno"> 1914 </span><span class="spaces">  </span><span class="istickedoff">case C.dDefinition decl of</span>
<span class="lineno"> 1915 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1916 </span><span class="spaces">    </span><span class="istickedoff">C.DForeign {} -&gt;</span>
<span class="lineno"> 1917 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1918 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Foreign declarations not allowed in 'let':&quot; &lt;&gt; Text.pack (show (C.dName decl)),</span></span>
<span class="lineno"> 1919 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1920 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1921 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1922 </span><span class="spaces">    </span><span class="istickedoff">C.DPrim -&gt;</span>
<span class="lineno"> 1923 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1924 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Primitive declarations not allowed in 'let':&quot; &lt;&gt; Text.pack (show (C.dName decl)),</span></span>
<span class="lineno"> 1925 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1926 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1927 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1928 </span><span class="spaces">    </span><span class="istickedoff">C.DExpr expr -&gt; do</span>
<span class="lineno"> 1929 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- importExpr sc env expr</span>
<span class="lineno"> 1930 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- case C.dSignature decl of</span>
<span class="lineno"> 1931 </span><span class="spaces">              </span><span class="istickedoff">C.Forall [] [] ty1 -&gt; return ty1</span>
<span class="lineno"> 1932 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;importMatches&quot; [</span></span>
<span class="lineno"> 1933 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;Unimplemented: polymorphic Let&quot;,</span></span>
<span class="lineno"> 1934 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;   &quot; &lt;&gt; Text.pack (pretty decl)</span></span>
<span class="lineno"> 1935 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1936 </span><span class="spaces">     </span><span class="istickedoff">a &lt;- importType sc env ty1</span>
<span class="lineno"> 1937 </span><span class="spaces">     </span><span class="istickedoff">env' &lt;- bindName sc (C.dName decl) (C.dSignature decl) env</span>
<span class="lineno"> 1938 </span><span class="spaces">     </span><span class="istickedoff">(body, len, ty2, args) &lt;- importMatches sc env' matches</span>
<span class="lineno"> 1939 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- importType sc env len</span>
<span class="lineno"> 1940 </span><span class="spaces">     </span><span class="istickedoff">b &lt;- importType sc env ty2</span>
<span class="lineno"> 1941 </span><span class="spaces">     </span><span class="istickedoff">f &lt;- scLambda sc (nameToLocalName (C.dName decl)) a body</span>
<span class="lineno"> 1942 </span><span class="spaces">     </span><span class="istickedoff">result &lt;- scGlobalApply sc &quot;Cryptol.mlet&quot; [a, b, n, e, f]</span>
<span class="lineno"> 1943 </span><span class="spaces">     </span><span class="istickedoff">return (result, len, C.tTuple [ty1, ty2], (C.dName decl, ty1) : args)</span></span>
<span class="lineno"> 1944 </span>
<span class="lineno"> 1945 </span>
<span class="lineno"> 1946 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1947 </span>-- Utilities:
<span class="lineno"> 1948 </span>
<span class="lineno"> 1949 </span>-- | assertSAWCoreTypeChecks sc nm term mType - typeChecks (SAWCore) @term@.
<span class="lineno"> 1950 </span>--     if @mType == Just type'@ then ensure the following
<span class="lineno"> 1951 </span>--         term :: type'
<span class="lineno"> 1952 </span>--
<span class="lineno"> 1953 </span>--   This code is used for sanity checks during code generation, like assert.
<span class="lineno"> 1954 </span>--
<span class="lineno"> 1955 </span>--   FIXME: Currently we have made parts of this function un-reachable to
<span class="lineno"> 1956 </span>--     reduce the run-time impact of this check.  A better, long-term,
<span class="lineno"> 1957 </span>--     project-wide solution would be desirable: how to dial up run-time checks for
<span class="lineno"> 1958 </span>--     [integration] tests, but dial down run-time checks for general use.
<span class="lineno"> 1959 </span>--
<span class="lineno"> 1960 </span>assertSAWCoreTypeChecks :: Show i =&gt; SharedContext -&gt; i -&gt; Term -&gt; Maybe Term -&gt; IO ()
<span class="lineno"> 1961 </span><span class="decl"><span class="istickedoff">assertSAWCoreTypeChecks sc ident term mType =</span>
<span class="lineno"> 1962 </span><span class="spaces">  </span><span class="istickedoff">do result &lt;- SC.scTypeCheck sc <span class="nottickedoff">Nothing</span> term</span>
<span class="lineno"> 1963 </span><span class="spaces">     </span><span class="istickedoff">case result of</span>
<span class="lineno"> 1964 </span><span class="spaces">       </span><span class="istickedoff">Right ty1 -&gt;</span>
<span class="lineno"> 1965 </span><span class="spaces">           </span><span class="istickedoff">case mType of</span>
<span class="lineno"> 1966 </span><span class="spaces">             </span><span class="istickedoff">Nothing  -&gt;</span>
<span class="lineno"> 1967 </span><span class="spaces">               </span><span class="istickedoff">pure <span class="nottickedoff">()</span></span>
<span class="lineno"> 1968 </span><span class="spaces">             </span><span class="istickedoff">Just ty2 -&gt;</span>
<span class="lineno"> 1969 </span><span class="spaces">               </span><span class="istickedoff">when False $</span>
<span class="lineno"> 1970 </span><span class="spaces">                 </span><span class="istickedoff">-- N.B. currently unreachable to reduce run-time impact:</span>
<span class="lineno"> 1971 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do</span></span>
<span class="lineno"> 1972 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">eq &lt;- scConvertible sc True ty1 ty2</span></span>
<span class="lineno"> 1973 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">unless eq $</span></span>
<span class="lineno"> 1974 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">panic &quot;assertSAWCoreTypeChecks&quot; [</span></span>
<span class="lineno"> 1975 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected type &quot; &lt;&gt; Text.pack (showTerm ty1),</span></span>
<span class="lineno"> 1976 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">&quot;does not match the inferred type &quot; &lt;&gt; Text.pack (showTerm ty2)</span></span>
<span class="lineno"> 1977 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1978 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt;</span>
<span class="lineno"> 1979 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">panic &quot;assertSAWCoreTypeChecks&quot; ([</span></span>
<span class="lineno"> 1980 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">&quot;Internal type error when checking &quot; &lt;&gt; Text.pack (show ident) &lt;&gt; &quot;:&quot;</span></span>
<span class="lineno"> 1981 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">] ++</span></span>
<span class="lineno"> 1982 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">map Text.pack (SC.prettyTCError err)</span></span>
<span class="lineno"> 1983 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">)</span></span></span>
<span class="lineno"> 1984 </span>
<span class="lineno"> 1985 </span>
<span class="lineno"> 1986 </span>-- | When possible, convert back from a SAWCore type to a Cryptol Type, or Kind.
<span class="lineno"> 1987 </span>scCryptolType :: SharedContext -&gt; Term -&gt; IO (Maybe (Either C.Kind C.Type))
<span class="lineno"> 1988 </span><span class="decl"><span class="istickedoff">scCryptolType sc t =</span>
<span class="lineno"> 1989 </span><span class="spaces">  </span><span class="istickedoff">do modmap &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1990 </span><span class="spaces">     </span><span class="istickedoff">catch</span>
<span class="lineno"> 1991 </span><span class="spaces">       </span><span class="istickedoff">(case SC.evalSharedTerm <span class="nottickedoff">modmap</span> Map.empty <span class="nottickedoff">Map.empty</span> t of</span>
<span class="lineno"> 1992 </span><span class="spaces">           </span><span class="istickedoff">-- NOTE: we make sure that asCryptolTypeValue gets evaluated, to</span>
<span class="lineno"> 1993 </span><span class="spaces">           </span><span class="istickedoff">-- ensure that any panics in the simulator get caught here</span>
<span class="lineno"> 1994 </span><span class="spaces">           </span><span class="istickedoff">SC.TValue tv</span>
<span class="lineno"> 1995 </span><span class="spaces">             </span><span class="istickedoff">| Just !ret &lt;- asCryptolTypeValue tv -&gt; return $ Just ret</span>
<span class="lineno"> 1996 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; return Nothing)</span>
<span class="lineno"> 1997 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">(\ (_::SomeException) -&gt; return Nothing)</span></span>
<span class="lineno"> 1998 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1999 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2000 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2001 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2002 </span><span class="spaces">  </span><span class="istickedoff">asCryptolTypeValue :: SC.TValue SC.Concrete -&gt; Maybe (Either C.Kind C.Type)</span>
<span class="lineno"> 2003 </span><span class="spaces">  </span><span class="istickedoff">asCryptolTypeValue v =</span>
<span class="lineno"> 2004 </span><span class="spaces">    </span><span class="istickedoff">case v of</span>
<span class="lineno"> 2005 </span><span class="spaces">      </span><span class="istickedoff">SC.VBoolType -&gt; return (Right C.tBit)</span>
<span class="lineno"> 2006 </span><span class="spaces">      </span><span class="istickedoff">SC.VIntType -&gt; <span class="nottickedoff">return (Right C.tInteger)</span></span>
<span class="lineno"> 2007 </span><span class="spaces">      </span><span class="istickedoff">SC.VIntModType n -&gt; <span class="nottickedoff">return (Right (C.tIntMod (C.tNum n)))</span></span>
<span class="lineno"> 2008 </span><span class="spaces">      </span><span class="istickedoff">SC.VArrayType v1 v2 -&gt; do</span>
<span class="lineno"> 2009 </span><span class="spaces">        </span><span class="istickedoff">Right t1 &lt;- asCryptolTypeValue v1</span>
<span class="lineno"> 2010 </span><span class="spaces">        </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 2011 </span><span class="spaces">        </span><span class="istickedoff">return (Right (C.tArray t1 t2))</span>
<span class="lineno"> 2012 </span><span class="spaces">      </span><span class="istickedoff">SC.VVecType n v2 -&gt; do</span>
<span class="lineno"> 2013 </span><span class="spaces">        </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 2014 </span><span class="spaces">        </span><span class="istickedoff">return (Right (C.tSeq (C.tNum n) t2))</span>
<span class="lineno"> 2015 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2016 </span><span class="spaces">      </span><span class="istickedoff">SC.VDataType (primName -&gt; &quot;Prelude.Stream&quot;) [SC.TValue v1] [] -&gt;</span>
<span class="lineno"> 2017 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do Right t1 &lt;- asCryptolTypeValue v1</span></span>
<span class="lineno"> 2018 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">return (Right (C.tSeq C.tInf t1))</span></span>
<span class="lineno"> 2019 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2020 </span><span class="spaces">      </span><span class="istickedoff">SC.VDataType (primName -&gt; &quot;Cryptol.Num&quot;) [] [] -&gt;</span>
<span class="lineno"> 2021 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return (Left C.KNum)</span></span>
<span class="lineno"> 2022 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2023 </span><span class="spaces">      </span><span class="istickedoff">SC.VDataType _ _ _ -&gt; Nothing</span>
<span class="lineno"> 2024 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2025 </span><span class="spaces">      </span><span class="istickedoff">SC.VUnitType -&gt; return (Right (C.tTuple []))</span>
<span class="lineno"> 2026 </span><span class="spaces">      </span><span class="istickedoff">SC.VPairType v1 v2 -&gt; do</span>
<span class="lineno"> 2027 </span><span class="spaces">        </span><span class="istickedoff">Right t1 &lt;- asCryptolTypeValue v1</span>
<span class="lineno"> 2028 </span><span class="spaces">        </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 2029 </span><span class="spaces">        </span><span class="istickedoff">case C.tIsTuple t2 of</span>
<span class="lineno"> 2030 </span><span class="spaces">          </span><span class="istickedoff">Just ts -&gt; return (Right <span class="nottickedoff">(C.tTuple (t1 : ts))</span>)</span>
<span class="lineno"> 2031 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; return (Right (C.tTuple [t1, t2]))</span>
<span class="lineno"> 2032 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2033 </span><span class="spaces">      </span><span class="istickedoff">SC.VPiType _nm v1 (SC.VNondependentPi v2) -&gt;</span>
<span class="lineno"> 2034 </span><span class="spaces">        </span><span class="istickedoff">do Right t1 &lt;- asCryptolTypeValue v1</span>
<span class="lineno"> 2035 </span><span class="spaces">           </span><span class="istickedoff">Right t2 &lt;- asCryptolTypeValue v2</span>
<span class="lineno"> 2036 </span><span class="spaces">           </span><span class="istickedoff">return (Right (C.tFun t1 t2))</span>
<span class="lineno"> 2037 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2038 </span><span class="spaces">      </span><span class="istickedoff">SC.VSort s</span>
<span class="lineno"> 2039 </span><span class="spaces">        </span><span class="istickedoff">| s == mkSort 0 -&gt; return (Left <span class="nottickedoff">C.KType</span>)</span>
<span class="lineno"> 2040 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>     -&gt; Nothing</span>
<span class="lineno"> 2041 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2042 </span><span class="spaces">      </span><span class="istickedoff">-- TODO?</span>
<span class="lineno"> 2043 </span><span class="spaces">      </span><span class="istickedoff">SC.VPiType _nm _v1 (SC.VDependentPi _) -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2044 </span><span class="spaces">      </span><span class="istickedoff">SC.VStringType -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2045 </span><span class="spaces">      </span><span class="istickedoff">SC.VRecordType{} -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2046 </span><span class="spaces">      </span><span class="istickedoff">SC.VRecursorType{} -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 2047 </span><span class="spaces">      </span><span class="istickedoff">SC.VTyTerm{} -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno"> 2048 </span>
<span class="lineno"> 2049 </span>--------------------------------------------------------------------------------
<span class="lineno"> 2050 </span>-- exporting functions:
<span class="lineno"> 2051 </span>
<span class="lineno"> 2052 </span>-- | Convert from SAWCore's Value type to Cryptol's, guided by the
<span class="lineno"> 2053 </span>-- Cryptol type schema.
<span class="lineno"> 2054 </span>exportValueWithSchema :: C.Schema -&gt; SC.CValue -&gt; V.Eval V.Value
<span class="lineno"> 2055 </span><span class="decl"><span class="istickedoff">exportValueWithSchema (C.Forall [] [] ty) v = exportValue (evalValType <span class="nottickedoff">mempty</span> ty) v</span>
<span class="lineno"> 2056 </span><span class="spaces"></span><span class="istickedoff">exportValueWithSchema _ _ = <span class="nottickedoff">pure (V.VPoly mempty (error &quot;exportValueWithSchema&quot;))</span></span></span>
<span class="lineno"> 2057 </span>-- TODO: proper support for polymorphic values
<span class="lineno"> 2058 </span>
<span class="lineno"> 2059 </span>exportValue :: TV.TValue -&gt; SC.CValue -&gt; V.Eval V.Value
<span class="lineno"> 2060 </span><span class="decl"><span class="istickedoff">exportValue ty v = case ty of</span>
<span class="lineno"> 2061 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2062 </span><span class="spaces">  </span><span class="istickedoff">TV.TVBit -&gt;</span>
<span class="lineno"> 2063 </span><span class="spaces">    </span><span class="istickedoff">pure (V.VBit (SC.toBool v))</span>
<span class="lineno"> 2064 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2065 </span><span class="spaces">  </span><span class="istickedoff">TV.TVInteger -&gt;</span>
<span class="lineno"> 2066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (V.VInteger (case v of SC.VInt x -&gt; x; _ -&gt; error &quot;exportValue: expected integer&quot;))</span></span>
<span class="lineno"> 2067 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2068 </span><span class="spaces">  </span><span class="istickedoff">TV.TVIntMod _modulus -&gt;</span>
<span class="lineno"> 2069 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (V.VInteger (case v of SC.VIntMod _ x -&gt; x; _ -&gt; error &quot;exportValue: expected intmod&quot;))</span></span>
<span class="lineno"> 2070 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2071 </span><span class="spaces">  </span><span class="istickedoff">TV.TVArray{} -&gt; <span class="nottickedoff">panic &quot;exportValue&quot; [&quot;Not yet implemented: array type: &quot; &lt;&gt; Text.pack (pretty (TV.tValTy ty))]</span></span>
<span class="lineno"> 2072 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2073 </span><span class="spaces">  </span><span class="istickedoff">TV.TVRational -&gt; <span class="nottickedoff">panic &quot;exportValue&quot; [&quot;Not yet implemented: Rational&quot;]</span></span>
<span class="lineno"> 2074 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2075 </span><span class="spaces">  </span><span class="istickedoff">TV.TVFloat _ _ -&gt; <span class="nottickedoff">panic &quot;exportValue&quot; [&quot;Not yet implemented: Float&quot;]</span></span>
<span class="lineno"> 2076 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2077 </span><span class="spaces">  </span><span class="istickedoff">TV.TVSeq _ e -&gt;</span>
<span class="lineno"> 2078 </span><span class="spaces">    </span><span class="istickedoff">case v of</span>
<span class="lineno"> 2079 </span><span class="spaces">      </span><span class="istickedoff">SC.VWord w -&gt; V.word <span class="nottickedoff">V.Concrete</span> (toInteger (width w)) (unsigned w)</span>
<span class="lineno"> 2080 </span><span class="spaces">      </span><span class="istickedoff">SC.VVector xs</span>
<span class="lineno"> 2081 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">TV.isTBit e</span> -&gt; V.VWord &lt;$&gt;</span>
<span class="lineno"> 2082 </span><span class="spaces">            </span><span class="istickedoff">V.bitmapWordVal <span class="nottickedoff">V.Concrete</span> (toInteger (Vector.length xs))</span>
<span class="lineno"> 2083 </span><span class="spaces">                 </span><span class="istickedoff">(V.finiteSeqMap <span class="nottickedoff">V.Concrete</span> . map (V.ready . SC.toBool . SC.runIdentity . force) $ Fold.toList xs)</span>
<span class="lineno"> 2084 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span>   -&gt; <span class="nottickedoff">V.mkSeq V.Concrete (C.Nat (toInteger (Vector.length xs))) e $ V.finiteSeqMap V.Concrete $</span></span>
<span class="lineno"> 2085 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">map (\x -&gt; exportValue e (SC.runIdentity (force x))) (Vector.toList xs)</span></span>
<span class="lineno"> 2086 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;exportValue (on seq type &quot; ++ show ty ++ &quot;)&quot;</span></span>
<span class="lineno"> 2087 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2088 </span><span class="spaces">  </span><span class="istickedoff">-- infinite streams</span>
<span class="lineno"> 2089 </span><span class="spaces">  </span><span class="istickedoff">TV.TVStream e -&gt;</span>
<span class="lineno"> 2090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">case v of</span></span>
<span class="lineno"> 2091 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">SC.VExtra (SC.CStream trie) -&gt; pure $ V.VStream (V.indexSeqMap $ \i -&gt; exportValue e (IntTrie.apply trie i))</span></span>
<span class="lineno"> 2092 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; error $ &quot;exportValue (on seq type &quot; ++ show ty ++ &quot;)&quot;</span></span>
<span class="lineno"> 2093 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2094 </span><span class="spaces">  </span><span class="istickedoff">-- tuples</span>
<span class="lineno"> 2095 </span><span class="spaces">  </span><span class="istickedoff">TV.TVTuple etys -&gt; <span class="nottickedoff">pure $ V.VTuple $ exportTupleValue etys v</span></span>
<span class="lineno"> 2096 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2097 </span><span class="spaces">  </span><span class="istickedoff">-- records</span>
<span class="lineno"> 2098 </span><span class="spaces">  </span><span class="istickedoff">TV.TVRec fields -&gt;</span>
<span class="lineno"> 2099 </span><span class="spaces">      </span><span class="istickedoff">pure . V.VRecord . C.recordFromFieldsWithDisplay (C.displayOrder fields) $ exportRecordValue (C.canonicalFields fields) v</span>
<span class="lineno"> 2100 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2101 </span><span class="spaces">  </span><span class="istickedoff">-- functions</span>
<span class="lineno"> 2102 </span><span class="spaces">  </span><span class="istickedoff">TV.TVFun _aty _bty -&gt;</span>
<span class="lineno"> 2103 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure $ V.VFun mempty (error &quot;exportValue: TODO functions&quot;)</span></span>
<span class="lineno"> 2104 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2105 </span><span class="spaces">  </span><span class="istickedoff">-- nominal types</span>
<span class="lineno"> 2106 </span><span class="spaces">  </span><span class="istickedoff">TV.TVNominal _ _ fields -&gt;</span>
<span class="lineno"> 2107 </span><span class="spaces">    </span><span class="istickedoff">case fields of</span>
<span class="lineno"> 2108 </span><span class="spaces">      </span><span class="istickedoff">TV.TVStruct fs   -&gt; exportValue (TV.TVRec fs) v</span>
<span class="lineno"> 2109 </span><span class="spaces">      </span><span class="istickedoff">TV.TVEnum {}     -&gt; <span class="nottickedoff">error (&quot;exportValue: TODO enum: &quot; ++ show v)</span></span>
<span class="lineno"> 2110 </span><span class="spaces">      </span><span class="istickedoff">TV.TVAbstract {} -&gt; <span class="nottickedoff">error &quot;exportValue: TODO abstract types&quot;</span></span></span>
<span class="lineno"> 2111 </span>
<span class="lineno"> 2112 </span>
<span class="lineno"> 2113 </span>exportTupleValue :: [TV.TValue] -&gt; SC.CValue -&gt; [V.Eval V.Value]
<span class="lineno"> 2114 </span><span class="decl"><span class="nottickedoff">exportTupleValue tys v =</span>
<span class="lineno"> 2115 </span><span class="spaces">  </span><span class="nottickedoff">case (tys, v) of</span>
<span class="lineno"> 2116 </span><span class="spaces">    </span><span class="nottickedoff">([]    , SC.VUnit    ) -&gt; []</span>
<span class="lineno"> 2117 </span><span class="spaces">    </span><span class="nottickedoff">([t]   , _           ) -&gt; [exportValue t v]</span>
<span class="lineno"> 2118 </span><span class="spaces">    </span><span class="nottickedoff">(t : ts, SC.VPair x y) -&gt; (exportValue t (run x)) : exportTupleValue ts (run y)</span>
<span class="lineno"> 2119 </span><span class="spaces">    </span><span class="nottickedoff">_                      -&gt; error $ &quot;exportValue: expected tuple&quot;</span>
<span class="lineno"> 2120 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2121 </span><span class="spaces">    </span><span class="nottickedoff">run = SC.runIdentity . force</span></span>
<span class="lineno"> 2122 </span>
<span class="lineno"> 2123 </span>exportRecordValue :: [(C.Ident, TV.TValue)] -&gt; SC.CValue -&gt; [(C.Ident, V.Eval V.Value)]
<span class="lineno"> 2124 </span><span class="decl"><span class="istickedoff">exportRecordValue fields v =</span>
<span class="lineno"> 2125 </span><span class="spaces">  </span><span class="istickedoff">case (fields, <span class="nottickedoff">v</span>) of</span>
<span class="lineno"> 2126 </span><span class="spaces">    </span><span class="istickedoff">([]         , SC.VUnit    ) -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 2127 </span><span class="spaces">    </span><span class="istickedoff">([(n, t)]   , _           ) -&gt; [(n, exportValue t v)]</span>
<span class="lineno"> 2128 </span><span class="spaces">    </span><span class="istickedoff">((n, t) : ts, SC.VPair x y) -&gt; <span class="nottickedoff">(n, exportValue t (run x)) : exportRecordValue ts (run y)</span></span>
<span class="lineno"> 2129 </span><span class="spaces">    </span><span class="istickedoff">(_, SC.VRecordValue (alistAllFields</span>
<span class="lineno"> 2130 </span><span class="spaces">                         </span><span class="istickedoff">(map (C.identText . fst) fields) -&gt; Just ths)) -&gt;</span>
<span class="lineno"> 2131 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">zipWith (\(n,t) x -&gt; (n, exportValue t (run x))) fields ths</span></span>
<span class="lineno"> 2132 </span><span class="spaces">    </span><span class="istickedoff">_                              -&gt; <span class="nottickedoff">error $ &quot;exportValue: expected record&quot;</span></span>
<span class="lineno"> 2133 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2134 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">run = SC.runIdentity . force</span></span></span>
<span class="lineno"> 2135 </span>
<span class="lineno"> 2136 </span>--------------------------------------------------------------------------------
<span class="lineno"> 2137 </span>-- Supporting Nominal Types:
<span class="lineno"> 2138 </span>
<span class="lineno"> 2139 </span>-- | Generate functions, required by 'NominalType's, to be inserted into the
<span class="lineno"> 2140 </span>--   term environment.
<span class="lineno"> 2141 </span>--
<span class="lineno"> 2142 </span>--   - For 'C.Struct', make identity functions that take the record which
<span class="lineno"> 2143 </span>--     the newtype wraps.
<span class="lineno"> 2144 </span>--
<span class="lineno"> 2145 </span>--   - For 'C.Abstract', no functions need to be produced.
<span class="lineno"> 2146 </span>--
<span class="lineno"> 2147 </span>--   - 'C.Enum' will will create these definitions:
<span class="lineno"> 2148 </span>--     - multiple constructor functions (added to Cryptol Env)
<span class="lineno"> 2149 </span>--     - a number of 'internal' only SAWCore definitions:
<span class="lineno"> 2150 </span>--       - case function for the type (not used directly by Cryptol code).
<span class="lineno"> 2151 </span>--       - multiple definitions that define the Enum's representation
<span class="lineno"> 2152 </span>--         type in SAWCore
<span class="lineno"> 2153 </span>
<span class="lineno"> 2154 </span>genCodeForNominalTypes ::
<span class="lineno"> 2155 </span>  HasCallStack =&gt;
<span class="lineno"> 2156 </span>  SharedContext -&gt; Map C.Name NominalType -&gt; Env -&gt; IO Env
<span class="lineno"> 2157 </span><span class="decl"><span class="istickedoff">genCodeForNominalTypes sc nominalMap env0 =</span>
<span class="lineno"> 2158 </span><span class="spaces">  </span><span class="istickedoff">foldM updateEnvForNominal env0 nominalMap</span>
<span class="lineno"> 2159 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2160 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2161 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2162 </span><span class="spaces">    </span><span class="istickedoff">updateEnvForNominal :: Env -&gt; NominalType -&gt; IO Env</span>
<span class="lineno"> 2163 </span><span class="spaces">    </span><span class="istickedoff">updateEnvForNominal env nt = do</span>
<span class="lineno"> 2164 </span><span class="spaces">      </span><span class="istickedoff">let kinds = map C.tpKind (C.ntParams nt)</span>
<span class="lineno"> 2165 </span><span class="spaces">      </span><span class="istickedoff">unless (all (`elem` [C.KType, C.KNum]) kinds) $</span>
<span class="lineno"> 2166 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;genCodeForNominalTypes&quot; [</span></span>
<span class="lineno"> 2167 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Type parameters for nominal types must each have kind * or #:&quot;,</span></span>
<span class="lineno"> 2168 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show kinds)</span></span>
<span class="lineno"> 2169 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2170 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2171 </span><span class="spaces">      </span><span class="istickedoff">ns &lt;- newDefsForNominal env nt</span>
<span class="lineno"> 2172 </span><span class="spaces">      </span><span class="istickedoff">let conTs = C.nominalTypeConTypes nt</span>
<span class="lineno"> 2173 </span><span class="spaces">          </span><span class="istickedoff">constrs = map</span>
<span class="lineno"> 2174 </span><span class="spaces">                      </span><span class="istickedoff">(\(x,e) -&gt; (x,(e,0)))  -- the De Bruijn 'magic'</span>
<span class="lineno"> 2175 </span><span class="spaces">                      </span><span class="istickedoff">ns</span>
<span class="lineno"> 2176 </span><span class="spaces">      </span><span class="istickedoff">let env' = env { envE = foldr (uncurry Map.insert) (envE env) constrs</span>
<span class="lineno"> 2177 </span><span class="spaces">                     </span><span class="istickedoff">, envC = foldr (uncurry Map.insert) (envC env) conTs</span>
<span class="lineno"> 2178 </span><span class="spaces">                     </span><span class="istickedoff">}</span>
<span class="lineno"> 2179 </span><span class="spaces">        </span><span class="istickedoff">-- NOTE: the Cryptol schemas for the Struct &amp; Enum constructors get added to</span>
<span class="lineno"> 2180 </span><span class="spaces">        </span><span class="istickedoff">--       the Cryptol environment.</span>
<span class="lineno"> 2181 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2182 </span><span class="spaces">      </span><span class="istickedoff">return env'</span>
<span class="lineno"> 2183 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2184 </span><span class="spaces">    </span><span class="istickedoff">-- | Create functions/constructors for different 'NominalType's.</span>
<span class="lineno"> 2185 </span><span class="spaces">    </span><span class="istickedoff">newDefsForNominal ::</span>
<span class="lineno"> 2186 </span><span class="spaces">      </span><span class="istickedoff">HasCallStack =&gt; Env -&gt; NominalType -&gt; IO [(C.Name,Term)]</span>
<span class="lineno"> 2187 </span><span class="spaces">    </span><span class="istickedoff">newDefsForNominal env nt =</span>
<span class="lineno"> 2188 </span><span class="spaces">      </span><span class="istickedoff">case C.ntDef nt of</span>
<span class="lineno"> 2189 </span><span class="spaces">        </span><span class="istickedoff">C.Abstract  -&gt; return []</span>
<span class="lineno"> 2190 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2191 </span><span class="spaces">        </span><span class="istickedoff">C.Enum x    -&gt; genCodeForEnum sc env nt x</span>
<span class="lineno"> 2192 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2193 </span><span class="spaces">        </span><span class="istickedoff">C.Struct fs -&gt; do</span>
<span class="lineno"> 2194 </span><span class="spaces">            </span><span class="istickedoff">let recTy      = C.TRec (C.ntFields fs)</span>
<span class="lineno"> 2195 </span><span class="spaces">                </span><span class="istickedoff">conNm      = C.ntConName fs</span>
<span class="lineno"> 2196 </span><span class="spaces">                </span><span class="istickedoff">paramName  = C.asLocal <span class="nottickedoff">C.NSValue</span> conNm</span>
<span class="lineno"> 2197 </span><span class="spaces">                             </span><span class="istickedoff">-- NOTE: We use name of constructor as the</span>
<span class="lineno"> 2198 </span><span class="spaces">                             </span><span class="istickedoff">-- name of the constructor argument! Thus we can</span>
<span class="lineno"> 2199 </span><span class="spaces">                             </span><span class="istickedoff">-- avoid need for a new unique name.</span>
<span class="lineno"> 2200 </span><span class="spaces">                             </span><span class="istickedoff">-- FIXME: this doesn't seem foolproof!</span>
<span class="lineno"> 2201 </span><span class="spaces">                </span><span class="istickedoff">fn         = C.EAbs paramName recTy (C.EVar paramName)</span>
<span class="lineno"> 2202 </span><span class="spaces">                </span><span class="istickedoff">fnWithTAbs = foldr <span class="nottickedoff">C.ETAbs</span> fn (C.ntParams nt)</span>
<span class="lineno"> 2203 </span><span class="spaces">            </span><span class="istickedoff">e &lt;- importExpr sc env fnWithTAbs</span>
<span class="lineno"> 2204 </span><span class="spaces">            </span><span class="istickedoff">return [(conNm, e)]</span></span>
<span class="lineno"> 2205 </span>
<span class="lineno"> 2206 </span>
<span class="lineno"> 2207 </span>-- | genCodeForEnum ... - called when we see an &quot;enum&quot; definition in the Cryptol module.
<span class="lineno"> 2208 </span>--    - This action does two things
<span class="lineno"> 2209 </span>--       1. Returns the names &amp; definitions of the constructors of the enum.
<span class="lineno"> 2210 </span>--          This fits with the code for other nominals, needed because
<span class="lineno"> 2211 </span>--          the &quot;rest&quot; of Cryptol code to be translated needs to see the
<span class="lineno"> 2212 </span>--          constructors in the Cryptol environments.
<span class="lineno"> 2213 </span>--       2. It adds many other definitions to the SAWCore environment
<span class="lineno"> 2214 </span>--          (in the sc :: SharedContext).  These definitions are only
<span class="lineno"> 2215 </span>--          used by other generated SAWCore code, so we don't need to
<span class="lineno"> 2216 </span>--          return this information back to the Cryptol environment(s).
<span class="lineno"> 2217 </span>--
<span class="lineno"> 2218 </span>--    - N.B. PLEASE refer to doc/developer/translating-enums.md for a
<span class="lineno"> 2219 </span>--      description of this translation at a more abstract level.  The
<span class="lineno"> 2220 </span>--      example there is what is used below to explain the below code
<span class="lineno"> 2221 </span>--      by SAWCore examples.  The running example we use is
<span class="lineno"> 2222 </span>--
<span class="lineno"> 2223 </span>--      &gt; enum ETT ts = C1
<span class="lineno"> 2224 </span>--      &gt;             | C2 Nat
<span class="lineno"> 2225 </span>--      &gt;             | C3 Bool ts
<span class="lineno"> 2226 </span>--
<span class="lineno"> 2227 </span>--   FIXME: the uses of 'preludeName' should all be removed and new
<span class="lineno"> 2228 </span>--     definitions should be added to the module name being processed.
<span class="lineno"> 2229 </span>--     (At one point this was problematic, TODO: figure out and
<span class="lineno"> 2230 </span>--     resolve.)
<span class="lineno"> 2231 </span>--
<span class="lineno"> 2232 </span>genCodeForEnum ::
<span class="lineno"> 2233 </span>  HasCallStack =&gt;
<span class="lineno"> 2234 </span>  SharedContext -&gt; Env -&gt; NominalType -&gt; [C.EnumCon] -&gt; IO [(C.Name,Term)]
<span class="lineno"> 2235 </span><span class="decl"><span class="istickedoff">genCodeForEnum sc env nt ctors =</span>
<span class="lineno"> 2236 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno"> 2237 </span><span class="spaces">  </span><span class="istickedoff">let ntName'  = ntName nt</span>
<span class="lineno"> 2238 </span><span class="spaces">      </span><span class="istickedoff">numCtors = length ctors</span>
<span class="lineno"> 2239 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2240 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2241 </span><span class="spaces">  </span><span class="istickedoff">-- Common code to handle type parameters of the nominal type:</span>
<span class="lineno"> 2242 </span><span class="spaces">  </span><span class="istickedoff">--  - ExtCns are used to capture each of the type variables.</span>
<span class="lineno"> 2243 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2244 </span><span class="spaces">  </span><span class="istickedoff">-- The type parameters (`ts` in the example above)</span>
<span class="lineno"> 2245 </span><span class="spaces">  </span><span class="istickedoff">let tyParamsInfo  = C.ntParams nt</span>
<span class="lineno"> 2246 </span><span class="spaces">      </span><span class="istickedoff">tyParamsNames = map tparamToLocalName tyParamsInfo</span>
<span class="lineno"> 2247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2248 </span><span class="spaces">  </span><span class="istickedoff">-- | the kinds of the type Params:</span>
<span class="lineno"> 2249 </span><span class="spaces">  </span><span class="istickedoff">tyParamsKinds &lt;- forM tyParamsInfo $ \tpi -&gt;</span>
<span class="lineno"> 2250 </span><span class="spaces">                   </span><span class="istickedoff">importKind sc (C.tpKind tpi)</span>
<span class="lineno"> 2251 </span><span class="spaces">  </span><span class="istickedoff">-- | the type Params captured using ExtCns:</span>
<span class="lineno"> 2252 </span><span class="spaces">  </span><span class="istickedoff">tyParamsECs   &lt;- forM (zip tyParamsKinds tyParamsNames) $ \(k,nm) -&gt;</span>
<span class="lineno"> 2253 </span><span class="spaces">                   </span><span class="istickedoff">scFreshEC sc nm k</span>
<span class="lineno"> 2254 </span><span class="spaces">  </span><span class="istickedoff">-- | create references to the type Params:</span>
<span class="lineno"> 2255 </span><span class="spaces">  </span><span class="istickedoff">tyParamsVars  &lt;- mapM (scExtCns sc) tyParamsECs</span>
<span class="lineno"> 2256 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2257 </span><span class="spaces">  </span><span class="istickedoff">let</span>
<span class="lineno"> 2258 </span><span class="spaces">      </span><span class="istickedoff">-- | @addTypeAbstractions t@ - create the SAWCore type</span>
<span class="lineno"> 2259 </span><span class="spaces">      </span><span class="istickedoff">--   abstractions around @t@ (holding the type Param references)</span>
<span class="lineno"> 2260 </span><span class="spaces">      </span><span class="istickedoff">--</span>
<span class="lineno"> 2261 </span><span class="spaces">      </span><span class="istickedoff">--    N.B.: by using ExtCns we can write SAWCore in (`t`) that</span>
<span class="lineno"> 2262 </span><span class="spaces">      </span><span class="istickedoff">--    need not keep track of de Bruijn's for the type parameters.</span>
<span class="lineno"> 2263 </span><span class="spaces">      </span><span class="istickedoff">addTypeAbstractions :: Term -&gt; IO Term</span>
<span class="lineno"> 2264 </span><span class="spaces">      </span><span class="istickedoff">addTypeAbstractions t = scAbstractExts sc tyParamsECs t</span>
<span class="lineno"> 2265 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2266 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2267 </span><span class="spaces">  </span><span class="istickedoff">-- Common naming conventions:</span>
<span class="lineno"> 2268 </span><span class="spaces">  </span><span class="istickedoff">let sumTy_ident = identOfEnumType ntName'</span>
<span class="lineno"> 2269 </span><span class="spaces">      </span><span class="istickedoff">case_ident  = identOfEnumCase ntName'</span>
<span class="lineno"> 2270 </span><span class="spaces">      </span><span class="istickedoff">tl_ident    = newIdent ntName' &quot;__LS&quot;</span>
<span class="lineno"> 2271 </span><span class="spaces">                    </span><span class="istickedoff">-- name for the 'type list', type is ListSort (thus LS)</span>
<span class="lineno"> 2272 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2273 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2274 </span><span class="spaces">  </span><span class="istickedoff">-- Definitions to access needed SAWCore Prelude types &amp; definitions:</span>
<span class="lineno"> 2275 </span><span class="spaces">  </span><span class="istickedoff">sort0          &lt;- scSort sc (mkSort 0)</span>
<span class="lineno"> 2276 </span><span class="spaces">  </span><span class="istickedoff">scListSort     &lt;- scDataTypeApp sc &quot;Prelude.ListSort&quot; []</span>
<span class="lineno"> 2277 </span><span class="spaces">  </span><span class="istickedoff">scLS_Nil       &lt;- scCtorApp sc &quot;Prelude.LS_Nil&quot;  []</span>
<span class="lineno"> 2278 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2279 </span><span class="spaces">  </span><span class="istickedoff">let scLS_Cons s ls   = scCtorApp     sc &quot;Prelude.LS_Cons&quot; [s,ls]</span>
<span class="lineno"> 2280 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2281 </span><span class="spaces">      </span><span class="istickedoff">scEithersV ls    = scGlobalApply sc &quot;Prelude.EithersV&quot; [ls]</span>
<span class="lineno"> 2282 </span><span class="spaces">      </span><span class="istickedoff">sc_eithersV b ls = scGlobalApply sc &quot;Prelude.eithersV&quot; [b,ls]</span>
<span class="lineno"> 2283 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2284 </span><span class="spaces">     </span><span class="istickedoff">-- to create values of the Either type:</span>
<span class="lineno"> 2285 </span><span class="spaces">      </span><span class="istickedoff">scLeft  a b x    = scCtorApp     sc &quot;Prelude.Left&quot;  [a,b,x]</span>
<span class="lineno"> 2286 </span><span class="spaces">      </span><span class="istickedoff">scRight a b x    = scCtorApp     sc &quot;Prelude.Right&quot; [a,b,x]</span>
<span class="lineno"> 2287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2288 </span><span class="spaces">      </span><span class="istickedoff">scMakeListSort :: [Term] -&gt; IO Term</span>
<span class="lineno"> 2289 </span><span class="spaces">      </span><span class="istickedoff">scMakeListSort = Fold.foldrM scLS_Cons scLS_Nil</span>
<span class="lineno"> 2290 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2291 </span><span class="spaces">      </span><span class="istickedoff">-- | scMakeFunsTo b tvs - create FunsTo list of type `FunsTo b`, given</span>
<span class="lineno"> 2292 </span><span class="spaces">      </span><span class="istickedoff">--    the list of (type, val :: type-&gt;b) pairs</span>
<span class="lineno"> 2293 </span><span class="spaces">      </span><span class="istickedoff">scMakeFunsTo :: Term -&gt; [(Term,Term)] -&gt; IO Term</span>
<span class="lineno"> 2294 </span><span class="spaces">      </span><span class="istickedoff">scMakeFunsTo b tvs =</span>
<span class="lineno"> 2295 </span><span class="spaces">        </span><span class="istickedoff">do</span>
<span class="lineno"> 2296 </span><span class="spaces">        </span><span class="istickedoff">scFunsTo_Nil &lt;- scCtorApp sc &quot;Prelude.FunsTo_Nil&quot;  [b]</span>
<span class="lineno"> 2297 </span><span class="spaces">        </span><span class="istickedoff">let scFunsTo_Cons (t,v) r =</span>
<span class="lineno"> 2298 </span><span class="spaces">              </span><span class="istickedoff">scCtorApp sc &quot;Prelude.FunsTo_Cons&quot; [b,t,v,r]</span>
<span class="lineno"> 2299 </span><span class="spaces">        </span><span class="istickedoff">Fold.foldrM scFunsTo_Cons scFunsTo_Nil tvs</span>
<span class="lineno"> 2300 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2301 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2302 </span><span class="spaces">  </span><span class="istickedoff">-- Create TypeList(tl) for the Enum, add to SAWCore environment:</span>
<span class="lineno"> 2303 </span><span class="spaces">  </span><span class="istickedoff">--  - elements of list are the elements of the Sum.</span>
<span class="lineno"> 2304 </span><span class="spaces">  </span><span class="istickedoff">--  - the types maintain the same exact type vars (see tyParamsInfo)</span>
<span class="lineno"> 2305 </span><span class="spaces">  </span><span class="istickedoff">-- Using the running example, we want to add the following to the</span>
<span class="lineno"> 2306 </span><span class="spaces">  </span><span class="istickedoff">-- SAWCore environment:</span>
<span class="lineno"> 2307 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2308 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; ETT__LS : sort 0 -&gt; ListSort;</span>
<span class="lineno"> 2309 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; ETT__LS ts = LS_Cons     (scTupleType [])</span>
<span class="lineno"> 2310 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;               (LS_Cons  (scTupleType [Nat])</span>
<span class="lineno"> 2311 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;                (LS_Cons (scTupleType [Bool,ts])</span>
<span class="lineno"> 2312 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;                  LS_Nil));</span>
<span class="lineno"> 2313 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2314 </span><span class="spaces">  </span><span class="istickedoff">--  cheating a little in the above syntax.</span>
<span class="lineno"> 2315 </span><span class="spaces">  </span><span class="istickedoff">--   - scTupleType is not SAWCore, it represents what's created with `scTupleType' function</span>
<span class="lineno"> 2316 </span><span class="spaces">  </span><span class="istickedoff">--   - using list syntax for the ListSort lists that are the arguments to the above.</span>
<span class="lineno"> 2317 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2318 </span><span class="spaces">  </span><span class="istickedoff">-- argTypes_eachCtor is the sum of products matrix for our enum type:</span>
<span class="lineno"> 2319 </span><span class="spaces">  </span><span class="istickedoff">(argTypes_eachCtor :: [[Term]]) &lt;-</span>
<span class="lineno"> 2320 </span><span class="spaces">    </span><span class="istickedoff">-- add tyParamsInfo to the env as it is needed to allow `importType`</span>
<span class="lineno"> 2321 </span><span class="spaces">    </span><span class="istickedoff">-- to work:</span>
<span class="lineno"> 2322 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno"> 2323 </span><span class="spaces">    </span><span class="istickedoff">env' &lt;- Fold.foldrM (\tp env'-&gt; bindTParam sc tp env') env tyParamsInfo</span>
<span class="lineno"> 2324 </span><span class="spaces">    </span><span class="istickedoff">forM ctors $ \c-&gt;</span>
<span class="lineno"> 2325 </span><span class="spaces">      </span><span class="istickedoff">mapM (\t-&gt; do</span>
<span class="lineno"> 2326 </span><span class="spaces">              </span><span class="istickedoff">t' &lt;- importType sc env' t</span>
<span class="lineno"> 2327 </span><span class="spaces">                </span><span class="istickedoff">-- here ^, type params are De Bruijn's</span>
<span class="lineno"> 2328 </span><span class="spaces">              </span><span class="istickedoff">instantiateVarList <span class="nottickedoff">sc</span> 0 tyParamsVars t'</span>
<span class="lineno"> 2329 </span><span class="spaces">                </span><span class="istickedoff">-- here ^, type params are references to ExtCns</span>
<span class="lineno"> 2330 </span><span class="spaces">           </span><span class="istickedoff">)</span>
<span class="lineno"> 2331 </span><span class="spaces">           </span><span class="istickedoff">(C.ecFields c)</span>
<span class="lineno"> 2332 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2333 </span><span class="spaces">  </span><span class="istickedoff">-- map the list of types to the product type:</span>
<span class="lineno"> 2334 </span><span class="spaces">  </span><span class="istickedoff">represType_eachCtor &lt;- forM argTypes_eachCtor $ \ts -&gt;</span>
<span class="lineno"> 2335 </span><span class="spaces">                           </span><span class="istickedoff">scTupleType sc ts</span>
<span class="lineno"> 2336 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2337 </span><span class="spaces">  </span><span class="istickedoff">tl_rhs   &lt;- addTypeAbstractions =&lt;&lt; scMakeListSort represType_eachCtor</span>
<span class="lineno"> 2338 </span><span class="spaces">  </span><span class="istickedoff">tl_type  &lt;- scFunAll sc tyParamsKinds scListSort</span>
<span class="lineno"> 2339 </span><span class="spaces">  </span><span class="istickedoff">scInsertDef sc preludeName tl_ident tl_type tl_rhs</span>
<span class="lineno"> 2340 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2341 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2342 </span><span class="spaces">  </span><span class="istickedoff">-- Create the definition for the SAWCore sum (to which we map the</span>
<span class="lineno"> 2343 </span><span class="spaces">  </span><span class="istickedoff">-- enum type).  For the running example we would see this:</span>
<span class="lineno"> 2344 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2345 </span><span class="spaces">  </span><span class="istickedoff">-- &gt; ETT : (ts : sort 0) -&gt; sort 0;</span>
<span class="lineno"> 2346 </span><span class="spaces">  </span><span class="istickedoff">-- &gt; ETT ts = EithersV (ETT__LS ts);</span>
<span class="lineno"> 2347 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2348 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2349 </span><span class="spaces">  </span><span class="istickedoff">-- the Typelist(tl) applied to the [free] type arguments.</span>
<span class="lineno"> 2350 </span><span class="spaces">  </span><span class="istickedoff">tl_applied &lt;- scGlobalApply sc tl_ident tyParamsVars</span>
<span class="lineno"> 2351 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2352 </span><span class="spaces">  </span><span class="istickedoff">sumTy_type &lt;- scFunAll sc tyParamsKinds sort0</span>
<span class="lineno"> 2353 </span><span class="spaces">  </span><span class="istickedoff">sumTy_rhs  &lt;- addTypeAbstractions =&lt;&lt; scEithersV tl_applied</span>
<span class="lineno"> 2354 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2355 </span><span class="spaces">  </span><span class="istickedoff">scInsertDef sc preludeName sumTy_ident sumTy_type sumTy_rhs</span>
<span class="lineno"> 2356 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2357 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2358 </span><span class="spaces">  </span><span class="istickedoff">-- Create a `case` function specialized to the enum type.</span>
<span class="lineno"> 2359 </span><span class="spaces">  </span><span class="istickedoff">-- For the running example, we will define this:</span>
<span class="lineno"> 2360 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2361 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; ETT_case  : (ts : sort 0)</span>
<span class="lineno"> 2362 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;          -&gt; (b: sort 0)</span>
<span class="lineno"> 2363 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;          -&gt; (arrowsType []        b)</span>
<span class="lineno"> 2364 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;          -&gt; (arrowsType [Nat]     b)</span>
<span class="lineno"> 2365 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;          -&gt; (arrowsType [Bool,ts] b)</span>
<span class="lineno"> 2366 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;          -&gt; ETT ts</span>
<span class="lineno"> 2367 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;          -&gt; b;</span>
<span class="lineno"> 2368 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; ETT_case ts b f1 f2 f3 =</span>
<span class="lineno"> 2369 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;   eithersV b</span>
<span class="lineno"> 2370 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;     (FunsTo_Cons b (ETT__ArgType_C1 ts) (\(x: scTupleType []       ) -&gt; f1)</span>
<span class="lineno"> 2371 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;     (FunsTo_Cons b (ETT__ArgType_C2 ts) (\(x: scTupleType [Nat]    ) -&gt; f2 x.1)</span>
<span class="lineno"> 2372 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;     (FunsTo_Cons b (ETT__ArgType_C3 ts) (\(x: scTupleType [Bool,ts]) -&gt; f3 x.1 x.2)</span>
<span class="lineno"> 2373 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;     (FunsTo_Nil b))));</span>
<span class="lineno"> 2374 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2375 </span><span class="spaces">  </span><span class="istickedoff">-- Using the same syntax cheats we did above.</span>
<span class="lineno"> 2376 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2377 </span><span class="spaces">  </span><span class="istickedoff">sumTy_applied &lt;- scGlobalApply sc sumTy_ident tyParamsVars</span>
<span class="lineno"> 2378 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2379 </span><span class="spaces">  </span><span class="istickedoff">let mkAltFuncTypes b = mapM (\ts-&gt;scFunAll sc ts b) argTypes_eachCtor</span>
<span class="lineno"> 2380 </span><span class="spaces">  </span><span class="istickedoff">case_type &lt;-</span>
<span class="lineno"> 2381 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno"> 2382 </span><span class="spaces">      </span><span class="istickedoff">b &lt;- scLocalVar sc 0</span>
<span class="lineno"> 2383 </span><span class="spaces">            </span><span class="istickedoff">-- all uses are direct under the 'Pi'</span>
<span class="lineno"> 2384 </span><span class="spaces">            </span><span class="istickedoff">-- N.B.: scFun's aren't included in De Bruijn's!</span>
<span class="lineno"> 2385 </span><span class="spaces">      </span><span class="istickedoff">altFuncTypes &lt;- mkAltFuncTypes b</span>
<span class="lineno"> 2386 </span><span class="spaces">      </span><span class="istickedoff">scPiAbstractExts sc tyParamsECs</span>
<span class="lineno"> 2387 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; scPi sc &quot;b&quot; sort0</span>
<span class="lineno"> 2388 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; scFunAll sc altFuncTypes</span>
<span class="lineno"> 2389 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; scFun sc sumTy_applied b</span>
<span class="lineno"> 2390 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2391 </span><span class="spaces">  </span><span class="istickedoff">case_rhs &lt;-</span>
<span class="lineno"> 2392 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno"> 2393 </span><span class="spaces">      </span><span class="istickedoff">-- Create needed vars for SAWCore expression</span>
<span class="lineno"> 2394 </span><span class="spaces">      </span><span class="istickedoff">--  - generating something like:</span>
<span class="lineno"> 2395 </span><span class="spaces">      </span><span class="istickedoff">--    \tyvars..-&gt; \(b: sort)-&gt;(\f1 f2 ... -&gt;</span>
<span class="lineno"> 2396 </span><span class="spaces">      </span><span class="istickedoff">--       eithersV b (FunsToCons b ... (\x-&gt; f1 ...) ...)</span>
<span class="lineno"> 2397 </span><span class="spaces">      </span><span class="istickedoff">--  - the 'base' of the de Bruijn indices are inside `body` below,</span>
<span class="lineno"> 2398 </span><span class="spaces">      </span><span class="istickedoff">--    thus, the following two defs:</span>
<span class="lineno"> 2399 </span><span class="spaces">      </span><span class="istickedoff">x &lt;- scLocalVar sc 0</span>
<span class="lineno"> 2400 </span><span class="spaces">      </span><span class="istickedoff">funcVars  &lt;- reverse &lt;$&gt; mapM (scLocalVar sc) [1..numCtors]</span>
<span class="lineno"> 2401 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2402 </span><span class="spaces">      </span><span class="istickedoff">bExtCn &lt;- scFreshEC sc &quot;b&quot; sort0</span>
<span class="lineno"> 2403 </span><span class="spaces">      </span><span class="istickedoff">b      &lt;- scExtCns sc bExtCn  -- bExtCn into Term variable</span>
<span class="lineno"> 2404 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2405 </span><span class="spaces">      </span><span class="istickedoff">let funcNames = map (\n-&gt; Text.pack (&quot;f&quot; ++ show n)) [1..numCtors]</span>
<span class="lineno"> 2406 </span><span class="spaces">      </span><span class="istickedoff">funcTypes &lt;- mkAltFuncTypes b</span>
<span class="lineno"> 2407 </span><span class="spaces">      </span><span class="istickedoff">funcDefs  &lt;- forM (zip3 funcVars represType_eachCtor ctors) $</span>
<span class="lineno"> 2408 </span><span class="spaces">                     </span><span class="istickedoff">\(funcVar,ty,ctor) -&gt;</span>
<span class="lineno"> 2409 </span><span class="spaces">                         </span><span class="istickedoff">do</span>
<span class="lineno"> 2410 </span><span class="spaces">                         </span><span class="istickedoff">let n = length (C.ecFields ctor)</span>
<span class="lineno"> 2411 </span><span class="spaces">                         </span><span class="istickedoff">funcArgs &lt;- forM [1..n] $ \i-&gt;</span>
<span class="lineno"> 2412 </span><span class="spaces">                                       </span><span class="istickedoff">scTupleSelector sc x i n</span>
<span class="lineno"> 2413 </span><span class="spaces">                         </span><span class="istickedoff">body &lt;- scApplyAll sc funcVar funcArgs</span>
<span class="lineno"> 2414 </span><span class="spaces">                         </span><span class="istickedoff">scLambda sc &quot;x&quot; ty body</span>
<span class="lineno"> 2415 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2416 </span><span class="spaces">      </span><span class="istickedoff">addTypeAbstractions</span>
<span class="lineno"> 2417 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; scAbstractExts sc [bExtCn]</span>
<span class="lineno"> 2418 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; scLambdaList sc (zip funcNames funcTypes)</span>
<span class="lineno"> 2419 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; sc_eithersV b</span>
<span class="lineno"> 2420 </span><span class="spaces">        </span><span class="istickedoff">=&lt;&lt; scMakeFunsTo b (zip represType_eachCtor funcDefs)</span>
<span class="lineno"> 2421 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2422 </span><span class="spaces">  </span><span class="istickedoff">scInsertDef sc preludeName case_ident case_type case_rhs</span>
<span class="lineno"> 2423 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2424 </span><span class="spaces">  </span><span class="istickedoff">assertSAWCoreTypeChecks sc <span class="nottickedoff">case_ident</span> case_rhs (Just <span class="nottickedoff">case_type</span>)</span>
<span class="lineno"> 2425 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2426 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2427 </span><span class="spaces">  </span><span class="istickedoff">-- There's a bit of 'tedium' in creating the constructors, let's look at our</span>
<span class="lineno"> 2428 </span><span class="spaces">  </span><span class="istickedoff">-- running example, the SAWCore constructors we want are these:</span>
<span class="lineno"> 2429 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2430 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; ```</span>
<span class="lineno"> 2431 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; C1 : (ts : sort 0) -&gt; listSortGet (ETT__LS ts) 0 -&gt; ETT ts;</span>
<span class="lineno"> 2432 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; C1 ts x =</span>
<span class="lineno"> 2433 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;   Left (listSortGet (ETT__LS ts) 0) (EithersV (listSortDrop (ETT__LS ts) 1))</span>
<span class="lineno"> 2434 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;        x;</span>
<span class="lineno"> 2435 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;</span>
<span class="lineno"> 2436 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; C2 : (ts : sort 0) -&gt; listSortGet (ETT__LS ts) 1 -&gt; ETT ts;</span>
<span class="lineno"> 2437 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; C2 ts x =</span>
<span class="lineno"> 2438 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;   Right (listSortGet (ETT__LS ts) 0) (EithersV (listSortDrop (ETT__LS ts) 1))</span>
<span class="lineno"> 2439 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;   (Left (listSortGet (ETT__LS ts) 1) (EithersV (listSortDrop (ETT__LS ts) 2))</span>
<span class="lineno"> 2440 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;    x);</span>
<span class="lineno"> 2441 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;</span>
<span class="lineno"> 2442 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; C3 : (ts : sort 0) -&gt; listSortGet (ETT__LS ts) 2 -&gt; ETT ts;</span>
<span class="lineno"> 2443 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; C3 ts x =</span>
<span class="lineno"> 2444 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;  Right   (listSortGet (ETT__LS ts) 0) (EithersV (listSortDrop (ETT__LS ts) 1))</span>
<span class="lineno"> 2445 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;   (Right (listSortGet (ETT__LS ts) 1) (EithersV (listSortDrop (ETT__LS ts) 2))</span>
<span class="lineno"> 2446 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;    (Left (listSortGet (ETT__LS ts) 2) (EithersV (listSortDrop (ETT__LS ts) 3))</span>
<span class="lineno"> 2447 </span><span class="spaces">  </span><span class="istickedoff">--   &gt;    x));</span>
<span class="lineno"> 2448 </span><span class="spaces">  </span><span class="istickedoff">--   &gt; ```</span>
<span class="lineno"> 2449 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 2450 </span><span class="spaces">  </span><span class="istickedoff">-- One can see that we try to encapsulate all the enum specific data in the</span>
<span class="lineno"> 2451 </span><span class="spaces">  </span><span class="istickedoff">-- @ETT__LS ts@ structure.</span>
<span class="lineno"> 2452 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2453 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2454 </span><span class="spaces"></span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2455 </span><span class="spaces">  </span><span class="istickedoff">-- Define function for N-th injection into the whole Sum (nested Either's):</span>
<span class="lineno"> 2456 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2457 </span><span class="spaces">  </span><span class="istickedoff">scNthInjection &lt;-</span>
<span class="lineno"> 2458 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno"> 2459 </span><span class="spaces">      </span><span class="istickedoff">-- Create needed SAWCore types for the Left/Right constructors</span>
<span class="lineno"> 2460 </span><span class="spaces">      </span><span class="istickedoff">-- (each Either in the nested Either's needs a pair of types):</span>
<span class="lineno"> 2461 </span><span class="spaces">      </span><span class="istickedoff">tps &lt;- Vector.generateM numCtors $ \i-&gt;</span>
<span class="lineno"> 2462 </span><span class="spaces">               </span><span class="istickedoff">do</span>
<span class="lineno"> 2463 </span><span class="spaces">               </span><span class="istickedoff">typeLeft  &lt;- do</span>
<span class="lineno"> 2464 </span><span class="spaces">                            </span><span class="istickedoff">n &lt;- scNat sc (fromIntegral i)</span>
<span class="lineno"> 2465 </span><span class="spaces">                            </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.listSortGet&quot;</span>
<span class="lineno"> 2466 </span><span class="spaces">                              </span><span class="istickedoff">[tl_applied, n]</span>
<span class="lineno"> 2467 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2468 </span><span class="spaces">               </span><span class="istickedoff">typeRight &lt;- do</span>
<span class="lineno"> 2469 </span><span class="spaces">                            </span><span class="istickedoff">n &lt;- scNat sc (fromIntegral i + 1)</span>
<span class="lineno"> 2470 </span><span class="spaces">                            </span><span class="istickedoff">tl_remainder &lt;-</span>
<span class="lineno"> 2471 </span><span class="spaces">                              </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.listSortDrop&quot;</span>
<span class="lineno"> 2472 </span><span class="spaces">                                </span><span class="istickedoff">[tl_applied, n]</span>
<span class="lineno"> 2473 </span><span class="spaces">                            </span><span class="istickedoff">scEithersV tl_remainder</span>
<span class="lineno"> 2474 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2475 </span><span class="spaces">               </span><span class="istickedoff">return (typeLeft, typeRight)</span>
<span class="lineno"> 2476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2477 </span><span class="spaces">      </span><span class="istickedoff">let</span>
<span class="lineno"> 2478 </span><span class="spaces">        </span><span class="istickedoff">scInjectRight :: Int -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 2479 </span><span class="spaces">        </span><span class="istickedoff">scInjectRight n x | n &lt; 0     = return x</span>
<span class="lineno"> 2480 </span><span class="spaces">                          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = do</span>
<span class="lineno"> 2481 </span><span class="spaces">                              </span><span class="istickedoff">y &lt;- scRight (fst (tps Vector.! n)) (snd (tps Vector.! n)) x</span>
<span class="lineno"> 2482 </span><span class="spaces">                              </span><span class="istickedoff">scInjectRight (n-1) y</span>
<span class="lineno"> 2483 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2484 </span><span class="spaces">        </span><span class="istickedoff">scNthInjection :: Int -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 2485 </span><span class="spaces">        </span><span class="istickedoff">scNthInjection n x = do</span>
<span class="lineno"> 2486 </span><span class="spaces">                             </span><span class="istickedoff">y &lt;- scLeft (fst (tps Vector.! n)) (snd (tps Vector.! n)) x</span>
<span class="lineno"> 2487 </span><span class="spaces">                             </span><span class="istickedoff">scInjectRight (n-1) y</span>
<span class="lineno"> 2488 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2489 </span><span class="spaces">      </span><span class="istickedoff">return scNthInjection</span>
<span class="lineno"> 2490 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2491 </span><span class="spaces">  </span><span class="istickedoff">-------------------------------------------------------------</span>
<span class="lineno"> 2492 </span><span class="spaces">  </span><span class="istickedoff">-- Create the definition for each constructor:</span>
<span class="lineno"> 2493 </span><span class="spaces">  </span><span class="istickedoff">defn_eachCtor &lt;-</span>
<span class="lineno"> 2494 </span><span class="spaces">    </span><span class="istickedoff">forM (zip argTypes_eachCtor ctors) $</span>
<span class="lineno"> 2495 </span><span class="spaces">        </span><span class="istickedoff">\(argTypes, ctor)-&gt;</span>
<span class="lineno"> 2496 </span><span class="spaces">        </span><span class="istickedoff">do</span>
<span class="lineno"> 2497 </span><span class="spaces">        </span><span class="istickedoff">let</span>
<span class="lineno"> 2498 </span><span class="spaces">          </span><span class="istickedoff">ctorName   = C.ecName ctor</span>
<span class="lineno"> 2499 </span><span class="spaces">          </span><span class="istickedoff">ctorNumber = C.ecNumber ctor</span>
<span class="lineno"> 2500 </span><span class="spaces">          </span><span class="istickedoff">numArgs    = length argTypes</span>
<span class="lineno"> 2501 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2502 </span><span class="spaces">        </span><span class="istickedoff">-- NOTE: we don't add the constructor arguments to the Env, as</span>
<span class="lineno"> 2503 </span><span class="spaces">        </span><span class="istickedoff">-- the only references to these arguments are in the generated</span>
<span class="lineno"> 2504 </span><span class="spaces">        </span><span class="istickedoff">-- SAWCore code.</span>
<span class="lineno"> 2505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2506 </span><span class="spaces">        </span><span class="istickedoff">-- create the vars (&amp; names) for constructor arguments:</span>
<span class="lineno"> 2507 </span><span class="spaces">        </span><span class="istickedoff">paramVars &lt;- reverse &lt;$&gt; mapM (scLocalVar sc) [0..numArgs-1]</span>
<span class="lineno"> 2508 </span><span class="spaces">        </span><span class="istickedoff">let paramNames = map (\x-&gt; Text.pack (&quot;x&quot; ++ show x)) [0..numArgs-1]</span>
<span class="lineno"> 2509 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2510 </span><span class="spaces">        </span><span class="istickedoff">-- create the constructor:</span>
<span class="lineno"> 2511 </span><span class="spaces">        </span><span class="istickedoff">ctorBody &lt;- addTypeAbstractions</span>
<span class="lineno"> 2512 </span><span class="spaces">                    </span><span class="istickedoff">=&lt;&lt; scLambdaList sc (zip paramNames argTypes)</span>
<span class="lineno"> 2513 </span><span class="spaces">                    </span><span class="istickedoff">=&lt;&lt; scNthInjection ctorNumber</span>
<span class="lineno"> 2514 </span><span class="spaces">                    </span><span class="istickedoff">=&lt;&lt; scTuple sc paramVars</span>
<span class="lineno"> 2515 </span><span class="spaces">        </span><span class="istickedoff">assertSAWCoreTypeChecks sc <span class="nottickedoff">(C.nameIdent ctorName)</span> ctorBody Nothing</span>
<span class="lineno"> 2516 </span><span class="spaces">        </span><span class="istickedoff">return (ctorName, ctorBody)</span>
<span class="lineno"> 2517 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2518 </span><span class="spaces">  </span><span class="istickedoff">return defn_eachCtor</span></span>
<span class="lineno"> 2519 </span>
<span class="lineno"> 2520 </span>
<span class="lineno"> 2521 </span>-- | importCase - translates a Cryptol case expr to SAWCore: an application
<span class="lineno"> 2522 </span>--   of the generated SAWCore &lt;NAME&gt;__case function to appropriate arguments.
<span class="lineno"> 2523 </span>--
<span class="lineno"> 2524 </span>--   - Note missing functionality: (FIXME)
<span class="lineno"> 2525 </span>--     - not implemented yet: default case alternatives that bind the whole scrutinee,
<span class="lineno"> 2526 </span>--       i.e.,
<span class="lineno"> 2527 </span>--
<span class="lineno"> 2528 </span>--       &gt;  case S of
<span class="lineno"> 2529 </span>--       &gt;    C1 ... -&gt; E
<span class="lineno"> 2530 </span>--       &gt;    y      -&gt; E[y]  -- y == S   &lt;- NOT IMPLEMENTED YET
<span class="lineno"> 2531 </span>--
<span class="lineno"> 2532 </span>importCase ::
<span class="lineno"> 2533 </span>  HasCallStack =&gt;
<span class="lineno"> 2534 </span>  SharedContext -&gt; Env -&gt;
<span class="lineno"> 2535 </span>  C.Type -&gt; C.Expr -&gt; Map C.Ident C.CaseAlt -&gt; Maybe C.CaseAlt -&gt; IO Term
<span class="lineno"> 2536 </span><span class="decl"><span class="istickedoff">importCase sc env b scrutinee altsMap mDfltAlt =</span>
<span class="lineno"> 2537 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno"> 2538 </span><span class="spaces">  </span><span class="istickedoff">let scrutineeTy = fastTypeOf (envC env) scrutinee</span>
<span class="lineno"> 2539 </span><span class="spaces">  </span><span class="istickedoff">(nm,ctors,tyParams,tyArgs) &lt;- case scrutineeTy of</span>
<span class="lineno"> 2540 </span><span class="spaces">      </span><span class="istickedoff">(C.tIsNominal -&gt; Just (C.NominalType{C.ntDef=C.Enum ctors, ntName=nm, ntParams=tyParams},tyArgs))</span>
<span class="lineno"> 2541 </span><span class="spaces">        </span><span class="istickedoff">-&gt;</span>
<span class="lineno"> 2542 </span><span class="spaces">          </span><span class="istickedoff">return (nm,ctors,tyParams,tyArgs)</span>
<span class="lineno"> 2543 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 2544 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importCase&quot; [</span></span>
<span class="lineno"> 2545 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">&quot;`case` expression scrutinee is not an Enum type&quot;,</span></span>
<span class="lineno"> 2546 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">Text.pack (pretty scrutineeTy)</span></span>
<span class="lineno"> 2547 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2548 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2549 </span><span class="spaces">  </span><span class="istickedoff">-- Create a sequential set of `C.CaseAlt`s that exactly match the constructors:</span>
<span class="lineno"> 2550 </span><span class="spaces">  </span><span class="istickedoff">--   - preconditions:</span>
<span class="lineno"> 2551 </span><span class="spaces">  </span><span class="istickedoff">--      Assume `altsMap` is valid, thus not checking for extraneous</span>
<span class="lineno"> 2552 </span><span class="spaces">  </span><span class="istickedoff">--      entries. (Call panic if a missing alternative is not covered</span>
<span class="lineno"> 2553 </span><span class="spaces">  </span><span class="istickedoff">--      by presence of default in `mDfltAlt`.)</span>
<span class="lineno"> 2554 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2555 </span><span class="spaces">  </span><span class="istickedoff">-- First, define what to do if alternative for constructor is missing:</span>
<span class="lineno"> 2556 </span><span class="spaces">  </span><span class="istickedoff">let</span>
<span class="lineno"> 2557 </span><span class="spaces">      </span><span class="istickedoff">-- | useDefaultAlt - when constructor (ctor) has no 'CaseAlt',</span>
<span class="lineno"> 2558 </span><span class="spaces">      </span><span class="istickedoff">-- create a ctor specific alt-function from the mDfltAlt</span>
<span class="lineno"> 2559 </span><span class="spaces">      </span><span class="istickedoff">-- &quot;default expr&quot;.</span>
<span class="lineno"> 2560 </span><span class="spaces">      </span><span class="istickedoff">--   - For each constructor we may need to generate a default alternative,</span>
<span class="lineno"> 2561 </span><span class="spaces">      </span><span class="istickedoff">--     (the code cannot be shared as the arity and types for each constructor</span>
<span class="lineno"> 2562 </span><span class="spaces">      </span><span class="istickedoff">--     will be different).</span>
<span class="lineno"> 2563 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2564 </span><span class="spaces">      </span><span class="istickedoff">useDefaultAlt :: HasCallStack =&gt; C.EnumCon -&gt; IO C.CaseAlt</span>
<span class="lineno"> 2565 </span><span class="spaces">      </span><span class="istickedoff">useDefaultAlt ctor = case mDfltAlt of</span>
<span class="lineno"> 2566 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2567 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importCase&quot; [</span></span>
<span class="lineno"> 2568 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;missing CaseAlt and no default CaseAlt: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno"> 2569 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2570 </span><span class="spaces">        </span><span class="istickedoff">Just (C.CaseAlt [(nm',_)] dfltE)</span>
<span class="lineno"> 2571 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">nameIsUnusedPat nm'</span> -&gt;</span>
<span class="lineno"> 2572 </span><span class="spaces">                </span><span class="istickedoff">do</span>
<span class="lineno"> 2573 </span><span class="spaces">                </span><span class="istickedoff">-- NOTE nm' is unused Name</span>
<span class="lineno"> 2574 </span><span class="spaces">                </span><span class="istickedoff">let sub  = C.listSubst (zip (map C.TVBound tyParams) tyArgs)</span>
<span class="lineno"> 2575 </span><span class="spaces">                    </span><span class="istickedoff">vts  = map</span>
<span class="lineno"> 2576 </span><span class="spaces">                             </span><span class="istickedoff">(\ty-&gt; (nm',plainSubst sub ty))</span>
<span class="lineno"> 2577 </span><span class="spaces">                             </span><span class="istickedoff">(C.ecFields ctor)</span>
<span class="lineno"> 2578 </span><span class="spaces">                  </span><span class="istickedoff">-- N.B.: to avoid extra name construction, we are using</span>
<span class="lineno"> 2579 </span><span class="spaces">                  </span><span class="istickedoff">--  the same name (un-referenced!) nm' for each of the arguments</span>
<span class="lineno"> 2580 </span><span class="spaces">                  </span><span class="istickedoff">--  of the CaseAlt function.  This appears to work.  However, if the</span>
<span class="lineno"> 2581 </span><span class="spaces">                  </span><span class="istickedoff">--  '_' name *was* actually referenced, it would not be what we would want</span>
<span class="lineno"> 2582 </span><span class="spaces">                  </span><span class="istickedoff">--  However, typechecking would ascertain this.</span>
<span class="lineno"> 2583 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2584 </span><span class="spaces">                </span><span class="istickedoff">return (C.CaseAlt vts dfltE)</span>
<span class="lineno"> 2585 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2586 </span><span class="spaces">            </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno"> 2587 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importCase&quot; [</span></span>
<span class="lineno"> 2588 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;Unsupported style of case expression: &quot; &lt;&gt;</span></span>
<span class="lineno"> 2589 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">&quot;default case alternative that binds scrutinee&quot;,</span></span>
<span class="lineno"> 2590 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;pattern: &quot; &lt;&gt; Text.pack (pretty nm)</span></span>
<span class="lineno"> 2591 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2592 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2593 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno"> 2594 </span><span class="spaces">          </span><span class="istickedoff">nameIsUnusedPat nm'' =</span>
<span class="lineno"> 2595 </span><span class="spaces">            </span><span class="istickedoff">Text.take 3 (nameToLocalName nm'') == &quot;__p&quot;</span>
<span class="lineno"> 2596 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2597 </span><span class="spaces">            </span><span class="istickedoff">-- Except for the prefix, the indication that this is an unused pattern</span>
<span class="lineno"> 2598 </span><span class="spaces">            </span><span class="istickedoff">-- is long gone. This name is created using `getIdent` in</span>
<span class="lineno"> 2599 </span><span class="spaces">            </span><span class="istickedoff">--   deps/cryptol/src/Cryptol/Parser/Name.hs</span>
<span class="lineno"> 2600 </span><span class="spaces">            </span><span class="istickedoff">-- FIXME:</span>
<span class="lineno"> 2601 </span><span class="spaces">            </span><span class="istickedoff">--  - Clearly this is undesirable coupling.</span>
<span class="lineno"> 2602 </span><span class="spaces">            </span><span class="istickedoff">--  - Best (but non-local, pervasive) solution is to have a more</span>
<span class="lineno"> 2603 </span><span class="spaces">            </span><span class="istickedoff">--    precise type for default CaseAlt, the type is currently</span>
<span class="lineno"> 2604 </span><span class="spaces">            </span><span class="istickedoff">--    too general.</span>
<span class="lineno"> 2605 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2606 </span><span class="spaces">        </span><span class="istickedoff">Just (C.CaseAlt nts _) -&gt;</span>
<span class="lineno"> 2607 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;importCase&quot; [</span></span>
<span class="lineno"> 2608 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Default CaseAlt breaks invariant: &quot; &lt;&gt;</span></span>
<span class="lineno"> 2609 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">&quot;(assumed) invariant is that exactly one variable pattern is allowed in the default CaseAlt&quot;,</span></span>
<span class="lineno"> 2610 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">Text.pack (show $ PP.ppList $ map PP.pp (map fst nts))</span></span>
<span class="lineno"> 2611 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2612 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2613 </span><span class="spaces">  </span><span class="istickedoff">-- now create one alternative ('CaseAlt') for each ctor:</span>
<span class="lineno"> 2614 </span><span class="spaces">  </span><span class="istickedoff">alts &lt;- forM ctors $ \ctor-&gt;</span>
<span class="lineno"> 2615 </span><span class="spaces">            </span><span class="istickedoff">case Map.lookup (C.nameIdent $ C.ecName ctor) altsMap of</span>
<span class="lineno"> 2616 </span><span class="spaces">              </span><span class="istickedoff">Just a  -&gt; return a</span>
<span class="lineno"> 2617 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; useDefaultAlt ctor</span>
<span class="lineno"> 2618 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2619 </span><span class="spaces">  </span><span class="istickedoff">{- |</span>
<span class="lineno"> 2620 </span><span class="spaces">  </span><span class="istickedoff">What we just did is, in terms of the running ETT example above, this:</span>
<span class="lineno"> 2621 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2622 </span><span class="spaces">  </span><span class="istickedoff">Given this Cryptol</span>
<span class="lineno"> 2623 </span><span class="spaces">    </span><span class="istickedoff">&gt; case scrutinee  of</span>
<span class="lineno"> 2624 </span><span class="spaces">    </span><span class="istickedoff">&gt;   C1     -&gt; RHS1</span>
<span class="lineno"> 2625 </span><span class="spaces">    </span><span class="istickedoff">&gt;   _      -&gt; DFLT</span>
<span class="lineno"> 2626 </span><span class="spaces">  </span><span class="istickedoff">we transform it into this Cryptol</span>
<span class="lineno"> 2627 </span><span class="spaces">    </span><span class="istickedoff">&gt; case scrutinee  of</span>
<span class="lineno"> 2628 </span><span class="spaces">    </span><span class="istickedoff">&gt;   C1     -&gt; RHS1</span>
<span class="lineno"> 2629 </span><span class="spaces">    </span><span class="istickedoff">&gt;   C2 _   -&gt; DFLT</span>
<span class="lineno"> 2630 </span><span class="spaces">    </span><span class="istickedoff">&gt;   C3 _ _ -&gt; DFLT</span>
<span class="lineno"> 2631 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2632 </span><span class="spaces">  </span><span class="istickedoff">And what we will do next is transform this last into this SAWCore:</span>
<span class="lineno"> 2633 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2634 </span><span class="spaces">    </span><span class="istickedoff">&gt; ETT_case</span>
<span class="lineno"> 2635 </span><span class="spaces">    </span><span class="istickedoff">&gt;   T1                          -- type application, the instantiation of 'a1'</span>
<span class="lineno"> 2636 </span><span class="spaces">    </span><span class="istickedoff">&gt;   B                           -- type application, the result of the whole case</span>
<span class="lineno"> 2637 </span><span class="spaces">    </span><span class="istickedoff">&gt;   RHS1                        -- deconstructor for C1</span>
<span class="lineno"> 2638 </span><span class="spaces">    </span><span class="istickedoff">&gt;   (\(_: Nat)         -&gt; DFLT) -- deconstructor for C2</span>
<span class="lineno"> 2639 </span><span class="spaces">    </span><span class="istickedoff">&gt;   (\(_: Bool) (_:T1) -&gt; DFLT) -- deconstructor for C3</span>
<span class="lineno"> 2640 </span><span class="spaces">    </span><span class="istickedoff">&gt;                               --  - note the 'a1' has been instantiated to T1</span>
<span class="lineno"> 2641 </span><span class="spaces">    </span><span class="istickedoff">&gt;   scrutinee</span>
<span class="lineno"> 2642 </span><span class="spaces">  </span><span class="istickedoff">-}</span>
<span class="lineno"> 2643 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2644 </span><span class="spaces">  </span><span class="istickedoff">-- translate each CaseAlt into a Cryptol function:</span>
<span class="lineno"> 2645 </span><span class="spaces">  </span><span class="istickedoff">let funcs = map (\(C.CaseAlt xs body)-&gt;</span>
<span class="lineno"> 2646 </span><span class="spaces">                      </span><span class="istickedoff">foldr (\(n,t) e-&gt; C.EAbs n t e) body xs)</span>
<span class="lineno"> 2647 </span><span class="spaces">                  </span><span class="istickedoff">alts</span>
<span class="lineno"> 2648 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2649 </span><span class="spaces">  </span><span class="istickedoff">-- the Cryptol to SAWCore translations:</span>
<span class="lineno"> 2650 </span><span class="spaces">  </span><span class="istickedoff">tyArgs'    &lt;- mapM (importType sc env) tyArgs</span>
<span class="lineno"> 2651 </span><span class="spaces">  </span><span class="istickedoff">b'         &lt;- importType sc env b        -- b is type of whole case expr</span>
<span class="lineno"> 2652 </span><span class="spaces">  </span><span class="istickedoff">scrutinee' &lt;- importExpr <span class="nottickedoff">sc</span> env scrutinee</span>
<span class="lineno"> 2653 </span><span class="spaces">  </span><span class="istickedoff">funcs'     &lt;- mapM (importExpr sc env) funcs</span>
<span class="lineno"> 2654 </span><span class="spaces">  </span><span class="istickedoff">caseExpr   &lt;- scGlobalApply sc (identOfEnumCase nm) $</span>
<span class="lineno"> 2655 </span><span class="spaces">                  </span><span class="istickedoff">tyArgs'             -- case is expecting the type arguments</span>
<span class="lineno"> 2656 </span><span class="spaces">                                      </span><span class="istickedoff">--   that the enumtype is instantiated to</span>
<span class="lineno"> 2657 </span><span class="spaces">                  </span><span class="istickedoff">++ [b']             -- the result type of case expression</span>
<span class="lineno"> 2658 </span><span class="spaces">                  </span><span class="istickedoff">++ funcs'           -- the eliminator funcs, one for each constructor</span>
<span class="lineno"> 2659 </span><span class="spaces">                  </span><span class="istickedoff">++ [scrutinee']     -- scrutinee of case, of enum type</span>
<span class="lineno"> 2660 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2661 </span><span class="spaces">  </span><span class="istickedoff">return caseExpr</span></span>
<span class="lineno"> 2662 </span>
<span class="lineno"> 2663 </span>
<span class="lineno"> 2664 </span>-- Shared naming conventions for Enum support:
<span class="lineno"> 2665 </span>
<span class="lineno"> 2666 </span>identOfEnumType :: C.Name -&gt; Ident
<span class="lineno"> 2667 </span><span class="decl"><span class="istickedoff">identOfEnumType nt = newIdent nt &quot;__TY&quot;</span></span>
<span class="lineno"> 2668 </span>
<span class="lineno"> 2669 </span>identOfEnumCase :: C.Name -&gt; Ident
<span class="lineno"> 2670 </span><span class="decl"><span class="istickedoff">identOfEnumCase nt = newIdent nt &quot;__case&quot;</span></span>
<span class="lineno"> 2671 </span>
<span class="lineno"> 2672 </span>newIdent :: C.Name -&gt; Text -&gt; Ident
<span class="lineno"> 2673 </span><span class="decl"><span class="istickedoff">newIdent name suffix =</span>
<span class="lineno"> 2674 </span><span class="spaces">  </span><span class="istickedoff">mkIdent</span>
<span class="lineno"> 2675 </span><span class="spaces">    </span><span class="istickedoff">preludeName</span>
<span class="lineno"> 2676 </span><span class="spaces">       </span><span class="istickedoff">-- FIXME: These generated definitions should not be added to the prelude but to</span>
<span class="lineno"> 2677 </span><span class="spaces">       </span><span class="istickedoff">--        the module where the Enum (or ...) is defined.</span>
<span class="lineno"> 2678 </span><span class="spaces">    </span><span class="istickedoff">(C.identText (C.nameIdent name) `Text.append` suffix)</span></span>

</pre>
</body>
</html>
