<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    2 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">    3 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    5 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">    6 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    7 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    8 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   10 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   11 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">   12 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   13 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>module SAWScript.HeapsterBuiltins
<span class="lineno">   16 </span>       ( heapster_init_env
<span class="lineno">   17 </span>       , heapster_init_env_debug
<span class="lineno">   18 </span>       , heapster_init_env_from_file
<span class="lineno">   19 </span>       , heapster_init_env_from_file_debug
<span class="lineno">   20 </span>       , heapster_init_env_for_files
<span class="lineno">   21 </span>       , heapster_init_env_for_files_debug
<span class="lineno">   22 </span>       , load_sawcore_from_file
<span class="lineno">   23 </span>       , heapster_get_cfg
<span class="lineno">   24 </span>       , heapster_typecheck_fun
<span class="lineno">   25 </span>       , heapster_typecheck_mut_funs
<span class="lineno">   26 </span>       , heapster_typecheck_fun_rename
<span class="lineno">   27 </span>       , heapster_typecheck_mut_funs_rename
<span class="lineno">   28 </span>       -- , heapster_typecheck_fun_rs
<span class="lineno">   29 </span>       -- , heapster_typecheck_fun_rename_rs
<span class="lineno">   30 </span>       , heapster_define_opaque_perm
<span class="lineno">   31 </span>       , heapster_define_recursive_perm
<span class="lineno">   32 </span>       , heapster_define_reachability_perm
<span class="lineno">   33 </span>       , heapster_define_recursive_shape
<span class="lineno">   34 </span>       , heapster_define_perm
<span class="lineno">   35 </span>       , heapster_define_llvmshape
<span class="lineno">   36 </span>       , heapster_define_opaque_llvmshape
<span class="lineno">   37 </span>       , heapster_define_rust_type
<span class="lineno">   38 </span>       , heapster_define_rust_type_qual
<span class="lineno">   39 </span>       , heapster_block_entry_hint
<span class="lineno">   40 </span>       , heapster_gen_block_perms_hint
<span class="lineno">   41 </span>       , heapster_join_point_hint
<span class="lineno">   42 </span>       , heapster_find_symbol
<span class="lineno">   43 </span>       , heapster_find_symbols
<span class="lineno">   44 </span>       , heapster_find_symbol_with_type
<span class="lineno">   45 </span>       , heapster_find_symbols_with_type
<span class="lineno">   46 </span>       , heapster_find_symbol_commands
<span class="lineno">   47 </span>       , heapster_find_trait_method_symbol
<span class="lineno">   48 </span>       , heapster_assume_fun
<span class="lineno">   49 </span>       , heapster_assume_fun_rename
<span class="lineno">   50 </span>       , heapster_translate_rust_type
<span class="lineno">   51 </span>       , heapster_assume_fun_rename_prim
<span class="lineno">   52 </span>       , heapster_assume_fun_multi
<span class="lineno">   53 </span>       , heapster_set_event_type
<span class="lineno">   54 </span>       , heapster_print_fun_trans
<span class="lineno">   55 </span>       , heapster_export_coq
<span class="lineno">   56 </span>       , heapster_parse_test
<span class="lineno">   57 </span>       , heapster_dump_ide_info
<span class="lineno">   58 </span>       , heapster_set_debug_level
<span class="lineno">   59 </span>       , heapster_set_translation_checks
<span class="lineno">   60 </span>       ) where
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>import Data.Maybe
<span class="lineno">   63 </span>import Data.String
<span class="lineno">   64 </span>import Data.List (find, intersperse, isInfixOf)
<span class="lineno">   65 </span>import Data.IORef
<span class="lineno">   66 </span>import Data.Functor.Product
<span class="lineno">   67 </span>import Data.Functor.Constant (getConstant)
<span class="lineno">   68 </span>import Control.Applicative ( (&lt;|&gt;) )
<span class="lineno">   69 </span>import Control.Lens
<span class="lineno">   70 </span>import Control.Monad
<span class="lineno">   71 </span>import Control.Monad.Reader
<span class="lineno">   72 </span>import qualified Control.Monad.Fail as Fail
<span class="lineno">   73 </span>import System.Directory
<span class="lineno">   74 </span>import Data.Text (Text)
<span class="lineno">   75 </span>import qualified Data.Text as Text
<span class="lineno">   76 </span>import qualified Data.Text as T  -- XXX remove uses of this (too many for just now)
<span class="lineno">   77 </span>import qualified Data.Text.Lazy as TL
<span class="lineno">   78 </span>import qualified Data.Text.Lazy.IO as TLIO
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>import Data.Binding.Hobbits hiding (sym)
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>import Data.Parameterized.BoolRepr
<span class="lineno">   83 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">   84 </span>import Data.Parameterized.TraversableF
<span class="lineno">   85 </span>import Data.Parameterized.TraversableFC
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts)
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>import SAWCore.Term.Functor
<span class="lineno">   90 </span>import SAWCore.Name
<span class="lineno">   91 </span>import SAWCore.Module (Def(..), DefQualifier(..), Module(..), emptyModule, insImport)
<span class="lineno">   92 </span>import SAWCore.Module as Mod (resolveName)
<span class="lineno">   93 </span>import CryptolSAWCore.Monadify
<span class="lineno">   94 </span>import SAWCore.SharedTerm
<span class="lineno">   95 </span>import SAWCore.Recognizer
<span class="lineno">   96 </span>import SAWCore.OpenTerm
<span class="lineno">   97 </span>import SAWCore.Typechecker
<span class="lineno">   98 </span>import SAWCore.SCTypeCheck
<span class="lineno">   99 </span>import qualified SAWCore.Term.Pretty as Pretty (scPrettyTerm, scPrettyTermInCtx)
<span class="lineno">  100 </span>import qualified SAWCore.Parser.AST as Un
<span class="lineno">  101 </span>import qualified SAWCore.Parser.Grammar as Un
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>import Lang.Crucible.Types
<span class="lineno">  104 </span>import Lang.Crucible.FunctionHandle
<span class="lineno">  105 </span>import Lang.Crucible.CFG.Core
<span class="lineno">  106 </span>import Lang.Crucible.LLVM.Extension
<span class="lineno">  107 </span>import Lang.Crucible.LLVM.MemModel
<span class="lineno">  108 </span>import qualified Lang.Crucible.LLVM.PrettyPrint as Crucible.LLVM
<span class="lineno">  109 </span>import Lang.Crucible.LLVM.Translation
<span class="lineno">  110 </span>-- import Lang.Crucible.LLVM.Translation.Types
<span class="lineno">  111 </span>import Lang.Crucible.LLVM.TypeContext
<span class="lineno">  112 </span>import Lang.Crucible.LLVM.DataLayout
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>import qualified Text.LLVM.AST as L
<span class="lineno">  115 </span>import qualified Text.LLVM.Parser as L
<span class="lineno">  116 </span>import qualified Text.PrettyPrint.HughesPJ as L (render)
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>import SAWCentral.TopLevel
<span class="lineno">  119 </span>import SAWCentral.Value
<span class="lineno">  120 </span>import SAWCentral.Options
<span class="lineno">  121 </span>import SAWCentral.LLVMBuiltins
<span class="lineno">  122 </span>import SAWCentral.Builtins
<span class="lineno">  123 </span>import SAWCentral.Crucible.LLVM.Builtins
<span class="lineno">  124 </span>import SAWCentral.Crucible.LLVM.MethodSpecIR
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>import Heapster.CruUtil
<span class="lineno">  127 </span>import Heapster.HintExtract
<span class="lineno">  128 </span>import Heapster.Permissions
<span class="lineno">  129 </span>import Heapster.SAWTranslation
<span class="lineno">  130 </span>import Heapster.PermParser
<span class="lineno">  131 </span>import Heapster.RustTypes (parseSome3FunPermFromRust, Some3FunPerm(..))
<span class="lineno">  132 </span>import Heapster.ParsedCtx
<span class="lineno">  133 </span>import qualified Heapster.IDESupport as HIDE
<span class="lineno">  134 </span>import Heapster.LLVMGlobalConst
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>import SAWCentral.Prover.Exporter
<span class="lineno">  137 </span>import SAWCoreCoq.Coq
<span class="lineno">  138 </span>import Prettyprinter
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>import SAWScript.Panic
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- | Build the SAW core term for the type @TpDesc@
<span class="lineno">  144 </span>tpDescTypeM :: MonadIO m =&gt; SharedContext -&gt; m Term
<span class="lineno">  145 </span><span class="decl"><span class="nottickedoff">tpDescTypeM sc = liftIO $ completeOpenTerm sc tpDescTypeOpenTerm</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>-- | Pretty-print a SAW core term with a 'String' prefix to 'stderr' if the
<span class="lineno">  148 </span>-- current debug level in the supplied 'HeapsterEnv' is above the supplied one
<span class="lineno">  149 </span>debugPrettyTermWithPrefix :: HeapsterEnv -&gt; DebugLevel -&gt; String -&gt; Term -&gt;
<span class="lineno">  150 </span>                             TopLevel ()
<span class="lineno">  151 </span><span class="decl"><span class="nottickedoff">debugPrettyTermWithPrefix henv req_dlevel prefix trm =</span>
<span class="lineno">  152 </span><span class="spaces">  </span><span class="nottickedoff">do dlevel &lt;- liftIO $ readIORef $ heapsterEnvDebugLevel henv</span>
<span class="lineno">  153 </span><span class="spaces">     </span><span class="nottickedoff">pp_opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  154 </span><span class="spaces">     </span><span class="nottickedoff">debugTrace req_dlevel dlevel (prefix ++</span>
<span class="lineno">  155 </span><span class="spaces">                                   </span><span class="nottickedoff">Pretty.scPrettyTerm pp_opts trm) (return ())</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>-- | Check that a type equals the type described by a type description in a ctx
<span class="lineno">  158 </span>checkTypeAgreesWithDesc :: SharedContext -&gt; PermEnv -&gt; Text -&gt; Ident -&gt;
<span class="lineno">  159 </span>                           CruCtx args -&gt; Ident -&gt; IO ()
<span class="lineno">  160 </span><span class="decl"><span class="nottickedoff">checkTypeAgreesWithDesc sc env nm tp_ident ctx d_ident =</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="nottickedoff">do d_tp &lt;- translateDescTypeFun sc env ctx $ identOpenTerm d_ident</span>
<span class="lineno">  162 </span><span class="spaces">     </span><span class="nottickedoff">tp &lt;- scGlobalDef sc tp_ident</span>
<span class="lineno">  163 </span><span class="spaces">     </span><span class="nottickedoff">ok &lt;- scConvertibleEval sc scTypeCheckWHNF True tp d_tp</span>
<span class="lineno">  164 </span><span class="spaces">     </span><span class="nottickedoff">if ok then return () else</span>
<span class="lineno">  165 </span><span class="spaces">       </span><span class="nottickedoff">do tp_norm &lt;- scTypeCheckWHNF sc tp</span>
<span class="lineno">  166 </span><span class="spaces">          </span><span class="nottickedoff">d_tp_norm &lt;- scTypeCheckWHNF sc d_tp</span>
<span class="lineno">  167 </span><span class="spaces">          </span><span class="nottickedoff">fail $ Text.unpack $</span>
<span class="lineno">  168 </span><span class="spaces">                </span><span class="nottickedoff">&quot;Type description for &quot; &lt;&gt; nm &lt;&gt;</span>
<span class="lineno">  169 </span><span class="spaces">                </span><span class="nottickedoff">&quot; does not match user-supplied type\n&quot; &lt;&gt;</span>
<span class="lineno">  170 </span><span class="spaces">                </span><span class="nottickedoff">&quot;Type for description:\n&quot; &lt;&gt;</span>
<span class="lineno">  171 </span><span class="spaces">                </span><span class="nottickedoff">Text.pack (Pretty.scPrettyTermInCtx PPS.defaultOpts [] d_tp_norm) &lt;&gt;</span>
<span class="lineno">  172 </span><span class="spaces">                </span><span class="nottickedoff">&quot;\n&quot; &lt;&gt;</span>
<span class="lineno">  173 </span><span class="spaces">                </span><span class="nottickedoff">&quot;User-supplied type:\n&quot; &lt;&gt;</span>
<span class="lineno">  174 </span><span class="spaces">                </span><span class="nottickedoff">Text.pack (Pretty.scPrettyTermInCtx PPS.defaultOpts [] tp_norm)</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>-- | Extract out the contents of the 'Right' of an 'Either', calling 'fail' if
<span class="lineno">  177 </span>-- the 'Either' is a 'Left'. The supplied 'String' describes the action (in
<span class="lineno">  178 </span>-- &quot;ing&quot; form, as in, &quot;parsing&quot;) that was performed to create this 'Either'.
<span class="lineno">  179 </span>-- failOnLeft :: (MonadFail m, Show err) =&gt; String -&gt; Either err a -&gt; m a
<span class="lineno">  180 </span>-- failOnLeft action (Left err) = Fail.fail (&quot;Error&quot; ++ action ++ &quot;: &quot; ++ show err)
<span class="lineno">  181 </span>-- failOnLeft _ (Right a) = return a
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>-- | Extract out the contents of the 'Just' of a 'Maybe' wrapped in a
<span class="lineno">  184 </span>-- `MonadFail`, calling 'fail' on the given string if the `Maybe` is a
<span class="lineno">  185 </span>-- `Nothing`.
<span class="lineno">  186 </span>failOnNothing :: Fail.MonadFail m =&gt; Text -&gt; Maybe a -&gt; m a
<span class="lineno">  187 </span><span class="decl"><span class="nottickedoff">failOnNothing err_str Nothing = Fail.fail $ Text.unpack err_str</span>
<span class="lineno">  188 </span><span class="spaces"></span><span class="nottickedoff">failOnNothing _ (Just a) = return a</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | Extract the bit width of an architecture
<span class="lineno">  191 </span>archReprWidth :: ArchRepr arch -&gt; NatRepr (ArchWidth arch)
<span class="lineno">  192 </span><span class="decl"><span class="nottickedoff">archReprWidth (X86Repr w) = w</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>-- | Get the architecture of an LLVM module
<span class="lineno">  195 </span>llvmModuleArchRepr :: LLVMModule arch -&gt; ArchRepr arch
<span class="lineno">  196 </span><span class="decl"><span class="nottickedoff">llvmModuleArchRepr lm = llvmArch $ view transContext $ modTrans lm</span></span>
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>-- | Get the bit width of the architecture of an LLVM module
<span class="lineno">  199 </span>llvmModuleArchReprWidth :: LLVMModule arch -&gt; NatRepr (ArchWidth arch)
<span class="lineno">  200 </span><span class="decl"><span class="nottickedoff">llvmModuleArchReprWidth = archReprWidth . llvmModuleArchRepr</span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>-- | Get the 'TypeContext' of an LLVM module
<span class="lineno">  203 </span>llvmModuleTypeContext :: LLVMModule arch -&gt; TypeContext
<span class="lineno">  204 </span><span class="decl"><span class="nottickedoff">llvmModuleTypeContext lm = modTrans lm ^. transContext . llvmTypeCtx</span></span>
<span class="lineno">  205 </span>
<span class="lineno">  206 </span>-- | Look up the 'L.Declare' for an external symbol in an 'LLVMModule'
<span class="lineno">  207 </span>lookupFunctionDecl :: LLVMModule arch -&gt; Text -&gt; Maybe L.Declare
<span class="lineno">  208 </span><span class="decl"><span class="nottickedoff">lookupFunctionDecl lm nm =</span>
<span class="lineno">  209 </span><span class="spaces">  </span><span class="nottickedoff">find (((fromString $ Text.unpack nm) ==) . L.decName) $ L.modDeclares $ modAST lm</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | Look up the 'L.Define' for a symbol defined in an 'LLVMModule'
<span class="lineno">  212 </span>lookupFunctionDef :: LLVMModule arch -&gt; Text -&gt; Maybe L.Define
<span class="lineno">  213 </span><span class="decl"><span class="nottickedoff">lookupFunctionDef lm nm =</span>
<span class="lineno">  214 </span><span class="spaces">  </span><span class="nottickedoff">find (((fromString $ Text.unpack nm) ==) . L.defName) $ L.modDefines $ modAST lm</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>-- | Lookup a the singnature for a symbol in an 'LLVMModule'. This
<span class="lineno">  217 </span>--   will find a signaure for either an external symbol, or for
<span class="lineno">  218 </span>--   a defined symbol
<span class="lineno">  219 </span>lookupFunctionDeclOrDef :: LLVMModule arch -&gt; Text -&gt; Maybe L.Declare
<span class="lineno">  220 </span><span class="decl"><span class="nottickedoff">lookupFunctionDeclOrDef lm nm =</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="nottickedoff">lookupFunctionDecl lm nm &lt;|&gt; (declareFromDefine &lt;$&gt; lookupFunctionDef lm nm)</span></span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>-- | Look up the Crucible CFG for a defined symbol in an 'LLVMModule'
<span class="lineno">  224 </span>lookupFunctionCFG :: LLVMModule arch -&gt; Text -&gt; IO (Maybe (AnyCFG Lang.Crucible.LLVM.Extension.LLVM))
<span class="lineno">  225 </span><span class="decl"><span class="nottickedoff">lookupFunctionCFG lm nm =</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="nottickedoff">getTranslatedCFG (modTrans lm) (fromString $ Text.unpack nm) &gt;&gt;= \case</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="nottickedoff">Just (_,cfg,_warns) -&gt; return (Just cfg)</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>-- | Look up the argument and return types of a named function
<span class="lineno">  231 </span>lookupFunctionType :: LLVMModule arch -&gt; Text -&gt;
<span class="lineno">  232 </span>                      TopLevel (Some CtxRepr, Some TypeRepr)
<span class="lineno">  233 </span><span class="decl"><span class="nottickedoff">lookupFunctionType (lm :: LLVMModule arch) nm =</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="nottickedoff">case lookupFunctionDeclOrDef lm nm of</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="nottickedoff">Just decl -&gt;</span>
<span class="lineno">  236 </span><span class="spaces">      </span><span class="nottickedoff">do let w = llvmModuleArchReprWidth lm</span>
<span class="lineno">  237 </span><span class="spaces">         </span><span class="nottickedoff">leq1_proof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno">  238 </span><span class="spaces">           </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno">  239 </span><span class="spaces">           </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno">  240 </span><span class="spaces">         </span><span class="nottickedoff">leq16_proof &lt;- case decideLeq (knownNat @16) w of</span>
<span class="lineno">  241 </span><span class="spaces">           </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno">  242 </span><span class="spaces">           </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is too small!&quot;</span>
<span class="lineno">  243 </span><span class="spaces">         </span><span class="nottickedoff">let ?ptrWidth = w</span>
<span class="lineno">  244 </span><span class="spaces">         </span><span class="nottickedoff">let ?lc = llvmModuleTypeContext lm</span>
<span class="lineno">  245 </span><span class="spaces">         </span><span class="nottickedoff">withLeqProof leq1_proof $ withLeqProof leq16_proof $</span>
<span class="lineno">  246 </span><span class="spaces">           </span><span class="nottickedoff">llvmDeclToFunHandleRepr' @(ArchWidth arch) decl $ \args ret -&gt;</span>
<span class="lineno">  247 </span><span class="spaces">           </span><span class="nottickedoff">return (Some args, Some ret)</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  249 </span><span class="spaces">      </span><span class="nottickedoff">fail $ Text.unpack $ &quot;Could not find symbol: &quot; &lt;&gt; nm</span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-- | Look for the LLVM module in a 'HeapsterEnv' where a symbol is defined
<span class="lineno">  252 </span>lookupModDefiningSym :: HeapsterEnv -&gt; Text -&gt; Maybe (Some LLVMModule)
<span class="lineno">  253 </span><span class="decl"><span class="nottickedoff">lookupModDefiningSym env nm =</span>
<span class="lineno">  254 </span><span class="spaces">  </span><span class="nottickedoff">find (\(Some lm) -&gt; isJust (lookupFunctionDef lm nm)) $</span>
<span class="lineno">  255 </span><span class="spaces">  </span><span class="nottickedoff">heapsterEnvLLVMModules env</span></span>
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>-- | Look for any LLVM module in a 'HeapsterEnv' containing a symbol
<span class="lineno">  258 </span>lookupModContainingSym :: HeapsterEnv -&gt; Text -&gt; Maybe (Some LLVMModule)
<span class="lineno">  259 </span><span class="decl"><span class="nottickedoff">lookupModContainingSym env nm =</span>
<span class="lineno">  260 </span><span class="spaces">  </span><span class="nottickedoff">find (\(Some lm) -&gt; isJust (lookupFunctionDeclOrDef lm nm)) $</span>
<span class="lineno">  261 </span><span class="spaces">  </span><span class="nottickedoff">heapsterEnvLLVMModules env</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>-- | An LLVM module plus a CFG for a specific function in that module
<span class="lineno">  264 </span>data ModuleAndCFG arch =
<span class="lineno">  265 </span>  ModuleAndCFG (LLVMModule arch) (AnyCFG Lang.Crucible.LLVM.Extension.LLVM)
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>-- | Look up the LLVM module and associated CFG for a symobl
<span class="lineno">  268 </span>lookupLLVMSymbolModAndCFG :: HeapsterEnv -&gt; Text -&gt; IO (Maybe (Some ModuleAndCFG))
<span class="lineno">  269 </span><span class="decl"><span class="nottickedoff">lookupLLVMSymbolModAndCFG henv nm =</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="nottickedoff">case lookupModDefiningSym henv nm of</span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="nottickedoff">Just (Some lm) -&gt;</span>
<span class="lineno">  272 </span><span class="spaces">      </span><span class="nottickedoff">do res &lt;- lookupFunctionCFG lm nm</span>
<span class="lineno">  273 </span><span class="spaces">         </span><span class="nottickedoff">return ((Some . ModuleAndCFG lm) &lt;$&gt; res)</span>
<span class="lineno">  274 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; return Nothing</span></span>
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>heapster_default_env :: PermEnv
<span class="lineno">  277 </span><span class="decl"><span class="nottickedoff">heapster_default_env = emptyPermEnv</span></span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>-- | Based on the function of the same name in SAWCore.ParserUtils.
<span class="lineno">  280 </span>-- Unlike that function, this calls 'fail' instead of 'error'.
<span class="lineno">  281 </span>--
<span class="lineno">  282 </span>-- XXX: we only need one; unify these once the error handling gets fixed.
<span class="lineno">  283 </span>readModuleFromFile :: FilePath -&gt; TopLevel (Un.Module, ModuleName)
<span class="lineno">  284 </span><span class="decl"><span class="istickedoff">readModuleFromFile path = do</span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="istickedoff">base &lt;- liftIO getCurrentDirectory</span>
<span class="lineno">  286 </span><span class="spaces">  </span><span class="istickedoff">txt &lt;- liftIO $ TLIO.readFile path</span>
<span class="lineno">  287 </span><span class="spaces">  </span><span class="istickedoff">case Un.parseSAW base path txt of</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">Right m@(Un.Module (Un.PosPair _ mnm) _ _) -&gt; pure (m, <span class="nottickedoff">mnm</span>)</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt; fail $ &quot;Module parsing failed:\n&quot; ++ show err</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>-- | Parse the second given string as a term, the first given string being
<span class="lineno">  292 </span>-- used as the path for error reporting
<span class="lineno">  293 </span>--
<span class="lineno">  294 </span>-- XXX: this should be moved to saw-core once we have unified error
<span class="lineno">  295 </span>-- handling that'll allow it to not need to explicitly live in
<span class="lineno">  296 </span>-- TopLevel.
<span class="lineno">  297 </span>parseTermFromString :: String -&gt; String -&gt; TopLevel Un.UTerm
<span class="lineno">  298 </span><span class="decl"><span class="nottickedoff">parseTermFromString nm term_string = do</span>
<span class="lineno">  299 </span><span class="spaces">  </span><span class="nottickedoff">let base = &quot;&quot;</span>
<span class="lineno">  300 </span><span class="spaces">      </span><span class="nottickedoff">path = &quot;&lt;&quot; ++ nm ++ &quot;&gt;&quot;</span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="nottickedoff">case Un.parseSAWTerm base path (TL.pack term_string) of</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="nottickedoff">Right term -&gt; pure term</span>
<span class="lineno">  303 </span><span class="spaces">    </span><span class="nottickedoff">Left err -&gt; fail $ &quot;Term parsing failed:\n&quot; ++ show err</span></span>
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>-- | Find an unused identifier in a 'Module' by starting with a particular
<span class="lineno">  306 </span>-- 'String' and appending a number if necessary
<span class="lineno">  307 </span>findUnusedIdent :: Module -&gt; String -&gt; Ident
<span class="lineno">  308 </span><span class="decl"><span class="nottickedoff">findUnusedIdent m str =</span>
<span class="lineno">  309 </span><span class="spaces">  </span><span class="nottickedoff">fromJust $ find (isNothing . Mod.resolveName m . identBaseName) $</span>
<span class="lineno">  310 </span><span class="spaces">  </span><span class="nottickedoff">map (mkSafeIdent (moduleName m)) $</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="nottickedoff">(str : map ((str ++) . show) [(0::Int) ..])</span></span>
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>-- | Insert a SAW core definition into the SAW core module associated with a
<span class="lineno">  314 </span>-- 'HeapsterEnv', printing out the definition if the debug level is at least 2
<span class="lineno">  315 </span>heapsterInsertDef :: HeapsterEnv -&gt; Ident -&gt; Term -&gt; Term -&gt; TopLevel ()
<span class="lineno">  316 </span><span class="decl"><span class="nottickedoff">heapsterInsertDef henv trm_ident trm_tp trm =</span>
<span class="lineno">  317 </span><span class="spaces">  </span><span class="nottickedoff">do debugPrettyTermWithPrefix henv verboseDebugLevel</span>
<span class="lineno">  318 </span><span class="spaces">       </span><span class="nottickedoff">(&quot;Inserting def &quot; ++ show trm_ident ++ &quot; =\n&quot;) trm</span>
<span class="lineno">  319 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  320 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ scInsertDef sc trm_ident trm_tp trm</span></span>
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>-- | Parse the second given string as a term, check that it has the given type,
<span class="lineno">  323 </span>-- and, if the parsed term is not already an identifier, add it as a definition
<span class="lineno">  324 </span>-- in the current module using the first given string. If that first string is
<span class="lineno">  325 </span>-- already used, find another name for the definition. Return either the
<span class="lineno">  326 </span>-- identifer of the new definition or the identifier that was parsed.
<span class="lineno">  327 </span>parseAndInsDef :: HeapsterEnv -&gt; String -&gt; Term -&gt; String -&gt; TopLevel Ident
<span class="lineno">  328 </span><span class="decl"><span class="nottickedoff">parseAndInsDef henv nm term_tp term_string =</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  330 </span><span class="spaces">     </span><span class="nottickedoff">un_term &lt;- parseTermFromString nm term_string</span>
<span class="lineno">  331 </span><span class="spaces">     </span><span class="nottickedoff">let mnm = heapsterEnvSAWModule henv</span>
<span class="lineno">  332 </span><span class="spaces">     </span><span class="nottickedoff">typed_term &lt;- liftIO $ scTypeCheckCompleteError sc (Just mnm) un_term</span>
<span class="lineno">  333 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ scCheckSubtype sc (Just mnm) typed_term term_tp</span>
<span class="lineno">  334 </span><span class="spaces">     </span><span class="nottickedoff">case typedVal typed_term of</span>
<span class="lineno">  335 </span><span class="spaces">       </span><span class="nottickedoff">STApp {stAppTermF = Constant (Name _ (ModuleIdentifier term_ident))} -&gt;</span>
<span class="lineno">  336 </span><span class="spaces">         </span><span class="nottickedoff">return term_ident</span>
<span class="lineno">  337 </span><span class="spaces">       </span><span class="nottickedoff">term -&gt; do</span>
<span class="lineno">  338 </span><span class="spaces">         </span><span class="nottickedoff">m &lt;- liftIO $ scFindModule sc mnm</span>
<span class="lineno">  339 </span><span class="spaces">         </span><span class="nottickedoff">let term_ident = findUnusedIdent m nm</span>
<span class="lineno">  340 </span><span class="spaces">         </span><span class="nottickedoff">heapsterInsertDef henv term_ident term_tp term</span>
<span class="lineno">  341 </span><span class="spaces">         </span><span class="nottickedoff">return term_ident</span></span>
<span class="lineno">  342 </span>
<span class="lineno">  343 </span>-- | Build a 'HeapsterEnv' associated with the given SAW core module and the
<span class="lineno">  344 </span>-- given 'LLVMModule's. Add any globals in the 'LLVMModule's to the returned
<span class="lineno">  345 </span>-- 'HeapsterEnv'.
<span class="lineno">  346 </span>mkHeapsterEnv :: DebugLevel -&gt; ModuleName -&gt; [Some LLVMModule] -&gt;
<span class="lineno">  347 </span>                 TopLevel HeapsterEnv
<span class="lineno">  348 </span><span class="decl"><span class="nottickedoff">mkHeapsterEnv dlevel saw_mod_name llvm_mods@(Some first_mod:_) =</span>
<span class="lineno">  349 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  350 </span><span class="spaces">     </span><span class="nottickedoff">let w = llvmModuleArchReprWidth first_mod</span>
<span class="lineno">  351 </span><span class="spaces">     </span><span class="nottickedoff">let endianness =</span>
<span class="lineno">  352 </span><span class="spaces">           </span><span class="nottickedoff">llvmDataLayout (modTrans first_mod ^. transContext ^. llvmTypeCtx)</span>
<span class="lineno">  353 </span><span class="spaces">           </span><span class="nottickedoff">^. intLayout</span>
<span class="lineno">  354 </span><span class="spaces">     </span><span class="nottickedoff">leq_proof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno">  355 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno">  356 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno">  357 </span><span class="spaces">     </span><span class="nottickedoff">let globals = concatMap (\(Some lm) -&gt; L.modGlobals $ modAST lm) llvm_mods</span>
<span class="lineno">  358 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;-</span>
<span class="lineno">  359 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ withKnownNat w $ withLeqProof leq_proof $</span>
<span class="lineno">  360 </span><span class="spaces">       </span><span class="nottickedoff">foldM (permEnvAddGlobalConst sc saw_mod_name dlevel endianness w)</span>
<span class="lineno">  361 </span><span class="spaces">       </span><span class="nottickedoff">heapster_default_env globals</span>
<span class="lineno">  362 </span><span class="spaces">     </span><span class="nottickedoff">env_ref &lt;- liftIO $ newIORef env</span>
<span class="lineno">  363 </span><span class="spaces">     </span><span class="nottickedoff">dlevel_ref &lt;- liftIO $ newIORef dlevel</span>
<span class="lineno">  364 </span><span class="spaces">     </span><span class="nottickedoff">checks_ref &lt;- liftIO $ newIORef doChecks</span>
<span class="lineno">  365 </span><span class="spaces">     </span><span class="nottickedoff">tcfg_ref &lt;- liftIO $ newIORef []</span>
<span class="lineno">  366 </span><span class="spaces">     </span><span class="nottickedoff">return $ HeapsterEnv {</span>
<span class="lineno">  367 </span><span class="spaces">       </span><span class="nottickedoff">heapsterEnvSAWModule = saw_mod_name,</span>
<span class="lineno">  368 </span><span class="spaces">       </span><span class="nottickedoff">heapsterEnvPermEnvRef = env_ref,</span>
<span class="lineno">  369 </span><span class="spaces">       </span><span class="nottickedoff">heapsterEnvLLVMModules = llvm_mods,</span>
<span class="lineno">  370 </span><span class="spaces">       </span><span class="nottickedoff">heapsterEnvDebugLevel = dlevel_ref,</span>
<span class="lineno">  371 </span><span class="spaces">       </span><span class="nottickedoff">heapsterEnvChecksFlag = checks_ref,</span>
<span class="lineno">  372 </span><span class="spaces">       </span><span class="nottickedoff">heapsterEnvTCFGs = tcfg_ref</span>
<span class="lineno">  373 </span><span class="spaces">       </span><span class="nottickedoff">}</span>
<span class="lineno">  374 </span><span class="spaces"></span><span class="nottickedoff">mkHeapsterEnv _ _ [] = fail &quot;mkHeapsterEnv: empty list of LLVM modules!&quot;</span></span>
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>heapster_init_env :: Text -&gt; FilePath -&gt; TopLevel HeapsterEnv
<span class="lineno">  378 </span><span class="decl"><span class="nottickedoff">heapster_init_env mod_str llvm_filename =</span>
<span class="lineno">  379 </span><span class="spaces">  </span><span class="nottickedoff">heapster_init_env_gen noDebugLevel mod_str llvm_filename</span></span>
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>heapster_init_env_debug :: Text -&gt; FilePath -&gt; TopLevel HeapsterEnv
<span class="lineno">  382 </span><span class="decl"><span class="nottickedoff">heapster_init_env_debug mod_str llvm_filename =</span>
<span class="lineno">  383 </span><span class="spaces">  </span><span class="nottickedoff">heapster_init_env_gen traceDebugLevel mod_str llvm_filename</span></span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>heapster_init_env_gen :: DebugLevel -&gt; Text -&gt; FilePath -&gt; TopLevel HeapsterEnv
<span class="lineno">  386 </span><span class="decl"><span class="nottickedoff">heapster_init_env_gen dlevel mod_str llvm_filename =</span>
<span class="lineno">  387 </span><span class="spaces">  </span><span class="nottickedoff">do llvm_mod &lt;- llvm_load_module llvm_filename</span>
<span class="lineno">  388 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  389 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ ensureCryptolMLoaded sc</span>
<span class="lineno">  390 </span><span class="spaces">     </span><span class="nottickedoff">let saw_mod_name = mkModuleName [mod_str]</span>
<span class="lineno">  391 </span><span class="spaces">     </span><span class="nottickedoff">mod_loaded &lt;- liftIO $ scModuleIsLoaded sc saw_mod_name</span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="nottickedoff">if mod_loaded then</span>
<span class="lineno">  393 </span><span class="spaces">       </span><span class="nottickedoff">fail (&quot;SAW module with name &quot; ++ show mod_str ++ &quot; already defined!&quot;)</span>
<span class="lineno">  394 </span><span class="spaces">       </span><span class="nottickedoff">else return ()</span>
<span class="lineno">  395 </span><span class="spaces">     </span><span class="nottickedoff">-- import SpecM by default</span>
<span class="lineno">  396 </span><span class="spaces">     </span><span class="nottickedoff">let specMModuleName = mkModuleName [&quot;SpecM&quot;]</span>
<span class="lineno">  397 </span><span class="spaces">     </span><span class="nottickedoff">preludeMod &lt;- liftIO $ scFindModule sc specMModuleName</span>
<span class="lineno">  398 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ scLoadModule sc (insImport (const True) preludeMod $</span>
<span class="lineno">  399 </span><span class="spaces">                                 </span><span class="nottickedoff">emptyModule saw_mod_name)</span>
<span class="lineno">  400 </span><span class="spaces">     </span><span class="nottickedoff">mkHeapsterEnv dlevel saw_mod_name [llvm_mod]</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>load_sawcore_from_file :: FilePath -&gt; TopLevel ()
<span class="lineno">  403 </span><span class="decl"><span class="istickedoff">load_sawcore_from_file mod_filename =</span>
<span class="lineno">  404 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  405 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ ensureCryptolMLoaded sc</span>
<span class="lineno">  406 </span><span class="spaces">     </span><span class="istickedoff">(saw_mod, _) &lt;- readModuleFromFile mod_filename</span>
<span class="lineno">  407 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ tcInsertModule sc saw_mod</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>heapster_init_env_from_file :: FilePath -&gt; FilePath -&gt; TopLevel HeapsterEnv
<span class="lineno">  410 </span><span class="decl"><span class="nottickedoff">heapster_init_env_from_file mod_filename llvm_filename =</span>
<span class="lineno">  411 </span><span class="spaces">  </span><span class="nottickedoff">heapster_init_env_for_files_gen noDebugLevel mod_filename [llvm_filename]</span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>heapster_init_env_from_file_debug :: FilePath -&gt; FilePath -&gt; TopLevel HeapsterEnv
<span class="lineno">  414 </span><span class="decl"><span class="nottickedoff">heapster_init_env_from_file_debug mod_filename llvm_filename =</span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="nottickedoff">heapster_init_env_for_files_gen traceDebugLevel mod_filename [llvm_filename]</span></span>
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>heapster_init_env_for_files_gen :: DebugLevel -&gt;
<span class="lineno">  418 </span>                                   FilePath -&gt; [FilePath] -&gt;
<span class="lineno">  419 </span>                                   TopLevel HeapsterEnv
<span class="lineno">  420 </span><span class="decl"><span class="nottickedoff">heapster_init_env_for_files_gen dlevel mod_filename llvm_filenames =</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">do llvm_mods &lt;- mapM llvm_load_module llvm_filenames</span>
<span class="lineno">  422 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  423 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ ensureCryptolMLoaded sc</span>
<span class="lineno">  424 </span><span class="spaces">     </span><span class="nottickedoff">(saw_mod, saw_mod_name) &lt;- readModuleFromFile mod_filename</span>
<span class="lineno">  425 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ tcInsertModule sc saw_mod</span>
<span class="lineno">  426 </span><span class="spaces">     </span><span class="nottickedoff">mkHeapsterEnv dlevel saw_mod_name llvm_mods</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>heapster_init_env_for_files :: FilePath -&gt; [FilePath] -&gt; TopLevel HeapsterEnv
<span class="lineno">  429 </span><span class="decl"><span class="nottickedoff">heapster_init_env_for_files mod_filename llvm_filenames =</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="nottickedoff">heapster_init_env_for_files_gen noDebugLevel mod_filename llvm_filenames</span></span>
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>heapster_init_env_for_files_debug :: FilePath -&gt; [FilePath] -&gt; TopLevel HeapsterEnv
<span class="lineno">  433 </span><span class="decl"><span class="nottickedoff">heapster_init_env_for_files_debug mod_filename llvm_filenames =</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="nottickedoff">heapster_init_env_for_files_gen traceDebugLevel mod_filename llvm_filenames</span></span>
<span class="lineno">  435 </span>
<span class="lineno">  436 </span>-- | Look up the CFG associated with a symbol name in a Heapster environment
<span class="lineno">  437 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  438 </span>heapster_get_cfg :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  439 </span>                    Text -&gt; TopLevel SAW_CFG
<span class="lineno">  440 </span><span class="decl"><span class="nottickedoff">heapster_get_cfg _ _ henv nm =</span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="nottickedoff">case lookupModDefiningSym henv nm of</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="nottickedoff">Just (Some lm) -&gt; llvm_cfg (Some lm) nm</span>
<span class="lineno">  443 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail $ Text.unpack $ &quot;Could not find CFG for symbol: &quot; &lt;&gt; nm</span></span>
<span class="lineno">  444 </span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>-- | Define a new opaque named permission with the given name, arguments, and
<span class="lineno">  447 </span>-- Crucible type that translates to the given SAW core type with the supplied
<span class="lineno">  448 </span>-- type description
<span class="lineno">  449 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  450 </span>heapster_define_opaque_perm :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  451 </span>                               Text -&gt; Text -&gt; Text -&gt; Text -&gt;
<span class="lineno">  452 </span>                               Text -&gt; TopLevel ()
<span class="lineno">  453 </span><span class="decl"><span class="nottickedoff">heapster_define_opaque_perm _bic _opts henv nm args_str tp_str term_str d_str =</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  455 </span><span class="spaces">     </span><span class="nottickedoff">Some args &lt;- parseCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  456 </span><span class="spaces">     </span><span class="nottickedoff">Some tp_perm &lt;- parseTypeString &quot;permission type&quot; env (Text.unpack tp_str)</span>
<span class="lineno">  457 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  458 </span><span class="spaces">     </span><span class="nottickedoff">term_tp &lt;- liftIO $ translateExprTypeFunType sc env args</span>
<span class="lineno">  459 </span><span class="spaces">     </span><span class="nottickedoff">term_ident &lt;- parseAndInsDef henv (Text.unpack nm) term_tp (Text.unpack term_str)</span>
<span class="lineno">  460 </span><span class="spaces">     </span><span class="nottickedoff">d_tp &lt;- tpDescTypeM sc</span>
<span class="lineno">  461 </span><span class="spaces">     </span><span class="nottickedoff">d_ident &lt;- parseAndInsDef henv (Text.unpack nm ++ &quot;__desc&quot;) d_tp (Text.unpack d_str)</span>
<span class="lineno">  462 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ checkTypeAgreesWithDesc sc env nm term_ident args d_ident</span>
<span class="lineno">  463 </span><span class="spaces">     </span><span class="nottickedoff">let env' = permEnvAddOpaquePerm env (Text.unpack nm) args tp_perm term_ident d_ident</span>
<span class="lineno">  464 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>-- | Define a new recursive named permission with the given name, arguments,
<span class="lineno">  468 </span>-- type, and permission that it unfolds to
<span class="lineno">  469 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  470 </span>heapster_define_recursive_perm :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  471 </span>                                  Text -&gt; Text -&gt; Text -&gt; Text -&gt;
<span class="lineno">  472 </span>                                  TopLevel ()
<span class="lineno">  473 </span><span class="decl"><span class="nottickedoff">heapster_define_recursive_perm _bic _opts henv nm args_str tp_str p_str =</span>
<span class="lineno">  474 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  475 </span><span class="spaces">     </span><span class="nottickedoff">let mnm = heapsterEnvSAWModule henv</span>
<span class="lineno">  476 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  477 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  478 </span><span class="spaces">     </span><span class="nottickedoff">-- Parse the arguments, the type, and the body</span>
<span class="lineno">  479 </span><span class="spaces">     </span><span class="nottickedoff">Some args_ctx &lt;- parseParsedCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  480 </span><span class="spaces">     </span><span class="nottickedoff">Some tp &lt;- parseTypeString &quot;permission type&quot; env (Text.unpack tp_str)</span>
<span class="lineno">  481 </span><span class="spaces">     </span><span class="nottickedoff">let args = parsedCtxCtx args_ctx</span>
<span class="lineno">  482 </span><span class="spaces">         </span><span class="nottickedoff">args_p = CruCtxCons args (ValuePermRepr tp)</span>
<span class="lineno">  483 </span><span class="spaces">     </span><span class="nottickedoff">mb_p &lt;- parsePermInCtxString &quot;permission&quot; env</span>
<span class="lineno">  484 </span><span class="spaces">       </span><span class="nottickedoff">(consParsedCtx (Text.unpack nm) (ValuePermRepr tp) args_ctx) tp (Text.unpack p_str)</span>
<span class="lineno">  485 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  486 </span><span class="spaces">     </span><span class="nottickedoff">-- Generate the type description for the body of the recursive perm</span>
<span class="lineno">  487 </span><span class="spaces">     </span><span class="nottickedoff">d_tp &lt;- tpDescTypeM sc</span>
<span class="lineno">  488 </span><span class="spaces">     </span><span class="nottickedoff">let d_ident = mkSafeIdent mnm (Text.unpack nm ++ &quot;__desc&quot;)</span>
<span class="lineno">  489 </span><span class="spaces">     </span><span class="nottickedoff">d_trm &lt;- liftIO $ translateCompleteDescInCtx sc env args_p mb_p</span>
<span class="lineno">  490 </span><span class="spaces">     </span><span class="nottickedoff">heapsterInsertDef henv d_ident d_tp d_trm</span>
<span class="lineno">  491 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  492 </span><span class="spaces">     </span><span class="nottickedoff">-- Generate the function \args -&gt; tpElemEnv args (Ind d) from the</span>
<span class="lineno">  493 </span><span class="spaces">     </span><span class="nottickedoff">-- arguments to the type of the translation of the permission as the term</span>
<span class="lineno">  494 </span><span class="spaces">     </span><span class="nottickedoff">let transf_ident = mkSafeIdent mnm (Text.unpack nm)</span>
<span class="lineno">  495 </span><span class="spaces">     </span><span class="nottickedoff">transf_tp &lt;- liftIO $ translateExprTypeFunType sc env args</span>
<span class="lineno">  496 </span><span class="spaces">     </span><span class="nottickedoff">transf_trm &lt;-</span>
<span class="lineno">  497 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ translateIndTypeFun sc env args (globalOpenTerm d_ident)</span>
<span class="lineno">  498 </span><span class="spaces">     </span><span class="nottickedoff">heapsterInsertDef henv transf_ident transf_tp transf_trm</span>
<span class="lineno">  499 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  500 </span><span class="spaces">     </span><span class="nottickedoff">-- Add the recursive perm to the environment and update henv</span>
<span class="lineno">  501 </span><span class="spaces">     </span><span class="nottickedoff">env' &lt;-</span>
<span class="lineno">  502 </span><span class="spaces">       </span><span class="nottickedoff">permEnvAddRecPermM env (Text.unpack nm) args tp transf_ident d_ident mb_p</span>
<span class="lineno">  503 </span><span class="spaces">       </span><span class="nottickedoff">NameNonReachConstr</span>
<span class="lineno">  504 </span><span class="spaces">       </span><span class="nottickedoff">(\_ _ -&gt; return NoReachMethods)</span>
<span class="lineno">  505 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>-- | Define a new recursive named permission with the given name, arguments,
<span class="lineno">  509 </span>-- type, and permission that it unfolds to, that forms a reachability
<span class="lineno">  510 </span>-- permission, meaning it has the form
<span class="lineno">  511 </span>--
<span class="lineno">  512 </span>-- &gt; P&lt;args,x&gt; := eq(x) or q
<span class="lineno">  513 </span>--
<span class="lineno">  514 </span>-- where the name @P@ occurs exactly once and @x@ occurs not at all in
<span class="lineno">  515 </span>-- permission @q@. The last input should define a transitivity method as
<span class="lineno">  516 </span>-- described in the documentation for the 'ReachMethods' type.
<span class="lineno">  517 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  518 </span>heapster_define_reachability_perm :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  519 </span>                                     Text -&gt; Text -&gt; Text -&gt; Text -&gt;
<span class="lineno">  520 </span>                                     Text -&gt; TopLevel ()
<span class="lineno">  521 </span><span class="decl"><span class="nottickedoff">heapster_define_reachability_perm _bic _opts henv nm args_str tp_str p_str trans_fun_str =</span>
<span class="lineno">  522 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  523 </span><span class="spaces">     </span><span class="nottickedoff">let mnm = heapsterEnvSAWModule henv</span>
<span class="lineno">  524 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  525 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  526 </span><span class="spaces">     </span><span class="nottickedoff">-- Parse the arguments, the type, and the translation type</span>
<span class="lineno">  527 </span><span class="spaces">     </span><span class="nottickedoff">Some (tp :: TypeRepr tp) &lt;- parseTypeString &quot;permission type&quot; env (Text.unpack tp_str)</span>
<span class="lineno">  528 </span><span class="spaces">     </span><span class="nottickedoff">(Some pre_args_ctx,</span>
<span class="lineno">  529 </span><span class="spaces">      </span><span class="nottickedoff">last_args_ctx :: ParsedCtx (RNil :&gt; tp)) &lt;-</span>
<span class="lineno">  530 </span><span class="spaces">       </span><span class="nottickedoff">do some_args_ctx &lt;- parseParsedCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  531 </span><span class="spaces">          </span><span class="nottickedoff">case some_args_ctx of</span>
<span class="lineno">  532 </span><span class="spaces">            </span><span class="nottickedoff">Some args_ctx</span>
<span class="lineno">  533 </span><span class="spaces">              </span><span class="nottickedoff">| CruCtxCons _ tp' &lt;- parsedCtxCtx args_ctx</span>
<span class="lineno">  534 </span><span class="spaces">              </span><span class="nottickedoff">, Just Refl &lt;- testEquality tp tp' -&gt;</span>
<span class="lineno">  535 </span><span class="spaces">                </span><span class="nottickedoff">return (Some (parsedCtxUncons args_ctx), parsedCtxLast args_ctx)</span>
<span class="lineno">  536 </span><span class="spaces">            </span><span class="nottickedoff">_ -&gt; Fail.fail &quot;Incorrect type for last argument of reachability perm&quot;</span>
<span class="lineno">  537 </span><span class="spaces">     </span><span class="nottickedoff">let args_ctx = appendParsedCtx pre_args_ctx last_args_ctx</span>
<span class="lineno">  538 </span><span class="spaces">     </span><span class="nottickedoff">let args = parsedCtxCtx args_ctx</span>
<span class="lineno">  539 </span><span class="spaces">         </span><span class="nottickedoff">args_p = CruCtxCons args (ValuePermRepr tp)</span>
<span class="lineno">  540 </span><span class="spaces">     </span><span class="nottickedoff">mb_p &lt;- parsePermInCtxString &quot;permission&quot; env</span>
<span class="lineno">  541 </span><span class="spaces">       </span><span class="nottickedoff">(consParsedCtx (Text.unpack nm) (ValuePermRepr tp) args_ctx) tp (Text.unpack p_str)</span>
<span class="lineno">  542 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  543 </span><span class="spaces">     </span><span class="nottickedoff">-- Generate the type description for the body of the recursive perm</span>
<span class="lineno">  544 </span><span class="spaces">     </span><span class="nottickedoff">d_tp &lt;- tpDescTypeM sc</span>
<span class="lineno">  545 </span><span class="spaces">     </span><span class="nottickedoff">let d_ident = mkSafeIdent mnm (Text.unpack nm ++ &quot;__desc&quot;)</span>
<span class="lineno">  546 </span><span class="spaces">     </span><span class="nottickedoff">d_trm &lt;- liftIO $ translateCompleteDescInCtx sc env args_p mb_p</span>
<span class="lineno">  547 </span><span class="spaces">     </span><span class="nottickedoff">heapsterInsertDef henv d_ident d_tp d_trm</span>
<span class="lineno">  548 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  549 </span><span class="spaces">     </span><span class="nottickedoff">-- Generate the function \args -&gt; tpElemEnv args (Ind d) from the</span>
<span class="lineno">  550 </span><span class="spaces">     </span><span class="nottickedoff">-- arguments to the type of the translation of the permission as the term</span>
<span class="lineno">  551 </span><span class="spaces">     </span><span class="nottickedoff">let transf_ident = mkSafeIdent mnm (Text.unpack nm)</span>
<span class="lineno">  552 </span><span class="spaces">     </span><span class="nottickedoff">transf_tp &lt;- liftIO $ translateExprTypeFunType sc env args</span>
<span class="lineno">  553 </span><span class="spaces">     </span><span class="nottickedoff">transf_trm &lt;-</span>
<span class="lineno">  554 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ translateIndTypeFun sc env args (globalOpenTerm d_ident)</span>
<span class="lineno">  555 </span><span class="spaces">     </span><span class="nottickedoff">heapsterInsertDef henv transf_ident transf_tp transf_trm</span>
<span class="lineno">  556 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  557 </span><span class="spaces">     </span><span class="nottickedoff">-- Add the recursive perm to the environment and update henv</span>
<span class="lineno">  558 </span><span class="spaces">     </span><span class="nottickedoff">env' &lt;-</span>
<span class="lineno">  559 </span><span class="spaces">       </span><span class="nottickedoff">permEnvAddRecPermM env (Text.unpack nm) args tp transf_ident d_ident mb_p</span>
<span class="lineno">  560 </span><span class="spaces">       </span><span class="nottickedoff">NameReachConstr</span>
<span class="lineno">  561 </span><span class="spaces">       </span><span class="nottickedoff">(\npn tmp_env -&gt;</span>
<span class="lineno">  562 </span><span class="spaces">           </span><span class="nottickedoff">-- Return the ReachMethods structure, which contains trans_ident.</span>
<span class="lineno">  563 </span><span class="spaces">           </span><span class="nottickedoff">-- Typecheck trans_ident with x:P&lt;args,y&gt;, y:P&lt;args,z&gt; -o x:P&lt;args,z&gt;</span>
<span class="lineno">  564 </span><span class="spaces">           </span><span class="nottickedoff">do trans_fun_tp &lt;-</span>
<span class="lineno">  565 </span><span class="spaces">                </span><span class="nottickedoff">liftIO $</span>
<span class="lineno">  566 </span><span class="spaces">                </span><span class="nottickedoff">translateCompletePureFunType sc tmp_env (CruCtxCons args tp)</span>
<span class="lineno">  567 </span><span class="spaces">                </span><span class="nottickedoff">(nus (cruCtxProxies args :&gt;: Proxy) $ \(ns :&gt;: y :&gt;: z) -&gt;</span>
<span class="lineno">  568 </span><span class="spaces">                  </span><span class="nottickedoff">MNil :&gt;:</span>
<span class="lineno">  569 </span><span class="spaces">                  </span><span class="nottickedoff">ValPerm_Named npn (namesToExprs (ns :&gt;: y)) NoPermOffset :&gt;:</span>
<span class="lineno">  570 </span><span class="spaces">                  </span><span class="nottickedoff">ValPerm_Named npn (namesToExprs (ns :&gt;: z)) NoPermOffset)</span>
<span class="lineno">  571 </span><span class="spaces">                </span><span class="nottickedoff">(nus (cruCtxProxies args :&gt;: Proxy) $ \(ns :&gt;: _ :&gt;: z) -&gt;</span>
<span class="lineno">  572 </span><span class="spaces">                  </span><span class="nottickedoff">ValPerm_Named npn (namesToExprs (ns :&gt;: z)) NoPermOffset)</span>
<span class="lineno">  573 </span><span class="spaces">              </span><span class="nottickedoff">trans_ident &lt;-</span>
<span class="lineno">  574 </span><span class="spaces">                </span><span class="nottickedoff">parseAndInsDef henv (&quot;trans_&quot; ++ Text.unpack nm) trans_fun_tp (Text.unpack trans_fun_str)</span>
<span class="lineno">  575 </span><span class="spaces">              </span><span class="nottickedoff">return (ReachMethods trans_ident))</span>
<span class="lineno">  576 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  577 </span>
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>-- | Helper function to add a recursive named shape to a 'PermEnv', adding all
<span class="lineno">  580 </span>-- the required identifiers to the given SAW core module
<span class="lineno">  581 </span>addRecNamedShape :: 1 &lt;= w =&gt; HeapsterEnv -&gt; String -&gt;
<span class="lineno">  582 </span>                    CruCtx args -&gt; NatRepr w -&gt;
<span class="lineno">  583 </span>                    Mb (args :&gt; LLVMShapeType w) (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno">  584 </span>                    TopLevel PermEnv
<span class="lineno">  585 </span><span class="decl"><span class="nottickedoff">addRecNamedShape henv nm args w mb_sh =</span>
<span class="lineno">  586 </span><span class="spaces">  </span><span class="nottickedoff">-- Generate the type description for the body of the recursive shape</span>
<span class="lineno">  587 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  588 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  589 </span><span class="spaces">     </span><span class="nottickedoff">let mnm = heapsterEnvSAWModule henv</span>
<span class="lineno">  590 </span><span class="spaces">     </span><span class="nottickedoff">d_tp &lt;- tpDescTypeM sc</span>
<span class="lineno">  591 </span><span class="spaces">     </span><span class="nottickedoff">let d_ident = mkSafeIdent mnm (nm ++ &quot;__desc&quot;)</span>
<span class="lineno">  592 </span><span class="spaces">         </span><span class="nottickedoff">args_p = CruCtxCons args (LLVMShapeRepr w)</span>
<span class="lineno">  593 </span><span class="spaces">     </span><span class="nottickedoff">d_trm &lt;- liftIO $ translateCompleteDescInCtx sc env args_p mb_sh</span>
<span class="lineno">  594 </span><span class="spaces">     </span><span class="nottickedoff">heapsterInsertDef henv d_ident d_tp d_trm</span>
<span class="lineno">  595 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  596 </span><span class="spaces">     </span><span class="nottickedoff">-- Generate the function \args -&gt; tpElemEnv args (Ind d) from the</span>
<span class="lineno">  597 </span><span class="spaces">     </span><span class="nottickedoff">-- arguments to the type of the translation of the permission as the term</span>
<span class="lineno">  598 </span><span class="spaces">     </span><span class="nottickedoff">let transf_ident = mkSafeIdent mnm nm</span>
<span class="lineno">  599 </span><span class="spaces">     </span><span class="nottickedoff">transf_tp &lt;- liftIO $ translateExprTypeFunType sc env args</span>
<span class="lineno">  600 </span><span class="spaces">     </span><span class="nottickedoff">transf_trm &lt;-</span>
<span class="lineno">  601 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ translateIndTypeFun sc env args (globalOpenTerm d_ident)</span>
<span class="lineno">  602 </span><span class="spaces">     </span><span class="nottickedoff">heapsterInsertDef henv transf_ident transf_tp transf_trm</span>
<span class="lineno">  603 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  604 </span><span class="spaces">     </span><span class="nottickedoff">-- Add the recursive shape to the environment and update henv</span>
<span class="lineno">  605 </span><span class="spaces">     </span><span class="nottickedoff">let nmsh = NamedShape nm args $ RecShapeBody mb_sh transf_ident d_ident</span>
<span class="lineno">  606 </span><span class="spaces">     </span><span class="nottickedoff">return $ withKnownNat w $ permEnvAddNamedShape env nmsh</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>
<span class="lineno">  609 </span>-- | Define a new recursive named permission with the given name, arguments,
<span class="lineno">  610 </span>-- type, and memory shape that it unfolds to
<span class="lineno">  611 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  612 </span>heapster_define_recursive_shape :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  613 </span>                                   Text -&gt; Int -&gt; Text -&gt; Text -&gt;
<span class="lineno">  614 </span>                                   TopLevel ()
<span class="lineno">  615 </span><span class="decl"><span class="nottickedoff">heapster_define_recursive_shape _bic _opts henv nm w_int args_str body_str =</span>
<span class="lineno">  616 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  617 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  618 </span><span class="spaces">     </span><span class="nottickedoff">-- Parse the bit width, arguments, and the body</span>
<span class="lineno">  619 </span><span class="spaces">     </span><span class="nottickedoff">SomeKnownNatGeq1 w &lt;-</span>
<span class="lineno">  620 </span><span class="spaces">       </span><span class="nottickedoff">failOnNothing &quot;Shape width must be positive&quot; $ someKnownNatGeq1 w_int</span>
<span class="lineno">  621 </span><span class="spaces">     </span><span class="nottickedoff">Some args_ctx &lt;- parseParsedCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  622 </span><span class="spaces">     </span><span class="nottickedoff">let args = parsedCtxCtx args_ctx</span>
<span class="lineno">  623 </span><span class="spaces">     </span><span class="nottickedoff">mb_sh &lt;- parseExprInCtxString env (LLVMShapeRepr w)</span>
<span class="lineno">  624 </span><span class="spaces">       </span><span class="nottickedoff">(consParsedCtx (Text.unpack nm) (LLVMShapeRepr w) args_ctx) (Text.unpack body_str)</span>
<span class="lineno">  625 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  626 </span><span class="spaces">     </span><span class="nottickedoff">-- Add the shape to the current environment</span>
<span class="lineno">  627 </span><span class="spaces">     </span><span class="nottickedoff">env' &lt;- addRecNamedShape henv (Text.unpack nm) args w mb_sh</span>
<span class="lineno">  628 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>
<span class="lineno">  631 </span>-- | Define a new named permission with the given name, arguments, and type
<span class="lineno">  632 </span>-- that is equivalent to the given permission.
<span class="lineno">  633 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  634 </span>heapster_define_perm :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  635 </span>                        Text -&gt; Text -&gt; Text -&gt; Text -&gt;
<span class="lineno">  636 </span>                        TopLevel ()
<span class="lineno">  637 </span><span class="decl"><span class="nottickedoff">heapster_define_perm _bic _opts henv nm args_str tp_str perm_string =</span>
<span class="lineno">  638 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  639 </span><span class="spaces">     </span><span class="nottickedoff">Some args_ctx &lt;- parseParsedCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  640 </span><span class="spaces">     </span><span class="nottickedoff">let args = parsedCtxCtx args_ctx</span>
<span class="lineno">  641 </span><span class="spaces">     </span><span class="nottickedoff">Some tp_perm &lt;- parseTypeString &quot;permission type&quot; env (Text.unpack tp_str)</span>
<span class="lineno">  642 </span><span class="spaces">     </span><span class="nottickedoff">perm &lt;- parsePermInCtxString &quot;permission body&quot; env</span>
<span class="lineno">  643 </span><span class="spaces">                                   </span><span class="nottickedoff">args_ctx tp_perm (Text.unpack perm_string)</span>
<span class="lineno">  644 </span><span class="spaces">     </span><span class="nottickedoff">let env' = permEnvAddDefinedPerm env (Text.unpack nm) args tp_perm perm</span>
<span class="lineno">  645 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  646 </span>
<span class="lineno">  647 </span>
<span class="lineno">  648 </span>-- | Define a new named llvm shape with the given name, pointer width,
<span class="lineno">  649 </span>-- arguments, and definition as a shape
<span class="lineno">  650 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  651 </span>heapster_define_llvmshape :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  652 </span>                             Text -&gt; Int -&gt; Text -&gt; Text -&gt;
<span class="lineno">  653 </span>                             TopLevel ()
<span class="lineno">  654 </span><span class="decl"><span class="nottickedoff">heapster_define_llvmshape _bic _opts henv nm w_int args_str sh_str =</span>
<span class="lineno">  655 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  656 </span><span class="spaces">     </span><span class="nottickedoff">(Some (Pair w LeqProof)) &lt;-</span>
<span class="lineno">  657 </span><span class="spaces">       </span><span class="nottickedoff">failOnNothing &quot;Shape width must be positive&quot; $ someNatGeq1 w_int</span>
<span class="lineno">  658 </span><span class="spaces">     </span><span class="nottickedoff">Some args_ctx &lt;- parseParsedCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  659 </span><span class="spaces">     </span><span class="nottickedoff">let args = parsedCtxCtx args_ctx</span>
<span class="lineno">  660 </span><span class="spaces">     </span><span class="nottickedoff">mb_sh &lt;- parseExprInCtxString env (LLVMShapeRepr w) args_ctx (Text.unpack sh_str)</span>
<span class="lineno">  661 </span><span class="spaces">     </span><span class="nottickedoff">let env' = withKnownNat w $ permEnvAddDefinedShape env (Text.unpack nm) args mb_sh</span>
<span class="lineno">  662 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  663 </span>
<span class="lineno">  664 </span>
<span class="lineno">  665 </span>-- | Define a new opaque llvm shape with the given name, pointer width,
<span class="lineno">  666 </span>-- arguments, expression for the length in bytes, SAW core expression for a
<span class="lineno">  667 </span>-- type-level function from the Heapster translations of the argument types to a
<span class="lineno">  668 </span>-- SAW core type, and SAW core expression for a type description of that type
<span class="lineno">  669 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  670 </span>heapster_define_opaque_llvmshape :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  671 </span>                                    Text -&gt; Int -&gt; Text -&gt; Text -&gt;
<span class="lineno">  672 </span>                                    Text -&gt; Text -&gt; TopLevel ()
<span class="lineno">  673 </span><span class="decl"><span class="nottickedoff">heapster_define_opaque_llvmshape _bic _opts henv nm w_int args_str len_str tp_str d_str =</span>
<span class="lineno">  674 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  675 </span><span class="spaces">     </span><span class="nottickedoff">(Some (Pair w LeqProof)) &lt;-</span>
<span class="lineno">  676 </span><span class="spaces">       </span><span class="nottickedoff">failOnNothing &quot;Shape width must be positive&quot; $ someNatGeq1 w_int</span>
<span class="lineno">  677 </span><span class="spaces">     </span><span class="nottickedoff">Some args_ctx &lt;- parseParsedCtxString &quot;argument types&quot; env (Text.unpack args_str)</span>
<span class="lineno">  678 </span><span class="spaces">     </span><span class="nottickedoff">let args = parsedCtxCtx args_ctx</span>
<span class="lineno">  679 </span><span class="spaces">     </span><span class="nottickedoff">mb_len &lt;- parseExprInCtxString env (BVRepr w) args_ctx (Text.unpack len_str)</span>
<span class="lineno">  680 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  681 </span><span class="spaces">     </span><span class="nottickedoff">d_tp &lt;- tpDescTypeM sc</span>
<span class="lineno">  682 </span><span class="spaces">     </span><span class="nottickedoff">d_id &lt;- parseAndInsDef henv (Text.unpack nm ++ &quot;__desc&quot;) d_tp (Text.unpack d_str)</span>
<span class="lineno">  683 </span><span class="spaces">     </span><span class="nottickedoff">tp_tp &lt;- liftIO $ translateExprTypeFunType sc env args</span>
<span class="lineno">  684 </span><span class="spaces">     </span><span class="nottickedoff">tp_id &lt;- parseAndInsDef henv (Text.unpack nm) tp_tp (Text.unpack tp_str)</span>
<span class="lineno">  685 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ checkTypeAgreesWithDesc sc env nm tp_id args d_id</span>
<span class="lineno">  686 </span><span class="spaces">     </span><span class="nottickedoff">let env' =</span>
<span class="lineno">  687 </span><span class="spaces">           </span><span class="nottickedoff">withKnownNat w $ permEnvAddOpaqueShape env (Text.unpack nm) args mb_len tp_id d_id</span>
<span class="lineno">  688 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>-- | Define a new named LLVM shape from a Rust type declaration and an optional
<span class="lineno">  692 </span>-- crate name that qualifies the type name
<span class="lineno">  693 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  694 </span>heapster_define_rust_type_qual_opt :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  695 </span>                                      Maybe Text -&gt; Text -&gt; TopLevel ()
<span class="lineno">  696 </span><span class="decl"><span class="nottickedoff">heapster_define_rust_type_qual_opt _bic _opts henv maybe_crate str =</span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: Looking at first LLVM module to determine pointer width. Need to</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="nottickedoff">-- think more to determine if this is always a safe thing to do (e.g. are</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="nottickedoff">-- there ever circumstances where different modules have different pointer</span>
<span class="lineno">  700 </span><span class="spaces">  </span><span class="nottickedoff">-- widths?)</span>
<span class="lineno">  701 </span><span class="spaces">  </span><span class="nottickedoff">do Some lm &lt;- failOnNothing (&quot;No LLVM modules found&quot;)</span>
<span class="lineno">  702 </span><span class="spaces">                              </span><span class="nottickedoff">(listToMaybe $ heapsterEnvLLVMModules henv)</span>
<span class="lineno">  703 </span><span class="spaces">     </span><span class="nottickedoff">let w = llvmModuleArchReprWidth lm</span>
<span class="lineno">  704 </span><span class="spaces">     </span><span class="nottickedoff">leq_proof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno">  705 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno">  706 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno">  707 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- liftIO $ readIORef (heapsterEnvPermEnvRef henv)</span>
<span class="lineno">  708 </span><span class="spaces">     </span><span class="nottickedoff">let crated_nm nm = maybe nm (\crate -&gt; crate &lt;&gt; &quot;::&quot; &lt;&gt; nm) maybe_crate</span>
<span class="lineno">  709 </span><span class="spaces">     </span><span class="nottickedoff">withKnownNat w $ withLeqProof leq_proof $</span>
<span class="lineno">  710 </span><span class="spaces">       </span><span class="nottickedoff">do partialShape &lt;- parseRustTypeString env w (Text.unpack str)</span>
<span class="lineno">  711 </span><span class="spaces">          </span><span class="nottickedoff">case partialShape of</span>
<span class="lineno">  712 </span><span class="spaces">            </span><span class="nottickedoff">NonRecShape nm ctx sh -&gt;</span>
<span class="lineno">  713 </span><span class="spaces">              </span><span class="nottickedoff">do let nsh = NamedShape { namedShapeName = Text.unpack $ crated_nm (Text.pack nm)</span>
<span class="lineno">  714 </span><span class="spaces">                                      </span><span class="nottickedoff">, namedShapeArgs = ctx</span>
<span class="lineno">  715 </span><span class="spaces">                                      </span><span class="nottickedoff">, namedShapeBody = DefinedShapeBody sh</span>
<span class="lineno">  716 </span><span class="spaces">                                      </span><span class="nottickedoff">}</span>
<span class="lineno">  717 </span><span class="spaces">                     </span><span class="nottickedoff">env' = permEnvAddNamedShape env nsh</span>
<span class="lineno">  718 </span><span class="spaces">                 </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span>
<span class="lineno">  719 </span><span class="spaces">            </span><span class="nottickedoff">RecShape nm ctx mb_sh -&gt;</span>
<span class="lineno">  720 </span><span class="spaces">              </span><span class="nottickedoff">do let nm' = crated_nm (Text.pack nm)</span>
<span class="lineno">  721 </span><span class="spaces">                 </span><span class="nottickedoff">env' &lt;- addRecNamedShape henv (Text.unpack nm') ctx w mb_sh</span>
<span class="lineno">  722 </span><span class="spaces">                 </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  723 </span>
<span class="lineno">  724 </span>
<span class="lineno">  725 </span>-- | Define a new named LLVM shape from a Rust type declaration
<span class="lineno">  726 </span>heapster_define_rust_type :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  727 </span>                             Text -&gt; TopLevel ()
<span class="lineno">  728 </span><span class="decl"><span class="nottickedoff">heapster_define_rust_type bic opts henv str =</span>
<span class="lineno">  729 </span><span class="spaces">  </span><span class="nottickedoff">heapster_define_rust_type_qual_opt bic opts henv Nothing str</span></span>
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>-- | Define a new named LLVM shape from a Rust type declaration and a crate name
<span class="lineno">  732 </span>-- that qualifies the Rust type by being prefixed to the name of the LLVM shape
<span class="lineno">  733 </span>heapster_define_rust_type_qual :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  734 </span>                                  Text -&gt; Text -&gt; TopLevel ()
<span class="lineno">  735 </span><span class="decl"><span class="nottickedoff">heapster_define_rust_type_qual bic opts henv crate str =</span>
<span class="lineno">  736 </span><span class="spaces">  </span><span class="nottickedoff">heapster_define_rust_type_qual_opt bic opts henv (Just crate) str</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>-- | Add Heapster type-checking hint for some blocks in a function given by
<span class="lineno">  739 </span>-- name. The blocks to receive the hint are those specified in the list, or all
<span class="lineno">  740 </span>-- blocks if the list is empty.
<span class="lineno">  741 </span>heapster_add_block_hints :: HeapsterEnv -&gt; Text -&gt; [Int] -&gt;
<span class="lineno">  742 </span>                            (forall ext blocks init ret args.
<span class="lineno">  743 </span>                             CFG ext blocks init ret -&gt; BlockID blocks args -&gt;
<span class="lineno">  744 </span>                             TopLevel (BlockHintSort args)) -&gt;
<span class="lineno">  745 </span>                            TopLevel ()
<span class="lineno">  746 </span><span class="decl"><span class="nottickedoff">heapster_add_block_hints henv nm blks hintF =</span>
<span class="lineno">  747 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  748 </span><span class="spaces">     </span><span class="nottickedoff">Some (ModuleAndCFG _ (AnyCFG cfg)) &lt;-</span>
<span class="lineno">  749 </span><span class="spaces">       </span><span class="nottickedoff">failOnNothing (&quot;Could not find symbol definition: &quot; &lt;&gt; nm) =&lt;&lt;</span>
<span class="lineno">  750 </span><span class="spaces">         </span><span class="nottickedoff">io (lookupLLVMSymbolModAndCFG henv nm)</span>
<span class="lineno">  751 </span><span class="spaces">     </span><span class="nottickedoff">let h = cfgHandle cfg</span>
<span class="lineno">  752 </span><span class="spaces">         </span><span class="nottickedoff">blocks = fmapFC blockInputs $ cfgBlockMap cfg</span>
<span class="lineno">  753 </span><span class="spaces">         </span><span class="nottickedoff">block_idxs = fmapFC (blockIDIndex . blockID) $ cfgBlockMap cfg</span>
<span class="lineno">  754 </span><span class="spaces">     </span><span class="nottickedoff">blkIDs &lt;- case blks of</span>
<span class="lineno">  755 </span><span class="spaces">       </span><span class="nottickedoff">-- If an empty list is given, add a hint to every block</span>
<span class="lineno">  756 </span><span class="spaces">       </span><span class="nottickedoff">[] -&gt; pure $ toListFC (Some . BlockID) block_idxs</span>
<span class="lineno">  757 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; forM blks $ \blk -&gt;</span>
<span class="lineno">  758 </span><span class="spaces">         </span><span class="nottickedoff">failOnNothing (&quot;Block ID &quot; &lt;&gt; Text.pack (show blk) &lt;&gt;</span>
<span class="lineno">  759 </span><span class="spaces">                        </span><span class="nottickedoff">&quot; not found in function &quot; &lt;&gt; nm)</span>
<span class="lineno">  760 </span><span class="spaces">                       </span><span class="nottickedoff">(fmapF BlockID &lt;$&gt; Ctx.intIndex blk (Ctx.size blocks))</span>
<span class="lineno">  761 </span><span class="spaces">     </span><span class="nottickedoff">env' &lt;- foldM (\env' (Some blkID) -&gt;</span>
<span class="lineno">  762 </span><span class="spaces">                     </span><span class="nottickedoff">permEnvAddHint env' &lt;$&gt; Hint_Block &lt;$&gt;</span>
<span class="lineno">  763 </span><span class="spaces">                     </span><span class="nottickedoff">BlockHint h blocks blkID &lt;$&gt;</span>
<span class="lineno">  764 </span><span class="spaces">                     </span><span class="nottickedoff">hintF cfg blkID)</span>
<span class="lineno">  765 </span><span class="spaces">       </span><span class="nottickedoff">env blkIDs</span>
<span class="lineno">  766 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno">  767 </span>
<span class="lineno">  768 </span>-- | Add a hint to the Heapster type-checker that Crucible block number @block@ in
<span class="lineno">  769 </span>-- function @fun@ should have permissions @perms@ on its inputs
<span class="lineno">  770 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  771 </span>heapster_block_entry_hint :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  772 </span>                             Text -&gt; Int -&gt; Text -&gt; Text -&gt; Text -&gt;
<span class="lineno">  773 </span>                             TopLevel ()
<span class="lineno">  774 </span><span class="decl"><span class="nottickedoff">heapster_block_entry_hint _bic _opts henv nm blk top_args_str ghosts_str perms_str =</span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  776 </span><span class="spaces">     </span><span class="nottickedoff">Some top_args_p &lt;-</span>
<span class="lineno">  777 </span><span class="spaces">       </span><span class="nottickedoff">parseParsedCtxString &quot;top-level argument context&quot; env (Text.unpack top_args_str)</span>
<span class="lineno">  778 </span><span class="spaces">     </span><span class="nottickedoff">Some ghosts_p &lt;-</span>
<span class="lineno">  779 </span><span class="spaces">       </span><span class="nottickedoff">parseParsedCtxString &quot;ghost argument context&quot; env (Text.unpack ghosts_str)</span>
<span class="lineno">  780 </span><span class="spaces">     </span><span class="nottickedoff">let top_args = parsedCtxCtx top_args_p</span>
<span class="lineno">  781 </span><span class="spaces">         </span><span class="nottickedoff">ghosts = parsedCtxCtx ghosts_p</span>
<span class="lineno">  782 </span><span class="spaces">     </span><span class="nottickedoff">heapster_add_block_hints henv nm [blk] $ \cfg blkID -&gt;</span>
<span class="lineno">  783 </span><span class="spaces">       </span><span class="nottickedoff">let block_args =</span>
<span class="lineno">  784 </span><span class="spaces">             </span><span class="nottickedoff">mkCruCtx $ blockInputs $</span>
<span class="lineno">  785 </span><span class="spaces">             </span><span class="nottickedoff">(cfgBlockMap cfg) Ctx.! (blockIDIndex blkID) in</span>
<span class="lineno">  786 </span><span class="spaces">       </span><span class="nottickedoff">BlockEntryHintSort top_args ghosts &lt;$&gt;</span>
<span class="lineno">  787 </span><span class="spaces">       </span><span class="nottickedoff">parsePermsString &quot;block entry permissions&quot; env</span>
<span class="lineno">  788 </span><span class="spaces">       </span><span class="nottickedoff">(appendParsedCtx (appendParsedCtx</span>
<span class="lineno">  789 </span><span class="spaces">                         </span><span class="nottickedoff">top_args_p (mkArgsParsedCtx block_args)) ghosts_p)</span>
<span class="lineno">  790 </span><span class="spaces">       </span><span class="nottickedoff">(Text.unpack perms_str)</span></span>
<span class="lineno">  791 </span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>-- | Add a hint to the Heapster type-checker to *generalize* (recursively
<span class="lineno">  794 </span>-- replace all instances of @eq(const)@ with @exists x. eq(x)@) all permissions
<span class="lineno">  795 </span>-- on the inputs of the given Crucible blocks numbers. If the given list is
<span class="lineno">  796 </span>-- empty, do so for every block in the CFG.
<span class="lineno">  797 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  798 </span>heapster_gen_block_perms_hint :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  799 </span>                                 Text -&gt; [Int] -&gt; TopLevel ()
<span class="lineno">  800 </span><span class="decl"><span class="nottickedoff">heapster_gen_block_perms_hint _bic _opts henv nm blks =</span>
<span class="lineno">  801 </span><span class="spaces">  </span><span class="nottickedoff">heapster_add_block_hints henv nm blks $ \_ _ -&gt; return GenPermsHintSort</span></span>
<span class="lineno">  802 </span>
<span class="lineno">  803 </span>-- | Add a hint to the Heapster type-checker to make a join point at each of the
<span class="lineno">  804 </span>-- given block numbers, meaning that all entries to the given blocks are merged
<span class="lineno">  805 </span>-- into a single entrypoint, whose permissions are given by the first call to
<span class="lineno">  806 </span>-- the block
<span class="lineno">  807 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  808 </span>heapster_join_point_hint :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  809 </span>                            Text -&gt; [Int] -&gt; TopLevel ()
<span class="lineno">  810 </span><span class="decl"><span class="nottickedoff">heapster_join_point_hint _bic _opts henv nm blks =</span>
<span class="lineno">  811 </span><span class="spaces">  </span><span class="nottickedoff">heapster_add_block_hints henv nm blks $ \_ _ -&gt; return JoinPointHintSort</span></span>
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>-- | Search for all symbol names in any LLVM module in a 'HeapsterEnv' that
<span class="lineno">  814 </span>-- contain the supplied string as a substring
<span class="lineno">  815 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  816 </span>heapster_find_symbols :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt; Text -&gt;
<span class="lineno">  817 </span>                         TopLevel [Text]
<span class="lineno">  818 </span><span class="decl"><span class="nottickedoff">heapster_find_symbols _bic _opts henv txt = do</span>
<span class="lineno">  819 </span><span class="spaces">  </span><span class="nottickedoff">let str = T.unpack txt</span>
<span class="lineno">  820 </span><span class="spaces">      </span><span class="nottickedoff">results =</span>
<span class="lineno">  821 </span><span class="spaces">        </span><span class="nottickedoff">concatMap (\(Some lm) -&gt;</span>
<span class="lineno">  822 </span><span class="spaces">                    </span><span class="nottickedoff">mapMaybe (\(L.Symbol nm) -&gt;</span>
<span class="lineno">  823 </span><span class="spaces">                               </span><span class="nottickedoff">if isInfixOf str nm then Just nm else Nothing) $</span>
<span class="lineno">  824 </span><span class="spaces">                    </span><span class="nottickedoff">map L.decName (L.modDeclares $ modAST lm) ++</span>
<span class="lineno">  825 </span><span class="spaces">                    </span><span class="nottickedoff">map L.defName (L.modDefines $ modAST lm)) $</span>
<span class="lineno">  826 </span><span class="spaces">        </span><span class="nottickedoff">heapsterEnvLLVMModules henv</span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="nottickedoff">return $ map T.pack results</span></span>
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>-- | Search for a symbol name in any LLVM module in a 'HeapsterEnv' that
<span class="lineno">  830 </span>-- contains the supplied string as a substring, failing if there is not exactly
<span class="lineno">  831 </span>-- one such symbol
<span class="lineno">  832 </span>heapster_find_symbol :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt; Text -&gt;
<span class="lineno">  833 </span>                        TopLevel Text
<span class="lineno">  834 </span><span class="decl"><span class="nottickedoff">heapster_find_symbol bic opts henv txt =</span>
<span class="lineno">  835 </span><span class="spaces">  </span><span class="nottickedoff">heapster_find_symbols bic opts henv txt &gt;&gt;= \syms -&gt;</span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="nottickedoff">case syms of</span>
<span class="lineno">  837 </span><span class="spaces">    </span><span class="nottickedoff">[sym] -&gt; return sym</span>
<span class="lineno">  838 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; fail (&quot;No symbol found matching string: &quot; ++ T.unpack txt)</span>
<span class="lineno">  839 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail (&quot;Found multiple symbols matching string &quot; ++ T.unpack txt ++ &quot;: &quot; ++</span>
<span class="lineno">  840 </span><span class="spaces">               </span><span class="nottickedoff">concat (intersperse &quot;, &quot; $ map show syms))</span></span>
<span class="lineno">  841 </span>
<span class="lineno">  842 </span>-- | Extract the 'String' name of an LLVM symbol
<span class="lineno">  843 </span>symString :: L.Symbol -&gt; String
<span class="lineno">  844 </span><span class="decl"><span class="nottickedoff">symString (L.Symbol str) = str</span></span>
<span class="lineno">  845 </span>
<span class="lineno">  846 </span>-- | Extract the function type of an LLVM definition
<span class="lineno">  847 </span>defFunType :: L.Define -&gt; L.Type
<span class="lineno">  848 </span><span class="decl"><span class="nottickedoff">defFunType defn =</span>
<span class="lineno">  849 </span><span class="spaces">  </span><span class="nottickedoff">L.FunTy (L.defRetType defn) (map L.typedType</span>
<span class="lineno">  850 </span><span class="spaces">                               </span><span class="nottickedoff">(L.defArgs defn)) (L.defVarArgs defn)</span></span>
<span class="lineno">  851 </span>
<span class="lineno">  852 </span>-- | Extract the function type of an LLVM declaration
<span class="lineno">  853 </span>decFunType :: L.Declare -&gt; L.Type
<span class="lineno">  854 </span><span class="decl"><span class="nottickedoff">decFunType decl =</span>
<span class="lineno">  855 </span><span class="spaces">  </span><span class="nottickedoff">L.FunTy (L.decRetType decl) (L.decArgs decl) (L.decVarArgs decl)</span></span>
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>-- | Search for all symbols with the supplied string as a substring that have
<span class="lineno">  858 </span>-- the supplied LLVM type
<span class="lineno">  859 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  860 </span>heapster_find_symbols_with_type :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  861 </span>                                   Text -&gt; Text -&gt; TopLevel [Text]
<span class="lineno">  862 </span><span class="decl"><span class="nottickedoff">heapster_find_symbols_with_type _bic _opts henv str tp_str =</span>
<span class="lineno">  863 </span><span class="spaces">  </span><span class="nottickedoff">let str' = T.unpack str</span>
<span class="lineno">  864 </span><span class="spaces">      </span><span class="nottickedoff">tp_str' = T.unpack tp_str</span>
<span class="lineno">  865 </span><span class="spaces">  </span><span class="nottickedoff">in</span>
<span class="lineno">  866 </span><span class="spaces">  </span><span class="nottickedoff">case L.parseType tp_str' of</span>
<span class="lineno">  867 </span><span class="spaces">    </span><span class="nottickedoff">Left err -&gt;</span>
<span class="lineno">  868 </span><span class="spaces">      </span><span class="nottickedoff">fail (&quot;Error parsing LLVM type: &quot; ++ tp_str' ++ &quot;\n&quot; ++ show err)</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="nottickedoff">Right tp@(L.FunTy _ _ _) -&gt;</span>
<span class="lineno">  870 </span><span class="spaces">      </span><span class="nottickedoff">return $</span>
<span class="lineno">  871 </span><span class="spaces">      </span><span class="nottickedoff">concatMap (\(Some lm) -&gt;</span>
<span class="lineno">  872 </span><span class="spaces">                  </span><span class="nottickedoff">mapMaybe (\decl -&gt;</span>
<span class="lineno">  873 </span><span class="spaces">                             </span><span class="nottickedoff">if isInfixOf str' (symString $ L.decName decl) &amp;&amp;</span>
<span class="lineno">  874 </span><span class="spaces">                                </span><span class="nottickedoff">decFunType decl == tp</span>
<span class="lineno">  875 </span><span class="spaces">                             </span><span class="nottickedoff">then Just (T.pack $ symString $ L.decName decl) else Nothing)</span>
<span class="lineno">  876 </span><span class="spaces">                  </span><span class="nottickedoff">(L.modDeclares $ modAST lm)</span>
<span class="lineno">  877 </span><span class="spaces">                  </span><span class="nottickedoff">++</span>
<span class="lineno">  878 </span><span class="spaces">                  </span><span class="nottickedoff">mapMaybe (\defn -&gt;</span>
<span class="lineno">  879 </span><span class="spaces">                             </span><span class="nottickedoff">if isInfixOf str' (symString $ L.defName defn) &amp;&amp;</span>
<span class="lineno">  880 </span><span class="spaces">                                </span><span class="nottickedoff">defFunType defn == tp</span>
<span class="lineno">  881 </span><span class="spaces">                             </span><span class="nottickedoff">then Just (T.pack $ symString $ L.defName defn) else Nothing)</span>
<span class="lineno">  882 </span><span class="spaces">                  </span><span class="nottickedoff">(L.modDefines $ modAST lm)) $</span>
<span class="lineno">  883 </span><span class="spaces">                </span><span class="nottickedoff">heapsterEnvLLVMModules henv</span>
<span class="lineno">  884 </span><span class="spaces">    </span><span class="nottickedoff">Right tp -&gt;</span>
<span class="lineno">  885 </span><span class="spaces">      </span><span class="nottickedoff">fail (&quot;Expected an LLVM function type, but found: &quot; ++ show tp)</span></span>
<span class="lineno">  886 </span>
<span class="lineno">  887 </span>-- | Search for a symbol by name and Crucible type in any LLVM module in a
<span class="lineno">  888 </span>-- 'HeapsterEnv' that contains the supplied string as a substring
<span class="lineno">  889 </span>heapster_find_symbol_with_type :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  890 </span>                                  Text -&gt; Text -&gt; TopLevel Text
<span class="lineno">  891 </span><span class="decl"><span class="nottickedoff">heapster_find_symbol_with_type bic opts henv str tp_str =</span>
<span class="lineno">  892 </span><span class="spaces">  </span><span class="nottickedoff">let str' = T.unpack str</span>
<span class="lineno">  893 </span><span class="spaces">      </span><span class="nottickedoff">tp_str' = T.unpack tp_str</span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="nottickedoff">in</span>
<span class="lineno">  895 </span><span class="spaces">  </span><span class="nottickedoff">heapster_find_symbols_with_type bic opts henv str tp_str &gt;&gt;= \syms -&gt;</span>
<span class="lineno">  896 </span><span class="spaces">  </span><span class="nottickedoff">case syms of</span>
<span class="lineno">  897 </span><span class="spaces">    </span><span class="nottickedoff">[sym] -&gt; return sym</span>
<span class="lineno">  898 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; fail (&quot;No symbol found matching string: &quot; ++ str' ++</span>
<span class="lineno">  899 </span><span class="spaces">                </span><span class="nottickedoff">&quot; and type: &quot; ++ tp_str')</span>
<span class="lineno">  900 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail (&quot;Found multiple symbols matching string &quot; ++ str' ++</span>
<span class="lineno">  901 </span><span class="spaces">               </span><span class="nottickedoff">&quot; and type: &quot; ++ tp_str' ++ &quot;: &quot; ++</span>
<span class="lineno">  902 </span><span class="spaces">               </span><span class="nottickedoff">concat (intersperse &quot;, &quot; $ map show syms))</span></span>
<span class="lineno">  903 </span>
<span class="lineno">  904 </span>-- | Print a 'String' as a SAW-script string literal, escaping any double quotes
<span class="lineno">  905 </span>-- or newlines
<span class="lineno">  906 </span>print_as_saw_script_string :: String -&gt; String
<span class="lineno">  907 </span><span class="decl"><span class="nottickedoff">print_as_saw_script_string str =</span>
<span class="lineno">  908 </span><span class="spaces">  </span><span class="nottickedoff">&quot;\&quot;&quot; ++ concatMap (\c -&gt; case c of</span>
<span class="lineno">  909 </span><span class="spaces">                        </span><span class="nottickedoff">'\&quot;' -&gt; &quot;\\\&quot;&quot;</span>
<span class="lineno">  910 </span><span class="spaces">                        </span><span class="nottickedoff">'\n' -&gt; &quot;\\\n\\&quot;</span>
<span class="lineno">  911 </span><span class="spaces">                        </span><span class="nottickedoff">_ -&gt; [c]) str ++ &quot;\&quot;&quot;</span></span>;
<span class="lineno">  912 </span>
<span class="lineno">  913 </span>-- | Map a search string @str@ to a newline-separated sequence of SAW-script
<span class="lineno">  914 </span>-- commands @&quot;heapster_find_symbol_with_type str tp&quot;@, one for each LLVM type
<span class="lineno">  915 </span>-- @tp@ associated with a symbol whose name contains @str@
<span class="lineno">  916 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  917 </span>heapster_find_symbol_commands :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  918 </span>                                 Text -&gt; TopLevel Text
<span class="lineno">  919 </span><span class="decl"><span class="nottickedoff">heapster_find_symbol_commands _bic _opts henv str =</span>
<span class="lineno">  920 </span><span class="spaces">  </span><span class="nottickedoff">let str' = T.unpack str</span>
<span class="lineno">  921 </span><span class="spaces">      </span><span class="nottickedoff">result =</span>
<span class="lineno">  922 </span><span class="spaces">        </span><span class="nottickedoff">concatMap (\tp -&gt;</span>
<span class="lineno">  923 </span><span class="spaces">                    </span><span class="nottickedoff">&quot;heapster_find_symbol_with_type env\n  \&quot;&quot; ++ str' ++ &quot;\&quot;\n  &quot; ++</span>
<span class="lineno">  924 </span><span class="spaces">                    </span><span class="nottickedoff">print_as_saw_script_string (L.render $ Crucible.LLVM.ppType tp) ++ &quot;;\n&quot;) $</span>
<span class="lineno">  925 </span><span class="spaces">        </span><span class="nottickedoff">concatMap (\(Some lm) -&gt;</span>
<span class="lineno">  926 </span><span class="spaces">                    </span><span class="nottickedoff">mapMaybe (\decl -&gt;</span>
<span class="lineno">  927 </span><span class="spaces">                               </span><span class="nottickedoff">if isInfixOf str' (symString $ L.decName decl)</span>
<span class="lineno">  928 </span><span class="spaces">                               </span><span class="nottickedoff">then Just (decFunType decl)</span>
<span class="lineno">  929 </span><span class="spaces">                               </span><span class="nottickedoff">else Nothing)</span>
<span class="lineno">  930 </span><span class="spaces">                    </span><span class="nottickedoff">(L.modDeclares $ modAST lm)</span>
<span class="lineno">  931 </span><span class="spaces">                    </span><span class="nottickedoff">++</span>
<span class="lineno">  932 </span><span class="spaces">                    </span><span class="nottickedoff">mapMaybe (\defn -&gt;</span>
<span class="lineno">  933 </span><span class="spaces">                               </span><span class="nottickedoff">if isInfixOf str' (symString $ L.defName defn)</span>
<span class="lineno">  934 </span><span class="spaces">                               </span><span class="nottickedoff">then Just (defFunType defn) else Nothing)</span>
<span class="lineno">  935 </span><span class="spaces">                    </span><span class="nottickedoff">(L.modDefines $ modAST lm)) $</span>
<span class="lineno">  936 </span><span class="spaces">        </span><span class="nottickedoff">heapsterEnvLLVMModules henv</span>
<span class="lineno">  937 </span><span class="spaces">  </span><span class="nottickedoff">in</span>
<span class="lineno">  938 </span><span class="spaces">  </span><span class="nottickedoff">return $ T.pack result</span></span>
<span class="lineno">  939 </span>
<span class="lineno">  940 </span>
<span class="lineno">  941 </span>-- | Search for a symbol name in any LLVM module in a 'HeapsterEnv' that
<span class="lineno">  942 </span>-- corresponds to the supplied string, which should be of the form:
<span class="lineno">  943 </span>-- @&quot;trait::method&lt;type&gt;&quot;@. Fails if there is not exactly one such symbol.
<span class="lineno">  944 </span>heapster_find_trait_method_symbol :: BuiltinContext -&gt; Options -&gt;
<span class="lineno">  945 </span>                                     HeapsterEnv -&gt; Text -&gt; TopLevel Text
<span class="lineno">  946 </span><span class="decl"><span class="nottickedoff">heapster_find_trait_method_symbol bic opts henv str = do</span>
<span class="lineno">  947 </span><span class="spaces">  </span><span class="nottickedoff">-- Divide into &quot;trait::method&quot; and &quot;&lt;type&gt;&quot; at the left angle bracket, if any</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="nottickedoff">let (traitMethod, instType) = T.span (/= '&lt;') str</span>
<span class="lineno">  949 </span><span class="spaces">  </span><span class="nottickedoff">-- Check for the &lt;&gt; on the type</span>
<span class="lineno">  950 </span><span class="spaces">  </span><span class="nottickedoff">if not (T.isPrefixOf &quot;&lt;&quot; instType &amp;&amp; T.isSuffixOf &quot;&gt;&quot; instType) then</span>
<span class="lineno">  951 </span><span class="spaces">    </span><span class="nottickedoff">fail $ T.unpack $ &quot;Ill-formed query string: &quot; &lt;&gt; str</span>
<span class="lineno">  952 </span><span class="spaces">  </span><span class="nottickedoff">else do</span>
<span class="lineno">  953 </span><span class="spaces">    </span><span class="nottickedoff">-- pop off the brackets</span>
<span class="lineno">  954 </span><span class="spaces">    </span><span class="nottickedoff">let unbracketedType :: Text = T.drop 1 $ T.dropEnd 1 instType</span>
<span class="lineno">  955 </span><span class="spaces">    </span><span class="nottickedoff">-- split the method off the &quot;trait::method&quot; (may be more than one &quot;::&quot;)</span>
<span class="lineno">  956 </span><span class="spaces">    </span><span class="nottickedoff">-- and replace each &quot;::&quot; with &quot;..&quot;</span>
<span class="lineno">  957 </span><span class="spaces">    </span><span class="nottickedoff">let (colonTrait, method) =</span>
<span class="lineno">  958 </span><span class="spaces">          </span><span class="nottickedoff">let (revMethod, revTrait) = T.span (/= ':') (T.reverse traitMethod)</span>
<span class="lineno">  959 </span><span class="spaces">          </span><span class="nottickedoff">in (T.reverse (T.drop 2 revTrait), T.reverse revMethod)</span>
<span class="lineno">  960 </span><span class="spaces">        </span><span class="nottickedoff">trait = T.intercalate &quot;..&quot; $ T.splitOn &quot;::&quot; colonTrait</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="nottickedoff">-- assemble the lower-level query string</span>
<span class="lineno">  962 </span><span class="spaces">    </span><span class="nottickedoff">let queryStr = unbracketedType</span>
<span class="lineno">  963 </span><span class="spaces">                </span><span class="nottickedoff">&lt;&gt; &quot;$u20$as$u20$&quot;</span>
<span class="lineno">  964 </span><span class="spaces">                </span><span class="nottickedoff">&lt;&gt; trait</span>
<span class="lineno">  965 </span><span class="spaces">                </span><span class="nottickedoff">&lt;&gt; &quot;$GT$&quot;</span>
<span class="lineno">  966 </span><span class="spaces">                </span><span class="nottickedoff">&lt;&gt; (T.pack $ show $ T.length method)</span>
<span class="lineno">  967 </span><span class="spaces">                </span><span class="nottickedoff">&lt;&gt; method</span>
<span class="lineno">  968 </span><span class="spaces">    </span><span class="nottickedoff">heapster_find_symbol bic opts henv queryStr</span></span>
<span class="lineno">  969 </span>
<span class="lineno">  970 </span>
<span class="lineno">  971 </span>-- | Assume that the given named function has the supplied type and translates
<span class="lineno">  972 </span>-- to a SAW core definition given by the second name
<span class="lineno">  973 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno">  974 </span>heapster_assume_fun_rename :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno">  975 </span>                              Text -&gt; Text -&gt; Text -&gt; Text -&gt;
<span class="lineno">  976 </span>                              TopLevel ()
<span class="lineno">  977 </span><span class="decl"><span class="nottickedoff">heapster_assume_fun_rename _bic _opts henv nm nm_to perms_string term_string =</span>
<span class="lineno">  978 </span><span class="spaces">  </span><span class="nottickedoff">do let nm_to' = T.unpack nm_to</span>
<span class="lineno">  979 </span><span class="spaces">         </span><span class="nottickedoff">perms_string' = T.unpack perms_string</span>
<span class="lineno">  980 </span><span class="spaces">         </span><span class="nottickedoff">term_string' = T.unpack term_string</span>
<span class="lineno">  981 </span><span class="spaces">     </span><span class="nottickedoff">Some lm &lt;- failOnNothing (&quot;Could not find symbol: &quot; &lt;&gt; nm)</span>
<span class="lineno">  982 </span><span class="spaces">                              </span><span class="nottickedoff">(lookupModContainingSym henv nm)</span>
<span class="lineno">  983 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  984 </span><span class="spaces">     </span><span class="nottickedoff">let w = llvmModuleArchReprWidth lm</span>
<span class="lineno">  985 </span><span class="spaces">     </span><span class="nottickedoff">leq_proof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno">  986 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno">  987 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno">  988 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno">  989 </span><span class="spaces">     </span><span class="nottickedoff">(Some cargs, Some ret) &lt;- lookupFunctionType lm nm</span>
<span class="lineno">  990 </span><span class="spaces">     </span><span class="nottickedoff">let args = mkCruCtx cargs</span>
<span class="lineno">  991 </span><span class="spaces">     </span><span class="nottickedoff">withKnownNat w $ withLeqProof leq_proof $ do</span>
<span class="lineno">  992 </span><span class="spaces">        </span><span class="nottickedoff">SomeFunPerm fun_perm &lt;-</span>
<span class="lineno">  993 </span><span class="spaces">          </span><span class="nottickedoff">parseFunPermStringMaybeRust &quot;permissions&quot; w env args ret perms_string'</span>
<span class="lineno">  994 </span><span class="spaces">        </span><span class="nottickedoff">env' &lt;- liftIO $ readIORef (heapsterEnvPermEnvRef henv)</span>
<span class="lineno">  995 </span><span class="spaces">        </span><span class="nottickedoff">fun_typ &lt;- liftIO $ translateCompleteFunPerm sc env fun_perm</span>
<span class="lineno">  996 </span><span class="spaces">        </span><span class="nottickedoff">term_ident &lt;- parseAndInsDef henv nm_to' fun_typ term_string'</span>
<span class="lineno">  997 </span><span class="spaces">        </span><span class="nottickedoff">let env'' = permEnvAddGlobalSymFun env'</span>
<span class="lineno">  998 </span><span class="spaces">                                           </span><span class="nottickedoff">(GlobalSymbol $ fromString $ T.unpack nm)</span>
<span class="lineno">  999 </span><span class="spaces">                                           </span><span class="nottickedoff">w</span>
<span class="lineno"> 1000 </span><span class="spaces">                                           </span><span class="nottickedoff">fun_perm</span>
<span class="lineno"> 1001 </span><span class="spaces">                                           </span><span class="nottickedoff">(globalOpenTerm term_ident)</span>
<span class="lineno"> 1002 </span><span class="spaces">        </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env''</span></span>
<span class="lineno"> 1003 </span>
<span class="lineno"> 1004 </span>-- | Create a new SAW core primitive named @nm@ with type @tp@ in the module
<span class="lineno"> 1005 </span>-- associated with the supplied Heapster environment, and return its identifier
<span class="lineno"> 1006 </span>insPrimitive :: HeapsterEnv -&gt; Text -&gt; Term -&gt; TopLevel Ident
<span class="lineno"> 1007 </span><span class="decl"><span class="nottickedoff">insPrimitive henv nm tp =</span>
<span class="lineno"> 1008 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1009 </span><span class="spaces">     </span><span class="nottickedoff">let mnm = heapsterEnvSAWModule henv</span>
<span class="lineno"> 1010 </span><span class="spaces">     </span><span class="nottickedoff">let ident = mkSafeIdent mnm (Text.unpack nm)</span>
<span class="lineno"> 1011 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ scDeclarePrim sc ident PrimQualifier tp</span>
<span class="lineno"> 1012 </span><span class="spaces">     </span><span class="nottickedoff">return ident</span></span>
<span class="lineno"> 1013 </span>
<span class="lineno"> 1014 </span>-- | Assume that the given named function has the supplied type and translates
<span class="lineno"> 1015 </span>-- to a SAW core definition given by the second name
<span class="lineno"> 1016 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1017 </span>heapster_assume_fun_rename_prim :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1018 </span>                                   Text -&gt; Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 1019 </span><span class="decl"><span class="nottickedoff">heapster_assume_fun_rename_prim _bic _opts henv nm nm_to perms_string =</span>
<span class="lineno"> 1020 </span><span class="spaces">  </span><span class="nottickedoff">do Some lm &lt;- failOnNothing (&quot;Could not find symbol: &quot; &lt;&gt; nm)</span>
<span class="lineno"> 1021 </span><span class="spaces">                              </span><span class="nottickedoff">(lookupModContainingSym henv nm)</span>
<span class="lineno"> 1022 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1023 </span><span class="spaces">     </span><span class="nottickedoff">let w = llvmModuleArchReprWidth lm</span>
<span class="lineno"> 1024 </span><span class="spaces">     </span><span class="nottickedoff">leq_proof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno"> 1025 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno"> 1026 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno"> 1027 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno"> 1028 </span><span class="spaces">     </span><span class="nottickedoff">(Some cargs, Some ret) &lt;- lookupFunctionType lm nm</span>
<span class="lineno"> 1029 </span><span class="spaces">     </span><span class="nottickedoff">let args = mkCruCtx cargs</span>
<span class="lineno"> 1030 </span><span class="spaces">     </span><span class="nottickedoff">withKnownNat w $ withLeqProof leq_proof $ do</span>
<span class="lineno"> 1031 </span><span class="spaces">        </span><span class="nottickedoff">SomeFunPerm fun_perm &lt;-</span>
<span class="lineno"> 1032 </span><span class="spaces">          </span><span class="nottickedoff">parseFunPermStringMaybeRust &quot;permissions&quot; w env args ret (Text.unpack perms_string)</span>
<span class="lineno"> 1033 </span><span class="spaces">        </span><span class="nottickedoff">env' &lt;- liftIO $ readIORef (heapsterEnvPermEnvRef henv)</span>
<span class="lineno"> 1034 </span><span class="spaces">        </span><span class="nottickedoff">fun_typ &lt;- liftIO $ translateCompleteFunPerm sc env fun_perm</span>
<span class="lineno"> 1035 </span><span class="spaces">        </span><span class="nottickedoff">term_ident &lt;- insPrimitive henv nm_to fun_typ</span>
<span class="lineno"> 1036 </span><span class="spaces">        </span><span class="nottickedoff">let env'' = permEnvAddGlobalSymFun env'</span>
<span class="lineno"> 1037 </span><span class="spaces">                                           </span><span class="nottickedoff">(GlobalSymbol $ fromString $ Text.unpack nm)</span>
<span class="lineno"> 1038 </span><span class="spaces">                                           </span><span class="nottickedoff">w</span>
<span class="lineno"> 1039 </span><span class="spaces">                                           </span><span class="nottickedoff">fun_perm</span>
<span class="lineno"> 1040 </span><span class="spaces">                                           </span><span class="nottickedoff">(globalOpenTerm term_ident)</span>
<span class="lineno"> 1041 </span><span class="spaces">        </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env''</span></span>
<span class="lineno"> 1042 </span>
<span class="lineno"> 1043 </span>-- | Assume that the given named function has the supplied type and translates
<span class="lineno"> 1044 </span>-- to a SAW core definition given by name
<span class="lineno"> 1045 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1046 </span>heapster_assume_fun :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1047 </span>                       Text -&gt; Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 1048 </span><span class="decl"><span class="nottickedoff">heapster_assume_fun _bic _opts henv nm perms_string term_string =</span>
<span class="lineno"> 1049 </span><span class="spaces">  </span><span class="nottickedoff">heapster_assume_fun_rename _bic _opts henv nm nm perms_string term_string</span></span>
<span class="lineno"> 1050 </span>
<span class="lineno"> 1051 </span>-- | Assume that the given named function has one or more permissions and
<span class="lineno"> 1052 </span>-- associated translations, each of which is as given in 'heapster_assume_fun'
<span class="lineno"> 1053 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1054 </span>heapster_assume_fun_multi :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1055 </span>                             Text -&gt; [(Text, Text)] -&gt; TopLevel ()
<span class="lineno"> 1056 </span><span class="decl"><span class="nottickedoff">heapster_assume_fun_multi _bic _opts henv nm perms_terms_strings =</span>
<span class="lineno"> 1057 </span><span class="spaces">  </span><span class="nottickedoff">do Some lm &lt;- failOnNothing (&quot;Could not find symbol: &quot; &lt;&gt; nm)</span>
<span class="lineno"> 1058 </span><span class="spaces">                              </span><span class="nottickedoff">(lookupModContainingSym henv nm)</span>
<span class="lineno"> 1059 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1060 </span><span class="spaces">     </span><span class="nottickedoff">let w = llvmModuleArchReprWidth lm</span>
<span class="lineno"> 1061 </span><span class="spaces">     </span><span class="nottickedoff">leq_proof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno"> 1062 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno"> 1063 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno"> 1064 </span><span class="spaces">     </span><span class="nottickedoff">(Some (cargs :: CtxRepr cargs),</span>
<span class="lineno"> 1065 </span><span class="spaces">      </span><span class="nottickedoff">Some (ret :: TypeRepr ret)) &lt;- lookupFunctionType lm nm</span>
<span class="lineno"> 1066 </span><span class="spaces">     </span><span class="nottickedoff">let args = mkCruCtx cargs</span>
<span class="lineno"> 1067 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- liftIO $ readIORef (heapsterEnvPermEnvRef henv)</span>
<span class="lineno"> 1068 </span><span class="spaces">     </span><span class="nottickedoff">perms_terms :: [(SomeFunPerm (CtxToRList cargs) ret, OpenTerm)] &lt;-</span>
<span class="lineno"> 1069 </span><span class="spaces">       </span><span class="nottickedoff">forM (zip perms_terms_strings [0::Int ..]) $ \((perms_string,</span>
<span class="lineno"> 1070 </span><span class="spaces">                                                       </span><span class="nottickedoff">term_string), i) -&gt;</span>
<span class="lineno"> 1071 </span><span class="spaces">       </span><span class="nottickedoff">withKnownNat w $ withLeqProof leq_proof $</span>
<span class="lineno"> 1072 </span><span class="spaces">       </span><span class="nottickedoff">do some_fun_perm &lt;-</span>
<span class="lineno"> 1073 </span><span class="spaces">            </span><span class="nottickedoff">parseFunPermStringMaybeRust &quot;permissions&quot; w env args ret (Text.unpack perms_string)</span>
<span class="lineno"> 1074 </span><span class="spaces">          </span><span class="nottickedoff">fun_typ &lt;-</span>
<span class="lineno"> 1075 </span><span class="spaces">            </span><span class="nottickedoff">case some_fun_perm of</span>
<span class="lineno"> 1076 </span><span class="spaces">              </span><span class="nottickedoff">SomeFunPerm fun_perm -&gt;</span>
<span class="lineno"> 1077 </span><span class="spaces">                </span><span class="nottickedoff">liftIO $ translateCompleteFunPerm sc env fun_perm</span>
<span class="lineno"> 1078 </span><span class="spaces">          </span><span class="nottickedoff">term_ident &lt;-</span>
<span class="lineno"> 1079 </span><span class="spaces">            </span><span class="nottickedoff">parseAndInsDef henv (Text.unpack nm ++ &quot;__&quot; ++ show i) fun_typ (Text.unpack term_string)</span>
<span class="lineno"> 1080 </span><span class="spaces">          </span><span class="nottickedoff">return (some_fun_perm, globalOpenTerm term_ident)</span>
<span class="lineno"> 1081 </span><span class="spaces">     </span><span class="nottickedoff">let env' =</span>
<span class="lineno"> 1082 </span><span class="spaces">           </span><span class="nottickedoff">withKnownNat w $ withLeqProof leq_proof $</span>
<span class="lineno"> 1083 </span><span class="spaces">           </span><span class="nottickedoff">permEnvAddGlobalSymFunMulti env (GlobalSymbol $</span>
<span class="lineno"> 1084 </span><span class="spaces">                                            </span><span class="nottickedoff">fromString $ Text.unpack nm) w perms_terms</span>
<span class="lineno"> 1085 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span></span>
<span class="lineno"> 1086 </span>
<span class="lineno"> 1087 </span>
<span class="lineno"> 1088 </span>-- | Type-check a list of potentially mutually recursive functions, each against
<span class="lineno"> 1089 </span>-- its own function permission, specified as a list of pairs of a function
<span class="lineno"> 1090 </span>-- name and a 'Text' representation of its permission
<span class="lineno"> 1091 </span>heapster_typecheck_mut_funs :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1092 </span>                               [(Text, Text)] -&gt; TopLevel ()
<span class="lineno"> 1093 </span><span class="decl"><span class="nottickedoff">heapster_typecheck_mut_funs bic opts henv =</span>
<span class="lineno"> 1094 </span><span class="spaces">  </span><span class="nottickedoff">heapster_typecheck_mut_funs_rename bic opts henv .</span>
<span class="lineno"> 1095 </span><span class="spaces">  </span><span class="nottickedoff">map (\(nm, perms_string) -&gt; (nm, nm, perms_string))</span></span>
<span class="lineno"> 1096 </span>
<span class="lineno"> 1097 </span>-- | Type-check a list of potentially mutually recursive functions, each against
<span class="lineno"> 1098 </span>-- its own function permission, potentially renaming the functions in the
<span class="lineno"> 1099 </span>-- generated SAW core specifications. The functions are specified as a list of
<span class="lineno"> 1100 </span>-- triples @(nm,nm_to,perms)@ of the function symbol @nm@ in the binary, the
<span class="lineno"> 1101 </span>-- desired name @mn_to@ for the SAW core specification, and the permissions
<span class="lineno"> 1102 </span>-- @perms@ given as a 'Text'
<span class="lineno"> 1103 </span>heapster_typecheck_mut_funs_rename ::
<span class="lineno"> 1104 </span>  BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1105 </span>  [(Text, Text, Text)] -&gt; TopLevel ()
<span class="lineno"> 1106 </span><span class="decl"><span class="nottickedoff">heapster_typecheck_mut_funs_rename _bic opts henv fn_names_and_perms =</span>
<span class="lineno"> 1107 </span><span class="spaces">  </span><span class="nottickedoff">do let fst_nm =</span>
<span class="lineno"> 1108 </span><span class="spaces">           </span><span class="nottickedoff">case fn_names_and_perms of</span>
<span class="lineno"> 1109 </span><span class="spaces">             </span><span class="nottickedoff">(nm, _, _):_ -&gt; nm</span>
<span class="lineno"> 1110 </span><span class="spaces">             </span><span class="nottickedoff">-- TODO: Give a proper error message here instead of panicking,</span>
<span class="lineno"> 1111 </span><span class="spaces">             </span><span class="nottickedoff">-- and document the non-empty list requirement. See #2096.</span>
<span class="lineno"> 1112 </span><span class="spaces">             </span><span class="nottickedoff">[] -&gt; panic &quot;heapster_typecheck_mut_funs_rename&quot;</span>
<span class="lineno"> 1113 </span><span class="spaces">                         </span><span class="nottickedoff">[ &quot;Unexpected empty list of mutually recursive functions&quot;</span>
<span class="lineno"> 1114 </span><span class="spaces">                         </span><span class="nottickedoff">, &quot;See https://github.com/GaloisInc/saw-script/issues/2096&quot;</span>
<span class="lineno"> 1115 </span><span class="spaces">                         </span><span class="nottickedoff">]</span>
<span class="lineno"> 1116 </span><span class="spaces">     </span><span class="nottickedoff">Some lm &lt;- failOnNothing (&quot;Could not find symbol definition: &quot; &lt;&gt; fst_nm)</span>
<span class="lineno"> 1117 </span><span class="spaces">                              </span><span class="nottickedoff">(lookupModDefiningSym henv fst_nm)</span>
<span class="lineno"> 1118 </span><span class="spaces">     </span><span class="nottickedoff">let w = llvmModuleArchReprWidth lm</span>
<span class="lineno"> 1119 </span><span class="spaces">     </span><span class="nottickedoff">let endianness =</span>
<span class="lineno"> 1120 </span><span class="spaces">           </span><span class="nottickedoff">llvmDataLayout (modTrans lm ^. transContext ^. llvmTypeCtx)</span>
<span class="lineno"> 1121 </span><span class="spaces">           </span><span class="nottickedoff">^. intLayout</span>
<span class="lineno"> 1122 </span><span class="spaces">     </span><span class="nottickedoff">dlevel &lt;- liftIO $ readIORef $ heapsterEnvDebugLevel henv</span>
<span class="lineno"> 1123 </span><span class="spaces">     </span><span class="nottickedoff">checks &lt;- liftIO $ readIORef $ heapsterEnvChecksFlag henv</span>
<span class="lineno"> 1124 </span><span class="spaces">     </span><span class="nottickedoff">LeqProof &lt;- case decideLeq (knownNat @16) w of</span>
<span class="lineno"> 1125 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno"> 1126 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is &lt; 16!&quot;</span>
<span class="lineno"> 1127 </span><span class="spaces">     </span><span class="nottickedoff">LeqProof &lt;- case decideLeq (knownNat @1) w of</span>
<span class="lineno"> 1128 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno"> 1129 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; panic &quot;heapster_typecheck_mut_funs_rename&quot; [&quot;1 &gt; 16!&quot;]</span>
<span class="lineno"> 1130 </span><span class="spaces">     </span><span class="nottickedoff">some_cfgs_and_perms &lt;- forM fn_names_and_perms $ \(nm, nm_to, perms_string) -&gt;</span>
<span class="lineno"> 1131 </span><span class="spaces">       </span><span class="nottickedoff">do let nm' = Text.unpack nm</span>
<span class="lineno"> 1132 </span><span class="spaces">              </span><span class="nottickedoff">nm_to' = Text.unpack nm_to</span>
<span class="lineno"> 1133 </span><span class="spaces">          </span><span class="nottickedoff">AnyCFG cfg &lt;-</span>
<span class="lineno"> 1134 </span><span class="spaces">            </span><span class="nottickedoff">failOnNothing (&quot;Could not find symbol definition: &quot; &lt;&gt; nm) =&lt;&lt;</span>
<span class="lineno"> 1135 </span><span class="spaces">              </span><span class="nottickedoff">io (lookupFunctionCFG lm nm)</span>
<span class="lineno"> 1136 </span><span class="spaces">          </span><span class="nottickedoff">env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno"> 1137 </span><span class="spaces">          </span><span class="nottickedoff">let args = mkCruCtx $ handleArgTypes $ cfgHandle cfg</span>
<span class="lineno"> 1138 </span><span class="spaces">          </span><span class="nottickedoff">let ret = handleReturnType $ cfgHandle cfg</span>
<span class="lineno"> 1139 </span><span class="spaces">          </span><span class="nottickedoff">SomeFunPerm fun_perm &lt;-</span>
<span class="lineno"> 1140 </span><span class="spaces">            </span><span class="nottickedoff">withKnownNat w $</span>
<span class="lineno"> 1141 </span><span class="spaces">            </span><span class="nottickedoff">parseFunPermStringMaybeRust &quot;permissions&quot; w env args ret (Text.unpack perms_string)</span>
<span class="lineno"> 1142 </span><span class="spaces">          </span><span class="nottickedoff">let mods = [ modAST m | Some m &lt;- heapsterEnvLLVMModules henv ]</span>
<span class="lineno"> 1143 </span><span class="spaces">          </span><span class="nottickedoff">hints &lt;- case extractHints env mods fun_perm cfg of</span>
<span class="lineno"> 1144 </span><span class="spaces">            </span><span class="nottickedoff">Left err -&gt; fail (&quot;Error parsing LLVM-level hints: &quot; ++ err)</span>
<span class="lineno"> 1145 </span><span class="spaces">            </span><span class="nottickedoff">Right hints -&gt; return hints</span>
<span class="lineno"> 1146 </span><span class="spaces">          </span><span class="nottickedoff">let env' = foldlFC (\e h -&gt; maybe e (permEnvAddHint e) (getConstant h))</span>
<span class="lineno"> 1147 </span><span class="spaces">                             </span><span class="nottickedoff">env</span>
<span class="lineno"> 1148 </span><span class="spaces">                             </span><span class="nottickedoff">hints</span>
<span class="lineno"> 1149 </span><span class="spaces">          </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span>
<span class="lineno"> 1150 </span><span class="spaces">          </span><span class="nottickedoff">return (SomeCFGAndPerm (GlobalSymbol $</span>
<span class="lineno"> 1151 </span><span class="spaces">                                  </span><span class="nottickedoff">fromString nm') nm_to' cfg fun_perm)</span>
<span class="lineno"> 1152 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno"> 1153 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1154 </span><span class="spaces">     </span><span class="nottickedoff">let saw_modname = heapsterEnvSAWModule henv</span>
<span class="lineno"> 1155 </span><span class="spaces">     </span><span class="nottickedoff">(env', tcfgs) &lt;- liftIO $</span>
<span class="lineno"> 1156 </span><span class="spaces">       </span><span class="nottickedoff">let ?ptrWidth = w in</span>
<span class="lineno"> 1157 </span><span class="spaces">       </span><span class="nottickedoff">tcTranslateAddCFGs sc saw_modname env checks endianness dlevel</span>
<span class="lineno"> 1158 </span><span class="spaces">       </span><span class="nottickedoff">some_cfgs_and_perms</span>
<span class="lineno"> 1159 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvPermEnvRef henv) env'</span>
<span class="lineno"> 1160 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ modifyIORef (heapsterEnvTCFGs henv) (\old -&gt; map Some tcfgs ++ old)</span>
<span class="lineno"> 1161 </span><span class="spaces">     </span><span class="nottickedoff">forM_ fn_names_and_perms $ \(_, nm_to, _) -&gt;</span>
<span class="lineno"> 1162 </span><span class="spaces">       </span><span class="nottickedoff">warnErrs nm_to =&lt;&lt; heapsterFunTrans henv nm_to</span>
<span class="lineno"> 1163 </span><span class="spaces">  </span><span class="nottickedoff">where warnErrs :: Text -&gt; Term -&gt; TopLevel ()</span>
<span class="lineno"> 1164 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asApplyAll -&gt; (asGlobalDef -&gt; Just &quot;SpecM.errorS&quot;,</span>
<span class="lineno"> 1165 </span><span class="spaces">                                    </span><span class="nottickedoff">[_ev, _a, asStringLit -&gt; Just msg]))</span>
<span class="lineno"> 1166 </span><span class="spaces">          </span><span class="nottickedoff">| Just msg_body &lt;- Text.stripPrefix (Text.pack implicationFailurePrefix) msg</span>
<span class="lineno"> 1167 </span><span class="spaces">          </span><span class="nottickedoff">= let pref = &quot;WARNING: Heapster implication failure while typechecking &quot;</span>
<span class="lineno"> 1168 </span><span class="spaces">            </span><span class="nottickedoff">in io $ printOutLn opts Warn $ Text.unpack $ pref &lt;&gt; nm &lt;&gt; &quot;:\n&quot; &lt;&gt; msg_body &lt;&gt; &quot;\n&quot;</span>
<span class="lineno"> 1169 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asLambda -&gt; Just (_, _, t)) = warnErrs nm t</span>
<span class="lineno"> 1170 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asApp -&gt; Just (f, arg)) = warnErrs nm arg &gt;&gt; warnErrs nm f</span>
<span class="lineno"> 1171 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asRecursorApp -&gt; Just (_, _, ixs, arg)) = mapM_ (warnErrs nm) (arg:ixs)</span>
<span class="lineno"> 1172 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asTupleValue -&gt; Just ts) = mapM_ (warnErrs nm) ts</span>
<span class="lineno"> 1173 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asTupleSelector -&gt; Just (t, _)) = warnErrs nm t</span>
<span class="lineno"> 1174 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asRecordValue -&gt; Just ts) = mapM_ (warnErrs nm) ts</span>
<span class="lineno"> 1175 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asRecordSelector -&gt; Just (t, _)) = warnErrs nm t</span>
<span class="lineno"> 1176 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs nm (asArrayValue -&gt; Just (_, ts)) = mapM_ (warnErrs nm) ts</span>
<span class="lineno"> 1177 </span><span class="spaces">        </span><span class="nottickedoff">warnErrs _ _ = return ()</span></span>
<span class="lineno"> 1178 </span>
<span class="lineno"> 1179 </span>
<span class="lineno"> 1180 </span>-- | Type-check a single function against a function permission
<span class="lineno"> 1181 </span>heapster_typecheck_fun :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1182 </span>                          Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 1183 </span><span class="decl"><span class="nottickedoff">heapster_typecheck_fun bic opts henv fn_name perms_string =</span>
<span class="lineno"> 1184 </span><span class="spaces">  </span><span class="nottickedoff">heapster_typecheck_mut_funs bic opts henv [(fn_name, perms_string)]</span></span>
<span class="lineno"> 1185 </span>
<span class="lineno"> 1186 </span>-- | Type-check a single function against a function permission and generate a
<span class="lineno"> 1187 </span>-- SAW core specification with a potentially different name
<span class="lineno"> 1188 </span>heapster_typecheck_fun_rename :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1189 </span>                                 Text -&gt; Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 1190 </span><span class="decl"><span class="nottickedoff">heapster_typecheck_fun_rename bic opts henv fn_name fn_name_to perms_string =</span>
<span class="lineno"> 1191 </span><span class="spaces">  </span><span class="nottickedoff">heapster_typecheck_mut_funs_rename bic opts henv [(fn_name, fn_name_to,</span>
<span class="lineno"> 1192 </span><span class="spaces">                                                     </span><span class="nottickedoff">perms_string)]</span></span>
<span class="lineno"> 1193 </span>
<span class="lineno"> 1194 </span>{-
<span class="lineno"> 1195 </span>heapster_typecheck_fun_rs :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1196 </span>                             String -&gt; String -&gt; TopLevel ()
<span class="lineno"> 1197 </span>heapster_typecheck_fun_rs bic opts henv fn_name perms_string =
<span class="lineno"> 1198 </span>  heapster_typecheck_fun bic opts henv
<span class="lineno"> 1199 </span>
<span class="lineno"> 1200 </span>heapster_typecheck_fun_rename_rs :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1201 </span>                                    String -&gt; String -&gt; String -&gt; TopLevel ()
<span class="lineno"> 1202 </span>heapster_typecheck_fun_rename_rs bic opts henv fn_name fn_name_to perms_string =
<span class="lineno"> 1203 </span>  heapster_typecheck_mut_funs_rename bic opts henv [(fn_name, fn_name_to,
<span class="lineno"> 1204 </span>                                                     perms_string)]
<span class="lineno"> 1205 </span>-}
<span class="lineno"> 1206 </span>
<span class="lineno"> 1207 </span>-- | Set the event type for the remaining Heapster translations
<span class="lineno"> 1208 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1209 </span>heapster_set_event_type :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1210 </span>                           Text -&gt; TopLevel ()
<span class="lineno"> 1211 </span><span class="decl"><span class="nottickedoff">heapster_set_event_type _bic _opts henv term_string =</span>
<span class="lineno"> 1212 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1213 </span><span class="spaces">     </span><span class="nottickedoff">ev_tp &lt;-</span>
<span class="lineno"> 1214 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ completeOpenTerm sc $ dataTypeOpenTerm &quot;SpecM.EvType&quot; []</span>
<span class="lineno"> 1215 </span><span class="spaces">     </span><span class="nottickedoff">ev_id &lt;- parseAndInsDef henv &quot;HeapsterEv&quot; ev_tp (Text.unpack term_string)</span>
<span class="lineno"> 1216 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ modifyIORef' (heapsterEnvPermEnvRef henv) $ \env -&gt;</span>
<span class="lineno"> 1217 </span><span class="spaces">       </span><span class="nottickedoff">env { permEnvEventType = EventType (globalOpenTerm ev_id) }</span></span>
<span class="lineno"> 1218 </span>
<span class="lineno"> 1219 </span>-- | Fetch the SAW core definition associated with a name
<span class="lineno"> 1220 </span>heapsterFunTrans :: HeapsterEnv -&gt; Text -&gt; TopLevel Term
<span class="lineno"> 1221 </span><span class="decl"><span class="nottickedoff">heapsterFunTrans henv fn_name =</span>
<span class="lineno"> 1222 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1223 </span><span class="spaces">     </span><span class="nottickedoff">let saw_modname = heapsterEnvSAWModule henv</span>
<span class="lineno"> 1224 </span><span class="spaces">     </span><span class="nottickedoff">fun_term &lt;-</span>
<span class="lineno"> 1225 </span><span class="spaces">       </span><span class="nottickedoff">fmap (fromJust . defBody) $</span>
<span class="lineno"> 1226 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ scRequireDef sc $ mkSafeIdent saw_modname (Text.unpack fn_name)</span>
<span class="lineno"> 1227 </span><span class="spaces">     </span><span class="nottickedoff">bodies &lt;-</span>
<span class="lineno"> 1228 </span><span class="spaces">       </span><span class="nottickedoff">liftIO $ scResolveName sc $ fn_name &lt;&gt; &quot;__bodies&quot;</span>
<span class="lineno"> 1229 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ scUnfoldConstants sc bodies fun_term &gt;&gt;=</span>
<span class="lineno"> 1230 </span><span class="spaces">              </span><span class="nottickedoff">sawLetMinimize sc &gt;&gt;= betaNormalize sc</span></span>
<span class="lineno"> 1231 </span>
<span class="lineno"> 1232 </span>-- | Fetch the SAW core definition associated with a name and print it
<span class="lineno"> 1233 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1234 </span>heapster_print_fun_trans :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1235 </span>                            Text -&gt; TopLevel ()
<span class="lineno"> 1236 </span><span class="decl"><span class="nottickedoff">heapster_print_fun_trans _bic _opts henv fn_name =</span>
<span class="lineno"> 1237 </span><span class="spaces">  </span><span class="nottickedoff">do pp_opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1238 </span><span class="spaces">     </span><span class="nottickedoff">fun_term &lt;- heapsterFunTrans henv fn_name</span>
<span class="lineno"> 1239 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ putStrLn $ Pretty.scPrettyTerm pp_opts fun_term</span></span>
<span class="lineno"> 1240 </span>
<span class="lineno"> 1241 </span>-- | Export all definitions in the SAW core module associated with a Heapster
<span class="lineno"> 1242 </span>-- environment to a Coq file with the given name
<span class="lineno"> 1243 </span>heapster_export_coq :: HeapsterEnv -&gt; FilePath -&gt; TopLevel ()
<span class="lineno"> 1244 </span><span class="decl"><span class="nottickedoff">heapster_export_coq henv filename =</span>
<span class="lineno"> 1245 </span><span class="spaces">  </span><span class="nottickedoff">do let coq_trans_conf = coqTranslationConfiguration [] []</span>
<span class="lineno"> 1246 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1247 </span><span class="spaces">     </span><span class="nottickedoff">mm &lt;- liftIO $ scGetModuleMap sc</span>
<span class="lineno"> 1248 </span><span class="spaces">     </span><span class="nottickedoff">saw_mod &lt;- liftIO $ scFindModule sc $ heapsterEnvSAWModule henv</span>
<span class="lineno"> 1249 </span><span class="spaces">     </span><span class="nottickedoff">let coq_doc =</span>
<span class="lineno"> 1250 </span><span class="spaces">           </span><span class="nottickedoff">vcat [preamble coq_trans_conf {</span>
<span class="lineno"> 1251 </span><span class="spaces">                   </span><span class="nottickedoff">postPreamble =</span>
<span class="lineno"> 1252 </span><span class="spaces">                       </span><span class="nottickedoff">&quot;From CryptolToCoq Require Import &quot; ++</span>
<span class="lineno"> 1253 </span><span class="spaces">                       </span><span class="nottickedoff">&quot;SAWCorePrelude SpecMPrimitivesForSAWCore SAWCoreBitvectors.\n&quot; },</span>
<span class="lineno"> 1254 </span><span class="spaces">                 </span><span class="nottickedoff">translateSAWModule coq_trans_conf mm saw_mod]</span>
<span class="lineno"> 1255 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ writeFile filename (show coq_doc)</span></span>
<span class="lineno"> 1256 </span>
<span class="lineno"> 1257 </span>-- | Set the Hepaster debug level
<span class="lineno"> 1258 </span>heapster_set_debug_level :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1259 </span>                            Int -&gt; TopLevel ()
<span class="lineno"> 1260 </span><span class="decl"><span class="nottickedoff">heapster_set_debug_level _ _ env l =</span>
<span class="lineno"> 1261 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvDebugLevel env) (DebugLevel l)</span></span>
<span class="lineno"> 1262 </span>
<span class="lineno"> 1263 </span>-- | Turn on or off the translation checks in the Heapster-to-SAW translation
<span class="lineno"> 1264 </span>heapster_set_translation_checks :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1265 </span>                                   Bool -&gt; TopLevel ()
<span class="lineno"> 1266 </span><span class="decl"><span class="nottickedoff">heapster_set_translation_checks _ _ env f =</span>
<span class="lineno"> 1267 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ writeIORef (heapsterEnvChecksFlag env) (ChecksFlag f)</span></span>
<span class="lineno"> 1268 </span>
<span class="lineno"> 1269 </span>-- | Parse a Rust type from an input string, translate it to a Heapster function
<span class="lineno"> 1270 </span>-- permission, and print out that Heapster permission on stdout
<span class="lineno"> 1271 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1272 </span>heapster_translate_rust_type :: BuiltinContext -&gt; Options -&gt; HeapsterEnv -&gt;
<span class="lineno"> 1273 </span>                                Text -&gt; TopLevel ()
<span class="lineno"> 1274 </span><span class="decl"><span class="nottickedoff">heapster_translate_rust_type _bic _opts henv perms_string =</span>
<span class="lineno"> 1275 </span><span class="spaces">  </span><span class="nottickedoff">do env &lt;- liftIO $ readIORef $ heapsterEnvPermEnvRef henv</span>
<span class="lineno"> 1276 </span><span class="spaces">     </span><span class="nottickedoff">let w64 = (knownNat @64::NatRepr 64)</span>
<span class="lineno"> 1277 </span><span class="spaces">     </span><span class="nottickedoff">leq_proof &lt;- case decideLeq (knownNat @1) w64 of</span>
<span class="lineno"> 1278 </span><span class="spaces">       </span><span class="nottickedoff">Left pf -&gt; return pf</span>
<span class="lineno"> 1279 </span><span class="spaces">       </span><span class="nottickedoff">Right _ -&gt; fail &quot;LLVM arch width is 0!&quot;</span>
<span class="lineno"> 1280 </span><span class="spaces">     </span><span class="nottickedoff">withKnownNat w64 $ withLeqProof leq_proof $ do</span>
<span class="lineno"> 1281 </span><span class="spaces">        </span><span class="nottickedoff">Some3FunPerm fun_perm &lt;-</span>
<span class="lineno"> 1282 </span><span class="spaces">          </span><span class="nottickedoff">parseSome3FunPermFromRust env w64 (Text.unpack perms_string)</span>
<span class="lineno"> 1283 </span><span class="spaces">        </span><span class="nottickedoff">liftIO $ putStrLn $ permPrettyString emptyPPInfo fun_perm</span></span>
<span class="lineno"> 1284 </span>
<span class="lineno"> 1285 </span>-- | Parse a Heapster function permission from a 'String' and print it to
<span class="lineno"> 1286 </span>-- stdout, using a particular symbol in an LLVM module as the type of the
<span class="lineno"> 1287 </span>-- function that the permission applies to
<span class="lineno"> 1288 </span>-- XXX why does this take the BuiltinContext and Options if it doesn't use them?
<span class="lineno"> 1289 </span>heapster_parse_test :: BuiltinContext -&gt; Options -&gt; Some LLVMModule -&gt;
<span class="lineno"> 1290 </span>                       Text -&gt; Text -&gt; TopLevel ()
<span class="lineno"> 1291 </span><span class="decl"><span class="nottickedoff">heapster_parse_test _bic _opts _some_lm@(Some lm) fn_name perms_string =</span>
<span class="lineno"> 1292 </span><span class="spaces">  </span><span class="nottickedoff">do let env = heapster_default_env -- FIXME: env should be an argument</span>
<span class="lineno"> 1293 </span><span class="spaces">     </span><span class="nottickedoff">let _arch = llvmModuleArchRepr lm</span>
<span class="lineno"> 1294 </span><span class="spaces">     </span><span class="nottickedoff">AnyCFG cfg &lt;-</span>
<span class="lineno"> 1295 </span><span class="spaces">       </span><span class="nottickedoff">failOnNothing (&quot;Could not find symbol: &quot; &lt;&gt; fn_name) =&lt;&lt;</span>
<span class="lineno"> 1296 </span><span class="spaces">         </span><span class="nottickedoff">io (lookupFunctionCFG lm fn_name)</span>
<span class="lineno"> 1297 </span><span class="spaces">     </span><span class="nottickedoff">let args = mkCruCtx $ handleArgTypes $ cfgHandle cfg</span>
<span class="lineno"> 1298 </span><span class="spaces">     </span><span class="nottickedoff">let ret = handleReturnType $ cfgHandle cfg</span>
<span class="lineno"> 1299 </span><span class="spaces">     </span><span class="nottickedoff">SomeFunPerm fun_perm &lt;- parseFunPermString &quot;permissions&quot; env args</span>
<span class="lineno"> 1300 </span><span class="spaces">                                                </span><span class="nottickedoff">ret (Text.unpack perms_string)</span>
<span class="lineno"> 1301 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ putStrLn $ permPrettyString emptyPPInfo fun_perm</span></span>
<span class="lineno"> 1302 </span>
<span class="lineno"> 1303 </span>-- | Dump the IDE information contained in a Heapster environment to a JSON file
<span class="lineno"> 1304 </span>heapster_dump_ide_info :: HeapsterEnv -&gt; FilePath -&gt; TopLevel ()
<span class="lineno"> 1305 </span><span class="decl"><span class="nottickedoff">heapster_dump_ide_info henv filename = do</span>
<span class="lineno"> 1306 </span><span class="spaces">  </span><span class="nottickedoff">-- heapster_typecheck_mut_funs bic opts henv [(fnName, perms)]</span>
<span class="lineno"> 1307 </span><span class="spaces">  </span><span class="nottickedoff">penv &lt;- io $ readIORef (heapsterEnvPermEnvRef henv)</span>
<span class="lineno"> 1308 </span><span class="spaces">  </span><span class="nottickedoff">tcfgs &lt;- io $ readIORef (heapsterEnvTCFGs henv)</span>
<span class="lineno"> 1309 </span><span class="spaces">  </span><span class="nottickedoff">io $ HIDE.printIDEInfo penv tcfgs filename emptyPPInfo</span></span>

</pre>
</body>
</html>
