<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    2 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    3 </span>
<span class="lineno">    4 </span>{- |
<span class="lineno">    5 </span>Module      : SAWCore.Term.Certified
<span class="lineno">    6 </span>Copyright   : Galois, Inc. 2025
<span class="lineno">    7 </span>License     : BSD3
<span class="lineno">    8 </span>Maintainer  : huffman@galois.com
<span class="lineno">    9 </span>Stability   : experimental
<span class="lineno">   10 </span>Portability : non-portable (language extensions)
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>This module is the interface to the trusted kernel of SAWCore.
<span class="lineno">   13 </span>The API is built around operations in the SAWCore monad, 'SCM'.
<span class="lineno">   14 </span>Such functions are recognized by the @scm@ prefix.
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>The API guarantees that all 'Term's are well-formed and well-typed
<span class="lineno">   17 </span>with respect to the 'SharedContext' they were built with.
<span class="lineno">   18 </span>Attempting to build an invalid 'Term' will result in a failure of type
<span class="lineno">   19 </span>'TermError' being raised in the 'SCM' monad.
<span class="lineno">   20 </span>-}
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>module SAWCore.Term.Certified
<span class="lineno">   23 </span>  ( -- * Terms
<span class="lineno">   24 </span>    SharedContext -- abstract
<span class="lineno">   25 </span>  , Term -- abstract
<span class="lineno">   26 </span>  , TermIndex
<span class="lineno">   27 </span>  , unwrapTermF
<span class="lineno">   28 </span>  , termIndex
<span class="lineno">   29 </span>  , varTypes
<span class="lineno">   30 </span>  , freeVars
<span class="lineno">   31 </span>  , closedTerm
<span class="lineno">   32 </span>  , termSortOrType
<span class="lineno">   33 </span>  , alphaEquiv
<span class="lineno">   34 </span>    -- * Term building monad
<span class="lineno">   35 </span>  , TermError(..)
<span class="lineno">   36 </span>  , SCM
<span class="lineno">   37 </span>  , runSCM
<span class="lineno">   38 </span>    -- * Building certified terms
<span class="lineno">   39 </span>  , scmAscribe
<span class="lineno">   40 </span>  , scmTermF
<span class="lineno">   41 </span>  , scmFlatTermF
<span class="lineno">   42 </span>  , scmApply
<span class="lineno">   43 </span>  , scmLambda
<span class="lineno">   44 </span>  , scmPi
<span class="lineno">   45 </span>  , scmPiList
<span class="lineno">   46 </span>  , scmConst
<span class="lineno">   47 </span>  , scmGlobalDef
<span class="lineno">   48 </span>  , scmVariable
<span class="lineno">   49 </span>  , scmUnitValue
<span class="lineno">   50 </span>  , scmUnitType
<span class="lineno">   51 </span>  , scmPairValue
<span class="lineno">   52 </span>  , scmPairType
<span class="lineno">   53 </span>  , scmPairLeft
<span class="lineno">   54 </span>  , scmPairRight
<span class="lineno">   55 </span>  , scmRecursor
<span class="lineno">   56 </span>  , scmRecordType
<span class="lineno">   57 </span>  , scmRecordValue
<span class="lineno">   58 </span>  , scmRecordSelect
<span class="lineno">   59 </span>  , scmSort
<span class="lineno">   60 </span>  , scmSortWithFlags
<span class="lineno">   61 </span>  , scmNat
<span class="lineno">   62 </span>  , scmVector
<span class="lineno">   63 </span>  , scmString
<span class="lineno">   64 </span>    -- * Typing and reduction
<span class="lineno">   65 </span>  , scmTypeOf
<span class="lineno">   66 </span>  , scmEnsureSortType
<span class="lineno">   67 </span>  , scmWhnf
<span class="lineno">   68 </span>  , scmConvertible
<span class="lineno">   69 </span>  , scmSubtype
<span class="lineno">   70 </span>  , scmInstantiate
<span class="lineno">   71 </span>  , scmInstantiateBeta
<span class="lineno">   72 </span>  , scmApplyAllBeta
<span class="lineno">   73 </span>  , scmReduceRecursor
<span class="lineno">   74 </span>  -- * SharedContext operations
<span class="lineno">   75 </span>  , mkSharedContext
<span class="lineno">   76 </span>  , scGetModuleMap
<span class="lineno">   77 </span>  , scGetNamingEnv
<span class="lineno">   78 </span>  , scmRegisterName
<span class="lineno">   79 </span>  , scmFreshVarName
<span class="lineno">   80 </span>  , scInjectCode
<span class="lineno">   81 </span>  , scmDeclarePrim
<span class="lineno">   82 </span>  , scmFreshConstant
<span class="lineno">   83 </span>  , scmDefineConstant
<span class="lineno">   84 </span>  , scmOpaqueConstant
<span class="lineno">   85 </span>  , DataTypeSpec(..)
<span class="lineno">   86 </span>  , CtorSpec(..)
<span class="lineno">   87 </span>  , scmDefineDataType
<span class="lineno">   88 </span>  , scImportModule
<span class="lineno">   89 </span>  , scLoadModule
<span class="lineno">   90 </span>  , scmFreshName
<span class="lineno">   91 </span>  , scFreshenGlobalIdent
<span class="lineno">   92 </span>  , scResolveNameByURI
<span class="lineno">   93 </span>    -- * Checkpointing
<span class="lineno">   94 </span>  , SharedContextCheckpoint
<span class="lineno">   95 </span>  , checkpointSharedContext
<span class="lineno">   96 </span>  , restoreSharedContext
<span class="lineno">   97 </span>  ) where
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>import Control.Lens
<span class="lineno">  100 </span>import Control.Monad (foldM, forM, join, unless, when)
<span class="lineno">  101 </span>import Control.Monad.Except (ExceptT(..), runExceptT, throwError)
<span class="lineno">  102 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">  103 </span>import Control.Monad.Reader (ReaderT(..), runReaderT, ask)
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>import Data.Bits
<span class="lineno">  106 </span>import qualified Data.Foldable as Fold
<span class="lineno">  107 </span>import Data.Foldable (foldlM, foldrM)
<span class="lineno">  108 </span>import Data.Hashable (Hashable(hash))
<span class="lineno">  109 </span>import Data.HashMap.Strict (HashMap)
<span class="lineno">  110 </span>import qualified Data.HashMap.Strict as HMap
<span class="lineno">  111 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">  112 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">  113 </span>import qualified Data.IntSet as IntSet
<span class="lineno">  114 </span>import Data.IORef (IORef,newIORef,readIORef,modifyIORef',atomicModifyIORef',writeIORef)
<span class="lineno">  115 </span>import Data.List (find)
<span class="lineno">  116 </span>import qualified Data.Map as Map
<span class="lineno">  117 </span>import Data.Map (Map)
<span class="lineno">  118 </span>import Data.Maybe
<span class="lineno">  119 </span>import Data.Ref (C)
<span class="lineno">  120 </span>import Data.Text (Text)
<span class="lineno">  121 </span>import qualified Data.Text as Text
<span class="lineno">  122 </span>import qualified Data.Vector as V
<span class="lineno">  123 </span>import Numeric.Natural (Natural)
<span class="lineno">  124 </span>import Prelude hiding (maximum)
<span class="lineno">  125 </span>import Text.URI
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>import SAWSupport.IntRangeSet (IntRangeSet)
<span class="lineno">  128 </span>import qualified SAWSupport.IntRangeSet as IntRangeSet
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>import SAWCore.Cache
<span class="lineno">  131 </span>import SAWCore.Module
<span class="lineno">  132 </span>  ( dtName
<span class="lineno">  133 </span>  , ctorNumParams
<span class="lineno">  134 </span>  , ctorName
<span class="lineno">  135 </span>  , emptyModuleMap
<span class="lineno">  136 </span>  , moduleIsLoaded
<span class="lineno">  137 </span>  , moduleName
<span class="lineno">  138 </span>  , loadModule
<span class="lineno">  139 </span>  , lookupVarIndexInMap
<span class="lineno">  140 </span>  , insDefInMap
<span class="lineno">  141 </span>  , insInjectCodeInMap
<span class="lineno">  142 </span>  , insImportInMap
<span class="lineno">  143 </span>  , insTypeDeclInMap
<span class="lineno">  144 </span>  , resolvedNameType
<span class="lineno">  145 </span>  , requireNameInMap
<span class="lineno">  146 </span>  , CtorArg(..)
<span class="lineno">  147 </span>  , CtorArgStruct(..)
<span class="lineno">  148 </span>  , Ctor(..)
<span class="lineno">  149 </span>  , DefQualifier(..)
<span class="lineno">  150 </span>  , DataType(..)
<span class="lineno">  151 </span>  , Def(..)
<span class="lineno">  152 </span>  , Module
<span class="lineno">  153 </span>  , ModuleMap
<span class="lineno">  154 </span>  , ResolvedName(..)
<span class="lineno">  155 </span>  )
<span class="lineno">  156 </span>import SAWCore.Name
<span class="lineno">  157 </span>import SAWCore.Panic (panic)
<span class="lineno">  158 </span>import SAWCore.Prelude.Constants
<span class="lineno">  159 </span>import SAWCore.Recognizer
<span class="lineno">  160 </span>import SAWCore.Term.Functor
<span class="lineno">  161 </span>import SAWCore.Term.Raw
<span class="lineno">  162 </span>import SAWCore.Unique
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>----------------------------------------------------------------------
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | Errors that can occur while constructing 'Term's.
<span class="lineno">  167 </span>data TermError
<span class="lineno">  168 </span>  = StaleTerm Term IntRangeSet
<span class="lineno">  169 </span>  | VariableContextMismatch Text VarIndex Term Term
<span class="lineno">  170 </span>  | ApplyNotPiType Term Term -- function, argument
<span class="lineno">  171 </span>  | ApplyNotSubtype Term Term -- expected, arg
<span class="lineno">  172 </span>  | VariableFreeInContext VarName Term
<span class="lineno">  173 </span>  | NotType Term
<span class="lineno">  174 </span>  | NotPairType Term
<span class="lineno">  175 </span>  | NameNotFound Name
<span class="lineno">  176 </span>  | IdentNotFound Ident
<span class="lineno">  177 </span>  | NotRecord Term
<span class="lineno">  178 </span>  | FieldNotFound Term FieldName
<span class="lineno">  179 </span>  | VectorNotSubtype Term Term -- expected type, element
<span class="lineno">  180 </span>  | DataTypeNotFound Name
<span class="lineno">  181 </span>  | RecursorPropElim Name Sort
<span class="lineno">  182 </span>  | ConstantNotClosed Name Term
<span class="lineno">  183 </span>  | DuplicateURI URI
<span class="lineno">  184 </span>  | AlreadyDefined Name
<span class="lineno">  185 </span>  | AscriptionNotSubtype Term Term -- expected type, body
<span class="lineno">  186 </span>  | DataTypeKindNotClosed Name Term
<span class="lineno">  187 </span>  | DataTypeParameterSort Name Sort VarName Term -- dt name, dt sort, param name, param type
<span class="lineno">  188 </span>  | DataTypeIndexSort Name Sort VarName Term -- dt name, dt sort, index name, index type
<span class="lineno">  189 </span>  | DataTypeCtorNotClosed Name Name Term -- dt name, ctor name, ctor type
<span class="lineno">  190 </span>  | DataTypeCtorSort Name Sort Name Term -- dt name, dt sort, ctor name, ctor type
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>----------------------------------------------------------------------
<span class="lineno">  193 </span>-- SAWCore Monad
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>newtype SCM a = SCM (ReaderT SharedContext (ExceptT TermError IO) a)
<span class="lineno">  196 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff">MonadIO</span></span>, <span class="decl"><span class="istickedoff">C</span></span>)
<span class="lineno">  197 </span>
<span class="lineno">  198 </span>scmSharedContext :: SCM SharedContext
<span class="lineno">  199 </span><span class="decl"><span class="istickedoff">scmSharedContext = SCM ask</span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>scmError :: TermError -&gt; SCM a
<span class="lineno">  202 </span><span class="decl"><span class="istickedoff">scmError err = SCM (throwError err)</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>runSCM :: SharedContext -&gt; SCM a -&gt; IO (Either TermError a)
<span class="lineno">  205 </span><span class="decl"><span class="istickedoff">runSCM sc (SCM m) = runExceptT (runReaderT m sc)</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>----------------------------------------------------------------------
<span class="lineno">  208 </span>-- TermFMaps
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>{-
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>Hash-consing story:
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>For scApply, we do a hash-consing lookup in 'appMapTFM' *before*
<span class="lineno">  215 </span>computing the result type (because computing the type may be expensive
<span class="lineno">  216 </span>in some cases). Terms in 'appMapTFM' must have the default type that
<span class="lineno">  217 </span>would normally be computed by scApply.
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>If we don't find the pair of keys in 'appMapTFM', only then do we
<span class="lineno">  220 </span>compute the result type, generate a new TermIndex, create a Term, and
<span class="lineno">  221 </span>then add it to appMapTFM.
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>For anything other than Apply nodes, we compute the type first.
<span class="lineno">  224 </span>(For non-Apply this should usually be fairly cheap to compute.)
<span class="lineno">  225 </span>Then we look up the pair of TermF and type together in hashMapTFM.
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>Terms may have types ascribed to them that are convertible (but not
<span class="lineno">  228 </span>equal) to the type that would have been computed by the typing rules.
<span class="lineno">  229 </span>When constructing an application term with a possibly-modified type,
<span class="lineno">  230 </span>we should do the following:
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>* Look up the TermF and type in hashMapTFM; if an entry is found,
<span class="lineno">  233 </span>  return it.
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>* Look up the two subterms in appMapTFM; if an entry is found *and the
<span class="lineno">  236 </span>  type matches*, then return it.
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>* If an entry with the wrong type was found in appMapTFM, then obtain
<span class="lineno">  239 </span>  a new TermIndex, add a new entry to hashMapTFM, and return the new
<span class="lineno">  240 </span>  term.
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>* If no entry was found in either table, we *could* compute the
<span class="lineno">  243 </span>  expected type for scApply and compare it to the given type to see
<span class="lineno">  244 </span>  which table the new term should go in. This is probably a very
<span class="lineno">  245 </span>  uncommon case.
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>In any case, a type-ascription operation should test for whether the
<span class="lineno">  248 </span>new type is identical to the old type and return the original term if
<span class="lineno">  249 </span>so.
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-}
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>-- | A TermFMap is a data structure used for hash-consing of terms.
<span class="lineno">  254 </span>data TermFMap a
<span class="lineno">  255 </span>  = TermFMap
<span class="lineno">  256 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">appMapTFM</span></span></span> :: !(IntMap (IntMap a))
<span class="lineno">  257 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">hashMapTFM</span></span></span> :: !(HashMap (TermF Term, Either Sort Term) a)
<span class="lineno">  258 </span>  }
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>emptyTFM :: TermFMap a
<span class="lineno">  261 </span><span class="decl"><span class="istickedoff">emptyTFM = TermFMap mempty mempty</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>lookupAppTFM :: Term -&gt; Term -&gt; TermFMap a -&gt; Maybe a
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">lookupAppTFM STApp{stAppIndex = i} STApp{stAppIndex = j} tfm =</span>
<span class="lineno">  265 </span><span class="spaces">  </span><span class="istickedoff">IntMap.lookup i (appMapTFM tfm) &gt;&gt;= IntMap.lookup j</span></span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>insertAppTFM :: Term -&gt; Term -&gt; a -&gt; TermFMap a -&gt; TermFMap a
<span class="lineno">  268 </span><span class="decl"><span class="istickedoff">insertAppTFM STApp{stAppIndex = i} STApp{stAppIndex = j} x tfm =</span>
<span class="lineno">  269 </span><span class="spaces">  </span><span class="istickedoff">let f Nothing = Just (IntMap.singleton j x)</span>
<span class="lineno">  270 </span><span class="spaces">      </span><span class="istickedoff">f (Just m) = Just (IntMap.insert j x m)</span>
<span class="lineno">  271 </span><span class="spaces">  </span><span class="istickedoff">in tfm { appMapTFM = IntMap.alter f i (appMapTFM tfm) }</span></span>
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>lookupTFM :: TermF Term -&gt; Either Sort Term -&gt; TermFMap a -&gt; Maybe a
<span class="lineno">  274 </span><span class="decl"><span class="istickedoff">lookupTFM tf mty tfm =</span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="istickedoff">HMap.lookup (tf, mty) (hashMapTFM tfm)</span></span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>insertTFM :: TermF Term -&gt; Either Sort Term -&gt; a -&gt; TermFMap a -&gt; TermFMap a
<span class="lineno">  278 </span><span class="decl"><span class="istickedoff">insertTFM tf mty x tfm =</span>
<span class="lineno">  279 </span><span class="spaces">  </span><span class="istickedoff">tfm { hashMapTFM = HMap.insert (tf, mty) x (hashMapTFM tfm) }</span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>filterTFM :: (a -&gt; Bool) -&gt; TermFMap a -&gt; TermFMap a
<span class="lineno">  282 </span><span class="decl"><span class="istickedoff">filterTFM p tfm =</span>
<span class="lineno">  283 </span><span class="spaces">  </span><span class="istickedoff">TermFMap</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">{ appMapTFM = IntMap.map (IntMap.filter p) (appMapTFM tfm)</span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="istickedoff">, hashMapTFM = HMap.filter p (hashMapTFM tfm)</span>
<span class="lineno">  286 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>type AppCache = TermFMap Term
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>type AppCacheRef = IORef AppCache
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>emptyAppCache :: AppCache
<span class="lineno">  293 </span><span class="decl"><span class="istickedoff">emptyAppCache = emptyTFM</span></span>
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>----------------------------------------------------------------------
<span class="lineno">  296 </span>-- SharedContext: a high-level interface for building Terms.
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>-- | 'SharedContext' is an abstract datatype representing all the
<span class="lineno">  299 </span>-- information necessary to resolve names and to construct,
<span class="lineno">  300 </span>-- type-check, normalize, and evaluate SAWCore 'Term's.
<span class="lineno">  301 </span>-- A 'SharedContext' contains mutable references so that it can be
<span class="lineno">  302 </span>-- extended at run-time with new names and declarations.
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>-- Invariant: scGlobalEnv is a cache with one entry for every global
<span class="lineno">  305 </span>-- declaration in 'scModuleMap' whose name is a 'ModuleIdentifier'.
<span class="lineno">  306 </span>-- Each map entry points to a 'Constant' term with the same 'Ident'.
<span class="lineno">  307 </span>-- It exists only to save one map lookup when building terms: Without
<span class="lineno">  308 </span>-- it we would first have to look up the Ident by URI in scURIEnv, and
<span class="lineno">  309 </span>-- then do another lookup for hash-consing the Constant term.
<span class="lineno">  310 </span>-- Invariant: All entries in 'scAppCache' must have 'TermIndex'es that
<span class="lineno">  311 </span>-- are less than 'scNextTermIndex' and marked valid in 'scValidTerms'.
<span class="lineno">  312 </span>data SharedContext = SharedContext
<span class="lineno">  313 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">scModuleMap</span></span></span>      :: IORef ModuleMap
<span class="lineno">  314 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scAppCache</span></span></span>       :: AppCacheRef
<span class="lineno">  315 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scDisplayNameEnv</span></span></span> :: IORef DisplayNameEnv
<span class="lineno">  316 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scURIEnv</span></span></span>         :: IORef (Map URI VarIndex)
<span class="lineno">  317 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scGlobalEnv</span></span></span>      :: IORef (HashMap Ident Term)
<span class="lineno">  318 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scNextVarIndex</span></span></span>   :: IORef VarIndex
<span class="lineno">  319 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scNextTermIndex</span></span></span>  :: IORef TermIndex
<span class="lineno">  320 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scValidTerms</span></span></span>     :: IORef IntRangeSet
<span class="lineno">  321 </span>  }
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>-- | Internal function to get the next available 'TermIndex'. Not exported.
<span class="lineno">  324 </span>scmFreshTermIndex :: SCM VarIndex
<span class="lineno">  325 </span><span class="decl"><span class="istickedoff">scmFreshTermIndex =</span>
<span class="lineno">  326 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  327 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ atomicModifyIORef' (scNextTermIndex sc) (\i -&gt; (i + 1, i))</span></span>
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>scmEnsureValidTerm :: Term -&gt; SCM ()
<span class="lineno">  330 </span><span class="decl"><span class="istickedoff">scmEnsureValidTerm t =</span>
<span class="lineno">  331 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  332 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- liftIO $ readIORef (scValidTerms sc)</span>
<span class="lineno">  333 </span><span class="spaces">     </span><span class="istickedoff">unless (IntRangeSet.member (termIndex t) s) $ <span class="nottickedoff">scmError (StaleTerm t s)</span></span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>-- | Internal function to make a 'Term' from a 'TermF' with a given
<span class="lineno">  336 </span>-- variable typing context and type.
<span class="lineno">  337 </span>-- Precondition: The 'Either' argument should never have 'Right'
<span class="lineno">  338 </span>-- applied to a 'Sort'.
<span class="lineno">  339 </span>-- Precondition: All subterms should have been checked with 'scEnsureValidTerm'.
<span class="lineno">  340 </span>scmMakeTerm :: IntMap Term -&gt; TermF Term -&gt; Either Sort Term -&gt; SCM Term
<span class="lineno">  341 </span><span class="decl"><span class="istickedoff">scmMakeTerm vt tf mty =</span>
<span class="lineno">  342 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  343 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- liftIO $ readIORef (scAppCache sc)</span>
<span class="lineno">  344 </span><span class="spaces">     </span><span class="istickedoff">case lookupTFM tf mty s of</span>
<span class="lineno">  345 </span><span class="spaces">       </span><span class="istickedoff">Just term -&gt; pure term</span>
<span class="lineno">  346 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  347 </span><span class="spaces">         </span><span class="istickedoff">do i &lt;- scmFreshTermIndex</span>
<span class="lineno">  348 </span><span class="spaces">            </span><span class="istickedoff">let term = STApp { stAppIndex = i</span>
<span class="lineno">  349 </span><span class="spaces">                             </span><span class="istickedoff">, stAppHash = hash tf</span>
<span class="lineno">  350 </span><span class="spaces">                             </span><span class="istickedoff">, stAppVarTypes = vt</span>
<span class="lineno">  351 </span><span class="spaces">                             </span><span class="istickedoff">, stAppTermF = tf</span>
<span class="lineno">  352 </span><span class="spaces">                             </span><span class="istickedoff">, stAppType = mty</span>
<span class="lineno">  353 </span><span class="spaces">                             </span><span class="istickedoff">}</span>
<span class="lineno">  354 </span><span class="spaces">            </span><span class="istickedoff">liftIO $ modifyIORef' (scAppCache sc) (insertTFM tf mty term)</span>
<span class="lineno">  355 </span><span class="spaces">            </span><span class="istickedoff">pure term</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>--------------------------------------------------------------------------------
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>data SharedContextCheckpoint =
<span class="lineno">  360 </span>  SCC
<span class="lineno">  361 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccModuleMap</span></span></span> :: ModuleMap
<span class="lineno">  362 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccNamingEnv</span></span></span> :: DisplayNameEnv
<span class="lineno">  363 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccURIEnv</span></span></span>    :: Map URI VarIndex
<span class="lineno">  364 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccGlobalEnv</span></span></span> :: HashMap Ident Term
<span class="lineno">  365 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">sccTermIndex</span></span></span> :: TermIndex
<span class="lineno">  366 </span>  }
<span class="lineno">  367 </span>
<span class="lineno">  368 </span>checkpointSharedContext :: SharedContext -&gt; IO SharedContextCheckpoint
<span class="lineno">  369 </span><span class="decl"><span class="istickedoff">checkpointSharedContext sc =</span>
<span class="lineno">  370 </span><span class="spaces">  </span><span class="istickedoff">do mmap &lt;- readIORef (scModuleMap sc)</span>
<span class="lineno">  371 </span><span class="spaces">     </span><span class="istickedoff">nenv &lt;- readIORef (scDisplayNameEnv sc)</span>
<span class="lineno">  372 </span><span class="spaces">     </span><span class="istickedoff">uenv &lt;- readIORef (scURIEnv sc)</span>
<span class="lineno">  373 </span><span class="spaces">     </span><span class="istickedoff">genv &lt;- readIORef (scGlobalEnv sc)</span>
<span class="lineno">  374 </span><span class="spaces">     </span><span class="istickedoff">i &lt;- readIORef (scNextTermIndex sc)</span>
<span class="lineno">  375 </span><span class="spaces">     </span><span class="istickedoff">return SCC</span>
<span class="lineno">  376 </span><span class="spaces">            </span><span class="istickedoff">{ sccModuleMap = <span class="nottickedoff">mmap</span></span>
<span class="lineno">  377 </span><span class="spaces">            </span><span class="istickedoff">, sccNamingEnv = <span class="nottickedoff">nenv</span></span>
<span class="lineno">  378 </span><span class="spaces">            </span><span class="istickedoff">, sccURIEnv = <span class="nottickedoff">uenv</span></span>
<span class="lineno">  379 </span><span class="spaces">            </span><span class="istickedoff">, sccGlobalEnv = <span class="nottickedoff">genv</span></span>
<span class="lineno">  380 </span><span class="spaces">            </span><span class="istickedoff">, sccTermIndex = i</span>
<span class="lineno">  381 </span><span class="spaces">            </span><span class="istickedoff">}</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>restoreSharedContext :: SharedContextCheckpoint -&gt; SharedContext -&gt; IO ()
<span class="lineno">  384 </span><span class="decl"><span class="istickedoff">restoreSharedContext scc sc =</span>
<span class="lineno">  385 </span><span class="spaces">  </span><span class="istickedoff">do -- Ensure that the checkpoint itself is not stale</span>
<span class="lineno">  386 </span><span class="spaces">     </span><span class="istickedoff">let i = sccTermIndex scc</span>
<span class="lineno">  387 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- readIORef (scValidTerms sc)</span>
<span class="lineno">  388 </span><span class="spaces">     </span><span class="istickedoff">unless (IntRangeSet.member i s) $</span>
<span class="lineno">  389 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines $</span></span>
<span class="lineno">  390 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Stale checkpoint encountered: index = &quot; ++ show i</span></span>
<span class="lineno">  391 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, &quot;Valid indexes: &quot; ++ show (IntRangeSet.toList s)</span></span>
<span class="lineno">  392 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="istickedoff">-- Restore saved environments</span>
<span class="lineno">  394 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scModuleMap sc) <span class="nottickedoff">(sccModuleMap scc)</span></span>
<span class="lineno">  395 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scDisplayNameEnv sc) <span class="nottickedoff">(sccNamingEnv scc)</span></span>
<span class="lineno">  396 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scURIEnv sc) <span class="nottickedoff">(sccURIEnv scc)</span></span>
<span class="lineno">  397 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scGlobalEnv sc) <span class="nottickedoff">(sccGlobalEnv scc)</span></span>
<span class="lineno">  398 </span><span class="spaces">     </span><span class="istickedoff">-- Mark 'TermIndex'es created since the checkpoint as invalid</span>
<span class="lineno">  399 </span><span class="spaces">     </span><span class="istickedoff">j &lt;- readIORef (scNextTermIndex sc)</span>
<span class="lineno">  400 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scValidTerms sc) (IntRangeSet.delete (i, j-1))</span>
<span class="lineno">  401 </span><span class="spaces">     </span><span class="istickedoff">-- Filter stale terms from AppCache</span>
<span class="lineno">  402 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scAppCache sc) (filterTFM (\t -&gt; termIndex t &lt; i))</span></span>
<span class="lineno">  403 </span>     -- scNextVarIndex and scNextTermIndex are left untouched
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>--------------------------------------------------------------------------------
<span class="lineno">  406 </span>-- Fundamental term builders
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>-- | Build a variant of a 'Term' with a specific type.
<span class="lineno">  409 </span>-- The first term's type must be a subtype of the second term.
<span class="lineno">  410 </span>scmAscribe :: Term -&gt; Term -&gt; SCM Term
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">scmAscribe t0 ty =</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">do let mty = maybe (Right ty) Left (asSort ty)</span>
<span class="lineno">  413 </span><span class="spaces">     </span><span class="istickedoff">ty0 &lt;- scmTypeOf t0</span>
<span class="lineno">  414 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- scmSharedContext</span>
<span class="lineno">  415 </span><span class="spaces">     </span><span class="istickedoff">ok &lt;- scmSubtype ty0 ty</span>
<span class="lineno">  416 </span><span class="spaces">     </span><span class="istickedoff">unless ok $ <span class="nottickedoff">scmError (AscriptionNotSubtype ty t0)</span></span>
<span class="lineno">  417 </span><span class="spaces">     </span><span class="istickedoff">let tf = unwrapTermF t0</span>
<span class="lineno">  418 </span><span class="spaces">     </span><span class="istickedoff">let fallback = scmMakeTerm (varTypes t0) tf mty</span>
<span class="lineno">  419 </span><span class="spaces">     </span><span class="istickedoff">tfm &lt;- liftIO $ readIORef (scAppCache sc)</span>
<span class="lineno">  420 </span><span class="spaces">     </span><span class="istickedoff">case tf of</span>
<span class="lineno">  421 </span><span class="spaces">       </span><span class="istickedoff">App f arg -&gt;</span>
<span class="lineno">  422 </span><span class="spaces">         </span><span class="istickedoff">case lookupAppTFM f arg tfm of</span>
<span class="lineno">  423 </span><span class="spaces">           </span><span class="istickedoff">Just t' -&gt;</span>
<span class="lineno">  424 </span><span class="spaces">             </span><span class="istickedoff">if fmap termIndex mty == fmap termIndex (termSortOrType t')</span>
<span class="lineno">  425 </span><span class="spaces">             </span><span class="istickedoff">then pure t' else fallback</span>
<span class="lineno">  426 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fallback</span></span>
<span class="lineno">  427 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; fallback</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>-- | Build a new 'Term' value from the given 'TermF'.
<span class="lineno">  430 </span>-- Reuse a 'Term' from the cache if an identical one already exists.
<span class="lineno">  431 </span>scmTermF :: TermF Term -&gt; SCM Term
<span class="lineno">  432 </span><span class="decl"><span class="istickedoff">scmTermF tf =</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  434 </span><span class="spaces">    </span><span class="istickedoff">FTermF ftf -&gt; scmFlatTermF ftf</span>
<span class="lineno">  435 </span><span class="spaces">    </span><span class="istickedoff">App t1 t2 -&gt; scmApply t1 t2</span>
<span class="lineno">  436 </span><span class="spaces">    </span><span class="istickedoff">Lambda x t1 t2 -&gt; scmLambda x t1 t2</span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">Pi x t1 t2 -&gt; scmPi x t1 t2</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">Constant nm -&gt; scmConst nm</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">Variable x t1 -&gt; scmVariable x t1</span></span>
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>-- | Create a new term from a lower-level 'FlatTermF' term.
<span class="lineno">  442 </span>scmFlatTermF :: FlatTermF Term -&gt; SCM Term
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">scmFlatTermF ftf =</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">UnitValue -&gt; scmUnitValue</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">UnitType -&gt; scmUnitType</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">PairValue t1 t2 -&gt; scmPairValue t1 t2</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">PairType t1 t2 -&gt; scmPairType t1 t2</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">PairLeft t -&gt; scmPairLeft t</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff">PairRight t -&gt; scmPairRight t</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">Recursor crec -&gt; scmRecursor (recursorDataType crec) (recursorSort crec)</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">RecordType fs -&gt; scmRecordType fs</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">RecordValue fs -&gt; scmRecordValue fs</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">RecordProj t fname -&gt; scmRecordSelect t fname</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">Sort s flags -&gt; scmSortWithFlags s flags</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue t ts -&gt; scmVector t (V.toList ts)</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">StringLit s -&gt; <span class="nottickedoff">scmString s</span></span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>-- | Create a function application term, or return a 'TermError'.
<span class="lineno">  460 </span>scmApply ::
<span class="lineno">  461 </span>  Term {- ^ The function to apply -} -&gt;
<span class="lineno">  462 </span>  Term {- ^ The argument to apply to -} -&gt;
<span class="lineno">  463 </span>  SCM Term
<span class="lineno">  464 </span><span class="decl"><span class="istickedoff">scmApply t1 t2 =</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="istickedoff">-- Look up this application in the hash table first; if it is</span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="istickedoff">-- already there we can avoid recomputing the result type.</span>
<span class="lineno">  467 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  468 </span><span class="spaces">     </span><span class="istickedoff">tfm &lt;- liftIO $ readIORef (scAppCache sc)</span>
<span class="lineno">  469 </span><span class="spaces">     </span><span class="istickedoff">case lookupAppTFM t1 t2 tfm of</span>
<span class="lineno">  470 </span><span class="spaces">       </span><span class="istickedoff">Just term -&gt; pure term</span>
<span class="lineno">  471 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  472 </span><span class="spaces">         </span><span class="istickedoff">do scmEnsureValidTerm t1</span>
<span class="lineno">  473 </span><span class="spaces">            </span><span class="istickedoff">scmEnsureValidTerm t2</span>
<span class="lineno">  474 </span><span class="spaces">            </span><span class="istickedoff">vt &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scApply&quot;</span> (varTypes t1) (varTypes t2)</span>
<span class="lineno">  475 </span><span class="spaces">            </span><span class="istickedoff">ty1 &lt;- scmTypeOf t1</span>
<span class="lineno">  476 </span><span class="spaces">            </span><span class="istickedoff">(x, ty1a, ty1b) &lt;- scmEnsureRecognizer (ApplyNotPiType t1 t2) asPi ty1</span>
<span class="lineno">  477 </span><span class="spaces">            </span><span class="istickedoff">ty2 &lt;- scmTypeOf t2</span>
<span class="lineno">  478 </span><span class="spaces">            </span><span class="istickedoff">ok &lt;- scmSubtype ty2 ty1a</span>
<span class="lineno">  479 </span><span class="spaces">            </span><span class="istickedoff">unless ok $ scmError (ApplyNotSubtype ty1a t2)</span>
<span class="lineno">  480 </span><span class="spaces">            </span><span class="istickedoff">-- Computing the result type with scmInstantiateBeta may</span>
<span class="lineno">  481 </span><span class="spaces">            </span><span class="istickedoff">-- lead to other calls to scApply, but these should be at</span>
<span class="lineno">  482 </span><span class="spaces">            </span><span class="istickedoff">-- simpler types, so it should always terminate.</span>
<span class="lineno">  483 </span><span class="spaces">            </span><span class="istickedoff">ty &lt;- scmInstantiateBeta (IntMap.singleton (vnIndex x) t2) ty1b</span>
<span class="lineno">  484 </span><span class="spaces">            </span><span class="istickedoff">let mty = maybe (Right ty) Left (asSort ty)</span>
<span class="lineno">  485 </span><span class="spaces">            </span><span class="istickedoff">i &lt;- scmFreshTermIndex</span>
<span class="lineno">  486 </span><span class="spaces">            </span><span class="istickedoff">let tf = App t1 t2</span>
<span class="lineno">  487 </span><span class="spaces">            </span><span class="istickedoff">let term =</span>
<span class="lineno">  488 </span><span class="spaces">                  </span><span class="istickedoff">STApp</span>
<span class="lineno">  489 </span><span class="spaces">                  </span><span class="istickedoff">{ stAppIndex = i</span>
<span class="lineno">  490 </span><span class="spaces">                  </span><span class="istickedoff">, stAppHash = hash tf</span>
<span class="lineno">  491 </span><span class="spaces">                  </span><span class="istickedoff">, stAppVarTypes = vt</span>
<span class="lineno">  492 </span><span class="spaces">                  </span><span class="istickedoff">, stAppTermF = tf</span>
<span class="lineno">  493 </span><span class="spaces">                  </span><span class="istickedoff">, stAppType = mty</span>
<span class="lineno">  494 </span><span class="spaces">                  </span><span class="istickedoff">}</span>
<span class="lineno">  495 </span><span class="spaces">            </span><span class="istickedoff">liftIO $ modifyIORef' (scAppCache sc) (insertAppTFM t1 t2 term)</span>
<span class="lineno">  496 </span><span class="spaces">            </span><span class="istickedoff">pure term</span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | Create a lambda term from a parameter name (as a 'VarName'),
<span class="lineno">  499 </span>-- parameter type (as a 'Term'), and a body ('Term').
<span class="lineno">  500 </span>-- All free variables with the same 'VarName' in the body become
<span class="lineno">  501 </span>-- bound.
<span class="lineno">  502 </span>scmLambda ::
<span class="lineno">  503 </span>  VarName {- ^ The parameter name -} -&gt;
<span class="lineno">  504 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  505 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  506 </span>  SCM Term
<span class="lineno">  507 </span><span class="decl"><span class="istickedoff">scmLambda x t body =</span>
<span class="lineno">  508 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t</span>
<span class="lineno">  509 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureValidTerm body</span>
<span class="lineno">  510 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureNotFreeInContext x body</span>
<span class="lineno">  511 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scLambda&quot;</span> (IntMap.singleton (vnIndex x) t) (varTypes body)</span>
<span class="lineno">  512 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scLambda&quot;</span> (varTypes t) (IntMap.delete (vnIndex x) (varTypes body))</span>
<span class="lineno">  513 </span><span class="spaces">     </span><span class="istickedoff">rty &lt;- scmTypeOf body</span>
<span class="lineno">  514 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scmPi x t rty</span>
<span class="lineno">  515 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt (Lambda x t body) (Right ty)</span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>-- | Create a (possibly dependent) function given a parameter name,
<span class="lineno">  518 </span>-- parameter type (as a 'Term'), and a body ('Term').
<span class="lineno">  519 </span>-- All free variables with the same 'VarName' in the body become
<span class="lineno">  520 </span>-- bound.
<span class="lineno">  521 </span>scmPi ::
<span class="lineno">  522 </span>  VarName {- ^ The parameter name -} -&gt;
<span class="lineno">  523 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  524 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  525 </span>  SCM Term
<span class="lineno">  526 </span><span class="decl"><span class="istickedoff">scmPi x t body =</span>
<span class="lineno">  527 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t</span>
<span class="lineno">  528 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureValidTerm body</span>
<span class="lineno">  529 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureNotFreeInContext x body</span>
<span class="lineno">  530 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scPi&quot;</span> (IntMap.singleton (vnIndex x) t) (varTypes body)</span>
<span class="lineno">  531 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scPi&quot;</span> (varTypes t) (IntMap.delete (vnIndex x) (varTypes body))</span>
<span class="lineno">  532 </span><span class="spaces">     </span><span class="istickedoff">s1 &lt;- scmEnsureSortType t</span>
<span class="lineno">  533 </span><span class="spaces">     </span><span class="istickedoff">s2 &lt;- scmEnsureSortType body</span>
<span class="lineno">  534 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt (Pi x t body) (Left (piSort s1 s2))</span></span>
<span class="lineno">  535 </span>
<span class="lineno">  536 </span>-- | Create a constant 'Term' from a 'Name'.
<span class="lineno">  537 </span>scmConst :: Name -&gt; SCM Term
<span class="lineno">  538 </span><span class="decl"><span class="istickedoff">scmConst nm =</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scmTypeOfName nm</span>
<span class="lineno">  540 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right ty) Left (asSort ty)</span>
<span class="lineno">  541 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm IntMap.empty (Constant nm) mty</span></span>
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>-- | Create a named variable 'Term' from a 'VarName' and a type.
<span class="lineno">  544 </span>scmVariable :: VarName -&gt; Term -&gt; SCM Term
<span class="lineno">  545 </span><span class="decl"><span class="istickedoff">scmVariable x t =</span>
<span class="lineno">  546 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t</span>
<span class="lineno">  547 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scVariable&quot;</span> (IntMap.singleton (vnIndex x) t) (varTypes t)</span>
<span class="lineno">  548 </span><span class="spaces">     </span><span class="istickedoff">_s &lt;- scmEnsureSortType t</span>
<span class="lineno">  549 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right t) Left (asSort t)</span>
<span class="lineno">  550 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt (Variable x t) mty</span></span>
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>-- | Check whether the given 'VarName' occurs free in the type of
<span class="lineno">  553 </span>-- another variable in the context of the given 'Term', and fail if it
<span class="lineno">  554 </span>-- does.
<span class="lineno">  555 </span>scmEnsureNotFreeInContext :: VarName -&gt; Term -&gt; SCM ()
<span class="lineno">  556 </span><span class="decl"><span class="istickedoff">scmEnsureNotFreeInContext x body =</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff">when (any (IntMap.member (vnIndex x) . varTypes) (varTypes body)) $</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">scmError $ VariableFreeInContext x body</span></span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>-- | Two typing contexts are unifiable if they agree perfectly on all
<span class="lineno">  561 </span>-- entries where they overlap.
<span class="lineno">  562 </span>scmUnifyVarTypes :: Text -&gt; IntMap Term -&gt; IntMap Term -&gt; SCM (IntMap Term)
<span class="lineno">  563 </span><span class="decl"><span class="istickedoff">scmUnifyVarTypes msg ctx1 ctx2 =</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="istickedoff">do let check i t1 t2 =</span>
<span class="lineno">  565 </span><span class="spaces">           </span><span class="istickedoff">unless (t1 == t2) $ <span class="nottickedoff">scmError (VariableContextMismatch msg i t1 t2)</span></span>
<span class="lineno">  566 </span><span class="spaces">     </span><span class="istickedoff">sequence_ (IntMap.intersectionWithKey check ctx1 ctx2)</span>
<span class="lineno">  567 </span><span class="spaces">     </span><span class="istickedoff">pure (IntMap.union ctx1 ctx2)</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>scmEnsureRecognizer :: TermError -&gt; (Term -&gt; Maybe a) -&gt; Term -&gt; SCM a
<span class="lineno">  570 </span><span class="decl"><span class="istickedoff">scmEnsureRecognizer err f trm =</span>
<span class="lineno">  571 </span><span class="spaces">  </span><span class="istickedoff">case f trm of</span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="istickedoff">Just a -&gt; pure a</span>
<span class="lineno">  573 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  574 </span><span class="spaces">      </span><span class="istickedoff">do trm' &lt;- scmWhnf trm</span>
<span class="lineno">  575 </span><span class="spaces">         </span><span class="istickedoff">case f trm' of</span>
<span class="lineno">  576 </span><span class="spaces">           </span><span class="istickedoff">Just a -&gt; pure a</span>
<span class="lineno">  577 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; scmError err</span></span>
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>-- | Ensure the type of a 'Term' is a sort, and return that sort.
<span class="lineno">  580 </span>scmEnsureSortType :: Term -&gt; SCM Sort
<span class="lineno">  581 </span><span class="decl"><span class="istickedoff">scmEnsureSortType t =</span>
<span class="lineno">  582 </span><span class="spaces">  </span><span class="istickedoff">case termSortOrType t of</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">Left s -&gt; pure s</span>
<span class="lineno">  584 </span><span class="spaces">    </span><span class="istickedoff">Right ty -&gt; scmEnsureRecognizer (NotType t) asSort ty</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>scmEnsurePairType :: Term -&gt; SCM (Term, Term)
<span class="lineno">  587 </span><span class="decl"><span class="istickedoff">scmEnsurePairType t =</span>
<span class="lineno">  588 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scmTypeOf t</span>
<span class="lineno">  589 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureRecognizer (NotPairType t) asPairType ty</span></span>
<span class="lineno">  590 </span>
<span class="lineno">  591 </span>piSort :: Sort -&gt; Sort -&gt; Sort
<span class="lineno">  592 </span><span class="decl"><span class="istickedoff">piSort s1 s2 = if s2 == propSort then propSort else max s1 s2</span></span>
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>--------------------------------------------------------------------------------
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>-- | Create a function application term from the 'Name' of a global
<span class="lineno">  597 </span>-- constant and a list of 'Term' arguments.
<span class="lineno">  598 </span>scmConstApply :: Name -&gt; [Term] -&gt; SCM Term
<span class="lineno">  599 </span><span class="decl"><span class="istickedoff">scmConstApply i ts =</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="istickedoff">do c &lt;- scmConst i</span>
<span class="lineno">  601 </span><span class="spaces">     </span><span class="istickedoff">scmApplyAll c ts</span></span>
<span class="lineno">  602 </span>
<span class="lineno">  603 </span>-- | Create a list of named variables from a list of names and types.
<span class="lineno">  604 </span>scmVariables :: Traversable t =&gt; t (VarName, Term) -&gt; SCM (t Term)
<span class="lineno">  605 </span><span class="decl"><span class="istickedoff">scmVariables = traverse (\(v, t) -&gt; scmVariable v t)</span></span>
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>-- | Internal function to get the next available 'VarIndex'. Not exported.
<span class="lineno">  608 </span>scmFreshVarIndex :: SCM VarIndex
<span class="lineno">  609 </span><span class="decl"><span class="istickedoff">scmFreshVarIndex =</span>
<span class="lineno">  610 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  611 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ atomicModifyIORef' (scNextVarIndex sc) (\i -&gt; (i + 1, i))</span></span>
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>-- | Internal function to register a name with a caller-provided
<span class="lineno">  614 </span>-- 'VarIndex'. Not exported.
<span class="lineno">  615 </span>scmRegisterNameWithIndex :: VarIndex -&gt; NameInfo -&gt; SCM ()
<span class="lineno">  616 </span><span class="decl"><span class="istickedoff">scmRegisterNameWithIndex i nmi =</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  618 </span><span class="spaces">     </span><span class="istickedoff">uris &lt;- liftIO $ readIORef (scURIEnv sc)</span>
<span class="lineno">  619 </span><span class="spaces">     </span><span class="istickedoff">let uri = nameURI nmi</span>
<span class="lineno">  620 </span><span class="spaces">     </span><span class="istickedoff">when (Map.member uri uris) $ scmError (DuplicateURI uri)</span>
<span class="lineno">  621 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ writeIORef (scURIEnv sc) (Map.insert uri i uris)</span>
<span class="lineno">  622 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ modifyIORef' (scDisplayNameEnv sc) $ extendDisplayNameEnv i (nameAliases nmi)</span></span>
<span class="lineno">  623 </span>
<span class="lineno">  624 </span>-- | Generate a 'Name' with a fresh 'VarIndex' for the given
<span class="lineno">  625 </span>-- 'NameInfo' and register everything together in the naming
<span class="lineno">  626 </span>-- environment of the 'SharedContext'.
<span class="lineno">  627 </span>scmRegisterName :: NameInfo -&gt; SCM Name
<span class="lineno">  628 </span><span class="decl"><span class="istickedoff">scmRegisterName nmi =</span>
<span class="lineno">  629 </span><span class="spaces">  </span><span class="istickedoff">do i &lt;- scmFreshVarIndex</span>
<span class="lineno">  630 </span><span class="spaces">     </span><span class="istickedoff">scmRegisterNameWithIndex i nmi</span>
<span class="lineno">  631 </span><span class="spaces">     </span><span class="istickedoff">pure (Name i nmi)</span></span>
<span class="lineno">  632 </span>
<span class="lineno">  633 </span>scResolveNameByURI :: SharedContext -&gt; URI -&gt; IO (Maybe VarIndex)
<span class="lineno">  634 </span><span class="decl"><span class="istickedoff">scResolveNameByURI sc uri =</span>
<span class="lineno">  635 </span><span class="spaces">  </span><span class="istickedoff">do env &lt;- readIORef (scURIEnv sc)</span>
<span class="lineno">  636 </span><span class="spaces">     </span><span class="istickedoff">pure $! Map.lookup uri env</span></span>
<span class="lineno">  637 </span>
<span class="lineno">  638 </span>-- | Create a unique global name with the given base name.
<span class="lineno">  639 </span>scmFreshName :: Text -&gt; SCM Name
<span class="lineno">  640 </span><span class="decl"><span class="nottickedoff">scmFreshName x =</span>
<span class="lineno">  641 </span><span class="spaces">  </span><span class="nottickedoff">do i &lt;- scmFreshVarIndex</span>
<span class="lineno">  642 </span><span class="spaces">     </span><span class="nottickedoff">let uri = scFreshNameURI x i</span>
<span class="lineno">  643 </span><span class="spaces">     </span><span class="nottickedoff">let nmi = ImportedName uri [x, x &lt;&gt; &quot;#&quot; &lt;&gt;  Text.pack (show i)]</span>
<span class="lineno">  644 </span><span class="spaces">     </span><span class="nottickedoff">scmRegisterNameWithIndex i nmi</span>
<span class="lineno">  645 </span><span class="spaces">     </span><span class="nottickedoff">pure (Name i nmi)</span></span>
<span class="lineno">  646 </span>
<span class="lineno">  647 </span>-- | Create a 'VarName' with the given identifier (which may be &quot;_&quot;).
<span class="lineno">  648 </span>scmFreshVarName :: Text -&gt; SCM VarName
<span class="lineno">  649 </span><span class="decl"><span class="istickedoff">scmFreshVarName x = VarName &lt;$&gt; scmFreshVarIndex &lt;*&gt; pure x</span></span>
<span class="lineno">  650 </span>
<span class="lineno">  651 </span>-- | Returns shared term associated with ident.
<span class="lineno">  652 </span>-- Does not check module namespace.
<span class="lineno">  653 </span>scmGlobalDef :: Ident -&gt; SCM Term
<span class="lineno">  654 </span><span class="decl"><span class="istickedoff">scmGlobalDef ident =</span>
<span class="lineno">  655 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  656 </span><span class="spaces">     </span><span class="istickedoff">m &lt;- liftIO $ readIORef (scGlobalEnv sc)</span>
<span class="lineno">  657 </span><span class="spaces">     </span><span class="istickedoff">case HMap.lookup ident m of</span>
<span class="lineno">  658 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">scmError (IdentNotFound ident)</span></span>
<span class="lineno">  659 </span><span class="spaces">       </span><span class="istickedoff">Just t -&gt; pure t</span></span>
<span class="lineno">  660 </span>
<span class="lineno">  661 </span>-- | Internal function to register an 'Ident' with a 'Term' (which
<span class="lineno">  662 </span>-- must be a 'Constant' term with the same 'Ident') in the
<span class="lineno">  663 </span>-- 'scGlobalEnv' map of the 'SharedContext'. Not exported.
<span class="lineno">  664 </span>scmRegisterGlobal :: Ident -&gt; Term -&gt; SCM ()
<span class="lineno">  665 </span><span class="decl"><span class="istickedoff">scmRegisterGlobal ident t =</span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  667 </span><span class="spaces">     </span><span class="istickedoff">dup &lt;- liftIO $ atomicModifyIORef' (scGlobalEnv sc) f</span>
<span class="lineno">  668 </span><span class="spaces">     </span><span class="istickedoff">when dup $ <span class="nottickedoff">scmError (DuplicateURI (moduleIdentToURI ident))</span></span>
<span class="lineno">  669 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  670 </span><span class="spaces">    </span><span class="istickedoff">f m =</span>
<span class="lineno">  671 </span><span class="spaces">      </span><span class="istickedoff">case HMap.lookup ident m of</span>
<span class="lineno">  672 </span><span class="spaces">        </span><span class="istickedoff">Just _ -&gt; <span class="nottickedoff">(m, True)</span></span>
<span class="lineno">  673 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; (HMap.insert ident t m, False)</span></span>
<span class="lineno">  674 </span>
<span class="lineno">  675 </span>-- | Find a variant of an identifier that is not already being used as a global,
<span class="lineno">  676 </span>-- by possibly adding a numeric suffix
<span class="lineno">  677 </span>scFreshenGlobalIdent :: SharedContext -&gt; Ident -&gt; IO Ident
<span class="lineno">  678 </span><span class="decl"><span class="nottickedoff">scFreshenGlobalIdent sc ident =</span>
<span class="lineno">  679 </span><span class="spaces">  </span><span class="nottickedoff">readIORef (scGlobalEnv sc) &gt;&gt;= \gmap -&gt;</span>
<span class="lineno">  680 </span><span class="spaces">  </span><span class="nottickedoff">return $ fromJust $ find (\i -&gt; not $ HMap.member i gmap) $</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="nottickedoff">ident : map (mkIdent (identModule ident) .</span>
<span class="lineno">  682 </span><span class="spaces">               </span><span class="nottickedoff">Text.append (identBaseName ident) .</span>
<span class="lineno">  683 </span><span class="spaces">               </span><span class="nottickedoff">Text.pack . show) [(0::Integer) ..]</span></span>
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>-- | Get the current naming environment
<span class="lineno">  686 </span>scGetNamingEnv :: SharedContext -&gt; IO DisplayNameEnv
<span class="lineno">  687 </span><span class="decl"><span class="istickedoff">scGetNamingEnv sc = readIORef (scDisplayNameEnv sc)</span></span>
<span class="lineno">  688 </span>
<span class="lineno">  689 </span>-- | Get the current 'ModuleMap'
<span class="lineno">  690 </span>scGetModuleMap :: SharedContext -&gt; IO ModuleMap
<span class="lineno">  691 </span><span class="decl"><span class="istickedoff">scGetModuleMap sc = readIORef (scModuleMap sc)</span></span>
<span class="lineno">  692 </span>
<span class="lineno">  693 </span>-- | Get the current 'ModuleMap'
<span class="lineno">  694 </span>scmGetModuleMap :: SCM ModuleMap
<span class="lineno">  695 </span><span class="decl"><span class="istickedoff">scmGetModuleMap =</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  697 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ readIORef (scModuleMap sc)</span></span>
<span class="lineno">  698 </span>
<span class="lineno">  699 </span>-- | Test if a module is loaded in the current shared context
<span class="lineno">  700 </span>scModuleIsLoaded :: SharedContext -&gt; ModuleName -&gt; IO Bool
<span class="lineno">  701 </span><span class="decl"><span class="istickedoff">scModuleIsLoaded sc name =</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="istickedoff">moduleIsLoaded name &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  703 </span>
<span class="lineno">  704 </span>-- | Load a module into the current shared context, raising an error if a module
<span class="lineno">  705 </span>-- of the same name is already loaded
<span class="lineno">  706 </span>scLoadModule :: SharedContext -&gt; Module -&gt; IO ()
<span class="lineno">  707 </span><span class="decl"><span class="istickedoff">scLoadModule sc m =</span>
<span class="lineno">  708 </span><span class="spaces">  </span><span class="istickedoff">do loaded &lt;- scModuleIsLoaded sc (moduleName m)</span>
<span class="lineno">  709 </span><span class="spaces">     </span><span class="istickedoff">when loaded $ <span class="nottickedoff">fail $ &quot;scLoadModule: module &quot;</span></span>
<span class="lineno">  710 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">++ show (moduleName m) ++ &quot; already loaded!&quot;</span></span>
<span class="lineno">  711 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scModuleMap sc) (loadModule m)</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>-- | Bring a subset of names from one module into scope in a second module.
<span class="lineno">  714 </span>scImportModule ::
<span class="lineno">  715 </span>  SharedContext -&gt;
<span class="lineno">  716 </span>  (Text -&gt; Bool) {- ^ which names to import -} -&gt;
<span class="lineno">  717 </span>  ModuleName {- ^ from this module -} -&gt;
<span class="lineno">  718 </span>  ModuleName {- ^ into this module -} -&gt;
<span class="lineno">  719 </span>  IO ()
<span class="lineno">  720 </span><span class="decl"><span class="istickedoff">scImportModule sc p mn1 mn2 =</span>
<span class="lineno">  721 </span><span class="spaces">  </span><span class="istickedoff">modifyIORef' (scModuleMap sc) (insImportInMap p mn1 mn2)</span></span>
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>-- | Internal function to insert a definition into the 'ModuleMap' of
<span class="lineno">  724 </span>-- the 'SharedContext'.
<span class="lineno">  725 </span>-- Throws an exception if the name is already registered.
<span class="lineno">  726 </span>scmInsDefInMap :: Def -&gt; SCM ()
<span class="lineno">  727 </span><span class="decl"><span class="istickedoff">scmInsDefInMap d =</span>
<span class="lineno">  728 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  729 </span><span class="spaces">     </span><span class="istickedoff">e &lt;-</span>
<span class="lineno">  730 </span><span class="spaces">       </span><span class="istickedoff">liftIO $ atomicModifyIORef' (scModuleMap sc) $ \mm -&gt;</span>
<span class="lineno">  731 </span><span class="spaces">       </span><span class="istickedoff">case insDefInMap d mm of</span>
<span class="lineno">  732 </span><span class="spaces">         </span><span class="istickedoff">Left nm -&gt; <span class="nottickedoff">(mm, Just (AlreadyDefined nm))</span></span>
<span class="lineno">  733 </span><span class="spaces">         </span><span class="istickedoff">Right mm' -&gt; (mm', Nothing)</span>
<span class="lineno">  734 </span><span class="spaces">     </span><span class="istickedoff">maybe (pure <span class="nottickedoff">()</span>) <span class="nottickedoff">scmError</span> e</span></span>
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>-- | Internal function to extend the SAWCore global environment with a
<span class="lineno">  737 </span>-- new constant, which may or may not have a definition. Not exported.
<span class="lineno">  738 </span>-- Assumes that the type and body (if present) are closed terms, and
<span class="lineno">  739 </span>-- that the body has the given type.
<span class="lineno">  740 </span>scmDeclareDef :: Name -&gt; DefQualifier -&gt; Term -&gt; Maybe Term -&gt; SCM Term
<span class="lineno">  741 </span><span class="decl"><span class="istickedoff">scmDeclareDef nm q ty body =</span>
<span class="lineno">  742 </span><span class="spaces">  </span><span class="istickedoff">do scmInsDefInMap $</span>
<span class="lineno">  743 </span><span class="spaces">       </span><span class="istickedoff">Def</span>
<span class="lineno">  744 </span><span class="spaces">       </span><span class="istickedoff">{ defName = nm</span>
<span class="lineno">  745 </span><span class="spaces">       </span><span class="istickedoff">, defQualifier = <span class="nottickedoff">q</span></span>
<span class="lineno">  746 </span><span class="spaces">       </span><span class="istickedoff">, defType = ty</span>
<span class="lineno">  747 </span><span class="spaces">       </span><span class="istickedoff">, defBody = body</span>
<span class="lineno">  748 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno">  749 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- scmConst nm</span>
<span class="lineno">  750 </span><span class="spaces">     </span><span class="istickedoff">-- Register constant in scGlobalEnv if it has an Ident name</span>
<span class="lineno">  751 </span><span class="spaces">     </span><span class="istickedoff">case nameInfo nm of</span>
<span class="lineno">  752 </span><span class="spaces">       </span><span class="istickedoff">ModuleIdentifier ident -&gt; scmRegisterGlobal ident t</span>
<span class="lineno">  753 </span><span class="spaces">       </span><span class="istickedoff">ImportedName{} -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  754 </span><span class="spaces">     </span><span class="istickedoff">pure t</span></span>
<span class="lineno">  755 </span>
<span class="lineno">  756 </span>-- | Declare a SAW core primitive of the specified type.
<span class="lineno">  757 </span>scmDeclarePrim :: Ident -&gt; DefQualifier -&gt; Term -&gt; SCM ()
<span class="lineno">  758 </span><span class="decl"><span class="istickedoff">scmDeclarePrim ident q def_tp =</span>
<span class="lineno">  759 </span><span class="spaces">  </span><span class="istickedoff">do _ &lt;- scmEnsureSortType def_tp</span>
<span class="lineno">  760 </span><span class="spaces">     </span><span class="istickedoff">let nmi = ModuleIdentifier ident</span>
<span class="lineno">  761 </span><span class="spaces">     </span><span class="istickedoff">nm &lt;- scmRegisterName nmi</span>
<span class="lineno">  762 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- scmDeclareDef nm <span class="nottickedoff">q</span> def_tp Nothing</span>
<span class="lineno">  763 </span><span class="spaces">     </span><span class="istickedoff">pure <span class="nottickedoff">()</span></span></span>
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>-- Internal function
<span class="lineno">  766 </span>scmFindDefBody :: VarIndex -&gt; SCM (Maybe Term)
<span class="lineno">  767 </span><span class="decl"><span class="istickedoff">scmFindDefBody vi =</span>
<span class="lineno">  768 </span><span class="spaces">  </span><span class="istickedoff">do mm &lt;- scmGetModuleMap</span>
<span class="lineno">  769 </span><span class="spaces">     </span><span class="istickedoff">case lookupVarIndexInMap vi mm of</span>
<span class="lineno">  770 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedDef d) -&gt; pure (defBody d)</span>
<span class="lineno">  771 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; pure Nothing</span></span>
<span class="lineno">  772 </span>
<span class="lineno">  773 </span>-- | Insert an \&quot;injectCode\&quot; declaration to the given SAWCore module.
<span class="lineno">  774 </span>-- This declaration has no logical effect within SAW; it is used to
<span class="lineno">  775 </span>-- add extra code (like class instance declarations, for example) to
<span class="lineno">  776 </span>-- exported SAWCore modules in certain translation backends.
<span class="lineno">  777 </span>scInjectCode ::
<span class="lineno">  778 </span>  SharedContext -&gt;
<span class="lineno">  779 </span>  ModuleName -&gt;
<span class="lineno">  780 </span>  Text {- ^ Code namespace -} -&gt;
<span class="lineno">  781 </span>  Text {- ^ Code to inject -} -&gt;
<span class="lineno">  782 </span>  IO ()
<span class="lineno">  783 </span><span class="decl"><span class="istickedoff">scInjectCode sc mnm ns txt =</span>
<span class="lineno">  784 </span><span class="spaces">  </span><span class="istickedoff">modifyIORef' (scModuleMap sc) $ insInjectCodeInMap mnm <span class="nottickedoff">ns</span> <span class="nottickedoff">txt</span></span></span>
<span class="lineno">  785 </span>
<span class="lineno">  786 </span>--------------------------------------------------------------------------------
<span class="lineno">  787 </span>-- Data Types
<span class="lineno">  788 </span>
<span class="lineno">  789 </span>data DataTypeSpec =
<span class="lineno">  790 </span>  DataTypeSpec
<span class="lineno">  791 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsNameInfo</span></span></span> :: NameInfo
<span class="lineno">  792 </span>    -- ^ The name of this data type
<span class="lineno">  793 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsParams</span></span></span> :: [(VarName, Term)]
<span class="lineno">  794 </span>    -- ^ The context of parameters of this data type.
<span class="lineno">  795 </span>    -- Earlier variable names in the list are in scope.
<span class="lineno">  796 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsIndices</span></span></span> :: [(VarName, Term)]
<span class="lineno">  797 </span>    -- ^ The context of indices of this data type.
<span class="lineno">  798 </span>    -- Earlier variable names and 'dtsParams' are in scope.
<span class="lineno">  799 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsSort</span></span></span> :: Sort
<span class="lineno">  800 </span>    -- ^ The universe of this data type.
<span class="lineno">  801 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsCtors</span></span></span> :: [CtorSpec]
<span class="lineno">  802 </span>    -- ^ The list of constructors of this data type.
<span class="lineno">  803 </span>    -- Variables from 'dtsParams' are in scope.
<span class="lineno">  804 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsMotiveName</span></span></span> :: VarName
<span class="lineno">  805 </span>    -- ^ Variable name to use for the motive parameter of the recursor.
<span class="lineno">  806 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">dtsArgName</span></span></span> :: VarName
<span class="lineno">  807 </span>    -- ^ Variable name to use for the data argument of the recursor.
<span class="lineno">  808 </span>  }
<span class="lineno">  809 </span>
<span class="lineno">  810 </span>data CtorSpec =
<span class="lineno">  811 </span>  CtorSpec
<span class="lineno">  812 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">cspecNameInfo</span></span></span> :: NameInfo
<span class="lineno">  813 </span>    -- ^ The name of this constructor
<span class="lineno">  814 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">cspecArgs</span></span></span> :: [(VarName, CtorArg)]
<span class="lineno">  815 </span>    -- ^ The argument types of this constructor.
<span class="lineno">  816 </span>    -- Earlier variables and 'dtsParams' (from the enclosing
<span class="lineno">  817 </span>    -- 'DataTypeSpec') are in scope.
<span class="lineno">  818 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">cspecIndices</span></span></span> :: [Term]
<span class="lineno">  819 </span>    -- ^ The indices of the result type of this constructor.
<span class="lineno">  820 </span>    -- Variables from 'dtsParams' (in the enclosing 'DataTypeSpec')
<span class="lineno">  821 </span>    -- and 'cspecArgs' are in scope.
<span class="lineno">  822 </span>  }
<span class="lineno">  823 </span>
<span class="lineno">  824 </span>-- | Define a new data type with constructors in the global context.
<span class="lineno">  825 </span>-- Return the type constructor and data constructors as 'Term's.
<span class="lineno">  826 </span>-- Throw an error if the data type declaration is not well-formed:
<span class="lineno">  827 </span>-- Parameters, indices and constructor arguments must refer only to
<span class="lineno">  828 </span>-- bound variables and inhabit the appropriate sorts.
<span class="lineno">  829 </span>scmDefineDataType :: DataTypeSpec -&gt; SCM (Term, [Term])
<span class="lineno">  830 </span><span class="decl"><span class="istickedoff">scmDefineDataType dts =</span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="istickedoff">do dName &lt;- scmRegisterName (dtsNameInfo dts)</span>
<span class="lineno">  832 </span><span class="spaces">     </span><span class="istickedoff">-- Enforce that sorts of dtsParams do not exceed dtsSort</span>
<span class="lineno">  833 </span><span class="spaces">     </span><span class="istickedoff">let checkParam (x, ty) =</span>
<span class="lineno">  834 </span><span class="spaces">           </span><span class="istickedoff">do paramSort &lt;- scmEnsureSortType ty</span>
<span class="lineno">  835 </span><span class="spaces">              </span><span class="istickedoff">unless (paramSort &lt;= sortOf (dtsSort dts)) $</span>
<span class="lineno">  836 </span><span class="spaces">                </span><span class="istickedoff">scmError (DataTypeParameterSort dName (dtsSort dts) x ty)</span>
<span class="lineno">  837 </span><span class="spaces">     </span><span class="istickedoff">unless (dtsSort dts == PropSort) $ mapM_ checkParam (dtsParams dts)</span>
<span class="lineno">  838 </span><span class="spaces">     </span><span class="istickedoff">-- Enforce that sorts of dtsIndices are strictly contained in dtsSort</span>
<span class="lineno">  839 </span><span class="spaces">     </span><span class="istickedoff">let checkIndex (x, ty) =</span>
<span class="lineno">  840 </span><span class="spaces">           </span><span class="istickedoff">do indexSort &lt;- scmEnsureSortType ty</span>
<span class="lineno">  841 </span><span class="spaces">              </span><span class="istickedoff">unless (indexSort &lt;= dtsSort dts) $</span>
<span class="lineno">  842 </span><span class="spaces">                </span><span class="istickedoff">scmError (DataTypeIndexSort dName (dtsSort dts) x ty)</span>
<span class="lineno">  843 </span><span class="spaces">     </span><span class="istickedoff">unless (dtsSort dts == PropSort) $ mapM_ checkIndex (dtsIndices dts)</span>
<span class="lineno">  844 </span><span class="spaces">     </span><span class="istickedoff">-- Construct the kind of the data type</span>
<span class="lineno">  845 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- scmSort (dtsSort dts)</span>
<span class="lineno">  846 </span><span class="spaces">     </span><span class="istickedoff">dType &lt;- scmPiList (dtsParams dts ++ dtsIndices dts) s</span>
<span class="lineno">  847 </span><span class="spaces">     </span><span class="istickedoff">-- Enforce that dType has no free variables.</span>
<span class="lineno">  848 </span><span class="spaces">     </span><span class="istickedoff">unless (closedTerm dType) $</span>
<span class="lineno">  849 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">scmError (DataTypeKindNotClosed dName dType)</span></span>
<span class="lineno">  850 </span><span class="spaces">     </span><span class="istickedoff">-- NOTE: We can't use 'scmConst' with 'dName' because we haven't yet</span>
<span class="lineno">  851 </span><span class="spaces">     </span><span class="istickedoff">-- registered the name with its definition in the global context.</span>
<span class="lineno">  852 </span><span class="spaces">     </span><span class="istickedoff">-- We need to use the internal function 'scmMakeTerm' instead.</span>
<span class="lineno">  853 </span><span class="spaces">     </span><span class="istickedoff">let dSortOrType = maybe (Right dType) Left (asSort dType)</span>
<span class="lineno">  854 </span><span class="spaces">     </span><span class="istickedoff">d &lt;- scmMakeTerm IntMap.empty (Constant dName) dSortOrType</span>
<span class="lineno">  855 </span><span class="spaces">            </span><span class="istickedoff">-- | DataTypeKindNotClosed Name Term</span>
<span class="lineno">  856 </span><span class="spaces">     </span><span class="istickedoff">params &lt;- scmVariables (dtsParams dts)</span>
<span class="lineno">  857 </span><span class="spaces">     </span><span class="istickedoff">d_params &lt;- scmApplyAll d params</span>
<span class="lineno">  858 </span><span class="spaces">     </span><span class="istickedoff">let ctorArgType :: CtorArg -&gt; SCM Term</span>
<span class="lineno">  859 </span><span class="spaces">         </span><span class="istickedoff">ctorArgType (ConstArg tp) = pure tp</span>
<span class="lineno">  860 </span><span class="spaces">         </span><span class="istickedoff">ctorArgType (RecursiveArg zs ixs) =</span>
<span class="lineno">  861 </span><span class="spaces">           </span><span class="istickedoff">scmPiList zs =&lt;&lt; scmApplyAll d_params ixs</span>
<span class="lineno">  862 </span><span class="spaces">     </span><span class="istickedoff">let ctorSpecType :: Name -&gt; CtorSpec -&gt; SCM Term</span>
<span class="lineno">  863 </span><span class="spaces">         </span><span class="istickedoff">ctorSpecType cName cspec =</span>
<span class="lineno">  864 </span><span class="spaces">           </span><span class="istickedoff">do d_params_ixs &lt;- scmApplyAll d_params (cspecIndices cspec)</span>
<span class="lineno">  865 </span><span class="spaces">              </span><span class="istickedoff">bs &lt;- traverse (traverse ctorArgType) (cspecArgs cspec)</span>
<span class="lineno">  866 </span><span class="spaces">              </span><span class="istickedoff">body &lt;- scmPiList bs d_params_ixs</span>
<span class="lineno">  867 </span><span class="spaces">              </span><span class="istickedoff">-- Enforce that the type of body is contained in dtsSort</span>
<span class="lineno">  868 </span><span class="spaces">              </span><span class="istickedoff">cSort &lt;- scmEnsureSortType body</span>
<span class="lineno">  869 </span><span class="spaces">              </span><span class="istickedoff">unless (cSort &lt;= dtsSort dts) $</span>
<span class="lineno">  870 </span><span class="spaces">                </span><span class="istickedoff">scmError (DataTypeCtorSort dName (dtsSort dts) cName body)</span>
<span class="lineno">  871 </span><span class="spaces">              </span><span class="istickedoff">-- Build constructor type</span>
<span class="lineno">  872 </span><span class="spaces">              </span><span class="istickedoff">scmPiList (dtsParams dts) body</span>
<span class="lineno">  873 </span><span class="spaces">     </span><span class="istickedoff">let makeCtor :: CtorSpec -&gt; SCM Ctor</span>
<span class="lineno">  874 </span><span class="spaces">         </span><span class="istickedoff">makeCtor cs =</span>
<span class="lineno">  875 </span><span class="spaces">           </span><span class="istickedoff">do cName &lt;- scmRegisterName (cspecNameInfo cs)</span>
<span class="lineno">  876 </span><span class="spaces">              </span><span class="istickedoff">cType &lt;- ctorSpecType cName cs</span>
<span class="lineno">  877 </span><span class="spaces">              </span><span class="istickedoff">-- Enforce that cType is closed.</span>
<span class="lineno">  878 </span><span class="spaces">              </span><span class="istickedoff">unless (closedTerm cType) $</span>
<span class="lineno">  879 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">scmError (DataTypeCtorNotClosed dName cName cType)</span></span>
<span class="lineno">  880 </span><span class="spaces">              </span><span class="istickedoff">pure $</span>
<span class="lineno">  881 </span><span class="spaces">                </span><span class="istickedoff">Ctor</span>
<span class="lineno">  882 </span><span class="spaces">                </span><span class="istickedoff">{ ctorName = cName</span>
<span class="lineno">  883 </span><span class="spaces">                </span><span class="istickedoff">, ctorArgStruct =</span>
<span class="lineno">  884 </span><span class="spaces">                  </span><span class="istickedoff">CtorArgStruct</span>
<span class="lineno">  885 </span><span class="spaces">                  </span><span class="istickedoff">{ ctorParams = dtsParams dts</span>
<span class="lineno">  886 </span><span class="spaces">                  </span><span class="istickedoff">, ctorArgs = cspecArgs cs</span>
<span class="lineno">  887 </span><span class="spaces">                  </span><span class="istickedoff">, ctorIndices = cspecIndices cs</span>
<span class="lineno">  888 </span><span class="spaces">                  </span><span class="istickedoff">}</span>
<span class="lineno">  889 </span><span class="spaces">                </span><span class="istickedoff">, ctorDataType = dName</span>
<span class="lineno">  890 </span><span class="spaces">                </span><span class="istickedoff">, ctorType = cType</span>
<span class="lineno">  891 </span><span class="spaces">                </span><span class="istickedoff">}</span>
<span class="lineno">  892 </span><span class="spaces">     </span><span class="istickedoff">ctors &lt;- traverse makeCtor (dtsCtors dts)</span>
<span class="lineno">  893 </span><span class="spaces">     </span><span class="istickedoff">let dt =</span>
<span class="lineno">  894 </span><span class="spaces">           </span><span class="istickedoff">DataType</span>
<span class="lineno">  895 </span><span class="spaces">           </span><span class="istickedoff">{ dtName = dName</span>
<span class="lineno">  896 </span><span class="spaces">           </span><span class="istickedoff">, dtParams = dtsParams dts</span>
<span class="lineno">  897 </span><span class="spaces">           </span><span class="istickedoff">, dtIndices = dtsIndices dts</span>
<span class="lineno">  898 </span><span class="spaces">           </span><span class="istickedoff">, dtSort = dtsSort dts</span>
<span class="lineno">  899 </span><span class="spaces">           </span><span class="istickedoff">, dtCtors = ctors</span>
<span class="lineno">  900 </span><span class="spaces">           </span><span class="istickedoff">, dtType = dType</span>
<span class="lineno">  901 </span><span class="spaces">           </span><span class="istickedoff">, dtMotiveName = dtsMotiveName dts</span>
<span class="lineno">  902 </span><span class="spaces">           </span><span class="istickedoff">, dtArgName = dtsArgName dts</span>
<span class="lineno">  903 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno">  904 </span><span class="spaces">     </span><span class="istickedoff">-- Register the data type in the ModuleMap.</span>
<span class="lineno">  905 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- scmSharedContext</span>
<span class="lineno">  906 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ modifyIORef' (scModuleMap sc) $ \mm -&gt;</span>
<span class="lineno">  907 </span><span class="spaces">       </span><span class="istickedoff">case insTypeDeclInMap dt mm of</span>
<span class="lineno">  908 </span><span class="spaces">         </span><span class="istickedoff">-- This should never happen; duplicate names are detected by scRegisterName.</span>
<span class="lineno">  909 </span><span class="spaces">         </span><span class="istickedoff">Left nm -&gt; <span class="nottickedoff">panic &quot;scmDefineDataType&quot; [&quot;Duplicate name: &quot; &lt;&gt; toAbsoluteName (nameInfo nm)]</span></span>
<span class="lineno">  910 </span><span class="spaces">         </span><span class="istickedoff">Right mm' -&gt; mm'</span>
<span class="lineno">  911 </span><span class="spaces">     </span><span class="istickedoff">-- Register data type constant in scGlobalEnv if it has an Ident name.</span>
<span class="lineno">  912 </span><span class="spaces">     </span><span class="istickedoff">case dtsNameInfo dts of</span>
<span class="lineno">  913 </span><span class="spaces">       </span><span class="istickedoff">ImportedName{} -&gt; <span class="nottickedoff">pure ()</span></span>
<span class="lineno">  914 </span><span class="spaces">       </span><span class="istickedoff">ModuleIdentifier i -&gt; scmRegisterGlobal i d</span>
<span class="lineno">  915 </span><span class="spaces">     </span><span class="istickedoff">-- Register constructors in scGlobalEnv if they have Ident names.</span>
<span class="lineno">  916 </span><span class="spaces">     </span><span class="istickedoff">cs &lt;-</span>
<span class="lineno">  917 </span><span class="spaces">       </span><span class="istickedoff">forM ctors $ \ctor -&gt;</span>
<span class="lineno">  918 </span><span class="spaces">       </span><span class="istickedoff">do c &lt;- scmConst (ctorName ctor)</span>
<span class="lineno">  919 </span><span class="spaces">          </span><span class="istickedoff">case nameInfo (ctorName ctor) of</span>
<span class="lineno">  920 </span><span class="spaces">            </span><span class="istickedoff">ImportedName{} -&gt; <span class="nottickedoff">pure ()</span></span>
<span class="lineno">  921 </span><span class="spaces">            </span><span class="istickedoff">ModuleIdentifier i -&gt; scmRegisterGlobal i c</span>
<span class="lineno">  922 </span><span class="spaces">          </span><span class="istickedoff">pure <span class="nottickedoff">c</span></span>
<span class="lineno">  923 </span><span class="spaces">     </span><span class="istickedoff">-- Return Terms for data type and constructors.</span>
<span class="lineno">  924 </span><span class="spaces">     </span><span class="istickedoff">pure <span class="nottickedoff">(d, cs)</span></span></span>
<span class="lineno">  925 </span>
<span class="lineno">  926 </span>--------------------------------------------------------------------------------
<span class="lineno">  927 </span>-- Recursors
<span class="lineno">  928 </span>
<span class="lineno">  929 </span>scmRecursor :: Name -&gt; Sort -&gt; SCM Term
<span class="lineno">  930 </span><span class="decl"><span class="istickedoff">scmRecursor nm s =</span>
<span class="lineno">  931 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno">  932 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- liftIO $ scGetModuleMap sc</span>
<span class="lineno">  933 </span><span class="spaces">     </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  934 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedDataType dt) -&gt;</span>
<span class="lineno">  935 </span><span class="spaces">         </span><span class="istickedoff">do unless (allowedElimSort dt s) $ scmError (RecursorPropElim nm s)</span>
<span class="lineno">  936 </span><span class="spaces">            </span><span class="istickedoff">let d = dtName dt</span>
<span class="lineno">  937 </span><span class="spaces">            </span><span class="istickedoff">let nparams = length (dtParams dt)</span>
<span class="lineno">  938 </span><span class="spaces">            </span><span class="istickedoff">let nixs = length (dtIndices dt)</span>
<span class="lineno">  939 </span><span class="spaces">            </span><span class="istickedoff">let ctorOrder = map ctorName (dtCtors dt)</span>
<span class="lineno">  940 </span><span class="spaces">            </span><span class="istickedoff">let crec = CompiledRecursor d s nparams nixs ctorOrder</span>
<span class="lineno">  941 </span><span class="spaces">            </span><span class="istickedoff">let vt = IntMap.empty</span>
<span class="lineno">  942 </span><span class="spaces">            </span><span class="istickedoff">let tf = FTermF (Recursor crec)</span>
<span class="lineno">  943 </span><span class="spaces">            </span><span class="istickedoff">ty &lt;- scmRecursorType dt s</span>
<span class="lineno">  944 </span><span class="spaces">            </span><span class="istickedoff">scmMakeTerm vt tf (Right ty)</span>
<span class="lineno">  945 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  946 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">scmError (DataTypeNotFound nm)</span></span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>-- | Test whether a 'DataType' can be eliminated to the given sort. The rules
<span class="lineno">  949 </span>-- are that you can only eliminate propositional datatypes to the proposition
<span class="lineno">  950 </span>-- sort, unless your propositional data type is the empty type. This differs
<span class="lineno">  951 </span>-- slightly from the Rocq rules, which allow elimination of propositional
<span class="lineno">  952 </span>-- datatypes with a single constructor that has only propositional arguments,
<span class="lineno">  953 </span>-- but this Rocq behavior can be simulated with the behavior we are using here.
<span class="lineno">  954 </span>allowedElimSort :: DataType -&gt; Sort -&gt; Bool
<span class="lineno">  955 </span><span class="decl"><span class="istickedoff">allowedElimSort dt s =</span>
<span class="lineno">  956 </span><span class="spaces">  </span><span class="istickedoff">if dtSort dt == propSort &amp;&amp; s /= propSort then</span>
<span class="lineno">  957 </span><span class="spaces">    </span><span class="istickedoff">length (dtCtors dt) == 1</span>
<span class="lineno">  958 </span><span class="spaces">  </span><span class="istickedoff">else True</span></span>
<span class="lineno">  959 </span>
<span class="lineno">  960 </span>-- | Compute the type of an eliminator function for a constructor from the name
<span class="lineno">  961 </span>-- of its datatype, its name, and its 'CtorArgStruct'. This type has, as free
<span class="lineno">  962 </span>-- variables, both the parameters of the datatype and a &quot;motive&quot; function from
<span class="lineno">  963 </span>-- indices of the datatype to a return type. It is of the form
<span class="lineno">  964 </span>--
<span class="lineno">  965 </span>-- &gt; (x1::arg1) -&gt; maybe (rec1::rec_tp1) -&gt; .. -&gt;
<span class="lineno">  966 </span>-- &gt; (xn::argn) -&gt; maybe (recn::rec_tpn) -&gt;
<span class="lineno">  967 </span>-- &gt;   p_ret ix_1 .. ix_k (ctor params x1 .. xn)
<span class="lineno">  968 </span>--
<span class="lineno">  969 </span>-- where the ixs are the type indices of the return type for the constructor,
<span class="lineno">  970 </span>-- the (xi::argi) are the arguments of the constructor, and the @maybe@s
<span class="lineno">  971 </span>-- indicate additional arguments that are present only for arguments of
<span class="lineno">  972 </span>-- recursive type, that is, where @argi@ has the form
<span class="lineno">  973 </span>--
<span class="lineno">  974 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk
<span class="lineno">  975 </span>--
<span class="lineno">  976 </span>-- In this case, @rec_tpi@ has the form
<span class="lineno">  977 </span>--
<span class="lineno">  978 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (f z1 .. zm)
<span class="lineno">  979 </span>--
<span class="lineno">  980 </span>-- Note that the output type cannot be expressed in the type of this function,
<span class="lineno">  981 </span>-- since it depends on fields of the 'CtorArgStruct', so, instead, the result is
<span class="lineno">  982 </span>-- just casted to whatever type the caller specifies.
<span class="lineno">  983 </span>ctxCtorElimType ::
<span class="lineno">  984 </span>  Name {- ^ data type name -} -&gt;
<span class="lineno">  985 </span>  Name {- ^ constructor name -} -&gt;
<span class="lineno">  986 </span>  Term {- ^ motive function -} -&gt;
<span class="lineno">  987 </span>  CtorArgStruct -&gt;
<span class="lineno">  988 </span>  SCM Term
<span class="lineno">  989 </span><span class="decl"><span class="istickedoff">ctxCtorElimType d c p_ret (CtorArgStruct{..}) =</span>
<span class="lineno">  990 </span><span class="spaces">  </span><span class="istickedoff">do params &lt;- scmVariables ctorParams</span>
<span class="lineno">  991 </span><span class="spaces">     </span><span class="istickedoff">d_params &lt;- scmConstApply d params</span>
<span class="lineno">  992 </span><span class="spaces">     </span><span class="istickedoff">let helper :: [Term] -&gt; [(VarName, CtorArg)] -&gt; SCM Term</span>
<span class="lineno">  993 </span><span class="spaces">         </span><span class="istickedoff">helper prevs ((nm, ConstArg tp) : args) =</span>
<span class="lineno">  994 </span><span class="spaces">           </span><span class="istickedoff">-- For a constant argument type, just abstract it and continue</span>
<span class="lineno">  995 </span><span class="spaces">           </span><span class="istickedoff">do arg &lt;- scmVariable nm tp</span>
<span class="lineno">  996 </span><span class="spaces">              </span><span class="istickedoff">rest &lt;- helper (prevs ++ [arg]) args</span>
<span class="lineno">  997 </span><span class="spaces">              </span><span class="istickedoff">scmPi nm tp rest</span>
<span class="lineno">  998 </span><span class="spaces">         </span><span class="istickedoff">helper prevs ((nm, RecursiveArg zs ts) : args) =</span>
<span class="lineno">  999 </span><span class="spaces">           </span><span class="istickedoff">-- For a recursive argument type of the form</span>
<span class="lineno"> 1000 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno"> 1001 </span><span class="spaces">           </span><span class="istickedoff">-- (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk</span>
<span class="lineno"> 1002 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno"> 1003 </span><span class="spaces">           </span><span class="istickedoff">-- form the type abstraction</span>
<span class="lineno"> 1004 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno"> 1005 </span><span class="spaces">           </span><span class="istickedoff">-- (arg:: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk) -&gt;</span>
<span class="lineno"> 1006 </span><span class="spaces">           </span><span class="istickedoff">-- (ih :: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (arg z1 .. zm)) -&gt;</span>
<span class="lineno"> 1007 </span><span class="spaces">           </span><span class="istickedoff">-- rest</span>
<span class="lineno"> 1008 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno"> 1009 </span><span class="spaces">           </span><span class="istickedoff">-- where rest is the result of a recursive call</span>
<span class="lineno"> 1010 </span><span class="spaces">           </span><span class="istickedoff">do d_params_ts &lt;- scmApplyAll d_params ts</span>
<span class="lineno"> 1011 </span><span class="spaces">              </span><span class="istickedoff">-- Build the type of the argument arg</span>
<span class="lineno"> 1012 </span><span class="spaces">              </span><span class="istickedoff">arg_tp &lt;- scmPiList zs d_params_ts</span>
<span class="lineno"> 1013 </span><span class="spaces">              </span><span class="istickedoff">arg &lt;- scmVariable nm arg_tp</span>
<span class="lineno"> 1014 </span><span class="spaces">              </span><span class="istickedoff">-- Build the type of ih</span>
<span class="lineno"> 1015 </span><span class="spaces">              </span><span class="istickedoff">pret_ts &lt;- scmApplyAll p_ret ts</span>
<span class="lineno"> 1016 </span><span class="spaces">              </span><span class="istickedoff">z_vars &lt;- scmVariables zs</span>
<span class="lineno"> 1017 </span><span class="spaces">              </span><span class="istickedoff">arg_zs &lt;- scmApplyAll arg z_vars</span>
<span class="lineno"> 1018 </span><span class="spaces">              </span><span class="istickedoff">ih_ret &lt;- scmApply pret_ts arg_zs</span>
<span class="lineno"> 1019 </span><span class="spaces">              </span><span class="istickedoff">ih_tp &lt;- scmPiList zs ih_ret</span>
<span class="lineno"> 1020 </span><span class="spaces">              </span><span class="istickedoff">-- Finally, build the pi-abstraction for arg and ih around the rest</span>
<span class="lineno"> 1021 </span><span class="spaces">              </span><span class="istickedoff">rest &lt;- helper (prevs ++ [arg]) args</span>
<span class="lineno"> 1022 </span><span class="spaces">              </span><span class="istickedoff">scmPi nm arg_tp =&lt;&lt; scmFun ih_tp rest</span>
<span class="lineno"> 1023 </span><span class="spaces">         </span><span class="istickedoff">helper prevs [] =</span>
<span class="lineno"> 1024 </span><span class="spaces">           </span><span class="istickedoff">-- If we are finished with our arguments, construct the final result type</span>
<span class="lineno"> 1025 </span><span class="spaces">           </span><span class="istickedoff">-- (p_ret ret_ixs (c params prevs))</span>
<span class="lineno"> 1026 </span><span class="spaces">           </span><span class="istickedoff">do p_ret_ixs &lt;- scmApplyAll p_ret ctorIndices</span>
<span class="lineno"> 1027 </span><span class="spaces">              </span><span class="istickedoff">appliedCtor &lt;- scmConstApply c (params ++ prevs)</span>
<span class="lineno"> 1028 </span><span class="spaces">              </span><span class="istickedoff">scmApply p_ret_ixs appliedCtor</span>
<span class="lineno"> 1029 </span><span class="spaces">     </span><span class="istickedoff">helper [] ctorArgs</span></span>
<span class="lineno"> 1030 </span>
<span class="lineno"> 1031 </span>-- | Reduce an application of a recursor to a particular constructor.
<span class="lineno"> 1032 </span>-- This is known in the Rocq literature as an iota reduction. More specifically,
<span class="lineno"> 1033 </span>-- the call
<span class="lineno"> 1034 </span>--
<span class="lineno"> 1035 </span>-- &gt; ctxReduceRecursor rec f_c [x1, .., xk]
<span class="lineno"> 1036 </span>--
<span class="lineno"> 1037 </span>-- reduces the term @(RecursorApp rec ixs (CtorApp c ps xs))@ to
<span class="lineno"> 1038 </span>--
<span class="lineno"> 1039 </span>-- &gt; f_c x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno"> 1040 </span>--
<span class="lineno"> 1041 </span>-- where @f_c@ is the eliminator function associated to the constructor @c@ by the
<span class="lineno"> 1042 </span>-- recursor value @rec@.  Here @maybe rec_tm_i@ indicates an optional recursive call
<span class="lineno"> 1043 </span>-- of the recursor on one of the @xi@. These recursive calls only exist for those
<span class="lineno"> 1044 </span>-- arguments @xi@ that are recursive arguments, i.e., that are specified with
<span class="lineno"> 1045 </span>-- 'RecursiveArg', and are omitted for non-recursive arguments specified by 'ConstArg'.
<span class="lineno"> 1046 </span>--
<span class="lineno"> 1047 </span>-- Specifically, for a @'RecursiveArg' zs ixs@ argument @xi@, which has type
<span class="lineno"> 1048 </span>-- @\(z1::Z1) -&gt; .. -&gt; d p1 .. pn ix1 .. ixp@, we build the recursive call
<span class="lineno"> 1049 </span>--
<span class="lineno"> 1050 </span>-- &gt; \(z1::[xs/args]Z1) -&gt; .. -&gt;
<span class="lineno"> 1051 </span>-- &gt;   RecursorApp rec [xs/args]ixs (xi z1 ... zn)
<span class="lineno"> 1052 </span>--
<span class="lineno"> 1053 </span>-- where @[xs/args]@ substitutes the concrete values for the earlier
<span class="lineno"> 1054 </span>-- constructor arguments @xs@ for the remaining free variables.
<span class="lineno"> 1055 </span>
<span class="lineno"> 1056 </span>ctxReduceRecursor ::
<span class="lineno"> 1057 </span>  Term {- ^ recursor applied to params, motive, and eliminator functions -} -&gt;
<span class="lineno"> 1058 </span>  Term {- ^ constructor eliminator function -} -&gt;
<span class="lineno"> 1059 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno"> 1060 </span>  CtorArgStruct {- ^ constructor formal argument descriptor -} -&gt;
<span class="lineno"> 1061 </span>  SCM Term
<span class="lineno"> 1062 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor r elimf c_args CtorArgStruct{..}</span>
<span class="lineno"> 1063 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">length c_args /= length ctorArgs</span> = <span class="nottickedoff">panic &quot;ctxReduceRecursor&quot; [&quot;Wrong number of constructor arguments&quot;]</span></span>
<span class="lineno"> 1064 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1065 </span><span class="spaces">    </span><span class="istickedoff">do args &lt;- mk_args IntMap.empty (zip c_args ctorArgs)</span>
<span class="lineno"> 1066 </span><span class="spaces">       </span><span class="istickedoff">scmWhnf =&lt;&lt; scmApplyAll elimf args</span>
<span class="lineno"> 1067 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1068 </span><span class="spaces">    </span><span class="istickedoff">mk_args :: IntMap Term -&gt;  -- already processed parameters/arguments</span>
<span class="lineno"> 1069 </span><span class="spaces">               </span><span class="istickedoff">[(Term, (VarName, CtorArg))] -&gt;</span>
<span class="lineno"> 1070 </span><span class="spaces">                 </span><span class="istickedoff">-- remaining actual arguments to process, with</span>
<span class="lineno"> 1071 </span><span class="spaces">                 </span><span class="istickedoff">-- telescope for typing the actual arguments</span>
<span class="lineno"> 1072 </span><span class="spaces">               </span><span class="istickedoff">SCM [Term]</span>
<span class="lineno"> 1073 </span><span class="spaces">    </span><span class="istickedoff">-- no more arguments to process</span>
<span class="lineno"> 1074 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ [] = return []</span>
<span class="lineno"> 1075 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1076 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is not a recursive call</span>
<span class="lineno"> 1077 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (nm, ConstArg _)) : xs_args) =</span>
<span class="lineno"> 1078 </span><span class="spaces">      </span><span class="istickedoff">do tl &lt;- mk_args (IntMap.insert (vnIndex nm) x pre_xs) xs_args</span>
<span class="lineno"> 1079 </span><span class="spaces">         </span><span class="istickedoff">pure (x : tl)</span>
<span class="lineno"> 1080 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1081 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is a recursive call</span>
<span class="lineno"> 1082 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (nm, RecursiveArg zs ixs)) : xs_args) =</span>
<span class="lineno"> 1083 </span><span class="spaces">      </span><span class="istickedoff">do zs'  &lt;- traverse <span class="nottickedoff">(traverse (scmInstantiate pre_xs))</span> zs</span>
<span class="lineno"> 1084 </span><span class="spaces">         </span><span class="istickedoff">ixs' &lt;- traverse (scmInstantiate pre_xs) ixs</span>
<span class="lineno"> 1085 </span><span class="spaces">         </span><span class="istickedoff">recx &lt;- mk_rec_arg zs' ixs' x</span>
<span class="lineno"> 1086 </span><span class="spaces">         </span><span class="istickedoff">tl   &lt;- mk_args <span class="nottickedoff">(IntMap.insert (vnIndex nm) x pre_xs)</span> xs_args</span>
<span class="lineno"> 1087 </span><span class="spaces">         </span><span class="istickedoff">pure (x : recx : tl)</span>
<span class="lineno"> 1088 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1089 </span><span class="spaces">    </span><span class="istickedoff">-- Build an individual recursive call, given the parameters, the bindings</span>
<span class="lineno"> 1090 </span><span class="spaces">    </span><span class="istickedoff">-- for the RecursiveArg, and the argument we are going to recurse on</span>
<span class="lineno"> 1091 </span><span class="spaces">    </span><span class="istickedoff">-- The resulting term has the form</span>
<span class="lineno"> 1092 </span><span class="spaces">    </span><span class="istickedoff">-- &gt; \(z1:Z1) .. (zk:Zk) -&gt; r ixs (x z1 .. zk)</span>
<span class="lineno"> 1093 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg ::</span>
<span class="lineno"> 1094 </span><span class="spaces">      </span><span class="istickedoff">[(VarName, Term)] -&gt;             -- telescope describing the zs</span>
<span class="lineno"> 1095 </span><span class="spaces">      </span><span class="istickedoff">[Term] -&gt;                        -- actual values for the indices, shifted under zs</span>
<span class="lineno"> 1096 </span><span class="spaces">      </span><span class="istickedoff">Term -&gt;                         -- actual value in recursive position</span>
<span class="lineno"> 1097 </span><span class="spaces">      </span><span class="istickedoff">SCM Term</span>
<span class="lineno"> 1098 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg zs_ctx ixs x =</span>
<span class="lineno"> 1099 </span><span class="spaces">      </span><span class="istickedoff">-- eta expand over the zs and apply the Recursor form</span>
<span class="lineno"> 1100 </span><span class="spaces">      </span><span class="istickedoff">do zs &lt;- scmVariables zs_ctx</span>
<span class="lineno"> 1101 </span><span class="spaces">         </span><span class="istickedoff">x_zs &lt;- scmApplyAll x zs</span>
<span class="lineno"> 1102 </span><span class="spaces">         </span><span class="istickedoff">r_ixs &lt;- scmApplyAll r ixs</span>
<span class="lineno"> 1103 </span><span class="spaces">         </span><span class="istickedoff">body &lt;- scmApply r_ixs x_zs</span>
<span class="lineno"> 1104 </span><span class="spaces">         </span><span class="istickedoff">scmLambdaList zs_ctx body</span></span>
<span class="lineno"> 1105 </span>
<span class="lineno"> 1106 </span>-- | Build the type of the @p_ret@ function, also known as the &quot;motive&quot;
<span class="lineno"> 1107 </span>-- function, of a recursor on datatype @d@. This type has the form
<span class="lineno"> 1108 </span>--
<span class="lineno"> 1109 </span>-- &gt; (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s
<span class="lineno"> 1110 </span>--
<span class="lineno"> 1111 </span>-- where the @pi@ are the parameters of @d@, the @ixj@ are the indices
<span class="lineno"> 1112 </span>-- of @d@, and @s@ is any sort supplied as an argument.
<span class="lineno"> 1113 </span>-- Parameter variables @p1 .. pn@ will be free in the resulting term.
<span class="lineno"> 1114 </span>scmRecursorMotiveType :: DataType -&gt; Sort -&gt; SCM Term
<span class="lineno"> 1115 </span><span class="decl"><span class="istickedoff">scmRecursorMotiveType dt s =</span>
<span class="lineno"> 1116 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- scmVariables (dtParams dt)</span>
<span class="lineno"> 1117 </span><span class="spaces">     </span><span class="istickedoff">ix_vars &lt;- scmVariables (dtIndices dt)</span>
<span class="lineno"> 1118 </span><span class="spaces">     </span><span class="istickedoff">d &lt;- scmConstApply (dtName dt) (param_vars ++ ix_vars)</span>
<span class="lineno"> 1119 </span><span class="spaces">     </span><span class="istickedoff">ret &lt;- scmFun d =&lt;&lt; scmSort s</span>
<span class="lineno"> 1120 </span><span class="spaces">     </span><span class="istickedoff">scmPiList (dtIndices dt) ret</span></span>
<span class="lineno"> 1121 </span>
<span class="lineno"> 1122 </span>-- | Build the type of a recursor for datatype @d@ that has been
<span class="lineno"> 1123 </span>-- applied to parameters, a motive function, and a full set of
<span class="lineno"> 1124 </span>-- eliminator functions. This type has the form
<span class="lineno"> 1125 </span>--
<span class="lineno"> 1126 </span>-- &gt; (i1:ix1) -&gt; .. -&gt; (im:ixm) -&gt;
<span class="lineno"> 1127 </span>-- &gt;   (arg : d p1 .. pn i1 .. im) -&gt; motive i1 .. im arg
<span class="lineno"> 1128 </span>--
<span class="lineno"> 1129 </span>-- where the @pi@ are the parameters of @d@, and the @ixj@ are the
<span class="lineno"> 1130 </span>-- indices of @d@.
<span class="lineno"> 1131 </span>-- Parameter variables @p1 .. pn@ will be free in the resulting term.
<span class="lineno"> 1132 </span>scmRecursorAppType :: DataType -&gt; Term -&gt; SCM Term
<span class="lineno"> 1133 </span><span class="decl"><span class="istickedoff">scmRecursorAppType dt motive =</span>
<span class="lineno"> 1134 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- scmVariables (dtParams dt)</span>
<span class="lineno"> 1135 </span><span class="spaces">     </span><span class="istickedoff">ix_vars &lt;- scmVariables (dtIndices dt)</span>
<span class="lineno"> 1136 </span><span class="spaces">     </span><span class="istickedoff">d &lt;- scmConstApply (dtName dt) (param_vars ++ ix_vars)</span>
<span class="lineno"> 1137 </span><span class="spaces">     </span><span class="istickedoff">let arg_vn = dtArgName dt</span>
<span class="lineno"> 1138 </span><span class="spaces">     </span><span class="istickedoff">arg_var &lt;- scmVariable arg_vn d</span>
<span class="lineno"> 1139 </span><span class="spaces">     </span><span class="istickedoff">ret &lt;- scmApplyAll motive (ix_vars ++ [arg_var])</span>
<span class="lineno"> 1140 </span><span class="spaces">     </span><span class="istickedoff">scmPiList (dtIndices dt ++ [(arg_vn, d)]) ret</span></span>
<span class="lineno"> 1141 </span>
<span class="lineno"> 1142 </span>-- | Build the full type of an unapplied recursor for datatype @d@
<span class="lineno"> 1143 </span>-- with elimination to sort @s@.
<span class="lineno"> 1144 </span>-- This type has the form
<span class="lineno"> 1145 </span>--
<span class="lineno"> 1146 </span>-- &gt; (p1:pt1) -&gt; .. -&gt; (pn::ptn) -&gt;
<span class="lineno"> 1147 </span>-- &gt; (motive : (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s) -&gt;
<span class="lineno"> 1148 </span>-- &gt; (elim1 : ..) -&gt; .. (elimk : ..) -&gt;
<span class="lineno"> 1149 </span>-- &gt; (i1:ix1) -&gt; .. -&gt; (im:ixm) -&gt;
<span class="lineno"> 1150 </span>-- &gt;   (arg : d p1 .. pn i1 .. im) -&gt; motive i1 .. im arg
<span class="lineno"> 1151 </span>scmRecursorType :: DataType -&gt; Sort -&gt; SCM Term
<span class="lineno"> 1152 </span><span class="decl"><span class="istickedoff">scmRecursorType dt s =</span>
<span class="lineno"> 1153 </span><span class="spaces">  </span><span class="istickedoff">do let d = dtName dt</span>
<span class="lineno"> 1154 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1155 </span><span class="spaces">     </span><span class="istickedoff">-- Compute the type of the motive function, which has the form</span>
<span class="lineno"> 1156 </span><span class="spaces">     </span><span class="istickedoff">-- (i1:ix1) -&gt; .. -&gt; (im:ixm) -&gt; d p1 .. pn i1 .. im -&gt; s</span>
<span class="lineno"> 1157 </span><span class="spaces">     </span><span class="istickedoff">motive_ty &lt;- scmRecursorMotiveType dt s</span>
<span class="lineno"> 1158 </span><span class="spaces">     </span><span class="istickedoff">let motive_vn = dtMotiveName dt</span>
<span class="lineno"> 1159 </span><span class="spaces">     </span><span class="istickedoff">motive_var &lt;- scmVariable motive_vn motive_ty</span>
<span class="lineno"> 1160 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1161 </span><span class="spaces">     </span><span class="istickedoff">-- Compute the types of the elimination functions</span>
<span class="lineno"> 1162 </span><span class="spaces">     </span><span class="istickedoff">elims_tps &lt;-</span>
<span class="lineno"> 1163 </span><span class="spaces">       </span><span class="istickedoff">forM (dtCtors dt) $ \ctor -&gt;</span>
<span class="lineno"> 1164 </span><span class="spaces">       </span><span class="istickedoff">ctxCtorElimType d (ctorName ctor) motive_var (ctorArgStruct ctor)</span>
<span class="lineno"> 1165 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1166 </span><span class="spaces">     </span><span class="istickedoff">scmPiList (dtParams dt) =&lt;&lt;</span>
<span class="lineno"> 1167 </span><span class="spaces">       </span><span class="istickedoff">scmPi motive_vn motive_ty =&lt;&lt;</span>
<span class="lineno"> 1168 </span><span class="spaces">       </span><span class="istickedoff">scmFunAll elims_tps =&lt;&lt;</span>
<span class="lineno"> 1169 </span><span class="spaces">       </span><span class="istickedoff">scmRecursorAppType dt motive_var</span></span>
<span class="lineno"> 1170 </span>
<span class="lineno"> 1171 </span>-- | Reduce an application of a recursor. This is known in the Rocq literature as
<span class="lineno"> 1172 </span>-- an iota reduction. More specifically, the call
<span class="lineno"> 1173 </span>--
<span class="lineno"> 1174 </span>-- &gt; scReduceRecursor sc rec crec ci [x1, .., xk]
<span class="lineno"> 1175 </span>--
<span class="lineno"> 1176 </span>-- reduces the term @(Recursor r elims ixs (CtorApp ci ps xs))@ to
<span class="lineno"> 1177 </span>--
<span class="lineno"> 1178 </span>-- &gt; fi x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno"> 1179 </span>--
<span class="lineno"> 1180 </span>-- where @maybe rec_tm_i@ indicates an optional recursive call of the recursor
<span class="lineno"> 1181 </span>-- on one of the @xi@. These recursive calls only exist for those arguments
<span class="lineno"> 1182 </span>-- @xi@. See the documentation for 'ctxReduceRecursor' for more details.
<span class="lineno"> 1183 </span>scmReduceRecursor ::
<span class="lineno"> 1184 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno"> 1185 </span>  CompiledRecursor {- ^ concrete data included in the recursor term -} -&gt;
<span class="lineno"> 1186 </span>  [Term] {- ^ datatype parameters -} -&gt;
<span class="lineno"> 1187 </span>  Term {- ^ motive function -} -&gt;
<span class="lineno"> 1188 </span>  [Term] {- ^ eliminator functions -} -&gt;
<span class="lineno"> 1189 </span>  Name {- ^ constructor name -} -&gt;
<span class="lineno"> 1190 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno"> 1191 </span>  SCM Term
<span class="lineno"> 1192 </span><span class="decl"><span class="istickedoff">scmReduceRecursor r crec params motive elims c args =</span>
<span class="lineno"> 1193 </span><span class="spaces">  </span><span class="istickedoff">do mres &lt;- lookupVarIndexInMap (nameIndex c) &lt;$&gt; scmGetModuleMap</span>
<span class="lineno"> 1194 </span><span class="spaces">     </span><span class="istickedoff">let cs_fs = Map.fromList (zip (map nameIndex (recursorCtorOrder crec)) elims)</span>
<span class="lineno"> 1195 </span><span class="spaces">     </span><span class="istickedoff">r_applied &lt;- scmApplyAll r (params ++ motive : elims)</span>
<span class="lineno"> 1196 </span><span class="spaces">     </span><span class="istickedoff">case mres of</span>
<span class="lineno"> 1197 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedCtor ctor) -&gt;</span>
<span class="lineno"> 1198 </span><span class="spaces">         </span><span class="istickedoff">ctorIotaReduction ctor r_applied cs_fs args</span>
<span class="lineno"> 1199 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1200 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">panic &quot;scReduceRecursor&quot; [&quot;Could not find constructor: &quot; &lt;&gt; toAbsoluteName (nameInfo c)]</span></span></span>
<span class="lineno"> 1201 </span>
<span class="lineno"> 1202 </span>-- | Function for computing the result of one step of iota reduction
<span class="lineno"> 1203 </span>-- of the term
<span class="lineno"> 1204 </span>--
<span class="lineno"> 1205 </span>-- &gt; dt#rec params elims ixs (c params args)
<span class="lineno"> 1206 </span>--
<span class="lineno"> 1207 </span>-- The arguments to this function are the recursor value (applied to
<span class="lineno"> 1208 </span>-- params, motive and elims), a mapping from constructor name indices
<span class="lineno"> 1209 </span>-- to eliminator functions, and the arguments to the constructor.
<span class="lineno"> 1210 </span>ctorIotaReduction ::
<span class="lineno"> 1211 </span>  Ctor -&gt;
<span class="lineno"> 1212 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno"> 1213 </span>  Map VarIndex Term {- ^ constructor eliminators -} -&gt;
<span class="lineno"> 1214 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno"> 1215 </span>  SCM Term
<span class="lineno"> 1216 </span><span class="decl"><span class="istickedoff">ctorIotaReduction ctor r cs_fs args =</span>
<span class="lineno"> 1217 </span><span class="spaces">  </span><span class="istickedoff">ctxReduceRecursor r elim args (ctorArgStruct ctor)</span>
<span class="lineno"> 1218 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1219 </span><span class="spaces">    </span><span class="istickedoff">elim =</span>
<span class="lineno"> 1220 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup (nameIndex (ctorName ctor)) cs_fs of</span>
<span class="lineno"> 1221 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; e</span>
<span class="lineno"> 1222 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1223 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;ctorIotaReduction&quot;</span></span>
<span class="lineno"> 1224 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;no eliminator for constructor &quot; &lt;&gt; toAbsoluteName (nameInfo (ctorName ctor))]</span></span></span>
<span class="lineno"> 1225 </span>
<span class="lineno"> 1226 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1227 </span>-- Reduction to head-normal form
<span class="lineno"> 1228 </span>
<span class="lineno"> 1229 </span>-- | An elimination for 'scWhnf'
<span class="lineno"> 1230 </span>data WHNFElim
<span class="lineno"> 1231 </span>  = ElimApp Term
<span class="lineno"> 1232 </span>  | ElimProj FieldName
<span class="lineno"> 1233 </span>  | ElimPair Bool
<span class="lineno"> 1234 </span>  | ElimRecursor Term CompiledRecursor [Term] Term [Term] [Term]
<span class="lineno"> 1235 </span>    -- ^ recursor, compiled recursor, params, motive, eliminators, indices
<span class="lineno"> 1236 </span>
<span class="lineno"> 1237 </span>-- | Reduces beta-redexes, tuple/record selectors, recursor applications, and
<span class="lineno"> 1238 </span>-- definitions at the top level of a term.
<span class="lineno"> 1239 </span>scmWhnf :: Term -&gt; SCM Term
<span class="lineno"> 1240 </span><span class="decl"><span class="istickedoff">scmWhnf t0 = go [] t0</span>
<span class="lineno"> 1241 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1242 </span><span class="spaces">    </span><span class="istickedoff">go :: [WHNFElim] -&gt; Term -&gt; SCM Term</span>
<span class="lineno"> 1243 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asApp            -&gt; Just (t, x)) = go (ElimApp x : xs) t</span>
<span class="lineno"> 1244 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asRecordSelector -&gt; Just (t, n)) = go (ElimProj n : xs) t</span>
<span class="lineno"> 1245 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asPairSelector -&gt; Just (t, i))   = go (ElimPair i : xs) t</span>
<span class="lineno"> 1246 </span><span class="spaces">    </span><span class="istickedoff">go (ElimApp x : xs)       (asLambda -&gt; Just (vn, _, body))  = betaReduce xs [(vn, x)] body</span>
<span class="lineno"> 1247 </span><span class="spaces">    </span><span class="istickedoff">go (ElimPair i : xs)      (asPairValue -&gt; Just (a, b))      = go xs (if i then b else a)</span>
<span class="lineno"> 1248 </span><span class="spaces">    </span><span class="istickedoff">go (ElimProj fld : xs)    (asRecordValue -&gt; Just elems)     = case Map.lookup fld elems of</span>
<span class="lineno"> 1249 </span><span class="spaces">                                                                    </span><span class="istickedoff">Just t -&gt; go xs t</span>
<span class="lineno"> 1250 </span><span class="spaces">                                                                    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1251 </span><span class="spaces">                                                                      </span><span class="istickedoff"><span class="nottickedoff">error &quot;scWhnf: field missing in record&quot;</span></span>
<span class="lineno"> 1252 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asRecursorApp -&gt; Just (r, crec)) | Just (params, ElimApp motive : xs1) &lt;- splitApps (recursorNumParams crec) xs</span>
<span class="lineno"> 1253 </span><span class="spaces">                                                                </span><span class="istickedoff">, Just (elims, xs2) &lt;- splitApps (length (recursorCtorOrder crec)) xs1</span>
<span class="lineno"> 1254 </span><span class="spaces">                                                                </span><span class="istickedoff">, Just (ixs, ElimApp x : xs') &lt;- splitApps (recursorNumIxs crec) xs2</span>
<span class="lineno"> 1255 </span><span class="spaces">                                                                </span><span class="istickedoff">= go (ElimRecursor r crec params motive elims ixs : xs') x</span>
<span class="lineno"> 1256 </span><span class="spaces">    </span><span class="istickedoff">go xs                     t@(asConstant -&gt; Just nm)         = do r &lt;- resolveConstant nm</span>
<span class="lineno"> 1257 </span><span class="spaces">                                                                     </span><span class="istickedoff">case r of</span>
<span class="lineno"> 1258 </span><span class="spaces">                                                                       </span><span class="istickedoff">ResolvedDef d -&gt;</span>
<span class="lineno"> 1259 </span><span class="spaces">                                                                         </span><span class="istickedoff">case defBody d of</span>
<span class="lineno"> 1260 </span><span class="spaces">                                                                           </span><span class="istickedoff">Just body -&gt; go xs body</span>
<span class="lineno"> 1261 </span><span class="spaces">                                                                           </span><span class="istickedoff">Nothing -&gt; foldM reapply t xs</span>
<span class="lineno"> 1262 </span><span class="spaces">                                                                       </span><span class="istickedoff">ResolvedCtor ctor -&gt;</span>
<span class="lineno"> 1263 </span><span class="spaces">                                                                         </span><span class="istickedoff">case asArgsRec xs of</span>
<span class="lineno"> 1264 </span><span class="spaces">                                                                           </span><span class="istickedoff">Nothing -&gt; foldM reapply t xs</span>
<span class="lineno"> 1265 </span><span class="spaces">                                                                           </span><span class="istickedoff">Just (rt, crec, params, motive, elims, args, xs') -&gt;</span>
<span class="lineno"> 1266 </span><span class="spaces">                                                                             </span><span class="istickedoff">do let args' = drop (ctorNumParams ctor) args</span>
<span class="lineno"> 1267 </span><span class="spaces">                                                                                </span><span class="istickedoff">scmReduceRecursor rt crec params motive elims nm args' &gt;&gt;= go xs'</span>
<span class="lineno"> 1268 </span><span class="spaces">                                                                       </span><span class="istickedoff">ResolvedDataType _ -&gt;</span>
<span class="lineno"> 1269 </span><span class="spaces">                                                                         </span><span class="istickedoff">foldM reapply t xs</span>
<span class="lineno"> 1270 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1271 </span><span class="spaces">    </span><span class="istickedoff">go xs                     t                                 = foldM reapply t xs</span>
<span class="lineno"> 1272 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1273 </span><span class="spaces">    </span><span class="istickedoff">betaReduce :: [WHNFElim] -&gt; [(VarName, Term)] -&gt; Term -&gt; SCM Term</span>
<span class="lineno"> 1274 </span><span class="spaces">    </span><span class="istickedoff">betaReduce (ElimApp x : xs) vs (asLambda -&gt; Just (vn,_,body)) =</span>
<span class="lineno"> 1275 </span><span class="spaces">      </span><span class="istickedoff">betaReduce xs ((vn, x) : vs) body</span>
<span class="lineno"> 1276 </span><span class="spaces">    </span><span class="istickedoff">betaReduce xs vs body =</span>
<span class="lineno"> 1277 </span><span class="spaces">      </span><span class="istickedoff">do let subst = IntMap.fromList [ (vnIndex vn, x) | (vn, x) &lt;- vs ]</span>
<span class="lineno"> 1278 </span><span class="spaces">         </span><span class="istickedoff">body' &lt;- scmInstantiate subst body</span>
<span class="lineno"> 1279 </span><span class="spaces">         </span><span class="istickedoff">go xs body'</span>
<span class="lineno"> 1280 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1281 </span><span class="spaces">    </span><span class="istickedoff">reapply :: Term -&gt; WHNFElim -&gt; SCM Term</span>
<span class="lineno"> 1282 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimApp x) = scmApply t x</span>
<span class="lineno"> 1283 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimProj i) = <span class="nottickedoff">scmRecordSelect t i</span></span>
<span class="lineno"> 1284 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimPair i) = scmPairSelector t i</span>
<span class="lineno"> 1285 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimRecursor r _crec params motive elims ixs) =</span>
<span class="lineno"> 1286 </span><span class="spaces">      </span><span class="istickedoff">do f &lt;- scmApplyAll r (params ++ motive : elims ++ ixs)</span>
<span class="lineno"> 1287 </span><span class="spaces">         </span><span class="istickedoff">scmApply f t</span>
<span class="lineno"> 1288 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1289 </span><span class="spaces">    </span><span class="istickedoff">resolveConstant :: Name -&gt; SCM ResolvedName</span>
<span class="lineno"> 1290 </span><span class="spaces">    </span><span class="istickedoff">resolveConstant nm = requireNameInMap nm &lt;$&gt; scmGetModuleMap</span>
<span class="lineno"> 1291 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1292 </span><span class="spaces">    </span><span class="istickedoff">-- look for a prefix of ElimApps followed by an ElimRecursor</span>
<span class="lineno"> 1293 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec :: [WHNFElim] -&gt; Maybe (Term, CompiledRecursor, [Term], Term, [Term], [Term], [WHNFElim])</span>
<span class="lineno"> 1294 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec (ElimRecursor r crec params motive elims _ixs : xs) = Just (r, crec, params, motive, elims, [], xs)</span>
<span class="lineno"> 1295 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec (ElimApp x : xs) =</span>
<span class="lineno"> 1296 </span><span class="spaces">      </span><span class="istickedoff">case asArgsRec xs of</span>
<span class="lineno"> 1297 </span><span class="spaces">        </span><span class="istickedoff">Just (r, crec, params, motive, elims, args, xs') -&gt; Just (r, crec, params, motive, elims, x : args, xs')</span>
<span class="lineno"> 1298 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; Nothing</span>
<span class="lineno"> 1299 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec _ = Nothing</span>
<span class="lineno"> 1300 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1301 </span><span class="spaces">    </span><span class="istickedoff">-- look for a prefix of n ElimApps</span>
<span class="lineno"> 1302 </span><span class="spaces">    </span><span class="istickedoff">splitApps :: Int -&gt; [WHNFElim] -&gt; Maybe ([Term], [WHNFElim])</span>
<span class="lineno"> 1303 </span><span class="spaces">    </span><span class="istickedoff">splitApps 0 xs = Just ([], xs)</span>
<span class="lineno"> 1304 </span><span class="spaces">    </span><span class="istickedoff">splitApps n (ElimApp t : xs) =</span>
<span class="lineno"> 1305 </span><span class="spaces">       </span><span class="istickedoff">do (ts, xs') &lt;- splitApps (n-1) xs</span>
<span class="lineno"> 1306 </span><span class="spaces">          </span><span class="istickedoff">Just (t : ts, xs')</span>
<span class="lineno"> 1307 </span><span class="spaces">    </span><span class="istickedoff">splitApps _ _ = Nothing</span></span>
<span class="lineno"> 1308 </span>
<span class="lineno"> 1309 </span>-- | Test if two terms are convertible up to a given evaluation procedure. In
<span class="lineno"> 1310 </span>-- practice, this procedure is usually 'scWhnf', possibly combined with some
<span class="lineno"> 1311 </span>-- rewriting.
<span class="lineno"> 1312 </span>scmConvertible ::
<span class="lineno"> 1313 </span>  Bool {- ^ Should constants be unfolded during this check? -} -&gt;
<span class="lineno"> 1314 </span>  Term -&gt;
<span class="lineno"> 1315 </span>  Term -&gt;
<span class="lineno"> 1316 </span>  SCM Bool
<span class="lineno"> 1317 </span><span class="decl"><span class="istickedoff">scmConvertible unfoldConst tm1 tm2 =</span>
<span class="lineno"> 1318 </span><span class="spaces">  </span><span class="istickedoff">do c &lt;- newIntCache</span>
<span class="lineno"> 1319 </span><span class="spaces">     </span><span class="istickedoff">go c IntMap.empty tm1 tm2</span>
<span class="lineno"> 1320 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1322 </span><span class="spaces">    </span><span class="istickedoff">whnf :: IntCache SCM Term -&gt; Term -&gt; SCM (TermF Term)</span>
<span class="lineno"> 1323 </span><span class="spaces">    </span><span class="istickedoff">whnf c t@STApp{stAppIndex = idx} =</span>
<span class="lineno"> 1324 </span><span class="spaces">      </span><span class="istickedoff">unwrapTermF &lt;$&gt; useIntCache c idx (scmWhnf t)</span>
<span class="lineno"> 1325 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1326 </span><span class="spaces">    </span><span class="istickedoff">go :: IntCache SCM Term -&gt; IntMap VarIndex -&gt; Term -&gt; Term -&gt; SCM Bool</span>
<span class="lineno"> 1327 </span><span class="spaces">    </span><span class="istickedoff">go _c vm (STApp{stAppIndex = idx1, stAppVarTypes = vt1}) (STApp{stAppIndex = idx2})</span>
<span class="lineno"> 1328 </span><span class="spaces">      </span><span class="istickedoff">| IntMap.disjoint vt1 vm &amp;&amp; idx1 == idx2 = pure True   -- succeed early case</span>
<span class="lineno"> 1329 </span><span class="spaces">    </span><span class="istickedoff">go c vm t1 t2 = join (goF c vm &lt;$&gt; whnf c t1 &lt;*&gt; whnf c t2)</span>
<span class="lineno"> 1330 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1331 </span><span class="spaces">    </span><span class="istickedoff">goF :: IntCache SCM Term -&gt; IntMap VarIndex -&gt; TermF Term -&gt; TermF Term -&gt; SCM Bool</span>
<span class="lineno"> 1332 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1333 </span><span class="spaces">    </span><span class="istickedoff">goF _c _vm (Constant nx) (Constant ny) | nameIndex nx == nameIndex ny = pure True</span>
<span class="lineno"> 1334 </span><span class="spaces">    </span><span class="istickedoff">goF c vm (Constant nx) y</span>
<span class="lineno"> 1335 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">unfoldConst</span> =</span>
<span class="lineno"> 1336 </span><span class="spaces">          </span><span class="istickedoff">do mx &lt;- scmFindDefBody (nameIndex nx)</span>
<span class="lineno"> 1337 </span><span class="spaces">             </span><span class="istickedoff">case mx of</span>
<span class="lineno"> 1338 </span><span class="spaces">               </span><span class="istickedoff">Just x -&gt; <span class="nottickedoff">join (goF c vm &lt;$&gt; whnf c x &lt;*&gt; return y)</span></span>
<span class="lineno"> 1339 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; pure False</span>
<span class="lineno"> 1340 </span><span class="spaces">    </span><span class="istickedoff">goF c vm x (Constant ny)</span>
<span class="lineno"> 1341 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">unfoldConst</span> =</span>
<span class="lineno"> 1342 </span><span class="spaces">          </span><span class="istickedoff">do my &lt;- scmFindDefBody (nameIndex ny)</span>
<span class="lineno"> 1343 </span><span class="spaces">             </span><span class="istickedoff">case my of</span>
<span class="lineno"> 1344 </span><span class="spaces">               </span><span class="istickedoff">Just y -&gt; <span class="nottickedoff">join (goF c vm &lt;$&gt; return x &lt;*&gt; whnf c y)</span></span>
<span class="lineno"> 1345 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; pure False</span>
<span class="lineno"> 1346 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1347 </span><span class="spaces">    </span><span class="istickedoff">goF c vm (FTermF ftf1) (FTermF ftf2) =</span>
<span class="lineno"> 1348 </span><span class="spaces">            </span><span class="istickedoff">case zipWithFlatTermF (go c vm) ftf1 ftf2 of</span>
<span class="lineno"> 1349 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">False</span></span>
<span class="lineno"> 1350 </span><span class="spaces">              </span><span class="istickedoff">Just zipped -&gt; Fold.and &lt;$&gt; traverse id zipped</span>
<span class="lineno"> 1351 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1352 </span><span class="spaces">    </span><span class="istickedoff">goF c vm (App f1 x1) (App f2 x2) =</span>
<span class="lineno"> 1353 </span><span class="spaces">           </span><span class="istickedoff">pure (&amp;&amp;) &lt;*&gt; go c vm f1 f2 &lt;*&gt; go c vm x1 x2</span>
<span class="lineno"> 1354 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1355 </span><span class="spaces">    </span><span class="istickedoff">goF c vm (Lambda (vnIndex -&gt; i1) ty1 body1) (Lambda (vnIndex -&gt; i2) ty2 body2) =</span>
<span class="lineno"> 1356 </span><span class="spaces">      </span><span class="istickedoff">pure (&amp;&amp;) &lt;*&gt; go c <span class="nottickedoff">vm</span> ty1 ty2 &lt;*&gt; go c vm' body1 body2</span>
<span class="lineno"> 1357 </span><span class="spaces">        </span><span class="istickedoff">where vm' = if i1 == i2 then vm else IntMap.insert i1 i2 vm</span>
<span class="lineno"> 1358 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1359 </span><span class="spaces">    </span><span class="istickedoff">goF c vm (Pi (vnIndex -&gt; i1) ty1 body1) (Pi (vnIndex -&gt; i2) ty2 body2) =</span>
<span class="lineno"> 1360 </span><span class="spaces">      </span><span class="istickedoff">pure (&amp;&amp;) &lt;*&gt; go c vm ty1 ty2 &lt;*&gt; go c vm' body1 body2</span>
<span class="lineno"> 1361 </span><span class="spaces">        </span><span class="istickedoff">where vm' = if i1 == i2 then vm else IntMap.insert i1 i2 vm</span>
<span class="lineno"> 1362 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1363 </span><span class="spaces">    </span><span class="istickedoff">goF c vm (Variable x1 t1) (Variable x2 t2)</span>
<span class="lineno"> 1364 </span><span class="spaces">      </span><span class="istickedoff">| i' == vnIndex x2 = go <span class="nottickedoff">c</span> vm t1 t2</span>
<span class="lineno"> 1365 </span><span class="spaces">        </span><span class="istickedoff">where i' = case IntMap.lookup (vnIndex x1) vm of</span>
<span class="lineno"> 1366 </span><span class="spaces">                     </span><span class="istickedoff">Nothing -&gt; vnIndex x1</span>
<span class="lineno"> 1367 </span><span class="spaces">                     </span><span class="istickedoff">Just i -&gt; i</span>
<span class="lineno"> 1368 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1369 </span><span class="spaces">    </span><span class="istickedoff">-- final catch-all case</span>
<span class="lineno"> 1370 </span><span class="spaces">    </span><span class="istickedoff">goF _c _vm _x _y = pure False</span></span>
<span class="lineno"> 1371 </span>
<span class="lineno"> 1372 </span>-- | Check whether one type is a subtype of another: Either they are
<span class="lineno"> 1373 </span>-- convertible, or they are both Pi types with convertible argument
<span class="lineno"> 1374 </span>-- types and result sorts @s1@ and @s2@ with @s1 &lt;= s2@.
<span class="lineno"> 1375 </span>scmSubtype :: Term -&gt; Term -&gt; SCM Bool
<span class="lineno"> 1376 </span><span class="decl"><span class="istickedoff">scmSubtype t1 t2</span>
<span class="lineno"> 1377 </span><span class="spaces">  </span><span class="istickedoff">| alphaEquiv t1 t2 = pure True</span>
<span class="lineno"> 1378 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1379 </span><span class="spaces">    </span><span class="istickedoff">do t1' &lt;- scmWhnf t1</span>
<span class="lineno"> 1380 </span><span class="spaces">       </span><span class="istickedoff">t2' &lt;- scmWhnf t2</span>
<span class="lineno"> 1381 </span><span class="spaces">       </span><span class="istickedoff">case (t1', t2') of</span>
<span class="lineno"> 1382 </span><span class="spaces">         </span><span class="istickedoff">(asSort -&gt; Just s1, asSort -&gt; Just s2) -&gt;</span>
<span class="lineno"> 1383 </span><span class="spaces">           </span><span class="istickedoff">pure (s1 &lt;= s2)</span>
<span class="lineno"> 1384 </span><span class="spaces">         </span><span class="istickedoff">(unwrapTermF -&gt; Pi x1 a1 b1, unwrapTermF -&gt; Pi x2 a2 b2)</span>
<span class="lineno"> 1385 </span><span class="spaces">           </span><span class="istickedoff">| x1 == x2 -&gt;</span>
<span class="lineno"> 1386 </span><span class="spaces">             </span><span class="istickedoff">(&amp;&amp;) &lt;$&gt; scmConvertible <span class="nottickedoff">True</span> a1 a2 &lt;*&gt; scmSubtype b1 b2</span>
<span class="lineno"> 1387 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1388 </span><span class="spaces">             </span><span class="istickedoff">do conv1 &lt;- scmConvertible <span class="nottickedoff">True</span> a1 a2</span>
<span class="lineno"> 1389 </span><span class="spaces">                </span><span class="istickedoff">var1 &lt;- scmVariable x1 a1</span>
<span class="lineno"> 1390 </span><span class="spaces">                </span><span class="istickedoff">b2' &lt;- scmInstantiate (IntMap.singleton (vnIndex x2) var1) b2</span>
<span class="lineno"> 1391 </span><span class="spaces">                </span><span class="istickedoff">conv2 &lt;- scmSubtype b1 b2'</span>
<span class="lineno"> 1392 </span><span class="spaces">                </span><span class="istickedoff">pure (conv1 &amp;&amp; conv2)</span>
<span class="lineno"> 1393 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1394 </span><span class="spaces">           </span><span class="istickedoff">scmConvertible True t1' t2'</span></span>
<span class="lineno"> 1395 </span>
<span class="lineno"> 1396 </span>
<span class="lineno"> 1397 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1398 </span>-- Type checking
<span class="lineno"> 1399 </span>
<span class="lineno"> 1400 </span>-- | Look up the type of a global constant, given its 'Name'.
<span class="lineno"> 1401 </span>scmTypeOfName :: Name -&gt; SCM Term
<span class="lineno"> 1402 </span><span class="decl"><span class="istickedoff">scmTypeOfName nm =</span>
<span class="lineno"> 1403 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- scmSharedContext</span>
<span class="lineno"> 1404 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- liftIO $ scGetModuleMap sc</span>
<span class="lineno"> 1405 </span><span class="spaces">     </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 1406 </span><span class="spaces">       </span><span class="istickedoff">Just r -&gt; pure (resolvedNameType r)</span>
<span class="lineno"> 1407 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">scmError (NameNotFound nm)</span></span></span>
<span class="lineno"> 1408 </span>
<span class="lineno"> 1409 </span>-- | Return the type of a term.
<span class="lineno"> 1410 </span>scmTypeOf :: Term -&gt; SCM Term
<span class="lineno"> 1411 </span><span class="decl"><span class="istickedoff">scmTypeOf t =</span>
<span class="lineno"> 1412 </span><span class="spaces">  </span><span class="istickedoff">case stAppType t of</span>
<span class="lineno"> 1413 </span><span class="spaces">    </span><span class="istickedoff">Right ty -&gt; pure ty</span>
<span class="lineno"> 1414 </span><span class="spaces">    </span><span class="istickedoff">Left s -&gt; scmSort s</span></span>
<span class="lineno"> 1415 </span>
<span class="lineno"> 1416 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1417 </span>-- Beta Normalization
<span class="lineno"> 1418 </span>
<span class="lineno"> 1419 </span>-- | Instantiate some of the named variables in the term, reducing any
<span class="lineno"> 1420 </span>-- new beta redexes created in the process.
<span class="lineno"> 1421 </span>-- The substitution 'IntMap' is keyed by 'VarIndex'.
<span class="lineno"> 1422 </span>-- If the input term and all terms in the substitution are in
<span class="lineno"> 1423 </span>-- beta-normal form, then the result will also be beta-normal.
<span class="lineno"> 1424 </span>-- If a substituted term is a lambda, and it is substituted into the
<span class="lineno"> 1425 </span>-- left side of an application, creating a new beta redex, then it
<span class="lineno"> 1426 </span>-- will trigger further beta reduction.
<span class="lineno"> 1427 </span>-- Existing beta redexes in the input term or substitution are
<span class="lineno"> 1428 </span>-- not reduced.
<span class="lineno"> 1429 </span>scmInstantiateBeta :: IntMap Term -&gt; Term -&gt; SCM Term
<span class="lineno"> 1430 </span><span class="decl"><span class="istickedoff">scmInstantiateBeta sub t0 =</span>
<span class="lineno"> 1431 </span><span class="spaces">  </span><span class="istickedoff">do let domainVars = IntMap.keysSet sub</span>
<span class="lineno"> 1432 </span><span class="spaces">     </span><span class="istickedoff">let rangeVars = foldMap freeVars sub</span>
<span class="lineno"> 1433 </span><span class="spaces">     </span><span class="istickedoff">cache &lt;- newIntCache</span>
<span class="lineno"> 1434 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; SCM Term</span>
<span class="lineno"> 1435 </span><span class="spaces">         </span><span class="istickedoff">memo t@STApp{stAppIndex = i} = useIntCache cache i (go t)</span>
<span class="lineno"> 1436 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; SCM Term</span>
<span class="lineno"> 1437 </span><span class="spaces">         </span><span class="istickedoff">go t</span>
<span class="lineno"> 1438 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.disjoint domainVars (freeVars t) = pure t</span>
<span class="lineno"> 1439 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goArgs t []</span>
<span class="lineno"> 1440 </span><span class="spaces">         </span><span class="istickedoff">goArgs :: Term -&gt; [Term] -&gt; SCM Term</span>
<span class="lineno"> 1441 </span><span class="spaces">         </span><span class="istickedoff">goArgs t args =</span>
<span class="lineno"> 1442 </span><span class="spaces">           </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1443 </span><span class="spaces">             </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno"> 1444 </span><span class="spaces">               </span><span class="istickedoff">do ftf' &lt;- traverse memo ftf</span>
<span class="lineno"> 1445 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scmFlatTermF ftf'</span>
<span class="lineno"> 1446 </span><span class="spaces">                  </span><span class="istickedoff">scmApplyAll t' args</span>
<span class="lineno"> 1447 </span><span class="spaces">             </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno"> 1448 </span><span class="spaces">               </span><span class="istickedoff">do t2' &lt;- memo t2</span>
<span class="lineno"> 1449 </span><span class="spaces">                  </span><span class="istickedoff">goArgs t1 (t2' : args)</span>
<span class="lineno"> 1450 </span><span class="spaces">             </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 1451 </span><span class="spaces">               </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1452 </span><span class="spaces">                  </span><span class="istickedoff">(x', t2') &lt;- goBinder x t1' t2</span>
<span class="lineno"> 1453 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scmLambda x' t1' t2'</span>
<span class="lineno"> 1454 </span><span class="spaces">                  </span><span class="istickedoff">scmApplyAll t' args</span>
<span class="lineno"> 1455 </span><span class="spaces">             </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 1456 </span><span class="spaces">               </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1457 </span><span class="spaces">                  </span><span class="istickedoff">(x', t2') &lt;- goBinder x <span class="nottickedoff">t1'</span> t2</span>
<span class="lineno"> 1458 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scmPi x' t1' t2'</span>
<span class="lineno"> 1459 </span><span class="spaces">                  </span><span class="istickedoff">scmApplyAll t' args</span>
<span class="lineno"> 1460 </span><span class="spaces">             </span><span class="istickedoff">Constant {} -&gt;</span>
<span class="lineno"> 1461 </span><span class="spaces">               </span><span class="istickedoff">scmApplyAll t args</span>
<span class="lineno"> 1462 </span><span class="spaces">             </span><span class="istickedoff">Variable x t1 -&gt;</span>
<span class="lineno"> 1463 </span><span class="spaces">               </span><span class="istickedoff">case IntMap.lookup (vnIndex x) sub of</span>
<span class="lineno"> 1464 </span><span class="spaces">                 </span><span class="istickedoff">Just t' -&gt; scmApplyAllBeta t' args</span>
<span class="lineno"> 1465 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1466 </span><span class="spaces">                   </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1467 </span><span class="spaces">                      </span><span class="istickedoff">t' &lt;- scmVariable x t1'</span>
<span class="lineno"> 1468 </span><span class="spaces">                      </span><span class="istickedoff">scmApplyAll t' args</span>
<span class="lineno"> 1469 </span><span class="spaces">         </span><span class="istickedoff">goBinder :: VarName -&gt; Term -&gt; Term -&gt; SCM (VarName, Term)</span>
<span class="lineno"> 1470 </span><span class="spaces">         </span><span class="istickedoff">goBinder x@(vnIndex -&gt; i) t body</span>
<span class="lineno"> 1471 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.member i rangeVars =</span>
<span class="lineno"> 1472 </span><span class="spaces">               </span><span class="istickedoff">-- Possibility of capture; rename bound variable.</span>
<span class="lineno"> 1473 </span><span class="spaces">               </span><span class="istickedoff">do x' &lt;- scmFreshVarName (vnName x)</span>
<span class="lineno"> 1474 </span><span class="spaces">                  </span><span class="istickedoff">var &lt;- scmVariable x' t</span>
<span class="lineno"> 1475 </span><span class="spaces">                  </span><span class="istickedoff">let sub' = IntMap.insert i var sub</span>
<span class="lineno"> 1476 </span><span class="spaces">                  </span><span class="istickedoff">body' &lt;- scmInstantiateBeta sub' body</span>
<span class="lineno"> 1477 </span><span class="spaces">                  </span><span class="istickedoff">pure (x', body')</span>
<span class="lineno"> 1478 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlyfalse">IntMap.member i sub</span> =</span>
<span class="lineno"> 1479 </span><span class="spaces">               </span><span class="istickedoff">-- Shadowing; remove entry from substitution.</span>
<span class="lineno"> 1480 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">do let sub' = IntMap.delete i sub</span></span>
<span class="lineno"> 1481 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">body' &lt;- scmInstantiateBeta sub' body</span></span>
<span class="lineno"> 1482 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">pure (x, body')</span></span>
<span class="lineno"> 1483 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1484 </span><span class="spaces">               </span><span class="istickedoff">-- No possibility of shadowing or capture.</span>
<span class="lineno"> 1485 </span><span class="spaces">               </span><span class="istickedoff">do body' &lt;- memo body</span>
<span class="lineno"> 1486 </span><span class="spaces">                  </span><span class="istickedoff">pure (x, body')</span>
<span class="lineno"> 1487 </span><span class="spaces">     </span><span class="istickedoff">go t0</span></span>
<span class="lineno"> 1488 </span>
<span class="lineno"> 1489 </span>-- | Apply a function 'Term' to a list of zero or more arguments.
<span class="lineno"> 1490 </span>-- If the function is a lambda term, then beta reduce the arguments
<span class="lineno"> 1491 </span>-- into the function body.
<span class="lineno"> 1492 </span>-- If all input terms are in beta-normal form, then the result will
<span class="lineno"> 1493 </span>-- also be beta-normal.
<span class="lineno"> 1494 </span>scmApplyAllBeta :: Term -&gt; [Term] -&gt; SCM Term
<span class="lineno"> 1495 </span><span class="decl"><span class="istickedoff">scmApplyAllBeta t0 [] = pure t0</span>
<span class="lineno"> 1496 </span><span class="spaces"></span><span class="istickedoff">scmApplyAllBeta t0 (arg0 : args0) =</span>
<span class="lineno"> 1497 </span><span class="spaces">  </span><span class="istickedoff">case asLambda t0 of</span>
<span class="lineno"> 1498 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; scmApplyAll t0 (arg0 : args0)</span>
<span class="lineno"> 1499 </span><span class="spaces">    </span><span class="istickedoff">Just (x, _, body) -&gt; go (IntMap.singleton (vnIndex x) arg0) body args0</span>
<span class="lineno"> 1500 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1501 </span><span class="spaces">    </span><span class="istickedoff">go :: IntMap Term -&gt; Term -&gt; [Term] -&gt; SCM Term</span>
<span class="lineno"> 1502 </span><span class="spaces">    </span><span class="istickedoff">go sub (asLambda -&gt; Just (x, _, body)) (arg : args) =</span>
<span class="lineno"> 1503 </span><span class="spaces">      </span><span class="istickedoff">go (IntMap.insert (vnIndex x) arg sub) body args</span>
<span class="lineno"> 1504 </span><span class="spaces">    </span><span class="istickedoff">go sub t args =</span>
<span class="lineno"> 1505 </span><span class="spaces">      </span><span class="istickedoff">do t' &lt;- scmInstantiateBeta sub t</span>
<span class="lineno"> 1506 </span><span class="spaces">         </span><span class="istickedoff">scmApplyAllBeta t' args</span></span>
<span class="lineno"> 1507 </span>
<span class="lineno"> 1508 </span>
<span class="lineno"> 1509 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1510 </span>-- Building shared terms
<span class="lineno"> 1511 </span>
<span class="lineno"> 1512 </span>-- | Apply a function 'Term' to zero or more argument 'Term's.
<span class="lineno"> 1513 </span>scmApplyAll :: Term -&gt; [Term] -&gt; SCM Term
<span class="lineno"> 1514 </span><span class="decl"><span class="istickedoff">scmApplyAll = foldlM scmApply</span></span>
<span class="lineno"> 1515 </span>
<span class="lineno"> 1516 </span>-- | Create a term from a 'Sort'.
<span class="lineno"> 1517 </span>scmSort :: Sort -&gt; SCM Term
<span class="lineno"> 1518 </span><span class="decl"><span class="istickedoff">scmSort s = scmSortWithFlags s noFlags</span></span>
<span class="lineno"> 1519 </span>
<span class="lineno"> 1520 </span>-- | Create a term from a 'Sort', and set the given advisory flags
<span class="lineno"> 1521 </span>scmSortWithFlags :: Sort -&gt; SortFlags -&gt; SCM Term
<span class="lineno"> 1522 </span><span class="decl"><span class="istickedoff">scmSortWithFlags s flags =</span>
<span class="lineno"> 1523 </span><span class="spaces">  </span><span class="istickedoff">scmMakeTerm IntMap.empty (FTermF (Sort s flags)) (Left (sortOf s))</span></span>
<span class="lineno"> 1524 </span>
<span class="lineno"> 1525 </span>-- | Create a literal term from a 'Natural'.
<span class="lineno"> 1526 </span>scmNat :: Natural -&gt; SCM Term
<span class="lineno"> 1527 </span><span class="decl"><span class="istickedoff">scmNat 0 = scmGlobalDef &quot;Prelude.Zero&quot;</span>
<span class="lineno"> 1528 </span><span class="spaces"></span><span class="istickedoff">scmNat n =</span>
<span class="lineno"> 1529 </span><span class="spaces">  </span><span class="istickedoff">do p &lt;- scmPos n</span>
<span class="lineno"> 1530 </span><span class="spaces">     </span><span class="istickedoff">scmGlobalApply &quot;Prelude.NatPos&quot; [p]</span></span>
<span class="lineno"> 1531 </span>
<span class="lineno"> 1532 </span>scmPos :: Natural -&gt; SCM Term
<span class="lineno"> 1533 </span><span class="decl"><span class="istickedoff">scmPos n</span>
<span class="lineno"> 1534 </span><span class="spaces">  </span><span class="istickedoff">| n &lt;= 1 = scmGlobalDef &quot;Prelude.One&quot;</span>
<span class="lineno"> 1535 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1536 </span><span class="spaces">    </span><span class="istickedoff">do arg &lt;- scmPos (div n 2)</span>
<span class="lineno"> 1537 </span><span class="spaces">       </span><span class="istickedoff">let ident = if even n then &quot;Prelude.Bit0&quot; else &quot;Prelude.Bit1&quot;</span>
<span class="lineno"> 1538 </span><span class="spaces">       </span><span class="istickedoff">scmGlobalApply ident [arg]</span></span>
<span class="lineno"> 1539 </span>
<span class="lineno"> 1540 </span>-- | Create a literal term (of saw-core type @String@) from a 'Text'.
<span class="lineno"> 1541 </span>scmString :: Text -&gt; SCM Term
<span class="lineno"> 1542 </span><span class="decl"><span class="istickedoff">scmString s =</span>
<span class="lineno"> 1543 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scmStringType</span>
<span class="lineno"> 1544 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm IntMap.empty (FTermF (StringLit s)) (Right ty)</span></span>
<span class="lineno"> 1545 </span>
<span class="lineno"> 1546 </span>-- | Create a term representing the primitive saw-core type @String@.
<span class="lineno"> 1547 </span>scmStringType :: SCM Term
<span class="lineno"> 1548 </span><span class="decl"><span class="istickedoff">scmStringType = scmGlobalDef preludeStringIdent</span></span>
<span class="lineno"> 1549 </span>
<span class="lineno"> 1550 </span>-- | Create a vector term from a type (as a 'Term') and a list of 'Term's of
<span class="lineno"> 1551 </span>-- that type.
<span class="lineno"> 1552 </span>scmVector :: Term -&gt; [Term] -&gt; SCM Term
<span class="lineno"> 1553 </span><span class="decl"><span class="istickedoff">scmVector e xs =</span>
<span class="lineno"> 1554 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm e</span>
<span class="lineno"> 1555 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- foldM (scmUnifyVarTypes <span class="nottickedoff">&quot;scVector&quot;</span>) (varTypes e) (map varTypes xs)</span>
<span class="lineno"> 1556 </span><span class="spaces">     </span><span class="istickedoff">let check x =</span>
<span class="lineno"> 1557 </span><span class="spaces">           </span><span class="istickedoff">do scmEnsureValidTerm x</span>
<span class="lineno"> 1558 </span><span class="spaces">              </span><span class="istickedoff">xty &lt;- scmTypeOf x</span>
<span class="lineno"> 1559 </span><span class="spaces">              </span><span class="istickedoff">ok &lt;- scmSubtype xty e</span>
<span class="lineno"> 1560 </span><span class="spaces">              </span><span class="istickedoff">unless ok $ <span class="nottickedoff">scmError (VectorNotSubtype e x)</span></span>
<span class="lineno"> 1561 </span><span class="spaces">     </span><span class="istickedoff">mapM_ check xs</span>
<span class="lineno"> 1562 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- scmNat (fromIntegral (length xs))</span>
<span class="lineno"> 1563 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (ArrayValue e (V.fromList xs))</span>
<span class="lineno"> 1564 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scmVecType n e</span>
<span class="lineno"> 1565 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt tf (Right ty)</span></span>
<span class="lineno"> 1566 </span>
<span class="lineno"> 1567 </span>-- | Create a term representing a vector type, from a term giving the length
<span class="lineno"> 1568 </span>-- and a term giving the element type.
<span class="lineno"> 1569 </span>scmVecType :: Term -&gt; Term -&gt; SCM Term
<span class="lineno"> 1570 </span><span class="decl"><span class="istickedoff">scmVecType n e = scmGlobalApply preludeVecIdent [n, e]</span></span>
<span class="lineno"> 1571 </span>
<span class="lineno"> 1572 </span>-- | Create a record term from a list of record fields.
<span class="lineno"> 1573 </span>scmRecordValue :: [(FieldName, Term)] -&gt; SCM Term
<span class="lineno"> 1574 </span><span class="decl"><span class="istickedoff">scmRecordValue fields =</span>
<span class="lineno"> 1575 </span><span class="spaces">  </span><span class="istickedoff">do mapM_ (scmEnsureValidTerm . snd) fields</span>
<span class="lineno"> 1576 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- foldM (scmUnifyVarTypes <span class="nottickedoff">&quot;scRecord&quot;</span>) IntMap.empty (map (varTypes . snd) fields)</span>
<span class="lineno"> 1577 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (RecordValue fields)</span>
<span class="lineno"> 1578 </span><span class="spaces">     </span><span class="istickedoff">field_tys &lt;- traverse (traverse (scmTypeOf)) fields</span>
<span class="lineno"> 1579 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scmRecordType field_tys</span>
<span class="lineno"> 1580 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt tf (Right ty)</span></span>
<span class="lineno"> 1581 </span>
<span class="lineno"> 1582 </span>-- | Create a record field access term from a 'Term' representing a record and
<span class="lineno"> 1583 </span>-- a 'FieldName'.
<span class="lineno"> 1584 </span>scmRecordSelect :: Term -&gt; FieldName -&gt; SCM Term
<span class="lineno"> 1585 </span><span class="decl"><span class="istickedoff">scmRecordSelect t fname =</span>
<span class="lineno"> 1586 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t</span>
<span class="lineno"> 1587 </span><span class="spaces">     </span><span class="istickedoff">let vt = varTypes t</span>
<span class="lineno"> 1588 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (RecordProj t fname)</span>
<span class="lineno"> 1589 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scmTypeOf t</span>
<span class="lineno"> 1590 </span><span class="spaces">     </span><span class="istickedoff">field_tys &lt;- scmEnsureRecognizer (NotRecord t) asRecordType ty</span>
<span class="lineno"> 1591 </span><span class="spaces">     </span><span class="istickedoff">case Map.lookup fname field_tys of</span>
<span class="lineno"> 1592 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; scmError (FieldNotFound t fname)</span>
<span class="lineno"> 1593 </span><span class="spaces">       </span><span class="istickedoff">Just ty' -&gt; scmMakeTerm vt tf (Right ty')</span></span>
<span class="lineno"> 1594 </span>
<span class="lineno"> 1595 </span>-- | Create a term representing the type of a record from a list associating
<span class="lineno"> 1596 </span>-- field names (as 'FieldName's) and types (as 'Term's). Note that the order of
<span class="lineno"> 1597 </span>-- the given list is irrelevant, as record fields are not ordered.
<span class="lineno"> 1598 </span>scmRecordType :: [(FieldName, Term)] -&gt; SCM Term
<span class="lineno"> 1599 </span><span class="decl"><span class="istickedoff">scmRecordType field_tys =</span>
<span class="lineno"> 1600 </span><span class="spaces">  </span><span class="istickedoff">do mapM_ (scmEnsureValidTerm . snd) field_tys</span>
<span class="lineno"> 1601 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- foldM (scmUnifyVarTypes <span class="nottickedoff">&quot;scRecordType&quot;</span>) IntMap.empty (map (varTypes . snd) field_tys)</span>
<span class="lineno"> 1602 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (RecordType field_tys)</span>
<span class="lineno"> 1603 </span><span class="spaces">     </span><span class="istickedoff">let field_sort (_, t) = scmEnsureSortType t</span>
<span class="lineno"> 1604 </span><span class="spaces">     </span><span class="istickedoff">sorts &lt;- traverse field_sort field_tys</span>
<span class="lineno"> 1605 </span><span class="spaces">     </span><span class="istickedoff">let s = foldl max (mkSort 0) sorts</span>
<span class="lineno"> 1606 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt tf (Left s)</span></span>
<span class="lineno"> 1607 </span>
<span class="lineno"> 1608 </span>-- | Create a unit-valued term.
<span class="lineno"> 1609 </span>scmUnitValue :: SCM Term
<span class="lineno"> 1610 </span><span class="decl"><span class="istickedoff">scmUnitValue =</span>
<span class="lineno"> 1611 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scmUnitType</span>
<span class="lineno"> 1612 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm IntMap.empty (FTermF UnitValue) (Right ty)</span></span>
<span class="lineno"> 1613 </span>
<span class="lineno"> 1614 </span>-- | Create a term representing the unit type.
<span class="lineno"> 1615 </span>scmUnitType :: SCM Term
<span class="lineno"> 1616 </span><span class="decl"><span class="istickedoff">scmUnitType =</span>
<span class="lineno"> 1617 </span><span class="spaces">  </span><span class="istickedoff">scmMakeTerm IntMap.empty (FTermF UnitType) (Left (TypeSort 0))</span></span>
<span class="lineno"> 1618 </span>
<span class="lineno"> 1619 </span>-- | Create a pair term from two terms.
<span class="lineno"> 1620 </span>scmPairValue ::
<span class="lineno"> 1621 </span>  Term {- ^ The left projection -} -&gt;
<span class="lineno"> 1622 </span>  Term {- ^ The right projection -} -&gt;
<span class="lineno"> 1623 </span>  SCM Term
<span class="lineno"> 1624 </span><span class="decl"><span class="istickedoff">scmPairValue t1 t2 =</span>
<span class="lineno"> 1625 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t1</span>
<span class="lineno"> 1626 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureValidTerm t2</span>
<span class="lineno"> 1627 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scPairValue&quot;</span> (varTypes t1) (varTypes t2)</span>
<span class="lineno"> 1628 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (PairValue t1 t2)</span>
<span class="lineno"> 1629 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- scmTypeOf t1</span>
<span class="lineno"> 1630 </span><span class="spaces">     </span><span class="istickedoff">ty2 &lt;- scmTypeOf t2</span>
<span class="lineno"> 1631 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scmPairType ty1 ty2</span>
<span class="lineno"> 1632 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt tf (Right ty)</span></span>
<span class="lineno"> 1633 </span>
<span class="lineno"> 1634 </span>-- | Create a term representing a pair type from two other terms, each
<span class="lineno"> 1635 </span>-- representing a type.
<span class="lineno"> 1636 </span>scmPairType ::
<span class="lineno"> 1637 </span>  Term {- ^ Left projection type -} -&gt;
<span class="lineno"> 1638 </span>  Term {- ^ Right projection type -} -&gt;
<span class="lineno"> 1639 </span>  SCM Term
<span class="lineno"> 1640 </span><span class="decl"><span class="istickedoff">scmPairType t1 t2 =</span>
<span class="lineno"> 1641 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t1</span>
<span class="lineno"> 1642 </span><span class="spaces">     </span><span class="istickedoff">scmEnsureValidTerm t2</span>
<span class="lineno"> 1643 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- scmUnifyVarTypes <span class="nottickedoff">&quot;scPairType&quot;</span> (varTypes t1) (varTypes t2)</span>
<span class="lineno"> 1644 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (PairType t1 t2)</span>
<span class="lineno"> 1645 </span><span class="spaces">     </span><span class="istickedoff">s1 &lt;- scmEnsureSortType t1</span>
<span class="lineno"> 1646 </span><span class="spaces">     </span><span class="istickedoff">s2 &lt;- scmEnsureSortType t2</span>
<span class="lineno"> 1647 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm vt tf (Left (max s1 s2))</span></span>
<span class="lineno"> 1648 </span>
<span class="lineno"> 1649 </span>-- | Create a term giving the left projection of a 'Term' representing a pair.
<span class="lineno"> 1650 </span>scmPairLeft :: Term -&gt; SCM Term
<span class="lineno"> 1651 </span><span class="decl"><span class="istickedoff">scmPairLeft t =</span>
<span class="lineno"> 1652 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t</span>
<span class="lineno"> 1653 </span><span class="spaces">     </span><span class="istickedoff">(ty, _) &lt;- scmEnsurePairType t</span>
<span class="lineno"> 1654 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right ty) <span class="nottickedoff">Left</span> (asSort ty)</span>
<span class="lineno"> 1655 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm (varTypes t) (FTermF (PairLeft t)) mty</span></span>
<span class="lineno"> 1656 </span>
<span class="lineno"> 1657 </span>-- | Create a term giving the right projection of a 'Term' representing a pair.
<span class="lineno"> 1658 </span>scmPairRight :: Term -&gt; SCM Term
<span class="lineno"> 1659 </span><span class="decl"><span class="istickedoff">scmPairRight t =</span>
<span class="lineno"> 1660 </span><span class="spaces">  </span><span class="istickedoff">do scmEnsureValidTerm t</span>
<span class="lineno"> 1661 </span><span class="spaces">     </span><span class="istickedoff">(_, ty) &lt;- scmEnsurePairType t</span>
<span class="lineno"> 1662 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right ty) <span class="nottickedoff">Left</span> (asSort ty)</span>
<span class="lineno"> 1663 </span><span class="spaces">     </span><span class="istickedoff">scmMakeTerm (varTypes t) (FTermF (PairRight t)) mty</span></span>
<span class="lineno"> 1664 </span>
<span class="lineno"> 1665 </span>-- | Create a term representing either the left or right projection of the
<span class="lineno"> 1666 </span>-- given 'Term', depending on the given 'Bool': left if @False@, right if @True@.
<span class="lineno"> 1667 </span>scmPairSelector :: Term -&gt; Bool -&gt; SCM Term
<span class="lineno"> 1668 </span><span class="decl"><span class="istickedoff">scmPairSelector t False = scmPairLeft t</span>
<span class="lineno"> 1669 </span><span class="spaces"></span><span class="istickedoff">scmPairSelector t True = <span class="nottickedoff">scmPairRight t</span></span></span>
<span class="lineno"> 1670 </span>
<span class="lineno"> 1671 </span>-- | Create a term representing the type of a non-dependent function, given a
<span class="lineno"> 1672 </span>-- parameter and result type (as 'Term's).
<span class="lineno"> 1673 </span>scmFun ::
<span class="lineno"> 1674 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno"> 1675 </span>  Term {- ^ The result type -} -&gt;
<span class="lineno"> 1676 </span>  SCM Term
<span class="lineno"> 1677 </span><span class="decl"><span class="istickedoff">scmFun a b = scmPi wildcardVarName a b</span></span>
<span class="lineno"> 1678 </span>
<span class="lineno"> 1679 </span>-- | Create a term representing the type of a non-dependent n-ary function,
<span class="lineno"> 1680 </span>-- given a list of parameter types and a result type (as terms).
<span class="lineno"> 1681 </span>scmFunAll ::
<span class="lineno"> 1682 </span>  [Term] {- ^ The parameter types -} -&gt;
<span class="lineno"> 1683 </span>  Term {- ^ The result type -} -&gt;
<span class="lineno"> 1684 </span>  SCM Term
<span class="lineno"> 1685 </span><span class="decl"><span class="istickedoff">scmFunAll argTypes resultType = foldrM scmFun resultType argTypes</span></span>
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>-- | Create a lambda term of multiple arguments (curried) from a list
<span class="lineno"> 1688 </span>-- associating parameter names to types (as 'Term's) and a body.
<span class="lineno"> 1689 </span>-- The parameters are listed outermost first.
<span class="lineno"> 1690 </span>-- Variable names in the parameter list are in scope for all parameter
<span class="lineno"> 1691 </span>-- types occurring later in the list.
<span class="lineno"> 1692 </span>scmLambdaList ::
<span class="lineno"> 1693 </span>  [(VarName, Term)] {- ^ List of parameter / parameter type pairs -} -&gt;
<span class="lineno"> 1694 </span>  Term {- ^ The body -} -&gt;
<span class="lineno"> 1695 </span>  SCM Term
<span class="lineno"> 1696 </span><span class="decl"><span class="istickedoff">scmLambdaList [] body = pure body</span>
<span class="lineno"> 1697 </span><span class="spaces"></span><span class="istickedoff">scmLambdaList ((x, t) : xts) body =</span>
<span class="lineno"> 1698 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">scmLambda x t =&lt;&lt; scmLambdaList xts body</span></span></span>
<span class="lineno"> 1699 </span>
<span class="lineno"> 1700 </span>-- | Create a (possibly dependent) function of multiple arguments (curried)
<span class="lineno"> 1701 </span>-- from a list associating parameter names to types (as 'Term's) and a body.
<span class="lineno"> 1702 </span>-- Variable names in the parameter list are in scope for all parameter
<span class="lineno"> 1703 </span>-- types occurring later in the list.
<span class="lineno"> 1704 </span>scmPiList ::
<span class="lineno"> 1705 </span>  [(VarName, Term)] {- ^ List of parameter / parameter type pairs -} -&gt;
<span class="lineno"> 1706 </span>  Term {- ^ The body -} -&gt;
<span class="lineno"> 1707 </span>  SCM Term
<span class="lineno"> 1708 </span><span class="decl"><span class="istickedoff">scmPiList [] body = pure body</span>
<span class="lineno"> 1709 </span><span class="spaces"></span><span class="istickedoff">scmPiList ((x, t) : xts) body =</span>
<span class="lineno"> 1710 </span><span class="spaces">  </span><span class="istickedoff">scmPi x t =&lt;&lt; scmPiList xts body</span></span>
<span class="lineno"> 1711 </span>
<span class="lineno"> 1712 </span>-- | Define a global constant with the specified base name (as
<span class="lineno"> 1713 </span>-- 'Text') and body.
<span class="lineno"> 1714 </span>-- The term for the body must not have any free variables.
<span class="lineno"> 1715 </span>-- A globally-unique name with the specified base name will be created
<span class="lineno"> 1716 </span>-- using 'scFreshName'.
<span class="lineno"> 1717 </span>-- The type of the body determines the type of the constant; to
<span class="lineno"> 1718 </span>-- specify a different formulation of the type, use 'scAscribe'.
<span class="lineno"> 1719 </span>scmFreshConstant ::
<span class="lineno"> 1720 </span>  Text {- ^ The base name -} -&gt;
<span class="lineno"> 1721 </span>  Term {- ^ The body -} -&gt;
<span class="lineno"> 1722 </span>  SCM Term
<span class="lineno"> 1723 </span><span class="decl"><span class="nottickedoff">scmFreshConstant name rhs =</span>
<span class="lineno"> 1724 </span><span class="spaces">  </span><span class="nottickedoff">do nm &lt;- scmFreshName name</span>
<span class="lineno"> 1725 </span><span class="spaces">     </span><span class="nottickedoff">unless (closedTerm rhs) $ scmError (ConstantNotClosed nm rhs)</span>
<span class="lineno"> 1726 </span><span class="spaces">     </span><span class="nottickedoff">ty &lt;- scmTypeOf rhs</span>
<span class="lineno"> 1727 </span><span class="spaces">     </span><span class="nottickedoff">scmDeclareDef nm NoQualifier ty (Just rhs)</span></span>
<span class="lineno"> 1728 </span>
<span class="lineno"> 1729 </span>-- | Define a global constant with the specified name (as 'NameInfo')
<span class="lineno"> 1730 </span>-- and body.
<span class="lineno"> 1731 </span>-- The URI in the given 'NameInfo' must be globally unique.
<span class="lineno"> 1732 </span>-- The term for the body must not have any free variables.
<span class="lineno"> 1733 </span>-- The type of the body determines the type of the constant; to
<span class="lineno"> 1734 </span>-- specify a different formulation of the type, use 'scAscribe'.
<span class="lineno"> 1735 </span>scmDefineConstant ::
<span class="lineno"> 1736 </span>  NameInfo {- ^ The name -} -&gt;
<span class="lineno"> 1737 </span>  Term {- ^ The body -} -&gt;
<span class="lineno"> 1738 </span>  SCM Term
<span class="lineno"> 1739 </span><span class="decl"><span class="istickedoff">scmDefineConstant nmi rhs =</span>
<span class="lineno"> 1740 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scmTypeOf rhs</span>
<span class="lineno"> 1741 </span><span class="spaces">     </span><span class="istickedoff">nm &lt;- scmRegisterName nmi</span>
<span class="lineno"> 1742 </span><span class="spaces">     </span><span class="istickedoff">unless (closedTerm rhs) $</span>
<span class="lineno"> 1743 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">scmError (ConstantNotClosed nm rhs)</span></span>
<span class="lineno"> 1744 </span><span class="spaces">     </span><span class="istickedoff">scmDeclareDef nm <span class="nottickedoff">NoQualifier</span> ty (Just rhs)</span></span>
<span class="lineno"> 1745 </span>
<span class="lineno"> 1746 </span>-- | Declare a global opaque constant with the specified name (as
<span class="lineno"> 1747 </span>-- 'NameInfo') and type.
<span class="lineno"> 1748 </span>-- Such a constant has no definition, but unlike a variable it may be
<span class="lineno"> 1749 </span>-- used in other constant definitions and is not subject to
<span class="lineno"> 1750 </span>-- lambda-binding or substitution.
<span class="lineno"> 1751 </span>scmOpaqueConstant ::
<span class="lineno"> 1752 </span>  NameInfo -&gt;
<span class="lineno"> 1753 </span>  Term {- ^ type of the constant -} -&gt;
<span class="lineno"> 1754 </span>  SCM Term
<span class="lineno"> 1755 </span><span class="decl"><span class="istickedoff">scmOpaqueConstant nmi ty =</span>
<span class="lineno"> 1756 </span><span class="spaces">  </span><span class="istickedoff">do _ &lt;- scmEnsureSortType ty</span>
<span class="lineno"> 1757 </span><span class="spaces">     </span><span class="istickedoff">nm &lt;- scmRegisterName nmi</span>
<span class="lineno"> 1758 </span><span class="spaces">     </span><span class="istickedoff">scmDeclareDef nm <span class="nottickedoff">NoQualifier</span> ty Nothing</span></span>
<span class="lineno"> 1759 </span>
<span class="lineno"> 1760 </span>-- | Create a function application term from a global identifier and a list of
<span class="lineno"> 1761 </span>-- arguments (as 'Term's).
<span class="lineno"> 1762 </span>scmGlobalApply :: Ident -&gt; [Term] -&gt; SCM Term
<span class="lineno"> 1763 </span><span class="decl"><span class="istickedoff">scmGlobalApply i ts =</span>
<span class="lineno"> 1764 </span><span class="spaces">    </span><span class="istickedoff">do c &lt;- scmGlobalDef i</span>
<span class="lineno"> 1765 </span><span class="spaces">       </span><span class="istickedoff">scmApplyAll c ts</span></span>
<span class="lineno"> 1766 </span>
<span class="lineno"> 1767 </span>
<span class="lineno"> 1768 </span>------------------------------------------------------------
<span class="lineno"> 1769 </span>
<span class="lineno"> 1770 </span>-- | The default instance of the SharedContext operations.
<span class="lineno"> 1771 </span>mkSharedContext :: IO SharedContext
<span class="lineno"> 1772 </span><span class="decl"><span class="istickedoff">mkSharedContext =</span>
<span class="lineno"> 1773 </span><span class="spaces">  </span><span class="istickedoff">do vr &lt;- newIORef (1 :: VarIndex) -- 0 is reserved for wildcardVarName.</span>
<span class="lineno"> 1774 </span><span class="spaces">     </span><span class="istickedoff">cr &lt;- newIORef emptyAppCache</span>
<span class="lineno"> 1775 </span><span class="spaces">     </span><span class="istickedoff">gr &lt;- newIORef HMap.empty</span>
<span class="lineno"> 1776 </span><span class="spaces">     </span><span class="istickedoff">mr &lt;- newIORef emptyModuleMap</span>
<span class="lineno"> 1777 </span><span class="spaces">     </span><span class="istickedoff">dr &lt;- newIORef emptyDisplayNameEnv</span>
<span class="lineno"> 1778 </span><span class="spaces">     </span><span class="istickedoff">ur &lt;- newIORef Map.empty</span>
<span class="lineno"> 1779 </span><span class="spaces">     </span><span class="istickedoff">-- The top 16 bits of the TermIndex form a unique ID for this</span>
<span class="lineno"> 1780 </span><span class="spaces">     </span><span class="istickedoff">-- particular SharedContext.</span>
<span class="lineno"> 1781 </span><span class="spaces">     </span><span class="istickedoff">-- We expect that the low 48 bits will never overflow.</span>
<span class="lineno"> 1782 </span><span class="spaces">     </span><span class="istickedoff">scid &lt;- getUniqueInt</span>
<span class="lineno"> 1783 </span><span class="spaces">     </span><span class="istickedoff">let i0 = scid `shiftL` 48</span>
<span class="lineno"> 1784 </span><span class="spaces">     </span><span class="istickedoff">tr &lt;- newIORef (i0 :: TermIndex)</span>
<span class="lineno"> 1785 </span><span class="spaces">     </span><span class="istickedoff">let j0 = i0 + (1 `shiftL` 48 - 1)</span>
<span class="lineno"> 1786 </span><span class="spaces">     </span><span class="istickedoff">ir &lt;- newIORef (IntRangeSet.singleton (i0, j0))</span>
<span class="lineno"> 1787 </span><span class="spaces">     </span><span class="istickedoff">pure $</span>
<span class="lineno"> 1788 </span><span class="spaces">       </span><span class="istickedoff">SharedContext</span>
<span class="lineno"> 1789 </span><span class="spaces">       </span><span class="istickedoff">{ scModuleMap = mr</span>
<span class="lineno"> 1790 </span><span class="spaces">       </span><span class="istickedoff">, scAppCache = cr</span>
<span class="lineno"> 1791 </span><span class="spaces">       </span><span class="istickedoff">, scNextVarIndex = vr</span>
<span class="lineno"> 1792 </span><span class="spaces">       </span><span class="istickedoff">, scDisplayNameEnv = dr</span>
<span class="lineno"> 1793 </span><span class="spaces">       </span><span class="istickedoff">, scURIEnv = ur</span>
<span class="lineno"> 1794 </span><span class="spaces">       </span><span class="istickedoff">, scGlobalEnv = gr</span>
<span class="lineno"> 1795 </span><span class="spaces">       </span><span class="istickedoff">, scNextTermIndex = tr</span>
<span class="lineno"> 1796 </span><span class="spaces">       </span><span class="istickedoff">, scValidTerms = ir</span>
<span class="lineno"> 1797 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1798 </span>
<span class="lineno"> 1799 </span>-- | Instantiate some of the named variables in the term.
<span class="lineno"> 1800 </span>-- The 'IntMap' is keyed by 'VarIndex'.
<span class="lineno"> 1801 </span>-- Note: The replacement is _not_ applied recursively
<span class="lineno"> 1802 </span>-- to the terms in the substitution map.
<span class="lineno"> 1803 </span>scmInstantiate :: IntMap Term -&gt; Term -&gt; SCM Term
<span class="lineno"> 1804 </span><span class="decl"><span class="istickedoff">scmInstantiate vmap t0 =</span>
<span class="lineno"> 1805 </span><span class="spaces">  </span><span class="istickedoff">do let domainVars = IntMap.keysSet vmap</span>
<span class="lineno"> 1806 </span><span class="spaces">     </span><span class="istickedoff">let rangeVars = foldMap freeVars vmap</span>
<span class="lineno"> 1807 </span><span class="spaces">     </span><span class="istickedoff">tcache &lt;- newIntCache</span>
<span class="lineno"> 1808 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; SCM Term</span>
<span class="lineno"> 1809 </span><span class="spaces">         </span><span class="istickedoff">memo t = useIntCache tcache (termIndex t) (go t)</span>
<span class="lineno"> 1810 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; SCM Term</span>
<span class="lineno"> 1811 </span><span class="spaces">         </span><span class="istickedoff">go t</span>
<span class="lineno"> 1812 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.disjoint domainVars (freeVars t) = pure t</span>
<span class="lineno"> 1813 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1814 </span><span class="spaces">             </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1815 </span><span class="spaces">               </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno"> 1816 </span><span class="spaces">                 </span><span class="istickedoff">scmFlatTermF =&lt;&lt; traverse memo ftf</span>
<span class="lineno"> 1817 </span><span class="spaces">               </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno"> 1818 </span><span class="spaces">                 </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1819 </span><span class="spaces">                    </span><span class="istickedoff">t2' &lt;- memo t2</span>
<span class="lineno"> 1820 </span><span class="spaces">                    </span><span class="istickedoff">scmApply t1' t2'</span>
<span class="lineno"> 1821 </span><span class="spaces">               </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 1822 </span><span class="spaces">                 </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1823 </span><span class="spaces">                    </span><span class="istickedoff">(x', t2') &lt;- goBinder x t1' t2</span>
<span class="lineno"> 1824 </span><span class="spaces">                    </span><span class="istickedoff">scmLambda x' t1' t2'</span>
<span class="lineno"> 1825 </span><span class="spaces">               </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 1826 </span><span class="spaces">                 </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1827 </span><span class="spaces">                    </span><span class="istickedoff">(x', t2') &lt;- goBinder x <span class="nottickedoff">t1'</span> t2</span>
<span class="lineno"> 1828 </span><span class="spaces">                    </span><span class="istickedoff">scmPi x' t1' t2'</span>
<span class="lineno"> 1829 </span><span class="spaces">               </span><span class="istickedoff">Constant {} -&gt; <span class="nottickedoff">pure t</span></span>
<span class="lineno"> 1830 </span><span class="spaces">               </span><span class="istickedoff">Variable nm tp -&gt;</span>
<span class="lineno"> 1831 </span><span class="spaces">                 </span><span class="istickedoff">case IntMap.lookup (vnIndex nm) vmap of</span>
<span class="lineno"> 1832 </span><span class="spaces">                   </span><span class="istickedoff">Just t' -&gt; pure t'</span>
<span class="lineno"> 1833 </span><span class="spaces">                   </span><span class="istickedoff">Nothing -&gt; scmVariable nm =&lt;&lt; memo tp</span>
<span class="lineno"> 1834 </span><span class="spaces">         </span><span class="istickedoff">goBinder :: VarName -&gt; Term -&gt; Term -&gt; SCM (VarName, Term)</span>
<span class="lineno"> 1835 </span><span class="spaces">         </span><span class="istickedoff">goBinder x@(vnIndex -&gt; i) t body</span>
<span class="lineno"> 1836 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.member i rangeVars =</span>
<span class="lineno"> 1837 </span><span class="spaces">               </span><span class="istickedoff">-- Possibility of capture; rename bound variable.</span>
<span class="lineno"> 1838 </span><span class="spaces">               </span><span class="istickedoff">do x' &lt;- scmFreshVarName (vnName x)</span>
<span class="lineno"> 1839 </span><span class="spaces">                  </span><span class="istickedoff">var &lt;- scmVariable x' t</span>
<span class="lineno"> 1840 </span><span class="spaces">                  </span><span class="istickedoff">let vmap' = IntMap.insert i var vmap</span>
<span class="lineno"> 1841 </span><span class="spaces">                  </span><span class="istickedoff">body' &lt;- scmInstantiate vmap' body</span>
<span class="lineno"> 1842 </span><span class="spaces">                  </span><span class="istickedoff">pure (x', body')</span>
<span class="lineno"> 1843 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlyfalse">IntMap.member i vmap</span> =</span>
<span class="lineno"> 1844 </span><span class="spaces">               </span><span class="istickedoff">-- Shadowing; remove entry from substitution.</span>
<span class="lineno"> 1845 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">do let vmap' = IntMap.delete i vmap</span></span>
<span class="lineno"> 1846 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">body' &lt;- scmInstantiate vmap' body</span></span>
<span class="lineno"> 1847 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">pure (x, body')</span></span>
<span class="lineno"> 1848 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1849 </span><span class="spaces">               </span><span class="istickedoff">-- No possibility of shadowing or capture.</span>
<span class="lineno"> 1850 </span><span class="spaces">               </span><span class="istickedoff">do body' &lt;- memo body</span>
<span class="lineno"> 1851 </span><span class="spaces">                  </span><span class="istickedoff">pure (x, body')</span>
<span class="lineno"> 1852 </span><span class="spaces">     </span><span class="istickedoff">go t0</span></span>

</pre>
</body>
</html>
