<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Builtins
<span class="lineno">    3 </span>Description : Implementations of SAW-Script primitives.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : atomb
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE DeriveDataTypeable #-}
<span class="lineno">   10 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   11 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   12 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   13 </span>{-# LANGUAGE Rank2Types #-}
<span class="lineno">   14 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   15 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   16 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   17 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   18 </span>{-# LANGUAGE DoAndIfThenElse #-}
<span class="lineno">   19 </span>{-# LANGUAGE NondecreasingIndentation #-}
<span class="lineno">   20 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>module SAWCentral.Builtins where
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>import Control.Lens (view)
<span class="lineno">   25 </span>import Control.Monad (foldM, forM, unless)
<span class="lineno">   26 </span>import Control.Monad.Except (MonadError(..))
<span class="lineno">   27 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   28 </span>import Control.Monad.Reader (asks)
<span class="lineno">   29 </span>import Control.Monad.State (MonadState(..), gets, modify)
<span class="lineno">   30 </span>import qualified Control.Exception as Ex
<span class="lineno">   31 </span>import qualified Data.ByteString as StrictBS
<span class="lineno">   32 </span>import qualified Data.ByteString.Lazy as BS
<span class="lineno">   33 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   34 </span>import Data.IORef
<span class="lineno">   35 </span>import Data.List (isPrefixOf, isInfixOf, sort)
<span class="lineno">   36 </span>import qualified Data.Map as Map
<span class="lineno">   37 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   38 </span>import Data.Parameterized.Classes (KnownRepr(..))
<span class="lineno">   39 </span>import Data.Set (Set)
<span class="lineno">   40 </span>import qualified Data.Set as Set
<span class="lineno">   41 </span>import Data.Text (Text)
<span class="lineno">   42 </span>import qualified Data.Text as Text
<span class="lineno">   43 </span>import qualified Data.Text.Lazy as LText
<span class="lineno">   44 </span>import qualified Data.Text.Lazy.IO as TLIO
<span class="lineno">   45 </span>import Data.Time.Clock
<span class="lineno">   46 </span>import Data.Typeable
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>import System.Directory
<span class="lineno">   49 </span>import qualified System.Environment as Env
<span class="lineno">   50 </span>import qualified System.Exit as Exit
<span class="lineno">   51 </span>import qualified Data.Text.IO as TextIO
<span class="lineno">   52 </span>import System.IO
<span class="lineno">   53 </span>import System.IO.Temp (withSystemTempFile, emptySystemTempFile)
<span class="lineno">   54 </span>import System.FilePath (hasDrive, (&lt;/&gt;))
<span class="lineno">   55 </span>import System.Process (callCommand, readProcessWithExitCode)
<span class="lineno">   56 </span>import Text.Printf (printf)
<span class="lineno">   57 </span>import Text.Read (readMaybe)
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import qualified Cryptol.Utils.PP as CryptolPP
<span class="lineno">   60 </span>import qualified Cryptol.TypeCheck.AST as Cryptol
<span class="lineno">   61 </span>import qualified CryptolSAWCore.Cryptol as Cryptol
<span class="lineno">   62 </span>import qualified CryptolSAWCore.Simpset as Cryptol
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- saw-support
<span class="lineno">   65 </span>import qualified SAWSupport.Pretty as PPS (MemoStyle(..), Opts(..), pShow)
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>-- saw-core
<span class="lineno">   68 </span>import qualified SAWCore.Parser.AST as Un
<span class="lineno">   69 </span>import SAWCore.Parser.Grammar (parseSAW, parseSAWTerm)
<span class="lineno">   70 </span>import SAWCore.ExternalFormat
<span class="lineno">   71 </span>import SAWCore.FiniteValue
<span class="lineno">   72 </span>  ( FiniteType(..), readFiniteValue
<span class="lineno">   73 </span>  , FirstOrderValue(..)
<span class="lineno">   74 </span>  , scFirstOrderValue
<span class="lineno">   75 </span>  )
<span class="lineno">   76 </span>import SAWCore.Name (ecShortName)
<span class="lineno">   77 </span>import SAWCore.SATQuery
<span class="lineno">   78 </span>import SAWCore.SCTypeCheck
<span class="lineno">   79 </span>import SAWCore.Recognizer
<span class="lineno">   80 </span>import SAWCore.Prelude (scEq)
<span class="lineno">   81 </span>import SAWCore.SharedTerm
<span class="lineno">   82 </span>import SAWCore.Typechecker (tcInsertModule, inferCompleteTermCtx)
<span class="lineno">   83 </span>import SAWCore.Term.Functor
<span class="lineno">   84 </span>import SAWCore.Term.Pretty (ppTerm, scPrettyTerm)
<span class="lineno">   85 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>import qualified SAWCore.Simulator.Concrete as Concrete
<span class="lineno">   88 </span>import SAWCore.Prim (rethrowEvalError)
<span class="lineno">   89 </span>import SAWCore.Rewriter
<span class="lineno">   90 </span>import SAWCore.Testing.Random (prepareSATQuery, runManyTests)
<span class="lineno">   91 </span>import qualified SAWCore.Simulator.TermModel as TM
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-- cryptol-saw-core
<span class="lineno">   94 </span>import qualified CryptolSAWCore.CryptolEnv as CEnv
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- saw-core-sbv
<span class="lineno">   97 </span>import qualified SAWCoreSBV.SBV as SBVSim
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>-- saw-core-what4
<span class="lineno">  100 </span>import qualified SAWCoreWhat4.What4 as W4Sim
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>-- sbv
<span class="lineno">  103 </span>import qualified Data.SBV.Dynamic as SBV
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- aig
<span class="lineno">  106 </span>import qualified Data.AIG as AIG
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- cryptol
<span class="lineno">  109 </span>import qualified Cryptol.ModuleSystem.Env as C (meSearchPath)
<span class="lineno">  110 </span>import qualified Cryptol.TypeCheck as C (SolverConfig)
<span class="lineno">  111 </span>import qualified Cryptol.TypeCheck.AST as C
<span class="lineno">  112 </span>import qualified Cryptol.TypeCheck.PP as C (ppWithNames, pp, text, (&lt;+&gt;))
<span class="lineno">  113 </span>import qualified Cryptol.TypeCheck.Solve as C (defaultReplExpr)
<span class="lineno">  114 </span>import qualified Cryptol.TypeCheck.Solver.SMT as C (withSolver)
<span class="lineno">  115 </span>import qualified Cryptol.TypeCheck.Solver.InfNat as C (Nat'(..))
<span class="lineno">  116 </span>import qualified Cryptol.TypeCheck.Subst as C (Subst, apSubst, listSubst)
<span class="lineno">  117 </span>import qualified Cryptol.Backend.Monad as C (runEval)
<span class="lineno">  118 </span>import qualified Cryptol.Eval.Type as C (evalType)
<span class="lineno">  119 </span>import qualified Cryptol.Eval.Value as C (fromVBit, fromVWord)
<span class="lineno">  120 </span>import qualified Cryptol.Eval.Concrete as C (Concrete(..), bvVal)
<span class="lineno">  121 </span>import qualified Cryptol.Utils.Ident as C (packModName,
<span class="lineno">  122 </span>                                           textToModName, PrimIdent(..))
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- crucible
<span class="lineno">  125 </span>import Lang.Crucible.CFG.Common (freshGlobalVar)
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>import SAWCentral.ImportAIG
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>import SAWCentral.AST (getVal, Located(..))
<span class="lineno">  130 </span>import SAWCentral.Options as Opts
<span class="lineno">  131 </span>import SAWCentral.Panic (panic)
<span class="lineno">  132 </span>import SAWCentral.Proof
<span class="lineno">  133 </span>import SAWCentral.Crucible.Common (PathSatSolver(..))
<span class="lineno">  134 </span>import qualified SAWCentral.Crucible.Common as Common
<span class="lineno">  135 </span>import SAWCentral.TopLevel
<span class="lineno">  136 </span>import qualified SAWCentral.Value as SV
<span class="lineno">  137 </span>import SAWCentral.Value (ProofScript, printOutLnTop, AIGNetwork)
<span class="lineno">  138 </span>import SAWCentral.SolverCache
<span class="lineno">  139 </span>import SAWCentral.SolverVersions
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as MS
<span class="lineno">  142 </span>import SAWCentral.Crucible.Common.Setup.Type (addCondition, croTags)
<span class="lineno">  143 </span>import SAWCentral.Prover.Util(checkBooleanSchema)
<span class="lineno">  144 </span>import SAWCentral.Prover.SolverStats
<span class="lineno">  145 </span>import qualified SAWCentral.Prover.SBV as Prover
<span class="lineno">  146 </span>import qualified SAWCentral.Prover.RME as Prover
<span class="lineno">  147 </span>import qualified SAWCentral.Prover.ABC as Prover
<span class="lineno">  148 </span>import qualified SAWCentral.Prover.What4 as Prover
<span class="lineno">  149 </span>import qualified SAWCentral.Prover.Exporter as Prover
<span class="lineno">  150 </span>import SAWCentral.VerificationSummary
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>showPrim :: SV.Value -&gt; TopLevel Text
<span class="lineno">  153 </span><span class="decl"><span class="istickedoff">showPrim v = do</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno">  155 </span><span class="spaces">  </span><span class="istickedoff">nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span>
<span class="lineno">  156 </span><span class="spaces">  </span><span class="istickedoff">return $ Text.pack $ SV.showsPrecValue opts nenv <span class="nottickedoff">0</span> v &quot;&quot;</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>definePrim :: Text -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno">  159 </span><span class="decl"><span class="nottickedoff">definePrim name (TypedTerm (TypedTermSchema schema) rhs) =</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  161 </span><span class="spaces">     </span><span class="nottickedoff">ty &lt;- io $ Cryptol.importSchema sc Cryptol.emptyEnv schema</span>
<span class="lineno">  162 </span><span class="spaces">     </span><span class="nottickedoff">t &lt;- io $ scConstant sc name rhs ty</span>
<span class="lineno">  163 </span><span class="spaces">     </span><span class="nottickedoff">return $ TypedTerm (TypedTermSchema schema) t</span>
<span class="lineno">  164 </span><span class="spaces"></span><span class="nottickedoff">definePrim _name (TypedTerm tp _) =</span>
<span class="lineno">  165 </span><span class="spaces">  </span><span class="nottickedoff">fail $ unlines</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Expected term with Cryptol schema type, but got&quot;</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="nottickedoff">, show (ppTypedTermType tp)</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="nottickedoff">]</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>readBytes :: Text -&gt; TopLevel TypedTerm
<span class="lineno">  171 </span><span class="decl"><span class="istickedoff">readBytes pathtxt = do</span>
<span class="lineno">  172 </span><span class="spaces">  </span><span class="istickedoff">let path :: FilePath = Text.unpack pathtxt</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  174 </span><span class="spaces">  </span><span class="istickedoff">content &lt;- io $ BS.readFile path</span>
<span class="lineno">  175 </span><span class="spaces">  </span><span class="istickedoff">let len = BS.length content</span>
<span class="lineno">  176 </span><span class="spaces">  </span><span class="istickedoff">let bytes = BS.unpack content</span>
<span class="lineno">  177 </span><span class="spaces">  </span><span class="istickedoff">e &lt;- io $ scBitvector sc 8</span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="istickedoff">xs &lt;- io $ mapM (scBvConst sc 8 . toInteger) bytes</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">trm &lt;- io $ scVector sc e xs</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">let schema = C.Forall [] [] (C.tSeq (C.tNum len) (C.tSeq (C.tNum (8::Int)) C.tBit))</span>
<span class="lineno">  181 </span><span class="spaces">  </span><span class="istickedoff">return (TypedTerm (TypedTermSchema schema) trm)</span></span>
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>-- | Use ABC's 'dsec' command to equivalence check to terms
<span class="lineno">  186 </span>-- representing SAIGs. Note that nothing is returned; you must read
<span class="lineno">  187 </span>-- the output to see what happened.
<span class="lineno">  188 </span>--
<span class="lineno">  189 </span>-- TODO: this is a first version. The interface can be improved later,
<span class="lineno">  190 </span>-- but I don't want too worry to much about generalization before I
<span class="lineno">  191 </span>-- have more examples. It might be an improvement to take SAIGs as
<span class="lineno">  192 </span>-- arguments, in the style of 'cecPrim' below. This would require
<span class="lineno">  193 </span>-- support for latches in the 'AIGNetwork' SAWScript type.
<span class="lineno">  194 </span>dsecPrint :: TypedTerm -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno">  195 </span><span class="decl"><span class="nottickedoff">dsecPrint t1 t2 = do</span>
<span class="lineno">  196 </span><span class="spaces">  </span><span class="nottickedoff">write_t1 &lt;- Prover.writeSAIGInferLatches t1</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="nottickedoff">write_t2 &lt;- Prover.writeSAIGInferLatches t2</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="nottickedoff">io $ withSystemTempFile &quot;.aig&quot; $ \path1 _handle1 -&gt;</span>
<span class="lineno">  199 </span><span class="spaces">       </span><span class="nottickedoff">withSystemTempFile &quot;.aig&quot; $ \path2 _handle2 -&gt;</span>
<span class="lineno">  200 </span><span class="spaces">        </span><span class="nottickedoff">do write_t1 path1</span>
<span class="lineno">  201 </span><span class="spaces">           </span><span class="nottickedoff">write_t2 path2</span>
<span class="lineno">  202 </span><span class="spaces">           </span><span class="nottickedoff">callCommand (abcDsec path1 path2)</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="nottickedoff">-- The '-w' here may be overkill ...</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="nottickedoff">abcDsec path1 path2 = printf &quot;abc -c 'read %s; dsec -v -w %s;'&quot; path1 path2</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>cecPrim :: AIGNetwork -&gt; AIGNetwork -&gt; TopLevel ProofResult
<span class="lineno">  208 </span><span class="decl"><span class="nottickedoff">cecPrim (SV.AIGNetwork x) (SV.AIGNetwork y) = do</span>
<span class="lineno">  209 </span><span class="spaces">  </span><span class="nottickedoff">y' &lt;- case cast y of</span>
<span class="lineno">  210 </span><span class="spaces">          </span><span class="nottickedoff">Just n -&gt; return n</span>
<span class="lineno">  211 </span><span class="spaces">          </span><span class="nottickedoff">Nothing -&gt; fail &quot;Inconsistent AIG types&quot;</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="nottickedoff">io $ verifyAIGCompatible x y'</span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="nottickedoff">res &lt;- io $ AIG.cec x y'</span>
<span class="lineno">  214 </span><span class="spaces">  </span><span class="nottickedoff">let stats = solverStats &quot;ABC&quot; 0 -- TODO, count the size of the networks...</span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="nottickedoff">case res of</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="nottickedoff">AIG.Valid -&gt; return $ ValidProof stats (error &quot;cecPrim: deprecated function!&quot;)</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="nottickedoff">AIG.Invalid bs</span>
<span class="lineno">  218 </span><span class="spaces">      </span><span class="nottickedoff">| Just _fv &lt;- readFiniteValue (FTVec (fromIntegral (length bs)) FTBit) bs -&gt;</span>
<span class="lineno">  219 </span><span class="spaces">           </span><span class="nottickedoff">return $ InvalidProof stats [] (error &quot;cecPRim : deprecated function!&quot;)</span>
<span class="lineno">  220 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise -&gt; fail &quot;cec: impossible, could not parse counterexample&quot;</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="nottickedoff">AIG.VerifyUnknown -&gt; fail &quot;cec: unknown result &quot;</span></span>
<span class="lineno">  222 </span>
<span class="lineno">  223 </span>bbPrim :: TypedTerm -&gt; TopLevel AIGNetwork
<span class="lineno">  224 </span><span class="decl"><span class="nottickedoff">bbPrim t = do</span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="nottickedoff">SV.AIGProxy proxy &lt;- SV.getProxy</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- SV.getSharedContext</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="nottickedoff">aig &lt;- io $ Prover.bitblastPrim proxy sc (ttTerm t)</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="nottickedoff">return (SV.AIGNetwork aig)</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>loadAIGPrim :: Text -&gt; TopLevel AIGNetwork
<span class="lineno">  231 </span><span class="decl"><span class="nottickedoff">loadAIGPrim ftxt = do</span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="nottickedoff">let f = Text.unpack ftxt</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="nottickedoff">SV.AIGProxy proxy &lt;- SV.getProxy</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="nottickedoff">exists &lt;- io $ doesFileExist f</span>
<span class="lineno">  235 </span><span class="spaces">  </span><span class="nottickedoff">unless exists $ fail $ &quot;AIG file &quot; ++ f ++ &quot; not found.&quot;</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="nottickedoff">et &lt;- io $ loadAIG proxy f</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="nottickedoff">case et of</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="nottickedoff">Left err -&gt; fail $ &quot;Reading AIG failed: &quot; ++ err</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="nottickedoff">Right ntk -&gt; return (SV.AIGNetwork ntk)</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span>saveAIGPrim :: Text -&gt; AIGNetwork -&gt; TopLevel ()
<span class="lineno">  242 </span><span class="decl"><span class="nottickedoff">saveAIGPrim f (SV.AIGNetwork n) = io $ AIG.writeAiger (Text.unpack f) n</span></span>
<span class="lineno">  243 </span>
<span class="lineno">  244 </span>saveAIGasCNFPrim :: Text -&gt; AIGNetwork -&gt; TopLevel ()
<span class="lineno">  245 </span><span class="decl"><span class="nottickedoff">saveAIGasCNFPrim f (SV.AIGNetwork (AIG.Network be ls)) =</span>
<span class="lineno">  246 </span><span class="spaces">  </span><span class="nottickedoff">case ls of</span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="nottickedoff">[l] -&gt; do _ &lt;- io $ AIG.writeCNF be l (Text.unpack f)</span>
<span class="lineno">  248 </span><span class="spaces">              </span><span class="nottickedoff">return ()</span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail &quot;save_aig_as_cnf: non-boolean term&quot;</span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-- | Read an AIG file representing a theorem or an arbitrary function
<span class="lineno">  252 </span>-- and represent its contents as a @Term@ lambda term. This is
<span class="lineno">  253 </span>-- inefficient but semantically correct.
<span class="lineno">  254 </span>readAIGPrim :: Text -&gt; TopLevel TypedTerm
<span class="lineno">  255 </span><span class="decl"><span class="istickedoff">readAIGPrim ftxt = do</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="istickedoff">let f :: FilePath = Text.unpack ftxt</span>
<span class="lineno">  257 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  258 </span><span class="spaces">  </span><span class="istickedoff">SV.AIGProxy proxy &lt;- SV.getProxy</span>
<span class="lineno">  259 </span><span class="spaces">  </span><span class="istickedoff">exists &lt;- io $ doesFileExist f</span>
<span class="lineno">  260 </span><span class="spaces">  </span><span class="istickedoff">unless exists $ <span class="nottickedoff">fail $ &quot;AIG file &quot; ++ f ++ &quot; not found.&quot;</span></span>
<span class="lineno">  261 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno">  262 </span><span class="spaces">  </span><span class="istickedoff">et &lt;- io $ readAIG <span class="nottickedoff">proxy</span> opts sc f</span>
<span class="lineno">  263 </span><span class="spaces">  </span><span class="istickedoff">case et of</span>
<span class="lineno">  264 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">fail $ &quot;Reading AIG failed: &quot; ++ err</span></span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">Right (inLen, outLen, t) -&gt; pure $ TypedTerm (TypedTermSchema schema) t</span>
<span class="lineno">  266 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  267 </span><span class="spaces">        </span><span class="istickedoff">t1 = C.tWord (C.tNum inLen)</span>
<span class="lineno">  268 </span><span class="spaces">        </span><span class="istickedoff">t2 = C.tWord (C.tNum outLen)</span>
<span class="lineno">  269 </span><span class="spaces">        </span><span class="istickedoff">schema = C.tMono (C.tFun t1 t2)</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>replacePrim :: TypedTerm -&gt; TypedTerm -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno">  272 </span><span class="decl"><span class="nottickedoff">replacePrim pat replace t = do</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  274 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="nottickedoff">let tpat  = ttTerm pat</span>
<span class="lineno">  276 </span><span class="spaces">  </span><span class="nottickedoff">let trepl = ttTerm replace</span>
<span class="lineno">  277 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  278 </span><span class="spaces">  </span><span class="nottickedoff">unless (termIsClosed tpat) $ fail $ unlines</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;pattern term is not closed&quot;, show tpat ]</span>
<span class="lineno">  280 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  281 </span><span class="spaces">  </span><span class="nottickedoff">unless (termIsClosed trepl) $ fail $ unlines</span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;replacement term is not closed&quot;, show trepl ]</span>
<span class="lineno">  283 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="nottickedoff">io $ do</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="nottickedoff">ty1 &lt;- scTypeOf sc tpat</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="nottickedoff">ty2 &lt;- scTypeOf sc trepl</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="nottickedoff">c &lt;- scConvertible sc False ty1 ty2</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="nottickedoff">unless c $ fail $ unlines</span>
<span class="lineno">  289 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;terms do not have convertible types&quot;, show tpat, show ty1, show trepl, show ty2 ]</span>
<span class="lineno">  290 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  291 </span><span class="spaces">  </span><span class="nottickedoff">let ss = emptySimpset :: SV.SAWSimpset</span>
<span class="lineno">  292 </span><span class="spaces">  </span><span class="nottickedoff">(_,t') &lt;- io $ replaceTerm sc ss (tpat, trepl) (ttTerm t)</span>
<span class="lineno">  293 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="nottickedoff">io $ do</span>
<span class="lineno">  295 </span><span class="spaces">    </span><span class="nottickedoff">ty  &lt;- scTypeOf sc (ttTerm t)</span>
<span class="lineno">  296 </span><span class="spaces">    </span><span class="nottickedoff">ty' &lt;- scTypeOf sc t'</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="nottickedoff">c' &lt;- scConvertible sc False ty ty'</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="nottickedoff">unless c' $ fail $ unlines</span>
<span class="lineno">  299 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;term does not have the same type after replacement&quot;, show ty, show ty' ]</span>
<span class="lineno">  300 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="nottickedoff">return t{ ttTerm = t' }</span></span>
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>hoistIfsPrim :: TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno">  305 </span><span class="decl"><span class="nottickedoff">hoistIfsPrim t = do</span>
<span class="lineno">  306 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="nottickedoff">t' &lt;- io $ hoistIfs sc (ttTerm t)</span>
<span class="lineno">  308 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  309 </span><span class="spaces">  </span><span class="nottickedoff">io $ do</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="nottickedoff">ty  &lt;- scTypeOf sc (ttTerm t)</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="nottickedoff">ty' &lt;- scTypeOf sc t'</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="nottickedoff">c' &lt;- scConvertible sc False ty ty'</span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="nottickedoff">unless c' $ fail $ unlines</span>
<span class="lineno">  314 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;term does not have the same type after hoisting ifs&quot;, show ty, show ty' ]</span>
<span class="lineno">  315 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  316 </span><span class="spaces">  </span><span class="nottickedoff">return t{ ttTerm = t' }</span></span>
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>isConvertiblePrim :: TypedTerm -&gt; TypedTerm -&gt; TopLevel Bool
<span class="lineno">  319 </span><span class="decl"><span class="nottickedoff">isConvertiblePrim x y = do</span>
<span class="lineno">  320 </span><span class="spaces">   </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  321 </span><span class="spaces">   </span><span class="nottickedoff">io $ scConvertible sc False (ttTerm x) (ttTerm y)</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>checkConvertiblePrim :: TypedTerm -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno">  324 </span><span class="decl"><span class="nottickedoff">checkConvertiblePrim x y = do</span>
<span class="lineno">  325 </span><span class="spaces">   </span><span class="nottickedoff">c &lt;- isConvertiblePrim x y</span>
<span class="lineno">  326 </span><span class="spaces">   </span><span class="nottickedoff">printOutLnTop Info (if c</span>
<span class="lineno">  327 </span><span class="spaces">                        </span><span class="nottickedoff">then &quot;Convertible&quot;</span>
<span class="lineno">  328 </span><span class="spaces">                        </span><span class="nottickedoff">else &quot;Not convertible&quot;)</span></span>
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>readCore :: Text -&gt; TopLevel TypedTerm
<span class="lineno">  332 </span><span class="decl"><span class="istickedoff">readCore pathtxt = do</span>
<span class="lineno">  333 </span><span class="spaces">  </span><span class="istickedoff">let path :: FilePath = Text.unpack pathtxt</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="istickedoff">io (mkTypedTerm sc =&lt;&lt; scReadExternal sc =&lt;&lt; readFile path)</span></span>
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>execTactic :: Tactic TopLevel a -&gt; ProofScript a
<span class="lineno">  338 </span><span class="decl"><span class="istickedoff">execTactic tac =</span>
<span class="lineno">  339 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- get</span>
<span class="lineno">  340 </span><span class="spaces">     </span><span class="istickedoff">SV.scriptTopLevel (withFirstGoal tac st) &gt;&gt;= \case</span>
<span class="lineno">  341 </span><span class="spaces">       </span><span class="istickedoff">Left cex -&gt; throwError cex</span>
<span class="lineno">  342 </span><span class="spaces">       </span><span class="istickedoff">Right (x,st') -&gt;</span>
<span class="lineno">  343 </span><span class="spaces">         </span><span class="istickedoff">do put st'</span>
<span class="lineno">  344 </span><span class="spaces">            </span><span class="istickedoff">return <span class="nottickedoff">x</span></span></span>
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>quickcheckGoal :: SharedContext -&gt; Integer -&gt; ProofScript ()
<span class="lineno">  347 </span><span class="decl"><span class="istickedoff">quickcheckGoal sc n = do</span>
<span class="lineno">  348 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- SV.scriptTopLevel getOptions</span>
<span class="lineno">  349 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticSolve $ \goal -&gt; io $ do</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">printOutLn opts Warn $ &quot;WARNING: using quickcheck to prove goal...&quot;</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">hFlush stdout</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">satq &lt;- sequentToSATQuery sc mempty (goalSequent goal)</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">testGen &lt;- prepareSATQuery sc satq</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">stats = solverStats &quot;quickcheck&quot; (sequentSharedSize (goalSequent goal))</span></span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">runManyTests testGen n &gt;&gt;= \case</span>
<span class="lineno">  356 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  357 </span><span class="spaces">         </span><span class="istickedoff">do printOutLn opts Info $ &quot;checked &quot; ++ show n ++ &quot; cases.&quot;</span>
<span class="lineno">  358 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, SolveSuccess (QuickcheckEvidence n (goalSequent goal)))</span>
<span class="lineno">  359 </span><span class="spaces">       </span><span class="istickedoff">Just cex -&gt; <span class="nottickedoff">return (stats, SolveCounterexample cex)</span></span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>assumeValid :: ProofScript ()
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff">assumeValid =</span>
<span class="lineno">  363 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticSolve $ \goal -&gt;</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="istickedoff">do printOutLnTop Warn $ &quot;WARNING: assuming goal &quot; ++ goalName goal ++ &quot; is valid&quot;</span>
<span class="lineno">  365 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno">  366 </span><span class="spaces">     </span><span class="istickedoff">let admitMsg = &quot;assumeValid: &quot; &lt;&gt; Text.pack (goalName goal)</span>
<span class="lineno">  367 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">stats = solverStats &quot;ADMITTED&quot; (sequentSharedSize (goalSequent goal))</span></span>
<span class="lineno">  368 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, SolveSuccess (Admitted admitMsg pos (goalSequent goal)))</span></span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>assumeUnsat :: ProofScript ()
<span class="lineno">  371 </span><span class="decl"><span class="istickedoff">assumeUnsat =</span>
<span class="lineno">  372 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticSolve $ \goal -&gt;</span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="istickedoff">do printOutLnTop Warn $ &quot;WARNING: assuming goal &quot; ++ goalName goal ++ &quot; is unsat&quot;</span>
<span class="lineno">  374 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno">  375 </span><span class="spaces">     </span><span class="istickedoff">let admitMsg = &quot;assumeUnsat: &quot; &lt;&gt; Text.pack (goalName goal)</span>
<span class="lineno">  376 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">stats = solverStats &quot;ADMITTED&quot; (sequentSharedSize (goalSequent goal))</span></span>
<span class="lineno">  377 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, SolveSuccess (Admitted admitMsg pos (goalSequent goal)))</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>admitProof :: Text -&gt; ProofScript ()
<span class="lineno">  380 </span><span class="decl"><span class="istickedoff">admitProof msg =</span>
<span class="lineno">  381 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticSolve $ \goal -&gt;</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="istickedoff">do printOutLnTop Warn $ &quot;WARNING: admitting goal &quot; ++ goalName goal</span>
<span class="lineno">  383 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno">  384 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">stats = solverStats &quot;ADMITTED&quot; (sequentSharedSize (goalSequent goal))</span></span>
<span class="lineno">  385 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, SolveSuccess (Admitted msg pos (goalSequent goal)))</span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>trivial :: ProofScript ()
<span class="lineno">  388 </span><span class="decl"><span class="istickedoff">trivial =</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  390 </span><span class="spaces">     </span><span class="istickedoff">execTactic (tacticTrivial sc)</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>split_goal :: ProofScript ()
<span class="lineno">  393 </span><span class="decl"><span class="nottickedoff">split_goal =</span>
<span class="lineno">  394 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  395 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticSplit sc)</span></span>
<span class="lineno">  396 </span>
<span class="lineno">  397 </span>getTopLevelPPOpts :: TopLevel PPS.Opts
<span class="lineno">  398 </span><span class="decl"><span class="istickedoff">getTopLevelPPOpts =</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="istickedoff">rwPPOpts &lt;$&gt; getTopLevelRW</span></span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>show_term :: Term -&gt; TopLevel Text
<span class="lineno">  402 </span><span class="decl"><span class="istickedoff">show_term t =</span>
<span class="lineno">  403 </span><span class="spaces">  </span><span class="istickedoff">do opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  404 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  405 </span><span class="spaces">     </span><span class="istickedoff">str &lt;- liftIO $ scShowTerm sc opts t</span>
<span class="lineno">  406 </span><span class="spaces">     </span><span class="istickedoff">return $ Text.pack str</span></span>
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>print_term :: Term -&gt; TopLevel ()
<span class="lineno">  409 </span><span class="decl"><span class="istickedoff">print_term t = do</span>
<span class="lineno">  410 </span><span class="spaces">  </span><span class="istickedoff">txt &lt;- show_term t</span>
<span class="lineno">  411 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info $ Text.unpack txt</span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>print_term_depth :: Int -&gt; Term -&gt; TopLevel ()
<span class="lineno">  414 </span><span class="decl"><span class="nottickedoff">print_term_depth d t =</span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="nottickedoff">do opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  416 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  417 </span><span class="spaces">     </span><span class="nottickedoff">let opts' = opts { PPS.ppMaxDepth = Just d }</span>
<span class="lineno">  418 </span><span class="spaces">     </span><span class="nottickedoff">output &lt;- liftIO $ scShowTerm sc opts' t</span>
<span class="lineno">  419 </span><span class="spaces">     </span><span class="nottickedoff">printOutLnTop Info output</span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>goalSummary :: ProofGoal -&gt; String
<span class="lineno">  422 </span><span class="decl"><span class="istickedoff">goalSummary goal = unlines $ concat</span>
<span class="lineno">  423 </span><span class="spaces">  </span><span class="istickedoff">[ [ &quot;Goal &quot; ++ goalName goal ++ &quot; (goal number &quot; ++ (show $ goalNum goal) ++ &quot;): &quot; ++ goalType goal</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">, &quot;at &quot; ++ goalLoc goal</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">]</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="istickedoff">, if Set.null (goalTags goal) then [] else</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="istickedoff">[ unwords (&quot;Tags:&quot; : map show (Set.toList (goalTags goal)))</span>
<span class="lineno">  428 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">, if null (goalDesc goal) then [] else [ goalDesc goal ]</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>write_goal :: FilePath -&gt; ProofScript ()
<span class="lineno">  433 </span><span class="decl"><span class="nottickedoff">write_goal fp =</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="nottickedoff">do opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  436 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  437 </span><span class="spaces">     </span><span class="nottickedoff">liftIO $ do</span>
<span class="lineno">  438 </span><span class="spaces">       </span><span class="nottickedoff">nenv &lt;- scGetNamingEnv sc</span>
<span class="lineno">  439 </span><span class="spaces">       </span><span class="nottickedoff">let output = prettySequent opts nenv (goalSequent goal)</span>
<span class="lineno">  440 </span><span class="spaces">       </span><span class="nottickedoff">writeFile fp (unlines [goalSummary goal, output])</span></span>
<span class="lineno">  441 </span>
<span class="lineno">  442 </span>print_goal :: ProofScript ()
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">print_goal =</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  445 </span><span class="spaces">  </span><span class="istickedoff">do opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  446 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  447 </span><span class="spaces">     </span><span class="istickedoff">nenv &lt;- io (scGetNamingEnv sc)</span>
<span class="lineno">  448 </span><span class="spaces">     </span><span class="istickedoff">let output = prettySequent opts nenv (goalSequent goal)</span>
<span class="lineno">  449 </span><span class="spaces">     </span><span class="istickedoff">printOutLnTop Info (unlines [goalSummary goal, output])</span></span>
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>-- | Print the current goal that a proof script is attempting to prove, without
<span class="lineno">  452 </span>-- generating @let@ bindings for the provided indices. For example,
<span class="lineno">  453 </span>-- @print_goal_inline [1,9,3]@ will print the goal without inlining the
<span class="lineno">  454 </span>-- variables that would otherwise be abstracted as @x\@1@, @x\@9@, and @x\@3@.
<span class="lineno">  455 </span>print_goal_inline :: [Int] -&gt; ProofScript ()
<span class="lineno">  456 </span><span class="decl"><span class="nottickedoff">print_goal_inline noInline =</span>
<span class="lineno">  457 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="nottickedoff">do</span>
<span class="lineno">  459 </span><span class="spaces">      </span><span class="nottickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  460 </span><span class="spaces">      </span><span class="nottickedoff">opts' &lt;-</span>
<span class="lineno">  461 </span><span class="spaces">        </span><span class="nottickedoff">case PPS.ppMemoStyle opts of</span>
<span class="lineno">  462 </span><span class="spaces">          </span><span class="nottickedoff">PPS.Incremental -&gt; pure opts { PPS.ppNoInlineMemoFresh = sort noInline }</span>
<span class="lineno">  463 </span><span class="spaces">          </span><span class="nottickedoff">PPS.HashIncremental _ -&gt; pure opts { PPS.ppNoInlineMemoFresh = sort noInline }</span>
<span class="lineno">  464 </span><span class="spaces">          </span><span class="nottickedoff">PPS.Hash _ -&gt; warnIncremental &gt;&gt; pure opts</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="nottickedoff">nenv &lt;- io (scGetNamingEnv sc)</span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="nottickedoff">let output = prettySequent opts' nenv (goalSequent goal)</span>
<span class="lineno">  468 </span><span class="spaces">      </span><span class="nottickedoff">printOutLnTop Info (unlines [goalSummary goal, output])</span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="nottickedoff">warnIncremental =</span>
<span class="lineno">  471 </span><span class="spaces">      </span><span class="nottickedoff">printOutLnTop Warn $</span>
<span class="lineno">  472 </span><span class="spaces">        </span><span class="nottickedoff">unlines</span>
<span class="lineno">  473 </span><span class="spaces">          </span><span class="nottickedoff">[ &quot;`print_goal_inline` is incompatible with non-incremental&quot;</span>
<span class="lineno">  474 </span><span class="spaces">          </span><span class="nottickedoff">, &quot;memoization strategies. Printing goal without inlining...&quot;</span>
<span class="lineno">  475 </span><span class="spaces">          </span><span class="nottickedoff">]</span></span>
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>print_goal_summary :: ProofScript ()
<span class="lineno">  478 </span><span class="decl"><span class="istickedoff">print_goal_summary =</span>
<span class="lineno">  479 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">printOutLnTop Info (goalSummary goal)</span></span>
<span class="lineno">  481 </span>
<span class="lineno">  482 </span>print_focus :: ProofScript ()
<span class="lineno">  483 </span><span class="decl"><span class="nottickedoff">print_focus =</span>
<span class="lineno">  484 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="nottickedoff">do opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  486 </span><span class="spaces">       </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  487 </span><span class="spaces">       </span><span class="nottickedoff">nenv &lt;- io (scGetNamingEnv sc)</span>
<span class="lineno">  488 </span><span class="spaces">       </span><span class="nottickedoff">case sequentGetFocus (goalSequent goal) of</span>
<span class="lineno">  489 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  490 </span><span class="spaces">           </span><span class="nottickedoff">printOutLnTop Warn &quot;Sequent is not focused&quot;</span>
<span class="lineno">  491 </span><span class="spaces">         </span><span class="nottickedoff">Just (Left (i,h)) -&gt;</span>
<span class="lineno">  492 </span><span class="spaces">           </span><span class="nottickedoff">let output = ppProp opts nenv h in</span>
<span class="lineno">  493 </span><span class="spaces">           </span><span class="nottickedoff">printOutLnTop Info (unlines [&quot;Hypothesis &quot; ++ show i, show output])</span>
<span class="lineno">  494 </span><span class="spaces">         </span><span class="nottickedoff">Just (Right (i,c)) -&gt;</span>
<span class="lineno">  495 </span><span class="spaces">           </span><span class="nottickedoff">let output = ppProp opts nenv c in</span>
<span class="lineno">  496 </span><span class="spaces">           </span><span class="nottickedoff">printOutLnTop Info (unlines [&quot;Conclusion &quot; ++ show i, show output])</span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>goal_num :: ProofScript Int
<span class="lineno">  500 </span><span class="decl"><span class="nottickedoff">goal_num =</span>
<span class="lineno">  501 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="nottickedoff">return (goalNum goal)</span></span>
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>print_goal_depth :: Int -&gt; ProofScript ()
<span class="lineno">  505 </span><span class="decl"><span class="nottickedoff">print_goal_depth n =</span>
<span class="lineno">  506 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  507 </span><span class="spaces">  </span><span class="nottickedoff">do opts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  508 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  509 </span><span class="spaces">     </span><span class="nottickedoff">let opts' = opts { PPS.ppMaxDepth = Just n }</span>
<span class="lineno">  510 </span><span class="spaces">     </span><span class="nottickedoff">nenv &lt;- io (scGetNamingEnv sc)</span>
<span class="lineno">  511 </span><span class="spaces">     </span><span class="nottickedoff">let output = prettySequent opts' nenv (goalSequent goal)</span>
<span class="lineno">  512 </span><span class="spaces">     </span><span class="nottickedoff">printOutLnTop Info (unlines [goalSummary goal, output])</span></span>
<span class="lineno">  513 </span>
<span class="lineno">  514 </span>printGoalConsts :: ProofScript ()
<span class="lineno">  515 </span><span class="decl"><span class="nottickedoff">printGoalConsts =</span>
<span class="lineno">  516 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="nottickedoff">do let cs = sequentConstantSet (goalSequent goal)</span>
<span class="lineno">  518 </span><span class="spaces">     </span><span class="nottickedoff">mapM_ (printOutLnTop Info) $</span>
<span class="lineno">  519 </span><span class="spaces">       </span><span class="nottickedoff">[ show nm | (_, nm) &lt;- Map.toList cs ]</span></span>
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>printGoalSize :: ProofScript ()
<span class="lineno">  522 </span><span class="decl"><span class="nottickedoff">printGoalSize =</span>
<span class="lineno">  523 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticId $ \goal -&gt;</span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="nottickedoff">do printOutLnTop Info $ &quot;Goal shared size: &quot; ++ show (sequentSharedSize (goalSequent goal))</span>
<span class="lineno">  525 </span><span class="spaces">     </span><span class="nottickedoff">printOutLnTop Info $ &quot;Goal unshared size: &quot; ++ show (sequentTreeSize (goalSequent goal))</span></span>
<span class="lineno">  526 </span>
<span class="lineno">  527 </span>resolveNames :: [Text] -&gt; TopLevel (Set VarIndex)
<span class="lineno">  528 </span><span class="decl"><span class="istickedoff">resolveNames nms =</span>
<span class="lineno">  529 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  530 </span><span class="spaces">     </span><span class="istickedoff">Set.fromList . mconcat &lt;$&gt; mapM (resolveName sc) nms</span></span>
<span class="lineno">  531 </span>
<span class="lineno">  532 </span>-- | Given a user-provided name, resolve it to (potentially several)
<span class="lineno">  533 </span>-- 'ExtCns' that each represent an unfoldable 'Constant' value or a
<span class="lineno">  534 </span>-- fresh uninterpreted constant.
<span class="lineno">  535 </span>-- The given name is searched for in both the local Cryptol environment
<span class="lineno">  536 </span>-- and the SAWCore naming environment.
<span class="lineno">  537 </span>-- Pulling this out of `TopLevel` is useful so we can use it in other
<span class="lineno">  538 </span>-- contexts (e.g., `crucible-mir-comp`)
<span class="lineno">  539 </span>resolveNameIO :: SharedContext -&gt; CEnv.CryptolEnv -&gt; Text -&gt; IO [VarIndex]
<span class="lineno">  540 </span><span class="decl"><span class="istickedoff">resolveNameIO sc cenv nm =</span>
<span class="lineno">  541 </span><span class="spaces">  </span><span class="istickedoff">do scnms &lt;- scResolveName sc nm</span>
<span class="lineno">  542 </span><span class="spaces">     </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">StrictBS.readFile</span></span>
<span class="lineno">  543 </span><span class="spaces">     </span><span class="istickedoff">res &lt;- CEnv.resolveIdentifier cenv nm</span>
<span class="lineno">  544 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno">  545 </span><span class="spaces">       </span><span class="istickedoff">Just cnm -&gt;</span>
<span class="lineno">  546 </span><span class="spaces">         </span><span class="istickedoff">do importedName &lt;- Cryptol.importName cnm</span>
<span class="lineno">  547 </span><span class="spaces">            </span><span class="istickedoff">case importedName of</span>
<span class="lineno">  548 </span><span class="spaces">              </span><span class="istickedoff">ImportedName uri _ -&gt;</span>
<span class="lineno">  549 </span><span class="spaces">                </span><span class="istickedoff">do resolvedName &lt;- scResolveNameByURI sc uri</span>
<span class="lineno">  550 </span><span class="spaces">                   </span><span class="istickedoff">case resolvedName of</span>
<span class="lineno">  551 </span><span class="spaces">                     </span><span class="istickedoff">Just vi -&gt; pure (vi : scnms)</span>
<span class="lineno">  552 </span><span class="spaces">                     </span><span class="istickedoff">Nothing -&gt; pure scnms</span>
<span class="lineno">  553 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">pure scnms</span></span>
<span class="lineno">  554 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure scnms</span></span>
<span class="lineno">  555 </span>
<span class="lineno">  556 </span>-- | Given a user-provided name, resolve it to (potentially several)
<span class="lineno">  557 </span>-- 'ExtCns' that each represent an unfoldable 'Constant' value or a
<span class="lineno">  558 </span>-- fresh uninterpreted constant.
<span class="lineno">  559 </span>-- The given name is searched for in both the local Cryptol environment
<span class="lineno">  560 </span>-- and the SAWCore naming environment. If it is found in neither, an
<span class="lineno">  561 </span>-- exception is thrown.
<span class="lineno">  562 </span>resolveName :: SharedContext -&gt; Text -&gt; TopLevel [VarIndex]
<span class="lineno">  563 </span><span class="decl"><span class="istickedoff">resolveName sc nm =</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="istickedoff">do cenv &lt;- rwCryptol &lt;$&gt; getTopLevelRW</span>
<span class="lineno">  565 </span><span class="spaces">     </span><span class="istickedoff">scnms &lt;- io (resolveNameIO sc cenv nm)</span>
<span class="lineno">  566 </span><span class="spaces">     </span><span class="istickedoff">case scnms of</span>
<span class="lineno">  567 </span><span class="spaces">       </span><span class="istickedoff">[] -&gt; fail $ Text.unpack $ &quot;Could not resolve name: &quot; &lt;&gt; nm</span>
<span class="lineno">  568 </span><span class="spaces">       </span><span class="istickedoff">_  -&gt; pure scnms</span></span>
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>normalize_term :: TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno">  571 </span><span class="decl"><span class="istickedoff">normalize_term tt = normalize_term_opaque [] tt</span></span>
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>normalize_term_opaque :: [Text] -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno">  574 </span><span class="decl"><span class="istickedoff">normalize_term_opaque opaque tt =</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  576 </span><span class="spaces">     </span><span class="istickedoff">modmap &lt;- io (scGetModuleMap sc)</span>
<span class="lineno">  577 </span><span class="spaces">     </span><span class="istickedoff">idxs &lt;- mconcat &lt;$&gt; mapM <span class="nottickedoff">(resolveName sc)</span> opaque</span>
<span class="lineno">  578 </span><span class="spaces">     </span><span class="istickedoff">let opaqueSet = Set.fromList idxs</span>
<span class="lineno">  579 </span><span class="spaces">     </span><span class="istickedoff">tm' &lt;- io (TM.normalizeSharedTerm sc modmap mempty mempty opaqueSet (ttTerm tt))</span>
<span class="lineno">  580 </span><span class="spaces">     </span><span class="istickedoff">pure tt{ ttTerm = tm' }</span></span>
<span class="lineno">  581 </span>
<span class="lineno">  582 </span>goal_normalize :: [Text] -&gt; ProofScript ()
<span class="lineno">  583 </span><span class="decl"><span class="istickedoff">goal_normalize opaque =</span>
<span class="lineno">  584 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  585 </span><span class="spaces">    </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  586 </span><span class="spaces">       </span><span class="istickedoff">idxs &lt;- mconcat &lt;$&gt; mapM (resolveName sc) opaque</span>
<span class="lineno">  587 </span><span class="spaces">       </span><span class="istickedoff">modmap &lt;- io (scGetModuleMap sc)</span>
<span class="lineno">  588 </span><span class="spaces">       </span><span class="istickedoff">let opaqueSet = Set.fromList idxs</span>
<span class="lineno">  589 </span><span class="spaces">       </span><span class="istickedoff">sqt' &lt;- io $ traverseSequentWithFocus (normalizeProp sc modmap opaqueSet) (goalSequent goal)</span>
<span class="lineno">  590 </span><span class="spaces">       </span><span class="istickedoff">return (sqt', NormalizePropEvidence opaqueSet)</span></span>
<span class="lineno">  591 </span>
<span class="lineno">  592 </span>unfocus :: ProofScript ()
<span class="lineno">  593 </span><span class="decl"><span class="nottickedoff">unfocus =</span>
<span class="lineno">  594 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  595 </span><span class="spaces">    </span><span class="nottickedoff">do let sqt' = unfocusSequent (goalSequent goal)</span>
<span class="lineno">  596 </span><span class="spaces">       </span><span class="nottickedoff">return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>focus_concl :: Integer -&gt; ProofScript ()
<span class="lineno">  599 </span><span class="decl"><span class="nottickedoff">focus_concl i =</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="nottickedoff">case focusOnConcl i (goalSequent goal) of</span>
<span class="lineno">  602 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; fail &quot;focus_concl : not enough conclusions&quot;</span>
<span class="lineno">  603 </span><span class="spaces">      </span><span class="nottickedoff">Just sqt' -&gt; return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  604 </span>
<span class="lineno">  605 </span>focus_hyp :: Integer -&gt; ProofScript ()
<span class="lineno">  606 </span><span class="decl"><span class="nottickedoff">focus_hyp i =</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  608 </span><span class="spaces">    </span><span class="nottickedoff">case focusOnHyp i (goalSequent goal) of</span>
<span class="lineno">  609 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; fail &quot;focus_hyp : not enough hypotheses&quot;</span>
<span class="lineno">  610 </span><span class="spaces">      </span><span class="nottickedoff">Just sqt' -&gt; return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  611 </span>
<span class="lineno">  612 </span>delete_hyps :: [Integer] -&gt; ProofScript ()
<span class="lineno">  613 </span><span class="decl"><span class="nottickedoff">delete_hyps hs =</span>
<span class="lineno">  614 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="nottickedoff">let sqt' = filterHyps (BlackList (Set.fromList hs)) (goalSequent goal)</span>
<span class="lineno">  616 </span><span class="spaces">     </span><span class="nottickedoff">in return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>retain_hyps :: [Integer] -&gt; ProofScript ()
<span class="lineno">  619 </span><span class="decl"><span class="nottickedoff">retain_hyps hs =</span>
<span class="lineno">  620 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  621 </span><span class="spaces">    </span><span class="nottickedoff">let sqt' = filterHyps (WhiteList (Set.fromList hs)) (goalSequent goal)</span>
<span class="lineno">  622 </span><span class="spaces">     </span><span class="nottickedoff">in return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  623 </span>
<span class="lineno">  624 </span>delete_concl :: [Integer] -&gt; ProofScript ()
<span class="lineno">  625 </span><span class="decl"><span class="nottickedoff">delete_concl gs =</span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="nottickedoff">let sqt' = filterConcls (BlackList (Set.fromList gs)) (goalSequent goal)</span>
<span class="lineno">  628 </span><span class="spaces">     </span><span class="nottickedoff">in return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>retain_concl :: [Integer] -&gt; ProofScript ()
<span class="lineno">  631 </span><span class="decl"><span class="nottickedoff">retain_concl gs =</span>
<span class="lineno">  632 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="nottickedoff">let sqt' = filterConcls (WhiteList (Set.fromList gs)) (goalSequent goal)</span>
<span class="lineno">  634 </span><span class="spaces">     </span><span class="nottickedoff">in return (sqt', structuralEvidence sqt')</span></span>
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>goal_cut :: Term -&gt; ProofScript ()
<span class="lineno">  638 </span><span class="decl"><span class="nottickedoff">goal_cut tm =</span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="nottickedoff">do -- TODO? Theres a bit of duplicated work here</span>
<span class="lineno">  640 </span><span class="spaces">     </span><span class="nottickedoff">-- and in boolToProp, termToProp.</span>
<span class="lineno">  641 </span><span class="spaces">     </span><span class="nottickedoff">-- maybe we can consolatate</span>
<span class="lineno">  642 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  643 </span><span class="spaces">     </span><span class="nottickedoff">p  &lt;- SV.scriptTopLevel $ io $</span>
<span class="lineno">  644 </span><span class="spaces">            </span><span class="nottickedoff">do tp &lt;- scWhnf sc =&lt;&lt; scTypeOf sc tm</span>
<span class="lineno">  645 </span><span class="spaces">               </span><span class="nottickedoff">case () of</span>
<span class="lineno">  646 </span><span class="spaces">                 </span><span class="nottickedoff">_ | Just () &lt;- asBoolType tp</span>
<span class="lineno">  647 </span><span class="spaces">                   </span><span class="nottickedoff">-&gt; boolToProp sc [] tm</span>
<span class="lineno">  648 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  649 </span><span class="spaces">                   </span><span class="nottickedoff">| Just s &lt;- asSort tp, s == propSort</span>
<span class="lineno">  650 </span><span class="spaces">                   </span><span class="nottickedoff">-&gt; termToProp sc tm</span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  652 </span><span class="spaces">                   </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  653 </span><span class="spaces">                   </span><span class="nottickedoff">-&gt; fail &quot;goal_cut: expected Bool or Prop term&quot;</span>
<span class="lineno">  654 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticCut sc p)</span></span>
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>normalize_sequent :: ProofScript ()
<span class="lineno">  657 </span><span class="decl"><span class="nottickedoff">normalize_sequent =</span>
<span class="lineno">  658 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  659 </span><span class="spaces">    </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  660 </span><span class="spaces">       </span><span class="nottickedoff">sqt' &lt;- io $ normalizeSequent sc (goalSequent goal)</span>
<span class="lineno">  661 </span><span class="spaces">       </span><span class="nottickedoff">return (sqt', NormalizeSequentEvidence sqt')</span></span>
<span class="lineno">  662 </span>
<span class="lineno">  663 </span>unfoldGoal :: [Text] -&gt; ProofScript ()
<span class="lineno">  664 </span><span class="decl"><span class="istickedoff">unfoldGoal unints =</span>
<span class="lineno">  665 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  667 </span><span class="spaces">     </span><span class="istickedoff">unints' &lt;- resolveNames unints</span>
<span class="lineno">  668 </span><span class="spaces">     </span><span class="istickedoff">sqt' &lt;- traverseSequentWithFocus (io . unfoldProp sc unints') (goalSequent goal)</span>
<span class="lineno">  669 </span><span class="spaces">     </span><span class="istickedoff">return (sqt', UnfoldEvidence unints')</span></span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>unfoldFixOnceGoal :: [Text] -&gt; ProofScript ()
<span class="lineno">  672 </span><span class="decl"><span class="istickedoff">unfoldFixOnceGoal unints =</span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  674 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  675 </span><span class="spaces">     </span><span class="istickedoff">unints' &lt;- resolveNames unints</span>
<span class="lineno">  676 </span><span class="spaces">     </span><span class="istickedoff">sqt' &lt;- traverseSequentWithFocus (io . unfoldFixOnceProp sc unints') (goalSequent goal)</span>
<span class="lineno">  677 </span><span class="spaces">     </span><span class="istickedoff">return (sqt', UnfoldFixOnceEvidence unints')</span></span>
<span class="lineno">  678 </span>
<span class="lineno">  679 </span>simplifyGoal :: SV.SAWSimpset -&gt; ProofScript ()
<span class="lineno">  680 </span><span class="decl"><span class="istickedoff">simplifyGoal ss =</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  683 </span><span class="spaces">     </span><span class="istickedoff">sqt' &lt;- traverseSequentWithFocus (\p -&gt; snd &lt;$&gt; io (simplifyProp sc ss p)) (goalSequent goal)</span>
<span class="lineno">  684 </span><span class="spaces">     </span><span class="istickedoff">return (sqt', RewriteEvidence [] ss)</span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>simplifyGoalWithLocals :: [Integer] -&gt; SV.SAWSimpset -&gt; ProofScript ()
<span class="lineno">  687 </span><span class="decl"><span class="nottickedoff">simplifyGoalWithLocals hs ss =</span>
<span class="lineno">  688 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  689 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  690 </span><span class="spaces">     </span><span class="nottickedoff">ss' &lt;- io (localHypSimpset sc (goalSequent goal) hs ss)</span>
<span class="lineno">  691 </span><span class="spaces">     </span><span class="nottickedoff">sqt' &lt;- traverseSequentWithFocus</span>
<span class="lineno">  692 </span><span class="spaces">               </span><span class="nottickedoff">(\p -&gt; snd &lt;$&gt; io (simplifyProp sc ss' p)) (goalSequent goal)</span>
<span class="lineno">  693 </span><span class="spaces">     </span><span class="nottickedoff">return (sqt', RewriteEvidence hs ss)</span></span>
<span class="lineno">  694 </span>
<span class="lineno">  695 </span>hoistIfsInGoalPrim :: ProofScript ()
<span class="lineno">  696 </span><span class="decl"><span class="istickedoff">hoistIfsInGoalPrim =</span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  699 </span><span class="spaces">       </span><span class="istickedoff">sqt' &lt;- traverseSequentWithFocus (io . hoistIfsInProp sc) (goalSequent goal)</span>
<span class="lineno">  700 </span><span class="spaces">       </span><span class="istickedoff">return (sqt', HoistIfsEvidence)</span></span>
<span class="lineno">  701 </span>
<span class="lineno">  702 </span>term_type :: TypedTerm -&gt; TopLevel C.Schema
<span class="lineno">  703 </span><span class="decl"><span class="nottickedoff">term_type tt =</span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="nottickedoff">case ttType tt of</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="nottickedoff">TypedTermSchema sch -&gt; pure sch</span>
<span class="lineno">  706 </span><span class="spaces">    </span><span class="nottickedoff">tp -&gt; fail $ unlines</span>
<span class="lineno">  707 </span><span class="spaces">            </span><span class="nottickedoff">[ &quot;Term does not have a Cryptol type&quot;</span>
<span class="lineno">  708 </span><span class="spaces">            </span><span class="nottickedoff">, show (ppTypedTermType tp)</span>
<span class="lineno">  709 </span><span class="spaces">            </span><span class="nottickedoff">]</span></span>
<span class="lineno">  710 </span>
<span class="lineno">  711 </span>goal_eval :: [Text] -&gt; ProofScript ()
<span class="lineno">  712 </span><span class="decl"><span class="istickedoff">goal_eval unints =</span>
<span class="lineno">  713 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  715 </span><span class="spaces">     </span><span class="istickedoff">unintSet &lt;- resolveNames unints</span>
<span class="lineno">  716 </span><span class="spaces">     </span><span class="istickedoff">what4PushMuxOps &lt;- gets rwWhat4PushMuxOps</span>
<span class="lineno">  717 </span><span class="spaces">     </span><span class="istickedoff">sqt' &lt;- traverseSequentWithFocus (io . evalProp sc what4PushMuxOps unintSet) (goalSequent goal)</span>
<span class="lineno">  718 </span><span class="spaces">     </span><span class="istickedoff">return (sqt', EvalEvidence unintSet)</span></span>
<span class="lineno">  719 </span>
<span class="lineno">  720 </span>extract_uninterp ::
<span class="lineno">  721 </span>  [Text] {- ^ uninterpred identifiers -} -&gt;
<span class="lineno">  722 </span>  [Text] {- ^ opaque identifiers -} -&gt;
<span class="lineno">  723 </span>  TypedTerm -&gt;
<span class="lineno">  724 </span>  TopLevel (TypedTerm, [(Text, [(TypedTerm,TypedTerm)])])
<span class="lineno">  725 </span><span class="decl"><span class="nottickedoff">extract_uninterp unints opaques tt =</span>
<span class="lineno">  726 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  727 </span><span class="spaces">     </span><span class="nottickedoff">idxs &lt;- mconcat &lt;$&gt; mapM (resolveName sc) unints</span>
<span class="lineno">  728 </span><span class="spaces">     </span><span class="nottickedoff">let unintSet = Set.fromList idxs</span>
<span class="lineno">  729 </span><span class="spaces">     </span><span class="nottickedoff">mmap &lt;- io (scGetModuleMap sc)</span>
<span class="lineno">  730 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  731 </span><span class="spaces">     </span><span class="nottickedoff">opaqueSet &lt;- Set.fromList . mconcat &lt;$&gt; mapM (resolveName sc) opaques</span>
<span class="lineno">  732 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  733 </span><span class="spaces">     </span><span class="nottickedoff">boundECRef &lt;- io (newIORef Set.empty)</span>
<span class="lineno">  734 </span><span class="spaces">     </span><span class="nottickedoff">let ?recordEC = \ec -&gt; modifyIORef boundECRef (Set.insert ec)</span>
<span class="lineno">  735 </span><span class="spaces">     </span><span class="nottickedoff">(tm, repls) &lt;- io (TM.extractUninterp sc mmap mempty mempty unintSet opaqueSet (ttTerm tt))</span>
<span class="lineno">  736 </span><span class="spaces">     </span><span class="nottickedoff">boundECSet &lt;- io (readIORef boundECRef)</span>
<span class="lineno">  737 </span><span class="spaces">     </span><span class="nottickedoff">let tt' = tt{ ttTerm = tm }</span>
<span class="lineno">  738 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  739 </span><span class="spaces">     </span><span class="nottickedoff">let f = traverse $ \(ec,vs) -&gt;</span>
<span class="lineno">  740 </span><span class="spaces">               </span><span class="nottickedoff">do ectm &lt;- scVariable sc ec</span>
<span class="lineno">  741 </span><span class="spaces">                  </span><span class="nottickedoff">vs'  &lt;- filterCryTerms sc vs</span>
<span class="lineno">  742 </span><span class="spaces">                  </span><span class="nottickedoff">pure (ectm, vs')</span>
<span class="lineno">  743 </span><span class="spaces">     </span><span class="nottickedoff">repls' &lt;- io (traverse f repls)</span>
<span class="lineno">  744 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  745 </span><span class="spaces">     </span><span class="nottickedoff">usedECRef &lt;- io (newIORef Set.empty)</span>
<span class="lineno">  746 </span><span class="spaces">     </span><span class="nottickedoff">replList &lt;- io $</span>
<span class="lineno">  747 </span><span class="spaces">        </span><span class="nottickedoff">forM (zip unints idxs) $ \(nm,idx) -&gt;</span>
<span class="lineno">  748 </span><span class="spaces">           </span><span class="nottickedoff">do let ls = fromMaybe [] (Map.lookup idx repls')</span>
<span class="lineno">  749 </span><span class="spaces">              </span><span class="nottickedoff">xs &lt;- forM ls $ \(e,vs) -&gt;</span>
<span class="lineno">  750 </span><span class="spaces">                      </span><span class="nottickedoff">do e'  &lt;- mkTypedTerm sc e</span>
<span class="lineno">  751 </span><span class="spaces">                         </span><span class="nottickedoff">vs' &lt;- tupleTypedTerm sc vs</span>
<span class="lineno">  752 </span><span class="spaces">                         </span><span class="nottickedoff">modifyIORef usedECRef (Set.union (getAllExtSet (ttTerm vs')))</span>
<span class="lineno">  753 </span><span class="spaces">                         </span><span class="nottickedoff">pure (e',vs')</span>
<span class="lineno">  754 </span><span class="spaces">              </span><span class="nottickedoff">pure (nm,xs)</span>
<span class="lineno">  755 </span><span class="spaces">     </span><span class="nottickedoff">usedECSet &lt;- io (readIORef usedECRef)</span>
<span class="lineno">  756 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  757 </span><span class="spaces">     </span><span class="nottickedoff">let boundAndUsed = Set.intersection boundECSet usedECSet</span>
<span class="lineno">  758 </span><span class="spaces">     </span><span class="nottickedoff">unless (Set.null boundAndUsed)</span>
<span class="lineno">  759 </span><span class="spaces">       </span><span class="nottickedoff">(do ppOpts &lt;- getTopLevelPPOpts</span>
<span class="lineno">  760 </span><span class="spaces">           </span><span class="nottickedoff">vs &lt;- io $ forM (Set.toList boundAndUsed) $ \ec -&gt;</span>
<span class="lineno">  761 </span><span class="spaces">                              </span><span class="nottickedoff">do pptm &lt;- scPrettyTerm ppOpts &lt;$&gt; scVariable sc ec</span>
<span class="lineno">  762 </span><span class="spaces">                                 </span><span class="nottickedoff">let ppty = scPrettyTerm ppOpts (ecType ec)</span>
<span class="lineno">  763 </span><span class="spaces">                                 </span><span class="nottickedoff">return (pptm &lt;&gt; &quot; : &quot; &lt;&gt; ppty)</span>
<span class="lineno">  764 </span><span class="spaces">           </span><span class="nottickedoff">printOutLnTop Warn $ unlines $</span>
<span class="lineno">  765 </span><span class="spaces">             </span><span class="nottickedoff">[ &quot;WARNING: extracted arguments reference captured variables!&quot;</span>
<span class="lineno">  766 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;This usually means one of functions you extracted was used in a higher-order way&quot;</span>
<span class="lineno">  767 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;that could not be fully unrolled, or the expression depends on lambda-bound variables.&quot;</span>
<span class="lineno">  768 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;The results of reasoning about this extraction may be unexpected.&quot;</span>
<span class="lineno">  769 </span><span class="spaces">             </span><span class="nottickedoff">, &quot;The affected variables are:&quot;</span>
<span class="lineno">  770 </span><span class="spaces">             </span><span class="nottickedoff">] ++ (map (&quot;  &quot;++) vs))</span>
<span class="lineno">  771 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  772 </span><span class="spaces">     </span><span class="nottickedoff">pure (tt', replList)</span></span>
<span class="lineno">  773 </span>
<span class="lineno">  774 </span>
<span class="lineno">  775 </span>congruence_for :: TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno">  776 </span><span class="decl"><span class="istickedoff">congruence_for tt =</span>
<span class="lineno">  777 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  778 </span><span class="spaces">     </span><span class="istickedoff">congTm &lt;- io $ build_congruence sc (ttTerm tt)</span>
<span class="lineno">  779 </span><span class="spaces">     </span><span class="istickedoff">io $ mkTypedTerm sc congTm</span></span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>-- | Given an input term, construct another term that
<span class="lineno">  782 </span>--   represents a congruence law for that term.
<span class="lineno">  783 </span>--   This term will be a Curry-Howard style theorem statement
<span class="lineno">  784 </span>--   that can be dispatched to solvers, and should have
<span class="lineno">  785 </span>--   type \&quot;Prop\&quot;.
<span class="lineno">  786 </span>--
<span class="lineno">  787 </span>--   This will only work for terms that represent non-dependent
<span class="lineno">  788 </span>--   functions.
<span class="lineno">  789 </span>build_congruence :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  790 </span><span class="decl"><span class="istickedoff">build_congruence sc tm =</span>
<span class="lineno">  791 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scTypeOf sc tm</span>
<span class="lineno">  792 </span><span class="spaces">     </span><span class="istickedoff">case asPiList ty of</span>
<span class="lineno">  793 </span><span class="spaces">       </span><span class="istickedoff">([],_) -&gt; <span class="nottickedoff">fail &quot;congruence_for: Term is not a function&quot;</span></span>
<span class="lineno">  794 </span><span class="spaces">       </span><span class="istickedoff">(pis, body) -&gt;</span>
<span class="lineno">  795 </span><span class="spaces">         </span><span class="istickedoff">if <span class="tickonlytrue">termIsClosed body</span> then</span>
<span class="lineno">  796 </span><span class="spaces">           </span><span class="istickedoff">loop pis []</span>
<span class="lineno">  797 </span><span class="spaces">         </span><span class="istickedoff">else</span>
<span class="lineno">  798 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">fail &quot;congruence_for: cannot build congruence for dependent functions&quot;</span></span>
<span class="lineno">  799 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  800 </span><span class="spaces">  </span><span class="istickedoff">loop ((nm,tp):pis) vars =</span>
<span class="lineno">  801 </span><span class="spaces">    </span><span class="istickedoff">if <span class="tickonlytrue">termIsClosed tp</span> then</span>
<span class="lineno">  802 </span><span class="spaces">      </span><span class="istickedoff">do l &lt;- scFreshEC sc (nm &lt;&gt; &quot;_1&quot;) tp</span>
<span class="lineno">  803 </span><span class="spaces">         </span><span class="istickedoff">r &lt;- scFreshEC sc (nm &lt;&gt; &quot;_2&quot;) tp</span>
<span class="lineno">  804 </span><span class="spaces">         </span><span class="istickedoff">loop pis ((l,r):vars)</span>
<span class="lineno">  805 </span><span class="spaces">     </span><span class="istickedoff">else</span>
<span class="lineno">  806 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">fail &quot;congruence_for: cannot build congruence for dependent functions&quot;</span></span>
<span class="lineno">  807 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  808 </span><span class="spaces">  </span><span class="istickedoff">loop [] vars =</span>
<span class="lineno">  809 </span><span class="spaces">    </span><span class="istickedoff">do lvars &lt;- mapM (scVariable sc . fst) (reverse vars)</span>
<span class="lineno">  810 </span><span class="spaces">       </span><span class="istickedoff">rvars &lt;- mapM (scVariable sc . snd) (reverse vars)</span>
<span class="lineno">  811 </span><span class="spaces">       </span><span class="istickedoff">let allVars = concat [ [l,r] | (l,r) &lt;- reverse vars ]</span>
<span class="lineno">  812 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  813 </span><span class="spaces">       </span><span class="istickedoff">basel &lt;- scApplyAll sc tm lvars</span>
<span class="lineno">  814 </span><span class="spaces">       </span><span class="istickedoff">baser &lt;- scApplyAll sc tm rvars</span>
<span class="lineno">  815 </span><span class="spaces">       </span><span class="istickedoff">baseeq &lt;- scEqTrue sc =&lt;&lt; scEq sc basel baser</span>
<span class="lineno">  816 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  817 </span><span class="spaces">       </span><span class="istickedoff">let f x (l,r) =</span>
<span class="lineno">  818 </span><span class="spaces">             </span><span class="istickedoff">do l' &lt;- scVariable sc l</span>
<span class="lineno">  819 </span><span class="spaces">                </span><span class="istickedoff">r' &lt;- scVariable sc r</span>
<span class="lineno">  820 </span><span class="spaces">                </span><span class="istickedoff">eq &lt;- scEqTrue sc =&lt;&lt; scEq sc l' r'</span>
<span class="lineno">  821 </span><span class="spaces">                </span><span class="istickedoff">scFun sc eq x</span>
<span class="lineno">  822 </span><span class="spaces">       </span><span class="istickedoff">finalEq &lt;- foldM f baseeq vars</span>
<span class="lineno">  823 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  824 </span><span class="spaces">       </span><span class="istickedoff">scGeneralizeExts sc allVars finalEq</span></span>
<span class="lineno">  825 </span>
<span class="lineno">  826 </span>
<span class="lineno">  827 </span>filterCryTerms :: SharedContext -&gt; [Term] -&gt; IO [TypedTerm]
<span class="lineno">  828 </span><span class="decl"><span class="nottickedoff">filterCryTerms sc = loop</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  830 </span><span class="spaces">  </span><span class="nottickedoff">loop [] = pure []</span>
<span class="lineno">  831 </span><span class="spaces">  </span><span class="nottickedoff">loop (x:xs) =</span>
<span class="lineno">  832 </span><span class="spaces">    </span><span class="nottickedoff">do tp &lt;- Cryptol.scCryptolType sc =&lt;&lt; scTypeOf sc x</span>
<span class="lineno">  833 </span><span class="spaces">       </span><span class="nottickedoff">case tp of</span>
<span class="lineno">  834 </span><span class="spaces">         </span><span class="nottickedoff">Just (Right cty) -&gt;</span>
<span class="lineno">  835 </span><span class="spaces">           </span><span class="nottickedoff">do let x' = TypedTerm (TypedTermSchema (C.tMono cty)) x</span>
<span class="lineno">  836 </span><span class="spaces">              </span><span class="nottickedoff">xs' &lt;- loop xs</span>
<span class="lineno">  837 </span><span class="spaces">              </span><span class="nottickedoff">pure (x':xs')</span>
<span class="lineno">  838 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  839 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; loop xs</span></span>
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>
<span class="lineno">  842 </span>beta_reduce_goal :: ProofScript ()
<span class="lineno">  843 </span><span class="decl"><span class="nottickedoff">beta_reduce_goal =</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticChange $ \goal -&gt;</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno">  846 </span><span class="spaces">     </span><span class="nottickedoff">sqt' &lt;- traverseSequentWithFocus (io . betaReduceProp sc) (goalSequent goal)</span>
<span class="lineno">  847 </span><span class="spaces">     </span><span class="nottickedoff">return (sqt', ConversionEvidence sqt')</span></span>
<span class="lineno">  848 </span>
<span class="lineno">  849 </span>goal_apply :: Theorem -&gt; ProofScript ()
<span class="lineno">  850 </span><span class="decl"><span class="istickedoff">goal_apply thm =</span>
<span class="lineno">  851 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  852 </span><span class="spaces">     </span><span class="istickedoff">execTactic (tacticApply sc thm)</span></span>
<span class="lineno">  853 </span>
<span class="lineno">  854 </span>goal_exact :: TypedTerm -&gt; ProofScript ()
<span class="lineno">  855 </span><span class="decl"><span class="nottickedoff">goal_exact tm =</span>
<span class="lineno">  856 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  857 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticExact sc (ttTerm tm))</span></span>
<span class="lineno">  858 </span>
<span class="lineno">  859 </span>goal_intro_hyp :: ProofScript ()
<span class="lineno">  860 </span><span class="decl"><span class="nottickedoff">goal_intro_hyp =</span>
<span class="lineno">  861 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  862 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticIntroHyps sc 1)</span></span>
<span class="lineno">  863 </span>
<span class="lineno">  864 </span>goal_intro_hyps :: Integer -&gt; ProofScript ()
<span class="lineno">  865 </span><span class="decl"><span class="nottickedoff">goal_intro_hyps n =</span>
<span class="lineno">  866 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  867 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticIntroHyps sc n)</span></span>
<span class="lineno">  868 </span>
<span class="lineno">  869 </span>goal_revert_hyp :: Integer -&gt; ProofScript ()
<span class="lineno">  870 </span><span class="decl"><span class="nottickedoff">goal_revert_hyp i =</span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  872 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticRevertHyp sc i)</span></span>
<span class="lineno">  873 </span>
<span class="lineno">  874 </span>goal_intro :: Text -&gt; ProofScript TypedTerm
<span class="lineno">  875 </span><span class="decl"><span class="istickedoff">goal_intro s =</span>
<span class="lineno">  876 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  877 </span><span class="spaces">     </span><span class="istickedoff">execTactic (tacticIntro sc s)</span></span>
<span class="lineno">  878 </span>
<span class="lineno">  879 </span>goal_insert :: Theorem -&gt; ProofScript ()
<span class="lineno">  880 </span><span class="decl"><span class="istickedoff">goal_insert thm =</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  882 </span><span class="spaces">     </span><span class="istickedoff">execTactic (tacticInsert <span class="nottickedoff">sc</span> thm [])</span></span>
<span class="lineno">  883 </span>
<span class="lineno">  884 </span>goal_insert_and_specialize :: Theorem -&gt; [TypedTerm] -&gt; ProofScript ()
<span class="lineno">  885 </span><span class="decl"><span class="nottickedoff">goal_insert_and_specialize thm tms =</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  887 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticInsert sc thm (map ttTerm tms))</span></span>
<span class="lineno">  888 </span>
<span class="lineno">  889 </span>goal_specialize_hyp :: [TypedTerm] -&gt; ProofScript ()
<span class="lineno">  890 </span><span class="decl"><span class="nottickedoff">goal_specialize_hyp ts =</span>
<span class="lineno">  891 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  892 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticSpecializeHyp sc (map ttTerm ts))</span></span>
<span class="lineno">  893 </span>
<span class="lineno">  894 </span>goal_apply_hyp :: Integer -&gt; ProofScript ()
<span class="lineno">  895 </span><span class="decl"><span class="nottickedoff">goal_apply_hyp n =</span>
<span class="lineno">  896 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- SV.scriptTopLevel getSharedContext</span>
<span class="lineno">  897 </span><span class="spaces">     </span><span class="nottickedoff">execTactic (tacticApplyHyp sc n)</span></span>
<span class="lineno">  898 </span>
<span class="lineno">  899 </span>goal_num_when :: Int -&gt; ProofScript () -&gt; ProofScript ()
<span class="lineno">  900 </span><span class="decl"><span class="nottickedoff">goal_num_when n script =</span>
<span class="lineno">  901 </span><span class="spaces">  </span><span class="nottickedoff">do s &lt;- get</span>
<span class="lineno">  902 </span><span class="spaces">     </span><span class="nottickedoff">case psGoals s of</span>
<span class="lineno">  903 </span><span class="spaces">       </span><span class="nottickedoff">g : _ | goalNum g == n -&gt; script</span>
<span class="lineno">  904 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; return ()</span></span>
<span class="lineno">  905 </span>
<span class="lineno">  906 </span>goal_when :: Text -&gt; ProofScript () -&gt; ProofScript ()
<span class="lineno">  907 </span><span class="decl"><span class="nottickedoff">goal_when str script =</span>
<span class="lineno">  908 </span><span class="spaces">  </span><span class="nottickedoff">do s &lt;- get</span>
<span class="lineno">  909 </span><span class="spaces">     </span><span class="nottickedoff">case psGoals s of</span>
<span class="lineno">  910 </span><span class="spaces">       </span><span class="nottickedoff">g : _ | (Text.unpack str) `isInfixOf` goalName g -&gt; script</span>
<span class="lineno">  911 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; return ()</span></span>
<span class="lineno">  912 </span>
<span class="lineno">  913 </span>goal_has_tags :: [Text] -&gt; ProofScript Bool
<span class="lineno">  914 </span><span class="decl"><span class="istickedoff">goal_has_tags tags =</span>
<span class="lineno">  915 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- get</span>
<span class="lineno">  916 </span><span class="spaces">     </span><span class="istickedoff">case psGoals s of</span>
<span class="lineno">  917 </span><span class="spaces">       </span><span class="istickedoff">g : _ | Set.isSubsetOf (Set.fromList (map Text.unpack tags)) (goalTags g) -&gt; return True</span>
<span class="lineno">  918 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; return False</span></span>
<span class="lineno">  919 </span>
<span class="lineno">  920 </span>goal_has_some_tag :: [Text] -&gt; ProofScript Bool
<span class="lineno">  921 </span><span class="decl"><span class="nottickedoff">goal_has_some_tag tags =</span>
<span class="lineno">  922 </span><span class="spaces">  </span><span class="nottickedoff">do s &lt;- get</span>
<span class="lineno">  923 </span><span class="spaces">     </span><span class="nottickedoff">case psGoals s of</span>
<span class="lineno">  924 </span><span class="spaces">       </span><span class="nottickedoff">g : _ | not $ Set.disjoint (Set.fromList (map Text.unpack tags)) (goalTags g) -&gt; return True</span>
<span class="lineno">  925 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; return False</span></span>
<span class="lineno">  926 </span>
<span class="lineno">  927 </span>goal_num_ite :: Int -&gt; ProofScript SV.Value -&gt; ProofScript SV.Value -&gt; ProofScript SV.Value
<span class="lineno">  928 </span><span class="decl"><span class="istickedoff">goal_num_ite n s1 s2 =</span>
<span class="lineno">  929 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- get</span>
<span class="lineno">  930 </span><span class="spaces">     </span><span class="istickedoff">case psGoals s of</span>
<span class="lineno">  931 </span><span class="spaces">          </span><span class="istickedoff">g : _ | goalNum g == n -&gt; s1</span>
<span class="lineno">  932 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; s2</span></span>
<span class="lineno">  933 </span>
<span class="lineno">  934 </span>-- | Bit-blast a proposition and check its validity using ABC.
<span class="lineno">  935 </span>proveABC :: ProofScript ()
<span class="lineno">  936 </span><span class="decl"><span class="nottickedoff">proveABC = do</span>
<span class="lineno">  937 </span><span class="spaces">  </span><span class="nottickedoff">SV.AIGProxy proxy &lt;- SV.scriptTopLevel SV.getProxy</span>
<span class="lineno">  938 </span><span class="spaces">  </span><span class="nottickedoff">wrapProver [AIG] [] (Prover.proveABC proxy) Set.empty</span></span>
<span class="lineno">  939 </span>
<span class="lineno">  940 </span>satExternal :: Bool -&gt; Text -&gt; [Text] -&gt; ProofScript ()
<span class="lineno">  941 </span><span class="decl"><span class="nottickedoff">satExternal doCNF execName args =</span>
<span class="lineno">  942 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticSolve $ \g -&gt;</span>
<span class="lineno">  943 </span><span class="spaces">    </span><span class="nottickedoff">do SV.AIGProxy proxy &lt;- SV.getProxy</span>
<span class="lineno">  944 </span><span class="spaces">       </span><span class="nottickedoff">sc &lt;- SV.getSharedContext</span>
<span class="lineno">  945 </span><span class="spaces">       </span><span class="nottickedoff">let execName' = Text.unpack execName</span>
<span class="lineno">  946 </span><span class="spaces">           </span><span class="nottickedoff">args' = map Text.unpack args</span>
<span class="lineno">  947 </span><span class="spaces">       </span><span class="nottickedoff">(mb, stats) &lt;- Prover.abcSatExternal proxy sc doCNF execName' args' g</span>
<span class="lineno">  948 </span><span class="spaces">       </span><span class="nottickedoff">case mb of</span>
<span class="lineno">  949 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; return (stats, SolveSuccess (SolverEvidence stats (goalSequent g)))</span>
<span class="lineno">  950 </span><span class="spaces">         </span><span class="nottickedoff">Just a  -&gt; return (stats, SolveCounterexample a)</span></span>
<span class="lineno">  951 </span>
<span class="lineno">  952 </span>writeAIGPrim :: Text -&gt; Term -&gt; TopLevel ()
<span class="lineno">  953 </span><span class="decl"><span class="istickedoff">writeAIGPrim ftxt e = do</span>
<span class="lineno">  954 </span><span class="spaces">  </span><span class="istickedoff">let f :: FilePath = Text.unpack ftxt</span>
<span class="lineno">  955 </span><span class="spaces">  </span><span class="istickedoff">Prover.writeAIG f e</span></span>
<span class="lineno">  956 </span>
<span class="lineno">  957 </span>writeSAIGPrim :: Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno">  958 </span><span class="decl"><span class="nottickedoff">writeSAIGPrim filetxt tt = do</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="nottickedoff">let file :: FilePath = Text.unpack filetxt</span>
<span class="lineno">  960 </span><span class="spaces">  </span><span class="nottickedoff">write_tt &lt;- Prover.writeSAIGInferLatches tt</span>
<span class="lineno">  961 </span><span class="spaces">  </span><span class="nottickedoff">io $ write_tt file</span></span>
<span class="lineno">  962 </span>
<span class="lineno">  963 </span>writeSAIGComputedPrim :: Text -&gt; Term -&gt; Int -&gt; TopLevel ()
<span class="lineno">  964 </span><span class="decl"><span class="nottickedoff">writeSAIGComputedPrim ftxt e n = do</span>
<span class="lineno">  965 </span><span class="spaces">  </span><span class="nottickedoff">let f :: FilePath = Text.unpack ftxt</span>
<span class="lineno">  966 </span><span class="spaces">  </span><span class="nottickedoff">Prover.writeSAIG f e n</span></span>
<span class="lineno">  967 </span>
<span class="lineno">  968 </span>-- | Bit-blast a proposition check its validity using the RME library.
<span class="lineno">  969 </span>proveRME :: ProofScript ()
<span class="lineno">  970 </span><span class="decl"><span class="istickedoff">proveRME = wrapProver [RME] [] Prover.proveRME Set.empty</span></span>
<span class="lineno">  971 </span>
<span class="lineno">  972 </span>codegenSBV :: SharedContext -&gt; Text -&gt; [Text] -&gt; Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno">  973 </span><span class="decl"><span class="nottickedoff">codegenSBV sc pathtxt unints fnametxt (TypedTerm _schema t) = do</span>
<span class="lineno">  974 </span><span class="spaces">     </span><span class="nottickedoff">let path :: FilePath = Text.unpack pathtxt</span>
<span class="lineno">  975 </span><span class="spaces">         </span><span class="nottickedoff">fname :: FilePath = Text.unpack fnametxt</span>
<span class="lineno">  976 </span><span class="spaces">     </span><span class="nottickedoff">unintSet &lt;- resolveNames unints</span>
<span class="lineno">  977 </span><span class="spaces">     </span><span class="nottickedoff">let mpath = if null path then Nothing else Just path</span>
<span class="lineno">  978 </span><span class="spaces">     </span><span class="nottickedoff">io $ SBVSim.sbvCodeGen sc mempty unintSet mpath fname t</span></span>
<span class="lineno">  979 </span>
<span class="lineno">  980 </span>-- | Bit-blast a proposition and check its validity using SBV.
<span class="lineno">  981 </span>-- (Currently ignores satisfying assignments.)
<span class="lineno">  982 </span>proveSBV :: SBV.SMTConfig -&gt; ProofScript ()
<span class="lineno">  983 </span><span class="decl"><span class="istickedoff">proveSBV conf = proveUnintSBV conf []</span></span>
<span class="lineno">  984 </span>
<span class="lineno">  985 </span>-- | Bit-blast a proposition and check its validity using SBV.
<span class="lineno">  986 </span>-- (Currently ignores satisfying assignments.) Constants with names in
<span class="lineno">  987 </span>-- @unints@ are kept as uninterpreted functions.
<span class="lineno">  988 </span>proveUnintSBV :: SBV.SMTConfig -&gt; [Text] -&gt; ProofScript ()
<span class="lineno">  989 </span><span class="decl"><span class="istickedoff">proveUnintSBV conf unints =</span>
<span class="lineno">  990 </span><span class="spaces">  </span><span class="istickedoff">do timeout &lt;- psTimeout &lt;$&gt; get</span>
<span class="lineno">  991 </span><span class="spaces">     </span><span class="istickedoff">unintSet &lt;- SV.scriptTopLevel (resolveNames unints)</span>
<span class="lineno">  992 </span><span class="spaces">     </span><span class="istickedoff">wrapProver (sbvBackends conf) []</span>
<span class="lineno">  993 </span><span class="spaces">                </span><span class="istickedoff">(Prover.proveUnintSBV conf timeout) unintSet</span></span>
<span class="lineno">  994 </span>
<span class="lineno">  995 </span>-- | Given a continuation which calls a prover, call the continuation on the
<span class="lineno">  996 </span>-- given 'Sequent' and return a 'SolveResult'. If there is a 'SolverCache',
<span class="lineno">  997 </span>-- do not call the continuation if the goal has an already cached result,
<span class="lineno">  998 </span>-- and otherwise save the result of the call to the cache.
<span class="lineno">  999 </span>applyProverToGoal :: [SolverBackend] -&gt; [SolverBackendOption]
<span class="lineno"> 1000 </span>                     -&gt; (SATQuery -&gt; TopLevel (Maybe CEX, Text))
<span class="lineno"> 1001 </span>                     -&gt; Set VarIndex -&gt; Sequent
<span class="lineno"> 1002 </span>                     -&gt; TopLevel (SolverStats, SolveResult)
<span class="lineno"> 1003 </span><span class="decl"><span class="istickedoff">applyProverToGoal backends opts f unintSet sqt = do</span>
<span class="lineno"> 1004 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1005 </span><span class="spaces">  </span><span class="istickedoff">let opt_backends = concatMap optionBackends opts</span>
<span class="lineno"> 1006 </span><span class="spaces">  </span><span class="istickedoff">vs   &lt;- io $ getSolverBackendVersions (backends ++ opt_backends)</span>
<span class="lineno"> 1007 </span><span class="spaces">  </span><span class="istickedoff">satq &lt;- io $ sequentToSATQuery sc unintSet sqt</span>
<span class="lineno"> 1008 </span><span class="spaces">  </span><span class="istickedoff">k    &lt;- io $ mkSolverCacheKey sc vs opts satq</span>
<span class="lineno"> 1009 </span><span class="spaces">  </span><span class="istickedoff">(mb, solver_name) &lt;- SV.onSolverCache (lookupInSolverCache k) &gt;&gt;= \case</span>
<span class="lineno"> 1010 </span><span class="spaces">    </span><span class="istickedoff">-- Use a cached result if one exists (and it's valid w.r.t our query)</span>
<span class="lineno"> 1011 </span><span class="spaces">    </span><span class="istickedoff">Just v -&gt; return $ fromSolverCacheValue satq v</span>
<span class="lineno"> 1012 </span><span class="spaces">    </span><span class="istickedoff">-- Otherwise try to cache the result of the call</span>
<span class="lineno"> 1013 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; f satq &gt;&gt;= \res -&gt; io (toSolverCacheValue vs opts satq res) &gt;&gt;= \case</span>
<span class="lineno"> 1014 </span><span class="spaces">           </span><span class="istickedoff">Just v  -&gt; SV.onSolverCache (insertInSolverCache k v) &gt;&gt;</span>
<span class="lineno"> 1015 </span><span class="spaces">                      </span><span class="istickedoff">return res</span>
<span class="lineno"> 1016 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return res</span></span>
<span class="lineno"> 1017 </span><span class="spaces">  </span><span class="istickedoff">let stats = solverStats solver_name (sequentSharedSize sqt)</span>
<span class="lineno"> 1018 </span><span class="spaces">  </span><span class="istickedoff">case mb of</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; return (stats, SolveSuccess (SolverEvidence stats sqt))</span>
<span class="lineno"> 1020 </span><span class="spaces">    </span><span class="istickedoff">Just a  -&gt; return (stats, SolveCounterexample a)</span></span>
<span class="lineno"> 1021 </span>
<span class="lineno"> 1022 </span>wrapProver ::
<span class="lineno"> 1023 </span>  [SolverBackend] -&gt; [SolverBackendOption] -&gt;
<span class="lineno"> 1024 </span>  (SATQuery -&gt; TopLevel (Maybe CEX, Text)) -&gt;
<span class="lineno"> 1025 </span>  Set VarIndex -&gt;
<span class="lineno"> 1026 </span>  ProofScript ()
<span class="lineno"> 1027 </span><span class="decl"><span class="istickedoff">wrapProver backends opts f unints =</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticSolve $ applyProverToGoal backends opts f unints . goalSequent</span></span>
<span class="lineno"> 1029 </span>
<span class="lineno"> 1030 </span>wrapW4Prover ::
<span class="lineno"> 1031 </span>  SolverBackend -&gt; [SolverBackendOption] -&gt;
<span class="lineno"> 1032 </span>  ( Bool -&gt; SATQuery -&gt; TopLevel (Maybe CEX, Text) ) -&gt;
<span class="lineno"> 1033 </span>  [Text] -&gt;
<span class="lineno"> 1034 </span>  ProofScript ()
<span class="lineno"> 1035 </span><span class="decl"><span class="istickedoff">wrapW4Prover backend opts f unints = do</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="istickedoff">hashConsing &lt;- SV.scriptTopLevel $ gets SV.rwWhat4HashConsing</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="istickedoff">unintSet &lt;- SV.scriptTopLevel $ resolveNames unints</span>
<span class="lineno"> 1038 </span><span class="spaces">  </span><span class="istickedoff">wrapProver [What4, backend] opts (f hashConsing) unintSet</span></span>
<span class="lineno"> 1039 </span>
<span class="lineno"> 1040 </span>wrapW4ProveExporter ::
<span class="lineno"> 1041 </span>  ( Bool -&gt; FilePath -&gt; SATQuery -&gt; TopLevel (Maybe CEX, Text) ) -&gt;
<span class="lineno"> 1042 </span>  [Text] -&gt;
<span class="lineno"> 1043 </span>  FilePath -&gt;
<span class="lineno"> 1044 </span>  FilePath -&gt;
<span class="lineno"> 1045 </span>  ProofScript ()
<span class="lineno"> 1046 </span><span class="decl"><span class="nottickedoff">wrapW4ProveExporter f unints path ext = do</span>
<span class="lineno"> 1047 </span><span class="spaces">  </span><span class="nottickedoff">hashConsing &lt;- SV.scriptTopLevel $ gets SV.rwWhat4HashConsing</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="nottickedoff">unintSet &lt;- SV.scriptTopLevel $ resolveNames unints</span>
<span class="lineno"> 1049 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticSolve $ \g -&gt; do</span>
<span class="lineno"> 1050 </span><span class="spaces">    </span><span class="nottickedoff">let file = path ++ &quot;.&quot; ++ goalType g ++ show (goalNum g) ++ ext</span>
<span class="lineno"> 1051 </span><span class="spaces">    </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1052 </span><span class="spaces">    </span><span class="nottickedoff">satq &lt;- io $ sequentToSATQuery sc unintSet (goalSequent g)</span>
<span class="lineno"> 1053 </span><span class="spaces">    </span><span class="nottickedoff">(_, solver_name) &lt;- f hashConsing file satq</span>
<span class="lineno"> 1054 </span><span class="spaces">    </span><span class="nottickedoff">let stats = solverStats solver_name (sequentSharedSize (goalSequent g))</span>
<span class="lineno"> 1055 </span><span class="spaces">    </span><span class="nottickedoff">return (stats, SolveSuccess (SolverEvidence stats (goalSequent g)))</span></span>
<span class="lineno"> 1056 </span>
<span class="lineno"> 1057 </span>--------------------------------------------------
<span class="lineno"> 1058 </span>proveABC_SBV :: ProofScript ()
<span class="lineno"> 1059 </span><span class="decl"><span class="nottickedoff">proveABC_SBV = proveSBV SBV.abc</span></span>
<span class="lineno"> 1060 </span>
<span class="lineno"> 1061 </span>proveBitwuzla :: ProofScript ()
<span class="lineno"> 1062 </span><span class="decl"><span class="istickedoff">proveBitwuzla = proveSBV SBV.bitwuzla</span></span>
<span class="lineno"> 1063 </span>
<span class="lineno"> 1064 </span>proveBoolector :: ProofScript ()
<span class="lineno"> 1065 </span><span class="decl"><span class="nottickedoff">proveBoolector = proveSBV SBV.boolector</span></span>
<span class="lineno"> 1066 </span>
<span class="lineno"> 1067 </span>proveZ3 :: ProofScript ()
<span class="lineno"> 1068 </span><span class="decl"><span class="istickedoff">proveZ3 = proveSBV SBV.z3</span></span>
<span class="lineno"> 1069 </span>
<span class="lineno"> 1070 </span>proveCVC4 :: ProofScript ()
<span class="lineno"> 1071 </span><span class="decl"><span class="istickedoff">proveCVC4 = proveSBV SBV.cvc4</span></span>
<span class="lineno"> 1072 </span>
<span class="lineno"> 1073 </span>proveCVC5 :: ProofScript ()
<span class="lineno"> 1074 </span><span class="decl"><span class="nottickedoff">proveCVC5 = proveSBV SBV.cvc5</span></span>
<span class="lineno"> 1075 </span>
<span class="lineno"> 1076 </span>proveMathSAT :: ProofScript ()
<span class="lineno"> 1077 </span><span class="decl"><span class="nottickedoff">proveMathSAT = proveSBV SBV.mathSAT</span></span>
<span class="lineno"> 1078 </span>
<span class="lineno"> 1079 </span>proveYices :: ProofScript ()
<span class="lineno"> 1080 </span><span class="decl"><span class="istickedoff">proveYices = proveSBV SBV.yices</span></span>
<span class="lineno"> 1081 </span>
<span class="lineno"> 1082 </span>proveUnintBitwuzla :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1083 </span><span class="decl"><span class="nottickedoff">proveUnintBitwuzla = proveUnintSBV SBV.bitwuzla</span></span>
<span class="lineno"> 1084 </span>
<span class="lineno"> 1085 </span>proveUnintBoolector :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1086 </span><span class="decl"><span class="nottickedoff">proveUnintBoolector = proveUnintSBV SBV.boolector</span></span>
<span class="lineno"> 1087 </span>
<span class="lineno"> 1088 </span>proveUnintZ3 :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1089 </span><span class="decl"><span class="istickedoff">proveUnintZ3 = proveUnintSBV SBV.z3</span></span>
<span class="lineno"> 1090 </span>
<span class="lineno"> 1091 </span>proveUnintCVC4 :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1092 </span><span class="decl"><span class="nottickedoff">proveUnintCVC4 = proveUnintSBV SBV.cvc4</span></span>
<span class="lineno"> 1093 </span>
<span class="lineno"> 1094 </span>proveUnintCVC5 :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1095 </span><span class="decl"><span class="nottickedoff">proveUnintCVC5 = proveUnintSBV SBV.cvc5</span></span>
<span class="lineno"> 1096 </span>
<span class="lineno"> 1097 </span>proveUnintMathSAT :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1098 </span><span class="decl"><span class="nottickedoff">proveUnintMathSAT = proveUnintSBV SBV.mathSAT</span></span>
<span class="lineno"> 1099 </span>
<span class="lineno"> 1100 </span>proveUnintYices :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1101 </span><span class="decl"><span class="istickedoff">proveUnintYices = proveUnintSBV SBV.yices</span></span>
<span class="lineno"> 1102 </span>
<span class="lineno"> 1103 </span>
<span class="lineno"> 1104 </span>--------------------------------------------------
<span class="lineno"> 1105 </span>w4_abc_smtlib2 :: ProofScript ()
<span class="lineno"> 1106 </span><span class="decl"><span class="nottickedoff">w4_abc_smtlib2 = wrapW4Prover ABC [W4_SMTLib2] Prover.proveWhat4_abc []</span></span>
<span class="lineno"> 1107 </span>
<span class="lineno"> 1108 </span>w4_bitwuzla :: ProofScript ()
<span class="lineno"> 1109 </span><span class="decl"><span class="nottickedoff">w4_bitwuzla = wrapW4Prover Bitwuzla [] Prover.proveWhat4_bitwuzla []</span></span>
<span class="lineno"> 1110 </span>
<span class="lineno"> 1111 </span>w4_boolector :: ProofScript ()
<span class="lineno"> 1112 </span><span class="decl"><span class="nottickedoff">w4_boolector = wrapW4Prover Boolector [] Prover.proveWhat4_boolector []</span></span>
<span class="lineno"> 1113 </span>
<span class="lineno"> 1114 </span>w4_z3 :: ProofScript ()
<span class="lineno"> 1115 </span><span class="decl"><span class="istickedoff">w4_z3 = wrapW4Prover Z3 [] Prover.proveWhat4_z3 []</span></span>
<span class="lineno"> 1116 </span>
<span class="lineno"> 1117 </span>w4_cvc4 :: ProofScript ()
<span class="lineno"> 1118 </span><span class="decl"><span class="nottickedoff">w4_cvc4 = wrapW4Prover CVC4 [] Prover.proveWhat4_cvc4 []</span></span>
<span class="lineno"> 1119 </span>
<span class="lineno"> 1120 </span>w4_cvc5 :: ProofScript ()
<span class="lineno"> 1121 </span><span class="decl"><span class="nottickedoff">w4_cvc5 = wrapW4Prover CVC5 [] Prover.proveWhat4_cvc5 []</span></span>
<span class="lineno"> 1122 </span>
<span class="lineno"> 1123 </span>w4_yices :: ProofScript ()
<span class="lineno"> 1124 </span><span class="decl"><span class="nottickedoff">w4_yices = wrapW4Prover Yices [] Prover.proveWhat4_yices []</span></span>
<span class="lineno"> 1125 </span>
<span class="lineno"> 1126 </span>w4_unint_bitwuzla :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1127 </span><span class="decl"><span class="istickedoff">w4_unint_bitwuzla = wrapW4Prover Bitwuzla [] Prover.proveWhat4_bitwuzla</span></span>
<span class="lineno"> 1128 </span>
<span class="lineno"> 1129 </span>w4_unint_boolector :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1130 </span><span class="decl"><span class="nottickedoff">w4_unint_boolector = wrapW4Prover Boolector [] Prover.proveWhat4_boolector</span></span>
<span class="lineno"> 1131 </span>
<span class="lineno"> 1132 </span>w4_unint_z3 :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1133 </span><span class="decl"><span class="istickedoff">w4_unint_z3 = wrapW4Prover Z3 [] Prover.proveWhat4_z3</span></span>
<span class="lineno"> 1134 </span>
<span class="lineno"> 1135 </span>w4_unint_z3_using :: Text -&gt; [Text] -&gt; ProofScript ()
<span class="lineno"> 1136 </span><span class="decl"><span class="istickedoff">w4_unint_z3_using tactic =</span>
<span class="lineno"> 1137 </span><span class="spaces">  </span><span class="istickedoff">let tactic' = Text.unpack tactic in</span>
<span class="lineno"> 1138 </span><span class="spaces">  </span><span class="istickedoff">wrapW4Prover Z3 [W4_Tactic tactic'] (Prover.proveWhat4_z3_using tactic')</span></span>
<span class="lineno"> 1139 </span>
<span class="lineno"> 1140 </span>w4_unint_cvc4 :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1141 </span><span class="decl"><span class="nottickedoff">w4_unint_cvc4 = wrapW4Prover CVC4 [] Prover.proveWhat4_cvc4</span></span>
<span class="lineno"> 1142 </span>
<span class="lineno"> 1143 </span>w4_unint_cvc5 :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1144 </span><span class="decl"><span class="istickedoff">w4_unint_cvc5 = wrapW4Prover CVC5 [] Prover.proveWhat4_cvc5</span></span>
<span class="lineno"> 1145 </span>
<span class="lineno"> 1146 </span>w4_unint_yices :: [Text] -&gt; ProofScript ()
<span class="lineno"> 1147 </span><span class="decl"><span class="istickedoff">w4_unint_yices = wrapW4Prover Yices [] Prover.proveWhat4_yices</span></span>
<span class="lineno"> 1148 </span>
<span class="lineno"> 1149 </span>offline_w4_unint_bitwuzla :: [Text] -&gt; FilePath -&gt; ProofScript ()
<span class="lineno"> 1150 </span><span class="decl"><span class="nottickedoff">offline_w4_unint_bitwuzla unints path =</span>
<span class="lineno"> 1151 </span><span class="spaces">  </span><span class="nottickedoff">wrapW4ProveExporter Prover.proveExportWhat4_bitwuzla unints path &quot;.smt2&quot;</span></span>
<span class="lineno"> 1152 </span>
<span class="lineno"> 1153 </span>offline_w4_unint_z3 :: [Text] -&gt; FilePath -&gt; ProofScript ()
<span class="lineno"> 1154 </span><span class="decl"><span class="nottickedoff">offline_w4_unint_z3 unints path =</span>
<span class="lineno"> 1155 </span><span class="spaces">  </span><span class="nottickedoff">wrapW4ProveExporter Prover.proveExportWhat4_z3 unints path &quot;.smt2&quot;</span></span>
<span class="lineno"> 1156 </span>
<span class="lineno"> 1157 </span>offline_w4_unint_cvc4 :: [Text] -&gt; FilePath -&gt; ProofScript ()
<span class="lineno"> 1158 </span><span class="decl"><span class="nottickedoff">offline_w4_unint_cvc4 unints path =</span>
<span class="lineno"> 1159 </span><span class="spaces">  </span><span class="nottickedoff">wrapW4ProveExporter Prover.proveExportWhat4_cvc4 unints path &quot;.smt2&quot;</span></span>
<span class="lineno"> 1160 </span>
<span class="lineno"> 1161 </span>offline_w4_unint_cvc5 :: [Text] -&gt; FilePath -&gt; ProofScript ()
<span class="lineno"> 1162 </span><span class="decl"><span class="nottickedoff">offline_w4_unint_cvc5 unints path =</span>
<span class="lineno"> 1163 </span><span class="spaces">  </span><span class="nottickedoff">wrapW4ProveExporter Prover.proveExportWhat4_cvc5 unints path &quot;.smt2&quot;</span></span>
<span class="lineno"> 1164 </span>
<span class="lineno"> 1165 </span>offline_w4_unint_yices :: [Text] -&gt; FilePath -&gt; ProofScript ()
<span class="lineno"> 1166 </span><span class="decl"><span class="nottickedoff">offline_w4_unint_yices unints path =</span>
<span class="lineno"> 1167 </span><span class="spaces">  </span><span class="nottickedoff">wrapW4ProveExporter Prover.proveExportWhat4_yices unints path &quot;.smt2&quot;</span></span>
<span class="lineno"> 1168 </span>
<span class="lineno"> 1169 </span>proveWithSATExporter ::
<span class="lineno"> 1170 </span>  (FilePath -&gt; SATQuery -&gt; TopLevel a) -&gt;
<span class="lineno"> 1171 </span>  Set VarIndex -&gt;
<span class="lineno"> 1172 </span>  String -&gt;
<span class="lineno"> 1173 </span>  String -&gt;
<span class="lineno"> 1174 </span>  String -&gt;
<span class="lineno"> 1175 </span>  ProofScript ()
<span class="lineno"> 1176 </span><span class="decl"><span class="istickedoff">proveWithSATExporter exporter unintSet path sep ext =</span>
<span class="lineno"> 1177 </span><span class="spaces">  </span><span class="istickedoff">execTactic $ tacticSolve $ \g -&gt;</span>
<span class="lineno"> 1178 </span><span class="spaces">  </span><span class="istickedoff">do let file = path ++ sep ++ goalType g ++ show (goalNum g) ++ ext</span>
<span class="lineno"> 1179 </span><span class="spaces">     </span><span class="istickedoff">stats &lt;- Prover.proveWithSATExporter exporter unintSet file (goalSequent g)</span>
<span class="lineno"> 1180 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">stats</span>, SolveSuccess (SolverEvidence stats (goalSequent g)))</span></span>
<span class="lineno"> 1181 </span>
<span class="lineno"> 1182 </span>proveWithPropExporter ::
<span class="lineno"> 1183 </span>  (FilePath -&gt; Prop -&gt; TopLevel a) -&gt;
<span class="lineno"> 1184 </span>  String -&gt;
<span class="lineno"> 1185 </span>  String -&gt;
<span class="lineno"> 1186 </span>  String -&gt;
<span class="lineno"> 1187 </span>  ProofScript ()
<span class="lineno"> 1188 </span><span class="decl"><span class="nottickedoff">proveWithPropExporter exporter path sep ext =</span>
<span class="lineno"> 1189 </span><span class="spaces">  </span><span class="nottickedoff">execTactic $ tacticSolve $ \g -&gt;</span>
<span class="lineno"> 1190 </span><span class="spaces">  </span><span class="nottickedoff">do let file = path ++ sep ++ goalType g ++ show (goalNum g) ++ ext</span>
<span class="lineno"> 1191 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1192 </span><span class="spaces">     </span><span class="nottickedoff">p &lt;- io $ sequentToProp sc (goalSequent g)</span>
<span class="lineno"> 1193 </span><span class="spaces">     </span><span class="nottickedoff">stats &lt;- Prover.proveWithPropExporter exporter file p</span>
<span class="lineno"> 1194 </span><span class="spaces">     </span><span class="nottickedoff">return (stats, SolveSuccess (SolverEvidence stats (goalSequent g)))</span></span>
<span class="lineno"> 1195 </span>
<span class="lineno"> 1196 </span>offline_aig :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1197 </span><span class="decl"><span class="nottickedoff">offline_aig path =</span>
<span class="lineno"> 1198 </span><span class="spaces">  </span><span class="nottickedoff">proveWithSATExporter Prover.writeAIG_SAT mempty path &quot;.&quot; &quot;.aig&quot;</span></span>
<span class="lineno"> 1199 </span>
<span class="lineno"> 1200 </span>offline_aig_external :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1201 </span><span class="decl"><span class="nottickedoff">offline_aig_external path =</span>
<span class="lineno"> 1202 </span><span class="spaces">  </span><span class="nottickedoff">proveWithSATExporter Prover.writeAIG_SATviaVerilog mempty path &quot;.&quot; &quot;.aig&quot;</span></span>
<span class="lineno"> 1203 </span>
<span class="lineno"> 1204 </span>offline_cnf :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1205 </span><span class="decl"><span class="istickedoff">offline_cnf path =</span>
<span class="lineno"> 1206 </span><span class="spaces">  </span><span class="istickedoff">proveWithSATExporter Prover.writeCNF mempty path &quot;.&quot; &quot;.cnf&quot;</span></span>
<span class="lineno"> 1207 </span>
<span class="lineno"> 1208 </span>offline_cnf_external :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1209 </span><span class="decl"><span class="nottickedoff">offline_cnf_external path =</span>
<span class="lineno"> 1210 </span><span class="spaces">  </span><span class="nottickedoff">proveWithSATExporter Prover.writeCNF_SATviaVerilog mempty path &quot;.&quot; &quot;.cnf&quot;</span></span>
<span class="lineno"> 1211 </span>
<span class="lineno"> 1212 </span>offline_coq :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1213 </span><span class="decl"><span class="nottickedoff">offline_coq path = proveWithPropExporter (Prover.writeCoqProp &quot;goal&quot; [] []) path &quot;_&quot; &quot;.v&quot;</span></span>
<span class="lineno"> 1214 </span>
<span class="lineno"> 1215 </span>offline_extcore :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1216 </span><span class="decl"><span class="nottickedoff">offline_extcore path = proveWithPropExporter Prover.writeCoreProp path &quot;.&quot; &quot;.extcore&quot;</span></span>
<span class="lineno"> 1217 </span>
<span class="lineno"> 1218 </span>offline_smtlib2 :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1219 </span><span class="decl"><span class="istickedoff">offline_smtlib2 path = proveWithSATExporter Prover.writeSMTLib2 mempty path &quot;.&quot; &quot;.smt2&quot;</span></span>
<span class="lineno"> 1220 </span>
<span class="lineno"> 1221 </span>w4_offline_smtlib2 :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1222 </span><span class="decl"><span class="nottickedoff">w4_offline_smtlib2 path = proveWithSATExporter Prover.writeSMTLib2What4 mempty path &quot;.&quot; &quot;.smt2&quot;</span></span>
<span class="lineno"> 1223 </span>
<span class="lineno"> 1224 </span>offline_unint_smtlib2 :: [Text] -&gt; FilePath -&gt; ProofScript ()
<span class="lineno"> 1225 </span><span class="decl"><span class="nottickedoff">offline_unint_smtlib2 unints path =</span>
<span class="lineno"> 1226 </span><span class="spaces">  </span><span class="nottickedoff">do unintSet &lt;- SV.scriptTopLevel $ resolveNames unints</span>
<span class="lineno"> 1227 </span><span class="spaces">     </span><span class="nottickedoff">proveWithSATExporter Prover.writeSMTLib2 unintSet path &quot;.&quot; &quot;.smt2&quot;</span></span>
<span class="lineno"> 1228 </span>
<span class="lineno"> 1229 </span>offline_verilog :: FilePath -&gt; ProofScript ()
<span class="lineno"> 1230 </span><span class="decl"><span class="nottickedoff">offline_verilog path =</span>
<span class="lineno"> 1231 </span><span class="spaces">  </span><span class="nottickedoff">proveWithSATExporter Prover.writeVerilogSAT mempty path &quot;.&quot; &quot;.v&quot;</span></span>
<span class="lineno"> 1232 </span>
<span class="lineno"> 1233 </span>w4_abc_aiger :: ProofScript ()
<span class="lineno"> 1234 </span><span class="decl"><span class="istickedoff">w4_abc_aiger = wrapW4Prover ABC [W4_AIGER] Prover.w4AbcAIGER []</span></span>
<span class="lineno"> 1235 </span>
<span class="lineno"> 1236 </span>w4_abc_verilog :: ProofScript ()
<span class="lineno"> 1237 </span><span class="decl"><span class="istickedoff">w4_abc_verilog = wrapW4Prover ABC [W4_Verilog] Prover.w4AbcVerilog []</span></span>
<span class="lineno"> 1238 </span>
<span class="lineno"> 1239 </span>set_timeout :: Integer -&gt; ProofScript ()
<span class="lineno"> 1240 </span><span class="decl"><span class="nottickedoff">set_timeout to = modify (setProofTimeout to)</span></span>
<span class="lineno"> 1241 </span>
<span class="lineno"> 1242 </span>-- | Translate a @Term@ representing a theorem for input to the
<span class="lineno"> 1243 </span>-- given validity-checking script and attempt to prove it.
<span class="lineno"> 1244 </span>provePrim ::
<span class="lineno"> 1245 </span>  ProofScript () -&gt;
<span class="lineno"> 1246 </span>  TypedTerm -&gt;
<span class="lineno"> 1247 </span>  TopLevel ProofResult
<span class="lineno"> 1248 </span><span class="decl"><span class="istickedoff">provePrim script t = do</span>
<span class="lineno"> 1249 </span><span class="spaces">  </span><span class="istickedoff">io $ checkBooleanSchema (ttType t)</span>
<span class="lineno"> 1250 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1251 </span><span class="spaces">  </span><span class="istickedoff">prop &lt;- io $ predicateToProp sc Universal (ttTerm t)</span>
<span class="lineno"> 1252 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 1253 </span><span class="spaces">  </span><span class="istickedoff">let goal = ProofGoal</span>
<span class="lineno"> 1254 </span><span class="spaces">             </span><span class="istickedoff">{ goalNum  = 0</span>
<span class="lineno"> 1255 </span><span class="spaces">             </span><span class="istickedoff">, goalType = &quot;prove&quot;</span>
<span class="lineno"> 1256 </span><span class="spaces">             </span><span class="istickedoff">, goalName = <span class="nottickedoff">&quot;prove_prim&quot;</span></span>
<span class="lineno"> 1257 </span><span class="spaces">             </span><span class="istickedoff">, goalLoc  = <span class="nottickedoff">show pos</span></span>
<span class="lineno"> 1258 </span><span class="spaces">             </span><span class="istickedoff">, goalDesc = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 1259 </span><span class="spaces">             </span><span class="istickedoff">, goalSequent = propToSequent prop</span>
<span class="lineno"> 1260 </span><span class="spaces">             </span><span class="istickedoff">, goalTags = <span class="nottickedoff">mempty</span></span>
<span class="lineno"> 1261 </span><span class="spaces">             </span><span class="istickedoff">}</span>
<span class="lineno"> 1262 </span><span class="spaces">  </span><span class="istickedoff">res &lt;- SV.runProofScript script prop goal <span class="nottickedoff">Nothing</span> <span class="nottickedoff">&quot;prove_prim&quot;</span> <span class="nottickedoff">True</span> False</span>
<span class="lineno"> 1263 </span><span class="spaces">  </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1264 </span><span class="spaces">    </span><span class="istickedoff">UnfinishedProof pst -&gt;</span>
<span class="lineno"> 1265 </span><span class="spaces">      </span><span class="istickedoff">printOutLnTop Info $ &quot;prove: &quot; ++ show (length (psGoals pst)) ++ &quot; unsolved subgoal(s)&quot;</span>
<span class="lineno"> 1266 </span><span class="spaces">    </span><span class="istickedoff">ValidProof _ thm -&gt; SV.recordTheoremProof <span class="nottickedoff">thm</span></span>
<span class="lineno"> 1267 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1268 </span><span class="spaces">  </span><span class="istickedoff">return res</span></span>
<span class="lineno"> 1269 </span>
<span class="lineno"> 1270 </span>proveHelper ::
<span class="lineno"> 1271 </span>  String -&gt;
<span class="lineno"> 1272 </span>  ProofScript () -&gt;
<span class="lineno"> 1273 </span>  Term -&gt;
<span class="lineno"> 1274 </span>  (Term -&gt; TopLevel Prop) -&gt;
<span class="lineno"> 1275 </span>  TopLevel Theorem
<span class="lineno"> 1276 </span><span class="decl"><span class="istickedoff">proveHelper nm script t f = do</span>
<span class="lineno"> 1277 </span><span class="spaces">  </span><span class="istickedoff">prop &lt;- f t</span>
<span class="lineno"> 1278 </span><span class="spaces">  </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 1279 </span><span class="spaces">  </span><span class="istickedoff">let goal = ProofGoal</span>
<span class="lineno"> 1280 </span><span class="spaces">             </span><span class="istickedoff">{ goalNum = 0</span>
<span class="lineno"> 1281 </span><span class="spaces">             </span><span class="istickedoff">, goalType = &quot;prove&quot;</span>
<span class="lineno"> 1282 </span><span class="spaces">             </span><span class="istickedoff">, goalName = nm</span>
<span class="lineno"> 1283 </span><span class="spaces">             </span><span class="istickedoff">, goalLoc  = show pos</span>
<span class="lineno"> 1284 </span><span class="spaces">             </span><span class="istickedoff">, goalDesc = &quot;&quot;</span>
<span class="lineno"> 1285 </span><span class="spaces">             </span><span class="istickedoff">, goalSequent = propToSequent prop</span>
<span class="lineno"> 1286 </span><span class="spaces">             </span><span class="istickedoff">, goalTags = mempty</span>
<span class="lineno"> 1287 </span><span class="spaces">             </span><span class="istickedoff">}</span>
<span class="lineno"> 1288 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1289 </span><span class="spaces">  </span><span class="istickedoff">res &lt;- SV.runProofScript script prop goal <span class="nottickedoff">Nothing</span> <span class="nottickedoff">(Text.pack nm)</span> True False</span>
<span class="lineno"> 1290 </span><span class="spaces">  </span><span class="istickedoff">let failProof pst =</span>
<span class="lineno"> 1291 </span><span class="spaces">         </span><span class="istickedoff">fail $ &quot;prove: &quot; ++ show (length (psGoals pst)) ++ &quot; unsolved subgoal(s)\n&quot;</span>
<span class="lineno"> 1292 </span><span class="spaces">                          </span><span class="istickedoff">++ SV.showsProofResult opts res &quot;&quot;</span>
<span class="lineno"> 1293 </span><span class="spaces">  </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1294 </span><span class="spaces">    </span><span class="istickedoff">ValidProof _stats thm -&gt;</span>
<span class="lineno"> 1295 </span><span class="spaces">      </span><span class="istickedoff">do printOutLnTop Debug $ <span class="nottickedoff">&quot;Valid: &quot; ++ show (ppTerm opts t)</span></span>
<span class="lineno"> 1296 </span><span class="spaces">         </span><span class="istickedoff">SV.returnTheoremProof thm</span>
<span class="lineno"> 1297 </span><span class="spaces">    </span><span class="istickedoff">InvalidProof _stats _cex pst -&gt; failProof pst</span>
<span class="lineno"> 1298 </span><span class="spaces">    </span><span class="istickedoff">UnfinishedProof pst -&gt; failProof pst</span></span>
<span class="lineno"> 1299 </span>
<span class="lineno"> 1300 </span>-- | See the inline help for 'prove_by_bv_induction' in the interpreter
<span class="lineno"> 1301 </span>--   for a description of what this is doing.
<span class="lineno"> 1302 </span>proveByBVInduction ::
<span class="lineno"> 1303 </span>  ProofScript () -&gt;
<span class="lineno"> 1304 </span>  TypedTerm -&gt;
<span class="lineno"> 1305 </span>  TopLevel Theorem
<span class="lineno"> 1306 </span><span class="decl"><span class="nottickedoff">proveByBVInduction script t =</span>
<span class="lineno"> 1307 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1308 </span><span class="spaces">     </span><span class="nottickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1309 </span><span class="spaces">     </span><span class="nottickedoff">ty &lt;- io $ scTypeCheckError sc (ttTerm t)</span>
<span class="lineno"> 1310 </span><span class="spaces">     </span><span class="nottickedoff">io (checkInductionScheme sc opts [] ty) &gt;&gt;= \case</span>
<span class="lineno"> 1311 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; badTy opts ty</span>
<span class="lineno"> 1312 </span><span class="spaces">       </span><span class="nottickedoff">Just ([],_) -&gt; badTy opts ty</span>
<span class="lineno"> 1313 </span><span class="spaces">       </span><span class="nottickedoff">Just (pis,w) -&gt;</span>
<span class="lineno"> 1314 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1315 </span><span class="spaces">         </span><span class="nottickedoff">-- This is a whole bunch of gross SAWCore manipulation to build a custom</span>
<span class="lineno"> 1316 </span><span class="spaces">         </span><span class="nottickedoff">-- induction principle for the user-given theorem statement.</span>
<span class="lineno"> 1317 </span><span class="spaces">         </span><span class="nottickedoff">-- I don't know offhand of a less gross way to do this.</span>
<span class="lineno"> 1318 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1319 </span><span class="spaces">         </span><span class="nottickedoff">-- The basic pattern closely follows the definition of BV_complete_induction</span>
<span class="lineno"> 1320 </span><span class="spaces">         </span><span class="nottickedoff">-- from the SAWCore prelude. Here, we reproduce the statement of the corresponding</span>
<span class="lineno"> 1321 </span><span class="spaces">         </span><span class="nottickedoff">-- parts of BV_complete_induction to give a sense of what term we intend to produce</span>
<span class="lineno"> 1322 </span><span class="spaces">         </span><span class="nottickedoff">-- in each of the following sub-parts.</span>
<span class="lineno"> 1323 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1324 </span><span class="spaces">         </span><span class="nottickedoff">do wt  &lt;- io $ scNat sc w</span>
<span class="lineno"> 1325 </span><span class="spaces">            </span><span class="nottickedoff">natty &lt;- io $ scNatType sc</span>
<span class="lineno"> 1326 </span><span class="spaces">            </span><span class="nottickedoff">toNat &lt;- io $ scGlobalDef sc &quot;Prelude.bvToNat&quot;</span>
<span class="lineno"> 1327 </span><span class="spaces">            </span><span class="nottickedoff">vars  &lt;- io $ mapM (scVariable sc) pis</span>
<span class="lineno"> 1328 </span><span class="spaces">            </span><span class="nottickedoff">innerVars &lt;-</span>
<span class="lineno"> 1329 </span><span class="spaces">              </span><span class="nottickedoff">io $ sequence $</span>
<span class="lineno"> 1330 </span><span class="spaces">              </span><span class="nottickedoff">[ scFreshVariable sc (&quot;i_&quot; &lt;&gt; ecShortName ec) (ecType ec) | ec &lt;- pis ]</span>
<span class="lineno"> 1331 </span><span class="spaces">            </span><span class="nottickedoff">t1    &lt;- io $ scApplyAllBeta sc (ttTerm t) vars</span>
<span class="lineno"> 1332 </span><span class="spaces">            </span><span class="nottickedoff">tsz   &lt;- io $ scTupleSelector sc t1 1 2 -- left element</span>
<span class="lineno"> 1333 </span><span class="spaces">            </span><span class="nottickedoff">tbody &lt;- io $ scEqTrue sc =&lt;&lt; scTupleSelector sc t1 2 2 -- rightmost tuple element</span>
<span class="lineno"> 1334 </span><span class="spaces">            </span><span class="nottickedoff">inner_t1 &lt;- io $ scApplyAllBeta sc (ttTerm t) innerVars</span>
<span class="lineno"> 1335 </span><span class="spaces">            </span><span class="nottickedoff">innersz  &lt;- io $ scTupleSelector sc inner_t1 1 2 -- left element</span>
<span class="lineno"> 1336 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1337 </span><span class="spaces">            </span><span class="nottickedoff">-- The result type of the theorem.</span>
<span class="lineno"> 1338 </span><span class="spaces">            </span><span class="nottickedoff">--</span>
<span class="lineno"> 1339 </span><span class="spaces">            </span><span class="nottickedoff">--   (x : Vec w Bool) -&gt; p x</span>
<span class="lineno"> 1340 </span><span class="spaces">            </span><span class="nottickedoff">thmResult &lt;- io $</span>
<span class="lineno"> 1341 </span><span class="spaces">                </span><span class="nottickedoff">do t3   &lt;- scGeneralizeExts sc pis tbody</span>
<span class="lineno"> 1342 </span><span class="spaces">                   </span><span class="nottickedoff">_    &lt;- scTypeCheckError sc t3 -- sanity check</span>
<span class="lineno"> 1343 </span><span class="spaces">                   </span><span class="nottickedoff">return t3</span>
<span class="lineno"> 1344 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1345 </span><span class="spaces">            </span><span class="nottickedoff">-- The type of the main hypothesis to the induction scheme. This is what</span>
<span class="lineno"> 1346 </span><span class="spaces">            </span><span class="nottickedoff">-- the user will ultimately be asked to prove. Note that this includes</span>
<span class="lineno"> 1347 </span><span class="spaces">            </span><span class="nottickedoff">-- the induction hypothesis.</span>
<span class="lineno"> 1348 </span><span class="spaces">            </span><span class="nottickedoff">--</span>
<span class="lineno"> 1349 </span><span class="spaces">            </span><span class="nottickedoff">--   ((x : Vec w Bool) -&gt; ((y: Vec w Bool) -&gt; is_bvult w y x -&gt; p y) -&gt; p x)</span>
<span class="lineno"> 1350 </span><span class="spaces">            </span><span class="nottickedoff">thmHyp &lt;- io $</span>
<span class="lineno"> 1351 </span><span class="spaces">                </span><span class="nottickedoff">do bvult &lt;- scGlobalDef sc &quot;Prelude.bvult&quot;</span>
<span class="lineno"> 1352 </span><span class="spaces">                   </span><span class="nottickedoff">islt  &lt;- scEqTrue sc =&lt;&lt; scApplyAll sc bvult [wt, innersz, tsz]</span>
<span class="lineno"> 1353 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1354 </span><span class="spaces">                   </span><span class="nottickedoff">tinner &lt;- scFun sc islt tbody</span>
<span class="lineno"> 1355 </span><span class="spaces">                   </span><span class="nottickedoff">thyp   &lt;- scGeneralizeTerms sc innerVars tinner</span>
<span class="lineno"> 1356 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1357 </span><span class="spaces">                   </span><span class="nottickedoff">touter &lt;- scFun sc thyp tbody</span>
<span class="lineno"> 1358 </span><span class="spaces">                   </span><span class="nottickedoff">scGeneralizeExts sc pis touter</span>
<span class="lineno"> 1359 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1360 </span><span class="spaces">            </span><span class="nottickedoff">-- The &quot;motive&quot; we will pass to the 'Nat_complete_induction' principle.</span>
<span class="lineno"> 1361 </span><span class="spaces">            </span><span class="nottickedoff">--</span>
<span class="lineno"> 1362 </span><span class="spaces">            </span><span class="nottickedoff">--      (\ (n:Nat) -&gt; (x:Vec w Bool) -&gt; IsLeNat (bvToNat w x) n -&gt; p x)</span>
<span class="lineno"> 1363 </span><span class="spaces">            </span><span class="nottickedoff">indMotive &lt;- io $</span>
<span class="lineno"> 1364 </span><span class="spaces">                </span><span class="nottickedoff">do indVar &lt;- scFreshVariable sc &quot;inductionVar&quot; natty</span>
<span class="lineno"> 1365 </span><span class="spaces">                   </span><span class="nottickedoff">tsz'   &lt;- scApplyAll sc toNat [wt, tsz]</span>
<span class="lineno"> 1366 </span><span class="spaces">                   </span><span class="nottickedoff">teq    &lt;- scGlobalApply sc &quot;Prelude.IsLeNat&quot; [tsz', indVar]</span>
<span class="lineno"> 1367 </span><span class="spaces">                   </span><span class="nottickedoff">t2     &lt;- scFun sc teq tbody</span>
<span class="lineno"> 1368 </span><span class="spaces">                   </span><span class="nottickedoff">t3     &lt;- scGeneralizeTerms sc vars t2</span>
<span class="lineno"> 1369 </span><span class="spaces">                   </span><span class="nottickedoff">scAbstractTerms sc [indVar] t3</span>
<span class="lineno"> 1370 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1371 </span><span class="spaces">            </span><span class="nottickedoff">-- This is the most complicated part of building the induction schema. Here we provide</span>
<span class="lineno"> 1372 </span><span class="spaces">            </span><span class="nottickedoff">-- the proof term required by 'Nat_complete_induction' that shows how to reduce our</span>
<span class="lineno"> 1373 </span><span class="spaces">            </span><span class="nottickedoff">-- current specific case to induction on natural numbers.</span>
<span class="lineno"> 1374 </span><span class="spaces">            </span><span class="nottickedoff">--</span>
<span class="lineno"> 1375 </span><span class="spaces">            </span><span class="nottickedoff">--      \ (H: (x : Vec w Bool) -&gt; ((y: Vec w Bool) -&gt; is_bvult w y x -&gt; p y) -&gt; p x)</span>
<span class="lineno"> 1376 </span><span class="spaces">            </span><span class="nottickedoff">--      \ (n:Nat) -&gt;</span>
<span class="lineno"> 1377 </span><span class="spaces">            </span><span class="nottickedoff">--      \ (Hind : (m : Nat) -&gt; (Hm : IsLtNat m n) -&gt; (y : Vec w Bool) -&gt;</span>
<span class="lineno"> 1378 </span><span class="spaces">            </span><span class="nottickedoff">--                (Hy : IsLeNat (bvToNat w y) m) -&gt; p y) -&gt;</span>
<span class="lineno"> 1379 </span><span class="spaces">            </span><span class="nottickedoff">--      \ (x : Vec w Bool) -&gt;</span>
<span class="lineno"> 1380 </span><span class="spaces">            </span><span class="nottickedoff">--      \ (Hx : IsLeNat (bvToNat w x) n) -&gt;</span>
<span class="lineno"> 1381 </span><span class="spaces">            </span><span class="nottickedoff">--        H x (\ (y:Vec w Bool) -&gt; \ (Hult : is_bvult w y x) -&gt;</span>
<span class="lineno"> 1382 </span><span class="spaces">            </span><span class="nottickedoff">--               Hind (bvToNat w y)</span>
<span class="lineno"> 1383 </span><span class="spaces">            </span><span class="nottickedoff">--                 (IsLeNat_transitive (Succ (bvToNat w y)) (bvToNat w x) n (bvultToIsLtNat w y x Hult) Hx)</span>
<span class="lineno"> 1384 </span><span class="spaces">            </span><span class="nottickedoff">--                 y (IsLeNat_base (bvToNat w y)))</span>
<span class="lineno"> 1385 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1386 </span><span class="spaces">            </span><span class="nottickedoff">indHypProof &lt;- io $</span>
<span class="lineno"> 1387 </span><span class="spaces">                </span><span class="nottickedoff">do hVar    &lt;- scFreshVariable sc &quot;H&quot; thmHyp</span>
<span class="lineno"> 1388 </span><span class="spaces">                   </span><span class="nottickedoff">nVar    &lt;- scFreshVariable sc &quot;n&quot; natty</span>
<span class="lineno"> 1389 </span><span class="spaces">                   </span><span class="nottickedoff">hindVar &lt;- scFreshVariable sc &quot;Hind&quot; =&lt;&lt;</span>
<span class="lineno"> 1390 </span><span class="spaces">                                </span><span class="nottickedoff">do m &lt;- scFreshVariable sc &quot;m&quot; natty</span>
<span class="lineno"> 1391 </span><span class="spaces">                                   </span><span class="nottickedoff">lt &lt;- scGlobalApply sc &quot;Prelude.IsLtNat&quot; [m, nVar]</span>
<span class="lineno"> 1392 </span><span class="spaces">                                   </span><span class="nottickedoff">scGeneralizeTerms sc [m] =&lt;&lt; scFun sc lt =&lt;&lt; scApplyBeta sc indMotive m</span>
<span class="lineno"> 1393 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1394 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1395 </span><span class="spaces">                   </span><span class="nottickedoff">let outersz = tsz</span>
<span class="lineno"> 1396 </span><span class="spaces">                   </span><span class="nottickedoff">natoutersz &lt;- scApplyAll sc toNat [wt, outersz]</span>
<span class="lineno"> 1397 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1398 </span><span class="spaces">                   </span><span class="nottickedoff">natinnersz &lt;- scApplyAll sc toNat [wt, innersz]</span>
<span class="lineno"> 1399 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1400 </span><span class="spaces">                   </span><span class="nottickedoff">succinnersz &lt;- scGlobalApply sc &quot;Prelude.Succ&quot; [natinnersz]</span>
<span class="lineno"> 1401 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1402 </span><span class="spaces">                   </span><span class="nottickedoff">bvltVar &lt;- scFreshVariable sc &quot;Hult&quot; =&lt;&lt; scEqTrue sc =&lt;&lt; scBvULt sc wt innersz outersz</span>
<span class="lineno"> 1403 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1404 </span><span class="spaces">                   </span><span class="nottickedoff">leVar   &lt;- scFreshVariable sc &quot;Hle&quot; =&lt;&lt;</span>
<span class="lineno"> 1405 </span><span class="spaces">                                 </span><span class="nottickedoff">scGlobalApply sc &quot;Prelude.IsLeNat&quot; [natoutersz, nVar]</span>
<span class="lineno"> 1406 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1407 </span><span class="spaces">                   </span><span class="nottickedoff">refl_inner &lt;- scGlobalApply sc &quot;Prelude.IsLeNat_base&quot; [natinnersz]</span>
<span class="lineno"> 1408 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1409 </span><span class="spaces">                   </span><span class="nottickedoff">prf     &lt;- do hyx &lt;- scGlobalApply sc &quot;Prelude.bvultToIsLtNat&quot; [wt,innersz,outersz,bvltVar]</span>
<span class="lineno"> 1410 </span><span class="spaces">                                 </span><span class="nottickedoff">scGlobalApply sc &quot;Prelude.IsLeNat_transitive&quot; [succinnersz, natoutersz, nVar, hyx, leVar]</span>
<span class="lineno"> 1411 </span><span class="spaces">                   </span><span class="nottickedoff">inner   &lt;- do body &lt;- scApplyAll sc hindVar ([natinnersz,prf]++innerVars++[refl_inner])</span>
<span class="lineno"> 1412 </span><span class="spaces">                                 </span><span class="nottickedoff">scAbstractTerms sc (innerVars ++ [bvltVar]) body</span>
<span class="lineno"> 1413 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1414 </span><span class="spaces">                   </span><span class="nottickedoff">body &lt;- scApplyAll sc hVar (vars ++ [inner])</span>
<span class="lineno"> 1415 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1416 </span><span class="spaces">                   </span><span class="nottickedoff">scAbstractTerms sc ([hVar, nVar, hindVar] ++ vars ++ [leVar]) body</span>
<span class="lineno"> 1417 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1418 </span><span class="spaces">            </span><span class="nottickedoff">-- Now we put all the pieces together</span>
<span class="lineno"> 1419 </span><span class="spaces">            </span><span class="nottickedoff">--</span>
<span class="lineno"> 1420 </span><span class="spaces">            </span><span class="nottickedoff">-- \ (Hind : (x : Vec w Bool) -&gt; ((y: Vec w Bool) -&gt; is_bvult w y x -&gt; p y) -&gt; p x) -&gt;</span>
<span class="lineno"> 1421 </span><span class="spaces">            </span><span class="nottickedoff">-- \ (x : Vec x Bool) -&gt;</span>
<span class="lineno"> 1422 </span><span class="spaces">            </span><span class="nottickedoff">--    Nat_complete_induction indMotive (indHypProof Hind) (bvToNat w x) x (IsLeNat_base (bvToNat w x))</span>
<span class="lineno"> 1423 </span><span class="spaces">            </span><span class="nottickedoff">indApp &lt;- io $</span>
<span class="lineno"> 1424 </span><span class="spaces">                </span><span class="nottickedoff">do varH   &lt;- scFreshVariable sc &quot;Hind&quot; thmHyp</span>
<span class="lineno"> 1425 </span><span class="spaces">                   </span><span class="nottickedoff">tsz'   &lt;- scApplyAll sc toNat [wt, tsz]</span>
<span class="lineno"> 1426 </span><span class="spaces">                   </span><span class="nottickedoff">trefl  &lt;- scGlobalApply sc &quot;Prelude.IsLeNat_base&quot; [tsz']</span>
<span class="lineno"> 1427 </span><span class="spaces">                   </span><span class="nottickedoff">indHypArg &lt;- scApplyBeta sc indHypProof varH</span>
<span class="lineno"> 1428 </span><span class="spaces">                   </span><span class="nottickedoff">ind    &lt;- scGlobalApply sc &quot;Prelude.Nat_complete_induction&quot; ([indMotive,indHypArg,tsz'] ++ vars ++ [trefl])</span>
<span class="lineno"> 1429 </span><span class="spaces">                   </span><span class="nottickedoff">ind''  &lt;- scAbstractTerms sc (varH : vars) ind</span>
<span class="lineno"> 1430 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1431 </span><span class="spaces">                   </span><span class="nottickedoff">_tp    &lt;- scTypeCheckError sc ind'' -- sanity check</span>
<span class="lineno"> 1432 </span><span class="spaces">                   </span><span class="nottickedoff">return ind''</span>
<span class="lineno"> 1433 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1434 </span><span class="spaces">            </span><span class="nottickedoff">indAppTT &lt;- io $ mkTypedTerm sc indApp</span>
<span class="lineno"> 1435 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1436 </span><span class="spaces">            </span><span class="nottickedoff">-- First produce a theorem value for our custom induction schemd by providing the</span>
<span class="lineno"> 1437 </span><span class="spaces">            </span><span class="nottickedoff">-- above as direct proof term.</span>
<span class="lineno"> 1438 </span><span class="spaces">            </span><span class="nottickedoff">ind_scheme_goal &lt;- io $ scFun sc thmHyp thmResult</span>
<span class="lineno"> 1439 </span><span class="spaces">            </span><span class="nottickedoff">ind_scheme_theorem &lt;- proveHelper &quot;bv_induction_scheme&quot; (goal_exact indAppTT) ind_scheme_goal (io . termToProp sc)</span>
<span class="lineno"> 1440 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1441 </span><span class="spaces">            </span><span class="nottickedoff">-- Now, set up a proof to actually prove the statement of interest by first immediately applying</span>
<span class="lineno"> 1442 </span><span class="spaces">            </span><span class="nottickedoff">-- our constructed induction schema, and then using the user-provided proof script.</span>
<span class="lineno"> 1443 </span><span class="spaces">            </span><span class="nottickedoff">let script' = goal_apply ind_scheme_theorem &gt;&gt; script</span>
<span class="lineno"> 1444 </span><span class="spaces">            </span><span class="nottickedoff">proveHelper &quot;prove_by_bv_induction&quot; script' thmResult (io . termToProp sc)</span>
<span class="lineno"> 1445 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1446 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno"> 1447 </span><span class="spaces">  </span><span class="nottickedoff">-- Here, we expect to see a collection of lambda bound terms, followed</span>
<span class="lineno"> 1448 </span><span class="spaces">  </span><span class="nottickedoff">-- by a tuple.  The first component must be a bitvector value, defining</span>
<span class="lineno"> 1449 </span><span class="spaces">  </span><span class="nottickedoff">-- the value we are performing induction on.  The second component is</span>
<span class="lineno"> 1450 </span><span class="spaces">  </span><span class="nottickedoff">-- a boolean value defining the proposition we are attempting to prove.</span>
<span class="lineno"> 1451 </span><span class="spaces">  </span><span class="nottickedoff">--</span>
<span class="lineno"> 1452 </span><span class="spaces">  </span><span class="nottickedoff">-- Return a list of the names and types of the lambda-bound variables,</span>
<span class="lineno"> 1453 </span><span class="spaces">  </span><span class="nottickedoff">-- and the width of the bitvector we are doing induction on.</span>
<span class="lineno"> 1454 </span><span class="spaces">  </span><span class="nottickedoff">checkInductionScheme sc opts pis ty =</span>
<span class="lineno"> 1455 </span><span class="spaces">    </span><span class="nottickedoff">do ty' &lt;- scWhnf sc ty</span>
<span class="lineno"> 1456 </span><span class="spaces">       </span><span class="nottickedoff">scAsPi sc ty' &gt;&gt;= \case</span>
<span class="lineno"> 1457 </span><span class="spaces">         </span><span class="nottickedoff">Just (ec, body) -&gt; checkInductionScheme sc opts (ec : pis) body</span>
<span class="lineno"> 1458 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 1459 </span><span class="spaces">           </span><span class="nottickedoff">case asTupleType ty' of</span>
<span class="lineno"> 1460 </span><span class="spaces">             </span><span class="nottickedoff">Just [bv, bool] -&gt;</span>
<span class="lineno"> 1461 </span><span class="spaces">               </span><span class="nottickedoff">do bool' &lt;- scWhnf sc bool</span>
<span class="lineno"> 1462 </span><span class="spaces">                  </span><span class="nottickedoff">bv'   &lt;- scWhnf sc bv</span>
<span class="lineno"> 1463 </span><span class="spaces">                  </span><span class="nottickedoff">case (asVectorType bv', asBoolType bool') of</span>
<span class="lineno"> 1464 </span><span class="spaces">                    </span><span class="nottickedoff">(Just (w,vbool), Just ()) -&gt;</span>
<span class="lineno"> 1465 </span><span class="spaces">                      </span><span class="nottickedoff">do w' &lt;- scWhnf sc w</span>
<span class="lineno"> 1466 </span><span class="spaces">                         </span><span class="nottickedoff">vbool' &lt;- scWhnf sc vbool</span>
<span class="lineno"> 1467 </span><span class="spaces">                         </span><span class="nottickedoff">case (asNat w', asBoolType vbool') of</span>
<span class="lineno"> 1468 </span><span class="spaces">                           </span><span class="nottickedoff">(Just n, Just ()) -&gt; return (Just (reverse pis, n))</span>
<span class="lineno"> 1469 </span><span class="spaces">                           </span><span class="nottickedoff">_ -&gt; return Nothing</span>
<span class="lineno"> 1470 </span><span class="spaces">                    </span><span class="nottickedoff">_ -&gt; return Nothing</span>
<span class="lineno"> 1471 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; return Nothing</span>
<span class="lineno"> 1472 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1473 </span><span class="spaces">  </span><span class="nottickedoff">badTy opts ty =</span>
<span class="lineno"> 1474 </span><span class="spaces">    </span><span class="nottickedoff">fail $ unlines [ &quot;Incorrect type for proof by induction!&quot;</span>
<span class="lineno"> 1475 </span><span class="spaces">                   </span><span class="nottickedoff">, &quot;Run `:help prove_by_bv_induction` to see a description of what is expected.&quot;</span>
<span class="lineno"> 1476 </span><span class="spaces">                   </span><span class="nottickedoff">, show (ppTerm opts ty)</span>
<span class="lineno"> 1477 </span><span class="spaces">                   </span><span class="nottickedoff">]</span></span>
<span class="lineno"> 1478 </span>
<span class="lineno"> 1479 </span>provePrintPrim ::
<span class="lineno"> 1480 </span>  ProofScript () -&gt;
<span class="lineno"> 1481 </span>  TypedTerm -&gt;
<span class="lineno"> 1482 </span>  TopLevel Theorem
<span class="lineno"> 1483 </span><span class="decl"><span class="istickedoff">provePrintPrim script t = do</span>
<span class="lineno"> 1484 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1485 </span><span class="spaces">  </span><span class="istickedoff">proveHelper &quot;prove_print&quot; script (ttTerm t) $ io . predicateToProp sc Universal</span></span>
<span class="lineno"> 1486 </span>
<span class="lineno"> 1487 </span>provePropPrim ::
<span class="lineno"> 1488 </span>  ProofScript () -&gt;
<span class="lineno"> 1489 </span>  TypedTerm -&gt;
<span class="lineno"> 1490 </span>  TopLevel Theorem
<span class="lineno"> 1491 </span><span class="decl"><span class="istickedoff">provePropPrim script t = do</span>
<span class="lineno"> 1492 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1493 </span><span class="spaces">  </span><span class="istickedoff">proveHelper &quot;prove_extcore&quot; script (ttTerm t) $ io . termToProp sc</span></span>
<span class="lineno"> 1494 </span>
<span class="lineno"> 1495 </span>satPrim ::
<span class="lineno"> 1496 </span>  ProofScript () -&gt;
<span class="lineno"> 1497 </span>  TypedTerm -&gt;
<span class="lineno"> 1498 </span>  TopLevel SV.SatResult
<span class="lineno"> 1499 </span><span class="decl"><span class="istickedoff">satPrim script t =</span>
<span class="lineno"> 1500 </span><span class="spaces">  </span><span class="istickedoff">do io $ checkBooleanSchema (ttType t)</span>
<span class="lineno"> 1501 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1502 </span><span class="spaces">     </span><span class="istickedoff">prop &lt;- io $ predicateToProp sc Existential (ttTerm t)</span>
<span class="lineno"> 1503 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 1504 </span><span class="spaces">     </span><span class="istickedoff">let goal = ProofGoal</span>
<span class="lineno"> 1505 </span><span class="spaces">                </span><span class="istickedoff">{ goalNum = <span class="nottickedoff">0</span></span>
<span class="lineno"> 1506 </span><span class="spaces">                </span><span class="istickedoff">, goalType = <span class="nottickedoff">&quot;sat&quot;</span></span>
<span class="lineno"> 1507 </span><span class="spaces">                </span><span class="istickedoff">, goalName = <span class="nottickedoff">&quot;sat&quot;</span></span>
<span class="lineno"> 1508 </span><span class="spaces">                </span><span class="istickedoff">, goalLoc  = <span class="nottickedoff">show pos</span></span>
<span class="lineno"> 1509 </span><span class="spaces">                </span><span class="istickedoff">, goalDesc = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 1510 </span><span class="spaces">                </span><span class="istickedoff">, goalSequent = propToSequent prop</span>
<span class="lineno"> 1511 </span><span class="spaces">                </span><span class="istickedoff">, goalTags = <span class="nottickedoff">mempty</span></span>
<span class="lineno"> 1512 </span><span class="spaces">                </span><span class="istickedoff">}</span>
<span class="lineno"> 1513 </span><span class="spaces">     </span><span class="istickedoff">res &lt;- SV.runProofScript script prop goal <span class="nottickedoff">Nothing</span> <span class="nottickedoff">&quot;sat&quot;</span> <span class="nottickedoff">False</span> False</span>
<span class="lineno"> 1514 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1515 </span><span class="spaces">       </span><span class="istickedoff">InvalidProof stats cex _ -&gt; return (SV.Sat <span class="nottickedoff">stats</span> cex)</span>
<span class="lineno"> 1516 </span><span class="spaces">       </span><span class="istickedoff">ValidProof stats _thm -&gt; return (SV.Unsat <span class="nottickedoff">stats</span>)</span>
<span class="lineno"> 1517 </span><span class="spaces">       </span><span class="istickedoff">UnfinishedProof _ -&gt; <span class="nottickedoff">return SV.SatUnknown</span></span></span>
<span class="lineno"> 1518 </span>
<span class="lineno"> 1519 </span>satPrintPrim ::
<span class="lineno"> 1520 </span>  ProofScript () -&gt;
<span class="lineno"> 1521 </span>  TypedTerm -&gt;
<span class="lineno"> 1522 </span>  TopLevel ()
<span class="lineno"> 1523 </span><span class="decl"><span class="istickedoff">satPrintPrim script t = do</span>
<span class="lineno"> 1524 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- satPrim script t</span>
<span class="lineno"> 1525 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1526 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info (SV.showsSatResult opts result &quot;&quot;)</span></span>
<span class="lineno"> 1527 </span>
<span class="lineno"> 1528 </span>-- | Quick check (random test) a term and print the result. The
<span class="lineno"> 1529 </span>-- 'Integer' parameter is the number of random tests to run.
<span class="lineno"> 1530 </span>quickCheckPrintPrim :: SharedContext -&gt; Options -&gt; Integer -&gt; TypedTerm -&gt; IO ()
<span class="lineno"> 1531 </span><span class="decl"><span class="nottickedoff">quickCheckPrintPrim sc opts numTests tt =</span>
<span class="lineno"> 1532 </span><span class="spaces">  </span><span class="nottickedoff">do prop &lt;- predicateToProp sc Universal (ttTerm tt)</span>
<span class="lineno"> 1533 </span><span class="spaces">     </span><span class="nottickedoff">satq &lt;- propToSATQuery sc mempty prop</span>
<span class="lineno"> 1534 </span><span class="spaces">     </span><span class="nottickedoff">testGen &lt;- prepareSATQuery sc satq</span>
<span class="lineno"> 1535 </span><span class="spaces">     </span><span class="nottickedoff">runManyTests testGen numTests &gt;&gt;= \case</span>
<span class="lineno"> 1536 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; printOutLn opts Info $ &quot;All &quot; ++ show numTests ++ &quot; tests passed!&quot;</span>
<span class="lineno"> 1537 </span><span class="spaces">        </span><span class="nottickedoff">Just cex -&gt;</span>
<span class="lineno"> 1538 </span><span class="spaces">          </span><span class="nottickedoff">do let cex' = [ (Text.unpack (ecShortName ec), v) | (ec,v) &lt;- cex ]</span>
<span class="lineno"> 1539 </span><span class="spaces">             </span><span class="nottickedoff">printOutLn opts OnlyCounterExamples $</span>
<span class="lineno"> 1540 </span><span class="spaces">               </span><span class="nottickedoff">&quot;----------Counterexample----------\n&quot; ++</span>
<span class="lineno"> 1541 </span><span class="spaces">               </span><span class="nottickedoff">showList cex' &quot;&quot;</span></span>
<span class="lineno"> 1542 </span>
<span class="lineno"> 1543 </span>cryptolSimpset :: TopLevel SV.SAWSimpset
<span class="lineno"> 1544 </span><span class="decl"><span class="istickedoff">cryptolSimpset =</span>
<span class="lineno"> 1545 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1546 </span><span class="spaces">     </span><span class="istickedoff">io $ Cryptol.mkCryptolSimpset sc</span></span>
<span class="lineno"> 1547 </span>
<span class="lineno"> 1548 </span>addPreludeEqs :: [Text] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1549 </span><span class="decl"><span class="istickedoff">addPreludeEqs names ss = do</span>
<span class="lineno"> 1550 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1551 </span><span class="spaces">  </span><span class="istickedoff">eqRules &lt;- io $ mapM (scEqRewriteRule sc) (map qualify names)</span>
<span class="lineno"> 1552 </span><span class="spaces">  </span><span class="istickedoff">return (addRules eqRules ss)</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">where qualify = mkIdent (mkModuleName [&quot;Prelude&quot;])</span></span>
<span class="lineno"> 1554 </span>
<span class="lineno"> 1555 </span>addCryptolEqs :: [Text] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1556 </span><span class="decl"><span class="nottickedoff">addCryptolEqs names ss = do</span>
<span class="lineno"> 1557 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1558 </span><span class="spaces">  </span><span class="nottickedoff">eqRules &lt;- io $ mapM (scEqRewriteRule sc) (map qualify names)</span>
<span class="lineno"> 1559 </span><span class="spaces">  </span><span class="nottickedoff">return (addRules eqRules ss)</span>
<span class="lineno"> 1560 </span><span class="spaces">    </span><span class="nottickedoff">where qualify = mkIdent (mkModuleName [&quot;Cryptol&quot;])</span></span>
<span class="lineno"> 1561 </span>
<span class="lineno"> 1562 </span>add_core_defs :: Text -&gt; [Text] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1563 </span><span class="decl"><span class="istickedoff">add_core_defs modname names ss =</span>
<span class="lineno"> 1564 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1565 </span><span class="spaces">     </span><span class="istickedoff">defs &lt;- io $ mapM (getDef sc) names -- FIXME: warn if not found</span>
<span class="lineno"> 1566 </span><span class="spaces">     </span><span class="istickedoff">defRules &lt;- io $ concat &lt;$&gt; (mapM (scDefRewriteRules sc) defs)</span>
<span class="lineno"> 1567 </span><span class="spaces">     </span><span class="istickedoff">return (addRules defRules ss)</span>
<span class="lineno"> 1568 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1569 </span><span class="spaces">    </span><span class="istickedoff">qualify = mkIdent (mkModuleName [modname])</span>
<span class="lineno"> 1570 </span><span class="spaces">    </span><span class="istickedoff">getDef sc n =</span>
<span class="lineno"> 1571 </span><span class="spaces">      </span><span class="istickedoff">scFindDef sc (qualify n) &gt;&gt;= \maybe_def -&gt;</span>
<span class="lineno"> 1572 </span><span class="spaces">      </span><span class="istickedoff">case maybe_def of</span>
<span class="lineno"> 1573 </span><span class="spaces">        </span><span class="istickedoff">Just d -&gt; return d</span>
<span class="lineno"> 1574 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ Text.unpack $ modname &lt;&gt; &quot; definition &quot; &lt;&gt; n &lt;&gt; &quot; not found&quot;</span></span></span>
<span class="lineno"> 1575 </span>
<span class="lineno"> 1576 </span>add_prelude_defs :: [Text] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1577 </span><span class="decl"><span class="nottickedoff">add_prelude_defs = add_core_defs &quot;Prelude&quot;</span></span>
<span class="lineno"> 1578 </span>
<span class="lineno"> 1579 </span>add_cryptol_defs :: [Text] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1580 </span><span class="decl"><span class="istickedoff">add_cryptol_defs = add_core_defs &quot;Cryptol&quot;</span></span>
<span class="lineno"> 1581 </span>
<span class="lineno"> 1582 </span>rewritePrim :: SV.SAWSimpset -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1583 </span><span class="decl"><span class="istickedoff">rewritePrim ss (TypedTerm schema t) = do</span>
<span class="lineno"> 1584 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1585 </span><span class="spaces">  </span><span class="istickedoff">(_,t') &lt;- io $ rewriteSharedTerm sc ss t</span>
<span class="lineno"> 1586 </span><span class="spaces">  </span><span class="istickedoff">return (TypedTerm schema t')</span></span>
<span class="lineno"> 1587 </span>
<span class="lineno"> 1588 </span>unfold_term :: [Text] -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1589 </span><span class="decl"><span class="istickedoff">unfold_term unints (TypedTerm schema t) = do</span>
<span class="lineno"> 1590 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1591 </span><span class="spaces">  </span><span class="istickedoff">unints' &lt;- mconcat &lt;$&gt; mapM (resolveName sc) unints</span>
<span class="lineno"> 1592 </span><span class="spaces">  </span><span class="istickedoff">t' &lt;- io $ scUnfoldConstants sc unints' t</span>
<span class="lineno"> 1593 </span><span class="spaces">  </span><span class="istickedoff">return (TypedTerm schema t')</span></span>
<span class="lineno"> 1594 </span>
<span class="lineno"> 1595 </span>beta_reduce_term :: TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1596 </span><span class="decl"><span class="nottickedoff">beta_reduce_term (TypedTerm schema t) = do</span>
<span class="lineno"> 1597 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1598 </span><span class="spaces">  </span><span class="nottickedoff">t' &lt;- io $ betaNormalize sc t</span>
<span class="lineno"> 1599 </span><span class="spaces">  </span><span class="nottickedoff">return (TypedTerm schema t')</span></span>
<span class="lineno"> 1600 </span>
<span class="lineno"> 1601 </span>term_eval :: [Text] -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1602 </span><span class="decl"><span class="nottickedoff">term_eval unints (TypedTerm schema t0) =</span>
<span class="lineno"> 1603 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1604 </span><span class="spaces">     </span><span class="nottickedoff">unintSet &lt;- resolveNames unints</span>
<span class="lineno"> 1605 </span><span class="spaces">     </span><span class="nottickedoff">what4PushMuxOps &lt;- gets rwWhat4PushMuxOps</span>
<span class="lineno"> 1606 </span><span class="spaces">     </span><span class="nottickedoff">sym &lt;- liftIO $ Common.newSAWCoreExprBuilder sc what4PushMuxOps</span>
<span class="lineno"> 1607 </span><span class="spaces">     </span><span class="nottickedoff">st &lt;- liftIO $ Common.sawCoreState sym</span>
<span class="lineno"> 1608 </span><span class="spaces">     </span><span class="nottickedoff">t1 &lt;- liftIO $ W4Sim.w4EvalTerm sym st sc Map.empty unintSet t0</span>
<span class="lineno"> 1609 </span><span class="spaces">     </span><span class="nottickedoff">pure (TypedTerm schema t1)</span></span>
<span class="lineno"> 1610 </span>
<span class="lineno"> 1611 </span>addsimp :: Theorem -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1612 </span><span class="decl"><span class="istickedoff">addsimp thm ss =</span>
<span class="lineno"> 1613 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1614 </span><span class="spaces">     </span><span class="istickedoff">io (propToRewriteRule sc (thmProp thm) (Just (thmNonce thm))) &gt;&gt;= \case</span>
<span class="lineno"> 1615 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;addsimp: theorem not an equation&quot;</span></span>
<span class="lineno"> 1616 </span><span class="spaces">       </span><span class="istickedoff">Just rule -&gt; pure (addRule rule ss)</span></span>
<span class="lineno"> 1617 </span>
<span class="lineno"> 1618 </span>addsimp_shallow :: Theorem -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1619 </span><span class="decl"><span class="nottickedoff">addsimp_shallow thm ss =</span>
<span class="lineno"> 1620 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1621 </span><span class="spaces">     </span><span class="nottickedoff">io (propToRewriteRule sc (thmProp thm) (Just (thmNonce thm))) &gt;&gt;= \case</span>
<span class="lineno"> 1622 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; fail &quot;addsimp: theorem not an equation&quot;</span>
<span class="lineno"> 1623 </span><span class="spaces">       </span><span class="nottickedoff">Just rule -&gt; pure (addRule (shallowRule rule) ss)</span></span>
<span class="lineno"> 1624 </span>
<span class="lineno"> 1625 </span>-- TODO: remove this, it implicitly adds axioms
<span class="lineno"> 1626 </span>addsimp' :: Term -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1627 </span><span class="decl"><span class="nottickedoff">addsimp' t ss =</span>
<span class="lineno"> 1628 </span><span class="spaces">  </span><span class="nottickedoff">do  sc &lt;- getSharedContext</span>
<span class="lineno"> 1629 </span><span class="spaces">      </span><span class="nottickedoff">io (ruleOfProp sc t Nothing) &gt;&gt;= \case</span>
<span class="lineno"> 1630 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; fail &quot;addsimp': theorem not an equation&quot;</span>
<span class="lineno"> 1631 </span><span class="spaces">        </span><span class="nottickedoff">Just rule -&gt; pure (addRule rule ss)</span></span>
<span class="lineno"> 1632 </span>
<span class="lineno"> 1633 </span>addsimps :: [Theorem] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1634 </span><span class="decl"><span class="istickedoff">addsimps thms ss = foldM (flip addsimp) ss thms</span></span>
<span class="lineno"> 1635 </span>
<span class="lineno"> 1636 </span>addsimps' :: [Term] -&gt; SV.SAWSimpset -&gt; TopLevel SV.SAWSimpset
<span class="lineno"> 1637 </span><span class="decl"><span class="nottickedoff">addsimps' ts ss = foldM (flip addsimp') ss ts</span></span>
<span class="lineno"> 1638 </span>
<span class="lineno"> 1639 </span>print_type :: Term -&gt; TopLevel ()
<span class="lineno"> 1640 </span><span class="decl"><span class="istickedoff">print_type t = do</span>
<span class="lineno"> 1641 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1642 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1643 </span><span class="spaces">  </span><span class="istickedoff">ty &lt;- io $ scTypeOf sc t</span>
<span class="lineno"> 1644 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info (scPrettyTerm opts ty)</span></span>
<span class="lineno"> 1645 </span>
<span class="lineno"> 1646 </span>check_term :: TypedTerm -&gt; TopLevel ()
<span class="lineno"> 1647 </span><span class="decl"><span class="istickedoff">check_term tt = do</span>
<span class="lineno"> 1648 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1649 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1650 </span><span class="spaces">  </span><span class="istickedoff">cenv &lt;- rwCryptol &lt;$&gt; getTopLevelRW</span>
<span class="lineno"> 1651 </span><span class="spaces">  </span><span class="istickedoff">let t = ttTerm tt</span>
<span class="lineno"> 1652 </span><span class="spaces">  </span><span class="istickedoff">ty &lt;- io $ scTypeCheckError sc t</span>
<span class="lineno"> 1653 </span><span class="spaces">  </span><span class="istickedoff">expectedTy &lt;-</span>
<span class="lineno"> 1654 </span><span class="spaces">    </span><span class="istickedoff">case ttType tt of</span>
<span class="lineno"> 1655 </span><span class="spaces">      </span><span class="istickedoff">TypedTermSchema schema -&gt; io $ importSchemaCEnv sc cenv schema</span>
<span class="lineno"> 1656 </span><span class="spaces">      </span><span class="istickedoff">TypedTermKind k -&gt; <span class="nottickedoff">io $ Cryptol.importKind sc k</span></span>
<span class="lineno"> 1657 </span><span class="spaces">      </span><span class="istickedoff">TypedTermOther ty' -&gt; <span class="nottickedoff">pure ty'</span></span>
<span class="lineno"> 1658 </span><span class="spaces">  </span><span class="istickedoff">convertible &lt;- io $ scConvertible sc <span class="nottickedoff">True</span> ty expectedTy</span>
<span class="lineno"> 1659 </span><span class="spaces">  </span><span class="istickedoff">unless convertible $</span>
<span class="lineno"> 1660 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">panic &quot;check_term&quot;</span></span>
<span class="lineno"> 1661 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Term's actual type does not match its attached type:&quot;</span></span>
<span class="lineno"> 1662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected: &quot; &lt;&gt; Text.pack (scPrettyTerm opts expectedTy)</span></span>
<span class="lineno"> 1663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Actual: &quot; &lt;&gt; Text.pack (scPrettyTerm opts ty)</span></span>
<span class="lineno"> 1664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1665 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info (scPrettyTerm opts ty)</span></span>
<span class="lineno"> 1666 </span>
<span class="lineno"> 1667 </span>check_goal :: ProofScript ()
<span class="lineno"> 1668 </span><span class="decl"><span class="istickedoff">check_goal =</span>
<span class="lineno"> 1669 </span><span class="spaces">  </span><span class="istickedoff">do pfst &lt;- get</span>
<span class="lineno"> 1670 </span><span class="spaces">     </span><span class="istickedoff">case psGoals pfst of</span>
<span class="lineno"> 1671 </span><span class="spaces">       </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">fail &quot;ProofScript failed: no subgoal&quot;</span></span>
<span class="lineno"> 1672 </span><span class="spaces">       </span><span class="istickedoff">g : _ -&gt;</span>
<span class="lineno"> 1673 </span><span class="spaces">         </span><span class="istickedoff">SV.scriptTopLevel $</span>
<span class="lineno"> 1674 </span><span class="spaces">         </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1675 </span><span class="spaces">            </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 1676 </span><span class="spaces">            </span><span class="istickedoff">io $ checkSequent sc <span class="nottickedoff">opts</span> (goalSequent g)</span></span>
<span class="lineno"> 1677 </span>
<span class="lineno"> 1678 </span>freshSymbolicPrim :: Text -&gt; C.Schema -&gt; TopLevel TypedTerm
<span class="lineno"> 1679 </span><span class="decl"><span class="istickedoff">freshSymbolicPrim x schema@(C.Forall [] [] ct) = do</span>
<span class="lineno"> 1680 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1681 </span><span class="spaces">  </span><span class="istickedoff">cty &lt;- io $ Cryptol.importType sc <span class="nottickedoff">Cryptol.emptyEnv</span> ct</span>
<span class="lineno"> 1682 </span><span class="spaces">  </span><span class="istickedoff">tm &lt;- io $ scFreshVariable sc x cty</span>
<span class="lineno"> 1683 </span><span class="spaces">  </span><span class="istickedoff">return $ TypedTerm (TypedTermSchema schema) tm</span>
<span class="lineno"> 1684 </span><span class="spaces"></span><span class="istickedoff">freshSymbolicPrim _ _ =</span>
<span class="lineno"> 1685 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Can't create fresh symbolic variable of non-ground type.&quot;</span></span></span>
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>abstractSymbolicPrim :: TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1688 </span><span class="decl"><span class="istickedoff">abstractSymbolicPrim (TypedTerm _ t) = do</span>
<span class="lineno"> 1689 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1690 </span><span class="spaces">  </span><span class="istickedoff">io (mkTypedTerm sc =&lt;&lt; bindAllExts sc t)</span></span>
<span class="lineno"> 1691 </span>
<span class="lineno"> 1692 </span>bindAllExts :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1693 </span><span class="decl"><span class="istickedoff">bindAllExts sc body = scAbstractExts sc (getAllExts body) body</span></span>
<span class="lineno"> 1694 </span>
<span class="lineno"> 1695 </span>term_apply :: TypedTerm -&gt; [TypedTerm] -&gt; TopLevel TypedTerm
<span class="lineno"> 1696 </span><span class="decl"><span class="nottickedoff">term_apply fn args =</span>
<span class="lineno"> 1697 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1698 </span><span class="spaces">     </span><span class="nottickedoff">io $ applyTypedTerms sc fn args</span></span>
<span class="lineno"> 1699 </span>
<span class="lineno"> 1700 </span>lambda :: TypedTerm -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1701 </span><span class="decl"><span class="istickedoff">lambda x = lambdas [x]</span></span>
<span class="lineno"> 1702 </span>
<span class="lineno"> 1703 </span>lambdas :: [TypedTerm] -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1704 </span><span class="decl"><span class="istickedoff">lambdas vars tt =</span>
<span class="lineno"> 1705 </span><span class="spaces">  </span><span class="istickedoff">do tecs &lt;- traverse checkVar vars</span>
<span class="lineno"> 1706 </span><span class="spaces">     </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1707 </span><span class="spaces">     </span><span class="istickedoff">io $ abstractTypedExts sc tecs tt</span>
<span class="lineno"> 1708 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1709 </span><span class="spaces">    </span><span class="istickedoff">checkVar v =</span>
<span class="lineno"> 1710 </span><span class="spaces">      </span><span class="istickedoff">case asTypedExtCns v of</span>
<span class="lineno"> 1711 </span><span class="spaces">        </span><span class="istickedoff">Just tec -&gt; pure tec</span>
<span class="lineno"> 1712 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;lambda: argument not a valid symbolic variable&quot;</span></span></span>
<span class="lineno"> 1713 </span>
<span class="lineno"> 1714 </span>implies_term :: TypedTerm -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1715 </span><span class="decl"><span class="nottickedoff">implies_term x y =</span>
<span class="lineno"> 1716 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1717 </span><span class="spaces">     </span><span class="nottickedoff">-- check that the given terms are props</span>
<span class="lineno"> 1718 </span><span class="spaces">     </span><span class="nottickedoff">_ &lt;- io $ termToProp sc (ttTerm x)</span>
<span class="lineno"> 1719 </span><span class="spaces">     </span><span class="nottickedoff">_ &lt;- io $ termToProp sc (ttTerm y)</span>
<span class="lineno"> 1720 </span><span class="spaces">     </span><span class="nottickedoff">z &lt;- io $ scFun sc (ttTerm x) (ttTerm y)</span>
<span class="lineno"> 1721 </span><span class="spaces">     </span><span class="nottickedoff">io $ mkTypedTerm sc z</span></span>
<span class="lineno"> 1722 </span>
<span class="lineno"> 1723 </span>generalize_term :: [TypedTerm] -&gt; TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1724 </span><span class="decl"><span class="nottickedoff">generalize_term vars tt =</span>
<span class="lineno"> 1725 </span><span class="spaces">  </span><span class="nottickedoff">do tecs &lt;- traverse checkVar vars</span>
<span class="lineno"> 1726 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1727 </span><span class="spaces">     </span><span class="nottickedoff">tm &lt;- io $ scGeneralizeExts sc (map tecExt tecs) (ttTerm tt)</span>
<span class="lineno"> 1728 </span><span class="spaces">     </span><span class="nottickedoff">_tp &lt;- io $ scTypeCheckError sc tm -- sanity check the term</span>
<span class="lineno"> 1729 </span><span class="spaces">     </span><span class="nottickedoff">io $ mkTypedTerm sc tm</span>
<span class="lineno"> 1730 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1731 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1732 </span><span class="spaces">    </span><span class="nottickedoff">checkVar v =</span>
<span class="lineno"> 1733 </span><span class="spaces">      </span><span class="nottickedoff">case asTypedExtCns v of</span>
<span class="lineno"> 1734 </span><span class="spaces">        </span><span class="nottickedoff">Just tec -&gt; pure tec</span>
<span class="lineno"> 1735 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; fail &quot;generalize_term: argument not a valid symbolic variable&quot;</span></span>
<span class="lineno"> 1736 </span>
<span class="lineno"> 1737 </span>-- | Apply the given Term to the given values, and evaluate to a
<span class="lineno"> 1738 </span>-- final value.
<span class="lineno"> 1739 </span>cexEvalFn :: SharedContext -&gt; [(ExtCns Term, FirstOrderValue)] -&gt; Term
<span class="lineno"> 1740 </span>          -&gt; IO Concrete.CValue
<span class="lineno"> 1741 </span><span class="decl"><span class="nottickedoff">cexEvalFn sc args tm = do</span>
<span class="lineno"> 1742 </span><span class="spaces">  </span><span class="nottickedoff">-- NB: there may be more args than exts, and this is ok. One side of</span>
<span class="lineno"> 1743 </span><span class="spaces">  </span><span class="nottickedoff">-- an equality may have more free variables than the other,</span>
<span class="lineno"> 1744 </span><span class="spaces">  </span><span class="nottickedoff">-- particularly in the case where there is a counter-example.</span>
<span class="lineno"> 1745 </span><span class="spaces">  </span><span class="nottickedoff">let exts = map fst args</span>
<span class="lineno"> 1746 </span><span class="spaces">  </span><span class="nottickedoff">args' &lt;- mapM (scFirstOrderValue sc . snd) args</span>
<span class="lineno"> 1747 </span><span class="spaces">  </span><span class="nottickedoff">let is = map ecVarIndex exts</span>
<span class="lineno"> 1748 </span><span class="spaces">      </span><span class="nottickedoff">argMap = IntMap.fromList (zip is args')</span>
<span class="lineno"> 1749 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1750 </span><span class="spaces">  </span><span class="nottickedoff">-- TODO, instead of instantiating and then evaluating, we should</span>
<span class="lineno"> 1751 </span><span class="spaces">  </span><span class="nottickedoff">-- evaluate in the context of an EC map instead.  argMap is almost</span>
<span class="lineno"> 1752 </span><span class="spaces">  </span><span class="nottickedoff">-- what we need, but the values syould be @Concrete.CValue@ instead.</span>
<span class="lineno"> 1753 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1754 </span><span class="spaces">  </span><span class="nottickedoff">tm' &lt;- scInstantiateExt sc argMap tm</span>
<span class="lineno"> 1755 </span><span class="spaces">  </span><span class="nottickedoff">modmap &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1756 </span><span class="spaces">  </span><span class="nottickedoff">return $ Concrete.evalSharedTerm modmap mempty mempty tm'</span></span>
<span class="lineno"> 1757 </span>
<span class="lineno"> 1758 </span>envCmd :: TopLevel ()
<span class="lineno"> 1759 </span><span class="decl"><span class="nottickedoff">envCmd = do</span>
<span class="lineno"> 1760 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- SV.getMergedEnv</span>
<span class="lineno"> 1761 </span><span class="spaces">  </span><span class="nottickedoff">let avail = rwPrimsAvail rw</span>
<span class="lineno"> 1762 </span><span class="spaces">      </span><span class="nottickedoff">vals = rwValueInfo rw</span>
<span class="lineno"> 1763 </span><span class="spaces">      </span><span class="nottickedoff">keep (_x, (lc, _ty, _v)) = Set.member lc avail</span>
<span class="lineno"> 1764 </span><span class="spaces">      </span><span class="nottickedoff">vals' = filter keep $ Map.assocs vals</span>
<span class="lineno"> 1765 </span><span class="spaces">      </span><span class="nottickedoff">showLName = Text.unpack . getVal</span>
<span class="lineno"> 1766 </span><span class="spaces">      </span><span class="nottickedoff">printit (x, (_lc, ty, _v)) = showLName x ++ &quot; : &quot; ++ PPS.pShow ty</span>
<span class="lineno"> 1767 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1768 </span><span class="spaces">  </span><span class="nottickedoff">io $ sequence_ [ printOutLn opts Info (printit item) | item &lt;- vals' ]</span></span>
<span class="lineno"> 1769 </span>
<span class="lineno"> 1770 </span>exitPrim :: Integer -&gt; IO ()
<span class="lineno"> 1771 </span><span class="decl"><span class="istickedoff">exitPrim code = Exit.exitWith exitCode</span>
<span class="lineno"> 1772 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1773 </span><span class="spaces">    </span><span class="istickedoff">exitCode = if code /= 0</span>
<span class="lineno"> 1774 </span><span class="spaces">               </span><span class="istickedoff">then Exit.ExitFailure (fromInteger code)</span>
<span class="lineno"> 1775 </span><span class="spaces">               </span><span class="istickedoff">else Exit.ExitSuccess</span></span>
<span class="lineno"> 1776 </span>
<span class="lineno"> 1777 </span>-- Run the toplevel command.  Return a tuple containing
<span class="lineno"> 1778 </span>-- the elapsed time to run the command in milliseconds
<span class="lineno"> 1779 </span>-- and the value returned by the action.
<span class="lineno"> 1780 </span>withTimePrim :: TopLevel SV.Value -&gt; TopLevel SV.Value
<span class="lineno"> 1781 </span><span class="decl"><span class="nottickedoff">withTimePrim a = do</span>
<span class="lineno"> 1782 </span><span class="spaces">  </span><span class="nottickedoff">t1 &lt;- liftIO $ getCurrentTime</span>
<span class="lineno"> 1783 </span><span class="spaces">  </span><span class="nottickedoff">r &lt;- a</span>
<span class="lineno"> 1784 </span><span class="spaces">  </span><span class="nottickedoff">t2 &lt;- liftIO $ getCurrentTime</span>
<span class="lineno"> 1785 </span><span class="spaces">  </span><span class="nottickedoff">-- diffUTCTime returns a length of time measured seconds</span>
<span class="lineno"> 1786 </span><span class="spaces">  </span><span class="nottickedoff">let diff = truncate (diffUTCTime t2 t1 * 1000)</span>
<span class="lineno"> 1787 </span><span class="spaces">  </span><span class="nottickedoff">return $ SV.VTuple [ SV.VInteger diff, r ]</span></span>
<span class="lineno"> 1788 </span>
<span class="lineno"> 1789 </span>timePrim :: TopLevel SV.Value -&gt; TopLevel SV.Value
<span class="lineno"> 1790 </span><span class="decl"><span class="istickedoff">timePrim a = do</span>
<span class="lineno"> 1791 </span><span class="spaces">  </span><span class="istickedoff">t1 &lt;- liftIO $ getCurrentTime</span>
<span class="lineno"> 1792 </span><span class="spaces">  </span><span class="istickedoff">r &lt;- a</span>
<span class="lineno"> 1793 </span><span class="spaces">  </span><span class="istickedoff">t2 &lt;- liftIO $ getCurrentTime</span>
<span class="lineno"> 1794 </span><span class="spaces">  </span><span class="istickedoff">let diff = diffUTCTime t2 t1</span>
<span class="lineno"> 1795 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info $ printf &quot;Time: %s\n&quot; (show diff)</span>
<span class="lineno"> 1796 </span><span class="spaces">  </span><span class="istickedoff">return r</span></span>
<span class="lineno"> 1797 </span>
<span class="lineno"> 1798 </span>failPrim :: Text -&gt; TopLevel SV.Value
<span class="lineno"> 1799 </span><span class="decl"><span class="istickedoff">failPrim msg = fail $ Text.unpack msg</span></span>
<span class="lineno"> 1800 </span>
<span class="lineno"> 1801 </span>failsPrim :: TopLevel SV.Value -&gt; TopLevel ()
<span class="lineno"> 1802 </span><span class="decl"><span class="istickedoff">failsPrim m = do</span>
<span class="lineno"> 1803 </span><span class="spaces">  </span><span class="istickedoff">topRO &lt;- getTopLevelRO</span>
<span class="lineno"> 1804 </span><span class="spaces">  </span><span class="istickedoff">topRW &lt;- getTopLevelRW</span>
<span class="lineno"> 1805 </span><span class="spaces">  </span><span class="istickedoff">x &lt;- liftIO $ Ex.try (runTopLevel m topRO topRW)</span>
<span class="lineno"> 1806 </span><span class="spaces">  </span><span class="istickedoff">case x of</span>
<span class="lineno"> 1807 </span><span class="spaces">    </span><span class="istickedoff">Left (ex :: Ex.SomeException) -&gt;</span>
<span class="lineno"> 1808 </span><span class="spaces">      </span><span class="istickedoff">do liftIO $ TextIO.putStrLn &quot;== Anticipated failure message ==&quot;</span>
<span class="lineno"> 1809 </span><span class="spaces">         </span><span class="istickedoff">liftIO $ print ex</span>
<span class="lineno"> 1810 </span><span class="spaces">    </span><span class="istickedoff">Right _ -&gt;</span>
<span class="lineno"> 1811 </span><span class="spaces">      </span><span class="istickedoff">do liftIO $ fail &quot;Expected failure, but succeeded instead!&quot;</span></span>
<span class="lineno"> 1812 </span>
<span class="lineno"> 1813 </span>eval_bool :: TypedTerm -&gt; TopLevel Bool
<span class="lineno"> 1814 </span><span class="decl"><span class="istickedoff">eval_bool t = do</span>
<span class="lineno"> 1815 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1816 </span><span class="spaces">  </span><span class="istickedoff">case ttType t of</span>
<span class="lineno"> 1817 </span><span class="spaces">    </span><span class="istickedoff">TypedTermSchema (C.Forall [] [] (C.tIsBit -&gt; True)) -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1818 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;eval_bool: not type Bit&quot;</span></span>
<span class="lineno"> 1819 </span><span class="spaces">  </span><span class="istickedoff">unless (null (getAllExts (ttTerm t))) $</span>
<span class="lineno"> 1820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail &quot;eval_bool: term contains symbolic variables&quot;</span></span>
<span class="lineno"> 1821 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- io $ rethrowEvalError $ SV.evaluateTypedTerm sc t</span>
<span class="lineno"> 1822 </span><span class="spaces">  </span><span class="istickedoff">return (C.fromVBit v)</span></span>
<span class="lineno"> 1823 </span>
<span class="lineno"> 1824 </span>eval_int :: TypedTerm -&gt; TopLevel Integer
<span class="lineno"> 1825 </span><span class="decl"><span class="istickedoff">eval_int t = do</span>
<span class="lineno"> 1826 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1827 </span><span class="spaces">  </span><span class="istickedoff">cenv &lt;- fmap <span class="nottickedoff">rwCryptol</span> getTopLevelRW</span>
<span class="lineno"> 1828 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">cfg = CEnv.meSolverConfig (CEnv.eModuleEnv cenv)</span></span>
<span class="lineno"> 1829 </span><span class="spaces">  </span><span class="istickedoff">unless (null (getAllExts (ttTerm t))) $</span>
<span class="lineno"> 1830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail &quot;term contains symbolic variables&quot;</span></span>
<span class="lineno"> 1831 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1832 </span><span class="spaces">  </span><span class="istickedoff">t' &lt;- io $ defaultTypedTerm <span class="nottickedoff">opts</span> <span class="nottickedoff">sc</span> <span class="nottickedoff">cfg</span> t</span>
<span class="lineno"> 1833 </span><span class="spaces">  </span><span class="istickedoff">case ttType t' of</span>
<span class="lineno"> 1834 </span><span class="spaces">    </span><span class="istickedoff">TypedTermSchema (C.Forall [] [] (isInteger -&gt; True)) -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1835 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;eval_int: argument is not a finite bitvector&quot;</span></span>
<span class="lineno"> 1836 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- io $ rethrowEvalError $ SV.evaluateTypedTerm sc t'</span>
<span class="lineno"> 1837 </span><span class="spaces">  </span><span class="istickedoff">io $ C.runEval <span class="nottickedoff">mempty</span> (C.bvVal &lt;$&gt; C.fromVWord <span class="nottickedoff">C.Concrete</span> <span class="nottickedoff">&quot;eval_int&quot;</span> v)</span></span>
<span class="lineno"> 1838 </span>
<span class="lineno"> 1839 </span>-- Predicate on Cryptol types true of integer types, i.e. types
<span class="lineno"> 1840 </span>-- @[n]Bit@ for *finite* @n@.
<span class="lineno"> 1841 </span>isInteger :: C.Type -&gt; Bool
<span class="lineno"> 1842 </span><span class="decl"><span class="istickedoff">isInteger (C.tIsSeq -&gt; Just (C.tIsNum -&gt; Just _, C.tIsBit -&gt; True)) = True</span>
<span class="lineno"> 1843 </span><span class="spaces"></span><span class="istickedoff">isInteger _ = <span class="nottickedoff">False</span></span></span>
<span class="lineno"> 1844 </span>
<span class="lineno"> 1845 </span>list_term :: [TypedTerm] -&gt; TopLevel TypedTerm
<span class="lineno"> 1846 </span><span class="decl"><span class="istickedoff">list_term [] = <span class="nottickedoff">fail &quot;list_term: invalid empty list&quot;</span></span>
<span class="lineno"> 1847 </span><span class="spaces"></span><span class="istickedoff">list_term tts@(tt0 : _) =</span>
<span class="lineno"> 1848 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1849 </span><span class="spaces">     </span><span class="istickedoff">a &lt;- case ttType tt0 of</span>
<span class="lineno"> 1850 </span><span class="spaces">            </span><span class="istickedoff">TypedTermSchema (C.Forall [] [] a) -&gt; return a</span>
<span class="lineno"> 1851 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;list_term: not a monomorphic element type&quot;</span></span>
<span class="lineno"> 1852 </span><span class="spaces">     </span><span class="istickedoff">let eqa (TypedTermSchema (C.Forall [] [] x)) = a == x</span>
<span class="lineno"> 1853 </span><span class="spaces">         </span><span class="istickedoff">eqa _ = <span class="nottickedoff">False</span></span>
<span class="lineno"> 1854 </span><span class="spaces">     </span><span class="istickedoff">unless (all eqa (map ttType tts)) $</span>
<span class="lineno"> 1855 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">fail &quot;list_term: non-uniform element types&quot;</span></span>
<span class="lineno"> 1856 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1857 </span><span class="spaces">     </span><span class="istickedoff">a' &lt;- io $ Cryptol.importType sc <span class="nottickedoff">Cryptol.emptyEnv</span> a</span>
<span class="lineno"> 1858 </span><span class="spaces">     </span><span class="istickedoff">trm &lt;- io $ scVectorReduced sc a' (map ttTerm tts)</span>
<span class="lineno"> 1859 </span><span class="spaces">     </span><span class="istickedoff">let n = C.tNum (length tts)</span>
<span class="lineno"> 1860 </span><span class="spaces">     </span><span class="istickedoff">return (TypedTerm (TypedTermSchema (C.tMono (C.tSeq n a))) trm)</span></span>
<span class="lineno"> 1861 </span>
<span class="lineno"> 1862 </span>eval_list :: TypedTerm -&gt; TopLevel [TypedTerm]
<span class="lineno"> 1863 </span><span class="decl"><span class="istickedoff">eval_list t = do</span>
<span class="lineno"> 1864 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1865 </span><span class="spaces">  </span><span class="istickedoff">(n, a) &lt;-</span>
<span class="lineno"> 1866 </span><span class="spaces">    </span><span class="istickedoff">case ttType t of</span>
<span class="lineno"> 1867 </span><span class="spaces">      </span><span class="istickedoff">TypedTermSchema (C.Forall [] [] (C.tIsSeq -&gt; Just (C.tIsNum -&gt; Just n, a))) -&gt; return (n, a)</span>
<span class="lineno"> 1868 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;eval_list: not a monomorphic array type&quot;</span></span>
<span class="lineno"> 1869 </span><span class="spaces">  </span><span class="istickedoff">n' &lt;- io $ scNat sc (fromInteger n)</span>
<span class="lineno"> 1870 </span><span class="spaces">  </span><span class="istickedoff">a' &lt;- io $ Cryptol.importType sc <span class="nottickedoff">Cryptol.emptyEnv</span> a</span>
<span class="lineno"> 1871 </span><span class="spaces">  </span><span class="istickedoff">idxs &lt;- io $ traverse (scNat sc) $ map fromInteger [0 .. n - 1]</span>
<span class="lineno"> 1872 </span><span class="spaces">  </span><span class="istickedoff">ts &lt;- io $ traverse (scAt sc n' a' (ttTerm t)) idxs</span>
<span class="lineno"> 1873 </span><span class="spaces">  </span><span class="istickedoff">return (map (TypedTerm (TypedTermSchema (C.tMono a))) ts)</span></span>
<span class="lineno"> 1874 </span>
<span class="lineno"> 1875 </span>term_theories :: [Text] -&gt; TypedTerm -&gt; TopLevel [Text]
<span class="lineno"> 1876 </span><span class="decl"><span class="nottickedoff">term_theories unints t = do</span>
<span class="lineno"> 1877 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1878 </span><span class="spaces">  </span><span class="nottickedoff">unintSet &lt;- resolveNames unints</span>
<span class="lineno"> 1879 </span><span class="spaces">  </span><span class="nottickedoff">hashConsing &lt;- gets SV.rwWhat4HashConsing</span>
<span class="lineno"> 1880 </span><span class="spaces">  </span><span class="nottickedoff">prop &lt;- io (predicateToProp sc Universal (ttTerm t))</span>
<span class="lineno"> 1881 </span><span class="spaces">  </span><span class="nottickedoff">Prover.what4Theories unintSet hashConsing (propToSequent prop)</span></span>
<span class="lineno"> 1882 </span>
<span class="lineno"> 1883 </span>default_typed_term :: TypedTerm -&gt; TopLevel TypedTerm
<span class="lineno"> 1884 </span><span class="decl"><span class="nottickedoff">default_typed_term tt = do</span>
<span class="lineno"> 1885 </span><span class="spaces">  </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 1886 </span><span class="spaces">  </span><span class="nottickedoff">cenv &lt;- fmap rwCryptol getTopLevelRW</span>
<span class="lineno"> 1887 </span><span class="spaces">  </span><span class="nottickedoff">let cfg = CEnv.meSolverConfig (CEnv.eModuleEnv cenv)</span>
<span class="lineno"> 1888 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno"> 1889 </span><span class="spaces">  </span><span class="nottickedoff">io $ defaultTypedTerm opts sc cfg tt</span></span>
<span class="lineno"> 1890 </span>
<span class="lineno"> 1891 </span>-- | Default the values of the type variables in a typed term.
<span class="lineno"> 1892 </span>defaultTypedTerm :: Options -&gt; SharedContext -&gt; C.SolverConfig -&gt; TypedTerm -&gt; IO TypedTerm
<span class="lineno"> 1893 </span><span class="decl"><span class="istickedoff">defaultTypedTerm opts sc cfg tt@(TypedTerm (TypedTermSchema schema) trm)</span>
<span class="lineno"> 1894 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">null (C.sVars schema)</span> = return tt</span>
<span class="lineno"> 1895 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1896 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">mdefault &lt;- C.withSolver (return ()) cfg (\s -&gt; C.defaultReplExpr s undefined schema)</span></span>
<span class="lineno"> 1897 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">let inst = do (soln, _) &lt;- mdefault</span></span>
<span class="lineno"> 1898 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">mapM (`lookup` soln) (C.sVars schema)</span></span>
<span class="lineno"> 1899 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">case inst of</span></span>
<span class="lineno"> 1900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; return (TypedTerm (TypedTermSchema schema) trm)</span></span>
<span class="lineno"> 1901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Just tys -&gt; do</span></span>
<span class="lineno"> 1902 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let vars = C.sVars schema</span></span>
<span class="lineno"> 1903 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let nms = C.addTNames CryptolPP.defaultPPCfg vars IntMap.empty</span></span>
<span class="lineno"> 1904 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">mapM_ (warnDefault nms) (zip vars tys)</span></span>
<span class="lineno"> 1905 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let applyType :: Term -&gt; C.Type -&gt; IO Term</span></span>
<span class="lineno"> 1906 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">applyType t ty = do</span></span>
<span class="lineno"> 1907 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">ty' &lt;- Cryptol.importType sc Cryptol.emptyEnv ty</span></span>
<span class="lineno"> 1908 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">scApply sc t ty'</span></span>
<span class="lineno"> 1909 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let dischargeProp :: Term -&gt; C.Prop -&gt; IO Term</span></span>
<span class="lineno"> 1910 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">dischargeProp t p</span></span>
<span class="lineno"> 1911 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">| Cryptol.isErasedProp p = return t</span></span>
<span class="lineno"> 1912 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">| otherwise = scApply sc t =&lt;&lt; Cryptol.proveProp sc Cryptol.emptyEnv p</span></span>
<span class="lineno"> 1913 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">trm' &lt;- foldM applyType trm tys</span></span>
<span class="lineno"> 1914 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let su = C.listSubst (zip (map C.tpVar vars) tys)</span></span>
<span class="lineno"> 1915 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let props = map (plainSubst su) (C.sProps schema)</span></span>
<span class="lineno"> 1916 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">trm'' &lt;- foldM dischargeProp trm' props</span></span>
<span class="lineno"> 1917 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">let schema' = C.Forall [] [] (C.apSubst su (C.sType schema))</span></span>
<span class="lineno"> 1918 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return (TypedTerm (TypedTermSchema schema') trm'')</span></span>
<span class="lineno"> 1919 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">warnDefault ns (x,t) =</span></span>
<span class="lineno"> 1921 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">printOutLn opts Info $ show $ C.text &quot;Assuming&quot; C.&lt;+&gt; C.ppWithNames ns (x :: C.TParam) C.&lt;+&gt; C.text &quot;=&quot; C.&lt;+&gt; C.pp t</span></span>
<span class="lineno"> 1922 </span><span class="spaces">    </span><span class="istickedoff">-- Apply a substitution to a type *without* simplifying</span>
<span class="lineno"> 1923 </span><span class="spaces">    </span><span class="istickedoff">-- constraints like @Arith [n]a@ to @Arith a@. (This is in contrast to</span>
<span class="lineno"> 1924 </span><span class="spaces">    </span><span class="istickedoff">-- 'apSubst', which performs simplifications wherever possible.)</span>
<span class="lineno"> 1925 </span><span class="spaces">    </span><span class="istickedoff">plainSubst :: C.Subst -&gt; C.Type -&gt; C.Type</span>
<span class="lineno"> 1926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">plainSubst s ty =</span></span>
<span class="lineno"> 1927 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case ty of</span></span>
<span class="lineno"> 1928 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TCon tc ts   -&gt; C.TCon tc (map (plainSubst s) ts)</span></span>
<span class="lineno"> 1929 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TUser f ts t -&gt; C.TUser f (map (plainSubst s) ts) (plainSubst s t)</span></span>
<span class="lineno"> 1930 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TRec fs      -&gt; C.TRec (fmap (plainSubst s) fs)</span></span>
<span class="lineno"> 1931 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TVar x       -&gt; C.apSubst s (C.TVar x)</span></span>
<span class="lineno"> 1932 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">C.TNominal nt ts -&gt; C.TNominal nt (fmap (plainSubst s) ts)</span></span>
<span class="lineno"> 1933 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1934 </span><span class="spaces"></span><span class="istickedoff">defaultTypedTerm _opts _sc _cfg tt = <span class="nottickedoff">return tt</span></span></span>
<span class="lineno"> 1935 </span>
<span class="lineno"> 1936 </span>
<span class="lineno"> 1937 </span>eval_size :: C.Schema -&gt; TopLevel Integer
<span class="lineno"> 1938 </span><span class="decl"><span class="istickedoff">eval_size s =</span>
<span class="lineno"> 1939 </span><span class="spaces">  </span><span class="istickedoff">case s of</span>
<span class="lineno"> 1940 </span><span class="spaces">    </span><span class="istickedoff">C.Forall [] [] t -&gt;</span>
<span class="lineno"> 1941 </span><span class="spaces">      </span><span class="istickedoff">case C.evalType <span class="nottickedoff">mempty</span> t of</span>
<span class="lineno"> 1942 </span><span class="spaces">        </span><span class="istickedoff">Left (C.Nat x) -&gt; return x</span>
<span class="lineno"> 1943 </span><span class="spaces">        </span><span class="istickedoff">Left C.Inf     -&gt; <span class="nottickedoff">fail &quot;eval_size: illegal infinite size&quot;</span></span>
<span class="lineno"> 1944 </span><span class="spaces">        </span><span class="istickedoff">Right _        -&gt; <span class="nottickedoff">fail &quot;eval_size: not a numeric type&quot;</span></span>
<span class="lineno"> 1945 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;eval_size: unsupported polymorphic type&quot;</span></span></span>
<span class="lineno"> 1946 </span>
<span class="lineno"> 1947 </span>int_to_term :: Int -&gt; TopLevel TypedTerm
<span class="lineno"> 1948 </span><span class="decl"><span class="nottickedoff">int_to_term i</span>
<span class="lineno"> 1949 </span><span class="spaces">  </span><span class="nottickedoff">| i &lt; 0 =</span>
<span class="lineno"> 1950 </span><span class="spaces">     </span><span class="nottickedoff">do sc  &lt;- getSharedContext</span>
<span class="lineno"> 1951 </span><span class="spaces">        </span><span class="nottickedoff">tm  &lt;- io (scNat sc (fromInteger (negate (toInteger i))))</span>
<span class="lineno"> 1952 </span><span class="spaces">        </span><span class="nottickedoff">tm' &lt;- io (scIntNeg sc =&lt;&lt; scNatToInt sc tm)</span>
<span class="lineno"> 1953 </span><span class="spaces">        </span><span class="nottickedoff">io (mkTypedTerm sc tm')</span>
<span class="lineno"> 1954 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise =</span>
<span class="lineno"> 1955 </span><span class="spaces">     </span><span class="nottickedoff">do sc  &lt;- getSharedContext</span>
<span class="lineno"> 1956 </span><span class="spaces">        </span><span class="nottickedoff">tm  &lt;- io (scNat sc (fromIntegral i))</span>
<span class="lineno"> 1957 </span><span class="spaces">        </span><span class="nottickedoff">tm' &lt;- io (scNatToInt sc tm)</span>
<span class="lineno"> 1958 </span><span class="spaces">        </span><span class="nottickedoff">io (mkTypedTerm sc tm')</span></span>
<span class="lineno"> 1959 </span>
<span class="lineno"> 1960 </span>nat_to_term :: Int -&gt; TopLevel TypedTerm
<span class="lineno"> 1961 </span><span class="decl"><span class="nottickedoff">nat_to_term i</span>
<span class="lineno"> 1962 </span><span class="spaces">  </span><span class="nottickedoff">| i &gt;= 0 =</span>
<span class="lineno"> 1963 </span><span class="spaces">      </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1964 </span><span class="spaces">         </span><span class="nottickedoff">tm &lt;- io $ scNat sc (fromIntegral i)</span>
<span class="lineno"> 1965 </span><span class="spaces">         </span><span class="nottickedoff">io $ mkTypedTerm sc tm</span>
<span class="lineno"> 1966 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1967 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise =</span>
<span class="lineno"> 1968 </span><span class="spaces">      </span><span class="nottickedoff">fail (&quot;nat_to_term: negative value &quot; ++ show i)</span></span>
<span class="lineno"> 1969 </span>
<span class="lineno"> 1970 </span>
<span class="lineno"> 1971 </span>size_to_term :: C.Schema -&gt; TopLevel TypedTerm
<span class="lineno"> 1972 </span><span class="decl"><span class="nottickedoff">size_to_term s =</span>
<span class="lineno"> 1973 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 1974 </span><span class="spaces">     </span><span class="nottickedoff">tm &lt;- io $ case s of</span>
<span class="lineno"> 1975 </span><span class="spaces">                  </span><span class="nottickedoff">C.Forall [] [] t -&gt;</span>
<span class="lineno"> 1976 </span><span class="spaces">                    </span><span class="nottickedoff">case C.evalType mempty t of</span>
<span class="lineno"> 1977 </span><span class="spaces">                      </span><span class="nottickedoff">Left (C.Nat x) | x &gt;= 0 -&gt;</span>
<span class="lineno"> 1978 </span><span class="spaces">                        </span><span class="nottickedoff">scGlobalApply sc &quot;Cryptol.TCNum&quot; =&lt;&lt; sequence [scNat sc (fromInteger x)]</span>
<span class="lineno"> 1979 </span><span class="spaces">                      </span><span class="nottickedoff">Left C.Inf -&gt; scGlobalApply sc &quot;Cryptol.TCInf&quot; []</span>
<span class="lineno"> 1980 </span><span class="spaces">                      </span><span class="nottickedoff">_ -&gt; fail &quot;size_to_term: not a numeric type&quot;</span>
<span class="lineno"> 1981 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; fail &quot;size_to_term: unsupported polymorphic type&quot;</span>
<span class="lineno"> 1982 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1983 </span><span class="spaces">     </span><span class="nottickedoff">return (TypedTerm (TypedTermKind C.KNum) tm)</span></span>
<span class="lineno"> 1984 </span>
<span class="lineno"> 1985 </span>nthPrim :: [a] -&gt; Int -&gt; TopLevel a
<span class="lineno"> 1986 </span><span class="decl"><span class="istickedoff">nthPrim [] _ = fail &quot;nth: index too large&quot;</span>
<span class="lineno"> 1987 </span><span class="spaces"></span><span class="istickedoff">nthPrim (x : _) 0 = return x</span>
<span class="lineno"> 1988 </span><span class="spaces"></span><span class="istickedoff">nthPrim (_ : xs) i = nthPrim xs (i - 1)</span></span>
<span class="lineno"> 1989 </span>
<span class="lineno"> 1990 </span>headPrim :: [a] -&gt; TopLevel a
<span class="lineno"> 1991 </span><span class="decl"><span class="istickedoff">headPrim [] = fail &quot;head: empty list&quot;</span>
<span class="lineno"> 1992 </span><span class="spaces"></span><span class="istickedoff">headPrim (x : _) = return x</span></span>
<span class="lineno"> 1993 </span>
<span class="lineno"> 1994 </span>tailPrim :: [a] -&gt; TopLevel [a]
<span class="lineno"> 1995 </span><span class="decl"><span class="istickedoff">tailPrim [] = fail &quot;tail: empty list&quot;</span>
<span class="lineno"> 1996 </span><span class="spaces"></span><span class="istickedoff">tailPrim (_ : xs) = return xs</span></span>
<span class="lineno"> 1997 </span>
<span class="lineno"> 1998 </span>parseCoreMod :: Text -&gt; Text -&gt; TopLevel Term
<span class="lineno"> 1999 </span><span class="decl"><span class="istickedoff">parseCoreMod mnm_str input =</span>
<span class="lineno"> 2000 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 2001 </span><span class="spaces">     </span><span class="istickedoff">let base = &quot;&lt;interactive&gt;&quot;</span>
<span class="lineno"> 2002 </span><span class="spaces">         </span><span class="istickedoff">path = &quot;&lt;interactive&gt;&quot;</span>
<span class="lineno"> 2003 </span><span class="spaces">     </span><span class="istickedoff">uterm &lt;-</span>
<span class="lineno"> 2004 </span><span class="spaces">       </span><span class="istickedoff">case parseSAWTerm base path (LText.fromStrict input) of</span>
<span class="lineno"> 2005 </span><span class="spaces">         </span><span class="istickedoff">Right uterm -&gt; return uterm</span>
<span class="lineno"> 2006 </span><span class="spaces">         </span><span class="istickedoff">Left err -&gt;</span>
<span class="lineno"> 2007 </span><span class="spaces">           </span><span class="istickedoff">do let msg = show err</span>
<span class="lineno"> 2008 </span><span class="spaces">              </span><span class="istickedoff">printOutLnTop Opts.Error msg</span>
<span class="lineno"> 2009 </span><span class="spaces">              </span><span class="istickedoff">fail msg</span>
<span class="lineno"> 2010 </span><span class="spaces">     </span><span class="istickedoff">let mnm =</span>
<span class="lineno"> 2011 </span><span class="spaces">           </span><span class="istickedoff">mkModuleName $ Text.splitOn &quot;.&quot; mnm_str</span>
<span class="lineno"> 2012 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- io $ scFindModule sc mnm -- Check that mnm exists</span>
<span class="lineno"> 2013 </span><span class="spaces">     </span><span class="istickedoff">err_or_t &lt;- io $ inferCompleteTermCtx sc (Just mnm) [] uterm</span>
<span class="lineno"> 2014 </span><span class="spaces">     </span><span class="istickedoff">case err_or_t of</span>
<span class="lineno"> 2015 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">fail (show err)</span></span>
<span class="lineno"> 2016 </span><span class="spaces">       </span><span class="istickedoff">Right x -&gt; pure x</span></span>
<span class="lineno"> 2017 </span>
<span class="lineno"> 2018 </span>parseCore :: Text -&gt; TopLevel Term
<span class="lineno"> 2019 </span><span class="decl"><span class="istickedoff">parseCore input = parseCoreMod &quot;Cryptol&quot; input</span></span>
<span class="lineno"> 2020 </span>
<span class="lineno"> 2021 </span>parse_core :: Text -&gt; TopLevel TypedTerm
<span class="lineno"> 2022 </span><span class="decl"><span class="istickedoff">parse_core input = do</span>
<span class="lineno"> 2023 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- parseCore input</span>
<span class="lineno"> 2024 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2025 </span><span class="spaces">  </span><span class="istickedoff">io $ mkTypedTerm sc t</span></span>
<span class="lineno"> 2026 </span>
<span class="lineno"> 2027 </span>parse_core_mod :: Text -&gt; Text -&gt; TopLevel TypedTerm
<span class="lineno"> 2028 </span><span class="decl"><span class="istickedoff">parse_core_mod mnm input = do</span>
<span class="lineno"> 2029 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- parseCoreMod mnm input</span>
<span class="lineno"> 2030 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2031 </span><span class="spaces">  </span><span class="istickedoff">io $ mkTypedTerm sc t</span></span>
<span class="lineno"> 2032 </span>
<span class="lineno"> 2033 </span>prove_core :: ProofScript () -&gt; Text -&gt; TopLevel Theorem
<span class="lineno"> 2034 </span><span class="decl"><span class="istickedoff">prove_core script input =</span>
<span class="lineno"> 2035 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 2036 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- parseCore input</span>
<span class="lineno"> 2037 </span><span class="spaces">     </span><span class="istickedoff">p &lt;- io (termToProp sc t)</span>
<span class="lineno"> 2038 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 2039 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 2040 </span><span class="spaces">     </span><span class="istickedoff">let goal = ProofGoal</span>
<span class="lineno"> 2041 </span><span class="spaces">                </span><span class="istickedoff">{ goalNum = <span class="nottickedoff">0</span></span>
<span class="lineno"> 2042 </span><span class="spaces">                </span><span class="istickedoff">, goalType = <span class="nottickedoff">&quot;prove&quot;</span></span>
<span class="lineno"> 2043 </span><span class="spaces">                </span><span class="istickedoff">, goalName = <span class="nottickedoff">&quot;prove_core&quot;</span></span>
<span class="lineno"> 2044 </span><span class="spaces">                </span><span class="istickedoff">, goalLoc  = <span class="nottickedoff">show pos</span></span>
<span class="lineno"> 2045 </span><span class="spaces">                </span><span class="istickedoff">, goalDesc = <span class="nottickedoff">&quot;&quot;</span></span>
<span class="lineno"> 2046 </span><span class="spaces">                </span><span class="istickedoff">, goalSequent = propToSequent p</span>
<span class="lineno"> 2047 </span><span class="spaces">                </span><span class="istickedoff">, goalTags = <span class="nottickedoff">mempty</span></span>
<span class="lineno"> 2048 </span><span class="spaces">                </span><span class="istickedoff">}</span>
<span class="lineno"> 2049 </span><span class="spaces">     </span><span class="istickedoff">res &lt;- SV.runProofScript script p goal <span class="nottickedoff">Nothing</span> <span class="nottickedoff">&quot;prove_core&quot;</span> <span class="nottickedoff">True</span> False</span>
<span class="lineno"> 2050 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">failProof pst =</span></span>
<span class="lineno"> 2051 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;prove_core: &quot; ++ show (length (psGoals pst)) ++ &quot; unsolved subgoal(s)\n&quot;</span></span>
<span class="lineno"> 2052 </span><span class="spaces">                                  </span><span class="istickedoff"><span class="nottickedoff">++ SV.showsProofResult opts res &quot;&quot;</span></span>
<span class="lineno"> 2053 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno"> 2054 </span><span class="spaces">       </span><span class="istickedoff">ValidProof _ thm -&gt; SV.returnTheoremProof thm</span>
<span class="lineno"> 2055 </span><span class="spaces">       </span><span class="istickedoff">InvalidProof _ _ pst -&gt; <span class="nottickedoff">failProof pst</span></span>
<span class="lineno"> 2056 </span><span class="spaces">       </span><span class="istickedoff">UnfinishedProof pst  -&gt; <span class="nottickedoff">failProof pst</span></span></span>
<span class="lineno"> 2057 </span>
<span class="lineno"> 2058 </span>core_axiom :: Text -&gt; TopLevel Theorem
<span class="lineno"> 2059 </span><span class="decl"><span class="istickedoff">core_axiom input =</span>
<span class="lineno"> 2060 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 2061 </span><span class="spaces">     </span><span class="istickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 2062 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- parseCore input</span>
<span class="lineno"> 2063 </span><span class="spaces">     </span><span class="istickedoff">p &lt;- io (termToProp sc t)</span>
<span class="lineno"> 2064 </span><span class="spaces">     </span><span class="istickedoff">db &lt;- SV.getTheoremDB</span>
<span class="lineno"> 2065 </span><span class="spaces">     </span><span class="istickedoff">(thm, db') &lt;- io (admitTheorem <span class="nottickedoff">db</span> <span class="nottickedoff">&quot;core_axiom&quot;</span> p <span class="nottickedoff">pos</span> <span class="nottickedoff">&quot;core_axiom&quot;</span>)</span>
<span class="lineno"> 2066 </span><span class="spaces">     </span><span class="istickedoff">SV.putTheoremDB <span class="nottickedoff">db'</span></span>
<span class="lineno"> 2067 </span><span class="spaces">     </span><span class="istickedoff">SV.returnTheoremProof thm</span></span>
<span class="lineno"> 2068 </span>
<span class="lineno"> 2069 </span>core_thm :: Text -&gt; TopLevel Theorem
<span class="lineno"> 2070 </span><span class="decl"><span class="nottickedoff">core_thm input =</span>
<span class="lineno"> 2071 </span><span class="spaces">  </span><span class="nottickedoff">do t &lt;- parseCore input</span>
<span class="lineno"> 2072 </span><span class="spaces">     </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2073 </span><span class="spaces">     </span><span class="nottickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 2074 </span><span class="spaces">     </span><span class="nottickedoff">db &lt;- SV.getTheoremDB</span>
<span class="lineno"> 2075 </span><span class="spaces">     </span><span class="nottickedoff">(thm, db') &lt;- io (proofByTerm sc db t pos &quot;core_thm&quot;)</span>
<span class="lineno"> 2076 </span><span class="spaces">     </span><span class="nottickedoff">SV.putTheoremDB db'</span>
<span class="lineno"> 2077 </span><span class="spaces">     </span><span class="nottickedoff">SV.returnTheoremProof thm</span></span>
<span class="lineno"> 2078 </span>
<span class="lineno"> 2079 </span>specialize_theorem :: Theorem -&gt; [TypedTerm] -&gt; TopLevel Theorem
<span class="lineno"> 2080 </span><span class="decl"><span class="nottickedoff">specialize_theorem thm ts =</span>
<span class="lineno"> 2081 </span><span class="spaces">  </span><span class="nottickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 2082 </span><span class="spaces">     </span><span class="nottickedoff">db &lt;- SV.getTheoremDB</span>
<span class="lineno"> 2083 </span><span class="spaces">     </span><span class="nottickedoff">pos &lt;- SV.getPosition</span>
<span class="lineno"> 2084 </span><span class="spaces">     </span><span class="nottickedoff">what4PushMuxOps &lt;- gets rwWhat4PushMuxOps</span>
<span class="lineno"> 2085 </span><span class="spaces">     </span><span class="nottickedoff">(thm', db') &lt;- io (specializeTheorem sc what4PushMuxOps db pos &quot;specialize_theorem&quot; thm (map ttTerm ts))</span>
<span class="lineno"> 2086 </span><span class="spaces">     </span><span class="nottickedoff">SV.putTheoremDB db'</span>
<span class="lineno"> 2087 </span><span class="spaces">     </span><span class="nottickedoff">SV.returnTheoremProof thm'</span></span>
<span class="lineno"> 2088 </span>
<span class="lineno"> 2089 </span>get_opt :: Int -&gt; TopLevel Text
<span class="lineno"> 2090 </span><span class="decl"><span class="istickedoff">get_opt n = do</span>
<span class="lineno"> 2091 </span><span class="spaces">  </span><span class="istickedoff">argv &lt;- asks roArgv</span>
<span class="lineno"> 2092 </span><span class="spaces">  </span><span class="istickedoff">nthPrim argv n</span></span>
<span class="lineno"> 2093 </span>
<span class="lineno"> 2094 </span>get_nopts :: () -&gt; TopLevel Int
<span class="lineno"> 2095 </span><span class="decl"><span class="istickedoff">get_nopts () = do</span>
<span class="lineno"> 2096 </span><span class="spaces">  </span><span class="istickedoff">argv &lt;- asks roArgv</span>
<span class="lineno"> 2097 </span><span class="spaces">  </span><span class="istickedoff">return $ length argv</span></span>
<span class="lineno"> 2098 </span>
<span class="lineno"> 2099 </span>get_env :: Text -&gt; TopLevel Text
<span class="lineno"> 2100 </span><span class="decl"><span class="istickedoff">get_env name = do</span>
<span class="lineno"> 2101 </span><span class="spaces">  </span><span class="istickedoff">mbValue &lt;- io $ Env.lookupEnv (Text.unpack name)</span>
<span class="lineno"> 2102 </span><span class="spaces">  </span><span class="istickedoff">case mbValue of</span>
<span class="lineno"> 2103 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; fail $ &quot;Environment variable not found: &quot; ++ Text.unpack name</span>
<span class="lineno"> 2104 </span><span class="spaces">    </span><span class="istickedoff">Just v -&gt; return $ Text.pack v</span></span>
<span class="lineno"> 2105 </span>
<span class="lineno"> 2106 </span>cryptol_prims :: TopLevel CryptolModule
<span class="lineno"> 2107 </span><span class="decl"><span class="nottickedoff">cryptol_prims = CryptolModule Map.empty &lt;$&gt; Map.fromList &lt;$&gt; traverse parsePrim prims</span>
<span class="lineno"> 2108 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2109 </span><span class="spaces">    </span><span class="nottickedoff">prims :: [(Text, Ident, Text)]</span>
<span class="lineno"> 2110 </span><span class="spaces">    </span><span class="nottickedoff">prims =</span>
<span class="lineno"> 2111 </span><span class="spaces">      </span><span class="nottickedoff">[ (&quot;trunc&quot;, &quot;Cryptol.ecTrunc&quot; , &quot;{m, n} (fin m, fin n) =&gt; [m+n] -&gt; [n]&quot;)</span>
<span class="lineno"> 2112 </span><span class="spaces">      </span><span class="nottickedoff">, (&quot;uext&quot; , &quot;Cryptol.ecUExt&quot;  , &quot;{m, n} (fin m, fin n) =&gt; [n] -&gt; [m+n]&quot;)</span>
<span class="lineno"> 2113 </span><span class="spaces">      </span><span class="nottickedoff">, (&quot;sext&quot; , &quot;Cryptol.ecSExt&quot;  , &quot;{m, n} (fin m, fin n, n &gt;= 1) =&gt; [n] -&gt; [m+n]&quot;)</span>
<span class="lineno"> 2114 </span><span class="spaces">      </span><span class="nottickedoff">, (&quot;sgt&quot;  , &quot;Cryptol.ecSgt&quot;   , &quot;{n} (fin n) =&gt; [n] -&gt; [n] -&gt; Bit&quot;)</span>
<span class="lineno"> 2115 </span><span class="spaces">      </span><span class="nottickedoff">, (&quot;sge&quot;  , &quot;Cryptol.ecSge&quot;   , &quot;{n} (fin n) =&gt; [n] -&gt; [n] -&gt; Bit&quot;)</span>
<span class="lineno"> 2116 </span><span class="spaces">      </span><span class="nottickedoff">, (&quot;slt&quot;  , &quot;Cryptol.ecSlt&quot;   , &quot;{n} (fin n) =&gt; [n] -&gt; [n] -&gt; Bit&quot;)</span>
<span class="lineno"> 2117 </span><span class="spaces">      </span><span class="nottickedoff">, (&quot;sle&quot;  , &quot;Cryptol.ecSle&quot;   , &quot;{n} (fin n) =&gt; [n] -&gt; [n] -&gt; Bit&quot;)</span>
<span class="lineno"> 2118 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno"> 2119 </span><span class="spaces">      </span><span class="nottickedoff">-- TODO: sext, sdiv, srem, sshr</span>
<span class="lineno"> 2120 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2121 </span><span class="spaces">    </span><span class="nottickedoff">noLoc :: Text -&gt; CEnv.InputText</span>
<span class="lineno"> 2122 </span><span class="spaces">    </span><span class="nottickedoff">noLoc x = CEnv.InputText</span>
<span class="lineno"> 2123 </span><span class="spaces">                </span><span class="nottickedoff">{ CEnv.inpText = x</span>
<span class="lineno"> 2124 </span><span class="spaces">                </span><span class="nottickedoff">, CEnv.inpFile = &quot;(cryptol_prims)&quot;</span>
<span class="lineno"> 2125 </span><span class="spaces">                </span><span class="nottickedoff">, CEnv.inpLine = 1</span>
<span class="lineno"> 2126 </span><span class="spaces">                </span><span class="nottickedoff">, CEnv.inpCol  = 1 + 2 -- add 2 for dropped {{</span>
<span class="lineno"> 2127 </span><span class="spaces">                </span><span class="nottickedoff">}</span>
<span class="lineno"> 2128 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2129 </span><span class="spaces">    </span><span class="nottickedoff">parsePrim :: (Text, Ident, Text) -&gt; TopLevel (C.Name, TypedTerm)</span>
<span class="lineno"> 2130 </span><span class="spaces">    </span><span class="nottickedoff">parsePrim (n, i, s) = do</span>
<span class="lineno"> 2131 </span><span class="spaces">      </span><span class="nottickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2132 </span><span class="spaces">      </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2133 </span><span class="spaces">      </span><span class="nottickedoff">let cenv = rwCryptol rw</span>
<span class="lineno"> 2134 </span><span class="spaces">      </span><span class="nottickedoff">let mname = C.packModName [&quot;Prims&quot;]</span>
<span class="lineno"> 2135 </span><span class="spaces">      </span><span class="nottickedoff">let ?fileReader = StrictBS.readFile</span>
<span class="lineno"> 2136 </span><span class="spaces">      </span><span class="nottickedoff">(n', cenv') &lt;- io $ CEnv.declareName cenv mname n</span>
<span class="lineno"> 2137 </span><span class="spaces">      </span><span class="nottickedoff">s' &lt;- io $ CEnv.parseSchema cenv' (noLoc s)</span>
<span class="lineno"> 2138 </span><span class="spaces">      </span><span class="nottickedoff">t' &lt;- io $ scGlobalDef sc i</span>
<span class="lineno"> 2139 </span><span class="spaces">      </span><span class="nottickedoff">putTopLevelRW $ rw { rwCryptol = cenv' }</span>
<span class="lineno"> 2140 </span><span class="spaces">      </span><span class="nottickedoff">return (n', TypedTerm (TypedTermSchema s') t')</span></span>
<span class="lineno"> 2141 </span>
<span class="lineno"> 2142 </span>cryptol_load :: (FilePath -&gt; IO StrictBS.ByteString) -&gt; FilePath -&gt; TopLevel CryptolModule
<span class="lineno"> 2143 </span><span class="decl"><span class="istickedoff">cryptol_load fileReader path = do</span>
<span class="lineno"> 2144 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno"> 2145 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2146 </span><span class="spaces">  </span><span class="istickedoff">let ce = rwCryptol rw</span>
<span class="lineno"> 2147 </span><span class="spaces">  </span><span class="istickedoff">let ?fileReader = fileReader</span>
<span class="lineno"> 2148 </span><span class="spaces">  </span><span class="istickedoff">(m, ce') &lt;- io $ CEnv.loadCryptolModule sc ce path</span>
<span class="lineno"> 2149 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW $ rw { rwCryptol = ce' }</span>
<span class="lineno"> 2150 </span><span class="spaces">  </span><span class="istickedoff">return m</span></span>
<span class="lineno"> 2151 </span>
<span class="lineno"> 2152 </span>cryptol_add_path :: FilePath -&gt; TopLevel ()
<span class="lineno"> 2153 </span><span class="decl"><span class="nottickedoff">cryptol_add_path path =</span>
<span class="lineno"> 2154 </span><span class="spaces">  </span><span class="nottickedoff">do rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2155 </span><span class="spaces">     </span><span class="nottickedoff">let ce = rwCryptol rw</span>
<span class="lineno"> 2156 </span><span class="spaces">     </span><span class="nottickedoff">let me = CEnv.eModuleEnv ce</span>
<span class="lineno"> 2157 </span><span class="spaces">     </span><span class="nottickedoff">let me' = me { C.meSearchPath = path : C.meSearchPath me }</span>
<span class="lineno"> 2158 </span><span class="spaces">     </span><span class="nottickedoff">let ce' = ce { CEnv.eModuleEnv = me' }</span>
<span class="lineno"> 2159 </span><span class="spaces">     </span><span class="nottickedoff">let rw' = rw { rwCryptol = ce' }</span>
<span class="lineno"> 2160 </span><span class="spaces">     </span><span class="nottickedoff">putTopLevelRW rw'</span></span>
<span class="lineno"> 2161 </span>
<span class="lineno"> 2162 </span>cryptol_add_prim :: Text -&gt; Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2163 </span><span class="decl"><span class="nottickedoff">cryptol_add_prim mnm nm trm =</span>
<span class="lineno"> 2164 </span><span class="spaces">  </span><span class="nottickedoff">do rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2165 </span><span class="spaces">     </span><span class="nottickedoff">let env = rwCryptol rw</span>
<span class="lineno"> 2166 </span><span class="spaces">     </span><span class="nottickedoff">let prim_name =</span>
<span class="lineno"> 2167 </span><span class="spaces">           </span><span class="nottickedoff">C.PrimIdent (C.textToModName mnm) nm</span>
<span class="lineno"> 2168 </span><span class="spaces">     </span><span class="nottickedoff">let env' =</span>
<span class="lineno"> 2169 </span><span class="spaces">           </span><span class="nottickedoff">env { CEnv.ePrims =</span>
<span class="lineno"> 2170 </span><span class="spaces">                   </span><span class="nottickedoff">Map.insert prim_name (ttTerm trm) (CEnv.ePrims env) }</span>
<span class="lineno"> 2171 </span><span class="spaces">     </span><span class="nottickedoff">putTopLevelRW (rw { rwCryptol = env' })</span></span>
<span class="lineno"> 2172 </span>
<span class="lineno"> 2173 </span>cryptol_add_prim_type :: Text -&gt; Text -&gt; TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2174 </span><span class="decl"><span class="nottickedoff">cryptol_add_prim_type mnm nm tp =</span>
<span class="lineno"> 2175 </span><span class="spaces">  </span><span class="nottickedoff">do rw &lt;- getTopLevelRW</span>
<span class="lineno"> 2176 </span><span class="spaces">     </span><span class="nottickedoff">let env = rwCryptol rw</span>
<span class="lineno"> 2177 </span><span class="spaces">     </span><span class="nottickedoff">let prim_name =</span>
<span class="lineno"> 2178 </span><span class="spaces">           </span><span class="nottickedoff">C.PrimIdent (C.textToModName mnm) nm</span>
<span class="lineno"> 2179 </span><span class="spaces">     </span><span class="nottickedoff">let env' = env { CEnv.ePrimTypes =</span>
<span class="lineno"> 2180 </span><span class="spaces">                        </span><span class="nottickedoff">Map.insert prim_name (ttTerm tp) (CEnv.ePrimTypes env) }</span>
<span class="lineno"> 2181 </span><span class="spaces">     </span><span class="nottickedoff">putTopLevelRW (rw { rwCryptol = env' })</span></span>
<span class="lineno"> 2182 </span>
<span class="lineno"> 2183 </span>-- | Call 'Cryptol.importSchema' using a 'CEnv.CryptolEnv'
<span class="lineno"> 2184 </span>importSchemaCEnv :: SharedContext -&gt; CEnv.CryptolEnv -&gt; Cryptol.Schema -&gt;
<span class="lineno"> 2185 </span>                    IO Term
<span class="lineno"> 2186 </span><span class="decl"><span class="istickedoff">importSchemaCEnv sc cenv schema =</span>
<span class="lineno"> 2187 </span><span class="spaces">  </span><span class="istickedoff">do cry_env &lt;- let ?fileReader = <span class="nottickedoff">StrictBS.readFile</span> in CEnv.mkCryEnv cenv</span>
<span class="lineno"> 2188 </span><span class="spaces">     </span><span class="istickedoff">Cryptol.importSchema sc cry_env schema</span></span>
<span class="lineno"> 2189 </span>
<span class="lineno"> 2190 </span>parseSharpSATResult :: String -&gt; Maybe Integer
<span class="lineno"> 2191 </span><span class="decl"><span class="nottickedoff">parseSharpSATResult s = parse (lines s)</span>
<span class="lineno"> 2192 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2193 </span><span class="spaces">    </span><span class="nottickedoff">parse (h : n : _) | &quot;# solutions&quot; `isPrefixOf` h = readMaybe n</span>
<span class="lineno"> 2194 </span><span class="spaces">    </span><span class="nottickedoff">parse (_ : rest) = parse rest</span>
<span class="lineno"> 2195 </span><span class="spaces">    </span><span class="nottickedoff">parse [] = Nothing</span></span>
<span class="lineno"> 2196 </span>
<span class="lineno"> 2197 </span>sharpSAT :: TypedTerm -&gt; TopLevel Integer
<span class="lineno"> 2198 </span><span class="decl"><span class="nottickedoff">sharpSAT t = do</span>
<span class="lineno"> 2199 </span><span class="spaces">  </span><span class="nottickedoff">tmp &lt;- io $ emptySystemTempFile &quot;sharpSAT-input&quot;</span>
<span class="lineno"> 2200 </span><span class="spaces">  </span><span class="nottickedoff">Prover.write_cnf tmp t</span>
<span class="lineno"> 2201 </span><span class="spaces">  </span><span class="nottickedoff">(_ec, out, _err) &lt;- io $ readProcessWithExitCode &quot;sharpSAT&quot; [tmp] &quot;&quot;</span>
<span class="lineno"> 2202 </span><span class="spaces">  </span><span class="nottickedoff">io $ removeFile tmp</span>
<span class="lineno"> 2203 </span><span class="spaces">  </span><span class="nottickedoff">case parseSharpSATResult out of</span>
<span class="lineno"> 2204 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail $ &quot;Garbled result from sharpSAT\n\n&quot; ++ out</span>
<span class="lineno"> 2205 </span><span class="spaces">    </span><span class="nottickedoff">Just n -&gt; return n</span></span>
<span class="lineno"> 2206 </span>
<span class="lineno"> 2207 </span>approxmc :: TypedTerm -&gt; TopLevel ()
<span class="lineno"> 2208 </span><span class="decl"><span class="nottickedoff">approxmc t = do</span>
<span class="lineno"> 2209 </span><span class="spaces">  </span><span class="nottickedoff">tmp &lt;- io $ emptySystemTempFile &quot;approxmc-input&quot;</span>
<span class="lineno"> 2210 </span><span class="spaces">  </span><span class="nottickedoff">Prover.write_cnf tmp t</span>
<span class="lineno"> 2211 </span><span class="spaces">  </span><span class="nottickedoff">(_ec, out, _err) &lt;- io $ readProcessWithExitCode &quot;approxmc&quot; [tmp] &quot;&quot;</span>
<span class="lineno"> 2212 </span><span class="spaces">  </span><span class="nottickedoff">io $ removeFile tmp</span>
<span class="lineno"> 2213 </span><span class="spaces">  </span><span class="nottickedoff">let msg = filter (&quot;[appmc] Number of solutions is&quot; `isPrefixOf`) (lines out)</span>
<span class="lineno"> 2214 </span><span class="spaces">  </span><span class="nottickedoff">case msg of</span>
<span class="lineno"> 2215 </span><span class="spaces">    </span><span class="nottickedoff">[l] -&gt; io $ putStrLn l</span>
<span class="lineno"> 2216 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail $ &quot;Garbled result from approxmc\n\n&quot; ++ out</span></span>
<span class="lineno"> 2217 </span>
<span class="lineno"> 2218 </span>set_path_sat_solver :: Text -&gt; TopLevel ()
<span class="lineno"> 2219 </span><span class="decl"><span class="nottickedoff">set_path_sat_solver nm =</span>
<span class="lineno"> 2220 </span><span class="spaces">  </span><span class="nottickedoff">case Text.toLower nm of</span>
<span class="lineno"> 2221 </span><span class="spaces">    </span><span class="nottickedoff">&quot;z3&quot;    -&gt; modify (\rw -&gt; rw{ rwPathSatSolver = PathSat_Z3 })</span>
<span class="lineno"> 2222 </span><span class="spaces">    </span><span class="nottickedoff">&quot;yices&quot; -&gt; modify (\rw -&gt; rw{ rwPathSatSolver = PathSat_Yices })</span>
<span class="lineno"> 2223 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail $ Text.unpack $ &quot;Unknown path sat solver: &quot; &lt;&gt; nm</span></span>
<span class="lineno"> 2224 </span>
<span class="lineno"> 2225 </span>summarize_verification :: TopLevel ()
<span class="lineno"> 2226 </span><span class="decl"><span class="istickedoff">summarize_verification =</span>
<span class="lineno"> 2227 </span><span class="spaces">  </span><span class="istickedoff">do values &lt;- rwProofs &lt;$&gt; getTopLevelRW</span>
<span class="lineno"> 2228 </span><span class="spaces">     </span><span class="istickedoff">let jspecs  = [ <span class="nottickedoff">s</span> | SV.VJVMMethodSpec s &lt;- values ]</span>
<span class="lineno"> 2229 </span><span class="spaces">         </span><span class="istickedoff">lspecs  = [ <span class="nottickedoff">s</span> | SV.VLLVMCrucibleMethodSpec s &lt;- values ]</span>
<span class="lineno"> 2230 </span><span class="spaces">         </span><span class="istickedoff">thms    = [ t | SV.VTheorem t &lt;- values ]</span>
<span class="lineno"> 2231 </span><span class="spaces">     </span><span class="istickedoff">db &lt;- SV.getTheoremDB</span>
<span class="lineno"> 2232 </span><span class="spaces">     </span><span class="istickedoff">let summary = computeVerificationSummary db jspecs lspecs thms</span>
<span class="lineno"> 2233 </span><span class="spaces">     </span><span class="istickedoff">opts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 2234 </span><span class="spaces">     </span><span class="istickedoff">nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span>
<span class="lineno"> 2235 </span><span class="spaces">     </span><span class="istickedoff">io $ putStrLn $ prettyVerificationSummary opts nenv summary</span></span>
<span class="lineno"> 2236 </span>
<span class="lineno"> 2237 </span>summarize_verification_json :: FilePath -&gt; TopLevel ()
<span class="lineno"> 2238 </span><span class="decl"><span class="nottickedoff">summarize_verification_json fpath =</span>
<span class="lineno"> 2239 </span><span class="spaces">  </span><span class="nottickedoff">do values &lt;- rwProofs &lt;$&gt; getTopLevelRW</span>
<span class="lineno"> 2240 </span><span class="spaces">     </span><span class="nottickedoff">let jspecs  = [ s | SV.VJVMMethodSpec s &lt;- values ]</span>
<span class="lineno"> 2241 </span><span class="spaces">         </span><span class="nottickedoff">lspecs  = [ s | SV.VLLVMCrucibleMethodSpec s &lt;- values ]</span>
<span class="lineno"> 2242 </span><span class="spaces">         </span><span class="nottickedoff">thms    = [ t | SV.VTheorem t &lt;- values ]</span>
<span class="lineno"> 2243 </span><span class="spaces">     </span><span class="nottickedoff">db &lt;- SV.getTheoremDB</span>
<span class="lineno"> 2244 </span><span class="spaces">     </span><span class="nottickedoff">let summary = computeVerificationSummary db jspecs lspecs thms</span>
<span class="lineno"> 2245 </span><span class="spaces">     </span><span class="nottickedoff">io (writeFile fpath (jsonVerificationSummary summary))</span></span>
<span class="lineno"> 2246 </span>
<span class="lineno"> 2247 </span>writeVerificationSummary :: TopLevel ()
<span class="lineno"> 2248 </span><span class="decl"><span class="istickedoff">writeVerificationSummary = do</span>
<span class="lineno"> 2249 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno"> 2250 </span><span class="spaces">    </span><span class="istickedoff">db &lt;- SV.getTheoremDB</span>
<span class="lineno"> 2251 </span><span class="spaces">    </span><span class="istickedoff">values &lt;- <span class="nottickedoff">rwProofs</span> &lt;$&gt; getTopLevelRW</span>
<span class="lineno"> 2252 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">jspecs  = [ s | SV.VJVMMethodSpec s &lt;- values ]</span></span>
<span class="lineno"> 2253 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">lspecs  = [ s | SV.VLLVMCrucibleMethodSpec s &lt;- values ]</span></span>
<span class="lineno"> 2254 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">thms    = [ t | SV.VTheorem t &lt;- values ]</span></span>
<span class="lineno"> 2255 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">summary = computeVerificationSummary db jspecs lspecs thms</span></span>
<span class="lineno"> 2256 </span><span class="spaces">    </span><span class="istickedoff">opts &lt;- asks roOptions</span>
<span class="lineno"> 2257 </span><span class="spaces">    </span><span class="istickedoff">dir &lt;- asks <span class="nottickedoff">roInitWorkDir</span></span>
<span class="lineno"> 2258 </span><span class="spaces">    </span><span class="istickedoff">nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span>
<span class="lineno"> 2259 </span><span class="spaces">    </span><span class="istickedoff">ppOpts &lt;- getTopLevelPPOpts</span>
<span class="lineno"> 2260 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2261 </span><span class="spaces">    </span><span class="istickedoff">case summaryFile opts of</span>
<span class="lineno"> 2262 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno"> 2263 </span><span class="spaces">      </span><span class="istickedoff">Just f -&gt; <span class="nottickedoff">let</span></span>
<span class="lineno"> 2264 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">f' = if hasDrive f then f else dir &lt;/&gt; f</span></span>
<span class="lineno"> 2265 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">formatSummary = case summaryFormat opts of</span></span>
<span class="lineno"> 2266 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">JSON -&gt; jsonVerificationSummary</span></span>
<span class="lineno"> 2267 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">Pretty -&gt; prettyVerificationSummary ppOpts nenv</span></span>
<span class="lineno"> 2268 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">in io $ writeFile f' $ formatSummary summary</span></span></span>
<span class="lineno"> 2269 </span>
<span class="lineno"> 2270 </span>declare_ghost_state ::
<span class="lineno"> 2271 </span>  Text -&gt;
<span class="lineno"> 2272 </span>  TopLevel SV.Value
<span class="lineno"> 2273 </span><span class="decl"><span class="istickedoff">declare_ghost_state name =</span>
<span class="lineno"> 2274 </span><span class="spaces">  </span><span class="istickedoff">do allocator &lt;- getHandleAlloc</span>
<span class="lineno"> 2275 </span><span class="spaces">     </span><span class="istickedoff">global &lt;- liftIO (freshGlobalVar <span class="nottickedoff">allocator</span> name knownRepr)</span>
<span class="lineno"> 2276 </span><span class="spaces">     </span><span class="istickedoff">return (SV.VGhostVar global)</span></span>
<span class="lineno"> 2277 </span>
<span class="lineno"> 2278 </span>ghost_value ::
<span class="lineno"> 2279 </span>  MS.GhostGlobal -&gt;
<span class="lineno"> 2280 </span>  TypedTerm -&gt;
<span class="lineno"> 2281 </span>  SV.CrucibleSetup ext ()
<span class="lineno"> 2282 </span><span class="decl"><span class="istickedoff">ghost_value ghost val =</span>
<span class="lineno"> 2283 </span><span class="spaces">  </span><span class="istickedoff">do loc &lt;- SV.getW4Position &quot;ghost_value&quot;</span>
<span class="lineno"> 2284 </span><span class="spaces">     </span><span class="istickedoff">tags &lt;- view croTags</span>
<span class="lineno"> 2285 </span><span class="spaces">     </span><span class="istickedoff">let md = MS.ConditionMetadata</span>
<span class="lineno"> 2286 </span><span class="spaces">              </span><span class="istickedoff">{ MS.conditionLoc = loc</span>
<span class="lineno"> 2287 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionTags = tags</span>
<span class="lineno"> 2288 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionType = &quot;ghost value&quot;</span>
<span class="lineno"> 2289 </span><span class="spaces">              </span><span class="istickedoff">, MS.conditionContext = &quot;&quot;</span>
<span class="lineno"> 2290 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 2291 </span><span class="spaces">     </span><span class="istickedoff">addCondition (MS.SetupCond_Ghost md ghost val)</span></span>
<span class="lineno"> 2292 </span>
<span class="lineno"> 2293 </span>-- | Based on the function of the same name in SAWCore.ParserUtils.
<span class="lineno"> 2294 </span>-- Unlike that function, this calls 'fail' instead of 'error'.
<span class="lineno"> 2295 </span>--
<span class="lineno"> 2296 </span>-- XXX: we only need one; unify these once the error handling gets fixed.
<span class="lineno"> 2297 </span>readModuleFromFile :: FilePath -&gt; TopLevel (Un.Module, ModuleName)
<span class="lineno"> 2298 </span><span class="decl"><span class="istickedoff">readModuleFromFile path =</span>
<span class="lineno"> 2299 </span><span class="spaces">  </span><span class="istickedoff">do base &lt;- liftIO getCurrentDirectory</span>
<span class="lineno"> 2300 </span><span class="spaces">     </span><span class="istickedoff">txt &lt;- liftIO $ TLIO.readFile path</span>
<span class="lineno"> 2301 </span><span class="spaces">     </span><span class="istickedoff">case parseSAW base path txt of</span>
<span class="lineno"> 2302 </span><span class="spaces">       </span><span class="istickedoff">Right m@(Un.Module (Un.PosPair _ mnm) _ _) -&gt; pure (m, <span class="nottickedoff">mnm</span>)</span>
<span class="lineno"> 2303 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt; fail $ &quot;Module parsing failed:\n&quot; ++ show err</span></span>
<span class="lineno"> 2304 </span>
<span class="lineno"> 2305 </span>load_sawcore_from_file :: FilePath -&gt; TopLevel ()
<span class="lineno"> 2306 </span><span class="decl"><span class="istickedoff">load_sawcore_from_file mod_filename =</span>
<span class="lineno"> 2307 </span><span class="spaces">  </span><span class="istickedoff">do sc &lt;- getSharedContext</span>
<span class="lineno"> 2308 </span><span class="spaces">     </span><span class="istickedoff">(saw_mod, _) &lt;- readModuleFromFile mod_filename</span>
<span class="lineno"> 2309 </span><span class="spaces">     </span><span class="istickedoff">liftIO $ tcInsertModule sc saw_mod</span></span>

</pre>
</body>
</html>
