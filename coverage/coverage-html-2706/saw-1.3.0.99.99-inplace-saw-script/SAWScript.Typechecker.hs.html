<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Typechecker
<span class="lineno">    3 </span>Description : SAW-Script type checking.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : diatchki
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   10 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   11 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   12 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   14 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   15 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   16 </span>-- See Note [-Wincomplete-uni-patterns and irrefutable patterns]
<span class="lineno">   17 </span>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>module SAWScript.Typechecker
<span class="lineno">   20 </span>       ( checkDecl
<span class="lineno">   21 </span>       , checkStmt
<span class="lineno">   22 </span>       , typesMatch
<span class="lineno">   23 </span>       , checkSchemaPattern
<span class="lineno">   24 </span>       ) where
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>import Control.Monad (when, zipWithM, zipWithM_)
<span class="lineno">   27 </span>import Control.Monad.Reader (MonadReader(..), ReaderT(..), asks)
<span class="lineno">   28 </span>import Control.Monad.State (MonadState(..), StateT, gets, modify, runState)
<span class="lineno">   29 </span>import Control.Monad.Identity (Identity)
<span class="lineno">   30 </span>import qualified Data.Text as Text
<span class="lineno">   31 </span>import Data.List (intercalate, genericTake)
<span class="lineno">   32 </span>import Data.Map (Map)
<span class="lineno">   33 </span>import Data.Either (partitionEithers)
<span class="lineno">   34 </span>import qualified Data.Map as M
<span class="lineno">   35 </span>import Data.Set (Set)
<span class="lineno">   36 </span>import qualified Data.Set as S
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>import qualified Prettyprinter as PP
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>import SAWSupport.Pretty (pShow)
<span class="lineno">   41 </span>import qualified SAWSupport.Pretty as PPS
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>import SAWCentral.AST
<span class="lineno">   44 </span>import SAWCentral.ASTUtil (namedTyVars, SubstituteTyVars(..), isDeprecated)
<span class="lineno">   45 </span>import SAWScript.Panic (panic)
<span class="lineno">   46 </span>import SAWCentral.Position (Inference(..), Pos(..), Positioned(..), choosePos)
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>-- short names for the environment types we use
<span class="lineno">   50 </span>type VarEnv = Map LName (PrimitiveLifecycle, Schema)
<span class="lineno">   51 </span>type TyEnv = Map Name (PrimitiveLifecycle, NamedType)
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>------------------------------------------------------------
<span class="lineno">   55 </span>-- UnifyVars {{{
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>--
<span class="lineno">   58 </span>-- unifyVars is a type-class-polymorphic function for extracting
<span class="lineno">   59 </span>-- unification vars from a type or type schema. It returns a set of
<span class="lineno">   60 </span>-- TypeIndex (TypeIndex is just Integer) manifested as a map from
<span class="lineno">   61 </span>-- those TypeIndexes to their positions/provenance.
<span class="lineno">   62 </span>--
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>class UnifyVars t where
<span class="lineno">   65 </span>  unifyVars :: t -&gt; M.Map TypeIndex Pos
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>instance (Ord k, UnifyVars a) =&gt; UnifyVars (M.Map k a) where
<span class="lineno">   68 </span>  <span class="decl"><span class="istickedoff">unifyVars = unifyVars . M.elems</span></span>
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>instance (UnifyVars a) =&gt; UnifyVars [a] where
<span class="lineno">   71 </span>  <span class="decl"><span class="istickedoff">unifyVars = M.unionsWith <span class="nottickedoff">choosePos</span> . map unifyVars</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>instance (UnifyVars a) =&gt; UnifyVars (PrimitiveLifecycle, a) where
<span class="lineno">   74 </span>  <span class="decl"><span class="istickedoff">unifyVars (_lc, t) = unifyVars t</span></span>
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>instance UnifyVars Type where
<span class="lineno">   77 </span>  <span class="decl"><span class="istickedoff">unifyVars t = case t of</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="istickedoff">TyCon _ _ ts      -&gt; unifyVars ts</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="istickedoff">TyRecord _ tm     -&gt; unifyVars tm</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ _         -&gt; M.empty</span>
<span class="lineno">   81 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar pos i  -&gt; M.singleton i pos</span></span>
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>instance UnifyVars Schema where
<span class="lineno">   84 </span>  <span class="decl"><span class="istickedoff">unifyVars (Forall _ t) = unifyVars t</span></span>
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>instance UnifyVars NamedType where
<span class="lineno">   87 </span>  <span class="decl"><span class="istickedoff">unifyVars nt = case nt of</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">ConcreteType ty -&gt; <span class="nottickedoff">unifyVars ty</span></span>
<span class="lineno">   89 </span><span class="spaces">    </span><span class="istickedoff">AbstractType -&gt; M.empty</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>-- }}}
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>------------------------------------------------------------
<span class="lineno">   95 </span>-- Substitutions {{{
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- Subst is the type of a substitution map for unification vars.
<span class="lineno">   98 </span>newtype Subst = Subst { <span class="istickedoff"><span class="decl"><span class="istickedoff">unSubst</span></span></span> :: M.Map TypeIndex Type } deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>-- Merge two substitution maps.
<span class="lineno">  101 </span>--
<span class="lineno">  102 </span>-- XXX: this knows that in the uses below the right substitution (m1)
<span class="lineno">  103 </span>-- is the older/preexisting one. That probably shouldn't be silently
<span class="lineno">  104 </span>-- baked in.
<span class="lineno">  105 </span>--
<span class="lineno">  106 </span>-- We apply the left substitution (m2) into the types in the right
<span class="lineno">  107 </span>-- substitution (m1). That is, any new substitutions are applied into
<span class="lineno">  108 </span>-- the existing ones. I expect this in pursuit of an invariant where
<span class="lineno">  109 </span>-- any unification variables existing in the right-hand sides of the
<span class="lineno">  110 </span>-- substitution aren't themselves defined by the substitution, so we
<span class="lineno">  111 </span>-- don't have to recurse into the right-hand sides later when applying
<span class="lineno">  112 </span>-- the substitution.
<span class="lineno">  113 </span>--
<span class="lineno">  114 </span>-- XXX: However, this assumes that whatever is on the left-hand side
<span class="lineno">  115 </span>-- doesn't already violate this invariant. We can check this with
<span class="lineno">  116 </span>-- reasonable accuracy since we have right here all the ways to create
<span class="lineno">  117 </span>-- a Subst (and we can check that there aren't any others hidden
<span class="lineno">  118 </span>-- below)... and we find that while emptySubst is obviously ok, and
<span class="lineno">  119 </span>-- singletonSubst is ok (an attempt to create a singleton substitution
<span class="lineno">  120 </span>-- that refers to itself will fail the occurs check right before
<span class="lineno">  121 </span>-- calling singletonSubst), there doesn't seem to be any such
<span class="lineno">  122 </span>-- assurance for substFromList. I'm not sure if this is actually a
<span class="lineno">  123 </span>-- problem or not but it should probably be looked into at some point.
<span class="lineno">  124 </span>--
<span class="lineno">  125 </span>-- XXX: we should probably crosscheck the key space of the maps. Note
<span class="lineno">  126 </span>-- that the ordering of the M.union args means that if there are
<span class="lineno">  127 </span>-- duplicated keys we prefer the right substitution (m1), namely the
<span class="lineno">  128 </span>-- preexisting one. Given that this choice seems to be explicit, it
<span class="lineno">  129 </span>-- must have been for a reason, but I'm not sure what that reason
<span class="lineno">  130 </span>-- would be. Ordinarily in this kind of typechecker you might update a
<span class="lineno">  131 </span>-- substitution you've already made, but only when replacing a weak
<span class="lineno">  132 </span>-- substitution (one unification var for another, like a1 -&gt; a2) with
<span class="lineno">  133 </span>-- a strong one (involving a real type, like a1 -&gt; Int)... but if so
<span class="lineno">  134 </span>-- it would always be the _new_ substitution you'd want to keep.
<span class="lineno">  135 </span>-- However, in this particular code we always apply the existing
<span class="lineno">  136 </span>-- substitution before doing further unification, so once we have any
<span class="lineno">  137 </span>-- substitution for a given unification var we shouldn't get another.
<span class="lineno">  138 </span>-- (Unless I guess if the intended invariant above is violated, but if
<span class="lineno">  139 </span>-- that happens we should probably panic, not chug along.)
<span class="lineno">  140 </span>--
<span class="lineno">  141 </span>-- XXX: also it isn't clear that anything below guarantees that we
<span class="lineno">  142 </span>-- won't just derive multiple inconsistent substitutions (e.g. from
<span class="lineno">  143 </span>-- disjoint subexpressions) and combine them incoherently. This should
<span class="lineno">  144 </span>-- really be looked into further.
<span class="lineno">  145 </span>--
<span class="lineno">  146 </span>-- XXX: and _furthermore_ it's not clear that we can't get cyclic
<span class="lineno">  147 </span>-- substitutions. If we already have a substitution a1 -&gt; a2, and we
<span class="lineno">  148 </span>-- add a2 -&gt; a1, we'll resolve the existing substitution to a1 -&gt; a1
<span class="lineno">  149 </span>-- rather than going directly into an infinite loop. That's not
<span class="lineno">  150 </span>-- necessarily preferable though. Normally in this kind of typechecker
<span class="lineno">  151 </span>-- one also wants some kind of acyclicity-oriented invariant, like
<span class="lineno">  152 </span>-- aN resolves to aM only if N &gt; M (otherwise you substitute the other
<span class="lineno">  153 </span>-- way) but we don't do anything like that.
<span class="lineno">  154 </span>--
<span class="lineno">  155 </span>-- When all the above issues get clarified we should consider coming
<span class="lineno">  156 </span>-- up with a different name that indicates that this operation isn't
<span class="lineno">  157 </span>-- commutative. Unless it actually can be.
<span class="lineno">  158 </span>mergeSubst :: Subst -&gt; Subst -&gt; Subst
<span class="lineno">  159 </span><span class="decl"><span class="istickedoff">mergeSubst s2@(Subst m2) (Subst m1) = Subst $ m1' `M.union` m2</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="istickedoff">m1' = fmap (appSubst s2) m1</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>emptySubst :: Subst
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">emptySubst = Subst M.empty</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>singletonSubst :: TypeIndex -&gt; Type -&gt; Subst
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff">singletonSubst tv t = Subst $ M.singleton tv t</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>substFromList :: [(TypeIndex, Type)] -&gt; Subst
<span class="lineno">  170 </span><span class="decl"><span class="istickedoff">substFromList entries = Subst $ M.fromList entries</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>--
<span class="lineno">  173 </span>-- appSubst is a type-class-polymorphic function for applying a
<span class="lineno">  174 </span>-- substitution (of numbered unification vars) to AST elements.
<span class="lineno">  175 </span>--
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>class AppSubst t where
<span class="lineno">  178 </span>  appSubst :: Subst -&gt; t -&gt; t
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>instance (AppSubst t) =&gt; AppSubst (Maybe t) where
<span class="lineno">  181 </span>  <span class="decl"><span class="istickedoff">appSubst s = fmap $ appSubst s</span></span>
<span class="lineno">  182 </span>
<span class="lineno">  183 </span>instance (AppSubst t) =&gt; AppSubst [t] where
<span class="lineno">  184 </span>  <span class="decl"><span class="istickedoff">appSubst s = map $ appSubst s</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>instance (AppSubst t) =&gt; AppSubst (PrimitiveLifecycle, t) where
<span class="lineno">  187 </span>  <span class="decl"><span class="istickedoff">appSubst s (lc, x) = (<span class="nottickedoff">lc</span>, appSubst <span class="nottickedoff">s</span> x)</span></span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>instance (Ord k, AppSubst a) =&gt; AppSubst (M.Map k a) where
<span class="lineno">  190 </span>  <span class="decl"><span class="istickedoff">appSubst s = fmap (appSubst s)</span></span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>instance AppSubst Expr where
<span class="lineno">  193 </span>  <span class="decl"><span class="istickedoff">appSubst s expr = case expr of</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">TSig pos e t           -&gt; <span class="nottickedoff">TSig pos (appSubst s e) (appSubst s t)</span></span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">Bool _ _               -&gt; <span class="nottickedoff">expr</span></span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">String _ _             -&gt; expr</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">Int _ _                -&gt; expr</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">Code _                 -&gt; expr</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">CType _                -&gt; expr</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">Array pos es           -&gt; Array <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> es)</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">Block pos (bs, e)      -&gt; Block <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> bs, appSubst <span class="nottickedoff">s</span> e)</span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff">Tuple pos es           -&gt; Tuple <span class="nottickedoff">pos</span> (appSubst s es)</span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff">Record pos fs          -&gt; Record <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> fs)</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">Index pos ar ix        -&gt; <span class="nottickedoff">Index pos (appSubst s ar) (appSubst s ix)</span></span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">Lookup pos rec fld     -&gt; <span class="nottickedoff">Lookup pos (appSubst s rec) fld</span></span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">TLookup pos tpl idx    -&gt; <span class="nottickedoff">TLookup pos (appSubst s tpl) idx</span></span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">Var _                  -&gt; expr</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">Lambda pos mname pat body -&gt; Lambda <span class="nottickedoff">pos</span> mname (appSubst s pat) (appSubst <span class="nottickedoff">s</span> body)</span>
<span class="lineno">  209 </span><span class="spaces">    </span><span class="istickedoff">Application pos f v    -&gt; Application pos (appSubst <span class="nottickedoff">s</span> f) (appSubst s v)</span>
<span class="lineno">  210 </span><span class="spaces">    </span><span class="istickedoff">Let pos dg e           -&gt; Let <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> dg) (appSubst <span class="nottickedoff">s</span> e)</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">IfThenElse pos e e2 e3 -&gt; IfThenElse <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> e) (appSubst <span class="nottickedoff">s</span> e2) (appSubst <span class="nottickedoff">s</span> e3)</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>instance AppSubst Pattern where
<span class="lineno">  214 </span>  <span class="decl"><span class="istickedoff">appSubst s pat = case pat of</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="istickedoff">PWild pos mt  -&gt; PWild <span class="nottickedoff">pos</span> (appSubst s mt)</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">PVar pos x mt -&gt; PVar <span class="nottickedoff">pos</span> x (appSubst s mt)</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">PTuple pos ps -&gt; PTuple <span class="nottickedoff">pos</span> (appSubst s ps)</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>instance AppSubst Stmt where
<span class="lineno">  220 </span>  <span class="decl"><span class="istickedoff">appSubst s bst = case bst of</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">StmtBind pos pat e       -&gt; StmtBind pos (appSubst s pat) (appSubst s e)</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">StmtLet pos dg           -&gt; StmtLet <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> dg)</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">StmtCode pos str         -&gt; StmtCode <span class="nottickedoff">pos</span> str</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">StmtImport pos imp       -&gt; StmtImport <span class="nottickedoff">pos</span> imp</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">StmtTypedef pos name ty  -&gt; StmtTypedef <span class="nottickedoff">pos</span> name (appSubst <span class="nottickedoff">s</span> ty)</span></span>
<span class="lineno">  226 </span>
<span class="lineno">  227 </span>instance AppSubst DeclGroup where
<span class="lineno">  228 </span>  <span class="decl"><span class="istickedoff">appSubst s (Recursive ds) = Recursive (appSubst <span class="nottickedoff">s</span> ds)</span>
<span class="lineno">  229 </span><span class="spaces">  </span><span class="istickedoff">appSubst s (NonRecursive d) = NonRecursive (appSubst <span class="nottickedoff">s</span> d)</span></span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>instance AppSubst Decl where
<span class="lineno">  232 </span>  <span class="decl"><span class="istickedoff">appSubst s (Decl pos p mt e) = Decl <span class="nottickedoff">pos</span> (appSubst <span class="nottickedoff">s</span> p) (appSubst <span class="nottickedoff">s</span> mt) (appSubst <span class="nottickedoff">s</span> e)</span></span>
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>instance AppSubst Type where
<span class="lineno">  235 </span>  <span class="decl"><span class="istickedoff">appSubst s t = case t of</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">TyCon pos tc ts     -&gt; TyCon pos tc (appSubst s ts)</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">TyRecord pos fs     -&gt; TyRecord pos (appSubst s fs)</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">TyVar _ _           -&gt; t</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _ i      -&gt; case M.lookup i (unSubst s) of</span>
<span class="lineno">  240 </span><span class="spaces">                             </span><span class="istickedoff">Just t' -&gt; t'</span>
<span class="lineno">  241 </span><span class="spaces">                             </span><span class="istickedoff">Nothing -&gt; t</span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>instance AppSubst Schema where
<span class="lineno">  244 </span>  <span class="decl"><span class="istickedoff">appSubst s (Forall ns t) = Forall ns (appSubst <span class="nottickedoff">s</span> t)</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>instance AppSubst NamedType where
<span class="lineno">  247 </span>  <span class="decl"><span class="istickedoff">appSubst s nt = case nt of</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">ConcreteType ty -&gt; <span class="nottickedoff">ConcreteType $ appSubst s ty</span></span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="istickedoff">AbstractType -&gt; AbstractType</span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-- }}}
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>------------------------------------------------------------
<span class="lineno">  255 </span>-- Kinds {{{
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>--
<span class="lineno">  258 </span>-- For the time being we can handle kinds using the number of expected
<span class="lineno">  259 </span>-- type arguments. That is, Kind 0 is *. Apart from tuples the only
<span class="lineno">  260 </span>-- things we have are of kinds *, * -&gt; *, and * -&gt; * -&gt; *, but we do
<span class="lineno">  261 </span>-- have tuples of arbitrary arity.
<span class="lineno">  262 </span>--
<span class="lineno">  263 </span>-- If we ever want additional structure (e.g. distinguishing the
<span class="lineno">  264 </span>-- monad/context types from other types) we can extend this
<span class="lineno">  265 </span>-- representation easily enough.
<span class="lineno">  266 </span>--
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>newtype Kind = Kind { <span class="istickedoff"><span class="decl"><span class="istickedoff">kindNumArgs</span></span></span> :: Int }
<span class="lineno">  269 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Eq</span></span></span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>kindStar :: Kind
<span class="lineno">  272 </span><span class="decl"><span class="istickedoff">kindStar = Kind 0</span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>-- these aren't currently used
<span class="lineno">  275 </span>--kindStarToStar :: Kind
<span class="lineno">  276 </span>--kindStarToStar = Kind 1
<span class="lineno">  277 </span>--
<span class="lineno">  278 </span>--kindStarToStarToStar :: Kind
<span class="lineno">  279 </span>--kindStarToStarToStar = Kind 2
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>instance PPS.PrettyPrec Kind where
<span class="lineno">  282 </span>  <span class="decl"><span class="nottickedoff">prettyPrec _ (Kind n) =</span>
<span class="lineno">  283 </span><span class="spaces">     </span><span class="nottickedoff">PP.viaShow $ intercalate &quot; -&gt; &quot; $ take (n + 1) $ repeat &quot;*&quot;</span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>-- }}}
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>------------------------------------------------------------
<span class="lineno">  290 </span>-- Pass context {{{
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>--
<span class="lineno">  293 </span>-- The monad for this pass is &quot;TI&quot;, which is composed of a &quot;readonly&quot;
<span class="lineno">  294 </span>-- part (which is not constant or readonly, but where changes are
<span class="lineno">  295 </span>-- scoped by the recursive structure of the code) and a read-write
<span class="lineno">  296 </span>-- part that accumulates as we move through the code.
<span class="lineno">  297 </span>--
<span class="lineno">  298 </span>-- XXX: the &quot;readonly&quot; part is used to implement scoping, which is
<span class="lineno">  299 </span>-- fine in theory, but in practice because we have declarations that
<span class="lineno">  300 </span>-- update the environment, the recursive structure of the code does
<span class="lineno">  301 </span>-- not naturally match the scoping. The result is that the recursive
<span class="lineno">  302 </span>-- structure of the code has been twisted around to make it work;
<span class="lineno">  303 </span>-- that isn't desirable and the organization should probably be
<span class="lineno">  304 </span>-- revised.
<span class="lineno">  305 </span>--
<span class="lineno">  306 </span>-- Anyhow, the elements of the context are split across RO and RW
<span class="lineno">  307 </span>-- below.
<span class="lineno">  308 </span>--
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>newtype TI a = TI { <span class="istickedoff"><span class="decl"><span class="istickedoff">unTI</span></span></span> :: ReaderT RO (StateT RW Identity) a }
<span class="lineno">  311 </span>                        deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>,<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>,<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>,<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadReader RO</span></span></span></span></span></span>)
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>-- | The &quot;readonly&quot; portion
<span class="lineno">  314 </span>data RO = RO
<span class="lineno">  315 </span>  {
<span class="lineno">  316 </span>    -- | The variable availability (lifecycle set)
<span class="lineno">  317 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">primsAvail</span></span></span> :: Set PrimitiveLifecycle,
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>    -- | The variable typing environment (variable name to type scheme)
<span class="lineno">  320 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">varEnv</span></span></span> :: VarEnv,
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>    -- | The type environment: named type variables, which are either
<span class="lineno">  323 </span>    --   typedefs (map to ConcreteType) or abstract types (AbstractType)
<span class="lineno">  324 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">tyEnv</span></span></span> :: TyEnv
<span class="lineno">  325 </span>  }
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | The read-write portion
<span class="lineno">  328 </span>data RW = RW
<span class="lineno">  329 </span>  {
<span class="lineno">  330 </span>    -- | The next fresh unification var number
<span class="lineno">  331 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">nextTypeIndex</span></span></span> :: TypeIndex,
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>    -- | The unification var substitution we're accumulating
<span class="lineno">  334 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">subst</span></span></span> :: Subst,
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>    -- | Any type errors and warnings we've generated so far
<span class="lineno">  337 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">errors</span></span></span> :: [(Pos, String)],
<span class="lineno">  338 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">warnings</span></span></span> :: [(Pos, String)]
<span class="lineno">  339 </span>  }
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>emptyRW :: RW
<span class="lineno">  342 </span><span class="decl"><span class="istickedoff">emptyRW = RW</span>
<span class="lineno">  343 </span><span class="spaces">  </span><span class="istickedoff">{ nextTypeIndex = 0</span>
<span class="lineno">  344 </span><span class="spaces">  </span><span class="istickedoff">, subst = emptySubst</span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">, errors = []</span>
<span class="lineno">  346 </span><span class="spaces">  </span><span class="istickedoff">, warnings = []</span>
<span class="lineno">  347 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>-- Get a fresh unification var number.
<span class="lineno">  350 </span>getFreshTypeIndex :: TI TypeIndex
<span class="lineno">  351 </span><span class="decl"><span class="istickedoff">getFreshTypeIndex = do</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- TI get</span>
<span class="lineno">  353 </span><span class="spaces">  </span><span class="istickedoff">TI $ put $ rw { nextTypeIndex = nextTypeIndex rw + 1 }</span>
<span class="lineno">  354 </span><span class="spaces">  </span><span class="istickedoff">return $ nextTypeIndex rw</span></span>
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>-- Construct a fresh type variable.
<span class="lineno">  357 </span>--
<span class="lineno">  358 </span>-- Collect the position that prompted us to make it; for example, if
<span class="lineno">  359 </span>-- we're the element type of an empty list we get the position of the
<span class="lineno">  360 </span>-- []. We haven't inferred anything, so use the InfFresh position.
<span class="lineno">  361 </span>-- This will cause the position of anything more substantive that gets
<span class="lineno">  362 </span>-- unified with it to be preferred. If no such thing happens though
<span class="lineno">  363 </span>-- this will be the position that gets attached to the quantifier
<span class="lineno">  364 </span>-- binding in generalize.
<span class="lineno">  365 </span>getFreshTyVar :: Pos -&gt; TI Type
<span class="lineno">  366 </span><span class="decl"><span class="istickedoff">getFreshTyVar pos = TyUnifyVar (PosInferred InfFresh pos) &lt;$&gt; getFreshTypeIndex</span></span>
<span class="lineno">  367 </span>
<span class="lineno">  368 </span>-- Construct a new type variable to use as a placeholder after an
<span class="lineno">  369 </span>-- error occurs. For now this is the same as other fresh type
<span class="lineno">  370 </span>-- variables, but I've split it out in case we want to distinguish it
<span class="lineno">  371 </span>-- in the future.
<span class="lineno">  372 </span>getErrorTyVar :: Pos -&gt; TI Type
<span class="lineno">  373 </span><span class="decl"><span class="istickedoff">getErrorTyVar pos = getFreshTyVar <span class="nottickedoff">pos</span></span></span>
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>-- Add an error message.
<span class="lineno">  376 </span>recordError :: Pos -&gt; String -&gt; TI ()
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">recordError pos err = do</span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">TI $ modify $ \rw -&gt; rw { errors = (pos, err) : errors rw }</span></span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>-- Add a warning message.
<span class="lineno">  381 </span>recordWarning :: Pos -&gt; String -&gt; TI ()
<span class="lineno">  382 </span><span class="decl"><span class="istickedoff">recordWarning pos msg = do</span>
<span class="lineno">  383 </span><span class="spaces">  </span><span class="istickedoff">TI $ modify $ \rw -&gt; rw { warnings = (pos, msg) : warnings rw }</span></span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>-- Apply the current substitution with appSubst.
<span class="lineno">  386 </span>applyCurrentSubst :: AppSubst t =&gt; t -&gt; TI t
<span class="lineno">  387 </span><span class="decl"><span class="istickedoff">applyCurrentSubst t = do</span>
<span class="lineno">  388 </span><span class="spaces">  </span><span class="istickedoff">s &lt;- TI $ gets subst</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="istickedoff">return $ appSubst s t</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>-- Apply the current typedef collection with substituteTyVars.
<span class="lineno">  392 </span>--
<span class="lineno">  393 </span>-- The type t has already been checked, so it's ok to panic if it refers
<span class="lineno">  394 </span>-- to something in the typedef collection that's not visible.
<span class="lineno">  395 </span>resolveCurrentTypedefs :: SubstituteTyVars t =&gt; t -&gt; TI t
<span class="lineno">  396 </span><span class="decl"><span class="istickedoff">resolveCurrentTypedefs t = do</span>
<span class="lineno">  397 </span><span class="spaces">  </span><span class="istickedoff">avail &lt;- TI $ asks primsAvail</span>
<span class="lineno">  398 </span><span class="spaces">  </span><span class="istickedoff">s &lt;- TI $ asks tyEnv</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="istickedoff">return $ substituteTyVars avail s t</span></span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>-- Get the unification vars that are used in the current variable typing
<span class="lineno">  402 </span>-- and named type environments.
<span class="lineno">  403 </span>--
<span class="lineno">  404 </span>-- FIXME: This function may miss type variables that occur in the type
<span class="lineno">  405 </span>-- of a binding that has been shadowed by another value with the same
<span class="lineno">  406 </span>-- name. This could potentially cause a run-time type error if the
<span class="lineno">  407 </span>-- type of a local function gets generalized too much. We can probably
<span class="lineno">  408 </span>-- wait to fix it until someone finds a sawscript program that breaks.
<span class="lineno">  409 </span>--
<span class="lineno">  410 </span>-- dholland 20241220: I don't think that's a problem. If there's a
<span class="lineno">  411 </span>-- loose unification var somewhere that's been shadowed to the point
<span class="lineno">  412 </span>-- where it's not accessible, we can't have accessed it in order to
<span class="lineno">  413 </span>-- generate a reference to it in the current block. If it is somewhere
<span class="lineno">  414 </span>-- accessible, we'll find it there. This might have broken in the past
<span class="lineno">  415 </span>-- when it didn't search the named type environment, but that leak has
<span class="lineno">  416 </span>-- been corrected.
<span class="lineno">  417 </span>--
<span class="lineno">  418 </span>-- Note that we apply the current substitution first. This means that
<span class="lineno">  419 </span>-- the caller must also apply the current substitution before reasoning
<span class="lineno">  420 </span>-- about what unification vars do and don't appear.
<span class="lineno">  421 </span>--
<span class="lineno">  422 </span>-- Returns a map of the index number to the occurrence position.
<span class="lineno">  423 </span>unifyVarsInEnvs :: TI (M.Map TypeIndex Pos)
<span class="lineno">  424 </span><span class="decl"><span class="istickedoff">unifyVarsInEnvs = do</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="istickedoff">venv &lt;- TI $ asks varEnv</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="istickedoff">tenv &lt;- TI $ asks tyEnv</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="istickedoff">vtys &lt;- mapM applyCurrentSubst $ M.elems venv</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">ttys &lt;- mapM applyCurrentSubst $ M.elems tenv</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">return $ M.unionWith <span class="nottickedoff">choosePos</span> (unifyVars vtys) (unifyVars ttys)</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- Get the named type vars that occur as keys in the current type name
<span class="lineno">  432 </span>-- environment.
<span class="lineno">  433 </span>namedVarDefinitions :: TI (S.Set Name)
<span class="lineno">  434 </span><span class="decl"><span class="istickedoff">namedVarDefinitions = do</span>
<span class="lineno">  435 </span><span class="spaces">   </span><span class="istickedoff">env &lt;- TI $ asks tyEnv</span>
<span class="lineno">  436 </span><span class="spaces">   </span><span class="istickedoff">return $ M.keysSet env</span></span>
<span class="lineno">  437 </span>
<span class="lineno">  438 </span>-- Get the position and name of the first binding in a pattern,
<span class="lineno">  439 </span>-- for use as context info when printing messages. If there's a
<span class="lineno">  440 </span>-- real variable, prefer that (Right cases); otherwise take the
<span class="lineno">  441 </span>-- position of the first wildcard or empty tuple (Left cases).
<span class="lineno">  442 </span>patternLName :: Pattern -&gt; LName
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">patternLName pat0 =</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">case visit pat0 of</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">Left pos -&gt; <span class="nottickedoff">Located &quot;_&quot; &quot;_&quot; pos</span></span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">Right n -&gt; n</span>
<span class="lineno">  447 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">visit pat =</span>
<span class="lineno">  449 </span><span class="spaces">      </span><span class="istickedoff">case pat of</span>
<span class="lineno">  450 </span><span class="spaces">        </span><span class="istickedoff">PWild pos _ -&gt; <span class="nottickedoff">Left pos</span></span>
<span class="lineno">  451 </span><span class="spaces">        </span><span class="istickedoff">PVar _ n _ -&gt; Right n</span>
<span class="lineno">  452 </span><span class="spaces">        </span><span class="istickedoff">PTuple pos [] -&gt; <span class="nottickedoff">Left pos</span></span>
<span class="lineno">  453 </span><span class="spaces">        </span><span class="istickedoff">PTuple allpos ps -&gt;</span>
<span class="lineno">  454 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case partitionEithers $ map visit ps of</span></span>
<span class="lineno">  455 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(_, n : _) -&gt; Right n</span></span>
<span class="lineno">  456 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">(pos : _, _) -&gt; Left pos</span></span>
<span class="lineno">  457 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Left allpos</span></span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>-- Get all the bindings in a pattern.
<span class="lineno">  460 </span>patternBindings :: Pattern -&gt; [(Located Name, Maybe Type)]
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">patternBindings pat =</span>
<span class="lineno">  462 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">PWild _ _mt -&gt; []</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">PVar _ x mt -&gt; [(x, mt)]</span>
<span class="lineno">  465 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ ps -&gt; concatMap patternBindings ps</span></span>
<span class="lineno">  466 </span>
<span class="lineno">  467 </span>-- }}}
<span class="lineno">  468 </span>
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>------------------------------------------------------------
<span class="lineno">  471 </span>-- Unification {{{
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>--
<span class="lineno">  474 </span>-- Error reporting.
<span class="lineno">  475 </span>--
<span class="lineno">  476 </span>-- When we find a mismatch, we have potentially recursed arbitrarily
<span class="lineno">  477 </span>-- deeply into the original type. We need to print the specific types
<span class="lineno">  478 </span>-- we trip on (this is important if they are e.g. elements in a large
<span class="lineno">  479 </span>-- system of nested records and typles) but we also want to print the
<span class="lineno">  480 </span>-- rest of the original context as well.
<span class="lineno">  481 </span>--
<span class="lineno">  482 </span>-- Therefore, we start with an initial descriptive message plus (in
<span class="lineno">  483 </span>-- most cases) a pair of expected and found types. Once we fail, we
<span class="lineno">  484 </span>-- add more expected/found type pairs on the way out of the recursion,
<span class="lineno">  485 </span>-- so we print every layer of the type.
<span class="lineno">  486 </span>--
<span class="lineno">  487 </span>-- As a special case, we keep only the outermost of a series of nested
<span class="lineno">  488 </span>-- function types, and drop the nested ones. Because functions are
<span class="lineno">  489 </span>-- curried, this prints the complete function signature once and skips
<span class="lineno">  490 </span>-- the incremental types completed by consuming each argument. (These
<span class="lineno">  491 </span>-- add little information and can also confuse casual users.)
<span class="lineno">  492 </span>--
<span class="lineno">  493 </span>-- The FailMGU type tracks this material. It contains three elements:
<span class="lineno">  494 </span>--    * the initial message
<span class="lineno">  495 </span>--    * the list of pairs of expected/found messages
<span class="lineno">  496 </span>--    * the current function-type expected/found message, if any
<span class="lineno">  497 </span>--
<span class="lineno">  498 </span>-- Empty strings are inserted between pairs to make the output more
<span class="lineno">  499 </span>-- readable.
<span class="lineno">  500 </span>--
<span class="lineno">  501 </span>-- Note that we print the messages on the fly rather than accumulating
<span class="lineno">  502 </span>-- a list of type pairs and printing them at the end. (That may have
<span class="lineno">  503 </span>-- been a mistake; we'll see.)
<span class="lineno">  504 </span>--
<span class="lineno">  505 </span>-- The last element (current function-type expected/found message) is
<span class="lineno">  506 </span>-- always either a list of two message strings or empty. Function types
<span class="lineno">  507 </span>-- we see go in it (replacing anything already there, so we keep only
<span class="lineno">  508 </span>-- the outermost of a series) and are shifted out of it when we see
<span class="lineno">  509 </span>-- something else. It could be a Maybe (String, String), but the code
<span class="lineno">  510 </span>-- is noticeably more convenient the way it is.
<span class="lineno">  511 </span>--
<span class="lineno">  512 </span>-- The initial message is kept separate so that the expected/found
<span class="lineno">  513 </span>-- list can readily be built in either order. It's not clear if it's
<span class="lineno">  514 </span>-- better to print the outermost or innermost mismatches first.
<span class="lineno">  515 </span>--
<span class="lineno">  516 </span>-- Further notes on the message formatting:
<span class="lineno">  517 </span>--
<span class="lineno">  518 </span>-- Print the expected and found types on their own lines. They can be
<span class="lineno">  519 </span>-- large; if they are the resulting lines can still be fairly
<span class="lineno">  520 </span>-- illegible, but at least the user doesn't have to hunt for &quot;found&quot;
<span class="lineno">  521 </span>-- in the middle of a multi-line print.
<span class="lineno">  522 </span>--
<span class="lineno">  523 </span>-- Pad the prefix of the prints so that the types line up; this is
<span class="lineno">  524 </span>-- helpful for longer types that still fit on one output line.
<span class="lineno">  525 </span>--
<span class="lineno">  526 </span>-- We'll indent each line with four spaces. What we send back gets
<span class="lineno">  527 </span>-- printed underneath a message that's already (at least in some
<span class="lineno">  528 </span>-- cases) indented by two spaces. It's important to make it clear that
<span class="lineno">  529 </span>-- all the stuff we generate is part of that message and not, for
<span class="lineno">  530 </span>-- example, an additional separate error. The indenting happens below.
<span class="lineno">  531 </span>--
<span class="lineno">  532 </span>-- Note that although we append to the end of the expected/found list,
<span class="lineno">  533 </span>-- we don't stick the start line in that list, because I keep going
<span class="lineno">  534 </span>-- back and forth on whether the larger types should be printed first
<span class="lineno">  535 </span>-- (prepending in failMGUadd) or last (appending). If we commit to
<span class="lineno">  536 </span>-- appending we don't need to keep the start line separate.
<span class="lineno">  537 </span>--
<span class="lineno">  538 </span>
<span class="lineno">  539 </span>data FailMGU = FailMGU
<span class="lineno">  540 </span>                    [String]    -- initial error message (often multiple lines)
<span class="lineno">  541 </span>                    [String]    -- list of found/expected message pairs
<span class="lineno">  542 </span>                    [String]    -- current found/expected function pair if any
<span class="lineno">  543 </span>
<span class="lineno">  544 </span>-- common code for printing expected/found types
<span class="lineno">  545 </span>showTypes :: Type -&gt; Type -&gt; [String]
<span class="lineno">  546 </span><span class="decl"><span class="istickedoff">showTypes ty1 ty2 =</span>
<span class="lineno">  547 </span><span class="spaces">  </span><span class="istickedoff">let expected = &quot;Expected: &quot; ++ pShow ty1</span>
<span class="lineno">  548 </span><span class="spaces">      </span><span class="istickedoff">found    = &quot;Found:    &quot; ++ pShow ty2</span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">[expected, found, &quot;&quot;]</span></span>
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>-- logic for showing details of a type
<span class="lineno">  553 </span>showTypeDetails :: Type -&gt; String
<span class="lineno">  554 </span><span class="decl"><span class="istickedoff">showTypeDetails ty =</span>
<span class="lineno">  555 </span><span class="spaces">  </span><span class="istickedoff">let pr pos what =</span>
<span class="lineno">  556 </span><span class="spaces">        </span><span class="istickedoff">show pos ++ &quot;: The type &quot; ++ pShow ty ++ &quot; arises from &quot; ++ what</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="istickedoff">case getPos ty of</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfFresh pos -&gt; <span class="nottickedoff">pr pos &quot;fresh type variable introduced here&quot;</span></span>
<span class="lineno">  560 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfTerm pos -&gt; pr pos &quot;the type of this term&quot;</span>
<span class="lineno">  561 </span><span class="spaces">    </span><span class="istickedoff">PosInferred InfContext pos -&gt; pr pos &quot;the context of the term&quot;</span>
<span class="lineno">  562 </span><span class="spaces">    </span><span class="istickedoff">pos -&gt; pr pos &quot;this type annotation&quot;</span></span>
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>-- fail with expected/found types
<span class="lineno">  565 </span>failMGU :: String -&gt; Type -&gt; Type -&gt; Either FailMGU a
<span class="lineno">  566 </span><span class="decl"><span class="istickedoff">failMGU start ty1 ty2 = Left (FailMGU start' (&quot;&quot; : showTypes ty1 ty2) [])</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="istickedoff">where start' = [start, showTypeDetails ty1, showTypeDetails ty2]</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>-- fail with no types
<span class="lineno">  570 </span>failMGU' :: String -&gt; Either FailMGU a
<span class="lineno">  571 </span><span class="decl"><span class="istickedoff">failMGU' start = Left (FailMGU [start] [] [])</span></span>
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>-- add another expected/found type pair to the failure
<span class="lineno">  574 </span>-- (pull in the last function-type lines if any)
<span class="lineno">  575 </span>failMGUAdd :: FailMGU -&gt; Type -&gt; Type -&gt; FailMGU
<span class="lineno">  576 </span><span class="decl"><span class="istickedoff">failMGUAdd (FailMGU start eflines lastfunlines) ty1 ty2 =</span>
<span class="lineno">  577 </span><span class="spaces">  </span><span class="istickedoff">FailMGU start (eflines ++ lastfunlines ++ showTypes ty1 ty2) []</span></span>
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>-- add another pair that's a function type
<span class="lineno">  580 </span>-- (overwrite any previous function type lines)
<span class="lineno">  581 </span>failMGUAddFun :: FailMGU -&gt; Type -&gt; Type -&gt; FailMGU
<span class="lineno">  582 </span><span class="decl"><span class="istickedoff">failMGUAddFun (FailMGU start eflines _) ty1 ty2 =</span>
<span class="lineno">  583 </span><span class="spaces">  </span><span class="istickedoff">FailMGU start eflines (showTypes ty1 ty2)</span></span>
<span class="lineno">  584 </span>
<span class="lineno">  585 </span>-- print the failure as a string list
<span class="lineno">  586 </span>ppFailMGU :: FailMGU -&gt; [String]
<span class="lineno">  587 </span><span class="decl"><span class="istickedoff">ppFailMGU (FailMGU start eflines lastfunlines) =</span>
<span class="lineno">  588 </span><span class="spaces">  </span><span class="istickedoff">start ++ eflines ++ lastfunlines</span></span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>-- We've found a substitution for unification var i.
<span class="lineno">  591 </span>--
<span class="lineno">  592 </span>-- Create the substitution, but first check that this doesn't result
<span class="lineno">  593 </span>-- in an invalid type.
<span class="lineno">  594 </span>--
<span class="lineno">  595 </span>-- Does not handle the case where t _is_ TyUnifyVar i; the caller
<span class="lineno">  596 </span>-- handles that.
<span class="lineno">  597 </span>--
<span class="lineno">  598 </span>-- XXX: we can resolve TyUnifyVar i to TyUnifyVar j here, which is
<span class="lineno">  599 </span>-- fine as far as it goes but there doesn't seem to be any logic to
<span class="lineno">  600 </span>-- prohibit also resolving TyUnifyVar j to TyUnifyVar i and creating
<span class="lineno">  601 </span>-- cycles.
<span class="lineno">  602 </span>resolveUnificationVar :: Pos -&gt; TypeIndex -&gt; Type -&gt; Either FailMGU Subst
<span class="lineno">  603 </span><span class="decl"><span class="istickedoff">resolveUnificationVar pos i t =</span>
<span class="lineno">  604 </span><span class="spaces">  </span><span class="istickedoff">case M.lookup i $ unifyVars t of</span>
<span class="lineno">  605 </span><span class="spaces">     </span><span class="istickedoff">Just otherpos -&gt;</span>
<span class="lineno">  606 </span><span class="spaces">       </span><span class="istickedoff">-- FIXME/XXX: this error message is better than the one that was here before</span>
<span class="lineno">  607 </span><span class="spaces">       </span><span class="istickedoff">-- but still lacks a certain something</span>
<span class="lineno">  608 </span><span class="spaces">       </span><span class="istickedoff">failMGU' $ &quot;Occurs check failure: the type at &quot; ++ show otherpos ++</span>
<span class="lineno">  609 </span><span class="spaces">                  </span><span class="istickedoff">&quot; appears within the type at &quot; ++ show pos</span>
<span class="lineno">  610 </span><span class="spaces">     </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  611 </span><span class="spaces">       </span><span class="istickedoff">return (singletonSubst i t)</span></span>
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>-- Guts of unification.
<span class="lineno">  614 </span>--
<span class="lineno">  615 </span>-- &quot;mgu&quot; stands for &quot;most general unifier&quot;.
<span class="lineno">  616 </span>--
<span class="lineno">  617 </span>-- Given two types, produce either a failure report or a substitution
<span class="lineno">  618 </span>-- (to add to the cumulative substitution we build up) that makes them
<span class="lineno">  619 </span>-- the same.
<span class="lineno">  620 </span>mgu :: Type -&gt; Type -&gt; Either FailMGU Subst
<span class="lineno">  621 </span><span class="decl"><span class="istickedoff">mgu t1 t2 = case (t1, t2) of</span>
<span class="lineno">  622 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">(TyUnifyVar _ i, TyUnifyVar _ j) | <span class="tickonlyfalse">i == j</span> -&gt;</span>
<span class="lineno">  624 </span><span class="spaces">      </span><span class="istickedoff">-- same unification var, nothing to do</span>
<span class="lineno">  625 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return emptySubst</span></span>
<span class="lineno">  626 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  627 </span><span class="spaces">  </span><span class="istickedoff">(TyUnifyVar pos i, _) -&gt;</span>
<span class="lineno">  628 </span><span class="spaces">      </span><span class="istickedoff">-- one side is a unification var, resolve it</span>
<span class="lineno">  629 </span><span class="spaces">      </span><span class="istickedoff">resolveUnificationVar pos i t2</span>
<span class="lineno">  630 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">(_, TyUnifyVar pos i) -&gt;</span>
<span class="lineno">  632 </span><span class="spaces">      </span><span class="istickedoff">-- one side is a unification var, resolve it</span>
<span class="lineno">  633 </span><span class="spaces">      </span><span class="istickedoff">resolveUnificationVar <span class="nottickedoff">pos</span> i t1</span>
<span class="lineno">  634 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  635 </span><span class="spaces">  </span><span class="istickedoff">(TyRecord _ ts1, TyRecord _ ts2)</span>
<span class="lineno">  636 </span><span class="spaces">    </span><span class="istickedoff">| M.keys ts1 /= M.keys ts2 -&gt;</span>
<span class="lineno">  637 </span><span class="spaces">      </span><span class="istickedoff">-- records with different keys</span>
<span class="lineno">  638 </span><span class="spaces">      </span><span class="istickedoff">failMGU &quot;Record field names mismatch.&quot; t1 t2</span>
<span class="lineno">  639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  640 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  641 </span><span class="spaces">      </span><span class="istickedoff">-- records with the same field names, try unifying the field types</span>
<span class="lineno">  642 </span><span class="spaces">      </span><span class="istickedoff">case mgus (M.elems ts1) (M.elems ts2) of</span>
<span class="lineno">  643 </span><span class="spaces">        </span><span class="istickedoff">Right result -&gt; Right result</span>
<span class="lineno">  644 </span><span class="spaces">        </span><span class="istickedoff">Left msgs -&gt; Left $ failMGUAdd msgs t1 t2</span>
<span class="lineno">  645 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  646 </span><span class="spaces">  </span><span class="istickedoff">(TyCon _ tc1 ts1, TyCon _ tc2 ts2)</span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="istickedoff">| tc1 == tc2 -&gt;</span>
<span class="lineno">  648 </span><span class="spaces">      </span><span class="istickedoff">-- same type constructor, unify the args</span>
<span class="lineno">  649 </span><span class="spaces">      </span><span class="istickedoff">case mgus ts1 ts2 of</span>
<span class="lineno">  650 </span><span class="spaces">        </span><span class="istickedoff">Right result -&gt; Right result</span>
<span class="lineno">  651 </span><span class="spaces">        </span><span class="istickedoff">Left msgs -&gt;</span>
<span class="lineno">  652 </span><span class="spaces">          </span><span class="istickedoff">-- oops, didn't work. handle functions specially for</span>
<span class="lineno">  653 </span><span class="spaces">          </span><span class="istickedoff">-- nicer error reporting</span>
<span class="lineno">  654 </span><span class="spaces">          </span><span class="istickedoff">case tc1 of</span>
<span class="lineno">  655 </span><span class="spaces">            </span><span class="istickedoff">FunCon -&gt; Left $ failMGUAddFun msgs t1 t2</span>
<span class="lineno">  656 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; Left $ failMGUAdd msgs t1 t2</span>
<span class="lineno">  657 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  658 </span><span class="spaces">    </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  659 </span><span class="spaces">      </span><span class="istickedoff">-- Wrong type constructors</span>
<span class="lineno">  660 </span><span class="spaces">      </span><span class="istickedoff">case tc1 of</span>
<span class="lineno">  661 </span><span class="spaces">        </span><span class="istickedoff">FunCon -&gt;</span>
<span class="lineno">  662 </span><span class="spaces">          </span><span class="istickedoff">failMGU (&quot;Term is not a function. (Maybe a function is applied &quot; ++</span>
<span class="lineno">  663 </span><span class="spaces">                   </span><span class="istickedoff">&quot;to too many arguments?)&quot;) t1 t2</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  665 </span><span class="spaces">          </span><span class="istickedoff">failMGU (&quot;Mismatch of type constructors. Expected: &quot; ++ pShow tc1 ++</span>
<span class="lineno">  666 </span><span class="spaces">                   </span><span class="istickedoff">&quot; but got &quot; ++ pShow tc2) t1 t2</span>
<span class="lineno">  667 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  668 </span><span class="spaces">  </span><span class="istickedoff">(TyVar _ a, TyVar _ b) | <span class="tickonlytrue">a == b</span> -&gt;</span>
<span class="lineno">  669 </span><span class="spaces">      </span><span class="istickedoff">-- Same named variable</span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  673 </span><span class="spaces">      </span><span class="istickedoff">-- Did not work</span>
<span class="lineno">  674 </span><span class="spaces">      </span><span class="istickedoff">failMGU &quot;Mismatch of types.&quot; t1 t2</span></span>
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>-- Run mgu on two lists of types.
<span class="lineno">  677 </span>mgus :: [Type] -&gt; [Type] -&gt; Either FailMGU Subst
<span class="lineno">  678 </span><span class="decl"><span class="istickedoff">mgus t1s t2s = case (t1s, t2s) of</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="istickedoff">([], []) -&gt;</span>
<span class="lineno">  680 </span><span class="spaces">        </span><span class="istickedoff">return emptySubst</span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="istickedoff">(t1 : t1s', t2 : t2s') -&gt; do</span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="istickedoff">-- unify the first types</span>
<span class="lineno">  683 </span><span class="spaces">        </span><span class="istickedoff">s &lt;- mgu t1 t2</span>
<span class="lineno">  684 </span><span class="spaces">        </span><span class="istickedoff">-- apply that substitution and then recurse</span>
<span class="lineno">  685 </span><span class="spaces">        </span><span class="istickedoff">s' &lt;- mgus (map (appSubst s) t1s') (map (appSubst s) t2s')</span>
<span class="lineno">  686 </span><span class="spaces">        </span><span class="istickedoff">return (mergeSubst s' s)</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  688 </span><span class="spaces">      </span><span class="istickedoff">-- XXX this is no good, it will always print one of the lengths as 0!</span>
<span class="lineno">  689 </span><span class="spaces">      </span><span class="istickedoff">-- (also, note that this is only reachable for type constructor args</span>
<span class="lineno">  690 </span><span class="spaces">      </span><span class="istickedoff">-- and not function args)</span>
<span class="lineno">  691 </span><span class="spaces">      </span><span class="istickedoff">--</span>
<span class="lineno">  692 </span><span class="spaces">      </span><span class="istickedoff">-- dholland 20250106: I believe this is currently unreachable.</span>
<span class="lineno">  693 </span><span class="spaces">      </span><span class="istickedoff">-- mgus is called from two places above (record fields and type</span>
<span class="lineno">  694 </span><span class="spaces">      </span><span class="istickedoff">-- constructor arguments); the record fields case always passes</span>
<span class="lineno">  695 </span><span class="spaces">      </span><span class="istickedoff">-- lists of the same length. The situation with type constructor</span>
<span class="lineno">  696 </span><span class="spaces">      </span><span class="istickedoff">-- arguments is murkier. However, there are only a handful of</span>
<span class="lineno">  697 </span><span class="spaces">      </span><span class="istickedoff">-- builtin types whose constructors take arguments at all:</span>
<span class="lineno">  698 </span><span class="spaces">      </span><span class="istickedoff">-- tuples, lists, functions, and monads/contexts/blocks. The</span>
<span class="lineno">  699 </span><span class="spaces">      </span><span class="istickedoff">-- parser special-cases the syntax for all of these, so that you</span>
<span class="lineno">  700 </span><span class="spaces">      </span><span class="istickedoff">-- apparently can't produce partially applied instances for</span>
<span class="lineno">  701 </span><span class="spaces">      </span><span class="istickedoff">-- any. (And for tuples, the arity is part of the constructor,</span>
<span class="lineno">  702 </span><span class="spaces">      </span><span class="istickedoff">-- so tuples of different arity won't get as far as trying to</span>
<span class="lineno">  703 </span><span class="spaces">      </span><span class="istickedoff">-- unify the arguments.)</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">failMGU' $ &quot;Wrong number of arguments. Expected &quot; ++ show (length t1s) ++</span></span>
<span class="lineno">  705 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">&quot; but got &quot; ++ show (length t2s)</span></span></span>
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>--
<span class="lineno">  708 </span>-- Unify two types.
<span class="lineno">  709 </span>--
<span class="lineno">  710 </span>
<span class="lineno">  711 </span>-- When typechecking an expression the first type argument (t1) should
<span class="lineno">  712 </span>-- be the type expected from the context, and the second (t2) should
<span class="lineno">  713 </span>-- be the type found in the expression appearing in that context. For
<span class="lineno">  714 </span>-- example, when checking the second argument of a function application
<span class="lineno">  715 </span>-- (Application _pos e1 e2) checking e1 gives rise to an expected type
<span class="lineno">  716 </span>-- for e2, so when unifying that with the result of checking e2 the
<span class="lineno">  717 </span>-- t1 argument should be the expected type arising from e1, the t2
<span class="lineno">  718 </span>-- argument should be the type returned by checking e2, and the position
<span class="lineno">  719 </span>-- argument should be the position of e2 (not the position of the
<span class="lineno">  720 </span>-- enclosing apply node). If it doesn't work, the message generated
<span class="lineno">  721 </span>-- will be of the form &quot;pos: found t2, expected t1&quot;.
<span class="lineno">  722 </span>--
<span class="lineno">  723 </span>-- Other cases should pass the arguments analogously. As of this
<span class="lineno">  724 </span>-- writing some are definitely backwards.
<span class="lineno">  725 </span>--
<span class="lineno">  726 </span>-- Further notes on error messages:
<span class="lineno">  727 </span>--
<span class="lineno">  728 </span>-- The error message returned by mgu already prints the types at some
<span class="lineno">  729 </span>-- length, so we don't need to print any of that again.
<span class="lineno">  730 </span>--
<span class="lineno">  731 </span>-- Indent all but the first line by four spaces because the first line
<span class="lineno">  732 </span>-- ends up indented by two when it ultimately gets printed (or at
<span class="lineno">  733 </span>-- least sometimes it does) and we want the grouping to be clearly
<span class="lineno">  734 </span>-- recognizable.
<span class="lineno">  735 </span>--
<span class="lineno">  736 </span>-- The LName passed in is (at least in most cases) the name of the
<span class="lineno">  737 </span>-- top-level binding the unification happens inside. Its position is
<span class="lineno">  738 </span>-- therefore usually not where the problem is except in a very
<span class="lineno">  739 </span>-- abstract sense and shouldn't be printed as if it's the error
<span class="lineno">  740 </span>-- location. So tack it onto the end of everything.
<span class="lineno">  741 </span>--
<span class="lineno">  742 </span>-- It's not clear that this is always the case, so in turn it's not
<span class="lineno">  743 </span>-- entirely clear that it's always useless and I'm hesitant to remove
<span class="lineno">  744 </span>-- it entirely, but that seems like a reasonable thing to do in the
<span class="lineno">  745 </span>-- future given more clarity.
<span class="lineno">  746 </span>--
<span class="lineno">  747 </span>unify :: LName -&gt; Type -&gt; Pos -&gt; Type -&gt; TI ()
<span class="lineno">  748 </span><span class="decl"><span class="istickedoff">unify m t1 pos t2 = do</span>
<span class="lineno">  749 </span><span class="spaces">  </span><span class="istickedoff">t1' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t1</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff">t2' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t2</span>
<span class="lineno">  751 </span><span class="spaces">  </span><span class="istickedoff">case mgu t1' t2' of</span>
<span class="lineno">  752 </span><span class="spaces">    </span><span class="istickedoff">Right s -&gt; TI $ modify $ \rw -&gt; rw { subst = mergeSubst s $ subst rw }</span>
<span class="lineno">  753 </span><span class="spaces">    </span><span class="istickedoff">Left msgs -&gt;</span>
<span class="lineno">  754 </span><span class="spaces">       </span><span class="istickedoff">recordError pos $ unlines $ firstline : morelines'</span>
<span class="lineno">  755 </span><span class="spaces">       </span><span class="istickedoff">where</span>
<span class="lineno">  756 </span><span class="spaces">         </span><span class="istickedoff">firstline = &quot;Type mismatch.&quot;</span>
<span class="lineno">  757 </span><span class="spaces">         </span><span class="istickedoff">morelines = ppFailMGU msgs ++ [&quot;within &quot; ++ show m]</span>
<span class="lineno">  758 </span><span class="spaces">         </span><span class="istickedoff">-- Indent all but the first line by four spaces.</span>
<span class="lineno">  759 </span><span class="spaces">         </span><span class="istickedoff">-- Don't indent blank lines; that produces trailing whitespace.</span>
<span class="lineno">  760 </span><span class="spaces">         </span><span class="istickedoff">adjust msg = case msg of</span>
<span class="lineno">  761 </span><span class="spaces">             </span><span class="istickedoff">[] -&gt; []</span>
<span class="lineno">  762 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; &quot;    &quot; ++ msg</span>
<span class="lineno">  763 </span><span class="spaces">         </span><span class="istickedoff">morelines' = map adjust morelines</span></span>
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>-- Check if two types match but don't actually unify them
<span class="lineno">  766 </span>-- (that is, on success throw away the substitution and on error
<span class="lineno">  767 </span>-- throw away the complaints)
<span class="lineno">  768 </span>--
<span class="lineno">  769 </span>-- This is inelegant, and used for some workaround logic to decide
<span class="lineno">  770 </span>-- which unifications to attempt to avoid failures on things we don't
<span class="lineno">  771 </span>-- want to make fatal just yet. It should be removed when no longer
<span class="lineno">  772 </span>-- needed.
<span class="lineno">  773 </span>matches :: Type -&gt; Type -&gt; TI Bool
<span class="lineno">  774 </span><span class="decl"><span class="istickedoff">matches t1 t2 = do</span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="istickedoff">t1' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t1</span>
<span class="lineno">  776 </span><span class="spaces">  </span><span class="istickedoff">t2' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t2</span>
<span class="lineno">  777 </span><span class="spaces">  </span><span class="istickedoff">case mgu t1' t2' of</span>
<span class="lineno">  778 </span><span class="spaces">    </span><span class="istickedoff">Right _ -&gt; return True</span>
<span class="lineno">  779 </span><span class="spaces">    </span><span class="istickedoff">Left _ -&gt; return False</span></span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>-- }}}
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>
<span class="lineno">  784 </span>------------------------------------------------------------
<span class="lineno">  785 </span>-- Inspect for free type variables {{{
<span class="lineno">  786 </span>
<span class="lineno">  787 </span>-- We want to allow declaring polymorphic functions by introducing
<span class="lineno">  788 </span>-- type variables in the function header (rather than requiring an
<span class="lineno">  789 </span>-- explicit forall binding), like Haskell does.
<span class="lineno">  790 </span>--
<span class="lineno">  791 </span>-- This means that free type variables in a function header (but not
<span class="lineno">  792 </span>-- elsewhere) should be accepted, collected, and handed off to
<span class="lineno">  793 </span>-- generalize for insertion in the resultant type scheme.
<span class="lineno">  794 </span>--
<span class="lineno">  795 </span>-- It turns out that because of the way the AST represents functions
<span class="lineno">  796 </span>-- in let-bindings that this is highly unpleasant to do on the fly
<span class="lineno">  797 </span>-- while typechecking. So instead extract the free type variables
<span class="lineno">  798 </span>-- separately.
<span class="lineno">  799 </span>--
<span class="lineno">  800 </span>-- A function header comes through like this:
<span class="lineno">  801 </span>--    Decl _pos &lt;function-name-pattern&gt; Nothing &lt;expr&gt;
<span class="lineno">  802 </span>--
<span class="lineno">  803 </span>-- where &lt;expr&gt; is
<span class="lineno">  804 </span>--    zero or more times, Lambda _pos &lt;arg-pattern&gt; &lt;expr'&gt;
<span class="lineno">  805 </span>--    then optionally, TSig _pos &lt;expr''&gt; &lt;return-type&gt;
<span class="lineno">  806 </span>--
<span class="lineno">  807 </span>-- so we need any free type variables in
<span class="lineno">  808 </span>--    - &lt;function-name-pattern&gt;
<span class="lineno">  809 </span>--    - &lt;return-type&gt;
<span class="lineno">  810 </span>--    - all &lt;arg-pattern&gt;
<span class="lineno">  811 </span>--
<span class="lineno">  812 </span>-- On the plus side this will also then work when people write
<span class="lineno">  813 </span>-- otherwise annoying things like
<span class="lineno">  814 </span>--    let f (x: a) = \(y: b) -&gt; (a, b)
<span class="lineno">  815 </span>--
<span class="lineno">  816 </span>-- We extract the type variables with the position of their
<span class="lineno">  817 </span>-- initial mention.
<span class="lineno">  818 </span>
<span class="lineno">  819 </span>-- Get the free type variables found in a Type.
<span class="lineno">  820 </span>inspectTypeFTVs :: Type -&gt; TI (Map Name Pos)
<span class="lineno">  821 </span><span class="decl"><span class="istickedoff">inspectTypeFTVs ty = case ty of</span>
<span class="lineno">  822 </span><span class="spaces">    </span><span class="istickedoff">TyCon _pos _ctor args -&gt; M.unions &lt;$&gt; mapM inspectTypeFTVs args</span>
<span class="lineno">  823 </span><span class="spaces">    </span><span class="istickedoff">TyRecord _pos fields -&gt; M.unions &lt;$&gt; traverse inspectTypeFTVs fields</span>
<span class="lineno">  824 </span><span class="spaces">    </span><span class="istickedoff">TyUnifyVar _pos _x -&gt; <span class="nottickedoff">return M.empty</span></span>
<span class="lineno">  825 </span><span class="spaces">    </span><span class="istickedoff">TyVar pos x -&gt; do</span>
<span class="lineno">  826 </span><span class="spaces">        </span><span class="istickedoff">tyenv &lt;- TI $ asks tyEnv</span>
<span class="lineno">  827 </span><span class="spaces">        </span><span class="istickedoff">case M.lookup x tyenv of</span>
<span class="lineno">  828 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; return $ M.singleton x <span class="nottickedoff">pos</span></span>
<span class="lineno">  829 </span><span class="spaces">            </span><span class="istickedoff">Just _ -&gt; return $ M.empty</span></span>
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>-- Get the free type variables found in a Maybe Type.
<span class="lineno">  832 </span>inspectMaybeTypeFTVs :: Maybe Type -&gt; TI (Map Name Pos)
<span class="lineno">  833 </span><span class="decl"><span class="istickedoff">inspectMaybeTypeFTVs mty = case mty of</span>
<span class="lineno">  834 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; return M.empty</span>
<span class="lineno">  835 </span><span class="spaces">    </span><span class="istickedoff">Just ty -&gt; inspectTypeFTVs ty</span></span>
<span class="lineno">  836 </span>
<span class="lineno">  837 </span>-- Get the free type variables found in a Pattern.
<span class="lineno">  838 </span>inspectPatternFTVs :: Pattern -&gt; TI (Map Name Pos)
<span class="lineno">  839 </span><span class="decl"><span class="istickedoff">inspectPatternFTVs pat = case pat of</span>
<span class="lineno">  840 </span><span class="spaces">    </span><span class="istickedoff">PWild _pos mty -&gt; <span class="nottickedoff">inspectMaybeTypeFTVs mty</span></span>
<span class="lineno">  841 </span><span class="spaces">    </span><span class="istickedoff">PVar _pos _x mty -&gt; inspectMaybeTypeFTVs mty</span>
<span class="lineno">  842 </span><span class="spaces">    </span><span class="istickedoff">PTuple _pos subpats -&gt;</span>
<span class="lineno">  843 </span><span class="spaces">        </span><span class="istickedoff">M.unions &lt;$&gt; mapM inspectPatternFTVs subpats</span></span>
<span class="lineno">  844 </span>
<span class="lineno">  845 </span>-- Get the free type variables found in a chain of Lambda Exprs.
<span class="lineno">  846 </span>-- Also return the body expression found on the inside of the chain
<span class="lineno">  847 </span>-- for possible further analysis.
<span class="lineno">  848 </span>inspectLambdaFTVs :: Expr -&gt; TI (Expr, Map Name Pos)
<span class="lineno">  849 </span><span class="decl"><span class="istickedoff">inspectLambdaFTVs e0 = case e0 of</span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="istickedoff">Lambda _fpos _mname pat e1 -&gt; do</span>
<span class="lineno">  851 </span><span class="spaces">        </span><span class="istickedoff">hereFTVs &lt;- inspectPatternFTVs pat</span>
<span class="lineno">  852 </span><span class="spaces">        </span><span class="istickedoff">(e1', moreFTVs) &lt;- inspectLambdaFTVs e1</span>
<span class="lineno">  853 </span><span class="spaces">        </span><span class="istickedoff">return (e1', M.union hereFTVs moreFTVs)</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  855 </span><span class="spaces">        </span><span class="istickedoff">return (e0, M.empty)</span></span>
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>-- Get the free type variables found in a Decl.
<span class="lineno">  858 </span>inspectDeclFTVs :: Decl -&gt; TI (Map Name Pos)
<span class="lineno">  859 </span><span class="decl"><span class="istickedoff">inspectDeclFTVs (Decl _dpos pat _mty e0) = do</span>
<span class="lineno">  860 </span><span class="spaces">    </span><span class="istickedoff">nameFTVs &lt;- inspectPatternFTVs pat</span>
<span class="lineno">  861 </span><span class="spaces">    </span><span class="istickedoff">(e1, argFTVs) &lt;- inspectLambdaFTVs e0</span>
<span class="lineno">  862 </span><span class="spaces">    </span><span class="istickedoff">retFTVs &lt;- case e1 of</span>
<span class="lineno">  863 </span><span class="spaces">        </span><span class="istickedoff">TSig _tspos _e2 ty -&gt; inspectTypeFTVs ty</span>
<span class="lineno">  864 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; return M.empty</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff">return $ M.unions [nameFTVs, argFTVs, retFTVs]</span></span>
<span class="lineno">  866 </span>
<span class="lineno">  867 </span>
<span class="lineno">  868 </span>-- }}}
<span class="lineno">  869 </span>
<span class="lineno">  870 </span>
<span class="lineno">  871 </span>------------------------------------------------------------
<span class="lineno">  872 </span>-- Main recursive pass {{{
<span class="lineno">  873 </span>
<span class="lineno">  874 </span>type OutExpr = Expr
<span class="lineno">  875 </span>type OutStmt = Stmt
<span class="lineno">  876 </span>
<span class="lineno">  877 </span>--
<span class="lineno">  878 </span>-- Expressions
<span class="lineno">  879 </span>--
<span class="lineno">  880 </span>
<span class="lineno">  881 </span>-- Take a struct field binding (name and expression) and return the
<span class="lineno">  882 </span>-- updated binding as well as the member entry for the enclosing
<span class="lineno">  883 </span>-- struct type.
<span class="lineno">  884 </span>inferField :: LName -&gt; (Name, Expr) -&gt; TI ((Name, OutExpr), (Name, Type))
<span class="lineno">  885 </span><span class="decl"><span class="istickedoff">inferField m (n,e) = do</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">(e',t) &lt;- inferExpr (<span class="nottickedoff">m</span>,e)</span>
<span class="lineno">  887 </span><span class="spaces">  </span><span class="istickedoff">return ((n,e'),(n,t))</span></span>
<span class="lineno">  888 </span>
<span class="lineno">  889 </span>-- wrap the action m with a type for x
<span class="lineno">  890 </span>withVar :: Located Name -&gt; Schema -&gt; TI a -&gt; TI a
<span class="lineno">  891 </span><span class="decl"><span class="istickedoff">withVar x s m =</span>
<span class="lineno">  892 </span><span class="spaces">  </span><span class="istickedoff">TI $ local (\ro -&gt; ro { varEnv = M.insert x (Current, s) $ varEnv ro }) $ unTI m</span></span>
<span class="lineno">  893 </span>
<span class="lineno">  894 </span>-- wrap the action m with types for a list of vars
<span class="lineno">  895 </span>withVars :: [(Located Name, Schema)] -&gt; TI a -&gt; TI a
<span class="lineno">  896 </span><span class="decl"><span class="istickedoff">withVars bindings m = foldr (uncurry withVar) m bindings</span></span>
<span class="lineno">  897 </span>
<span class="lineno">  898 </span>-- wrap the action m with types for all the vars in a pattern
<span class="lineno">  899 </span>--
<span class="lineno">  900 </span>-- (note that the pattern should have already been processed so it
<span class="lineno">  901 </span>-- contains types; hence the irrefutable Just t)
<span class="lineno">  902 </span>withPattern :: Pattern -&gt; TI a -&gt; TI a
<span class="lineno">  903 </span><span class="decl"><span class="istickedoff">withPattern pat m = withVars bindings m</span>
<span class="lineno">  904 </span><span class="spaces">  </span><span class="istickedoff">where bindings = [ (x, tMono t) | (x, Just t) &lt;- patternBindings pat ]</span></span>
<span class="lineno">  905 </span>
<span class="lineno">  906 </span>-- wrap the action m with types for all the vars in a pattern, using
<span class="lineno">  907 </span>-- the passed-in schema to produce the types and ignoring the types
<span class="lineno">  908 </span>-- already loaded into the pattern.
<span class="lineno">  909 </span>--
<span class="lineno">  910 </span>-- XXX: is that what we want? should probably assert that the schema
<span class="lineno">  911 </span>-- matches the types in the pattern, unless the pattern hasn't already
<span class="lineno">  912 </span>-- been checked yet, and that seems like it would be a bug.
<span class="lineno">  913 </span>--
<span class="lineno">  914 </span>-- Note that if the pattern is a tuple and the schema is not a tuple
<span class="lineno">  915 </span>-- type, we do nothing. Presumably in this case a type error has
<span class="lineno">  916 </span>-- already been generated and we don't need another one? But it would
<span class="lineno">  917 </span>-- probably be a good idea to check up on that. XXX
<span class="lineno">  918 </span>withPatternSchema :: Pattern -&gt; Schema -&gt; TI a -&gt; TI a
<span class="lineno">  919 </span><span class="decl"><span class="istickedoff">withPatternSchema pat s@(Forall vs t) m =</span>
<span class="lineno">  920 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="istickedoff">PWild _ _ -&gt; <span class="nottickedoff">m</span></span>
<span class="lineno">  922 </span><span class="spaces">    </span><span class="istickedoff">PVar _ x _ -&gt; withVar x s m</span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="istickedoff">PTuple _ ps -&gt;</span>
<span class="lineno">  924 </span><span class="spaces">      </span><span class="istickedoff">case t of</span>
<span class="lineno">  925 </span><span class="spaces">        </span><span class="istickedoff">TyCon _pos (TupleCon _) ts -&gt; foldr ($) m</span>
<span class="lineno">  926 </span><span class="spaces">          </span><span class="istickedoff">[ withPatternSchema p (Forall vs t') | (p, t') &lt;- zip ps ts ]</span>
<span class="lineno">  927 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">m</span></span></span>
<span class="lineno">  928 </span>
<span class="lineno">  929 </span>-- wrap the action m with types for the vars in a declaration.
<span class="lineno">  930 </span>--
<span class="lineno">  931 </span>-- Do nothing if there's no type schema in this declaration yet.
<span class="lineno">  932 </span>withDecl :: Decl -&gt; TI a -&gt; TI a
<span class="lineno">  933 </span><span class="decl"><span class="istickedoff">withDecl (Decl _ _ Nothing _) m = <span class="nottickedoff">m</span></span>
<span class="lineno">  934 </span><span class="spaces"></span><span class="istickedoff">withDecl (Decl _ p (Just s) _) m = withPatternSchema p s m</span></span>
<span class="lineno">  935 </span>
<span class="lineno">  936 </span>-- wrap the action m with types for the vars in a declgroup.
<span class="lineno">  937 </span>withDeclGroup :: DeclGroup -&gt; TI a -&gt; TI a
<span class="lineno">  938 </span><span class="decl"><span class="istickedoff">withDeclGroup (NonRecursive d) m = withDecl d m</span>
<span class="lineno">  939 </span><span class="spaces"></span><span class="istickedoff">withDeclGroup (Recursive ds) m = <span class="nottickedoff">foldr withDecl m ds</span></span></span>
<span class="lineno">  940 </span>
<span class="lineno">  941 </span>-- wrap the action m with some abstract type variables.
<span class="lineno">  942 </span>withAbstractTyVars :: Map Name Pos -&gt; TI a -&gt; TI a
<span class="lineno">  943 </span><span class="decl"><span class="istickedoff">withAbstractTyVars vars m = do</span>
<span class="lineno">  944 </span><span class="spaces">    </span><span class="istickedoff">let insertOne x _pos tyenv = M.insert x (Current, AbstractType) tyenv</span>
<span class="lineno">  945 </span><span class="spaces">        </span><span class="istickedoff">insertAll tyenv = M.foldrWithKey insertOne tyenv vars</span>
<span class="lineno">  946 </span><span class="spaces">    </span><span class="istickedoff">TI $ local (\ro -&gt; ro { tyEnv = insertAll $ tyEnv ro }) $ unTI m</span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>--
<span class="lineno">  949 </span>-- Infer the type for an expression.
<span class="lineno">  950 </span>--
<span class="lineno">  951 </span>-- The LName is the context name passed to unify, which isn't generally
<span class="lineno">  952 </span>-- useful and should probably be removed.
<span class="lineno">  953 </span>--
<span class="lineno">  954 </span>inferExpr :: (LName, Expr) -&gt; TI (OutExpr,Type)
<span class="lineno">  955 </span><span class="decl"><span class="istickedoff">inferExpr (ln, expr) = case expr of</span>
<span class="lineno">  956 </span><span class="spaces">  </span><span class="istickedoff">Bool pos b    -&gt; <span class="nottickedoff">return (Bool pos b, tBool (PosInferred InfTerm pos))</span></span>
<span class="lineno">  957 </span><span class="spaces">  </span><span class="istickedoff">String pos s  -&gt; return (String pos s, tString (PosInferred InfTerm pos))</span>
<span class="lineno">  958 </span><span class="spaces">  </span><span class="istickedoff">Int pos i     -&gt; return (Int pos i, tInt (PosInferred InfTerm pos))</span>
<span class="lineno">  959 </span><span class="spaces">  </span><span class="istickedoff">Code s        -&gt; return (Code s, tTerm <span class="nottickedoff">(PosInferred InfTerm $ getPos s)</span>)</span>
<span class="lineno">  960 </span><span class="spaces">  </span><span class="istickedoff">CType s       -&gt; return (CType s, tType <span class="nottickedoff">(PosInferred InfTerm $ getPos s)</span>)</span>
<span class="lineno">  961 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  962 </span><span class="spaces">  </span><span class="istickedoff">Array pos [] -&gt;</span>
<span class="lineno">  963 </span><span class="spaces">    </span><span class="istickedoff">do a &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  964 </span><span class="spaces">       </span><span class="istickedoff">return (Array <span class="nottickedoff">pos</span> [], tArray <span class="nottickedoff">(PosInferred InfTerm pos)</span> a)</span>
<span class="lineno">  965 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  966 </span><span class="spaces">  </span><span class="istickedoff">Array pos (e:es) -&gt;</span>
<span class="lineno">  967 </span><span class="spaces">    </span><span class="istickedoff">do (e',t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e)</span>
<span class="lineno">  968 </span><span class="spaces">       </span><span class="istickedoff">es' &lt;- mapM (flip (checkExpr ln) t) es</span>
<span class="lineno">  969 </span><span class="spaces">       </span><span class="istickedoff">return (Array pos (e':es'), tArray (PosInferred InfTerm pos) t)</span>
<span class="lineno">  970 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="istickedoff">Block pos body -&gt;</span>
<span class="lineno">  972 </span><span class="spaces">    </span><span class="istickedoff">do ctx &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  973 </span><span class="spaces">       </span><span class="istickedoff">tyResult &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno">  974 </span><span class="spaces">       </span><span class="istickedoff">let ty = tBlock <span class="nottickedoff">(PosInferred InfTerm pos)</span> ctx tyResult</span>
<span class="lineno">  975 </span><span class="spaces">       </span><span class="istickedoff">body' &lt;- inferBlock ln <span class="nottickedoff">pos</span> ctx ty body</span>
<span class="lineno">  976 </span><span class="spaces">       </span><span class="istickedoff">return (Block <span class="nottickedoff">pos</span> body', ty)</span>
<span class="lineno">  977 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  978 </span><span class="spaces">  </span><span class="istickedoff">Tuple pos es -&gt;</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="istickedoff">do (es',ts) &lt;- unzip `fmap` mapM (inferExpr . (ln,)) es</span>
<span class="lineno">  980 </span><span class="spaces">       </span><span class="istickedoff">return (Tuple pos es', tTuple (PosInferred InfTerm pos) ts)</span>
<span class="lineno">  981 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  982 </span><span class="spaces">  </span><span class="istickedoff">Record pos fs -&gt;</span>
<span class="lineno">  983 </span><span class="spaces">    </span><span class="istickedoff">do (nes',nts) &lt;- unzip `fmap` mapM (inferField <span class="nottickedoff">ln</span>) (M.toList fs)</span>
<span class="lineno">  984 </span><span class="spaces">       </span><span class="istickedoff">let ty = TyRecord (PosInferred InfTerm pos) $ M.fromList nts</span>
<span class="lineno">  985 </span><span class="spaces">       </span><span class="istickedoff">return (Record <span class="nottickedoff">pos</span> (M.fromList nes'), ty)</span>
<span class="lineno">  986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  987 </span><span class="spaces">  </span><span class="istickedoff">-- XXX this is currently unreachable because there's no concrete</span>
<span class="lineno">  988 </span><span class="spaces">  </span><span class="istickedoff">-- syntax for it; the parser will never produce it.</span>
<span class="lineno">  989 </span><span class="spaces">  </span><span class="istickedoff">Index pos ar ix -&gt;</span>
<span class="lineno">  990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do (ar',at) &lt;- inferExpr (ln,ar)</span></span>
<span class="lineno">  991 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">ix'      &lt;- checkExpr ln ix (tInt (PosInferred InfContext (getPos ix)))</span></span>
<span class="lineno">  992 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">t        &lt;- getFreshTyVar (getPos ix')</span></span>
<span class="lineno">  993 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">unify ln (tArray (PosInferred InfContext (getPos ar')) t) (getPos ar') at</span></span>
<span class="lineno">  994 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">return (Index pos ar' ix', t)</span></span>
<span class="lineno">  995 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="istickedoff">Lookup pos e n -&gt;</span>
<span class="lineno">  997 </span><span class="spaces">    </span><span class="istickedoff">do (e1,t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e)</span>
<span class="lineno">  998 </span><span class="spaces">       </span><span class="istickedoff">t1 &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t</span>
<span class="lineno">  999 </span><span class="spaces">       </span><span class="istickedoff">elTy &lt;- case t1 of</span>
<span class="lineno"> 1000 </span><span class="spaces">           </span><span class="istickedoff">TyRecord typos fs</span>
<span class="lineno"> 1001 </span><span class="spaces">            </span><span class="istickedoff">| Just ty &lt;- M.lookup n fs -&gt; do</span>
<span class="lineno"> 1002 </span><span class="spaces">               </span><span class="istickedoff">return ty</span>
<span class="lineno"> 1003 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1004 </span><span class="spaces">               </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1005 </span><span class="spaces">                   </span><span class="istickedoff">&quot;Record type has no field named &quot; ++ Text.unpack n</span>
<span class="lineno"> 1006 </span><span class="spaces">               </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">typos</span></span>
<span class="lineno"> 1007 </span><span class="spaces">           </span><span class="istickedoff">TyUnifyVar _ _ -&gt; do</span>
<span class="lineno"> 1008 </span><span class="spaces">               </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1009 </span><span class="spaces">                   </span><span class="istickedoff">&quot;Cannot infer a record type for field &quot; ++</span>
<span class="lineno"> 1010 </span><span class="spaces">                   </span><span class="istickedoff">Text.unpack n ++ &quot;; please use a type annotation&quot;</span>
<span class="lineno"> 1011 </span><span class="spaces">               </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1012 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1013 </span><span class="spaces">               </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1014 </span><span class="spaces">                   </span><span class="istickedoff">&quot;Record lookup on non-record value of type &quot; ++ pShow t1</span>
<span class="lineno"> 1015 </span><span class="spaces">               </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1016 </span><span class="spaces">       </span><span class="istickedoff">return (<span class="nottickedoff">Lookup pos e1 n</span>, elTy)</span>
<span class="lineno"> 1017 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1018 </span><span class="spaces">  </span><span class="istickedoff">TLookup pos e i -&gt;</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="istickedoff">do (e1,t) &lt;- inferExpr (<span class="nottickedoff">ln</span>,e)</span>
<span class="lineno"> 1020 </span><span class="spaces">       </span><span class="istickedoff">t1 &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs t</span>
<span class="lineno"> 1021 </span><span class="spaces">       </span><span class="istickedoff">elTy &lt;- case t1 of</span>
<span class="lineno"> 1022 </span><span class="spaces">           </span><span class="istickedoff">TyCon typos (TupleCon n) tys</span>
<span class="lineno"> 1023 </span><span class="spaces">            </span><span class="istickedoff">| i &lt; n -&gt;</span>
<span class="lineno"> 1024 </span><span class="spaces">               </span><span class="istickedoff">return (tys !! fromIntegral i)</span>
<span class="lineno"> 1025 </span><span class="spaces">            </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1026 </span><span class="spaces">               </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1027 </span><span class="spaces">                   </span><span class="istickedoff">&quot;Tuple index &quot; ++ show i ++ &quot; out of bounds; limit is &quot; ++</span>
<span class="lineno"> 1028 </span><span class="spaces">                   </span><span class="istickedoff">show n</span>
<span class="lineno"> 1029 </span><span class="spaces">               </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">typos</span></span>
<span class="lineno"> 1030 </span><span class="spaces">           </span><span class="istickedoff">TyUnifyVar _ _ -&gt; do</span>
<span class="lineno"> 1031 </span><span class="spaces">               </span><span class="istickedoff">recordError pos $</span>
<span class="lineno"> 1032 </span><span class="spaces">                   </span><span class="istickedoff">&quot;Cannot infer tuple arity for lookup of element &quot; ++</span>
<span class="lineno"> 1033 </span><span class="spaces">                   </span><span class="istickedoff">show i ++ &quot;; please use a type annotation&quot;</span>
<span class="lineno"> 1034 </span><span class="spaces">               </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1035 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; do</span>
<span class="lineno"> 1036 </span><span class="spaces">               </span><span class="istickedoff">recordError pos $ </span>
<span class="lineno"> 1037 </span><span class="spaces">                   </span><span class="istickedoff">&quot;Tuple lookup on non-tuple value of type &quot; ++ pShow t1</span>
<span class="lineno"> 1038 </span><span class="spaces">               </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1039 </span><span class="spaces">       </span><span class="istickedoff">return (<span class="nottickedoff">TLookup pos e1 i</span>, elTy)</span>
<span class="lineno"> 1040 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1041 </span><span class="spaces">  </span><span class="istickedoff">Var x -&gt;</span>
<span class="lineno"> 1042 </span><span class="spaces">    </span><span class="istickedoff">do avail &lt;- TI $ asks primsAvail</span>
<span class="lineno"> 1043 </span><span class="spaces">       </span><span class="istickedoff">env &lt;- TI $ asks varEnv</span>
<span class="lineno"> 1044 </span><span class="spaces">       </span><span class="istickedoff">case M.lookup x env of</span>
<span class="lineno"> 1045 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1046 </span><span class="spaces">           </span><span class="istickedoff">recordError (getPos x) $ &quot;Unbound variable: &quot; ++ show x</span>
<span class="lineno"> 1047 </span><span class="spaces">           </span><span class="istickedoff">t &lt;- getFreshTyVar <span class="nottickedoff">(getPos x)</span></span>
<span class="lineno"> 1048 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">Var x</span>, t)</span>
<span class="lineno"> 1049 </span><span class="spaces">         </span><span class="istickedoff">Just (lc, Forall as t)</span>
<span class="lineno"> 1050 </span><span class="spaces">          </span><span class="istickedoff">| S.member lc avail -&gt; do</span>
<span class="lineno"> 1051 </span><span class="spaces">           </span><span class="istickedoff">when (isDeprecated lc) $</span>
<span class="lineno"> 1052 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">case t of</span></span>
<span class="lineno"> 1053 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">TyCon _typos FunCon _args -&gt;</span></span>
<span class="lineno"> 1054 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">recordWarning (getPos x) $ &quot;Function is deprecated: &quot; &lt;&gt; show x</span></span>
<span class="lineno"> 1055 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">_ -&gt;</span></span>
<span class="lineno"> 1056 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">recordWarning (getPos x) $ &quot;Value is deprecated: &quot; &lt;&gt; show x</span></span>
<span class="lineno"> 1057 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1058 </span><span class="spaces">           </span><span class="istickedoff">-- get a fresh tyvar for each quantifier binding, convert</span>
<span class="lineno"> 1059 </span><span class="spaces">           </span><span class="istickedoff">-- to a name -&gt; ty map, and substitute the fresh tyvars</span>
<span class="lineno"> 1060 </span><span class="spaces">           </span><span class="istickedoff">let once (apos, a) = do</span>
<span class="lineno"> 1061 </span><span class="spaces">                 </span><span class="istickedoff">at &lt;- getFreshTyVar apos</span>
<span class="lineno"> 1062 </span><span class="spaces">                 </span><span class="istickedoff">return (a, (Current, ConcreteType at))</span>
<span class="lineno"> 1063 </span><span class="spaces">           </span><span class="istickedoff">substs &lt;- mapM once as</span>
<span class="lineno"> 1064 </span><span class="spaces">           </span><span class="istickedoff">let t' = substituteTyVars avail (M.fromList substs) t</span>
<span class="lineno"> 1065 </span><span class="spaces">           </span><span class="istickedoff">return (Var x, t')</span>
<span class="lineno"> 1066 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1067 </span><span class="spaces">           </span><span class="istickedoff">recordError (getPos x) $ &quot;Inaccessible variable: &quot; ++ show x</span>
<span class="lineno"> 1068 </span><span class="spaces">           </span><span class="istickedoff">let how = if lc == HideDeprecated then &quot;deprecated&quot; else &quot;experimental&quot;</span>
<span class="lineno"> 1069 </span><span class="spaces">           </span><span class="istickedoff">recordError (getPos x) $ &quot;This command is available only after running &quot; ++</span>
<span class="lineno"> 1070 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;`enable_&quot; ++ how ++ &quot;`.&quot;</span>
<span class="lineno"> 1071 </span><span class="spaces">           </span><span class="istickedoff">t' &lt;- getFreshTyVar <span class="nottickedoff">(getPos x)</span></span>
<span class="lineno"> 1072 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">Var x</span>, t')</span>
<span class="lineno"> 1073 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1074 </span><span class="spaces">  </span><span class="istickedoff">Lambda pos mname pat body -&gt;</span>
<span class="lineno"> 1075 </span><span class="spaces">    </span><span class="istickedoff">do (pt, pat') &lt;- inferPattern pat</span>
<span class="lineno"> 1076 </span><span class="spaces">       </span><span class="istickedoff">(body', t) &lt;- withPattern pat' $ inferExpr (ln, body)</span>
<span class="lineno"> 1077 </span><span class="spaces">       </span><span class="istickedoff">return (Lambda <span class="nottickedoff">pos</span> mname pat' body', tFun (PosInferred InfContext (getPos body)) pt t)</span>
<span class="lineno"> 1078 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1079 </span><span class="spaces">  </span><span class="istickedoff">Application pos f arg -&gt;</span>
<span class="lineno"> 1080 </span><span class="spaces">    </span><span class="istickedoff">do argtype &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1081 </span><span class="spaces">       </span><span class="istickedoff">rettype &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1082 </span><span class="spaces">       </span><span class="istickedoff">let ftype = tFun (PosInferred InfContext $ getPos f) argtype rettype</span>
<span class="lineno"> 1083 </span><span class="spaces">       </span><span class="istickedoff">-- Check f' first so that we complain about the arg (not the</span>
<span class="lineno"> 1084 </span><span class="spaces">       </span><span class="istickedoff">-- function) if they don't match. This is what everyone expects</span>
<span class="lineno"> 1085 </span><span class="spaces">       </span><span class="istickedoff">-- and doing it the other way is surprisingly confusing.</span>
<span class="lineno"> 1086 </span><span class="spaces">       </span><span class="istickedoff">f' &lt;- checkExpr ln f ftype</span>
<span class="lineno"> 1087 </span><span class="spaces">       </span><span class="istickedoff">arg' &lt;- checkExpr ln arg argtype</span>
<span class="lineno"> 1088 </span><span class="spaces">       </span><span class="istickedoff">return (Application pos f' arg', rettype)</span>
<span class="lineno"> 1089 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1090 </span><span class="spaces">  </span><span class="istickedoff">Let pos dg body -&gt;</span>
<span class="lineno"> 1091 </span><span class="spaces">    </span><span class="istickedoff">do dg' &lt;- inferDeclGroup dg</span>
<span class="lineno"> 1092 </span><span class="spaces">       </span><span class="istickedoff">(body', t) &lt;- withDeclGroup dg' (inferExpr (<span class="nottickedoff">ln</span>, body))</span>
<span class="lineno"> 1093 </span><span class="spaces">       </span><span class="istickedoff">return (Let <span class="nottickedoff">pos</span> dg' body', t)</span>
<span class="lineno"> 1094 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1095 </span><span class="spaces">  </span><span class="istickedoff">TSig _pos e t -&gt;</span>
<span class="lineno"> 1096 </span><span class="spaces">    </span><span class="istickedoff">do t' &lt;- checkType kindStar t</span>
<span class="lineno"> 1097 </span><span class="spaces">       </span><span class="istickedoff">(e',t'') &lt;- inferExpr (<span class="nottickedoff">ln</span>,e)</span>
<span class="lineno"> 1098 </span><span class="spaces">       </span><span class="istickedoff">unify ln t' (getPos e') t''</span>
<span class="lineno"> 1099 </span><span class="spaces">       </span><span class="istickedoff">return (e',t'')</span>
<span class="lineno"> 1100 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1101 </span><span class="spaces">  </span><span class="istickedoff">IfThenElse pos e1 e2 e3 -&gt;</span>
<span class="lineno"> 1102 </span><span class="spaces">    </span><span class="istickedoff">do e1' &lt;- checkExpr ln e1 (tBool (PosInferred InfContext $ getPos e1))</span>
<span class="lineno"> 1103 </span><span class="spaces">       </span><span class="istickedoff">(e2', t) &lt;- inferExpr (<span class="nottickedoff">ln</span>, e2)</span>
<span class="lineno"> 1104 </span><span class="spaces">       </span><span class="istickedoff">e3' &lt;- checkExpr ln e3 t</span>
<span class="lineno"> 1105 </span><span class="spaces">       </span><span class="istickedoff">return (IfThenElse <span class="nottickedoff">pos</span> e1' e2' e3', t)</span></span>
<span class="lineno"> 1106 </span>
<span class="lineno"> 1107 </span>--
<span class="lineno"> 1108 </span>-- Check the type of an expr, by inferring and then unifying the
<span class="lineno"> 1109 </span>-- result.
<span class="lineno"> 1110 </span>--
<span class="lineno"> 1111 </span>checkExpr :: LName -&gt; Expr -&gt; Type -&gt; TI OutExpr
<span class="lineno"> 1112 </span><span class="decl"><span class="istickedoff">checkExpr m e t = do</span>
<span class="lineno"> 1113 </span><span class="spaces">  </span><span class="istickedoff">(e',t') &lt;- inferExpr (m,e)</span>
<span class="lineno"> 1114 </span><span class="spaces">  </span><span class="istickedoff">unify m t (getPos e') t'</span>
<span class="lineno"> 1115 </span><span class="spaces">  </span><span class="istickedoff">return e'</span></span>
<span class="lineno"> 1116 </span>
<span class="lineno"> 1117 </span>--
<span class="lineno"> 1118 </span>-- patterns
<span class="lineno"> 1119 </span>--
<span class="lineno"> 1120 </span>
<span class="lineno"> 1121 </span>-- Infer types for a pattern, producing fresh type variables as needed.
<span class="lineno"> 1122 </span>--
<span class="lineno"> 1123 </span>-- There may already be types in the pattern if there were explicit
<span class="lineno"> 1124 </span>-- type annotations in the input; if so don't throw them away.
<span class="lineno"> 1125 </span>inferPattern :: Pattern -&gt; TI (Type, Pattern)
<span class="lineno"> 1126 </span><span class="decl"><span class="istickedoff">inferPattern pat =</span>
<span class="lineno"> 1127 </span><span class="spaces">  </span><span class="istickedoff">let resolveType pos mt = case mt of</span>
<span class="lineno"> 1128 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1129 </span><span class="spaces">        </span><span class="istickedoff">Just t -&gt; checkType kindStar t</span>
<span class="lineno"> 1130 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1131 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1132 </span><span class="spaces">    </span><span class="istickedoff">PWild pos mt -&gt;</span>
<span class="lineno"> 1133 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- resolveType <span class="nottickedoff">pos</span> mt</span>
<span class="lineno"> 1134 </span><span class="spaces">         </span><span class="istickedoff">return (t, PWild <span class="nottickedoff">pos</span> (Just t))</span>
<span class="lineno"> 1135 </span><span class="spaces">    </span><span class="istickedoff">PVar pos x mt -&gt;</span>
<span class="lineno"> 1136 </span><span class="spaces">      </span><span class="istickedoff">do t &lt;- resolveType <span class="nottickedoff">pos</span> mt</span>
<span class="lineno"> 1137 </span><span class="spaces">         </span><span class="istickedoff">return (t, PVar pos x (Just t))</span>
<span class="lineno"> 1138 </span><span class="spaces">    </span><span class="istickedoff">PTuple pos ps -&gt;</span>
<span class="lineno"> 1139 </span><span class="spaces">      </span><span class="istickedoff">do (ts, ps') &lt;- unzip &lt;$&gt; mapM inferPattern ps</span>
<span class="lineno"> 1140 </span><span class="spaces">         </span><span class="istickedoff">return (tTuple <span class="nottickedoff">(PosInferred InfTerm pos)</span> ts, PTuple <span class="nottickedoff">pos</span> ps')</span></span>
<span class="lineno"> 1141 </span>
<span class="lineno"> 1142 </span>-- Check the type of a pattern, by inferring and then unifying the
<span class="lineno"> 1143 </span>-- result.
<span class="lineno"> 1144 </span>checkPattern :: LName -&gt; Type -&gt; Pattern -&gt; TI Pattern
<span class="lineno"> 1145 </span><span class="decl"><span class="istickedoff">checkPattern ln t pat =</span>
<span class="lineno"> 1146 </span><span class="spaces">  </span><span class="istickedoff">do (pt, pat') &lt;- inferPattern pat</span>
<span class="lineno"> 1147 </span><span class="spaces">     </span><span class="istickedoff">unify ln t (getPos pat) pt</span>
<span class="lineno"> 1148 </span><span class="spaces">     </span><span class="istickedoff">return pat'</span></span>
<span class="lineno"> 1149 </span>
<span class="lineno"> 1150 </span>--
<span class="lineno"> 1151 </span>-- statements
<span class="lineno"> 1152 </span>--
<span class="lineno"> 1153 </span>
<span class="lineno"> 1154 </span>-- Wrap m with a typedef binding.
<span class="lineno"> 1155 </span>--
<span class="lineno"> 1156 </span>-- The expansion (t) has been checked, so it's ok to panic if it
<span class="lineno"> 1157 </span>-- refers to something not visible in the environment.
<span class="lineno"> 1158 </span>withTypedef :: LName -&gt; Type -&gt; TI a -&gt; TI a
<span class="lineno"> 1159 </span><span class="decl"><span class="istickedoff">withTypedef n t m =</span>
<span class="lineno"> 1160 </span><span class="spaces">  </span><span class="istickedoff">TI $</span>
<span class="lineno"> 1161 </span><span class="spaces">  </span><span class="istickedoff">local</span>
<span class="lineno"> 1162 </span><span class="spaces">    </span><span class="istickedoff">(\ro -&gt;</span>
<span class="lineno"> 1163 </span><span class="spaces">      </span><span class="istickedoff">let t' = substituteTyVars (primsAvail ro) (tyEnv ro) t</span>
<span class="lineno"> 1164 </span><span class="spaces">      </span><span class="istickedoff">in  ro { tyEnv = M.insert (getVal n) (Current, ConcreteType t') $ tyEnv ro })</span>
<span class="lineno"> 1165 </span><span class="spaces">    </span><span class="istickedoff">$ unTI m</span></span>
<span class="lineno"> 1166 </span>
<span class="lineno"> 1167 </span>-- break a monadic type down into its monad and value types, if it is one
<span class="lineno"> 1168 </span>--
<span class="lineno"> 1169 </span>--    monadType (TopLevel Int) gives Just (TopLevel, Int)
<span class="lineno"> 1170 </span>--    monadType Int gives Nothing
<span class="lineno"> 1171 </span>--
<span class="lineno"> 1172 </span>monadType  :: Type -&gt; Maybe (Type, Type)
<span class="lineno"> 1173 </span><span class="decl"><span class="istickedoff">monadType ty = case ty of</span>
<span class="lineno"> 1174 </span><span class="spaces">  </span><span class="istickedoff">TyCon _ BlockCon [ctx@(TyCon _ (ContextCon _) []), valty] -&gt;</span>
<span class="lineno"> 1175 </span><span class="spaces">      </span><span class="istickedoff">Just (ctx, valty)</span>
<span class="lineno"> 1176 </span><span class="spaces">  </span><span class="istickedoff">-- We don't currently ever generate this type, but be future-proof</span>
<span class="lineno"> 1177 </span><span class="spaces">  </span><span class="istickedoff">TyCon pos (ContextCon ctx) [valty] -&gt;</span>
<span class="lineno"> 1178 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Just (TyCon pos (ContextCon ctx) [], valty)</span></span>
<span class="lineno"> 1179 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1180 </span><span class="spaces">      </span><span class="istickedoff">Nothing</span></span>
<span class="lineno"> 1181 </span>
<span class="lineno"> 1182 </span>-- wrap an expression in &quot;return&quot;
<span class="lineno"> 1183 </span>wrapReturn :: Expr -&gt; Expr
<span class="lineno"> 1184 </span><span class="decl"><span class="istickedoff">wrapReturn e =</span>
<span class="lineno"> 1185 </span><span class="spaces">   </span><span class="istickedoff">let <span class="nottickedoff">ePos = getPos e</span></span>
<span class="lineno"> 1186 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">retPos = PosInternal &quot;&lt;implicitly inserted return&gt;&quot;</span></span>
<span class="lineno"> 1187 </span><span class="spaces">       </span><span class="istickedoff">ret = Var $ Located &quot;return&quot; <span class="nottickedoff">&quot;return&quot;</span> <span class="nottickedoff">retPos</span> </span>
<span class="lineno"> 1188 </span><span class="spaces">   </span><span class="istickedoff">in</span>
<span class="lineno"> 1189 </span><span class="spaces">   </span><span class="istickedoff">Application <span class="nottickedoff">ePos</span> ret e</span></span>
<span class="lineno"> 1190 </span>
<span class="lineno"> 1191 </span>-- type inference for a single statement
<span class="lineno"> 1192 </span>--
<span class="lineno"> 1193 </span>-- the boolean is whether we're at the syntactic top level, which is used
<span class="lineno"> 1194 </span>-- for workaround logic for issue #2162
<span class="lineno"> 1195 </span>--
<span class="lineno"> 1196 </span>-- the passed-in position should be the position associated with the monad type
<span class="lineno"> 1197 </span>-- the first type argument (ctx) is the monad type for any binds that occur
<span class="lineno"> 1198 </span>--
<span class="lineno"> 1199 </span>-- returns a wrapper for checking subsequent statements as well as
<span class="lineno"> 1200 </span>-- an updated statement.
<span class="lineno"> 1201 </span>inferStmt :: LName -&gt; Bool -&gt; Pos -&gt; Type -&gt; Stmt -&gt; TI (TI a -&gt; TI a, Stmt)
<span class="lineno"> 1202 </span><span class="decl"><span class="istickedoff">inferStmt ln atSyntacticTopLevel blockpos ctx s =</span>
<span class="lineno"> 1203 </span><span class="spaces">    </span><span class="istickedoff">case s of</span>
<span class="lineno"> 1204 </span><span class="spaces">        </span><span class="istickedoff">StmtBind spos pat e -&gt; do</span>
<span class="lineno"> 1205 </span><span class="spaces">            </span><span class="istickedoff">(pty, pat') &lt;- inferPattern pat</span>
<span class="lineno"> 1206 </span><span class="spaces">            </span><span class="istickedoff">-- The expression should be of monad type. The</span>
<span class="lineno"> 1207 </span><span class="spaces">            </span><span class="istickedoff">-- straightforward way to proceed here is to unify both</span>
<span class="lineno"> 1208 </span><span class="spaces">            </span><span class="istickedoff">-- the monad type (ctx) and the result type expected by</span>
<span class="lineno"> 1209 </span><span class="spaces">            </span><span class="istickedoff">-- the pattern (pty), like this:</span>
<span class="lineno"> 1210 </span><span class="spaces">            </span><span class="istickedoff">--    e' &lt;- checkExpr ln e (tBlock blockpos ctx pty)</span>
<span class="lineno"> 1211 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1212 </span><span class="spaces">            </span><span class="istickedoff">-- However, historically when at the syntactic top level</span>
<span class="lineno"> 1213 </span><span class="spaces">            </span><span class="istickedoff">-- (only), the monad type was left off, meaning that</span>
<span class="lineno"> 1214 </span><span class="spaces">            </span><span class="istickedoff">-- various incorrect forms were silently accepted. Fixing</span>
<span class="lineno"> 1215 </span><span class="spaces">            </span><span class="istickedoff">-- this in Dec 2024 triggered a lot of fallout, so for the</span>
<span class="lineno"> 1216 </span><span class="spaces">            </span><span class="istickedoff">-- time being we want to check for, warn about, and allow</span>
<span class="lineno"> 1217 </span><span class="spaces">            </span><span class="istickedoff">-- the following cases. (Again, only when at the syntactic</span>
<span class="lineno"> 1218 </span><span class="spaces">            </span><span class="istickedoff">-- top level. Which is not when in the TopLevel monad.)</span>
<span class="lineno"> 1219 </span><span class="spaces">            </span><span class="istickedoff">--    x &lt;- e for non-monadic e</span>
<span class="lineno"> 1220 </span><span class="spaces">            </span><span class="istickedoff">--    x &lt;- e for e in the wrong monad</span>
<span class="lineno"> 1221 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1222 </span><span class="spaces">            </span><span class="istickedoff">-- These should be made errors again at some point, but</span>
<span class="lineno"> 1223 </span><span class="spaces">            </span><span class="istickedoff">-- definitely no earlier than the _second_ release after</span>
<span class="lineno"> 1224 </span><span class="spaces">            </span><span class="istickedoff">-- December 2024, as the first such release should include</span>
<span class="lineno"> 1225 </span><span class="spaces">            </span><span class="istickedoff">-- the warning behavior. Probably the explicit messages</span>
<span class="lineno"> 1226 </span><span class="spaces">            </span><span class="istickedoff">-- should then in turn not be removed for at least one</span>
<span class="lineno"> 1227 </span><span class="spaces">            </span><span class="istickedoff">-- further release. See #2167 and #2162.</span>
<span class="lineno"> 1228 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1229 </span><span class="spaces">            </span><span class="istickedoff">-- To accomplish this, call inferExpr to get a type for</span>
<span class="lineno"> 1230 </span><span class="spaces">            </span><span class="istickedoff">-- the expression, and examine it. If the special cases</span>
<span class="lineno"> 1231 </span><span class="spaces">            </span><span class="istickedoff">-- apply, issue special-case warnings with explanations,</span>
<span class="lineno"> 1232 </span><span class="spaces">            </span><span class="istickedoff">-- unify the type with only the pattern type, and patch up</span>
<span class="lineno"> 1233 </span><span class="spaces">            </span><span class="istickedoff">-- the expression by wrapping it in &quot;return&quot;.  (The latter</span>
<span class="lineno"> 1234 </span><span class="spaces">            </span><span class="istickedoff">-- will restore the old behavior for both cases, so we</span>
<span class="lineno"> 1235 </span><span class="spaces">            </span><span class="istickedoff">-- don't need to also gunk up the interpreter to handle</span>
<span class="lineno"> 1236 </span><span class="spaces">            </span><span class="istickedoff">-- this problem.)</span>
<span class="lineno"> 1237 </span><span class="spaces">            </span><span class="istickedoff">--</span>
<span class="lineno"> 1238 </span><span class="spaces">            </span><span class="istickedoff">-- If the special cases don't apply, unify the result type</span>
<span class="lineno"> 1239 </span><span class="spaces">            </span><span class="istickedoff">-- with the complete type.</span>
<span class="lineno"> 1240 </span><span class="spaces">            </span><span class="istickedoff">(e', ty) &lt;- inferExpr (ln, e)</span>
<span class="lineno"> 1241 </span><span class="spaces">            </span><span class="istickedoff">ty' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs ty</span>
<span class="lineno"> 1242 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1243 </span><span class="spaces">            </span><span class="istickedoff">-- The correct, restricted case</span>
<span class="lineno"> 1244 </span><span class="spaces">            </span><span class="istickedoff">let restrictToCorrect = do</span>
<span class="lineno"> 1245 </span><span class="spaces">                  </span><span class="istickedoff">-- unify the type of e with the expected monad and</span>
<span class="lineno"> 1246 </span><span class="spaces">                  </span><span class="istickedoff">-- pattern types</span>
<span class="lineno"> 1247 </span><span class="spaces">                  </span><span class="istickedoff">unify ln (tBlock blockpos ctx pty) (getPos e') ty</span>
<span class="lineno"> 1248 </span><span class="spaces">                  </span><span class="istickedoff">return e'</span>
<span class="lineno"> 1249 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1250 </span><span class="spaces">            </span><span class="istickedoff">-- The special case for non-monadic values</span>
<span class="lineno"> 1251 </span><span class="spaces">            </span><span class="istickedoff">let allowNonMonadic = do</span>
<span class="lineno"> 1252 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;Monadic bind of non-monadic value; &quot; ++</span>
<span class="lineno"> 1253 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;rewrite as let-binding or use return&quot;</span>
<span class="lineno"> 1254 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This will become an error in a &quot; ++</span>
<span class="lineno"> 1255 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;future release of SAW&quot;</span>
<span class="lineno"> 1256 </span><span class="spaces">                  </span><span class="istickedoff">unify ln pty (getPos e') ty</span>
<span class="lineno"> 1257 </span><span class="spaces">                  </span><span class="istickedoff">-- Wrap the expression in &quot;return&quot; to correct the type</span>
<span class="lineno"> 1258 </span><span class="spaces">                  </span><span class="istickedoff">return $ wrapReturn e'</span>
<span class="lineno"> 1259 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1260 </span><span class="spaces">            </span><span class="istickedoff">-- The special case for the wrong monad</span>
<span class="lineno"> 1261 </span><span class="spaces">            </span><span class="istickedoff">let allowWrongMonad ctx' valty' = do</span>
<span class="lineno"> 1262 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;Monadic bind with the wrong monad; &quot; ++</span>
<span class="lineno"> 1263 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;found &quot; ++ pShow ctx' ++</span>
<span class="lineno"> 1264 </span><span class="spaces">                                       </span><span class="istickedoff">&quot; but expected &quot; ++ pShow ctx</span>
<span class="lineno"> 1265 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This creates the action but does &quot; ++</span>
<span class="lineno"> 1266 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;not execute it; if you meant to do &quot; ++</span>
<span class="lineno"> 1267 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;that, prefix the &quot; ++</span>
<span class="lineno"> 1268 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;expression with return&quot;</span>
<span class="lineno"> 1269 </span><span class="spaces">                  </span><span class="istickedoff">recordWarning spos $ &quot;This will become an error in a &quot; ++</span>
<span class="lineno"> 1270 </span><span class="spaces">                                       </span><span class="istickedoff">&quot;future release of SAW&quot;</span>
<span class="lineno"> 1271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1272 </span><span class="spaces">                  </span><span class="istickedoff">-- The historic behavior is that the pattern gets bound</span>
<span class="lineno"> 1273 </span><span class="spaces">                  </span><span class="istickedoff">-- to a value of type m t instead of type t. This means:</span>
<span class="lineno"> 1274 </span><span class="spaces">                  </span><span class="istickedoff">--    - we should unify pty, which is the type of the</span>
<span class="lineno"> 1275 </span><span class="spaces">                  </span><span class="istickedoff">--      pattern, with m t, which is tBlock ctx' valty'</span>
<span class="lineno"> 1276 </span><span class="spaces">                  </span><span class="istickedoff">--      (rather than tBlock ctx valty', which is the</span>
<span class="lineno"> 1277 </span><span class="spaces">                  </span><span class="istickedoff">--      type we should be getting)</span>
<span class="lineno"> 1278 </span><span class="spaces">                  </span><span class="istickedoff">--    - this will fail if the pattern includes a type</span>
<span class="lineno"> 1279 </span><span class="spaces">                  </span><span class="istickedoff">--      signature with a non-monad type, but that's ok</span>
<span class="lineno"> 1280 </span><span class="spaces">                  </span><span class="istickedoff">--      because that case also fails in old SAW</span>
<span class="lineno"> 1281 </span><span class="spaces">                  </span><span class="istickedoff">--    - we do _not_ need to update pty before returning</span>
<span class="lineno"> 1282 </span><span class="spaces">                  </span><span class="istickedoff">--      it out of inferStmt</span>
<span class="lineno"> 1283 </span><span class="spaces">                  </span><span class="istickedoff">--    - we _do_ need to wrap the expression in &quot;return&quot;</span>
<span class="lineno"> 1284 </span><span class="spaces">                  </span><span class="istickedoff">--      so that the ultimate results are well-typed and</span>
<span class="lineno"> 1285 </span><span class="spaces">                  </span><span class="istickedoff">--      happen in the TopLevel monad</span>
<span class="lineno"> 1286 </span><span class="spaces">                  </span><span class="istickedoff">unify ln pty (getPos e') (tBlock spos ctx' valty')</span>
<span class="lineno"> 1287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1288 </span><span class="spaces">                  </span><span class="istickedoff">-- Wrap the expression in &quot;return&quot; to produce an</span>
<span class="lineno"> 1289 </span><span class="spaces">                  </span><span class="istickedoff">-- expression of type TopLevel (m t).</span>
<span class="lineno"> 1290 </span><span class="spaces">                  </span><span class="istickedoff">return $ wrapReturn e'</span>
<span class="lineno"> 1291 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1292 </span><span class="spaces">            </span><span class="istickedoff">-- Figure out which case applies.</span>
<span class="lineno"> 1293 </span><span class="spaces">            </span><span class="istickedoff">e'' &lt;-</span>
<span class="lineno"> 1294 </span><span class="spaces">                </span><span class="istickedoff">if not atSyntacticTopLevel then</span>
<span class="lineno"> 1295 </span><span class="spaces">                    </span><span class="istickedoff">restrictToCorrect</span>
<span class="lineno"> 1296 </span><span class="spaces">                </span><span class="istickedoff">else do</span>
<span class="lineno"> 1297 </span><span class="spaces">                    </span><span class="istickedoff">ok &lt;- matches (tBlock <span class="nottickedoff">blockpos</span> ctx pty) ty</span>
<span class="lineno"> 1298 </span><span class="spaces">                    </span><span class="istickedoff">if ok then</span>
<span class="lineno"> 1299 </span><span class="spaces">                        </span><span class="istickedoff">restrictToCorrect</span>
<span class="lineno"> 1300 </span><span class="spaces">                    </span><span class="istickedoff">else</span>
<span class="lineno"> 1301 </span><span class="spaces">                        </span><span class="istickedoff">case monadType ty' of</span>
<span class="lineno"> 1302 </span><span class="spaces">                            </span><span class="istickedoff">Just (ctx', valty') -&gt;</span>
<span class="lineno"> 1303 </span><span class="spaces">                               </span><span class="istickedoff">-- Allow it only for _ and a single var.</span>
<span class="lineno"> 1304 </span><span class="spaces">                               </span><span class="istickedoff">-- Binding elements of a tuple this way</span>
<span class="lineno"> 1305 </span><span class="spaces">                               </span><span class="istickedoff">-- failed typecheck in the old saw and</span>
<span class="lineno"> 1306 </span><span class="spaces">                               </span><span class="istickedoff">-- doesn't need to be allowed now.</span>
<span class="lineno"> 1307 </span><span class="spaces">                               </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1308 </span><span class="spaces">                                   </span><span class="istickedoff">PTuple _ _ -&gt; restrictToCorrect</span>
<span class="lineno"> 1309 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; allowWrongMonad ctx' valty'</span>
<span class="lineno"> 1310 </span><span class="spaces">                            </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1311 </span><span class="spaces">                               </span><span class="istickedoff">-- allow it only if actually binding something</span>
<span class="lineno"> 1312 </span><span class="spaces">                               </span><span class="istickedoff">-- (just proclaiming a value by itself is not a</span>
<span class="lineno"> 1313 </span><span class="spaces">                               </span><span class="istickedoff">-- case we need to worry about)</span>
<span class="lineno"> 1314 </span><span class="spaces">                               </span><span class="istickedoff">case pat of</span>
<span class="lineno"> 1315 </span><span class="spaces">                                   </span><span class="istickedoff">PWild _ _ -&gt; restrictToCorrect</span>
<span class="lineno"> 1316 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; allowNonMonadic</span>
<span class="lineno"> 1317 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1318 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtBind spos pat' e''</span>
<span class="lineno"> 1319 </span><span class="spaces">            </span><span class="istickedoff">let wrapper = withPattern pat'</span>
<span class="lineno"> 1320 </span><span class="spaces">            </span><span class="istickedoff">return (wrapper, s')</span>
<span class="lineno"> 1321 </span><span class="spaces">        </span><span class="istickedoff">StmtLet spos dg -&gt; do</span>
<span class="lineno"> 1322 </span><span class="spaces">            </span><span class="istickedoff">dg' &lt;- inferDeclGroup dg</span>
<span class="lineno"> 1323 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtLet <span class="nottickedoff">spos</span> dg'</span>
<span class="lineno"> 1324 </span><span class="spaces">            </span><span class="istickedoff">let wrapper = withDeclGroup dg'</span>
<span class="lineno"> 1325 </span><span class="spaces">            </span><span class="istickedoff">return (wrapper, s')</span>
<span class="lineno"> 1326 </span><span class="spaces">        </span><span class="istickedoff">StmtCode _spos _ -&gt;</span>
<span class="lineno"> 1327 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">id</span>, s)</span>
<span class="lineno"> 1328 </span><span class="spaces">        </span><span class="istickedoff">StmtImport _spos _ -&gt;</span>
<span class="lineno"> 1329 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">id</span>, s)</span>
<span class="lineno"> 1330 </span><span class="spaces">        </span><span class="istickedoff">StmtTypedef spos name ty -&gt; do</span>
<span class="lineno"> 1331 </span><span class="spaces">            </span><span class="istickedoff">ty' &lt;- checkType kindStar ty</span>
<span class="lineno"> 1332 </span><span class="spaces">            </span><span class="istickedoff">let s' = StmtTypedef <span class="nottickedoff">spos</span> name ty'</span>
<span class="lineno"> 1333 </span><span class="spaces">            </span><span class="istickedoff">let wrapper = withTypedef name ty'</span>
<span class="lineno"> 1334 </span><span class="spaces">            </span><span class="istickedoff">return (wrapper, s')</span></span>
<span class="lineno"> 1335 </span>
<span class="lineno"> 1336 </span>-- Inference for a do-block.
<span class="lineno"> 1337 </span>--
<span class="lineno"> 1338 </span>-- The passed-in position should be the position for the whole
<span class="lineno"> 1339 </span>-- statement block.
<span class="lineno"> 1340 </span>--
<span class="lineno"> 1341 </span>-- The first type argument (ctx) is the monad type for the block.
<span class="lineno"> 1342 </span>--
<span class="lineno"> 1343 </span>-- The second type argument (ty) is the expected full result type for
<span class="lineno"> 1344 </span>-- the block (including the monad) to be unified with the result type
<span class="lineno"> 1345 </span>-- found.
<span class="lineno"> 1346 </span>--
<span class="lineno"> 1347 </span>inferBlock :: LName -&gt; Pos -&gt; Type -&gt; Type -&gt; ([Stmt], Expr) -&gt; TI ([OutStmt], OutExpr)
<span class="lineno"> 1348 </span><span class="decl"><span class="istickedoff">inferBlock ln blockpos ctx ty (stmts0, lastexpr) = do</span>
<span class="lineno"> 1349 </span><span class="spaces">  </span><span class="istickedoff">let atSyntacticTopLevel = False</span>
<span class="lineno"> 1350 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1351 </span><span class="spaces">  </span><span class="istickedoff">-- Check the statements in order, left first, passing through the</span>
<span class="lineno"> 1352 </span><span class="spaces">  </span><span class="istickedoff">-- wrapper produced by inferStmt.</span>
<span class="lineno"> 1353 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1354 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: this should really use foldlM on the statement list, except</span>
<span class="lineno"> 1355 </span><span class="spaces">  </span><span class="istickedoff">-- it doesn't typecheck that way because the type of the wrapper</span>
<span class="lineno"> 1356 </span><span class="spaces">  </span><span class="istickedoff">-- goes ... off the rails.</span>
<span class="lineno"> 1357 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1358 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: those wrappers should go away anyhow; it's a messy way of</span>
<span class="lineno"> 1359 </span><span class="spaces">  </span><span class="istickedoff">-- updating the typing environment by pretending that each statement</span>
<span class="lineno"> 1360 </span><span class="spaces">  </span><span class="istickedoff">-- in a do-block is nested inside the previous one. Things should</span>
<span class="lineno"> 1361 </span><span class="spaces">  </span><span class="istickedoff">-- get rearranged so we just update the environment in the monad</span>
<span class="lineno"> 1362 </span><span class="spaces">  </span><span class="istickedoff">-- context, instead of pretending that's not what we're doing.</span>
<span class="lineno"> 1363 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1364 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: Because of this rubbish we have to check the last expression</span>
<span class="lineno"> 1365 </span><span class="spaces">  </span><span class="istickedoff">-- _inside_ the loop when we get to the end of the list, instead of</span>
<span class="lineno"> 1366 </span><span class="spaces">  </span><span class="istickedoff">-- just doing it afterwards. Blegh.</span>
<span class="lineno"> 1367 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1368 </span><span class="spaces">  </span><span class="istickedoff">let go stmts = case stmts of</span>
<span class="lineno"> 1369 </span><span class="spaces">        </span><span class="istickedoff">[] -&gt; do</span>
<span class="lineno"> 1370 </span><span class="spaces">          </span><span class="istickedoff">-- Check the final expression.</span>
<span class="lineno"> 1371 </span><span class="spaces">          </span><span class="istickedoff">-- This produces the result type for the block.</span>
<span class="lineno"> 1372 </span><span class="spaces">          </span><span class="istickedoff">(lastexpr', ty') &lt;- inferExpr (<span class="nottickedoff">ln</span>, lastexpr)</span>
<span class="lineno"> 1373 </span><span class="spaces">          </span><span class="istickedoff">unify <span class="nottickedoff">ln</span> ty <span class="nottickedoff">(getPos lastexpr)</span> ty'</span>
<span class="lineno"> 1374 </span><span class="spaces">          </span><span class="istickedoff">return ([], lastexpr')</span>
<span class="lineno"> 1375 </span><span class="spaces">        </span><span class="istickedoff">stmt : more -&gt; do</span>
<span class="lineno"> 1376 </span><span class="spaces">          </span><span class="istickedoff">(wrapper, stmt') &lt;- inferStmt ln atSyntacticTopLevel <span class="nottickedoff">blockpos</span> ctx stmt</span>
<span class="lineno"> 1377 </span><span class="spaces">          </span><span class="istickedoff">(more', lastexpr') &lt;- wrapper $ go more</span>
<span class="lineno"> 1378 </span><span class="spaces">          </span><span class="istickedoff">return (stmt' : more', lastexpr')</span>
<span class="lineno"> 1379 </span><span class="spaces">  </span><span class="istickedoff">go stmts0</span></span>
<span class="lineno"> 1380 </span>
<span class="lineno"> 1381 </span>-- Wrapper around inferStmt suitable for checking one statement at a
<span class="lineno"> 1382 </span>-- time. This is temporary scaffolding for the interpreter while
<span class="lineno"> 1383 </span>-- fixing it. (Currently the interpreter typechecks one statement at a
<span class="lineno"> 1384 </span>-- time when executing, even when not at the repl, and this involves
<span class="lineno"> 1385 </span>-- assorted messiness and technical debt. Eventually we'll get it into
<span class="lineno"> 1386 </span>-- a state where we can always just typecheck immediately after
<span class="lineno"> 1387 </span>-- parsing (including incrementally from the repl) but we're some
<span class="lineno"> 1388 </span>-- distance from that. In the meantime the first step is to get it to
<span class="lineno"> 1389 </span>-- typecheck one statement at a time without special-casing any of
<span class="lineno"> 1390 </span>-- them, and this is how it does that.
<span class="lineno"> 1391 </span>--
<span class="lineno"> 1392 </span>-- Run inferStmt and then apply the current substitution before
<span class="lineno"> 1393 </span>-- returning the updated statement. Ignore the wrapper returned for
<span class="lineno"> 1394 </span>-- typechecking subsequent statements; the interpreter has its own
<span class="lineno"> 1395 </span>-- (misbegotten) logic for handling that in its own way. (Which should
<span class="lineno"> 1396 </span>-- be removed, but we need to get rid of these wrappers here first;
<span class="lineno"> 1397 </span>-- any sane incremental typechecking interface requires updating the
<span class="lineno"> 1398 </span>-- environment for sequential declarations, not pretending that
<span class="lineno"> 1399 </span>-- subsequent statements in a block are nested inside prior ones.)
<span class="lineno"> 1400 </span>inferSingleStmt :: LName -&gt; Pos -&gt; Type -&gt; Stmt -&gt; TI Stmt
<span class="lineno"> 1401 </span><span class="decl"><span class="istickedoff">inferSingleStmt ln pos ctx s = do</span>
<span class="lineno"> 1402 </span><span class="spaces">  </span><span class="istickedoff">-- currently we are always at the syntactic top level here because</span>
<span class="lineno"> 1403 </span><span class="spaces">  </span><span class="istickedoff">-- that's how the interpreter works</span>
<span class="lineno"> 1404 </span><span class="spaces">  </span><span class="istickedoff">let atSyntacticTopLevel = True</span>
<span class="lineno"> 1405 </span><span class="spaces">  </span><span class="istickedoff">(_wrapper, s') &lt;- inferStmt ln atSyntacticTopLevel pos ctx s</span>
<span class="lineno"> 1406 </span><span class="spaces">  </span><span class="istickedoff">s'' &lt;- applyCurrentSubst s'</span>
<span class="lineno"> 1407 </span><span class="spaces">  </span><span class="istickedoff">return s''</span></span>
<span class="lineno"> 1408 </span>
<span class="lineno"> 1409 </span>--
<span class="lineno"> 1410 </span>-- decls
<span class="lineno"> 1411 </span>--
<span class="lineno"> 1412 </span>
<span class="lineno"> 1413 </span>-- Create a type schema for a list of mutually referential
<span class="lineno"> 1414 </span>-- declarations out of their free vars.
<span class="lineno"> 1415 </span>--
<span class="lineno"> 1416 </span>-- (This creates names for any remaining unification vars, so
<span class="lineno"> 1417 </span>-- potentially updates the expression.)
<span class="lineno"> 1418 </span>--
<span class="lineno"> 1419 </span>-- The &quot;foralls&quot; argument is a set of tyvars that were mentioned
<span class="lineno"> 1420 </span>-- explicitly and should be forall-bound.
<span class="lineno"> 1421 </span>generalize :: Map Name Pos -&gt; [OutExpr] -&gt; [Type] -&gt; TI [(OutExpr,Schema)]
<span class="lineno"> 1422 </span><span class="decl"><span class="istickedoff">generalize foralls es0 ts0 = do</span>
<span class="lineno"> 1423 </span><span class="spaces">     </span><span class="istickedoff">-- first, substitute away any resolved unification variables</span>
<span class="lineno"> 1424 </span><span class="spaces">     </span><span class="istickedoff">-- in both the expressions and types.</span>
<span class="lineno"> 1425 </span><span class="spaces">     </span><span class="istickedoff">es &lt;- applyCurrentSubst es0</span>
<span class="lineno"> 1426 </span><span class="spaces">     </span><span class="istickedoff">ts &lt;- applyCurrentSubst ts0</span>
<span class="lineno"> 1427 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1428 </span><span class="spaces">     </span><span class="istickedoff">-- Extract lists of any unification vars and named type vars that</span>
<span class="lineno"> 1429 </span><span class="spaces">     </span><span class="istickedoff">-- still appear.</span>
<span class="lineno"> 1430 </span><span class="spaces">     </span><span class="istickedoff">let is0 = unifyVars ts</span>
<span class="lineno"> 1431 </span><span class="spaces">     </span><span class="istickedoff">let bs0 = namedTyVars ts</span>
<span class="lineno"> 1432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1433 </span><span class="spaces">     </span><span class="istickedoff">-- Drop any unification vars and named type vars that we</span>
<span class="lineno"> 1434 </span><span class="spaces">     </span><span class="istickedoff">-- shouldn't forall-bind.</span>
<span class="lineno"> 1435 </span><span class="spaces">     </span><span class="istickedoff">--</span>
<span class="lineno"> 1436 </span><span class="spaces">     </span><span class="istickedoff">-- For unification vars, any whose scope reaches beyond the</span>
<span class="lineno"> 1437 </span><span class="spaces">     </span><span class="istickedoff">-- current declaration should be left alone; they should only be</span>
<span class="lineno"> 1438 </span><span class="spaces">     </span><span class="istickedoff">-- bound when they eventually move out of scope. Get these by</span>
<span class="lineno"> 1439 </span><span class="spaces">     </span><span class="istickedoff">-- examining the types used in the right-hand sides of both the</span>
<span class="lineno"> 1440 </span><span class="spaces">     </span><span class="istickedoff">-- variable environment and the type environment.</span>
<span class="lineno"> 1441 </span><span class="spaces">     </span><span class="istickedoff">--</span>
<span class="lineno"> 1442 </span><span class="spaces">     </span><span class="istickedoff">-- For named vars, exclude any that appear that appear as keys</span>
<span class="lineno"> 1443 </span><span class="spaces">     </span><span class="istickedoff">-- (on the left-hand side) of the type environment. Those are</span>
<span class="lineno"> 1444 </span><span class="spaces">     </span><span class="istickedoff">-- already defined.</span>
<span class="lineno"> 1445 </span><span class="spaces">     </span><span class="istickedoff">--</span>
<span class="lineno"> 1446 </span><span class="spaces">     </span><span class="istickedoff">-- The only other named variables involved should be the set we</span>
<span class="lineno"> 1447 </span><span class="spaces">     </span><span class="istickedoff">-- explicitly intend to be forall-bound as passed in. Insert</span>
<span class="lineno"> 1448 </span><span class="spaces">     </span><span class="istickedoff">-- those, and favor their positions.</span>
<span class="lineno"> 1449 </span><span class="spaces">     </span><span class="istickedoff">--</span>
<span class="lineno"> 1450 </span><span class="spaces">     </span><span class="istickedoff">-- It would be handy for scaling if we didn't have to examine</span>
<span class="lineno"> 1451 </span><span class="spaces">     </span><span class="istickedoff">-- the entire variable environment (on the grounds that there</span>
<span class="lineno"> 1452 </span><span class="spaces">     </span><span class="istickedoff">-- should be no loose unification vars at the top level where</span>
<span class="lineno"> 1453 </span><span class="spaces">     </span><span class="istickedoff">-- most definitions will come from) but (a) we don't have the</span>
<span class="lineno"> 1454 </span><span class="spaces">     </span><span class="istickedoff">-- structure to support that and (b) it is not absolutely clear</span>
<span class="lineno"> 1455 </span><span class="spaces">     </span><span class="istickedoff">-- that there isn't a way to get such loose unification vars,</span>
<span class="lineno"> 1456 </span><span class="spaces">     </span><span class="istickedoff">-- in which case we'd have to do something about it.</span>
<span class="lineno"> 1457 </span><span class="spaces">     </span><span class="istickedoff">--</span>
<span class="lineno"> 1458 </span><span class="spaces">     </span><span class="istickedoff">-- This code also used to exclude named vars used on the</span>
<span class="lineno"> 1459 </span><span class="spaces">     </span><span class="istickedoff">-- right-hand side of the variable environment; this was to allow</span>
<span class="lineno"> 1460 </span><span class="spaces">     </span><span class="istickedoff">-- the use of otherwise undefined type names in the primitives</span>
<span class="lineno"> 1461 </span><span class="spaces">     </span><span class="istickedoff">-- table. There is no longer any need for such hackery, and</span>
<span class="lineno"> 1462 </span><span class="spaces">     </span><span class="istickedoff">-- undefined type names are not allowed to appear in the variable</span>
<span class="lineno"> 1463 </span><span class="spaces">     </span><span class="istickedoff">-- environment.</span>
<span class="lineno"> 1464 </span><span class="spaces">     </span><span class="istickedoff">--</span>
<span class="lineno"> 1465 </span><span class="spaces">     </span><span class="istickedoff">-- FUTURE: we end up replacing the user's forall-bound names with</span>
<span class="lineno"> 1466 </span><span class="spaces">     </span><span class="istickedoff">-- generated names, and I'm not sure why. It seems like it</span>
<span class="lineno"> 1467 </span><span class="spaces">     </span><span class="istickedoff">-- shouldn't be possible the way the code is structured. But the</span>
<span class="lineno"> 1468 </span><span class="spaces">     </span><span class="istickedoff">-- type signatures are coming out correct (which they wouldn't if</span>
<span class="lineno"> 1469 </span><span class="spaces">     </span><span class="istickedoff">-- something were seriously wrong) and we aren't inappropriately</span>
<span class="lineno"> 1470 </span><span class="spaces">     </span><span class="istickedoff">-- unifying these vars with each other or with other things, so</span>
<span class="lineno"> 1471 </span><span class="spaces">     </span><span class="istickedoff">-- I'm not going to stress over it right now.</span>
<span class="lineno"> 1472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1473 </span><span class="spaces">     </span><span class="istickedoff">envUnifyVars &lt;- unifyVarsInEnvs</span>
<span class="lineno"> 1474 </span><span class="spaces">     </span><span class="istickedoff">knownNamedVars &lt;- namedVarDefinitions</span>
<span class="lineno"> 1475 </span><span class="spaces">     </span><span class="istickedoff">let is1 = is0 M.\\ envUnifyVars</span>
<span class="lineno"> 1476 </span><span class="spaces">     </span><span class="istickedoff">let bs1 = M.union foralls $ M.withoutKeys bs0 knownNamedVars</span>
<span class="lineno"> 1477 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1478 </span><span class="spaces">     </span><span class="istickedoff">-- convert to lists</span>
<span class="lineno"> 1479 </span><span class="spaces">     </span><span class="istickedoff">let is2 = M.toList is1</span>
<span class="lineno"> 1480 </span><span class="spaces">     </span><span class="istickedoff">let bs2 = M.toList bs1</span>
<span class="lineno"> 1481 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1482 </span><span class="spaces">     </span><span class="istickedoff">-- if the position is &quot;fresh&quot; turn it into &quot;inferred from term&quot;</span>
<span class="lineno"> 1483 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">adjustPos pos = case pos of</span></span>
<span class="lineno"> 1484 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">PosInferred InfFresh pos' -&gt; PosInferred InfTerm pos'</span></span>
<span class="lineno"> 1485 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; pos</span></span>
<span class="lineno"> 1486 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1487 </span><span class="spaces">     </span><span class="istickedoff">-- generate names for the unification vars</span>
<span class="lineno"> 1488 </span><span class="spaces">     </span><span class="istickedoff">let is3 = [ (i, <span class="nottickedoff">adjustPos pos</span>, &quot;a.&quot; &lt;&gt; Text.pack (show i)) | (i, pos) &lt;- is2 ]</span>
<span class="lineno"> 1489 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1490 </span><span class="spaces">     </span><span class="istickedoff">-- build a substitution</span>
<span class="lineno"> 1491 </span><span class="spaces">     </span><span class="istickedoff">let s = substFromList [ (i, TyVar <span class="nottickedoff">pos</span> n) | (i, pos, n) &lt;- is3 ]</span>
<span class="lineno"> 1492 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1493 </span><span class="spaces">     </span><span class="istickedoff">-- get the names for the Forall</span>
<span class="lineno"> 1494 </span><span class="spaces">     </span><span class="istickedoff">let inames = [ (<span class="nottickedoff">pos</span>, n) | (_i, pos, n) &lt;- is3 ]</span>
<span class="lineno"> 1495 </span><span class="spaces">     </span><span class="istickedoff">let bnames = [ <span class="nottickedoff">(pos, x)</span> | (x, pos) &lt;- bs2 ]</span>
<span class="lineno"> 1496 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1497 </span><span class="spaces">     </span><span class="istickedoff">let mk e t = (appSubst <span class="nottickedoff">s</span> e, Forall (inames ++ bnames) (appSubst s t))</span>
<span class="lineno"> 1498 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1499 </span><span class="spaces">     </span><span class="istickedoff">return $ zipWith mk es ts</span></span>
<span class="lineno"> 1500 </span>
<span class="lineno"> 1501 </span>
<span class="lineno"> 1502 </span>-- Check that a type is a function and isn't a plain value, in order
<span class="lineno"> 1503 </span>-- to reject recursive values in &quot;rec&quot; definitions. Otherwise they
<span class="lineno"> 1504 </span>-- crash the interpreter downstream. See issue #2203.
<span class="lineno"> 1505 </span>--
<span class="lineno"> 1506 </span>-- There are cases where it might be convenient to include a plain
<span class="lineno"> 1507 </span>-- value within a system of recursive declarations. For example, if
<span class="lineno"> 1508 </span>-- you have something like
<span class="lineno"> 1509 </span>--    rec foo x = ...
<span class="lineno"> 1510 </span>--    and foo0 = foo 0
<span class="lineno"> 1511 </span>--    and foo1 = foo 1
<span class="lineno"> 1512 </span>--    and bar x = ...
<span class="lineno"> 1513 </span>--    and bar0 = bar 0
<span class="lineno"> 1514 </span>--    and bar1 = bar 1
<span class="lineno"> 1515 </span>--    and baz x = ...
<span class="lineno"> 1516 </span>--    and baz0 = baz 0
<span class="lineno"> 1517 </span>--    and baz1 = baz 1
<span class="lineno"> 1518 </span>-- then depending on what the code is, it might be logically
<span class="lineno"> 1519 </span>-- reasonable to place the values like this and ugly to need to move
<span class="lineno"> 1520 </span>-- them out of the flow. If this ever comes up it might make sense to
<span class="lineno"> 1521 </span>-- loosen this check (e.g. to check whether the value is actually
<span class="lineno"> 1522 </span>-- recursive) and also fix the interpreter to not choke. However,
<span class="lineno"> 1523 </span>-- provided the values actually aren't recursive it is _possible_ to
<span class="lineno"> 1524 </span>-- move them out, so this is only worth chasing after given a fairly
<span class="lineno"> 1525 </span>-- compelling use case.
<span class="lineno"> 1526 </span>--
<span class="lineno"> 1527 </span>-- Note that actual recursively defined values are always bottom (in
<span class="lineno"> 1528 </span>-- the absence of mutable variables) and are best not allowed.
<span class="lineno"> 1529 </span>--
<span class="lineno"> 1530 </span>requireFunction :: Pos -&gt; Type -&gt; TI ()
<span class="lineno"> 1531 </span><span class="decl"><span class="istickedoff">requireFunction pos ty = do</span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="istickedoff">ty' &lt;- applyCurrentSubst =&lt;&lt; resolveCurrentTypedefs ty</span>
<span class="lineno"> 1533 </span><span class="spaces">    </span><span class="istickedoff">case ty' of</span>
<span class="lineno"> 1534 </span><span class="spaces">        </span><span class="istickedoff">TyCon _pos FunCon _args -&gt;</span>
<span class="lineno"> 1535 </span><span class="spaces">            </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno"> 1536 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1537 </span><span class="spaces">            </span><span class="istickedoff">recordError pos $ &quot;Only functions may be recursive.&quot;</span></span>
<span class="lineno"> 1538 </span>
<span class="lineno"> 1539 </span>-- Type inference for a declaration.
<span class="lineno"> 1540 </span>--
<span class="lineno"> 1541 </span>-- Note that the type schema slot in Decl is always Nothing the way it
<span class="lineno"> 1542 </span>-- comes from the parser; if there's an explicit type annotation on
<span class="lineno"> 1543 </span>-- the declaration that shows up as a type signature in the
<span class="lineno"> 1544 </span>-- expression.
<span class="lineno"> 1545 </span>inferDecl :: Decl -&gt; TI Decl
<span class="lineno"> 1546 </span><span class="decl"><span class="istickedoff">inferDecl d@(Decl pos pat _ e) = do</span>
<span class="lineno"> 1547 </span><span class="spaces">  </span><span class="istickedoff">let n = patternLName pat</span>
<span class="lineno"> 1548 </span><span class="spaces">  </span><span class="istickedoff">foralls &lt;- inspectDeclFTVs d</span>
<span class="lineno"> 1549 </span><span class="spaces">  </span><span class="istickedoff">withAbstractTyVars foralls $ do</span>
<span class="lineno"> 1550 </span><span class="spaces">    </span><span class="istickedoff">(e',t) &lt;- inferExpr (n, e)</span>
<span class="lineno"> 1551 </span><span class="spaces">    </span><span class="istickedoff">pat' &lt;- checkPattern n t pat</span>
<span class="lineno"> 1552 </span><span class="spaces">    </span><span class="istickedoff">~[(e1,s)] &lt;- generalize foralls [e'] [t]</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">return (Decl <span class="nottickedoff">pos</span> pat' (Just s) e1)</span></span>
<span class="lineno"> 1554 </span>
<span class="lineno"> 1555 </span>-- Type inference for a system of mutually recursive declarations.
<span class="lineno"> 1556 </span>--
<span class="lineno"> 1557 </span>-- Note that the type schema slot in the Decls is always Nothing as we
<span class="lineno"> 1558 </span>-- get them from the parser; if there's an explicit type annotation on
<span class="lineno"> 1559 </span>-- some or all of the declarations those shows up as type signatures
<span class="lineno"> 1560 </span>-- in the expressions.
<span class="lineno"> 1561 </span>inferRecDecls :: [Decl] -&gt; TI [Decl]
<span class="lineno"> 1562 </span><span class="decl"><span class="istickedoff">inferRecDecls ds =</span>
<span class="lineno"> 1563 </span><span class="spaces">  </span><span class="istickedoff">do let pats = map dPat ds</span>
<span class="lineno"> 1564 </span><span class="spaces">         </span><span class="istickedoff">firstPat =</span>
<span class="lineno"> 1565 </span><span class="spaces">           </span><span class="istickedoff">case pats of</span>
<span class="lineno"> 1566 </span><span class="spaces">             </span><span class="istickedoff">p:_ -&gt; p</span>
<span class="lineno"> 1567 </span><span class="spaces">             </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">panic</span></span>
<span class="lineno"> 1568 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">&quot;inferRecDecls&quot;</span></span>
<span class="lineno"> 1569 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">[&quot;Empty list of declarations in recursive group&quot;]</span></span>
<span class="lineno"> 1570 </span><span class="spaces">     </span><span class="istickedoff">foralls &lt;- M.unions &lt;$&gt; mapM inspectDeclFTVs ds</span>
<span class="lineno"> 1571 </span><span class="spaces">     </span><span class="istickedoff">withAbstractTyVars foralls $ do</span>
<span class="lineno"> 1572 </span><span class="spaces">       </span><span class="istickedoff">(_ts, pats') &lt;- unzip &lt;$&gt; mapM inferPattern pats</span>
<span class="lineno"> 1573 </span><span class="spaces">       </span><span class="istickedoff">(es, ts) &lt;- fmap unzip</span>
<span class="lineno"> 1574 </span><span class="spaces">                   </span><span class="istickedoff">$ flip (foldr withPattern) pats'</span>
<span class="lineno"> 1575 </span><span class="spaces">                   </span><span class="istickedoff">$ sequence [ inferExpr (<span class="nottickedoff">patternLName p</span>, e)</span>
<span class="lineno"> 1576 </span><span class="spaces">                              </span><span class="istickedoff">| Decl _pos p _ e &lt;- ds</span>
<span class="lineno"> 1577 </span><span class="spaces">                              </span><span class="istickedoff">]</span>
<span class="lineno"> 1578 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1579 </span><span class="spaces">       </span><span class="istickedoff">-- Only functions can be recursive.</span>
<span class="lineno"> 1580 </span><span class="spaces">       </span><span class="istickedoff">zipWithM_ (\d t -&gt; requireFunction (getPos d) t) ds ts</span>
<span class="lineno"> 1581 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1582 </span><span class="spaces">       </span><span class="istickedoff">-- pats' has already been checked once, which will have inserted</span>
<span class="lineno"> 1583 </span><span class="spaces">       </span><span class="istickedoff">-- unification vars for any missing types. Running it through</span>
<span class="lineno"> 1584 </span><span class="spaces">       </span><span class="istickedoff">-- again will have no further effect, so we can ignore the</span>
<span class="lineno"> 1585 </span><span class="spaces">       </span><span class="istickedoff">-- theoretically-updated-again patterns returned by checkPattern.</span>
<span class="lineno"> 1586 </span><span class="spaces">       </span><span class="istickedoff">sequence_ $ zipWith (checkPattern (patternLName firstPat)) ts pats'</span>
<span class="lineno"> 1587 </span><span class="spaces">       </span><span class="istickedoff">ess &lt;- generalize <span class="nottickedoff">foralls</span> es ts</span>
<span class="lineno"> 1588 </span><span class="spaces">       </span><span class="istickedoff">return [ Decl <span class="nottickedoff">pos</span> p <span class="nottickedoff">(Just s)</span> e1</span>
<span class="lineno"> 1589 </span><span class="spaces">              </span><span class="istickedoff">| (pos, p, (e1, s)) &lt;- zip3 (map <span class="nottickedoff">getPos</span> ds) pats' ess</span>
<span class="lineno"> 1590 </span><span class="spaces">              </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1591 </span>
<span class="lineno"> 1592 </span>-- Type inference for a decl group.
<span class="lineno"> 1593 </span>inferDeclGroup :: DeclGroup -&gt; TI DeclGroup
<span class="lineno"> 1594 </span><span class="decl"><span class="istickedoff">inferDeclGroup (NonRecursive d) = do</span>
<span class="lineno"> 1595 </span><span class="spaces">  </span><span class="istickedoff">d' &lt;- inferDecl d</span>
<span class="lineno"> 1596 </span><span class="spaces">  </span><span class="istickedoff">return (NonRecursive d')</span>
<span class="lineno"> 1597 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1598 </span><span class="spaces"></span><span class="istickedoff">inferDeclGroup (Recursive ds) = do</span>
<span class="lineno"> 1599 </span><span class="spaces">  </span><span class="istickedoff">ds' &lt;- inferRecDecls ds</span>
<span class="lineno"> 1600 </span><span class="spaces">  </span><span class="istickedoff">return (Recursive ds')</span></span>
<span class="lineno"> 1601 </span>
<span class="lineno"> 1602 </span>--
<span class="lineno"> 1603 </span>-- types
<span class="lineno"> 1604 </span>--
<span class="lineno"> 1605 </span>
<span class="lineno"> 1606 </span>-- Look up a type constructor (in our fixed environment of hardcoded
<span class="lineno"> 1607 </span>-- types) and return its params as a list of kinds.
<span class="lineno"> 1608 </span>lookupTyCon :: TyCon -&gt; [Kind]
<span class="lineno"> 1609 </span><span class="decl"><span class="istickedoff">lookupTyCon tycon = case tycon of</span>
<span class="lineno"> 1610 </span><span class="spaces">  </span><span class="istickedoff">TupleCon n -&gt; genericTake n (repeat kindStar)</span>
<span class="lineno"> 1611 </span><span class="spaces">  </span><span class="istickedoff">ArrayCon -&gt; [kindStar]</span>
<span class="lineno"> 1612 </span><span class="spaces">  </span><span class="istickedoff">FunCon -&gt; [kindStar, kindStar]</span>
<span class="lineno"> 1613 </span><span class="spaces">  </span><span class="istickedoff">StringCon -&gt; []</span>
<span class="lineno"> 1614 </span><span class="spaces">  </span><span class="istickedoff">TermCon -&gt; []</span>
<span class="lineno"> 1615 </span><span class="spaces">  </span><span class="istickedoff">TypeCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1616 </span><span class="spaces">  </span><span class="istickedoff">BoolCon -&gt; []</span>
<span class="lineno"> 1617 </span><span class="spaces">  </span><span class="istickedoff">IntCon -&gt; []</span>
<span class="lineno"> 1618 </span><span class="spaces">  </span><span class="istickedoff">BlockCon -&gt; [kindStar, kindStar]</span>
<span class="lineno"> 1619 </span><span class="spaces">  </span><span class="istickedoff">AIGCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1620 </span><span class="spaces">  </span><span class="istickedoff">CFGCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1621 </span><span class="spaces">  </span><span class="istickedoff">JVMSpecCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1622 </span><span class="spaces">  </span><span class="istickedoff">LLVMSpecCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1623 </span><span class="spaces">  </span><span class="istickedoff">MIRSpecCon -&gt; <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1624 </span><span class="spaces">  </span><span class="istickedoff">ContextCon _ctx -&gt;</span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="istickedoff">-- XXX: while BlockCon exists, ContextCon has kind * and you</span>
<span class="lineno"> 1626 </span><span class="spaces">    </span><span class="istickedoff">-- have to use BlockCon to paste a result type to a ContextCon.</span>
<span class="lineno"> 1627 </span><span class="spaces">    </span><span class="istickedoff">-- (BlockCon should be removed. Then ContextCon has kind * -&gt; *</span>
<span class="lineno"> 1628 </span><span class="spaces">    </span><span class="istickedoff">-- like you'd expect.)</span>
<span class="lineno"> 1629 </span><span class="spaces">    </span><span class="istickedoff">[]</span></span>
<span class="lineno"> 1630 </span>
<span class="lineno"> 1631 </span>-- Check a type for validity and also for having the
<span class="lineno"> 1632 </span>-- correct kinding.
<span class="lineno"> 1633 </span>checkType :: Kind -&gt; Type -&gt; TI Type
<span class="lineno"> 1634 </span><span class="decl"><span class="istickedoff">checkType kind ty = case ty of</span>
<span class="lineno"> 1635 </span><span class="spaces">  </span><span class="istickedoff">TyCon pos tycon args -&gt; do</span>
<span class="lineno"> 1636 </span><span class="spaces">      </span><span class="istickedoff">-- First, look up the constructor.</span>
<span class="lineno"> 1637 </span><span class="spaces">      </span><span class="istickedoff">let params = lookupTyCon tycon</span>
<span class="lineno"> 1638 </span><span class="spaces">      </span><span class="istickedoff">let nparams = length params</span>
<span class="lineno"> 1639 </span><span class="spaces">          </span><span class="istickedoff">nargs = length args</span>
<span class="lineno"> 1640 </span><span class="spaces">          </span><span class="istickedoff">argsleft = kindNumArgs kind</span>
<span class="lineno"> 1641 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1642 </span><span class="spaces">      </span><span class="istickedoff">-- XXX: the failures are all currently unreachable, because the</span>
<span class="lineno"> 1643 </span><span class="spaces">      </span><span class="istickedoff">-- parser does not permit writing mis-kinded types. This should</span>
<span class="lineno"> 1644 </span><span class="spaces">      </span><span class="istickedoff">-- probably be changed, both for ergonomic reasons (messages</span>
<span class="lineno"> 1645 </span><span class="spaces">      </span><span class="istickedoff">-- about wrong type arguments are better than syntax errors) and</span>
<span class="lineno"> 1646 </span><span class="spaces">      </span><span class="istickedoff">-- also because all the special cases in the parser are ugly.</span>
<span class="lineno"> 1647 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1648 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">nargs &gt; nparams</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1649 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">-- XXX special case for BlockCon (remove along with BlockCon)</span></span>
<span class="lineno"> 1650 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case (tycon, args) of</span></span>
<span class="lineno"> 1651 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(BlockCon, arg : _) -&gt;</span></span>
<span class="lineno"> 1652 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Too many type arguments for type &quot; ++</span></span>
<span class="lineno"> 1653 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;constructor &quot; ++ pShow arg ++</span></span>
<span class="lineno"> 1654 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;; found &quot; ++ show (nargs - 1) ++</span></span>
<span class="lineno"> 1655 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but expected only &quot; ++ show (nparams - 1))</span></span>
<span class="lineno"> 1656 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(_, _) -&gt;</span></span>
<span class="lineno"> 1657 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Too many type arguments for type &quot; ++</span></span>
<span class="lineno"> 1658 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;constructor &quot; ++ pShow tycon ++</span></span>
<span class="lineno"> 1659 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot;; found &quot; ++ show nargs ++</span></span>
<span class="lineno"> 1660 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but expected only &quot; ++ show nparams)</span></span>
<span class="lineno"> 1661 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1662 </span><span class="spaces">      </span><span class="istickedoff">else if <span class="tickonlyfalse">nargs + argsleft /= nparams</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1663 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span></span>
<span class="lineno"> 1664 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot; but found &quot; ++ (pShow $ Kind (nparams - nargs)))</span></span>
<span class="lineno"> 1665 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1666 </span><span class="spaces">      </span><span class="istickedoff">else do</span>
<span class="lineno"> 1667 </span><span class="spaces">          </span><span class="istickedoff">-- note that this will ignore the extra params, and return</span>
<span class="lineno"> 1668 </span><span class="spaces">          </span><span class="istickedoff">-- a list of the same length as the args given</span>
<span class="lineno"> 1669 </span><span class="spaces">          </span><span class="istickedoff">args' &lt;- zipWithM checkType params args</span>
<span class="lineno"> 1670 </span><span class="spaces">          </span><span class="istickedoff">return $ TyCon pos tycon args'</span>
<span class="lineno"> 1671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1672 </span><span class="spaces">  </span><span class="istickedoff">TyRecord pos fields -&gt; do</span>
<span class="lineno"> 1673 </span><span class="spaces">      </span><span class="istickedoff">-- XXX as with TyCon the failure is currently unreachable</span>
<span class="lineno"> 1674 </span><span class="spaces">      </span><span class="istickedoff">-- because the parser can't be made to produce mis-kinded types.</span>
<span class="lineno"> 1675 </span><span class="spaces">      </span><span class="istickedoff">if <span class="tickonlyfalse">kind /= kindStar</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1676 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span></span>
<span class="lineno"> 1677 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">&quot; but found &quot; ++ pShow kindStar)</span></span>
<span class="lineno"> 1678 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1679 </span><span class="spaces">      </span><span class="istickedoff">else do</span>
<span class="lineno"> 1680 </span><span class="spaces">          </span><span class="istickedoff">-- Someone upstream had better have checked for duplicate</span>
<span class="lineno"> 1681 </span><span class="spaces">          </span><span class="istickedoff">-- field names because we can't once the fields are loaded</span>
<span class="lineno"> 1682 </span><span class="spaces">          </span><span class="istickedoff">-- into a map. (XXX: someone hasn't)</span>
<span class="lineno"> 1683 </span><span class="spaces">          </span><span class="istickedoff">fields' &lt;- traverse (checkType kindStar) fields</span>
<span class="lineno"> 1684 </span><span class="spaces">          </span><span class="istickedoff">return $ TyRecord pos fields'</span>
<span class="lineno"> 1685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1686 </span><span class="spaces">  </span><span class="istickedoff">TyVar pos x -&gt; do</span>
<span class="lineno"> 1687 </span><span class="spaces">      </span><span class="istickedoff">avail &lt;- TI $ asks primsAvail</span>
<span class="lineno"> 1688 </span><span class="spaces">      </span><span class="istickedoff">tyenv &lt;- TI $ asks tyEnv</span>
<span class="lineno"> 1689 </span><span class="spaces">      </span><span class="istickedoff">case M.lookup x tyenv of</span>
<span class="lineno"> 1690 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno"> 1691 </span><span class="spaces">              </span><span class="istickedoff">recordError pos (&quot;Unbound type variable &quot; ++ Text.unpack x)</span>
<span class="lineno"> 1692 </span><span class="spaces">              </span><span class="istickedoff">getErrorTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1693 </span><span class="spaces">          </span><span class="istickedoff">Just (lc, _ty')</span>
<span class="lineno"> 1694 </span><span class="spaces">           </span><span class="istickedoff">| S.member lc avail -&gt; do</span>
<span class="lineno"> 1695 </span><span class="spaces">              </span><span class="istickedoff">when (isDeprecated lc) $</span>
<span class="lineno"> 1696 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordWarning pos $ &quot;Type is deprecated: &quot; &lt;&gt; Text.unpack x</span></span>
<span class="lineno"> 1697 </span><span class="spaces">              </span><span class="istickedoff">-- Assume ty' was checked when it was entered.</span>
<span class="lineno"> 1698 </span><span class="spaces">              </span><span class="istickedoff">-- (If we entered it that's true, if it was in the</span>
<span class="lineno"> 1699 </span><span class="spaces">              </span><span class="istickedoff">-- initial environment we were given that depends on the</span>
<span class="lineno"> 1700 </span><span class="spaces">              </span><span class="istickedoff">-- interpreter not doing unfortunate things. This isn't</span>
<span class="lineno"> 1701 </span><span class="spaces">              </span><span class="istickedoff">-- currently seeming like a very good bet.)</span>
<span class="lineno"> 1702 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1703 </span><span class="spaces">              </span><span class="istickedoff">-- For now at least we require typedefs to be kind *</span>
<span class="lineno"> 1704 </span><span class="spaces">              </span><span class="istickedoff">-- (they can't have parameters and the expansions are thus</span>
<span class="lineno"> 1705 </span><span class="spaces">              </span><span class="istickedoff">-- restricted) so just fail if we use one in a context</span>
<span class="lineno"> 1706 </span><span class="spaces">              </span><span class="istickedoff">-- expecting something else.</span>
<span class="lineno"> 1707 </span><span class="spaces">              </span><span class="istickedoff">--</span>
<span class="lineno"> 1708 </span><span class="spaces">              </span><span class="istickedoff">-- The same holds for abstract types, so we don't need</span>
<span class="lineno"> 1709 </span><span class="spaces">              </span><span class="istickedoff">-- separate cases.</span>
<span class="lineno"> 1710 </span><span class="spaces">              </span><span class="istickedoff">if <span class="tickonlyfalse">kind /= kindStar</span> then <span class="nottickedoff">do</span></span>
<span class="lineno"> 1711 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">recordError pos (&quot;Kind mismatch: expected &quot; ++ pShow kind ++</span></span>
<span class="lineno"> 1712 </span><span class="spaces">                                   </span><span class="istickedoff"><span class="nottickedoff">&quot; but found &quot; ++ pShow kindStar)</span></span>
<span class="lineno"> 1713 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">getErrorTyVar pos</span></span>
<span class="lineno"> 1714 </span><span class="spaces">              </span><span class="istickedoff">else</span>
<span class="lineno"> 1715 </span><span class="spaces">                  </span><span class="istickedoff">-- We do _not_ want to expand typedefs when checking,</span>
<span class="lineno"> 1716 </span><span class="spaces">                  </span><span class="istickedoff">-- so return the original TyVar.</span>
<span class="lineno"> 1717 </span><span class="spaces">                  </span><span class="istickedoff">return ty</span>
<span class="lineno"> 1718 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; do</span>
<span class="lineno"> 1719 </span><span class="spaces">                  </span><span class="istickedoff">recordError pos $ &quot;Inaccessible type: &quot; ++ show x</span>
<span class="lineno"> 1720 </span><span class="spaces">                  </span><span class="istickedoff">let how = if lc == HideDeprecated then &quot;deprecated&quot; else &quot;experimental&quot;</span>
<span class="lineno"> 1721 </span><span class="spaces">                  </span><span class="istickedoff">recordError pos $ &quot;This type is available only after running &quot; ++</span>
<span class="lineno"> 1722 </span><span class="spaces">                                    </span><span class="istickedoff">&quot;`enable_&quot; ++ how ++ &quot;`.&quot;</span>
<span class="lineno"> 1723 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- getFreshTyVar <span class="nottickedoff">pos</span></span>
<span class="lineno"> 1724 </span><span class="spaces">                  </span><span class="istickedoff">return <span class="nottickedoff">t'</span></span>
<span class="lineno"> 1725 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1726 </span><span class="spaces">  </span><span class="istickedoff">TyUnifyVar _pos _ix -&gt;</span>
<span class="lineno"> 1727 </span><span class="spaces">      </span><span class="istickedoff">-- for now at least we don't track the kinds of unification vars</span>
<span class="lineno"> 1728 </span><span class="spaces">      </span><span class="istickedoff">-- (types of mismatched kinds can't be the same types, so they</span>
<span class="lineno"> 1729 </span><span class="spaces">      </span><span class="istickedoff">-- won't ever unify, so the possible mischief is limited) and all</span>
<span class="lineno"> 1730 </span><span class="spaces">      </span><span class="istickedoff">-- possible unification var numbers are well formed, so we don't</span>
<span class="lineno"> 1731 </span><span class="spaces">      </span><span class="istickedoff">-- need to do anything.</span>
<span class="lineno"> 1732 </span><span class="spaces">      </span><span class="istickedoff">return ty</span></span>
<span class="lineno"> 1733 </span>
<span class="lineno"> 1734 </span>-- }}}
<span class="lineno"> 1735 </span>
<span class="lineno"> 1736 </span>
<span class="lineno"> 1737 </span>------------------------------------------------------------
<span class="lineno"> 1738 </span>-- External interface {{{
<span class="lineno"> 1739 </span>
<span class="lineno"> 1740 </span>-- Some short names for use in the signatures below
<span class="lineno"> 1741 </span>type MsgList = [(Pos, String)]
<span class="lineno"> 1742 </span>type Result a = (Either MsgList a, MsgList)
<span class="lineno"> 1743 </span>
<span class="lineno"> 1744 </span>-- Run the TI monad.
<span class="lineno"> 1745 </span>--
<span class="lineno"> 1746 </span>-- Note that the error and warning lists accumulate in reverse order
<span class="lineno"> 1747 </span>-- (later messages are consed onto the head of the list) so we
<span class="lineno"> 1748 </span>-- reverse on the way out.
<span class="lineno"> 1749 </span>runTIWithEnv :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; TI a -&gt; (a, Subst, MsgList, MsgList)
<span class="lineno"> 1750 </span><span class="decl"><span class="istickedoff">runTIWithEnv avail env tenv m = (a, <span class="nottickedoff">subst rw</span>, reverse $ errors rw, reverse $ warnings rw)</span>
<span class="lineno"> 1751 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1752 </span><span class="spaces">  </span><span class="istickedoff">m' = runReaderT (unTI m) (RO avail env tenv)</span>
<span class="lineno"> 1753 </span><span class="spaces">  </span><span class="istickedoff">(a,rw) = runState m' emptyRW</span></span>
<span class="lineno"> 1754 </span>
<span class="lineno"> 1755 </span>-- Run the TI monad and interpret/collect the results
<span class="lineno"> 1756 </span>-- (failure if any errors were produced)
<span class="lineno"> 1757 </span>evalTIWithEnv :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; TI a -&gt; Result a
<span class="lineno"> 1758 </span><span class="decl"><span class="istickedoff">evalTIWithEnv avail env tenv m =</span>
<span class="lineno"> 1759 </span><span class="spaces">  </span><span class="istickedoff">case runTIWithEnv avail env tenv m of</span>
<span class="lineno"> 1760 </span><span class="spaces">    </span><span class="istickedoff">(res, _, [], warns) -&gt; (Right res, warns)</span>
<span class="lineno"> 1761 </span><span class="spaces">    </span><span class="istickedoff">(_, _, errs, warns) -&gt; (Left errs, warns)</span></span>
<span class="lineno"> 1762 </span>
<span class="lineno"> 1763 </span>-- | Check a single statement. (This is an external interface.)
<span class="lineno"> 1764 </span>--
<span class="lineno"> 1765 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 1766 </span>-- environments to use.
<span class="lineno"> 1767 </span>--
<span class="lineno"> 1768 </span>-- The third is a current position, and the fourth is the
<span class="lineno"> 1769 </span>-- context/monad type associated with the execution.
<span class="lineno"> 1770 </span>checkStmt :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; Context -&gt; Stmt -&gt; Result Stmt
<span class="lineno"> 1771 </span><span class="decl"><span class="istickedoff">checkStmt avail env tenv ctx stmt =</span>
<span class="lineno"> 1772 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: we shouldn't need this position here.</span>
<span class="lineno"> 1773 </span><span class="spaces">  </span><span class="istickedoff">-- The position is used for the following things:</span>
<span class="lineno"> 1774 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1775 </span><span class="spaces">  </span><span class="istickedoff">--    - to create ln, which is used as part of the error printing</span>
<span class="lineno"> 1776 </span><span class="spaces">  </span><span class="istickedoff">--      scheme, but is no longer particularly useful after recent</span>
<span class="lineno"> 1777 </span><span class="spaces">  </span><span class="istickedoff">--      improvements (especially here where it contains no real</span>
<span class="lineno"> 1778 </span><span class="spaces">  </span><span class="istickedoff">--      information) and should be removed;</span>
<span class="lineno"> 1779 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1780 </span><span class="spaces">  </span><span class="istickedoff">--    - to be the position associated with the monad context, which</span>
<span class="lineno"> 1781 </span><span class="spaces">  </span><span class="istickedoff">--      in a tidy world should just be PosRepl (as in, the only</span>
<span class="lineno"> 1782 </span><span class="spaces">  </span><span class="istickedoff">--      time we should be typechecking a single statement is when</span>
<span class="lineno"> 1783 </span><span class="spaces">  </span><span class="istickedoff">--      it was just typed interactively, and which monad we're in</span>
<span class="lineno"> 1784 </span><span class="spaces">  </span><span class="istickedoff">--      is a direct property of that context) but this is not</span>
<span class="lineno"> 1785 </span><span class="spaces">  </span><span class="istickedoff">--      currently true and will require a good bit of interpreter</span>
<span class="lineno"> 1786 </span><span class="spaces">  </span><span class="istickedoff">--      cleanup to make it true;</span>
<span class="lineno"> 1787 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1788 </span><span class="spaces">  </span><span class="istickedoff">--    - to pass to inferStmt, which also uses it as part of the</span>
<span class="lineno"> 1789 </span><span class="spaces">  </span><span class="istickedoff">--      position associated with the monad context. (This part is a</span>
<span class="lineno"> 1790 </span><span class="spaces">  </span><span class="istickedoff">--      result of BlockCon existing and can go away when BlockCon is</span>
<span class="lineno"> 1791 </span><span class="spaces">  </span><span class="istickedoff">--      removed.)</span>
<span class="lineno"> 1792 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno"> 1793 </span><span class="spaces">  </span><span class="istickedoff">-- XXX: using the position of the statement as the position</span>
<span class="lineno"> 1794 </span><span class="spaces">  </span><span class="istickedoff">-- associated with the monad context is not correct (or at least,</span>
<span class="lineno"> 1795 </span><span class="spaces">  </span><span class="istickedoff">-- will be confusing) and we should figure something else out if the</span>
<span class="lineno"> 1796 </span><span class="spaces">  </span><span class="istickedoff">-- interpreter cleanup doesn't come through soon. Note that</span>
<span class="lineno"> 1797 </span><span class="spaces">  </span><span class="istickedoff">-- currently we come through here only for syntactically top-level</span>
<span class="lineno"> 1798 </span><span class="spaces">  </span><span class="istickedoff">-- statements in the interpreter; these are TopLevel except when in</span>
<span class="lineno"> 1799 </span><span class="spaces">  </span><span class="istickedoff">-- the ProofScript repl. So perhaps we should use PosRepl when in</span>
<span class="lineno"> 1800 </span><span class="spaces">  </span><span class="istickedoff">-- ProofScript, and then either PosRepl or PosBuiltin for TopLevel?</span>
<span class="lineno"> 1801 </span><span class="spaces">  </span><span class="istickedoff">-- But we don't have a good way of knowing here whether we're</span>
<span class="lineno"> 1802 </span><span class="spaces">  </span><span class="istickedoff">-- actually in the repl.</span>
<span class="lineno"> 1803 </span><span class="spaces">  </span><span class="istickedoff">let pos = getPos stmt</span>
<span class="lineno"> 1804 </span><span class="spaces">      </span><span class="istickedoff">ln = case ctx of</span>
<span class="lineno"> 1805 </span><span class="spaces">          </span><span class="istickedoff">TopLevel -&gt; Located <span class="nottickedoff">&quot;&lt;toplevel&gt;&quot;</span> &quot;&lt;toplevel&gt;&quot; pos</span>
<span class="lineno"> 1806 </span><span class="spaces">          </span><span class="istickedoff">ProofScript -&gt; <span class="nottickedoff">Located &quot;&lt;proofscript&gt;&quot; &quot;&lt;proofscript&gt;&quot; pos</span></span>
<span class="lineno"> 1807 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;checkStmt&quot; [&quot;Invalid monad context &quot; &lt;&gt; Text.pack (pShow ctx)]</span></span>
<span class="lineno"> 1808 </span><span class="spaces">      </span><span class="istickedoff">ctxtype = TyCon pos (ContextCon ctx) []</span>
<span class="lineno"> 1809 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1810 </span><span class="spaces">  </span><span class="istickedoff">evalTIWithEnv avail env tenv (inferSingleStmt ln pos ctxtype stmt)</span></span>
<span class="lineno"> 1811 </span>
<span class="lineno"> 1812 </span>-- | Check a single declaration. (This is an external interface.)
<span class="lineno"> 1813 </span>--
<span class="lineno"> 1814 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 1815 </span>-- environments to use.
<span class="lineno"> 1816 </span>checkDecl :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; Decl -&gt; Result Decl
<span class="lineno"> 1817 </span><span class="decl"><span class="nottickedoff">checkDecl avail env tenv decl =</span>
<span class="lineno"> 1818 </span><span class="spaces">  </span><span class="nottickedoff">evalTIWithEnv avail env tenv (inferDecl decl)</span></span>
<span class="lineno"> 1819 </span>
<span class="lineno"> 1820 </span>-- | Check a found type (first argument) against an expected type
<span class="lineno"> 1821 </span>--   (second argument) and return True if they can be unified.
<span class="lineno"> 1822 </span>--
<span class="lineno"> 1823 </span>--   Both types are schemes because that's what we need upstream.
<span class="lineno"> 1824 </span>--
<span class="lineno"> 1825 </span>--   (This is an external interface.)
<span class="lineno"> 1826 </span>typesMatch :: Set PrimitiveLifecycle -&gt; TyEnv -&gt; Schema -&gt; Schema -&gt; Bool
<span class="lineno"> 1827 </span><span class="decl"><span class="istickedoff">typesMatch avail tenv schema'found schema'expected =</span>
<span class="lineno"> 1828 </span><span class="spaces">  </span><span class="istickedoff">let unpack (Forall as ty) = do</span>
<span class="lineno"> 1829 </span><span class="spaces">        </span><span class="istickedoff">-- Generate unification vars for all the forall-bindings</span>
<span class="lineno"> 1830 </span><span class="spaces">        </span><span class="istickedoff">let generate (pos'a, a) = do</span>
<span class="lineno"> 1831 </span><span class="spaces">              </span><span class="istickedoff">ty'a &lt;- getFreshTyVar <span class="nottickedoff">pos'a</span></span>
<span class="lineno"> 1832 </span><span class="spaces">              </span><span class="istickedoff">return (a, (Current, ConcreteType ty'a))</span>
<span class="lineno"> 1833 </span><span class="spaces">        </span><span class="istickedoff">substs &lt;- mapM generate as</span>
<span class="lineno"> 1834 </span><span class="spaces">        </span><span class="istickedoff">-- Substitute them into the type</span>
<span class="lineno"> 1835 </span><span class="spaces">        </span><span class="istickedoff">let ty' = substituteTyVars avail (M.fromList substs) ty</span>
<span class="lineno"> 1836 </span><span class="spaces">        </span><span class="istickedoff">return ty'</span>
<span class="lineno"> 1837 </span><span class="spaces">      </span><span class="istickedoff">match = do</span>
<span class="lineno"> 1838 </span><span class="spaces">        </span><span class="istickedoff">-- Unpack the schemas and check if they match</span>
<span class="lineno"> 1839 </span><span class="spaces">        </span><span class="istickedoff">ty'found &lt;- unpack schema'found</span>
<span class="lineno"> 1840 </span><span class="spaces">        </span><span class="istickedoff">ty'expected &lt;- unpack schema'expected</span>
<span class="lineno"> 1841 </span><span class="spaces">        </span><span class="istickedoff">matches ty'found ty'expected</span>
<span class="lineno"> 1842 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1843 </span><span class="spaces">  </span><span class="istickedoff">case evalTIWithEnv avail <span class="nottickedoff">M.empty</span> tenv match of</span>
<span class="lineno"> 1844 </span><span class="spaces">    </span><span class="istickedoff">(Left _errors, _warnings) -&gt; <span class="nottickedoff">False</span>          -- not actually reachable</span>
<span class="lineno"> 1845 </span><span class="spaces">    </span><span class="istickedoff">(Right b, _warnings) -&gt; b</span></span>                   -- return match success/failure
<span class="lineno"> 1846 </span>
<span class="lineno"> 1847 </span>-- | Check a schema (type) pattern as used by :search. (This is an
<span class="lineno"> 1848 </span>-- external interface.)
<span class="lineno"> 1849 </span>--
<span class="lineno"> 1850 </span>-- The first two arguments are the starting variable and typedef
<span class="lineno"> 1851 </span>-- environments to use. The third argument is the pattern.
<span class="lineno"> 1852 </span>--
<span class="lineno"> 1853 </span>-- Returns a possibly updated pattern.
<span class="lineno"> 1854 </span>--
<span class="lineno"> 1855 </span>checkSchemaPattern :: Set PrimitiveLifecycle -&gt; VarEnv -&gt; TyEnv -&gt; SchemaPattern -&gt; Result SchemaPattern
<span class="lineno"> 1856 </span><span class="decl"><span class="istickedoff">checkSchemaPattern _avail _env _tenv pat =</span>
<span class="lineno"> 1857 </span><span class="spaces">    </span><span class="istickedoff">-- For the time being, do nothing -- we specifically don't want it</span>
<span class="lineno"> 1858 </span><span class="spaces">    </span><span class="istickedoff">-- to reject unbound/free type variables (see Search.hs for a</span>
<span class="lineno"> 1859 </span><span class="spaces">    </span><span class="istickedoff">-- discussion of why) or underapplied type constructors, so the</span>
<span class="lineno"> 1860 </span><span class="spaces">    </span><span class="istickedoff">-- only check in checkType that makes sense to apply is the one</span>
<span class="lineno"> 1861 </span><span class="spaces">    </span><span class="istickedoff">-- for _overapplied_ type constructors, and that is (a) not</span>
<span class="lineno"> 1862 </span><span class="spaces">    </span><span class="istickedoff">-- critical (an overapplied type constructor will never match</span>
<span class="lineno"> 1863 </span><span class="spaces">    </span><span class="istickedoff">-- anything valid) and (b) as noted in checkType not currently</span>
<span class="lineno"> 1864 </span><span class="spaces">    </span><span class="istickedoff">-- actually reasonable because of limitations in the concrete</span>
<span class="lineno"> 1865 </span><span class="spaces">    </span><span class="istickedoff">-- syntax. Point (b) will probably change eventually, so we want</span>
<span class="lineno"> 1866 </span><span class="spaces">    </span><span class="istickedoff">-- to keep this hook and keep knowledge of its internals private</span>
<span class="lineno"> 1867 </span><span class="spaces">    </span><span class="istickedoff">-- here even though for now it's a nop.</span>
<span class="lineno"> 1868 </span><span class="spaces">    </span><span class="istickedoff">(Right pat, [])</span></span>
<span class="lineno"> 1869 </span>
<span class="lineno"> 1870 </span>-- }}}
<span class="lineno"> 1871 </span>
<span class="lineno"> 1872 </span>
<span class="lineno"> 1873 </span>{-
<span class="lineno"> 1874 </span>Note [-Wincomplete-uni-patterns and irrefutable patterns]
<span class="lineno"> 1875 </span>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineno"> 1876 </span>Various parts of SAW use irrefutable patterns in functions that assume that
<span class="lineno"> 1877 </span>their arguments have particular shapes. For example, inferDecl in this module
<span class="lineno"> 1878 </span>matches on ~[(e1,s)] with an irrefutable pattern because it assumes the
<span class="lineno"> 1879 </span>invariant that the list will have exactly one element. This lets inferDecl be
<span class="lineno"> 1880 </span>slightly lazier when evaluated.
<span class="lineno"> 1881 </span>
<span class="lineno"> 1882 </span>Unfortunately, this use of irrefutable patterns is at odds with the
<span class="lineno"> 1883 </span>-Wincomplete-uni-patterns warning. At present, -Wincomplete-uni-patterns will
<span class="lineno"> 1884 </span>produce a warning for any irrefutable pattern that does not cover all possible
<span class="lineno"> 1885 </span>data constructors. While we could rewrite functions like `inferDecl` to
<span class="lineno"> 1886 </span>explicitly provide a fall-through case, that would change its strictness
<span class="lineno"> 1887 </span>properties. As a result, we simply disable -Wincomplete-uni-patterns warnings
<span class="lineno"> 1888 </span>in each part of SAW that uses irrefutable patterns.
<span class="lineno"> 1889 </span>
<span class="lineno"> 1890 </span>Arguably, -Wincomplete-uni-patterns shouldn't be producing warnings for
<span class="lineno"> 1891 </span>irrefutable patterns at all. GHC issue #14800
<span class="lineno"> 1892 </span>(https://gitlab.haskell.org/ghc/ghc/-/issues/14800) proposes this idea.
<span class="lineno"> 1893 </span>If that issue is fixed in the future, we may want to reconsider whether we want
<span class="lineno"> 1894 </span>to disable -Wincomplete-uni-patterns.
<span class="lineno"> 1895 </span>-}

</pre>
</body>
</html>
