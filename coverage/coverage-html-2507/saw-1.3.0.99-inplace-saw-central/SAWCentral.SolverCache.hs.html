<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.SolverCache
<span class="lineno">    3 </span>Description : Caching SMT solver results for SAWScript
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : m-yac
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>This file defines an interface for caching SMT/SAT solver results using an LMDB
<span class="lineno">    9 </span>database. The interface, as used in 'applyProverToGoal', works as follows:
<span class="lineno">   10 </span>
<span class="lineno">   11 </span>1. An 'SMTQuery' is converted into a string using 'scWriteExternal', and
<span class="lineno">   12 </span>   along with any relevant 'SolverBackendVersion's (obtained using
<span class="lineno">   13 </span>   'getSolverBackendVersions' from @SAWCentral.SolverVersions@), is then hashed
<span class="lineno">   14 </span>   using SHA256 ('mkSolverCacheKey').
<span class="lineno">   15 </span>2. The core of the 'SolverCache' is an LMDB database mapping these hashes to
<span class="lineno">   16 </span>   previously obtained results ('solverCacheEnv', 'solverCacheDB'). If this is
<span class="lineno">   17 </span>   the first time solver caching is being used and the `SAW_SOLVER_CACHE_PATH`
<span class="lineno">   18 </span>   environment variable was set at startup, then open an LMDB database at the
<span class="lineno">   19 </span>   specified path and use this database for all subsequent uses of the solver
<span class="lineno">   20 </span>   cache. Note that this only occurs if there have been no prior calls to the
<span class="lineno">   21 </span>   `set_solver_cache_path` command, which immediately opens an LMDB database at
<span class="lineno">   22 </span>   specified path when called.
<span class="lineno">   23 </span>3. If the hash corresponding to the 'SATQuery' and 'SolverBackendVersion's
<span class="lineno">   24 </span>   can be found in the database ('lookupInSolverCache'), then the corresponding
<span class="lineno">   25 </span>   result is used.
<span class="lineno">   26 </span>4. Otherwise, the 'SATQuery' is dispatched to the requested backend and a
<span class="lineno">   27 </span>   result is obtained. This result is then added to the database using the
<span class="lineno">   28 </span>   aforementioned hash as the key ('insertInSolverCache').
<span class="lineno">   29 </span>
<span class="lineno">   30 </span>A interesting detail is how results are represented. For all of the backends
<span class="lineno">   31 </span>which use 'applyProverToGoal', the type of a result is:
<span class="lineno">   32 </span>@Maybe [(ExtCns Term, FirstOrderValue)]@, where 'Nothing' represents a result
<span class="lineno">   33 </span>of &quot;unsat,&quot; and 'Just' represents a result of &quot;sat&quot; along with a list of
<span class="lineno">   34 </span>counterexamples. Since 'ExtCns' contains execution-specific 'VarIndex'es, we
<span class="lineno">   35 </span>don't want to save these results directly. Instead, we represent each 'ExtCns'
<span class="lineno">   36 </span>as its index in the 'satVariables' field of 'SATQuery' (which is where they
<span class="lineno">   37 </span>were obtained by the backends in the first place).
<span class="lineno">   38 </span>-}
<span class="lineno">   39 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">   40 </span>{-# LANGUAGE GeneralisedNewtypeDeriving #-}
<span class="lineno">   41 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   42 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   43 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   44 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   45 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   46 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   47 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   48 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>module SAWCentral.SolverCache
<span class="lineno">   51 </span>  ( SolverBackend(..)
<span class="lineno">   52 </span>  , allBackends
<span class="lineno">   53 </span>  , sbvBackends
<span class="lineno">   54 </span>  , SolverBackendOption(..)
<span class="lineno">   55 </span>  , optionBackends
<span class="lineno">   56 </span>  , SolverBackendVersions
<span class="lineno">   57 </span>  , SolverCacheKey(..)
<span class="lineno">   58 </span>  , mkSolverCacheKey
<span class="lineno">   59 </span>  , SolverCacheValue(..)
<span class="lineno">   60 </span>  , toSolverCacheValue
<span class="lineno">   61 </span>  , fromSolverCacheValue
<span class="lineno">   62 </span>  , SolverCache(..)
<span class="lineno">   63 </span>  , lazyOpenSolverCache
<span class="lineno">   64 </span>  , openSolverCache
<span class="lineno">   65 </span>  , SolverCacheOp
<span class="lineno">   66 </span>  , solverCacheOp
<span class="lineno">   67 </span>  , solverCacheOpDefault
<span class="lineno">   68 </span>  , lookupInSolverCache
<span class="lineno">   69 </span>  , insertInSolverCache
<span class="lineno">   70 </span>  , setSolverCachePath
<span class="lineno">   71 </span>  , printSolverCacheByHex
<span class="lineno">   72 </span>  , cleanMismatchedVersionsSolverCache
<span class="lineno">   73 </span>  , printSolverCacheStats
<span class="lineno">   74 </span>  , testSolverCacheStats
<span class="lineno">   75 </span>  ) where
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>import System.Directory (createDirectoryIfMissing)
<span class="lineno">   78 </span>import Control.Exception (try, SomeException)
<span class="lineno">   79 </span>import Control.Monad (when, forM_)
<span class="lineno">   80 </span>import System.Timeout (timeout)
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>import GHC.Generics (Generic)
<span class="lineno">   83 </span>import Data.IORef (IORef, newIORef, modifyIORef, readIORef)
<span class="lineno">   84 </span>import Data.Time.Clock (UTCTime, getCurrentTime)
<span class="lineno">   85 </span>import Data.Tuple.Extra (first, firstM)
<span class="lineno">   86 </span>import Data.List (elemIndex, intercalate, isPrefixOf)
<span class="lineno">   87 </span>import Data.Maybe (fromMaybe, isJust)
<span class="lineno">   88 </span>import Data.Functor ((&lt;&amp;&gt;))
<span class="lineno">   89 </span>import Numeric (readHex)
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>import Data.Map.Strict (Map)
<span class="lineno">   92 </span>import qualified Data.Map.Strict as M
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>import Data.Text (Text)
<span class="lineno">   95 </span>import qualified Data.Text as Text
<span class="lineno">   96 </span>import Data.Text.Encoding (encodeUtf8)
<span class="lineno">   97 </span>import Text.Printf (printf)
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>import Data.ByteString (ByteString)
<span class="lineno">  100 </span>import qualified Data.ByteString as BS
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>import qualified Crypto.Hash.SHA256 as SHA256
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>import Data.Aeson ( FromJSON(..), ToJSON(..), FromJSONKey(..), ToJSONKey(..)
<span class="lineno">  105 </span>                  , (.:), (.:?), (.=), fromJSON )
<span class="lineno">  106 </span>import qualified Data.Aeson as JSON
<span class="lineno">  107 </span>import Codec.CBOR.JSON (encodeValue, decodeValue)
<span class="lineno">  108 </span>import Codec.Serialise (Serialise(..))
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>import qualified Database.LMDB.Simple as LMDB
<span class="lineno">  111 </span>import qualified Database.LMDB.Simple.Extra as LMDB
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>import qualified Data.SBV.Dynamic as SBV
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>import SAWCore.FiniteValue
<span class="lineno">  116 </span>import SAWCore.SATQuery
<span class="lineno">  117 </span>import SAWCore.ExternalFormat
<span class="lineno">  118 </span>import SAWCore.SharedTerm
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>import SAWCentral.Options
<span class="lineno">  121 </span>import SAWCentral.Proof
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- Helper Functions ------------------------------------------------------------
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>-- | Run the given IO action, but if the given 'timeout' (in microseconds) is
<span class="lineno">  127 </span>-- reached or the action encounters any 'SomeException', 'Left' is returned
<span class="lineno">  128 </span>tryWithTimeout :: Int -&gt; IO a -&gt; IO (Either String a)
<span class="lineno">  129 </span><span class="decl"><span class="istickedoff">tryWithTimeout t_us m = try (timeout t_us m) &lt;&amp;&gt; \case</span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="istickedoff">Right (Just a) -&gt; Right a</span>
<span class="lineno">  131 </span><span class="spaces">  </span><span class="istickedoff">Right Nothing -&gt; <span class="nottickedoff">let t_str | t_us `mod` 1000000 == 0 = show (t_us `div` 1000000) ++ &quot;s&quot;</span></span>
<span class="lineno">  132 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">| t_us `mod` 1000    == 0 = show (t_us `div` 1000) ++ &quot;ms&quot;</span></span>
<span class="lineno">  133 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">| otherwise               = show t_us ++ &quot;us&quot;</span></span>
<span class="lineno">  134 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">in Left $ &quot;Operation timed out (&quot; ++ t_str ++ &quot;)&quot;</span></span>
<span class="lineno">  135 </span><span class="spaces">  </span><span class="istickedoff">Left (exn :: SomeException) -&gt; <span class="nottickedoff">Left $ show exn</span></span></span>
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>-- | Encode a 'ByteString' as a hex string
<span class="lineno">  138 </span>encodeHex :: ByteString -&gt; String
<span class="lineno">  139 </span><span class="decl"><span class="nottickedoff">encodeHex = concatMap (printf &quot;%02x&quot;) . BS.unpack</span></span>
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- | Decode a hex string as a 'ByteString'
<span class="lineno">  142 </span>decodeHex :: String -&gt; Either String ByteString
<span class="lineno">  143 </span><span class="decl"><span class="nottickedoff">decodeHex s = BS.pack &lt;$&gt; go s</span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="nottickedoff">where go (c0:c1:cs) | [(b,[])] &lt;- readHex [c0,c1] = (b:) &lt;$&gt; go cs</span>
<span class="lineno">  145 </span><span class="spaces">        </span><span class="nottickedoff">go [] = return []</span>
<span class="lineno">  146 </span><span class="spaces">        </span><span class="nottickedoff">go _ = Left $ &quot;Hex decoding failure on: &quot; ++ s</span></span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>-- Solver Backends -------------------------------------------------------------
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- | A datatype including all solver backends currently supported by SAW. This
<span class="lineno">  152 </span>-- type is most often used in a list (@[SolverBackend]@), since at least one
<span class="lineno">  153 </span>-- other backend is always used along with 'What4' or 'SBV' (e.g. 'SBV' with
<span class="lineno">  154 </span>-- 'Z3' or 'W4' with 'AIG' and 'ABC').
<span class="lineno">  155 </span>-- NOTE: This definition includes all backends supported by SBV, even though not
<span class="lineno">  156 </span>-- all of them are currently supported by SAW (namely, 'Bitwuzla' and 'DReal').
<span class="lineno">  157 </span>-- This is to ensure the system for keeping track of solver backend versions
<span class="lineno">  158 </span>-- is not silently broken if support for these backends is ever added to SAW.
<span class="lineno">  159 </span>data SolverBackend = What4
<span class="lineno">  160 </span>                   | SBV
<span class="lineno">  161 </span>                   | AIG
<span class="lineno">  162 </span>                   | RME
<span class="lineno">  163 </span>                   -- External solvers supported by SBV (copied from SBV.Solver)
<span class="lineno">  164 </span>                   | ABC
<span class="lineno">  165 </span>                   | Boolector
<span class="lineno">  166 </span>                   | Bitwuzla
<span class="lineno">  167 </span>                   | CVC4
<span class="lineno">  168 </span>                   | CVC5
<span class="lineno">  169 </span>                   | DReal -- NOTE: Not currently supported by SAW
<span class="lineno">  170 </span>                   | MathSAT
<span class="lineno">  171 </span>                   | OpenSMT -- NOTE: Not currently supported by SAW
<span class="lineno">  172 </span>                   | Yices
<span class="lineno">  173 </span>                   | Z3
<span class="lineno">  174 </span>                   deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Enum</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Bounded</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>)
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">FromJSON SolverBackend</span></span></span></span> where
<span class="lineno">  177 </span>  <span class="decl"><span class="nottickedoff">parseJSON = JSON.genericParseJSON JSON.defaultOptions</span></span>
<span class="lineno">  178 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ToJSON SolverBackend</span></span></span></span></span></span> where
<span class="lineno">  179 </span>  <span class="decl"><span class="nottickedoff">toJSON = JSON.genericToJSON JSON.defaultOptions</span></span>
<span class="lineno">  180 </span>  <span class="decl"><span class="nottickedoff">toEncoding = JSON.genericToEncoding JSON.defaultOptions</span></span>
<span class="lineno">  181 </span>instance <span class="decl"><span class="nottickedoff">FromJSONKey SolverBackend</span></span> where
<span class="lineno">  182 </span>  <span class="decl"><span class="istickedoff">fromJSONKey = JSON.genericFromJSONKey JSON.defaultJSONKeyOptions</span></span>
<span class="lineno">  183 </span>instance <span class="decl"><span class="nottickedoff">ToJSONKey SolverBackend</span></span> where
<span class="lineno">  184 </span>  <span class="decl"><span class="istickedoff">toJSONKey = JSON.genericToJSONKey JSON.defaultJSONKeyOptions</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>-- | The list of all available 'SolverBackend's
<span class="lineno">  187 </span>allBackends :: [SolverBackend]
<span class="lineno">  188 </span><span class="decl"><span class="istickedoff">allBackends = [minBound..]</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | Given an 'SBV.SMTConfig', return the list of corresponding 'SolverBackend's
<span class="lineno">  191 </span>sbvBackends :: SBV.SMTConfig -&gt; [SolverBackend]
<span class="lineno">  192 </span><span class="decl"><span class="istickedoff">sbvBackends conf = [SBV, cvtSolver $ SBV.name $ SBV.solver conf]</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">where cvtSolver SBV.ABC       = <span class="nottickedoff">ABC</span></span>
<span class="lineno">  194 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.Boolector = <span class="nottickedoff">Boolector</span></span>
<span class="lineno">  195 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.Bitwuzla  = Bitwuzla</span>
<span class="lineno">  196 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.CVC4      = CVC4</span>
<span class="lineno">  197 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.CVC5      = <span class="nottickedoff">CVC5</span></span>
<span class="lineno">  198 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.DReal     = <span class="nottickedoff">DReal</span></span>
<span class="lineno">  199 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.MathSAT   = <span class="nottickedoff">MathSAT</span></span>
<span class="lineno">  200 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.OpenSMT   = <span class="nottickedoff">OpenSMT</span></span>
<span class="lineno">  201 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.Yices     = Yices</span>
<span class="lineno">  202 </span><span class="spaces">        </span><span class="istickedoff">cvtSolver SBV.Z3        = Z3</span></span>
<span class="lineno">  203 </span>
<span class="lineno">  204 </span>-- | A datatype representing an option to one of the 'SolverBackend's.
<span class="lineno">  205 </span>-- Currently, there are only the following options for using 'What4': with a
<span class="lineno">  206 </span>-- tactic ('W4_Tactic'), by converting to SMTLib2 then calling ABC
<span class="lineno">  207 </span>-- ('W4_SMTLib2'), by converting to Verilog then calling ABC ('W4_Verilog'),
<span class="lineno">  208 </span>-- or by converting to AIGER then calling ABC ('W4_AIGER'). Note that certain
<span class="lineno">  209 </span>-- options may imply that additional 'SolverBackend's were used - see
<span class="lineno">  210 </span>-- 'optionBackends'.
<span class="lineno">  211 </span>data SolverBackendOption = W4_Tactic String
<span class="lineno">  212 </span>                         | W4_SMTLib2
<span class="lineno">  213 </span>                         | W4_Verilog
<span class="lineno">  214 </span>                         | W4_AIGER
<span class="lineno">  215 </span>                         deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>)
<span class="lineno">  216 </span>
<span class="lineno">  217 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">FromJSON SolverBackendOption</span></span></span></span> where
<span class="lineno">  218 </span>  <span class="decl"><span class="istickedoff">parseJSON = JSON.genericParseJSON JSON.defaultOptions</span>
<span class="lineno">  219 </span><span class="spaces">                </span><span class="istickedoff">{ JSON.sumEncoding = JSON.TwoElemArray }</span></span>
<span class="lineno">  220 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ToJSON SolverBackendOption</span></span></span></span></span></span> where
<span class="lineno">  221 </span>  <span class="decl"><span class="istickedoff">toJSON = JSON.genericToJSON JSON.defaultOptions</span>
<span class="lineno">  222 </span><span class="spaces">             </span><span class="istickedoff">{ JSON.sumEncoding = JSON.TwoElemArray }</span></span>
<span class="lineno">  223 </span>  <span class="decl"><span class="nottickedoff">toEncoding = JSON.genericToEncoding JSON.defaultOptions</span>
<span class="lineno">  224 </span><span class="spaces">                </span><span class="nottickedoff">{ JSON.sumEncoding = JSON.TwoElemArray }</span></span>
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>-- | Given a 'SolverBackendOption', return the list of additional
<span class="lineno">  227 </span>-- 'SolverBackend's that are used
<span class="lineno">  228 </span>optionBackends :: SolverBackendOption -&gt; [SolverBackend]
<span class="lineno">  229 </span><span class="decl"><span class="istickedoff">optionBackends W4_AIGER = [AIG]</span>
<span class="lineno">  230 </span><span class="spaces"></span><span class="istickedoff">optionBackends _ = []</span></span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>-- | A map from 'SolverBackend's to their version 'String's, if one could be
<span class="lineno">  233 </span>-- obtained
<span class="lineno">  234 </span>type SolverBackendVersions = Map SolverBackend (Maybe String)
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>-- | Pretty-print a 'SolverBackend' with its version 'String'
<span class="lineno">  237 </span>showSolverBackendVersion :: SolverBackend -&gt; Maybe String -&gt; [String] -&gt; String
<span class="lineno">  238 </span><span class="decl"><span class="istickedoff">showSolverBackendVersion backend (Just v_str) opt_words =</span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="istickedoff">unwords $ show backend : v_str : opt_words</span>
<span class="lineno">  240 </span><span class="spaces"></span><span class="istickedoff">showSolverBackendVersion backend Nothing opt_words =</span>
<span class="lineno">  241 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">showSolverBackendVersion backend (Just &quot;[unknown version]&quot;) opt_words</span></span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>-- | Pretty-print a set of 'SolverBackendVersions' and 'SolverBackendOption's
<span class="lineno">  244 </span>-- with the given 'String' separator
<span class="lineno">  245 </span>showBackendVersionsWithOptions :: String -&gt; SolverBackendVersions -&gt;
<span class="lineno">  246 </span>                                  [SolverBackendOption] -&gt; String
<span class="lineno">  247 </span><span class="decl"><span class="istickedoff">showBackendVersionsWithOptions sep vs opts =</span>
<span class="lineno">  248 </span><span class="spaces">  </span><span class="istickedoff">let entries = M.unionWith (&lt;&gt;) (M.map (\v -&gt; (v, [])) vs)</span>
<span class="lineno">  249 </span><span class="spaces">                                 </span><span class="istickedoff">(M.fromList $ optEntry &lt;$&gt; opts)</span>
<span class="lineno">  250 </span><span class="spaces">   </span><span class="istickedoff">in intercalate sep $ showEntry &lt;$&gt; M.toList entries</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">where optEntry (W4_Tactic t) = (What4, (Nothing, [&quot;using&quot;, t]))</span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">optEntry W4_SMTLib2    = <span class="nottickedoff">(What4, (Nothing, [&quot;to&quot;, &quot;SMTLib2&quot;]))</span></span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">optEntry W4_Verilog    = (What4, (Nothing, [&quot;to&quot;, &quot;Verilog&quot;]))</span>
<span class="lineno">  254 </span><span class="spaces">        </span><span class="istickedoff">optEntry W4_AIGER      = (What4, (Nothing, [&quot;to&quot;, &quot;AIGER&quot;]))</span>
<span class="lineno">  255 </span><span class="spaces">        </span><span class="istickedoff">showEntry (backend, (mb_v_str, opt_words)) =</span>
<span class="lineno">  256 </span><span class="spaces">          </span><span class="istickedoff">showSolverBackendVersion backend mb_v_str opt_words</span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>-- Solver Cache Keys -----------------------------------------------------------
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>-- | The key type for 'SolverCache'. Each is a SHA256 hash of a 'SATQuery' (see
<span class="lineno">  262 </span>-- 'mkSolverCacheKey') along with optional solver version information used only
<span class="lineno">  263 </span>-- for pretty-printing.
<span class="lineno">  264 </span>data SolverCacheKey =
<span class="lineno">  265 </span>  SolverCacheKey
<span class="lineno">  266 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheKeyVersions</span></span></span> :: SolverBackendVersions
<span class="lineno">  267 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheKeyOptions</span></span></span>  :: [SolverBackendOption]
<span class="lineno">  268 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">solverCacheKeyHash</span></span></span>     :: ByteString
<span class="lineno">  269 </span>  }
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>instance <span class="decl"><span class="nottickedoff">Eq SolverCacheKey</span></span> where
<span class="lineno">  272 </span>  <span class="decl"><span class="nottickedoff">(SolverCacheKey _ _ bs1) == (SolverCacheKey _ _ bs2) = bs1 == bs2</span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show SolverCacheKey</span></span></span></span> where
<span class="lineno">  275 </span>  <span class="decl"><span class="nottickedoff">show (SolverCacheKey vs opts bs) = encodeHex (BS.take 8 bs) ++</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="nottickedoff">if M.null vs &amp;&amp; null opts then &quot;&quot;</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="nottickedoff">else &quot; (&quot; ++ showBackendVersionsWithOptions &quot;, &quot; vs opts ++ &quot;)&quot;</span></span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>-- | Make a 'SolverCacheKey' with no version information
<span class="lineno">  280 </span>solverCacheKeyFromHash :: ByteString -&gt; SolverCacheKey
<span class="lineno">  281 </span><span class="decl"><span class="istickedoff">solverCacheKeyFromHash = SolverCacheKey <span class="nottickedoff">M.empty</span> <span class="nottickedoff">[]</span></span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Serialise SolverCacheKey</span></span></span></span> where
<span class="lineno">  284 </span>  <span class="decl"><span class="istickedoff">encode = encode . solverCacheKeyHash</span></span>
<span class="lineno">  285 </span>  <span class="decl"><span class="istickedoff">decode = solverCacheKeyFromHash &lt;$&gt; decode</span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>-- | Hash using SHA256 a 'String' representation of a 'SATQuery' and a 'Set' of
<span class="lineno">  288 </span>-- 'SolverBackendVersion's to get a 'SolverCacheKey'. In particular, this
<span class="lineno">  289 </span>-- 'String' representation contains all the 'SolverBackendVersion's, the
<span class="lineno">  290 </span>-- number of 'satVariables' in the 'SATQuery', the number of 'satUninterp's in
<span class="lineno">  291 </span>-- the 'SATQuery, and finally the 'scWriteExternal' representation of the
<span class="lineno">  292 </span>-- 'satQueryAsPropTerm' of the 'SATQuery' - with two additional things:
<span class="lineno">  293 </span>-- 1. Before calling 'scWriteExternal', we generalize ('scGeneralizeExts') over
<span class="lineno">  294 </span>--    all 'satVariables' and 'satUninterp's. This ensures the hash does not
<span class="lineno">  295 </span>--    depend on any execution-specific 'VarIndex'es.
<span class="lineno">  296 </span>-- 2. After calling 'scWriteExternal', all 'LocalName's in 'Pi' and 'Lam'
<span class="lineno">  297 </span>--    constructors are removed. This ensures that two terms which are alpha
<span class="lineno">  298 </span>--    equivalent are given the same hash.
<span class="lineno">  299 </span>mkSolverCacheKey :: SharedContext -&gt; SolverBackendVersions -&gt;
<span class="lineno">  300 </span>                    [SolverBackendOption] -&gt; SATQuery -&gt; IO SolverCacheKey
<span class="lineno">  301 </span><span class="decl"><span class="istickedoff">mkSolverCacheKey sc vs opts satq = do</span>
<span class="lineno">  302 </span><span class="spaces">  </span><span class="istickedoff">body &lt;- satQueryAsPropTerm sc satq</span>
<span class="lineno">  303 </span><span class="spaces">  </span><span class="istickedoff">let ecs = M.keys (satVariables satq) ++</span>
<span class="lineno">  304 </span><span class="spaces">            </span><span class="istickedoff">filter (\ec -&gt; ecVarIndex ec `elem` satUninterp satq)</span>
<span class="lineno">  305 </span><span class="spaces">                   </span><span class="istickedoff">(getAllExts body)</span>
<span class="lineno">  306 </span><span class="spaces">  </span><span class="istickedoff">tm &lt;- scGeneralizeExts sc ecs body</span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="istickedoff">let str_prefix = [ showBackendVersionsWithOptions &quot;\n&quot; vs opts</span>
<span class="lineno">  308 </span><span class="spaces">                   </span><span class="istickedoff">, &quot;satVariables &quot; ++ show (M.size (satVariables satq))</span>
<span class="lineno">  309 </span><span class="spaces">                   </span><span class="istickedoff">, &quot;satUninterp &quot;  ++ show (length (satUninterp  satq)) ]</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">str_to_hash = unlines str_prefix ++ anonLocalNames (scWriteExternal tm)</span>
<span class="lineno">  311 </span><span class="spaces">  </span><span class="istickedoff">return $ SolverCacheKey <span class="nottickedoff">vs</span> <span class="nottickedoff">opts</span> $ SHA256.hash $ encodeUtf8 $ Text.pack $ str_to_hash</span>
<span class="lineno">  312 </span><span class="spaces">  </span><span class="istickedoff">where anonLocalNames = unlines . map (unwords . go . words) . lines</span>
<span class="lineno">  313 </span><span class="spaces">        </span><span class="istickedoff">go (x:y:_:xs) | y `elem` [&quot;Pi&quot;, &quot;Lam&quot;] = x:y:&quot;_&quot;:xs</span>
<span class="lineno">  314 </span><span class="spaces">        </span><span class="istickedoff">go xs = xs</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- Solver Cache Values ---------------------------------------------------------
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>-- | The value type for 'SolverCache': solver version information, the timestamp
<span class="lineno">  320 </span>-- of when the entry was last used, a 'Text' representing the solver used, and
<span class="lineno">  321 </span>-- an optional list of counterexamples, represented as pairs of indexes into the
<span class="lineno">  322 </span>-- list of 'satVariables' of an associated 'SATQuery'
<span class="lineno">  323 </span>data SolverCacheValue =
<span class="lineno">  324 </span>  SolverCacheValue
<span class="lineno">  325 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">solverCacheValueVersions</span></span></span>   :: SolverBackendVersions
<span class="lineno">  326 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheValueOptions</span></span></span>    :: [SolverBackendOption]
<span class="lineno">  327 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheValueSolverName</span></span></span> :: Text
<span class="lineno">  328 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheValueCEXs</span></span></span>       :: Maybe [(Int, FirstOrderValue)]
<span class="lineno">  329 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheValueLastUsed</span></span></span>   :: UTCTime
<span class="lineno">  330 </span>  } deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">FromJSON SolverCacheValue</span></span></span></span> where
<span class="lineno">  333 </span>  <span class="decl"><span class="istickedoff">parseJSON = JSON.withObject <span class="nottickedoff">&quot;SolverCacheValue&quot;</span> $ \v -&gt; do</span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="istickedoff">vs      &lt;- v .:  &quot;vs&quot;</span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff">opts    &lt;- v .:? &quot;opts&quot;</span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="istickedoff">nm      &lt;- v .:  &quot;nm&quot;</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff">mb_cexs &lt;- v .:? &quot;cexs&quot;</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="istickedoff">t       &lt;- v .:  &quot;t&quot;</span>
<span class="lineno">  339 </span><span class="spaces">    </span><span class="istickedoff">return $ SolverCacheValue vs (fromMaybe [] opts) nm mb_cexs <span class="nottickedoff">t</span></span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ToJSON SolverCacheValue</span></span></span></span></span></span> where
<span class="lineno">  342 </span>  <span class="decl"><span class="istickedoff">toJSON (SolverCacheValue vs opts nm mb_cexs t) = JSON.object $</span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="istickedoff">[&quot;vs&quot; .= vs] ++ (if null opts then [] else [&quot;opts&quot; .= opts]) ++</span>
<span class="lineno">  344 </span><span class="spaces">    </span><span class="istickedoff">[&quot;nm&quot; .= nm] ++ maybe [] (\cexs -&gt; [&quot;cexs&quot; .= cexs]) mb_cexs ++ [&quot;t&quot; .= t]</span></span>
<span class="lineno">  345 </span>  <span class="decl"><span class="nottickedoff">toEncoding (SolverCacheValue vs opts nm mb_cexs t) = JSON.pairs $</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="nottickedoff">&quot;vs&quot; .= vs &lt;&gt; (if null opts then mempty else &quot;opts&quot; .= opts) &lt;&gt;</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="nottickedoff">&quot;nm&quot; .= nm &lt;&gt; maybe mempty (\cexs -&gt; &quot;cexs&quot; .= cexs) mb_cexs &lt;&gt; &quot;t&quot; .= t</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>-- NOTE: We go through JSON because the `aeson` library gives us much nicer and
<span class="lineno">  350 </span>-- more customizable encodings than the `serialise` library, and because there
<span class="lineno">  351 </span>-- is a bijection between JSON and CBOR so we can freely pass between the two
<span class="lineno">  352 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Serialise SolverCacheValue</span></span></span></span> where
<span class="lineno">  353 </span>  <span class="decl"><span class="istickedoff">encode = encodeValue . toJSON</span></span>
<span class="lineno">  354 </span>  <span class="decl"><span class="istickedoff">decode = do</span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="istickedoff">v &lt;- decodeValue False</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">case fromJSON v of</span>
<span class="lineno">  357 </span><span class="spaces">      </span><span class="istickedoff">JSON.Success x -&gt; return x</span>
<span class="lineno">  358 </span><span class="spaces">      </span><span class="istickedoff">JSON.Error e -&gt; <span class="nottickedoff">fail e</span></span></span>
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>-- | Convert the result of a solver call on the given 'SATQuery' to a
<span class="lineno">  361 </span>-- 'SolverCacheValue'
<span class="lineno">  362 </span>toSolverCacheValue :: SolverBackendVersions -&gt; [SolverBackendOption] -&gt;
<span class="lineno">  363 </span>                      SATQuery -&gt; (Maybe CEX, Text) -&gt;
<span class="lineno">  364 </span>                      IO (Maybe SolverCacheValue)
<span class="lineno">  365 </span><span class="decl"><span class="istickedoff">toSolverCacheValue vs opts satq (cexs, solver_name) = do</span>
<span class="lineno">  366 </span><span class="spaces">  </span><span class="istickedoff">getCurrentTime &lt;&amp;&gt; \t -&gt; case firstsMaybeM (`elemIndex` ecs) cexs of</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="istickedoff">Just cexs' -&gt; Just $ SolverCacheValue vs opts solver_name cexs' t</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  369 </span><span class="spaces">  </span><span class="istickedoff">where ecs = M.keys $ satVariables satq</span>
<span class="lineno">  370 </span><span class="spaces">        </span><span class="istickedoff">firstsMaybeM :: Monad m =&gt; (a -&gt; m b) -&gt;</span>
<span class="lineno">  371 </span><span class="spaces">                        </span><span class="istickedoff">Maybe [(a, c)] -&gt; m (Maybe [(b, c)])</span>
<span class="lineno">  372 </span><span class="spaces">        </span><span class="istickedoff">firstsMaybeM = mapM . mapM . firstM</span></span>
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>-- | Convert a 'SolverCacheValue' to something which has the same form as the
<span class="lineno">  375 </span>-- result of a solver call on the given 'SATQuery'
<span class="lineno">  376 </span>fromSolverCacheValue :: SATQuery -&gt; SolverCacheValue -&gt; (Maybe CEX, Text)
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">fromSolverCacheValue satq (SolverCacheValue _ _ solver_name cexs _) =</span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">(firstsMaybe (ecs !!) cexs, solver_name)</span>
<span class="lineno">  379 </span><span class="spaces">  </span><span class="istickedoff">where ecs = M.keys $ satVariables satq</span>
<span class="lineno">  380 </span><span class="spaces">        </span><span class="istickedoff">firstsMaybe :: (a -&gt; b) -&gt; Maybe [(a, c)] -&gt; Maybe [(b, c)]</span>
<span class="lineno">  381 </span><span class="spaces">        </span><span class="istickedoff">firstsMaybe = fmap . fmap . first</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>-- The Solver Cache ------------------------------------------------------------
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>-- | A 'SolverCache' consists of a 'FilePath' to an LMDB database (which may or
<span class="lineno">  387 </span>-- may not exist yet), an optional LMDB database at that path (represented as an
<span class="lineno">  388 </span>-- 'LMDB.Environment' and 'LMDB.Database' once it is created), counters for how
<span class="lineno">  389 </span>-- many lookups, failed lookups, insertions, and failed insertions have been made
<span class="lineno">  390 </span>-- (see 'SolverCacheStat'), a map size for the LMDB database, and a timeout to
<span class="lineno">  391 </span>-- use for database lookups and inserts. Note that the counters are stored in an
<span class="lineno">  392 </span>-- 'IORef' to make sure failures are counted correctly.
<span class="lineno">  393 </span>data SolverCache =
<span class="lineno">  394 </span>  SolverCache
<span class="lineno">  395 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCachePath</span></span></span>    :: FilePath
<span class="lineno">  396 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheEnv</span></span></span>     :: Maybe (LMDB.Environment LMDB.ReadWrite)
<span class="lineno">  397 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheDB</span></span></span>      :: Maybe (LMDB.Database SolverCacheKey SolverCacheValue)
<span class="lineno">  398 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheStats</span></span></span>   :: IORef (Map SolverCacheStat Integer)
<span class="lineno">  399 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheMapSize</span></span></span> :: Int
<span class="lineno">  400 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">solverCacheTimeout</span></span></span> :: Int
<span class="lineno">  401 </span>  }
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>-- | A statistic to track in 'solverCacheStats'
<span class="lineno">  404 </span>data SolverCacheStat = Lookups | FailedLookups | Inserts | FailedInserts
<span class="lineno">  405 </span>                     deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Bounded</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Enum</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  406 </span>
<span class="lineno">  407 </span>-- | Create a 'SolverCache' with the given 'FilePath', but do not yet open an
<span class="lineno">  408 </span>-- LMDB database at that path (i.e. `solverCacheEnv` and `solverCacheDB` are
<span class="lineno">  409 </span>-- both set to 'Nothing')
<span class="lineno">  410 </span>lazyOpenSolverCache :: FilePath -&gt; IO SolverCache
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">lazyOpenSolverCache path = do</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">stats &lt;- newIORef $ M.fromList ((,0) &lt;$&gt; [minBound..])</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="istickedoff">return SolverCache { solverCachePath    = path,</span>
<span class="lineno">  414 </span><span class="spaces">                       </span><span class="istickedoff">solverCacheEnv     = Nothing,</span>
<span class="lineno">  415 </span><span class="spaces">                       </span><span class="istickedoff">solverCacheDB      = <span class="nottickedoff">Nothing</span>,</span>
<span class="lineno">  416 </span><span class="spaces">                       </span><span class="istickedoff">solverCacheStats   = stats,</span>
<span class="lineno">  417 </span><span class="spaces">                       </span><span class="istickedoff">solverCacheMapSize = 4 {- GiB -} * 1073741824,</span>
<span class="lineno">  418 </span><span class="spaces">                       </span><span class="istickedoff">solverCacheTimeout = 2 {- sec -} * 1000000 }</span></span>
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>-- | Create a 'SolverCache' with the given 'FilePath' and open an LMDB database
<span class="lineno">  421 </span>-- at that path (i.e. `solverCacheEnv` and `solverCacheDB` are both 'Just')
<span class="lineno">  422 </span>openSolverCache :: FilePath -&gt; IO SolverCache
<span class="lineno">  423 </span><span class="decl"><span class="nottickedoff">openSolverCache path = do</span>
<span class="lineno">  424 </span><span class="spaces">  </span><span class="nottickedoff">(_, _, cache') &lt;- forceSolverCacheOpened =&lt;&lt; lazyOpenSolverCache path</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="nottickedoff">return cache'</span></span>
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>-- | Ensure that the given 'SolverCache' has opened an LMDB database at its set
<span class="lineno">  428 </span>-- 'FilePath' - returning either the newly created or previously created
<span class="lineno">  429 </span>-- 'LMDB.Environment' and 'LMDB.Database', as well as an 'SolverCache'
<span class="lineno">  430 </span>-- containing both of them
<span class="lineno">  431 </span>forceSolverCacheOpened :: SolverCache -&gt;
<span class="lineno">  432 </span>                          IO (LMDB.Environment LMDB.ReadWrite,
<span class="lineno">  433 </span>                              LMDB.Database SolverCacheKey SolverCacheValue,
<span class="lineno">  434 </span>                              SolverCache)
<span class="lineno">  435 </span><span class="decl"><span class="istickedoff">forceSolverCacheOpened cache@SolverCache{ solverCacheEnv = Just env</span>
<span class="lineno">  436 </span><span class="spaces">                                        </span><span class="istickedoff">, solverCacheDB  = Just db } =</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">return (env, db, cache)</span>
<span class="lineno">  438 </span><span class="spaces"></span><span class="istickedoff">forceSolverCacheOpened cache@SolverCache{..} = do</span>
<span class="lineno">  439 </span><span class="spaces">  </span><span class="istickedoff">createDirectoryIfMissing True solverCachePath</span>
<span class="lineno">  440 </span><span class="spaces">  </span><span class="istickedoff">let limits = LMDB.defaultLimits { LMDB.mapSize = solverCacheMapSize }</span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="istickedoff">env &lt;- LMDB.openEnvironment solverCachePath limits</span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="istickedoff">db &lt;- LMDB.readOnlyTransaction env (LMDB.getDatabase Nothing)</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">let cache' = cache { solverCacheEnv = Just env, solverCacheDB = Just db }</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">return (env, db, cache')</span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>-- | Try to call 'forceSolverCacheOpened' then try to perform the given
<span class="lineno">  447 </span>-- 'LMDB.Transaction' on the LMDB database associated to the given
<span class="lineno">  448 </span>-- 'SolverCache', returning 'Left' if an error or timeout occurred at any point
<span class="lineno">  449 </span>-- and 'Right' otherwise, as well as the updated 'SolverCache' returned by
<span class="lineno">  450 </span>-- 'forceSolverCacheOpened'
<span class="lineno">  451 </span>tryTransaction :: (LMDB.Mode tmode, LMDB.SubMode LMDB.ReadWrite tmode) =&gt;
<span class="lineno">  452 </span>                  SolverCache -&gt;
<span class="lineno">  453 </span>                  (LMDB.Database SolverCacheKey SolverCacheValue -&gt;
<span class="lineno">  454 </span>                   LMDB.Transaction tmode a) -&gt;
<span class="lineno">  455 </span>                  IO (Either String a, SolverCache)
<span class="lineno">  456 </span><span class="decl"><span class="istickedoff">tryTransaction cache@SolverCache{..} t =</span>
<span class="lineno">  457 </span><span class="spaces">  </span><span class="istickedoff">tryWithTimeout solverCacheTimeout (forceSolverCacheOpened cache) &gt;&gt;= \case</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">Right (env, db, cache') -&gt;</span>
<span class="lineno">  459 </span><span class="spaces">      </span><span class="istickedoff">(,cache') &lt;$&gt; tryWithTimeout solverCacheTimeout</span>
<span class="lineno">  460 </span><span class="spaces">                                   </span><span class="istickedoff">(LMDB.transaction env (t db))</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt;</span>
<span class="lineno">  462 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return (Left $ &quot;Failed to open LMDB database: &quot; ++ err, cache)</span></span></span>
<span class="lineno">  463 </span>
<span class="lineno">  464 </span>-- | An operation on a 'SolverCache', returning a value of the given type as
<span class="lineno">  465 </span>-- well as an updated 'SolverCache' ('solverCacheOp'). Additionally, in the case
<span class="lineno">  466 </span>-- of no enabled solver cache, the operation could either fail or return a
<span class="lineno">  467 </span>-- default value ('solverCacheOpDefault').
<span class="lineno">  468 </span>data SolverCacheOp a = SCOpOrFail (Options -&gt; SolverCache -&gt; IO (a, SolverCache))
<span class="lineno">  469 </span>                     | SCOpOrDefault a (Options -&gt; SolverCache -&gt; IO (a, SolverCache))
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>-- | Get the operation associated to a 'SolverCacheOp'
<span class="lineno">  472 </span>solverCacheOp :: SolverCacheOp a -&gt; Options -&gt; SolverCache -&gt; IO (a, SolverCache)
<span class="lineno">  473 </span><span class="decl"><span class="istickedoff">solverCacheOp (SCOpOrFail f) = f</span>
<span class="lineno">  474 </span><span class="spaces"></span><span class="istickedoff">solverCacheOp (SCOpOrDefault _ f) = f</span></span>
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>-- | Get the default value associated to a 'SolverCacheOp', if any
<span class="lineno">  477 </span>solverCacheOpDefault :: SolverCacheOp a -&gt; Maybe a
<span class="lineno">  478 </span><span class="decl"><span class="nottickedoff">solverCacheOpDefault (SCOpOrFail _) = Nothing</span>
<span class="lineno">  479 </span><span class="spaces"></span><span class="nottickedoff">solverCacheOpDefault (SCOpOrDefault a _) = Just a</span></span>
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>-- | Lookup a 'SolverCacheKey' in the solver result cache
<span class="lineno">  482 </span>lookupInSolverCache :: SolverCacheKey -&gt; SolverCacheOp (Maybe SolverCacheValue)
<span class="lineno">  483 </span><span class="decl"><span class="istickedoff">lookupInSolverCache k = SCOpOrDefault <span class="nottickedoff">Nothing</span> $ \opts cache@SolverCache{..} -&gt;</span>
<span class="lineno">  484 </span><span class="spaces">  </span><span class="istickedoff">getCurrentTime &gt;&gt;= \now -&gt;</span>
<span class="lineno">  485 </span><span class="spaces">  </span><span class="istickedoff">let upd v = Just v { solverCacheValueLastUsed = now } in</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">tryTransaction @LMDB.ReadOnly cache (LMDB.lookup k) &gt;&gt;= \case</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">(Right (Just v), cache') -&gt; do</span>
<span class="lineno">  488 </span><span class="spaces">      </span><span class="istickedoff">printOutLn opts Debug <span class="nottickedoff">(&quot;Using cached result: &quot; ++ show k)</span></span>
<span class="lineno">  489 </span><span class="spaces">      </span><span class="istickedoff">modifyIORef solverCacheStats $ M.adjust (+1) Lookups</span>
<span class="lineno">  490 </span><span class="spaces">      </span><span class="istickedoff">cache'' &lt;- snd &lt;$&gt; tryTransaction cache' (LMDB.update upd k)</span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="istickedoff">return (Just v, cache'')</span>
<span class="lineno">  492 </span><span class="spaces">    </span><span class="istickedoff">(Left err, cache') -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">printOutLn opts Warn (&quot;Solver cache lookup failed:\n&quot; ++ err)</span></span>
<span class="lineno">  494 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">modifyIORef solverCacheStats $ M.adjust (+1) FailedLookups</span></span>
<span class="lineno">  495 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return (Nothing, cache')</span></span>
<span class="lineno">  496 </span><span class="spaces">    </span><span class="istickedoff">(Right Nothing, cache') -&gt; do</span>
<span class="lineno">  497 </span><span class="spaces">      </span><span class="istickedoff">return (Nothing, cache')</span></span>
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>-- | Add a 'SolverCacheValue' to the solver result cache
<span class="lineno">  500 </span>insertInSolverCache :: SolverCacheKey -&gt; SolverCacheValue -&gt; SolverCacheOp ()
<span class="lineno">  501 </span><span class="decl"><span class="istickedoff">insertInSolverCache k v = SCOpOrDefault <span class="nottickedoff">()</span> $ \opts cache@SolverCache{..} -&gt;</span>
<span class="lineno">  502 </span><span class="spaces">  </span><span class="istickedoff">printOutLn opts Debug <span class="nottickedoff">(&quot;Caching result: &quot; ++ show k)</span> &gt;&gt;</span>
<span class="lineno">  503 </span><span class="spaces">  </span><span class="istickedoff">tryTransaction cache (LMDB.insert k v) &gt;&gt;= \case</span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff">(Right (), cache') -&gt; do</span>
<span class="lineno">  505 </span><span class="spaces">      </span><span class="istickedoff">modifyIORef solverCacheStats $ M.adjust (+1) Inserts</span>
<span class="lineno">  506 </span><span class="spaces">      </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, cache')</span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff">(Left err, cache') -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  508 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">printOutLn opts Warn (&quot;Solver cache insert failed:\n&quot; ++ err)</span></span>
<span class="lineno">  509 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">modifyIORef solverCacheStats $ M.adjust (+1) FailedInserts</span></span>
<span class="lineno">  510 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return ((), cache')</span></span></span>
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>-- | Set the 'FilePath' of the solver result cache and save all results cached
<span class="lineno">  513 </span>-- so far
<span class="lineno">  514 </span>setSolverCachePath :: FilePath -&gt; SolverCacheOp ()
<span class="lineno">  515 </span><span class="decl"><span class="istickedoff">setSolverCachePath path = SCOpOrFail $ \opts cache@SolverCache{..} -&gt;</span>
<span class="lineno">  516 </span><span class="spaces">  </span><span class="istickedoff">if <span class="tickonlyfalse">path == solverCachePath</span></span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="istickedoff">then <span class="nottickedoff">do</span></span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(_, _, cache') &lt;- forceSolverCacheOpened cache</span></span>
<span class="lineno">  519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return ((), cache')</span></span>
<span class="lineno">  520 </span><span class="spaces">  </span><span class="istickedoff">else do</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="istickedoff">(new_env, new_db, cache') &lt;-</span>
<span class="lineno">  522 </span><span class="spaces">        </span><span class="istickedoff">forceSolverCacheOpened cache { solverCachePath = path</span>
<span class="lineno">  523 </span><span class="spaces">                                     </span><span class="istickedoff">, solverCacheEnv  = Nothing</span>
<span class="lineno">  524 </span><span class="spaces">                                     </span><span class="istickedoff">, solverCacheDB   = <span class="nottickedoff">Nothing</span> }</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="istickedoff">case (solverCacheEnv, <span class="nottickedoff">solverCacheDB</span>) of</span>
<span class="lineno">  526 </span><span class="spaces">      </span><span class="istickedoff">(Just old_env, Just old_db) -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  527 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">kvs &lt;- LMDB.readOnlyTransaction old_env $ LMDB.toList old_db</span></span>
<span class="lineno">  528 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">forM_ kvs $ \(k,v) -&gt; LMDB.transaction new_env $ LMDB.insert k v new_db</span></span>
<span class="lineno">  529 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">printOutLn opts Info (&quot;Saved &quot; ++ show (length kvs) ++ &quot; cached result&quot; ++</span></span>
<span class="lineno">  530 </span><span class="spaces">                              </span><span class="istickedoff"><span class="nottickedoff">(if length kvs == 1 then &quot;&quot; else &quot;s&quot;) ++ &quot; to disk&quot;)</span></span>
<span class="lineno">  531 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">return ((), cache')</span></span>
<span class="lineno">  532 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return (<span class="nottickedoff">()</span>, cache')</span></span>
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>-- | Print all entries in the solver result cache whose SHA256 hash keys start
<span class="lineno">  535 </span>-- with the given string
<span class="lineno">  536 </span>printSolverCacheByHex :: Text -&gt; SolverCacheOp ()
<span class="lineno">  537 </span><span class="decl"><span class="nottickedoff">printSolverCacheByHex hex_pref_txt = SCOpOrFail $ \opts cache -&gt; do</span>
<span class="lineno">  538 </span><span class="spaces">  </span><span class="nottickedoff">let hex_pref = Text.unpack hex_pref_txt</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="nottickedoff">(env, db, cache') &lt;- forceSolverCacheOpened cache</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="nottickedoff">let flt k v kvs = if hex_pref `isPrefixOf` encodeHex (solverCacheKeyHash k)</span>
<span class="lineno">  541 </span><span class="spaces">                    </span><span class="nottickedoff">then (k,v):kvs else kvs</span>
<span class="lineno">  542 </span><span class="spaces">  </span><span class="nottickedoff">kvs &lt;- case decodeHex hex_pref of</span>
<span class="lineno">  543 </span><span class="spaces">    </span><span class="nottickedoff">Right (solverCacheKeyFromHash -&gt; k) -&gt; do</span>
<span class="lineno">  544 </span><span class="spaces">      </span><span class="nottickedoff">LMDB.readOnlyTransaction env (LMDB.lookup k db) &gt;&gt;= \case</span>
<span class="lineno">  545 </span><span class="spaces">        </span><span class="nottickedoff">Just v -&gt; return [(k,v)]</span>
<span class="lineno">  546 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; LMDB.readOnlyTransaction env $ LMDB.foldrWithKey flt [] db</span>
<span class="lineno">  547 </span><span class="spaces">    </span><span class="nottickedoff">Left _ -&gt; LMDB.readOnlyTransaction env $ LMDB.foldrWithKey flt [] db</span>
<span class="lineno">  548 </span><span class="spaces">  </span><span class="nottickedoff">when (length kvs == 0) $ printOutLn opts Info &quot;No keys found&quot;</span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="nottickedoff">forM_ kvs $ \(k, SolverCacheValue vs bk_opts nm mb_cexs t) -&gt; do</span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="nottickedoff">let vs_str = showBackendVersionsWithOptions &quot;, &quot; vs bk_opts</span>
<span class="lineno">  551 </span><span class="spaces">        </span><span class="nottickedoff">res_str = maybe &quot;unsat&quot; ((&quot;sat &quot; ++) . show) mb_cexs</span>
<span class="lineno">  552 </span><span class="spaces">    </span><span class="nottickedoff">printOutLn opts Info $ &quot;SHA: &quot; ++ encodeHex (solverCacheKeyHash k)</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="nottickedoff">printOutLn opts Info $ &quot;- Result: &quot; ++ res_str</span>
<span class="lineno">  554 </span><span class="spaces">    </span><span class="nottickedoff">printOutLn opts Info $ &quot;- Solver: &quot; ++ show nm</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="nottickedoff">printOutLn opts Info $ &quot;- Versions: &quot; ++ vs_str</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="nottickedoff">printOutLn opts Info $ &quot;- Last used: &quot; ++ show t ++ &quot;\n&quot;</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="nottickedoff">return ((), cache')</span></span>
<span class="lineno">  558 </span>
<span class="lineno">  559 </span>-- | Remove all entries in the solver result cache which have version(s) that
<span class="lineno">  560 </span>-- do not match the current version(s) or are marked as stale
<span class="lineno">  561 </span>cleanMismatchedVersionsSolverCache :: SolverBackendVersions -&gt; SolverCacheOp ()
<span class="lineno">  562 </span><span class="decl"><span class="istickedoff">cleanMismatchedVersionsSolverCache curr_base_vs = SCOpOrFail $ \opts cache -&gt; do</span>
<span class="lineno">  563 </span><span class="spaces">  </span><span class="istickedoff">let known_curr_base_vs = M.filter isJust curr_base_vs</span>
<span class="lineno">  564 </span><span class="spaces">      </span><span class="istickedoff">mismatched_vs vs = M.mapMaybe id $ M.intersectionWith</span>
<span class="lineno">  565 </span><span class="spaces">        </span><span class="istickedoff">(\base_ver v_ver -&gt; if base_ver /= v_ver</span>
<span class="lineno">  566 </span><span class="spaces">                            </span><span class="istickedoff">then Just (base_ver, v_ver) else Nothing)</span>
<span class="lineno">  567 </span><span class="spaces">        </span><span class="istickedoff">known_curr_base_vs vs</span>
<span class="lineno">  568 </span><span class="spaces">      </span><span class="istickedoff">flt k v (ks, mvs) = let mvs' = mismatched_vs (solverCacheValueVersions v)</span>
<span class="lineno">  569 </span><span class="spaces">                           </span><span class="istickedoff">in if M.null mvs' then (ks, mvs)</span>
<span class="lineno">  570 </span><span class="spaces">                                             </span><span class="istickedoff">else (k:ks, M.union mvs mvs')</span>
<span class="lineno">  571 </span><span class="spaces">  </span><span class="istickedoff">(env, db, cache') &lt;- forceSolverCacheOpened cache</span>
<span class="lineno">  572 </span><span class="spaces">  </span><span class="istickedoff">(ks, mvs) &lt;- LMDB.readOnlyTransaction env $ LMDB.foldrWithKey flt ([], M.empty) db</span>
<span class="lineno">  573 </span><span class="spaces">  </span><span class="istickedoff">forM_ ks $ \k -&gt; LMDB.transaction env $ LMDB.delete k db</span>
<span class="lineno">  574 </span><span class="spaces">  </span><span class="istickedoff">let s0 = if <span class="tickonlyfalse">length ks == 1</span> then <span class="nottickedoff">&quot;&quot;</span> else &quot;s&quot;</span>
<span class="lineno">  575 </span><span class="spaces">      </span><span class="istickedoff">s1 = if <span class="tickonlyfalse">M.size mvs == 0</span> then <span class="nottickedoff">&quot;&quot;</span> else &quot;:&quot;</span>
<span class="lineno">  576 </span><span class="spaces">  </span><span class="istickedoff">printOutLn opts Info $</span>
<span class="lineno">  577 </span><span class="spaces">    </span><span class="istickedoff">&quot;Removed &quot; ++ show (length ks) ++</span>
<span class="lineno">  578 </span><span class="spaces">    </span><span class="istickedoff">&quot; cached result&quot; ++ s0 ++ &quot; with mismatched version&quot; ++ s0 ++ s1</span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="istickedoff">forM_ (M.toList mvs) $ \(backend, (v1, v2)) -&gt;</span>
<span class="lineno">  580 </span><span class="spaces">    </span><span class="istickedoff">printOutLn opts Info $</span>
<span class="lineno">  581 </span><span class="spaces">      </span><span class="istickedoff">&quot;- &quot; ++ showSolverBackendVersion backend v1 [] ++</span>
<span class="lineno">  582 </span><span class="spaces">      </span><span class="istickedoff">&quot; (Current: &quot; ++ showSolverBackendVersion backend v2 [] ++ &quot;)&quot;</span>
<span class="lineno">  583 </span><span class="spaces">  </span><span class="istickedoff">sz &lt;- LMDB.readOnlyTransaction env $ LMDB.size db</span>
<span class="lineno">  584 </span><span class="spaces">  </span><span class="istickedoff">let (sz0, sz1) = if <span class="tickonlyfalse">sz == 1</span> then <span class="nottickedoff">(&quot;is&quot;, &quot;&quot;)</span> else (&quot;are&quot;, &quot;s&quot;)</span>
<span class="lineno">  585 </span><span class="spaces">  </span><span class="istickedoff">printOutLn opts Info $ &quot;There &quot; ++ sz0 ++ &quot; &quot; ++ show sz ++ &quot; result&quot;</span>
<span class="lineno">  586 </span><span class="spaces">                                  </span><span class="istickedoff">++ sz1 ++ &quot; remaining in the cache&quot;</span>
<span class="lineno">  587 </span><span class="spaces">  </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, cache')</span></span>
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>-- | Print out statistics about how the solver cache was used
<span class="lineno">  590 </span>printSolverCacheStats :: SolverCacheOp ()
<span class="lineno">  591 </span><span class="decl"><span class="nottickedoff">printSolverCacheStats = SCOpOrFail $ \opts cache@SolverCache{..} -&gt; do</span>
<span class="lineno">  592 </span><span class="spaces">  </span><span class="nottickedoff">(env, db, cache') &lt;- forceSolverCacheOpened cache</span>
<span class="lineno">  593 </span><span class="spaces">  </span><span class="nottickedoff">printOutLn opts Info (&quot;== Solver result cache statistics ==&quot;)</span>
<span class="lineno">  594 </span><span class="spaces">  </span><span class="nottickedoff">sz &lt;- LMDB.readOnlyTransaction env $ LMDB.size db</span>
<span class="lineno">  595 </span><span class="spaces">  </span><span class="nottickedoff">printOutLn opts Info (&quot;- &quot; ++ show sz ++ &quot; result&quot; ++ pl sz</span>
<span class="lineno">  596 </span><span class="spaces">                             </span><span class="nottickedoff">++ &quot; cached in &quot; ++ solverCachePath)</span>
<span class="lineno">  597 </span><span class="spaces">  </span><span class="nottickedoff">stats &lt;- readIORef solverCacheStats</span>
<span class="lineno">  598 </span><span class="spaces">  </span><span class="nottickedoff">let (ls, ls_f) = (stats M.! Lookups, stats M.! FailedLookups)</span>
<span class="lineno">  599 </span><span class="spaces">      </span><span class="nottickedoff">(is, is_f) = (stats M.! Inserts, stats M.! FailedInserts)</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="nottickedoff">printOutLn opts Info $ &quot;- &quot; ++ show is ++ &quot; insertion&quot; ++ pl is</span>
<span class="lineno">  601 </span><span class="spaces">                              </span><span class="nottickedoff">++ &quot; into the cache so far this run (&quot;</span>
<span class="lineno">  602 </span><span class="spaces">                              </span><span class="nottickedoff">++ show is_f ++ &quot; failed attempt&quot; ++ pl is_f ++ &quot;)&quot;</span>
<span class="lineno">  603 </span><span class="spaces">  </span><span class="nottickedoff">printOutLn opts Info $ &quot;- &quot; ++ show ls ++ &quot; usage&quot; ++ pl ls</span>
<span class="lineno">  604 </span><span class="spaces">                              </span><span class="nottickedoff">++ &quot; of cached results so far this run (&quot;</span>
<span class="lineno">  605 </span><span class="spaces">                              </span><span class="nottickedoff">++ show ls_f ++ &quot; failed attempt&quot; ++ pl ls_f ++ &quot;)&quot;</span>
<span class="lineno">  606 </span><span class="spaces">  </span><span class="nottickedoff">return ((), cache')</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="nottickedoff">where pl i = if i == 1 then &quot;&quot; else &quot;s&quot;</span></span>
<span class="lineno">  608 </span>
<span class="lineno">  609 </span>-- | Check whether the values of the statistics printed out by
<span class="lineno">  610 </span>-- 'printSolverCacheStats' are equal to those given, failing if this does not
<span class="lineno">  611 </span>-- hold
<span class="lineno">  612 </span>testSolverCacheStats :: Integer -&gt; Integer -&gt; Integer -&gt; Integer -&gt; Integer -&gt;
<span class="lineno">  613 </span>                        SolverCacheOp ()
<span class="lineno">  614 </span><span class="decl"><span class="istickedoff">testSolverCacheStats sz ls ls_f is is_f = SCOpOrFail $ \opts cache@SolverCache{..} -&gt; do</span>
<span class="lineno">  615 </span><span class="spaces">  </span><span class="istickedoff">(env, db, cache') &lt;- forceSolverCacheOpened cache</span>
<span class="lineno">  616 </span><span class="spaces">  </span><span class="istickedoff">sz_actual &lt;- fromIntegral &lt;$&gt; LMDB.readOnlyTransaction env (LMDB.size db)</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="istickedoff">test sz sz_actual <span class="nottickedoff">&quot;Size of solver cache&quot;</span></span>
<span class="lineno">  618 </span><span class="spaces">  </span><span class="istickedoff">stats &lt;- readIORef solverCacheStats</span>
<span class="lineno">  619 </span><span class="spaces">  </span><span class="istickedoff">test ls (stats M.! Lookups) <span class="nottickedoff">&quot;Number of usages of solver cache&quot;</span></span>
<span class="lineno">  620 </span><span class="spaces">  </span><span class="istickedoff">test ls_f (stats M.! FailedLookups) <span class="nottickedoff">&quot;Number of failed usages of solver cache&quot;</span></span>
<span class="lineno">  621 </span><span class="spaces">  </span><span class="istickedoff">test is (stats M.! Inserts) <span class="nottickedoff">&quot;Number of insertions into solver cache&quot;</span></span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="istickedoff">test is_f (stats M.! FailedInserts) <span class="nottickedoff">&quot;Number of failed insertions into solver cache&quot;</span></span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">printOutLn opts Info $ &quot;Solver cache stats matched expected (&quot; ++ show sz ++ &quot; &quot; ++</span>
<span class="lineno">  624 </span><span class="spaces">    </span><span class="istickedoff">show ls ++ &quot; &quot; ++ show ls_f ++ &quot; &quot; ++ show is ++ &quot; &quot; ++ show is_f ++ &quot;)&quot;</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, cache')</span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="istickedoff">where test v v_actual str = when (v /= v_actual) $ <span class="nottickedoff">fail $</span></span>
<span class="lineno">  627 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">str ++ &quot; (&quot; ++ show v_actual ++ &quot;)&quot;</span></span>
<span class="lineno">  628 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">++ &quot; did not match expected (&quot; ++ show v ++ &quot;)&quot;</span></span></span>

</pre>
</body>
</html>
