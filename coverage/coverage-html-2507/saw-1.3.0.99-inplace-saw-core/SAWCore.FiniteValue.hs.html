<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>{- |
<span class="lineno">    4 </span>Module      : SAWCore.FiniteValue
<span class="lineno">    5 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    6 </span>License     : BSD3
<span class="lineno">    7 </span>Maintainer  : huffman@galois.com
<span class="lineno">    8 </span>Stability   : experimental
<span class="lineno">    9 </span>Portability : non-portable (language extensions)
<span class="lineno">   10 </span>-}
<span class="lineno">   11 </span>module SAWCore.FiniteValue where
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>import GHC.Generics (Generic)
<span class="lineno">   14 </span>import Control.Monad (replicateM, mzero)
<span class="lineno">   15 </span>import Control.Monad.Trans (lift)
<span class="lineno">   16 </span>import Control.Monad.Trans.Maybe
<span class="lineno">   17 </span>import qualified Control.Monad.State as S
<span class="lineno">   18 </span>import Data.List (intersperse)
<span class="lineno">   19 </span>import Data.Map (Map)
<span class="lineno">   20 </span>import qualified Data.Map as Map
<span class="lineno">   21 </span>import qualified Data.Text as Text
<span class="lineno">   22 </span>import Numeric.Natural (Natural)
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>import Data.Foldable.WithIndex (ifoldrM)
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>import Prettyprinter hiding (Doc)
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>import Data.Aeson ( FromJSON(..), ToJSON(..), FromJSONKey(..), ToJSONKey(..) )
<span class="lineno">   29 </span>import qualified Data.Aeson as JSON
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>import SAWSupport.Pretty (prettyNat)
<span class="lineno">   32 </span>import qualified SAWSupport.Pretty as PPS (Doc, Opts, defaultOpts)
<span class="lineno">   33 </span>
<span class="lineno">   34 </span>import qualified SAWCore.Recognizer as R
<span class="lineno">   35 </span>import SAWCore.SharedTerm
<span class="lineno">   36 </span>import SAWCore.Term.Functor
<span class="lineno">   37 </span>import SAWCore.Term.Pretty
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>-- | Finite types that can be encoded as bits for a SAT/SMT solver.
<span class="lineno">   40 </span>data FiniteType
<span class="lineno">   41 </span>  = FTBit
<span class="lineno">   42 </span>  | FTVec Natural FiniteType
<span class="lineno">   43 </span>  | FTTuple [FiniteType]
<span class="lineno">   44 </span>  | FTRec (Map FieldName FiniteType)
<span class="lineno">   45 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>-- | Values inhabiting those finite types.
<span class="lineno">   48 </span>data FiniteValue
<span class="lineno">   49 </span>  = FVBit Bool
<span class="lineno">   50 </span>  | FVWord Natural Integer -- ^ a more efficient special case for 'FVVec FTBit _'.
<span class="lineno">   51 </span>  | FVVec FiniteType [FiniteValue]
<span class="lineno">   52 </span>  | FVTuple [FiniteValue]
<span class="lineno">   53 </span>  | FVRec (Map FieldName FiniteValue)
<span class="lineno">   54 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>-- | First-order types that can be encoded in an SMT solver.
<span class="lineno">   57 </span>-- NB: The JSON encoding of this type, used for saw-script solver result caching,
<span class="lineno">   58 </span>-- assumes constructor names and argument orders will not change (though the
<span class="lineno">   59 </span>-- order and number of constructors may change) - see 'firstOrderJSONOptions'
<span class="lineno">   60 </span>data FirstOrderType
<span class="lineno">   61 </span>  = FOTBit
<span class="lineno">   62 </span>  | FOTInt
<span class="lineno">   63 </span>  | FOTIntMod Natural
<span class="lineno">   64 </span>  | FOTVec Natural FirstOrderType
<span class="lineno">   65 </span>  | FOTArray FirstOrderType FirstOrderType
<span class="lineno">   66 </span>  | FOTTuple [FirstOrderType]
<span class="lineno">   67 </span>  | FOTRec (Map FieldName FirstOrderType)
<span class="lineno">   68 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>)
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>-- | Values inhabiting those first-order types.
<span class="lineno">   71 </span>-- NB: The JSON encoding of this type, used for saw-script solver result caching,
<span class="lineno">   72 </span>-- assumes constructor names and argument orders will not change (though the
<span class="lineno">   73 </span>-- order and number of constructors may change) - see 'firstOrderJSONOptions'
<span class="lineno">   74 </span>--
<span class="lineno">   75 </span>-- The type argument of FOVArray is the key type; the value type is
<span class="lineno">   76 </span>-- derivable from the default value, which is the second argument. The third
<span class="lineno">   77 </span>-- argument is an assignment for all the entries that have non-default values.
<span class="lineno">   78 </span>--
<span class="lineno">   79 </span>-- FOVOpaqueArray is for arrays we get back from the solver only as a
<span class="lineno">   80 </span>-- function call that one can use for lookups. We can't do anything
<span class="lineno">   81 </span>-- with that (see Note [FOVArray] below) so we just treat it as an
<span class="lineno">   82 </span>-- opaque blob. The arguments are the key and value types, since we
<span class="lineno">   83 </span>-- do at least have that info.
<span class="lineno">   84 </span>data FirstOrderValue
<span class="lineno">   85 </span>  = FOVBit Bool
<span class="lineno">   86 </span>  | FOVInt Integer
<span class="lineno">   87 </span>  | FOVIntMod Natural Integer
<span class="lineno">   88 </span>  | FOVWord Natural Integer -- ^ a more efficient special case for 'FOVVec FOTBit _'.
<span class="lineno">   89 </span>  | FOVVec FirstOrderType [FirstOrderValue]
<span class="lineno">   90 </span>  | FOVArray FirstOrderType FirstOrderValue (Map FirstOrderValue FirstOrderValue)
<span class="lineno">   91 </span>  | FOVOpaqueArray FirstOrderType FirstOrderType
<span class="lineno">   92 </span>  | FOVTuple [FirstOrderValue]
<span class="lineno">   93 </span>  | FOVRec (Map FieldName FirstOrderValue)
<span class="lineno">   94 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Generic</span></span></span></span>)
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>--
<span class="lineno">   97 </span>-- Note [FOVArray]
<span class="lineno">   98 </span>-- ~~~~~~~~~~~~~~~
<span class="lineno">   99 </span>--
<span class="lineno">  100 </span>-- We only handle arrays that are:
<span class="lineno">  101 </span>--    - unidimensional
<span class="lineno">  102 </span>--    - made up of explicit concrete values
<span class="lineno">  103 </span>--
<span class="lineno">  104 </span>-- We could handle multidimensional arrays easily enough (the key type
<span class="lineno">  105 </span>-- and assignment keys just need to become lists) but for the moment
<span class="lineno">  106 </span>-- there's no use case.
<span class="lineno">  107 </span>--
<span class="lineno">  108 </span>-- The What4 interface can sometimes return an array that isn't made
<span class="lineno">  109 </span>-- up of explicit concrete values but is instead represented as a
<span class="lineno">  110 </span>-- function you can call to get values out for given keys. It is not
<span class="lineno">  111 </span>-- clear how we'd use this, since the primary thing we do with array
<span class="lineno">  112 </span>-- values that come back from the solver is print them as part of
<span class="lineno">  113 </span>-- models and without a way to know what keys are present a function
<span class="lineno">  114 </span>-- that just extracts values is fairly useless. If one of these pops
<span class="lineno">  115 </span>-- up, it comes back as FOVOpaqueArray and we treat it as an opaque
<span class="lineno">  116 </span>-- blob. Unfortuately this does happen (maybe we can improve What4 so
<span class="lineno">  117 </span>-- it happens less or maybe not at all, but that's not happening right
<span class="lineno">  118 </span>-- away) so we need to be able to handle it rather than erroring out
<span class="lineno">  119 </span>-- or crashing.
<span class="lineno">  120 </span>--
<span class="lineno">  121 </span>-- Note that trying to retain the function at this level is
<span class="lineno">  122 </span>-- problematic for a number of reasons:
<span class="lineno">  123 </span>--
<span class="lineno">  124 </span>--    1. It's not actually a first-order value, and calling it one is
<span class="lineno">  125 </span>--       borrowing trouble.
<span class="lineno">  126 </span>--
<span class="lineno">  127 </span>--    2. We need ToJSON and FromJSON instances for solver caching, and
<span class="lineno">  128 </span>--       there's no way to do that. Now, trying to stick one of these
<span class="lineno">  129 </span>--       objects in the solver cache is just not going to work no
<span class="lineno">  130 </span>--       matter how we handle it; but things are not structured so
<span class="lineno">  131 </span>--       that we can e.g. decline to cache values that contain
<span class="lineno">  132 </span>--       function-based arrays so that it's safe to stub out the
<span class="lineno">  133 </span>--       ToJSON and FromJSON instances with an error invocation. That
<span class="lineno">  134 </span>--       could doubtless be arranged, but it'll take work, possibly a
<span class="lineno">  135 </span>--       lot of work. As things stand, we _can_ stuff FOVOpaqueArray
<span class="lineno">  136 </span>--       into the solver cache, and it won't do anything useful when
<span class="lineno">  137 </span>--       we unstuff it later, but it won't crash.
<span class="lineno">  138 </span>--
<span class="lineno">  139 </span>--    3. FirstOrderValue needs Eq and Ord instances, at least but not
<span class="lineno">  140 </span>--       necessarily only for use by maps. At least one of those maps
<span class="lineno">  141 </span>--       (the one used in FOVArray) is restricted to not have array
<span class="lineno">  142 </span>--       values as keys; however, that's not an _explicit_ restriction
<span class="lineno">  143 </span>--       (e.g. in typechecking), it's a consequence of the things
<span class="lineno">  144 </span>--       What4 allows as array keys. To be halfway safe we'd need to
<span class="lineno">  145 </span>--       make it an explicit restriction, and in the current state of
<span class="lineno">  146 </span>--       SAW maintenance it's not really clear enough where we'd need
<span class="lineno">  147 </span>--       to enforce that to keep it safe. Also, there may be other
<span class="lineno">  148 </span>--       such maps about where arrays _can_ be keys, or for that
<span class="lineno">  149 </span>--       matter other comparisons. In principle you could have the
<span class="lineno">  150 </span>--       compiler find you all the uses by disabling the Eq and Ord
<span class="lineno">  151 </span>--       instances. But that doesn't work because the ToJSON and
<span class="lineno">  152 </span>--       FromJSON classes need them. The compiler then just fails on
<span class="lineno">  153 </span>--       those before telling you anything else.
<span class="lineno">  154 </span>--
<span class="lineno">  155 </span>-- Besides all the above, restrictions in What4 mean that array values
<span class="lineno">  156 </span>-- coming back from the solver via that interface are indexed only by
<span class="lineno">  157 </span>-- integers or bitvectors. At this layer, though, we can support any
<span class="lineno">  158 </span>-- FirstOrderValue.
<span class="lineno">  159 </span>--
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>toFirstOrderType :: FiniteType -&gt; FirstOrderType
<span class="lineno">  162 </span><span class="decl"><span class="nottickedoff">toFirstOrderType ft =</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="nottickedoff">case ft of</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="nottickedoff">FTBit      -&gt; FOTBit</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="nottickedoff">FTVec n t  -&gt; FOTVec n (toFirstOrderType t)</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="nottickedoff">FTTuple ts -&gt; FOTTuple (map toFirstOrderType ts)</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="nottickedoff">FTRec tm   -&gt; FOTRec (fmap toFirstOrderType tm)</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>toFirstOrderValue :: FiniteValue -&gt; FirstOrderValue
<span class="lineno">  170 </span><span class="decl"><span class="nottickedoff">toFirstOrderValue fv =</span>
<span class="lineno">  171 </span><span class="spaces">  </span><span class="nottickedoff">case fv of</span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="nottickedoff">FVBit b    -&gt; FOVBit b</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="nottickedoff">FVWord w i -&gt; FOVWord w i</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="nottickedoff">FVVec t vs -&gt; FOVVec (toFirstOrderType t) (map toFirstOrderValue vs)</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="nottickedoff">FVTuple vs -&gt; FOVTuple (map toFirstOrderValue vs)</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="nottickedoff">FVRec vm   -&gt; FOVRec (fmap toFirstOrderValue vm)</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>toFiniteType :: FirstOrderType -&gt; Maybe FiniteType
<span class="lineno">  180 </span><span class="decl"><span class="istickedoff">toFiniteType FOTBit        = pure FTBit</span>
<span class="lineno">  181 </span><span class="spaces"></span><span class="istickedoff">toFiniteType (FOTVec n t)  = FTVec n &lt;$&gt; toFiniteType t</span>
<span class="lineno">  182 </span><span class="spaces"></span><span class="istickedoff">toFiniteType (FOTTuple ts) = <span class="nottickedoff">FTTuple &lt;$&gt; traverse toFiniteType ts</span></span>
<span class="lineno">  183 </span><span class="spaces"></span><span class="istickedoff">toFiniteType (FOTRec fs)   = <span class="nottickedoff">FTRec   &lt;$&gt; traverse toFiniteType fs</span></span>
<span class="lineno">  184 </span><span class="spaces"></span><span class="istickedoff">toFiniteType FOTInt{}      = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  185 </span><span class="spaces"></span><span class="istickedoff">toFiniteType FOTIntMod{}   = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  186 </span><span class="spaces"></span><span class="istickedoff">toFiniteType FOTArray{}    = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show FiniteValue</span></span></span></span> where
<span class="lineno">  189 </span>  <span class="decl"><span class="nottickedoff">showsPrec p fv = showsPrec p (toFirstOrderValue fv)</span></span>
<span class="lineno">  190 </span>
<span class="lineno">  191 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show FirstOrderValue</span></span></span></span> where
<span class="lineno">  192 </span>  <span class="decl"><span class="nottickedoff">showsPrec _ fv =</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="nottickedoff">case fv of</span>
<span class="lineno">  194 </span><span class="spaces">      </span><span class="nottickedoff">FOVBit b    -&gt; shows b</span>
<span class="lineno">  195 </span><span class="spaces">      </span><span class="nottickedoff">FOVInt i    -&gt; shows i</span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="nottickedoff">FOVIntMod _ i -&gt; shows i</span>
<span class="lineno">  197 </span><span class="spaces">      </span><span class="nottickedoff">FOVWord _ x -&gt; shows x</span>
<span class="lineno">  198 </span><span class="spaces">      </span><span class="nottickedoff">FOVVec _ vs -&gt; showString &quot;[&quot; . commaSep (map shows vs) . showString &quot;]&quot;</span>
<span class="lineno">  199 </span><span class="spaces">      </span><span class="nottickedoff">FOVArray _kty d vs -&gt;</span>
<span class="lineno">  200 </span><span class="spaces">        </span><span class="nottickedoff">let vs' = map showEntry $ Map.toAscList vs</span>
<span class="lineno">  201 </span><span class="spaces">            </span><span class="nottickedoff">d' = showEntry (&quot;&lt;default&gt;&quot;, d)</span>
<span class="lineno">  202 </span><span class="spaces">        </span><span class="nottickedoff">in</span>
<span class="lineno">  203 </span><span class="spaces">        </span><span class="nottickedoff">showString &quot;[&quot; . commaSep (vs' ++ [d']) . showString &quot;]&quot;</span>
<span class="lineno">  204 </span><span class="spaces">      </span><span class="nottickedoff">FOVOpaqueArray _kty _vty -&gt;</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="nottickedoff">showString &quot;[ opaque array, sorry ]&quot;</span>
<span class="lineno">  206 </span><span class="spaces">      </span><span class="nottickedoff">FOVTuple vs -&gt; showString &quot;(&quot; . commaSep (map shows vs) . showString &quot;)&quot;</span>
<span class="lineno">  207 </span><span class="spaces">      </span><span class="nottickedoff">FOVRec vm   -&gt; showString &quot;{&quot; . commaSep (map showField (Map.assocs vm)) . showString &quot;}&quot;</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">  209 </span><span class="spaces">      </span><span class="nottickedoff">commaSep ss = foldr (.) id (intersperse (showString &quot;,&quot;) ss)</span>
<span class="lineno">  210 </span><span class="spaces">      </span><span class="nottickedoff">showEntry (k, v) = shows k . showString &quot; := &quot; . shows v</span>
<span class="lineno">  211 </span><span class="spaces">      </span><span class="nottickedoff">showField (field, v) = showString (Text.unpack field) . showString &quot; = &quot; . shows v</span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>ppFiniteValue :: PPS.Opts -&gt; FiniteValue -&gt; PPS.Doc
<span class="lineno">  214 </span><span class="decl"><span class="nottickedoff">ppFiniteValue opts fv = ppFirstOrderValue opts (toFirstOrderValue fv)</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>ppFirstOrderValue :: PPS.Opts -&gt; FirstOrderValue -&gt; PPS.Doc
<span class="lineno">  217 </span><span class="decl"><span class="istickedoff">ppFirstOrderValue opts = loop</span>
<span class="lineno">  218 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  219 </span><span class="spaces"> </span><span class="istickedoff">loop fv = case fv of</span>
<span class="lineno">  220 </span><span class="spaces">   </span><span class="istickedoff">FOVBit b</span>
<span class="lineno">  221 </span><span class="spaces">     </span><span class="istickedoff">| <span class="tickonlyfalse">b</span>         -&gt; <span class="nottickedoff">pretty &quot;True&quot;</span></span>
<span class="lineno">  222 </span><span class="spaces">     </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; pretty &quot;False&quot;</span>
<span class="lineno">  223 </span><span class="spaces">   </span><span class="istickedoff">FOVInt i      -&gt; <span class="nottickedoff">pretty i</span></span>
<span class="lineno">  224 </span><span class="spaces">   </span><span class="istickedoff">FOVIntMod _ i -&gt; <span class="nottickedoff">pretty i</span></span>
<span class="lineno">  225 </span><span class="spaces">   </span><span class="istickedoff">FOVWord _w i  -&gt; prettyNat opts i</span>
<span class="lineno">  226 </span><span class="spaces">   </span><span class="istickedoff">FOVVec _ xs   -&gt; brackets (sep (punctuate comma (map loop xs)))</span>
<span class="lineno">  227 </span><span class="spaces">   </span><span class="istickedoff">FOVArray _kty d vs -&gt;</span>
<span class="lineno">  228 </span><span class="spaces">      </span><span class="istickedoff">let ppEntry' k' v = k' &lt;+&gt; pretty &quot;:=&quot; &lt;+&gt; loop v</span>
<span class="lineno">  229 </span><span class="spaces">          </span><span class="istickedoff">ppEntry (k, v) = ppEntry' (loop k) v</span>
<span class="lineno">  230 </span><span class="spaces">          </span><span class="istickedoff">d' = ppEntry' (pretty &quot;&lt;default&gt;&quot;) d</span>
<span class="lineno">  231 </span><span class="spaces">          </span><span class="istickedoff">vs' = map ppEntry $ Map.toAscList vs</span>
<span class="lineno">  232 </span><span class="spaces">      </span><span class="istickedoff">in</span>
<span class="lineno">  233 </span><span class="spaces">      </span><span class="istickedoff">brackets (nest 4 (sep (punctuate comma (vs' ++ [d']))))</span>
<span class="lineno">  234 </span><span class="spaces">   </span><span class="istickedoff">FOVOpaqueArray _kty _vty -&gt;</span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">pretty &quot;[ opaque array, sorry ]&quot;</span></span>
<span class="lineno">  236 </span><span class="spaces">   </span><span class="istickedoff">FOVTuple xs   -&gt; <span class="nottickedoff">parens (nest 4 (sep (punctuate comma (map loop xs))))</span></span>
<span class="lineno">  237 </span><span class="spaces">   </span><span class="istickedoff">FOVRec xs     -&gt; <span class="nottickedoff">braces (sep (punctuate comma (map ppField (Map.toList xs))))</span></span>
<span class="lineno">  238 </span><span class="spaces">      </span><span class="istickedoff">where <span class="nottickedoff">ppField (f,x) = pretty f &lt;+&gt; pretty '=' &lt;+&gt; loop x</span></span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>-- | The options for JSON-serializing 'FirstOrderType's and 'FirstOrderValue's:
<span class="lineno">  241 </span>-- remove the @FOT@/@FOV@ prefixes and encode the different constructors as
<span class="lineno">  242 </span>-- two-element arrays. Thus, this encoding assumes constructor names and
<span class="lineno">  243 </span>-- argument orders will not change (though the order and number of constructors
<span class="lineno">  244 </span>-- may change).
<span class="lineno">  245 </span>firstOrderJSONOptions :: JSON.Options
<span class="lineno">  246 </span><span class="decl"><span class="istickedoff">firstOrderJSONOptions =</span>
<span class="lineno">  247 </span><span class="spaces">  </span><span class="istickedoff">JSON.defaultOptions { JSON.sumEncoding = JSON.TwoElemArray</span>
<span class="lineno">  248 </span><span class="spaces">                      </span><span class="istickedoff">, JSON.constructorTagModifier = dropFO }</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">where dropFO ('F':'O':tv:cs) | <span class="tickonlytrue">tv `elem` ['T', 'V']</span> = cs</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">dropFO cs = <span class="nottickedoff">cs</span></span></span>
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">FromJSON FirstOrderType</span></span></span></span> where
<span class="lineno">  253 </span>  <span class="decl"><span class="istickedoff">parseJSON = JSON.genericParseJSON firstOrderJSONOptions</span></span>
<span class="lineno">  254 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">FromJSON FirstOrderValue</span></span></span></span> where
<span class="lineno">  255 </span>  <span class="decl"><span class="istickedoff">parseJSON = JSON.genericParseJSON firstOrderJSONOptions</span></span>
<span class="lineno">  256 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">FromJSONKey FirstOrderValue</span></span></span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ToJSON FirstOrderType</span></span></span></span></span></span> where
<span class="lineno">  259 </span>  <span class="decl"><span class="istickedoff">toJSON = JSON.genericToJSON firstOrderJSONOptions</span></span>
<span class="lineno">  260 </span>  <span class="decl"><span class="nottickedoff">toEncoding = JSON.genericToEncoding firstOrderJSONOptions</span></span>
<span class="lineno">  261 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ToJSON FirstOrderValue</span></span></span></span></span></span> where
<span class="lineno">  262 </span>  <span class="decl"><span class="istickedoff">toJSON = JSON.genericToJSON firstOrderJSONOptions</span></span>
<span class="lineno">  263 </span>  <span class="decl"><span class="istickedoff">toEncoding = JSON.genericToEncoding <span class="nottickedoff">firstOrderJSONOptions</span></span></span>
<span class="lineno">  264 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">ToJSONKey FirstOrderValue</span></span></span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>-- | Smart constructor
<span class="lineno">  268 </span>fvVec :: FiniteType -&gt; [FiniteValue] -&gt; FiniteValue
<span class="lineno">  269 </span><span class="decl"><span class="nottickedoff">fvVec t vs =</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="nottickedoff">case (t, traverse toBit vs) of</span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="nottickedoff">(FTBit, Just bs) -&gt; FVWord (fromIntegral (length bs)) (fromBits bs)</span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; FVVec t vs</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  274 </span><span class="spaces">    </span><span class="nottickedoff">toBit :: FiniteValue -&gt; Maybe Bool</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="nottickedoff">toBit (FVBit b) = Just b</span>
<span class="lineno">  276 </span><span class="spaces">    </span><span class="nottickedoff">toBit _ = Nothing</span>
<span class="lineno">  277 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="nottickedoff">fromBits :: [Bool] -&gt; Integer</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="nottickedoff">fromBits = foldl (\n b -&gt; 2*n + if b then 1 else 0) 0</span></span>
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>-- | Smart constructor
<span class="lineno">  282 </span>fovVec :: FirstOrderType -&gt; [FirstOrderValue] -&gt; FirstOrderValue
<span class="lineno">  283 </span><span class="decl"><span class="nottickedoff">fovVec t vs =</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="nottickedoff">case (t, traverse toBit vs) of</span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="nottickedoff">(FOTBit, Just bs) -&gt; FOVWord (fromIntegral (length bs)) (fromBits bs)</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; FOVVec t vs</span>
<span class="lineno">  287 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="nottickedoff">toBit :: FirstOrderValue -&gt; Maybe Bool</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="nottickedoff">toBit (FOVBit b) = Just b</span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="nottickedoff">toBit _ = Nothing</span>
<span class="lineno">  291 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  292 </span><span class="spaces">    </span><span class="nottickedoff">fromBits :: [Bool] -&gt; Integer</span>
<span class="lineno">  293 </span><span class="spaces">    </span><span class="nottickedoff">fromBits = foldl (\n b -&gt; 2*n + if b then 1 else 0) 0</span></span>
<span class="lineno">  294 </span>
<span class="lineno">  295 </span>finiteTypeOf :: FiniteValue -&gt; FiniteType
<span class="lineno">  296 </span><span class="decl"><span class="nottickedoff">finiteTypeOf fv =</span>
<span class="lineno">  297 </span><span class="spaces">  </span><span class="nottickedoff">case fv of</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="nottickedoff">FVBit _    -&gt; FTBit</span>
<span class="lineno">  299 </span><span class="spaces">    </span><span class="nottickedoff">FVWord n _ -&gt; FTVec n FTBit</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="nottickedoff">FVVec t vs -&gt; FTVec (fromIntegral (length vs)) t</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="nottickedoff">FVTuple vs -&gt; FTTuple (map finiteTypeOf vs)</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="nottickedoff">FVRec vm   -&gt; FTRec (fmap finiteTypeOf vm)</span></span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>firstOrderTypeOf :: FirstOrderValue -&gt; FirstOrderType
<span class="lineno">  305 </span><span class="decl"><span class="istickedoff">firstOrderTypeOf fv =</span>
<span class="lineno">  306 </span><span class="spaces">  </span><span class="istickedoff">case fv of</span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">FOVBit _    -&gt; <span class="nottickedoff">FOTBit</span></span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">FOVInt _    -&gt; <span class="nottickedoff">FOTInt</span></span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">FOVIntMod n _ -&gt; <span class="nottickedoff">FOTIntMod n</span></span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">FOVWord n _ -&gt; <span class="nottickedoff">FOTVec n FOTBit</span></span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">FOVVec t vs -&gt; FOTVec <span class="nottickedoff">(fromIntegral (length vs))</span> t</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">FOVArray tk d _vs -&gt; <span class="nottickedoff">FOTArray tk (firstOrderTypeOf d)</span></span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">FOVOpaqueArray tk tv -&gt; <span class="nottickedoff">FOTArray tk tv</span></span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">FOVTuple vs -&gt; FOTTuple (map firstOrderTypeOf vs)</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="istickedoff">FOVRec vm   -&gt; <span class="nottickedoff">FOTRec (fmap firstOrderTypeOf vm)</span></span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- | Compute the number of bits in the type
<span class="lineno">  318 </span>sizeFiniteType :: FiniteType -&gt; Int
<span class="lineno">  319 </span><span class="decl"><span class="nottickedoff">sizeFiniteType x =</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="nottickedoff">case x of</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="nottickedoff">FTBit      -&gt; 1</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="nottickedoff">FTVec n xs -&gt; fromIntegral n * sizeFiniteType xs</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="nottickedoff">FTTuple xs -&gt; sum (map sizeFiniteType xs)</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="nottickedoff">FTRec xm   -&gt; sum (map sizeFiniteType (Map.elems xm))</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>asFiniteType :: SharedContext -&gt; Term -&gt; IO FiniteType
<span class="lineno">  327 </span><span class="decl"><span class="nottickedoff">asFiniteType sc t = do</span>
<span class="lineno">  328 </span><span class="spaces">  </span><span class="nottickedoff">t' &lt;- scWhnf sc t</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="nottickedoff">case t' of</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="nottickedoff">(R.asBoolType -&gt; Just ())</span>
<span class="lineno">  331 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; return FTBit</span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="nottickedoff">(R.isVecType return -&gt; Just (n R.:*: tp))</span>
<span class="lineno">  333 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; FTVec n &lt;$&gt; asFiniteType sc tp</span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="nottickedoff">(R.asTupleType -&gt; Just ts)</span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; FTTuple &lt;$&gt; traverse (asFiniteType sc) ts</span>
<span class="lineno">  336 </span><span class="spaces">    </span><span class="nottickedoff">(R.asRecordType -&gt; Just tm)</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="nottickedoff">-&gt; FTRec &lt;$&gt; traverse (asFiniteType sc) tm</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail $ &quot;asFiniteType: unsupported argument type: &quot; ++ scPrettyTerm PPS.defaultOpts t'</span></span>
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>asFirstOrderType :: SharedContext -&gt; Term -&gt; IO FirstOrderType
<span class="lineno">  341 </span><span class="decl"><span class="nottickedoff">asFirstOrderType sc t = maybe err pure =&lt;&lt; runMaybeT (asFirstOrderTypeMaybe sc t)</span>
<span class="lineno">  342 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="nottickedoff">err =</span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="nottickedoff">do t' &lt;- scWhnf sc t</span>
<span class="lineno">  345 </span><span class="spaces">         </span><span class="nottickedoff">fail (&quot;asFirstOrderType: unsupported argument type: &quot; ++ scPrettyTerm PPS.defaultOpts t')</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>asFirstOrderTypeMaybe :: SharedContext -&gt; Term -&gt; MaybeT IO FirstOrderType
<span class="lineno">  348 </span><span class="decl"><span class="nottickedoff">asFirstOrderTypeMaybe sc t =</span>
<span class="lineno">  349 </span><span class="spaces">  </span><span class="nottickedoff">do t' &lt;- lift (scWhnf sc t)</span>
<span class="lineno">  350 </span><span class="spaces">     </span><span class="nottickedoff">case t' of</span>
<span class="lineno">  351 </span><span class="spaces">       </span><span class="nottickedoff">(R.asBoolType -&gt; Just ())</span>
<span class="lineno">  352 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; return FOTBit</span>
<span class="lineno">  353 </span><span class="spaces">       </span><span class="nottickedoff">(R.asIntegerType -&gt; Just ())</span>
<span class="lineno">  354 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; return FOTInt</span>
<span class="lineno">  355 </span><span class="spaces">       </span><span class="nottickedoff">(R.asIntModType -&gt; Just n)</span>
<span class="lineno">  356 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; return (FOTIntMod n)</span>
<span class="lineno">  357 </span><span class="spaces">       </span><span class="nottickedoff">(R.isVecType return -&gt; Just (n R.:*: tp))</span>
<span class="lineno">  358 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; FOTVec n &lt;$&gt; asFirstOrderTypeMaybe sc tp</span>
<span class="lineno">  359 </span><span class="spaces">       </span><span class="nottickedoff">(R.asArrayType -&gt; Just (tp1 R.:*: tp2)) -&gt; do</span>
<span class="lineno">  360 </span><span class="spaces">         </span><span class="nottickedoff">tp1' &lt;- asFirstOrderTypeMaybe sc tp1</span>
<span class="lineno">  361 </span><span class="spaces">         </span><span class="nottickedoff">tp2' &lt;- asFirstOrderTypeMaybe sc tp2</span>
<span class="lineno">  362 </span><span class="spaces">         </span><span class="nottickedoff">return $ FOTArray tp1' tp2'</span>
<span class="lineno">  363 </span><span class="spaces">       </span><span class="nottickedoff">(R.asTupleType -&gt; Just ts)</span>
<span class="lineno">  364 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; FOTTuple &lt;$&gt; traverse (asFirstOrderTypeMaybe sc) ts</span>
<span class="lineno">  365 </span><span class="spaces">       </span><span class="nottickedoff">(R.asRecordType -&gt; Just tm)</span>
<span class="lineno">  366 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; FOTRec &lt;$&gt; traverse (asFirstOrderTypeMaybe sc) tm</span>
<span class="lineno">  367 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; mzero</span></span>
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>asFiniteTypePure :: Term -&gt; Maybe FiniteType
<span class="lineno">  371 </span><span class="decl"><span class="nottickedoff">asFiniteTypePure t =</span>
<span class="lineno">  372 </span><span class="spaces">  </span><span class="nottickedoff">case t of</span>
<span class="lineno">  373 </span><span class="spaces">    </span><span class="nottickedoff">(R.asBoolType -&gt; Just ()) -&gt; Just FTBit</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="nottickedoff">(R.isVecType return -&gt; Just (n R.:*: tp)) -&gt; FTVec n &lt;$&gt; asFiniteTypePure tp</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="nottickedoff">(R.asTupleType -&gt; Just ts) -&gt; FTTuple &lt;$&gt; traverse asFiniteTypePure ts</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="nottickedoff">(R.asRecordType -&gt; Just tm) -&gt; FTRec &lt;$&gt; traverse asFiniteTypePure tm</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>-- The definitions of the next two functions depend on the encoding of
<span class="lineno">  380 </span>-- tuples that we want to use. Maybe it is better not to include them
<span class="lineno">  381 </span>-- in this library, and we should have them in the SAWScript project
<span class="lineno">  382 </span>-- instead.
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>-- | Convert a finite type to a Term.
<span class="lineno">  385 </span>scFiniteType :: SharedContext -&gt; FiniteType -&gt; IO Term
<span class="lineno">  386 </span><span class="decl"><span class="nottickedoff">scFiniteType sc ft = scFirstOrderType sc (toFirstOrderType ft)</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>-- | Convert a finite type to a Term.
<span class="lineno">  389 </span>scFirstOrderType :: SharedContext -&gt; FirstOrderType -&gt; IO Term
<span class="lineno">  390 </span><span class="decl"><span class="istickedoff">scFirstOrderType sc ft =</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="istickedoff">case ft of</span>
<span class="lineno">  392 </span><span class="spaces">    </span><span class="istickedoff">FOTBit      -&gt; scBoolType sc</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="istickedoff">FOTInt      -&gt; <span class="nottickedoff">scIntegerType sc</span></span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="istickedoff">FOTIntMod n -&gt; <span class="nottickedoff">scIntModType sc =&lt;&lt; scNat sc n</span></span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="istickedoff">FOTVec n t  -&gt; do n' &lt;- scNat sc n</span>
<span class="lineno">  396 </span><span class="spaces">                      </span><span class="istickedoff">t' &lt;- scFirstOrderType sc t</span>
<span class="lineno">  397 </span><span class="spaces">                      </span><span class="istickedoff">scVecType sc n' t'</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="istickedoff">FOTArray t1 t2 -&gt; <span class="nottickedoff">do t1' &lt;- scFirstOrderType sc t1</span></span>
<span class="lineno">  399 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">t2' &lt;- scFirstOrderType sc t2</span></span>
<span class="lineno">  400 </span><span class="spaces">                         </span><span class="istickedoff"><span class="nottickedoff">scArrayType sc t1' t2'</span></span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">FOTTuple ts -&gt; scTupleType sc =&lt;&lt; traverse (scFirstOrderType sc) ts</span>
<span class="lineno">  402 </span><span class="spaces">    </span><span class="istickedoff">FOTRec tm   -&gt;</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">scRecordType sc =&lt;&lt; (Map.assocs &lt;$&gt; traverse (scFirstOrderType sc) tm)</span></span></span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>-- | Convert a finite value to a SharedTerm.
<span class="lineno">  406 </span>scFiniteValue :: SharedContext -&gt; FiniteValue -&gt; IO Term
<span class="lineno">  407 </span><span class="decl"><span class="nottickedoff">scFiniteValue sc fv = scFirstOrderValue sc (toFirstOrderValue fv)</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>-- | Convert a finite value to a SharedTerm.
<span class="lineno">  410 </span>scFirstOrderValue :: SharedContext -&gt; FirstOrderValue -&gt; IO Term
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">scFirstOrderValue sc fv =</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">case fv of</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="istickedoff">FOVBit b    -&gt; scBool sc b</span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">FOVInt i</span>
<span class="lineno">  415 </span><span class="spaces">      </span><span class="istickedoff">| i &gt;= 0  -&gt; scNatToInt sc =&lt;&lt; scNat sc (fromInteger i)</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">True</span>    -&gt; scIntNeg sc =&lt;&lt; scNatToInt sc =&lt;&lt; scNat sc (fromInteger (- i))</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="istickedoff">FOVIntMod 0 i -&gt;</span>
<span class="lineno">  418 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do n' &lt;- scNat sc 0</span></span>
<span class="lineno">  419 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">scToIntMod sc n' =&lt;&lt; scFirstOrderValue sc (FOVInt i)</span></span>
<span class="lineno">  420 </span><span class="spaces">    </span><span class="istickedoff">FOVIntMod n i -&gt;</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do n' &lt;- scNat sc n</span></span>
<span class="lineno">  422 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">i' &lt;- scNatToInt sc =&lt;&lt; scNat sc (fromInteger (i `mod` toInteger n))</span></span>
<span class="lineno">  423 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">scToIntMod sc n' i'</span></span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">FOVWord n x -&gt; scBvConst sc n x</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">FOVVec t vs -&gt; do t' &lt;- scFirstOrderType sc t</span>
<span class="lineno">  426 </span><span class="spaces">                      </span><span class="istickedoff">vs' &lt;- traverse (scFirstOrderValue sc) vs</span>
<span class="lineno">  427 </span><span class="spaces">                      </span><span class="istickedoff">scVector sc t' vs'</span>
<span class="lineno">  428 </span><span class="spaces">    </span><span class="istickedoff">FOVArray tk d vs -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  429 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- first get the key and value types</span></span>
<span class="lineno">  430 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">tk' &lt;- scFirstOrderType sc tk</span></span>
<span class="lineno">  431 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">tv' &lt;- scFirstOrderType sc $ firstOrderTypeOf d</span></span>
<span class="lineno">  432 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- convert the default value and make an array</span></span>
<span class="lineno">  433 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">d' &lt;- scFirstOrderValue sc d</span></span>
<span class="lineno">  434 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">arr0 &lt;- scArrayConstant sc tk' tv' d'</span></span>
<span class="lineno">  435 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- now add each update to the array (monadic fold)</span></span>
<span class="lineno">  436 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">let visit k v arr = do</span></span>
<span class="lineno">  437 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">k' &lt;- scFirstOrderValue sc k</span></span>
<span class="lineno">  438 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">v' &lt;- scFirstOrderValue sc v</span></span>
<span class="lineno">  439 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">scArrayUpdate sc tk' tv' arr k' v'</span></span>
<span class="lineno">  440 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ifoldrM visit arr0 vs</span></span>
<span class="lineno">  441 </span><span class="spaces">    </span><span class="istickedoff">FOVOpaqueArray _tk _tv -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Cannot convert opaque array to SharedTerm&quot;</span></span>
<span class="lineno">  443 </span><span class="spaces">    </span><span class="istickedoff">FOVTuple vs -&gt; scTuple sc =&lt;&lt; traverse (scFirstOrderValue sc) vs</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">FOVRec vm   -&gt; <span class="nottickedoff">scRecord sc =&lt;&lt; traverse (scFirstOrderValue sc) vm</span></span></span>
<span class="lineno">  445 </span>
<span class="lineno">  446 </span>-- Parsing values from lists of booleans ---------------------------------------
<span class="lineno">  447 </span>
<span class="lineno">  448 </span>data Endianness
<span class="lineno">  449 </span>  = BigEndian
<span class="lineno">  450 </span>  | LittleEndian
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>readFiniteValue' :: Endianness -&gt; FiniteType -&gt; S.StateT [Bool] Maybe FiniteValue
<span class="lineno">  453 </span><span class="decl"><span class="nottickedoff">readFiniteValue' en ft =</span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="nottickedoff">case ft of</span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="nottickedoff">FTBit      -&gt; do bs &lt;- S.get</span>
<span class="lineno">  456 </span><span class="spaces">                     </span><span class="nottickedoff">case bs of</span>
<span class="lineno">  457 </span><span class="spaces">                       </span><span class="nottickedoff">[]      -&gt; S.lift Nothing</span>
<span class="lineno">  458 </span><span class="spaces">                       </span><span class="nottickedoff">b : bs' -&gt; S.put bs' &gt;&gt; return (FVBit b)</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="nottickedoff">FTVec n t  -&gt; (fvVec t . fixup) &lt;$&gt; replicateM (fromIntegral n) (readFiniteValue' en t)</span>
<span class="lineno">  460 </span><span class="spaces">                    </span><span class="nottickedoff">where fixup = case (t, en) of</span>
<span class="lineno">  461 </span><span class="spaces">                                    </span><span class="nottickedoff">(FTBit, LittleEndian) -&gt; reverse</span>
<span class="lineno">  462 </span><span class="spaces">                                    </span><span class="nottickedoff">_ -&gt; id</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="nottickedoff">FTTuple ts -&gt; FVTuple &lt;$&gt; traverse (readFiniteValue' en) ts</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="nottickedoff">FTRec tm   -&gt; FVRec &lt;$&gt; traverse (readFiniteValue' en) tm</span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>readFiniteValues :: [FiniteType] -&gt; [Bool] -&gt; Maybe [FiniteValue]
<span class="lineno">  467 </span><span class="decl"><span class="nottickedoff">readFiniteValues ts bs = do</span>
<span class="lineno">  468 </span><span class="spaces">  </span><span class="nottickedoff">(vs, rest) &lt;- S.runStateT (traverse (readFiniteValue' BigEndian) ts) bs</span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="nottickedoff">case rest of</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; return vs</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>readFiniteValuesLE :: [FiniteType] -&gt; [Bool] -&gt; Maybe [FiniteValue]
<span class="lineno">  474 </span><span class="decl"><span class="nottickedoff">readFiniteValuesLE ts bs = do</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="nottickedoff">(vs, rest) &lt;- S.runStateT (traverse (readFiniteValue' LittleEndian) ts) bs</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="nottickedoff">case rest of</span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; return vs</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  479 </span>
<span class="lineno">  480 </span>readFiniteValue :: FiniteType -&gt; [Bool] -&gt; Maybe FiniteValue
<span class="lineno">  481 </span><span class="decl"><span class="nottickedoff">readFiniteValue t bs = do</span>
<span class="lineno">  482 </span><span class="spaces">  </span><span class="nottickedoff">(v, rest) &lt;- S.runStateT (readFiniteValue' BigEndian t) bs</span>
<span class="lineno">  483 </span><span class="spaces">  </span><span class="nottickedoff">case rest of</span>
<span class="lineno">  484 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt; return v</span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>

</pre>
</body>
</html>
