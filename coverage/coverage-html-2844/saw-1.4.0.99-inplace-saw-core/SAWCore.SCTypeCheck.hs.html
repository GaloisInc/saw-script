<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    2 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    3 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    4 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>{- |
<span class="lineno">    7 </span>Module      : SAWCore.SCTypeCheck
<span class="lineno">    8 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    9 </span>License     : BSD3
<span class="lineno">   10 </span>Maintainer  : jhendrix@galois.com
<span class="lineno">   11 </span>Stability   : experimental
<span class="lineno">   12 </span>Portability : non-portable (language extensions)
<span class="lineno">   13 </span>-}
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>module SAWCore.SCTypeCheck
<span class="lineno">   16 </span>  ( scConvertible
<span class="lineno">   17 </span>  , TCError(..)
<span class="lineno">   18 </span>  , prettyTCError
<span class="lineno">   19 </span>  , throwTCError
<span class="lineno">   20 </span>  , TCM
<span class="lineno">   21 </span>  , runTCM
<span class="lineno">   22 </span>  , rethrowTCError
<span class="lineno">   23 </span>  , withErrorUTerm
<span class="lineno">   24 </span>  , atPos
<span class="lineno">   25 </span>  , LiftTCM(..)
<span class="lineno">   26 </span>  , inferTermF
<span class="lineno">   27 </span>  , inferFlatTermF
<span class="lineno">   28 </span>  , typeCheckWHNF
<span class="lineno">   29 </span>  , checkSubtype
<span class="lineno">   30 </span>  , ensureSort
<span class="lineno">   31 </span>  , ensureSortType
<span class="lineno">   32 </span>  , applyPiTyped
<span class="lineno">   33 </span>  , compileRecursor
<span class="lineno">   34 </span>  ) where
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>import Control.Applicative
<span class="lineno">   37 </span>import Control.Monad (forM_, mapM, unless, void)
<span class="lineno">   38 </span>import Control.Monad.Except (MonadError(..), ExceptT, runExceptT)
<span class="lineno">   39 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   40 </span>import Control.Monad.Reader (MonadReader(..), Reader, ReaderT(..), runReader)
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   43 </span>import Data.Map (Map)
<span class="lineno">   44 </span>import qualified Data.Map as Map
<span class="lineno">   45 </span>import Data.Text (Text)
<span class="lineno">   46 </span>import qualified Data.Text as Text
<span class="lineno">   47 </span>import qualified Data.Vector as V
<span class="lineno">   48 </span>import Prelude hiding (mapM, maximum)
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts, render)
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>import SAWCore.Module
<span class="lineno">   53 </span>  ( ctorName
<span class="lineno">   54 </span>  , dtName
<span class="lineno">   55 </span>  , lookupVarIndexInMap
<span class="lineno">   56 </span>  , Ctor(..)
<span class="lineno">   57 </span>  , DataType(..)
<span class="lineno">   58 </span>  , ResolvedName(..)
<span class="lineno">   59 </span>  )
<span class="lineno">   60 </span>import SAWCore.Name
<span class="lineno">   61 </span>import SAWCore.Parser.AST (UTerm, prettyUTerm)
<span class="lineno">   62 </span>import SAWCore.Parser.Position
<span class="lineno">   63 </span>import SAWCore.Recognizer
<span class="lineno">   64 </span>import SAWCore.SharedTerm
<span class="lineno">   65 </span>import SAWCore.Term.Certified (scRecordValue)
<span class="lineno">   66 </span>import SAWCore.Term.Functor
<span class="lineno">   67 </span>import SAWCore.Term.Pretty (scPrettyTermInCtx)
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>-- | The 'ReaderT' environment for a type-checking computation.
<span class="lineno">   70 </span>type TCEnv = SharedContext
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>-- | The monad for type checking and inference, which:
<span class="lineno">   73 </span>--
<span class="lineno">   74 </span>-- * Maintains a 'SharedContext';
<span class="lineno">   75 </span>--
<span class="lineno">   76 </span>-- * Can throw 'TCError's
<span class="lineno">   77 </span>newtype TCM a = TCM (ReaderT TCEnv (ExceptT TCError IO) a)
<span class="lineno">   78 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">MonadFail</span></span>, <span class="decl"><span class="istickedoff">MonadIO</span></span>,
<span class="lineno">   79 </span>            <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadReader TCEnv</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">MonadError TCError</span></span></span></span>)
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-- | Run a type-checking computation in a given context, starting from the empty
<span class="lineno">   82 </span>-- memoization table
<span class="lineno">   83 </span>runTCM ::
<span class="lineno">   84 </span>  TCM a -&gt; SharedContext -&gt; IO (Either TCError a)
<span class="lineno">   85 </span><span class="decl"><span class="istickedoff">runTCM (TCM m) sc =</span>
<span class="lineno">   86 </span><span class="spaces">  </span><span class="istickedoff">runExceptT $ runReaderT m sc</span></span>
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>-- | Augment and rethrow any 'TCError' thrown by the given computation.
<span class="lineno">   89 </span>rethrowTCError :: (MonadError TCError m) =&gt; (TCError -&gt; TCError) -&gt; m a -&gt; m a
<span class="lineno">   90 </span><span class="decl"><span class="istickedoff">rethrowTCError f m = catchError m (throwError . f)</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>-- | Run a type-checking computation @m@ and tag any error it throws with the
<span class="lineno">   93 </span>-- 'ErrorUTerm' constructor
<span class="lineno">   94 </span>withErrorUTerm :: MonadError TCError m =&gt; UTerm -&gt; m a -&gt; m a
<span class="lineno">   95 </span><span class="decl"><span class="istickedoff">withErrorUTerm t = rethrowTCError (ErrorUTerm t)</span></span>
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- | Run a type-checking computation @m@ and tag any error it throws with the
<span class="lineno">   98 </span>-- given position, using the 'ErrorPos' constructor, unless that error is
<span class="lineno">   99 </span>-- already tagged with a position
<span class="lineno">  100 </span>atPos :: (MonadError TCError m) =&gt; Pos -&gt; m a -&gt; m a
<span class="lineno">  101 </span><span class="decl"><span class="istickedoff">atPos p = rethrowTCError (ErrorPos p)</span></span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>-- | Typeclass for lifting 'IO' computations that take a 'SharedContext' to
<span class="lineno">  104 </span>-- 'TCM' computations
<span class="lineno">  105 </span>class LiftTCM a where
<span class="lineno">  106 </span>  type TCMLifted a
<span class="lineno">  107 </span>  liftTCM :: (SharedContext -&gt; a) -&gt; TCMLifted a
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>instance LiftTCM (IO a) where
<span class="lineno">  110 </span>  type TCMLifted (IO a) = TCM a
<span class="lineno">  111 </span>  <span class="decl"><span class="istickedoff">liftTCM f =</span>
<span class="lineno">  112 </span><span class="spaces">    </span><span class="istickedoff">do sc &lt;- ask</span>
<span class="lineno">  113 </span><span class="spaces">       </span><span class="istickedoff">liftIO (f sc)</span></span>
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>instance LiftTCM b =&gt; LiftTCM (a -&gt; b) where
<span class="lineno">  116 </span>  type TCMLifted (a -&gt; b) = a -&gt; TCMLifted b
<span class="lineno">  117 </span>  <span class="decl"><span class="istickedoff">liftTCM f a = liftTCM (\sc -&gt; f sc a)</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>-- | Errors that can occur during type-checking
<span class="lineno">  120 </span>data TCError
<span class="lineno">  121 </span>  = NotSort Term
<span class="lineno">  122 </span>  | NotFuncTypeInApp Term Term
<span class="lineno">  123 </span>  | NotTupleType Term
<span class="lineno">  124 </span>  | BadTupleIndex Int Term
<span class="lineno">  125 </span>  | NotRecordType Term
<span class="lineno">  126 </span>  | BadRecordField FieldName Term
<span class="lineno">  127 </span>  | UnboundName Text
<span class="lineno">  128 </span>  | SubtypeFailure Term Term
<span class="lineno">  129 </span>  | EmptyVectorLit
<span class="lineno">  130 </span>  | NoSuchDataType NameInfo
<span class="lineno">  131 </span>  | NoSuchConstant NameInfo
<span class="lineno">  132 </span>  | MalformedRecursor NameInfo Sort String
<span class="lineno">  133 </span>  | DeclError Text String
<span class="lineno">  134 </span>  | ErrorPos Pos TCError
<span class="lineno">  135 </span>  | ErrorTerm Term TCError
<span class="lineno">  136 </span>  | ErrorUTerm UTerm TCError
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>-- | Throw a type-checking error
<span class="lineno">  140 </span>throwTCError :: (MonadError TCError m) =&gt; TCError -&gt; m a
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">throwTCError e = throwError e</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>type PPErrM = Reader (Maybe Pos)
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>-- | Pretty-print a type-checking error
<span class="lineno">  146 </span>prettyTCError :: TCError -&gt; [String]
<span class="lineno">  147 </span><span class="decl"><span class="istickedoff">prettyTCError e = runReader (helper e) <span class="nottickedoff">Nothing</span> where</span>
<span class="lineno">  148 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  149 </span><span class="spaces">  </span><span class="istickedoff">ppWithPos :: [PPErrM String] -&gt; PPErrM [String]</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="istickedoff">ppWithPos str_ms =</span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="istickedoff">do strs &lt;- mapM id str_ms</span>
<span class="lineno">  152 </span><span class="spaces">       </span><span class="istickedoff">maybe_p &lt;- ask</span>
<span class="lineno">  153 </span><span class="spaces">       </span><span class="istickedoff">case maybe_p of</span>
<span class="lineno">  154 </span><span class="spaces">         </span><span class="istickedoff">Just p -&gt; return (ppPos p : strs)</span>
<span class="lineno">  155 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return strs</span></span>
<span class="lineno">  156 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  157 </span><span class="spaces">  </span><span class="istickedoff">helper :: TCError -&gt; PPErrM [String]</span>
<span class="lineno">  158 </span><span class="spaces">  </span><span class="istickedoff">helper (NotSort ty) = ppWithPos [ return &quot;Not a sort&quot; , ishow ty ]</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">helper (NotFuncTypeInApp f arg) =</span>
<span class="lineno">  160 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Function application with non-function type&quot;</span>
<span class="lineno">  161 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;For term:&quot;</span>
<span class="lineno">  162 </span><span class="spaces">                </span><span class="istickedoff">, ishow f</span>
<span class="lineno">  163 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;With type:&quot;</span>
<span class="lineno">  164 </span><span class="spaces">                </span><span class="istickedoff">, tyshow f</span>
<span class="lineno">  165 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;To argument:&quot;</span>
<span class="lineno">  166 </span><span class="spaces">                </span><span class="istickedoff">, ishow arg ]</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="istickedoff">helper (NotTupleType ty) =</span>
<span class="lineno">  168 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Tuple field projection with non-tuple type&quot; ,</span>
<span class="lineno">  169 </span><span class="spaces">                  </span><span class="istickedoff">ishow ty ]</span>
<span class="lineno">  170 </span><span class="spaces">  </span><span class="istickedoff">helper (BadTupleIndex n ty) =</span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;Bad tuple index (&quot; ++ show n ++ &quot;) for type&quot;)</span></span>
<span class="lineno">  172 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, ishow ty ]</span></span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">helper (NotRecordType t) =</span>
<span class="lineno">  174 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Record field projection with non-record type&quot;</span>
<span class="lineno">  175 </span><span class="spaces">                </span><span class="istickedoff">, tyshow t</span>
<span class="lineno">  176 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;In term:&quot;</span>
<span class="lineno">  177 </span><span class="spaces">                </span><span class="istickedoff">, ishow t ]</span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="istickedoff">helper (BadRecordField n ty) =</span>
<span class="lineno">  179 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return (&quot;Bad record field (&quot; ++ show n ++ &quot;) for type&quot;)</span>
<span class="lineno">  180 </span><span class="spaces">                </span><span class="istickedoff">, ishow ty ]</span>
<span class="lineno">  181 </span><span class="spaces">  </span><span class="istickedoff">helper (UnboundName str) = ppWithPos [ return (&quot;Unbound name: &quot; ++ show str)]</span>
<span class="lineno">  182 </span><span class="spaces">  </span><span class="istickedoff">helper (SubtypeFailure trm tp2) =</span>
<span class="lineno">  183 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Inferred type&quot;, tyshow trm,</span>
<span class="lineno">  184 </span><span class="spaces">                  </span><span class="istickedoff">return &quot;Not a subtype of expected type&quot;, ishow tp2,</span>
<span class="lineno">  185 </span><span class="spaces">                  </span><span class="istickedoff">return &quot;For term&quot;, ishow trm ]</span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">helper EmptyVectorLit = ppWithPos [ return &quot;Empty vector literal&quot;]</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="istickedoff">helper (NoSuchDataType d) =</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">ppWithPos [ return (&quot;No such data type: &quot; ++ show d)]</span>
<span class="lineno">  189 </span><span class="spaces">  </span><span class="istickedoff">helper (NoSuchConstant c) =</span>
<span class="lineno">  190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;No such constant: &quot; ++ show c) ]</span></span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">helper (MalformedRecursor d s reason) =</span>
<span class="lineno">  192 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Malformed recursor&quot;,</span>
<span class="lineno">  193 </span><span class="spaces">                  </span><span class="istickedoff">pure (indent &quot;  &quot; (Text.unpack (toAbsoluteName d) ++ sortSuffix s)),</span>
<span class="lineno">  194 </span><span class="spaces">                  </span><span class="istickedoff">pure reason ]</span>
<span class="lineno">  195 </span><span class="spaces">  </span><span class="istickedoff">helper (DeclError nm reason) =</span>
<span class="lineno">  196 </span><span class="spaces">    </span><span class="istickedoff">ppWithPos [ return (&quot;Malformed declaration for &quot; ++ show nm), return reason ]</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">helper (ErrorPos p err) =</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">local (\_ -&gt; Just p) $ helper err</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">helper (ErrorTerm tm err) = <span class="nottickedoff">do</span></span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">info &lt;- ppWithPos [ return (&quot;While typechecking term:&quot;)</span></span>
<span class="lineno">  201 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">, ishow tm ]</span></span>
<span class="lineno">  202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">cont &lt;- helper err</span></span>
<span class="lineno">  203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">return (info ++ cont)</span></span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff">helper (ErrorUTerm t err) =</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">do info &lt;-</span>
<span class="lineno">  206 </span><span class="spaces">         </span><span class="istickedoff">ppWithPos</span>
<span class="lineno">  207 </span><span class="spaces">         </span><span class="istickedoff">[ pure (&quot;While typechecking term:&quot;)</span>
<span class="lineno">  208 </span><span class="spaces">         </span><span class="istickedoff">, pure $ indent &quot;  &quot; $ PPS.render PPS.defaultOpts (prettyUTerm t)</span>
<span class="lineno">  209 </span><span class="spaces">         </span><span class="istickedoff">]</span>
<span class="lineno">  210 </span><span class="spaces">       </span><span class="istickedoff">cont &lt;- helper err</span>
<span class="lineno">  211 </span><span class="spaces">       </span><span class="istickedoff">pure (info ++ cont)</span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="istickedoff">-- | Add prefix to every line, but remove final trailing newline</span>
<span class="lineno">  214 </span><span class="spaces">  </span><span class="istickedoff">indent :: String -&gt; String -&gt; String</span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="istickedoff">indent prefix s = init (unlines (map (prefix ++) (lines s)))</span>
<span class="lineno">  216 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  217 </span><span class="spaces">  </span><span class="istickedoff">ishow :: Term -&gt; PPErrM String</span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">ishow tm =</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff">-- return $ show tm</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">pure $ indent &quot;  &quot; $ scPrettyTermInCtx PPS.defaultOpts [] tm</span>
<span class="lineno">  221 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="istickedoff">tyshow :: Term -&gt; PPErrM String</span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff">tyshow t =</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">case termSortOrType t of</span>
<span class="lineno">  225 </span><span class="spaces">      </span><span class="istickedoff">Left s -&gt;</span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">pure $ indent &quot;  &quot; $ show s</span></span>
<span class="lineno">  227 </span><span class="spaces">      </span><span class="istickedoff">Right tm -&gt;</span>
<span class="lineno">  228 </span><span class="spaces">        </span><span class="istickedoff">pure $ indent &quot;  &quot; $ scPrettyTermInCtx PPS.defaultOpts [] tm</span>
<span class="lineno">  229 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  230 </span><span class="spaces">  </span><span class="istickedoff">sortSuffix :: Sort -&gt; String</span>
<span class="lineno">  231 </span><span class="spaces">  </span><span class="istickedoff">sortSuffix s =</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">case s of</span>
<span class="lineno">  233 </span><span class="spaces">      </span><span class="istickedoff">TypeSort 0 -&gt; &quot;#rec&quot;</span>
<span class="lineno">  234 </span><span class="spaces">      </span><span class="istickedoff">TypeSort n -&gt; <span class="nottickedoff">&quot;#rec&quot; ++ show n</span></span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="istickedoff">PropSort -&gt; <span class="nottickedoff">&quot;#ind&quot;</span></span></span>
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show TCError</span></span></span></span> where
<span class="lineno">  238 </span>  <span class="decl"><span class="nottickedoff">show = unlines . prettyTCError</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>-- | Construct a typed term from a 'TermF' where each subterm has
<span class="lineno">  241 </span>-- already been labeled with its type.
<span class="lineno">  242 </span>inferTermF :: TermF Term -&gt; TCM Term
<span class="lineno">  243 </span><span class="decl"><span class="istickedoff">inferTermF tf =</span>
<span class="lineno">  244 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno">  246 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">inferFlatTermF ftf</span></span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno">  248 </span><span class="spaces">      </span><span class="istickedoff">do let err = NotFuncTypeInApp t1 t2</span>
<span class="lineno">  249 </span><span class="spaces">         </span><span class="istickedoff">ty1 &lt;- liftTCM scTypeOf t1</span>
<span class="lineno">  250 </span><span class="spaces">         </span><span class="istickedoff">(_nm, arg_tp, _ret_tp) &lt;- ensurePiType err ty1</span>
<span class="lineno">  251 </span><span class="spaces">         </span><span class="istickedoff">checkSubtype t2 arg_tp</span>
<span class="lineno">  252 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scApply t1 t2</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno">  254 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSortType t1</span>
<span class="lineno">  255 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scLambda x t1 t2</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno">  257 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSortType t1</span>
<span class="lineno">  258 </span><span class="spaces">         </span><span class="istickedoff">void $ ensureSortType t2</span>
<span class="lineno">  259 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scPi x t1 t2</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">Constant nm -&gt;</span>
<span class="lineno">  261 </span><span class="spaces">      </span><span class="istickedoff">do mm &lt;- liftTCM scGetModuleMap</span>
<span class="lineno">  262 </span><span class="spaces">         </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  263 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwTCError $ NoSuchConstant (nameInfo nm)</span></span>
<span class="lineno">  264 </span><span class="spaces">           </span><span class="istickedoff">Just _ -&gt; liftTCM scConst nm</span>
<span class="lineno">  265 </span><span class="spaces">    </span><span class="istickedoff">Variable vn tp -&gt;</span>
<span class="lineno">  266 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scVariable vn tp</span></span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>-- | Construct a typed term from a 'FlatTermF' where each subterm has
<span class="lineno">  269 </span>-- already been labeled with its type.
<span class="lineno">  270 </span>inferFlatTermF :: FlatTermF Term -&gt; TCM Term
<span class="lineno">  271 </span><span class="decl"><span class="istickedoff">inferFlatTermF ftf =</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">UnitValue -&gt;</span>
<span class="lineno">  274 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scUnitValue</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff">UnitType -&gt;</span>
<span class="lineno">  276 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scUnitType</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">PairValue t1 t2 -&gt;</span>
<span class="lineno">  278 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scPairValue t1 t2</span>
<span class="lineno">  279 </span><span class="spaces">    </span><span class="istickedoff">PairType t1 t2 -&gt;</span>
<span class="lineno">  280 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSortType t1</span>
<span class="lineno">  281 </span><span class="spaces">         </span><span class="istickedoff">void $ ensureSortType t2</span>
<span class="lineno">  282 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scPairType t1 t2</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">PairLeft t -&gt;</span>
<span class="lineno">  284 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensurePairType =&lt;&lt; liftTCM scTypeOf t</span>
<span class="lineno">  285 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scPairLeft t</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">PairRight t -&gt;</span>
<span class="lineno">  287 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensurePairType =&lt;&lt; liftTCM scTypeOf t</span>
<span class="lineno">  288 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scPairRight t</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">Recursor r -&gt;</span>
<span class="lineno">  290 </span><span class="spaces">      </span><span class="istickedoff">do mm &lt;- liftTCM scGetModuleMap</span>
<span class="lineno">  291 </span><span class="spaces">         </span><span class="istickedoff">let d = recursorDataType r</span>
<span class="lineno">  292 </span><span class="spaces">         </span><span class="istickedoff">let s = recursorSort r</span>
<span class="lineno">  293 </span><span class="spaces">         </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex d) mm of</span>
<span class="lineno">  294 </span><span class="spaces">           </span><span class="istickedoff">Just (ResolvedDataType _dt) -&gt; liftTCM scRecursor d s</span>
<span class="lineno">  295 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwTCError $ NoSuchDataType (nameInfo d)</span></span>
<span class="lineno">  296 </span><span class="spaces">    </span><span class="istickedoff">RecordType elems -&gt;</span>
<span class="lineno">  297 </span><span class="spaces">      </span><span class="istickedoff">do void $ mapM (ensureSortType . snd) elems</span>
<span class="lineno">  298 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scRecordType elems</span>
<span class="lineno">  299 </span><span class="spaces">    </span><span class="istickedoff">RecordValue elems -&gt;</span>
<span class="lineno">  300 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scRecordValue elems</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">RecordProj t fld -&gt;</span>
<span class="lineno">  302 </span><span class="spaces">      </span><span class="istickedoff">do ty &lt;- liftTCM scTypeOf t</span>
<span class="lineno">  303 </span><span class="spaces">         </span><span class="istickedoff">ts &lt;- ensureRecordType (NotRecordType t) ty</span>
<span class="lineno">  304 </span><span class="spaces">         </span><span class="istickedoff">unless (Map.member fld ts) $</span>
<span class="lineno">  305 </span><span class="spaces">           </span><span class="istickedoff">throwTCError $ BadRecordField fld ty</span>
<span class="lineno">  306 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scRecordSelect t fld</span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">Sort s flags -&gt;</span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scSortWithFlags s flags</span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue tp vs -&gt;</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSortType tp</span>
<span class="lineno">  311 </span><span class="spaces">         </span><span class="istickedoff">tp' &lt;- typeCheckWHNF tp</span>
<span class="lineno">  312 </span><span class="spaces">         </span><span class="istickedoff">forM_ vs $ \v_elem -&gt; checkSubtype v_elem tp'</span>
<span class="lineno">  313 </span><span class="spaces">         </span><span class="istickedoff">liftTCM scVector tp (V.toList vs)</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">StringLit s -&gt;</span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="istickedoff">liftTCM scString s</span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- | Check that @fun_tp=Pi x a b@ and that @arg@ has type @a@, and return the
<span class="lineno">  318 </span>-- result of substituting @arg@ for @x@ in the result type @b@, i.e.,
<span class="lineno">  319 </span>-- @[arg/x]b@.
<span class="lineno">  320 </span>-- If @fun_tp@ is not a pi type, raise the supplied error.
<span class="lineno">  321 </span>applyPiTyped :: TCError -&gt; Term -&gt; Term -&gt; TCM Term
<span class="lineno">  322 </span><span class="decl"><span class="istickedoff">applyPiTyped err fun_tp arg =</span>
<span class="lineno">  323 </span><span class="spaces">  </span><span class="istickedoff">ensurePiType <span class="nottickedoff">err</span> fun_tp &gt;&gt;= \(nm, arg_tp, ret_tp) -&gt;</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="istickedoff">do checkSubtype arg arg_tp</span>
<span class="lineno">  325 </span><span class="spaces">     </span><span class="istickedoff">let sub = IntMap.singleton (vnIndex nm) arg</span>
<span class="lineno">  326 </span><span class="spaces">     </span><span class="istickedoff">liftTCM scInstantiate sub ret_tp</span></span>
<span class="lineno">  327 </span>
<span class="lineno">  328 </span>-- | Ensure that a 'Term' matches a recognizer function, normalizing if
<span class="lineno">  329 </span>-- necessary; otherwise throw the supplied 'TCError'
<span class="lineno">  330 </span>ensureRecognizer :: Recognizer Term a -&gt; TCError -&gt; Term -&gt; TCM a
<span class="lineno">  331 </span><span class="decl"><span class="istickedoff">ensureRecognizer f _ (f -&gt; Just a) = return a</span>
<span class="lineno">  332 </span><span class="spaces"></span><span class="istickedoff">ensureRecognizer f err trm =</span>
<span class="lineno">  333 </span><span class="spaces">  </span><span class="istickedoff">typeCheckWHNF trm &gt;&gt;= \case</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="istickedoff">(f -&gt; Just a) -&gt; return a</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; throwTCError err</span></span>
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>-- | Ensure the type of a 'Term' is a sort, and return that sort.
<span class="lineno">  338 </span>ensureSortType :: Term -&gt; TCM Sort
<span class="lineno">  339 </span><span class="decl"><span class="istickedoff">ensureSortType t = either pure ensureSort (termSortOrType t)</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>-- | Ensure a 'Term' is a sort, normalizing if necessary, and return that sort
<span class="lineno">  342 </span>ensureSort :: Term -&gt; TCM Sort
<span class="lineno">  343 </span><span class="decl"><span class="istickedoff">ensureSort tp = ensureRecognizer asSort (NotSort tp) tp</span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>-- | Ensure a 'Term' is a pair type, normalizing if necessary, and return the
<span class="lineno">  346 </span>-- two components of that pair type
<span class="lineno">  347 </span>ensurePairType :: Term -&gt; TCM (Term, Term)
<span class="lineno">  348 </span><span class="decl"><span class="istickedoff">ensurePairType tp = ensureRecognizer asPairType (NotTupleType tp) tp</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>-- | Ensure a 'Term' is a record type, normalizing if necessary, and return the
<span class="lineno">  351 </span>-- components of that record type
<span class="lineno">  352 </span>ensureRecordType :: TCError -&gt; Term -&gt; TCM (Map FieldName Term)
<span class="lineno">  353 </span><span class="decl"><span class="istickedoff">ensureRecordType err tp = ensureRecognizer asRecordType err tp</span></span>
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>-- | Ensure a 'Term' is a pi type, normalizing if necessary. Return the
<span class="lineno">  356 </span>-- components of that pi type on success; otherwise throw the supplied error.
<span class="lineno">  357 </span>ensurePiType :: TCError -&gt; Term -&gt; TCM (VarName, Term, Term)
<span class="lineno">  358 </span><span class="decl"><span class="istickedoff">ensurePiType err tp = ensureRecognizer asPi err tp</span></span>
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>-- | Reduce a type to weak head-normal form (using 'scWhnf').
<span class="lineno">  361 </span>typeCheckWHNF :: Term -&gt; TCM Term
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff">typeCheckWHNF = liftTCM scWhnf</span></span>
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>-- | Check that one type is a subtype of another, assuming both arguments are
<span class="lineno">  365 </span>-- types, i.e., that both have type Sort s for some s.
<span class="lineno">  366 </span>checkSubtype :: Term -&gt; Term -&gt; TCM ()
<span class="lineno">  367 </span><span class="decl"><span class="istickedoff">checkSubtype arg req_tp =</span>
<span class="lineno">  368 </span><span class="spaces">  </span><span class="istickedoff">do arg_tp' &lt;- liftTCM scWhnf =&lt;&lt; liftTCM scTypeOf arg</span>
<span class="lineno">  369 </span><span class="spaces">     </span><span class="istickedoff">req_tp' &lt;- liftTCM scWhnf req_tp</span>
<span class="lineno">  370 </span><span class="spaces">     </span><span class="istickedoff">ok &lt;- isSubtype arg_tp' req_tp'</span>
<span class="lineno">  371 </span><span class="spaces">     </span><span class="istickedoff">if ok then return <span class="nottickedoff">()</span> else throwTCError $ SubtypeFailure arg req_tp</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | Check if one type is a subtype of another, assuming both arguments are
<span class="lineno">  374 </span>-- types, i.e., that both have type Sort s for some s, and that they are both
<span class="lineno">  375 </span>-- already in WHNF
<span class="lineno">  376 </span>isSubtype :: Term -&gt; Term -&gt; TCM Bool
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">isSubtype (unwrapTermF -&gt; Pi x1 a1 b1) (unwrapTermF -&gt; Pi x2 a2 b2)</span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">| x1 == x2 =</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">(&amp;&amp;) &lt;$&gt; areConvertible a1 a2 &lt;*&gt; isSubtype b1 b2</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">do conv1 &lt;- areConvertible a1 a2</span>
<span class="lineno">  382 </span><span class="spaces">       </span><span class="istickedoff">var1 &lt;- liftTCM scVariable x1 a1</span>
<span class="lineno">  383 </span><span class="spaces">       </span><span class="istickedoff">let sub = IntMap.singleton (vnIndex x2) var1</span>
<span class="lineno">  384 </span><span class="spaces">       </span><span class="istickedoff">b2' &lt;- liftTCM scInstantiate sub b2</span>
<span class="lineno">  385 </span><span class="spaces">       </span><span class="istickedoff">conv2 &lt;- isSubtype b1 b2'</span>
<span class="lineno">  386 </span><span class="spaces">       </span><span class="istickedoff">pure (conv1 &amp;&amp; conv2)</span>
<span class="lineno">  387 </span><span class="spaces"></span><span class="istickedoff">isSubtype (asSort -&gt; Just s1) (asSort -&gt; Just s2) | <span class="tickonlytrue">s1 &lt;= s2</span> = return True</span>
<span class="lineno">  388 </span><span class="spaces"></span><span class="istickedoff">isSubtype t1' t2' = areConvertible t1' t2'</span></span>
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>-- | Check if two terms are &quot;convertible for type-checking&quot;, meaning that they
<span class="lineno">  391 </span>-- are convertible up to the reductions performed by 'scWhnf'.
<span class="lineno">  392 </span>areConvertible :: Term -&gt; Term -&gt; TCM Bool
<span class="lineno">  393 </span><span class="decl"><span class="istickedoff">areConvertible t1 t2 = liftTCM scConvertibleEval scWhnf True t1 t2</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>
<span class="lineno">  396 </span>compileRecursor ::
<span class="lineno">  397 </span>  DataType -&gt;
<span class="lineno">  398 </span>  Sort          {- ^ elimination sort -} -&gt;
<span class="lineno">  399 </span>  TCM CompiledRecursor
<span class="lineno">  400 </span><span class="decl"><span class="istickedoff">compileRecursor dt s =</span>
<span class="lineno">  401 </span><span class="spaces">  </span><span class="istickedoff">do let d = dtName dt</span>
<span class="lineno">  402 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nparams = length (dtParams dt)</span></span>
<span class="lineno">  403 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">nixs = length (dtIndices dt)</span></span>
<span class="lineno">  404 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">ctorOrder = map ctorName (dtCtors dt)</span></span>
<span class="lineno">  405 </span><span class="spaces">     </span><span class="istickedoff">let crec = CompiledRecursor d s <span class="nottickedoff">nparams</span> <span class="nottickedoff">nixs</span> <span class="nottickedoff">ctorOrder</span></span>
<span class="lineno">  406 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  407 </span><span class="spaces">     </span><span class="istickedoff">-- Check that the parameters are correct for the given datatype</span>
<span class="lineno">  408 </span><span class="spaces">     </span><span class="istickedoff">let err =</span>
<span class="lineno">  409 </span><span class="spaces">           </span><span class="istickedoff">MalformedRecursor (nameInfo d) s</span>
<span class="lineno">  410 </span><span class="spaces">           </span><span class="istickedoff">&quot;Disallowed propositional elimination&quot;</span>
<span class="lineno">  411 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  412 </span><span class="spaces">     </span><span class="istickedoff">unless (allowedElimSort dt s) $ throwTCError err</span>
<span class="lineno">  413 </span><span class="spaces">     </span><span class="istickedoff">return crec</span></span>

</pre>
</body>
</html>
