<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    2 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    3 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    4 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    5 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    6 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    7 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    8 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>{- |
<span class="lineno">   11 </span>Module      : SAWCore.Term.Pretty
<span class="lineno">   12 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">   13 </span>License     : BSD3
<span class="lineno">   14 </span>Maintainer  : huffman@galois.com
<span class="lineno">   15 </span>Stability   : experimental
<span class="lineno">   16 </span>Portability : non-portable (language extensions)
<span class="lineno">   17 </span>-}
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>module SAWCore.Term.Pretty
<span class="lineno">   20 </span>  ( ppTerm
<span class="lineno">   21 </span>  , ppTermInCtx
<span class="lineno">   22 </span>  , showTerm
<span class="lineno">   23 </span>  , scPrettyTerm
<span class="lineno">   24 </span>  , scPrettyTermInCtx
<span class="lineno">   25 </span>  , ppTermWithNames
<span class="lineno">   26 </span>  , showTermWithNames
<span class="lineno">   27 </span>  , scTermCount
<span class="lineno">   28 </span>  , shouldMemoizeTerm
<span class="lineno">   29 </span>  , ppName
<span class="lineno">   30 </span>  , ppTermContainerWithNames
<span class="lineno">   31 </span>  ) where
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import Data.Char (intToDigit, isDigit)
<span class="lineno">   34 </span>import Data.Maybe (isJust)
<span class="lineno">   35 </span>import Control.Monad.Reader (MonadReader(..), Reader, asks, runReader)
<span class="lineno">   36 </span>import Control.Monad.State.Strict (MonadState(..), State, evalState, execState, get, modify)
<span class="lineno">   37 </span>import qualified Data.Foldable as Fold
<span class="lineno">   38 </span>import Data.Hashable (hash)
<span class="lineno">   39 </span>import qualified Data.Text as Text
<span class="lineno">   40 </span>import qualified Data.Map as Map
<span class="lineno">   41 </span>import Data.Set (Set)
<span class="lineno">   42 </span>import qualified Data.Set as Set
<span class="lineno">   43 </span>import qualified Data.Vector as V
<span class="lineno">   44 </span>import Numeric (showHex)
<span class="lineno">   45 </span>import Prettyprinter
<span class="lineno">   46 </span>import Text.URI
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">   49 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>import SAWSupport.Pretty (prettyNat, prettyTypeConstraint)
<span class="lineno">   52 </span>import qualified SAWSupport.Pretty as PPS (
<span class="lineno">   53 </span>    Style(..), Doc, MemoStyle(..), Opts(..), defaultOpts, render
<span class="lineno">   54 </span> )
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import SAWCore.Panic (panic)
<span class="lineno">   57 </span>import SAWCore.Name
<span class="lineno">   58 </span>import SAWCore.Term.Functor
<span class="lineno">   59 </span>import SAWCore.Recognizer
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>-- | Test if a depth is &quot;allowed&quot;, meaning not greater than the max depth
<span class="lineno">   63 </span>depthAllowed :: PPS.Opts -&gt; Int -&gt; Bool
<span class="lineno">   64 </span><span class="decl"><span class="istickedoff">depthAllowed (PPS.Opts { ppMaxDepth = Just max_d }) d = d &lt; max_d</span>
<span class="lineno">   65 </span><span class="spaces"></span><span class="istickedoff">depthAllowed _ _ = True</span></span>
<span class="lineno">   66 </span>
<span class="lineno">   67 </span>-- | Precedence levels, each of which corresponds to a parsing nonterminal
<span class="lineno">   68 </span>data Prec
<span class="lineno">   69 </span>  = PrecCommas -- ^ Nonterminal @sepBy(Term, \',\')@
<span class="lineno">   70 </span>  | PrecTerm   -- ^ Nonterminal @Term@
<span class="lineno">   71 </span>  | PrecLambda -- ^ Nonterminal @LTerm@
<span class="lineno">   72 </span>  | PrecProd   -- ^ Nonterminal @ProdTerm@
<span class="lineno">   73 </span>  | PrecApp    -- ^ Nonterminal @AppTerm@
<span class="lineno">   74 </span>  | PrecArg    -- ^ Nonterminal @AtomTerm@
<span class="lineno">   75 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>-- | Test if the first precedence &quot;contains&quot; the second, meaning that terms at
<span class="lineno">   78 </span>-- the latter precedence level can be printed in the context of the former
<span class="lineno">   79 </span>-- without parentheses.
<span class="lineno">   80 </span>precContains :: Prec -&gt; Prec -&gt; Bool
<span class="lineno">   81 </span><span class="decl"><span class="istickedoff">precContains x y = x &lt;= y</span></span>
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>-- | Optionally print parentheses around a document, iff the incoming, outer
<span class="lineno">   84 </span>-- precedence (listed first) contains (as in 'precContains') the required
<span class="lineno">   85 </span>-- precedence (listed second) for printing the given document.
<span class="lineno">   86 </span>--
<span class="lineno">   87 </span>-- Stated differently: @ppParensPrec p1 p2 d@ means we are pretty-printing in a
<span class="lineno">   88 </span>-- term context that requires precedence @p1@, but @d@ was pretty-printed at
<span class="lineno">   89 </span>-- precedence level @p2@. If @p1@ does not contain @p2@ (e.g., if @p1@ is
<span class="lineno">   90 </span>-- 'PrecArg', meaning we are pretty-printing the argument of an application, and
<span class="lineno">   91 </span>-- @p2@ is 'PrecLambda', meaning the construct we are pretty-printing is a
<span class="lineno">   92 </span>-- lambda or pi abstraction) then add parentheses.
<span class="lineno">   93 </span>ppParensPrec :: Prec -&gt; Prec -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">   94 </span><span class="decl"><span class="istickedoff">ppParensPrec p1 p2 d</span>
<span class="lineno">   95 </span><span class="spaces">  </span><span class="istickedoff">| precContains p1 p2 = d</span>
<span class="lineno">   96 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = parens $ align d</span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>----------------------------------------------------------------------
<span class="lineno">  100 </span>-- * Local Variable Namings
<span class="lineno">  101 </span>----------------------------------------------------------------------
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>-- | Local variable namings, which map each deBruijn index in scope to a unique
<span class="lineno">  104 </span>-- string to be used to print it. This mapping is given by position in a list.
<span class="lineno">  105 </span>-- Renamings for named variables are in an 'IntMap' indexed by 'VarIndex'.
<span class="lineno">  106 </span>-- The third argument caches the set of all used or reserved names;
<span class="lineno">  107 </span>-- fresh 'LocalName's are chosen while avoiding names in this set.
<span class="lineno">  108 </span>data VarNaming = VarNaming [LocalName] (IntMap LocalName) (Set LocalName)
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>-- | The empty local variable context
<span class="lineno">  111 </span>emptyVarNaming :: Set LocalName -&gt; VarNaming
<span class="lineno">  112 </span><span class="decl"><span class="istickedoff">emptyVarNaming reserved = VarNaming [] IntMap.empty reserved</span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- | Look up a string to use for a 'DeBruijnIndex', if the first
<span class="lineno">  115 </span>-- argument is 'True', or just print the variable number if the first
<span class="lineno">  116 </span>-- argument is 'False'.
<span class="lineno">  117 </span>lookupDeBruijn :: Bool -&gt; VarNaming -&gt; DeBruijnIndex -&gt; LocalName
<span class="lineno">  118 </span><span class="decl"><span class="istickedoff">lookupDeBruijn True (VarNaming names _ _) i</span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">i &gt;= length names</span> = <span class="nottickedoff">Text.pack ('!' : show (i - length names))</span></span>
<span class="lineno">  120 </span><span class="spaces"></span><span class="istickedoff">lookupDeBruijn True (VarNaming names _ _) i = names!!i</span>
<span class="lineno">  121 </span><span class="spaces"></span><span class="istickedoff">lookupDeBruijn False _ i = <span class="nottickedoff">Text.pack ('!' : show i)</span></span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>-- | Look up a string to use for a 'VarName'.
<span class="lineno">  124 </span>lookupVarName :: VarNaming -&gt; VarName -&gt; LocalName
<span class="lineno">  125 </span><span class="decl"><span class="istickedoff">lookupVarName (VarNaming _ renames _) vn =</span>
<span class="lineno">  126 </span><span class="spaces">  </span><span class="istickedoff">case IntMap.lookup (vnIndex vn) renames of</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="istickedoff">Just alias -&gt; alias</span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">vnName vn</span></span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>-- | Generate a fresh name from a base name that does not clash with any names
<span class="lineno">  131 </span>-- already in a given list, unless it is &quot;_&quot;, in which case return it as is
<span class="lineno">  132 </span>freshName :: Set LocalName -&gt; LocalName -&gt; LocalName
<span class="lineno">  133 </span><span class="decl"><span class="istickedoff">freshName used name</span>
<span class="lineno">  134 </span><span class="spaces">  </span><span class="istickedoff">| name == &quot;_&quot; = name</span>
<span class="lineno">  135 </span><span class="spaces">  </span><span class="istickedoff">| Set.member name used = freshName used (nextName name)</span>
<span class="lineno">  136 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = name</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | Generate a variant of a name by incrementing the number at the
<span class="lineno">  139 </span>-- end, or appending the number 1 if there is none.
<span class="lineno">  140 </span>nextName :: LocalName -&gt; LocalName
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">nextName = Text.pack . reverse . go . reverse . Text.unpack</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  143 </span><span class="spaces">    </span><span class="istickedoff">go :: String -&gt; String</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">go (c : cs)</span>
<span class="lineno">  145 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == '9'</span>  = <span class="nottickedoff">'0' : go cs</span></span>
<span class="lineno">  146 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">isDigit c</span> = <span class="nottickedoff">succ c : cs</span></span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff">go cs = '1' : cs</span></span>
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>-- | Add a new variable with the given base name to the local variable list,
<span class="lineno">  150 </span>-- returning both the fresh name actually used and the new variable list. As a
<span class="lineno">  151 </span>-- special case, if the base name is &quot;_&quot;, it is not modified.
<span class="lineno">  152 </span>consVarNaming :: VarNaming -&gt; LocalName -&gt; (LocalName, VarNaming)
<span class="lineno">  153 </span><span class="decl"><span class="istickedoff">consVarNaming (VarNaming names renames used) name =</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="istickedoff">let nm = freshName used name</span>
<span class="lineno">  155 </span><span class="spaces">  </span><span class="istickedoff">in (nm, VarNaming (nm : names) <span class="nottickedoff">renames</span> (Set.insert nm used))</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>-- | Add a new variable with the given 'VarName' to the 'VarNaming',
<span class="lineno">  158 </span>-- returning both the chosen fresh name and the new 'VarNaming'.
<span class="lineno">  159 </span>-- As a special case, if the base name is &quot;_&quot;, it is not modified.
<span class="lineno">  160 </span>insertVarNaming :: VarNaming -&gt; VarName -&gt; (LocalName, VarNaming)
<span class="lineno">  161 </span><span class="decl"><span class="istickedoff">insertVarNaming (VarNaming names renames used) (VarName i name) =</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="istickedoff">let nm = freshName used name</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="istickedoff">in (<span class="nottickedoff">nm</span>, VarNaming <span class="nottickedoff">names</span> (IntMap.insert i nm renames) (Set.insert nm used))</span></span>
<span class="lineno">  164 </span>
<span class="lineno">  165 </span>-- | Compute the set of all free 'VarName's in a term.
<span class="lineno">  166 </span>termVarNames :: Term -&gt; Set VarName
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff">termVarNames t0 = evalState (go t0) IntMap.empty</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">go :: Term -&gt; State (IntMap (Set VarName)) (Set VarName)</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">go tm =</span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="istickedoff">case tm of</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">Unshared tf -&gt; termf &lt;$&gt; traverse go tf</span>
<span class="lineno">  173 </span><span class="spaces">        </span><span class="istickedoff">STApp { stAppIndex = i, stAppTermF = tf, stAppFreeVars = _vs } -&gt;</span>
<span class="lineno">  174 </span><span class="spaces">          </span><span class="istickedoff">do memo &lt;- get</span>
<span class="lineno">  175 </span><span class="spaces">             </span><span class="istickedoff">case IntMap.lookup i memo of</span>
<span class="lineno">  176 </span><span class="spaces">               </span><span class="istickedoff">Just vars -&gt; pure vars</span>
<span class="lineno">  177 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  178 </span><span class="spaces">                 </span><span class="istickedoff">do vars &lt;- termf &lt;$&gt; traverse go tf</span>
<span class="lineno">  179 </span><span class="spaces">                    </span><span class="istickedoff">modify (IntMap.insert i vars)</span>
<span class="lineno">  180 </span><span class="spaces">                    </span><span class="istickedoff">pure vars</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">termf :: TermF (Set VarName) -&gt; Set VarName</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">termf tf =</span>
<span class="lineno">  183 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno">  184 </span><span class="spaces">        </span><span class="istickedoff">FTermF ftf -&gt; Fold.fold ftf</span>
<span class="lineno">  185 </span><span class="spaces">        </span><span class="istickedoff">App e1 e2 -&gt; Set.union e1 e2</span>
<span class="lineno">  186 </span><span class="spaces">        </span><span class="istickedoff">Lambda _ e1 e2 -&gt; Set.union e1 e2</span>
<span class="lineno">  187 </span><span class="spaces">        </span><span class="istickedoff">Pi _ e1 e2 -&gt; Set.union e1 e2</span>
<span class="lineno">  188 </span><span class="spaces">        </span><span class="istickedoff">LocalVar _ -&gt; Set.empty</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">Constant _ -&gt; Set.empty</span>
<span class="lineno">  190 </span><span class="spaces">        </span><span class="istickedoff">Variable ec -&gt; Set.insert (ecName ec) (ecType ec)</span></span>
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>--------------------------------------------------------------------------------
<span class="lineno">  193 </span>-- * Pretty-printing monad
<span class="lineno">  194 </span>--------------------------------------------------------------------------------
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>-- | Memoization variables contain several pieces of information about the term
<span class="lineno">  197 </span>-- they bind. What subset is displayed when they're printed is governed by the
<span class="lineno">  198 </span>-- 'ppMemoStyle' field of 'PPS.Opts', in tandem with 'ppMemoVar'.
<span class="lineno">  199 </span>data MemoVar =
<span class="lineno">  200 </span>  MemoVar
<span class="lineno">  201 </span>    {
<span class="lineno">  202 </span>      -- | A unique value - like a deBruijn index, but evinced only during
<span class="lineno">  203 </span>      -- printing when a term is to be memoized.
<span class="lineno">  204 </span>      <span class="nottickedoff"><span class="decl"><span class="nottickedoff">memoFresh</span></span></span> :: Int,
<span class="lineno">  205 </span>      -- | A likely-unique value - the hash of the term this 'MemoVar'
<span class="lineno">  206 </span>      -- represents.
<span class="lineno">  207 </span>      <span class="nottickedoff"><span class="decl"><span class="nottickedoff">memoHash</span></span></span> :: Int }
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>-- | The local state used by pretty-printing computations
<span class="lineno">  210 </span>data PPState =
<span class="lineno">  211 </span>  PPState
<span class="lineno">  212 </span>  {
<span class="lineno">  213 </span>    -- | The global pretty-printing options
<span class="lineno">  214 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppOpts</span></span></span> :: PPS.Opts,
<span class="lineno">  215 </span>    -- | The current depth of printing
<span class="lineno">  216 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppDepth</span></span></span> :: Int,
<span class="lineno">  217 </span>    -- | The current naming for the local variables
<span class="lineno">  218 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppNaming</span></span></span> :: VarNaming,
<span class="lineno">  219 </span>    -- | The top-level naming environment
<span class="lineno">  220 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppNamingEnv</span></span></span> :: DisplayNameEnv,
<span class="lineno">  221 </span>    -- | A source of freshness for memoization variables
<span class="lineno">  222 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppMemoFresh</span></span></span> :: Int,
<span class="lineno">  223 </span>    -- | Memoization table for the global, closed terms, mapping term indices to
<span class="lineno">  224 </span>    -- &quot;memoization variables&quot; that are in scope
<span class="lineno">  225 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppGlobalMemoTable</span></span></span> :: IntMap MemoVar,
<span class="lineno">  226 </span>    -- | Memoization table for terms at the current binding level, mapping term
<span class="lineno">  227 </span>    -- indices to &quot;memoization variables&quot; that are in scope
<span class="lineno">  228 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppLocalMemoTable</span></span></span> :: IntMap MemoVar,
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>    -- | Terms to not inline because they're memoized (see 'withMemoVar')
<span class="lineno">  231 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppNoInlineIdx</span></span></span> :: Set TermIndex
<span class="lineno">  232 </span>  }
<span class="lineno">  233 </span>
<span class="lineno">  234 </span>emptyPPState :: PPS.Opts -&gt; DisplayNameEnv -&gt; PPState
<span class="lineno">  235 </span><span class="decl"><span class="istickedoff">emptyPPState opts ne =</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="istickedoff">PPState { ppOpts = opts,</span>
<span class="lineno">  237 </span><span class="spaces">            </span><span class="istickedoff">ppDepth = 0,</span>
<span class="lineno">  238 </span><span class="spaces">            </span><span class="istickedoff">ppNaming = emptyVarNaming (Map.keysSet (displayIndexes ne)),</span>
<span class="lineno">  239 </span><span class="spaces">            </span><span class="istickedoff">ppNamingEnv = ne,</span>
<span class="lineno">  240 </span><span class="spaces">            </span><span class="istickedoff">ppMemoFresh = 1,</span>
<span class="lineno">  241 </span><span class="spaces">            </span><span class="istickedoff">ppGlobalMemoTable = IntMap.empty,</span>
<span class="lineno">  242 </span><span class="spaces">            </span><span class="istickedoff">ppLocalMemoTable = IntMap.empty,</span>
<span class="lineno">  243 </span><span class="spaces">            </span><span class="istickedoff">ppNoInlineIdx = mempty</span>
<span class="lineno">  244 </span><span class="spaces">   </span><span class="istickedoff">}</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>-- | The pretty-printing monad
<span class="lineno">  247 </span>--
<span class="lineno">  248 </span>-- XXX: let's find a better name than PPM
<span class="lineno">  249 </span>newtype PPM a = PPM (Reader PPState a)
<span class="lineno">  250 </span>              deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>)
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>-- | Run a pretty-printing computation in a top-level, empty context
<span class="lineno">  253 </span>runPPM :: PPS.Opts -&gt; DisplayNameEnv -&gt; PPM a -&gt; a
<span class="lineno">  254 </span><span class="decl"><span class="istickedoff">runPPM opts ne (PPM m) = runReader m $ emptyPPState opts ne</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>instance <span class="decl"><span class="istickedoff">MonadReader PPState PPM</span></span> where
<span class="lineno">  257 </span>  <span class="decl"><span class="istickedoff">ask = PPM ask</span></span>
<span class="lineno">  258 </span>  <span class="decl"><span class="istickedoff">local f (PPM m) = PPM $ local f m</span></span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>-- | Look up the given local variable by deBruijn index to get its name
<span class="lineno">  261 </span>varLookupM :: DeBruijnIndex -&gt; PPM LocalName
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">varLookupM idx =</span>
<span class="lineno">  263 </span><span class="spaces">  </span><span class="istickedoff">lookupDeBruijn &lt;$&gt; (PPS.ppShowLocalNames &lt;$&gt; ppOpts &lt;$&gt; ask)</span>
<span class="lineno">  264 </span><span class="spaces">  </span><span class="istickedoff">&lt;*&gt; (ppNaming &lt;$&gt; ask) &lt;*&gt; return idx</span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>-- | Test if a given term index is memoized, returning its memoization variable
<span class="lineno">  267 </span>-- if so and otherwise returning 'Nothing'
<span class="lineno">  268 </span>memoLookupM :: TermIndex -&gt; PPM (Maybe MemoVar)
<span class="lineno">  269 </span><span class="decl"><span class="istickedoff">memoLookupM idx =</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- ask</span>
<span class="lineno">  271 </span><span class="spaces">     </span><span class="istickedoff">return $ case (IntMap.lookup idx (ppGlobalMemoTable s),</span>
<span class="lineno">  272 </span><span class="spaces">                    </span><span class="istickedoff">IntMap.lookup idx (ppLocalMemoTable s)) of</span>
<span class="lineno">  273 </span><span class="spaces">       </span><span class="istickedoff">(res@(Just _), _) -&gt; res</span>
<span class="lineno">  274 </span><span class="spaces">       </span><span class="istickedoff">(_, res@(Just _)) -&gt; res</span>
<span class="lineno">  275 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>-- | Run a pretty-printing computation at the next greater depth, returning the
<span class="lineno">  278 </span>-- default value if the max depth has been exceeded
<span class="lineno">  279 </span>atNextDepthM :: a -&gt; PPM a -&gt; PPM a
<span class="lineno">  280 </span><span class="decl"><span class="istickedoff">atNextDepthM dflt m =</span>
<span class="lineno">  281 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- ask</span>
<span class="lineno">  282 </span><span class="spaces">     </span><span class="istickedoff">let new_depth = ppDepth s + 1</span>
<span class="lineno">  283 </span><span class="spaces">     </span><span class="istickedoff">if <span class="tickonlytrue">depthAllowed (ppOpts s) new_depth</span></span>
<span class="lineno">  284 </span><span class="spaces">       </span><span class="istickedoff">then local (\_ -&gt; s { ppDepth = new_depth }) m</span>
<span class="lineno">  285 </span><span class="spaces">       </span><span class="istickedoff">else <span class="nottickedoff">return dflt</span></span></span>
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>-- | Run a pretty-printing computation in the context of a new bound variable,
<span class="lineno">  288 </span>-- also erasing the local memoization table (which is no longer valid in an
<span class="lineno">  289 </span>-- extended variable context) during that computation. Return the result of the
<span class="lineno">  290 </span>-- computation and also the name that was actually used for the bound variable.
<span class="lineno">  291 </span>withBoundVarM :: LocalName -&gt; PPM a -&gt; PPM (LocalName, a)
<span class="lineno">  292 </span><span class="decl"><span class="istickedoff">withBoundVarM basename m =</span>
<span class="lineno">  293 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- ask</span>
<span class="lineno">  294 </span><span class="spaces">     </span><span class="istickedoff">let (var, naming) = consVarNaming (ppNaming st) basename</span>
<span class="lineno">  295 </span><span class="spaces">     </span><span class="istickedoff">ret &lt;- local (\_ -&gt; st { ppNaming = naming,</span>
<span class="lineno">  296 </span><span class="spaces">                              </span><span class="istickedoff">ppLocalMemoTable = IntMap.empty }) m</span>
<span class="lineno">  297 </span><span class="spaces">     </span><span class="istickedoff">return (var, ret)</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>-- | Run a pretty-printing computation in a context with an additional
<span class="lineno">  300 </span>-- declared 'VarName'.
<span class="lineno">  301 </span>withVarName :: VarName -&gt; PPM a -&gt; PPM a
<span class="lineno">  302 </span><span class="decl"><span class="istickedoff">withVarName vn =</span>
<span class="lineno">  303 </span><span class="spaces">  </span><span class="istickedoff">local (\s -&gt; s { ppNaming = snd (insertVarNaming (ppNaming s) vn) })</span></span>
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>-- | Run a pretty-printing computation in a context with multiple
<span class="lineno">  306 </span>-- additional declared 'VarName's.
<span class="lineno">  307 </span>withVarNames :: [VarName] -&gt; PPM a -&gt; PPM a
<span class="lineno">  308 </span><span class="decl"><span class="istickedoff">withVarNames vs m = foldr withVarName m vs</span></span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>-- | Attempt to memoize the given term (index) 'termIdx' and run a computation
<span class="lineno">  311 </span>-- in the context that the attempt produces. If memoization succeeds, the
<span class="lineno">  312 </span>-- context will contain a binding (global in scope if 'global_p' is set, local
<span class="lineno">  313 </span>-- if not) of a fresh memoization variable to the term, and the fresh variable
<span class="lineno">  314 </span>-- will be supplied to the computation. If memoization fails, the context will
<span class="lineno">  315 </span>-- not contain such a binding, and no fresh variable will be supplied.
<span class="lineno">  316 </span>withMemoVar :: Bool -&gt; TermIndex -&gt; Int -&gt; (Maybe MemoVar -&gt; PPM a) -&gt; PPM a
<span class="lineno">  317 </span><span class="decl"><span class="istickedoff">withMemoVar global_p termIdx termHash f =</span>
<span class="lineno">  318 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno">  319 </span><span class="spaces">    </span><span class="istickedoff">memoFresh &lt;- asks ppMemoFresh</span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">let memoVar = MemoVar { memoFresh = memoFresh, memoHash = <span class="nottickedoff">termHash</span> }</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">memoFreshSkips &lt;- asks (PPS.ppNoInlineMemoFresh . ppOpts)</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff">termIdxSkips &lt;- asks ppNoInlineIdx</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff">case memoFreshSkips of</span>
<span class="lineno">  324 </span><span class="spaces">      </span><span class="istickedoff">-- Even if we must skip this memoization variable, we still want to</span>
<span class="lineno">  325 </span><span class="spaces">      </span><span class="istickedoff">-- &quot;pretend&quot; we memoized by calling `freshen`, so that non-inlined</span>
<span class="lineno">  326 </span><span class="spaces">      </span><span class="istickedoff">-- memoization identifiers are kept constant between two</span>
<span class="lineno">  327 </span><span class="spaces">      </span><span class="istickedoff">-- otherwise-identical terms with differing inline strategies.</span>
<span class="lineno">  328 </span><span class="spaces">      </span><span class="istickedoff">(skip:skips)</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">skip == memoFresh</span> -&gt;</span>
<span class="lineno">  330 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">local (freshen . addIdxSkip . setMemoFreshSkips skips) (f Nothing)</span></span>
<span class="lineno">  331 </span><span class="spaces">      </span><span class="istickedoff">_</span>
<span class="lineno">  332 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">termIdx `Set.member` termIdxSkips</span> -&gt; <span class="nottickedoff">f Nothing</span></span>
<span class="lineno">  333 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; local (freshen . bind memoVar) (f (Just memoVar))</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff">bind = if global_p then bindGlobal else bindLocal</span>
<span class="lineno">  336 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff">bindGlobal memoVar PPState{ .. } =</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="istickedoff">PPState { ppGlobalMemoTable = IntMap.insert termIdx memoVar ppGlobalMemoTable, .. }</span>
<span class="lineno">  339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">bindLocal memoVar PPState{ .. } =</span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff">PPState { ppLocalMemoTable = IntMap.insert termIdx memoVar ppLocalMemoTable, <span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff">..</span></span></span></span></span> }</span>
<span class="lineno">  342 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">setMemoFreshSkips memoSkips PPState{ ppOpts = PPS.Opts{ .. }, .. } =</span></span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PPState { ppOpts = PPS.Opts { ppNoInlineMemoFresh = memoSkips, ..}, ..}</span></span>
<span class="lineno">  345 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">addIdxSkip PPState{ .. } =</span></span>
<span class="lineno">  347 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PPState { ppNoInlineIdx = Set.insert termIdx ppNoInlineIdx, .. }</span></span>
<span class="lineno">  348 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">freshen PPState{ .. } =</span>
<span class="lineno">  350 </span><span class="spaces">      </span><span class="istickedoff">PPState { ppMemoFresh = ppMemoFresh + 1, .. }</span></span>
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>--------------------------------------------------------------------------------
<span class="lineno">  353 </span>-- * The Pretty-Printing of Specific Constructs
<span class="lineno">  354 </span>--------------------------------------------------------------------------------
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>-- | Pretty-print an identifier
<span class="lineno">  357 </span>ppIdent :: Ident -&gt; PPS.Doc
<span class="lineno">  358 </span><span class="decl"><span class="istickedoff">ppIdent = viaShow</span></span>
<span class="lineno">  359 </span>
<span class="lineno">  360 </span>-- | Pretty-print a memoization variable, according to 'ppMemoStyle'
<span class="lineno">  361 </span>ppMemoVar :: MemoVar -&gt; PPM PPS.Doc
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff">ppMemoVar MemoVar{..} = asks (PPS.ppMemoStyle . ppOpts) &gt;&gt;= \case</span>
<span class="lineno">  363 </span><span class="spaces">  </span><span class="istickedoff">PPS.Incremental -&gt;</span>
<span class="lineno">  364 </span><span class="spaces">    </span><span class="istickedoff">pure (&quot;x@&quot; &lt;&gt; pretty memoFresh)</span>
<span class="lineno">  365 </span><span class="spaces">  </span><span class="istickedoff">PPS.Hash prefixLen -&gt;</span>
<span class="lineno">  366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (&quot;x@&quot; &lt;&gt; pretty (take prefixLen hashStr))</span></span>
<span class="lineno">  367 </span><span class="spaces">  </span><span class="istickedoff">PPS.HashIncremental prefixLen -&gt;</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (&quot;x&quot; &lt;&gt; pretty memoFresh &lt;&gt; &quot;@&quot; &lt;&gt; pretty (take prefixLen hashStr))</span></span>
<span class="lineno">  369 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  370 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">hashStr = showHex (abs memoHash) &quot;&quot;</span></span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>-- | Pretty-print an application to 0 or more arguments at the given precedence
<span class="lineno">  373 </span>ppAppList :: Prec -&gt; PPS.Doc -&gt; [PPS.Doc] -&gt; PPS.Doc
<span class="lineno">  374 </span><span class="decl"><span class="istickedoff">ppAppList _ f [] = <span class="nottickedoff">f</span></span>
<span class="lineno">  375 </span><span class="spaces"></span><span class="istickedoff">ppAppList p f args = ppParensPrec p PrecApp $ group $ hang 2 $ vsep (f : args)</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>-- | Pretty-print &quot;let x = t ... x' = t' in body&quot;
<span class="lineno">  378 </span>ppLetBlock :: [(MemoVar, PPS.Doc)] -&gt; PPS.Doc -&gt; PPM PPS.Doc
<span class="lineno">  379 </span><span class="decl"><span class="istickedoff">ppLetBlock defs body =</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">lets &lt;- align . vcat &lt;$&gt; mapM ppEqn defs</span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">pure $</span>
<span class="lineno">  383 </span><span class="spaces">      </span><span class="istickedoff">vcat</span>
<span class="lineno">  384 </span><span class="spaces">        </span><span class="istickedoff">[ &quot;let&quot; &lt;+&gt; lbrace &lt;+&gt; lets</span>
<span class="lineno">  385 </span><span class="spaces">        </span><span class="istickedoff">, indent 4 rbrace</span>
<span class="lineno">  386 </span><span class="spaces">        </span><span class="istickedoff">, &quot; in&quot; &lt;+&gt; body</span>
<span class="lineno">  387 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  388 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="istickedoff">ppEqn (var,d) =</span>
<span class="lineno">  390 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno">  391 </span><span class="spaces">        </span><span class="istickedoff">mv &lt;- ppMemoVar var</span>
<span class="lineno">  392 </span><span class="spaces">        </span><span class="istickedoff">pure $ mv &lt;+&gt; pretty '=' &lt;+&gt; d</span></span>
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>-- | Pretty-print pairs as &quot;(x, y)&quot;
<span class="lineno">  396 </span>ppPair :: Prec -&gt; PPS.Doc -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  397 </span><span class="decl"><span class="istickedoff">ppPair prec x y = ppParensPrec prec PrecCommas (group (vcat [x &lt;&gt; pretty ',', y]))</span></span>
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>-- | Pretty-print pair types as &quot;x * y&quot;
<span class="lineno">  400 </span>ppPairType :: Prec -&gt; PPS.Doc -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  401 </span><span class="decl"><span class="istickedoff">ppPairType prec x y = ppParensPrec prec PrecProd (x &lt;+&gt; pretty '*' &lt;+&gt; y)</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>-- | Pretty-print records (if the flag is 'False') or record types (if the flag
<span class="lineno">  404 </span>-- is 'True'), where the latter are preceded by the string @#@, either as:
<span class="lineno">  405 </span>--
<span class="lineno">  406 </span>-- * @(val1, val2, .., valn)@, if the record represents a tuple; OR
<span class="lineno">  407 </span>--
<span class="lineno">  408 </span>-- * @{ fld1 op val1, ..., fldn op valn }@ otherwise, where @op@ is @::@ for
<span class="lineno">  409 </span>--   types and @=@ for values.
<span class="lineno">  410 </span>ppRecord :: Bool -&gt; [(FieldName, PPS.Doc)] -&gt; PPS.Doc
<span class="lineno">  411 </span><span class="decl"><span class="istickedoff">ppRecord type_p alist =</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="istickedoff">(if type_p then (pretty '#' &lt;&gt;) else id) $</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="istickedoff">encloseSep lbrace rbrace comma $ map ppField alist</span>
<span class="lineno">  414 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">ppField (fld, rhs) = group (nest 2 (vsep [pretty fld &lt;+&gt; op_str, rhs]))</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">op_str = if type_p then &quot;:&quot; else &quot;=&quot;</span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>-- | Pretty-print a projection / selector &quot;x.f&quot;
<span class="lineno">  419 </span>ppProj :: FieldName -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  420 </span><span class="decl"><span class="istickedoff">ppProj sel doc = doc &lt;&gt; pretty '.' &lt;&gt; pretty sel</span></span>
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>-- | Pretty-print an array value @[v1, ..., vn]@
<span class="lineno">  423 </span>ppArrayValue :: [PPS.Doc] -&gt; PPS.Doc
<span class="lineno">  424 </span><span class="decl"><span class="istickedoff">ppArrayValue = list</span></span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>-- | Pretty-print a lambda abstraction as @\(x :: tp) -&gt; body@, where the
<span class="lineno">  427 </span>-- variable name to use for @x@ is bundled with @body@
<span class="lineno">  428 </span>ppLambda :: PPS.Doc -&gt; (LocalName, PPS.Doc) -&gt; PPS.Doc
<span class="lineno">  429 </span><span class="decl"><span class="istickedoff">ppLambda tp (name, body) =</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">group $ hang 2 $</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="istickedoff">vsep [&quot;\\&quot; &lt;&gt; parens (prettyTypeConstraint (pretty name) tp) &lt;+&gt; &quot;-&gt;&quot;, body]</span></span>
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>-- | Pretty-print a pi abstraction as @(x :: tp) -&gt; body@, or as @tp -&gt; body@ if
<span class="lineno">  434 </span>-- @x == &quot;_&quot;@
<span class="lineno">  435 </span>ppPi :: PPS.Doc -&gt; (LocalName, PPS.Doc) -&gt; PPS.Doc
<span class="lineno">  436 </span><span class="decl"><span class="istickedoff">ppPi tp (name, body) = vsep [lhs, &quot;-&gt;&quot; &lt;+&gt; body]</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">lhs = if name == &quot;_&quot; then tp else parens (prettyTypeConstraint (pretty name) tp)</span></span>
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>--------------------------------------------------------------------------------
<span class="lineno">  442 </span>-- * Pretty-Printing Terms
<span class="lineno">  443 </span>--------------------------------------------------------------------------------
<span class="lineno">  444 </span>
<span class="lineno">  445 </span>-- | Pretty-print a built-in atomic construct
<span class="lineno">  446 </span>ppFlatTermF :: Prec -&gt; FlatTermF Term -&gt; PPM PPS.Doc
<span class="lineno">  447 </span><span class="decl"><span class="istickedoff">ppFlatTermF prec tf =</span>
<span class="lineno">  448 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">UnitValue     -&gt; <span class="nottickedoff">return &quot;(-empty-)&quot;</span></span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff">UnitType      -&gt; return &quot;#(-empty-)&quot;</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">PairValue x y -&gt; ppPair prec &lt;$&gt; ppTerm' <span class="nottickedoff">PrecTerm</span> x &lt;*&gt; ppTerm' PrecCommas y</span>
<span class="lineno">  452 </span><span class="spaces">    </span><span class="istickedoff">PairType x y  -&gt; ppPairType prec &lt;$&gt; ppTerm' PrecApp x &lt;*&gt; ppTerm' PrecProd y</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">PairLeft t    -&gt; ppProj &quot;1&quot; &lt;$&gt; ppTerm' PrecArg t</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">PairRight t   -&gt; <span class="nottickedoff">ppProj &quot;2&quot; &lt;$&gt; ppTerm' PrecArg t</span></span>
<span class="lineno">  455 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">Recursor (CompiledRecursor d s _params _nixs _ctorOrder _ty) -&gt;</span>
<span class="lineno">  457 </span><span class="spaces">      </span><span class="istickedoff">do nm &lt;- ppBestName d</span>
<span class="lineno">  458 </span><span class="spaces">         </span><span class="istickedoff">let suffix =</span>
<span class="lineno">  459 </span><span class="spaces">               </span><span class="istickedoff">case s of</span>
<span class="lineno">  460 </span><span class="spaces">                 </span><span class="istickedoff">TypeSort 0 -&gt; &quot;#rec&quot;</span>
<span class="lineno">  461 </span><span class="spaces">                 </span><span class="istickedoff">TypeSort n -&gt; &quot;#rec&quot; &lt;&gt; pretty n</span>
<span class="lineno">  462 </span><span class="spaces">                 </span><span class="istickedoff">PropSort -&gt; <span class="nottickedoff">&quot;#ind&quot;</span></span>
<span class="lineno">  463 </span><span class="spaces">         </span><span class="istickedoff">return $</span>
<span class="lineno">  464 </span><span class="spaces">           </span><span class="istickedoff">annotate <span class="nottickedoff">PPS.RecursorStyle</span> (nm &lt;&gt; suffix)</span>
<span class="lineno">  465 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">RecordType alist -&gt;</span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="istickedoff">ppRecord True &lt;$&gt; mapM (\(fld,t) -&gt; (fld,) &lt;$&gt; ppTerm' <span class="nottickedoff">PrecTerm</span> t) alist</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">RecordValue alist -&gt;</span>
<span class="lineno">  469 </span><span class="spaces">      </span><span class="istickedoff">ppRecord False &lt;$&gt; mapM (\(fld,t) -&gt; (fld,) &lt;$&gt; ppTerm' <span class="nottickedoff">PrecTerm</span> t) alist</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">RecordProj e fld -&gt; ppProj fld &lt;$&gt; ppTerm' <span class="nottickedoff">PrecArg</span> e</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">Sort s h -&gt; return (viaShow h &lt;&gt; viaShow s)</span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">NatLit i -&gt; prettyNat &lt;$&gt; (ppOpts &lt;$&gt; ask) &lt;*&gt; return (toInteger i)</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue (asBoolType -&gt; Just _) args</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">| Just bits &lt;- <span class="nottickedoff">mapM asBool $ V.toList args</span> -&gt;</span>
<span class="lineno">  475 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">if length bits `mod` 4 == 0 then</span></span>
<span class="lineno">  476 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ pretty (&quot;0x&quot; ++ ppBitsToHex bits)</span></span>
<span class="lineno">  477 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">else</span></span>
<span class="lineno">  478 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ pretty (&quot;0b&quot; ++ map (\b -&gt; if b then '1' else '0') bits)</span></span>
<span class="lineno">  479 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue _ args   -&gt;</span>
<span class="lineno">  480 </span><span class="spaces">      </span><span class="istickedoff">ppArrayValue &lt;$&gt; mapM (ppTerm' PrecTerm) (V.toList args)</span>
<span class="lineno">  481 </span><span class="spaces">    </span><span class="istickedoff">StringLit s -&gt; <span class="nottickedoff">return $ viaShow s</span></span></span>
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>-- | Pretty-print a big endian list of bit values as a hexadecimal number
<span class="lineno">  484 </span>ppBitsToHex :: [Bool] -&gt; String
<span class="lineno">  485 </span><span class="decl"><span class="nottickedoff">ppBitsToHex (b8:b4:b2:b1:bits') =</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="nottickedoff">intToDigit (8 * toInt b8 + 4 * toInt b4 + 2 * toInt b2 + toInt b1) :</span>
<span class="lineno">  487 </span><span class="spaces">  </span><span class="nottickedoff">ppBitsToHex bits'</span>
<span class="lineno">  488 </span><span class="spaces">  </span><span class="nottickedoff">where toInt True = 1</span>
<span class="lineno">  489 </span><span class="spaces">        </span><span class="nottickedoff">toInt False = 0</span>
<span class="lineno">  490 </span><span class="spaces"></span><span class="nottickedoff">ppBitsToHex [] = &quot;&quot;</span>
<span class="lineno">  491 </span><span class="spaces"></span><span class="nottickedoff">ppBitsToHex bits =</span>
<span class="lineno">  492 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;ppBitsToHex&quot; [</span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="nottickedoff">&quot;length of bit list &quot; &lt;&gt; bits' &lt;&gt; &quot; is not a multiple of 4&quot;</span>
<span class="lineno">  494 </span><span class="spaces">  </span><span class="nottickedoff">]</span>
<span class="lineno">  495 </span><span class="spaces">  </span><span class="nottickedoff">where bits' = Text.pack (show bits)</span></span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>-- | Pretty-print an 'ExtCns' according to the current 'VarNaming'.
<span class="lineno">  498 </span>ppExtCns :: ExtCns e -&gt; PPM PPS.Doc
<span class="lineno">  499 </span><span class="decl"><span class="istickedoff">ppExtCns ec = ppVarName (ecName ec)</span></span>
<span class="lineno">  500 </span>
<span class="lineno">  501 </span>-- | Pretty-print a 'VarName' according to the current 'VarNaming'.
<span class="lineno">  502 </span>ppVarName :: VarName -&gt; PPM PPS.Doc
<span class="lineno">  503 </span><span class="decl"><span class="istickedoff">ppVarName vn =</span>
<span class="lineno">  504 </span><span class="spaces">  </span><span class="istickedoff">do naming &lt;- asks ppNaming</span>
<span class="lineno">  505 </span><span class="spaces">     </span><span class="istickedoff">pure $ pretty (lookupVarName naming vn)</span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>-- | Pretty-print a 'Name', using the best unambiguous alias from the
<span class="lineno">  508 </span>-- naming environment.
<span class="lineno">  509 </span>ppBestName :: Name -&gt; PPM PPS.Doc
<span class="lineno">  510 </span><span class="decl"><span class="istickedoff">ppBestName nm =</span>
<span class="lineno">  511 </span><span class="spaces">  </span><span class="istickedoff">do ne &lt;- asks ppNamingEnv</span>
<span class="lineno">  512 </span><span class="spaces">     </span><span class="istickedoff">case bestDisplayName ne (nameIndex nm) of</span>
<span class="lineno">  513 </span><span class="spaces">       </span><span class="istickedoff">Just alias -&gt; pure $ pretty alias</span>
<span class="lineno">  514 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure $ ppName (nameInfo nm)</span></span>
<span class="lineno">  515 </span>
<span class="lineno">  516 </span>ppName :: NameInfo -&gt; PPS.Doc
<span class="lineno">  517 </span><span class="decl"><span class="istickedoff">ppName (ModuleIdentifier i) = ppIdent i</span>
<span class="lineno">  518 </span><span class="spaces"></span><span class="istickedoff">ppName (ImportedName absName _) = pretty (render absName)</span></span>
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>-- | Pretty-print a non-shared term
<span class="lineno">  521 </span>ppTermF :: Prec -&gt; TermF Term -&gt; PPM PPS.Doc
<span class="lineno">  522 </span><span class="decl"><span class="istickedoff">ppTermF prec (FTermF ftf) = ppFlatTermF prec ftf</span>
<span class="lineno">  523 </span><span class="spaces"></span><span class="istickedoff">ppTermF prec (App e1 e2) =</span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="istickedoff">ppAppList prec &lt;$&gt; ppTerm' PrecApp e1 &lt;*&gt; mapM (ppTerm' PrecArg) [e2]</span>
<span class="lineno">  525 </span><span class="spaces"></span><span class="istickedoff">ppTermF prec (Lambda x tp body) =</span>
<span class="lineno">  526 </span><span class="spaces">  </span><span class="istickedoff">ppParensPrec prec PrecLambda &lt;$&gt;</span>
<span class="lineno">  527 </span><span class="spaces">  </span><span class="istickedoff">(ppLambda &lt;$&gt; ppTerm' PrecApp tp &lt;*&gt; ppTermInBinder PrecLambda x body)</span>
<span class="lineno">  528 </span><span class="spaces"></span><span class="istickedoff">ppTermF prec (Pi x tp body) =</span>
<span class="lineno">  529 </span><span class="spaces">  </span><span class="istickedoff">ppParensPrec prec PrecLambda &lt;$&gt;</span>
<span class="lineno">  530 </span><span class="spaces">  </span><span class="istickedoff">(ppPi &lt;$&gt; ppTerm' PrecApp tp &lt;*&gt;</span>
<span class="lineno">  531 </span><span class="spaces">   </span><span class="istickedoff">ppTermInBinder PrecLambda x body)</span>
<span class="lineno">  532 </span><span class="spaces"></span><span class="istickedoff">ppTermF _ (LocalVar x) = annotate <span class="nottickedoff">PPS.LocalVarStyle</span> &lt;$&gt; pretty &lt;$&gt; varLookupM x</span>
<span class="lineno">  533 </span><span class="spaces"></span><span class="istickedoff">ppTermF _ (Constant nm) = annotate <span class="nottickedoff">PPS.ConstantStyle</span> &lt;$&gt; ppBestName nm</span>
<span class="lineno">  534 </span><span class="spaces"></span><span class="istickedoff">ppTermF _ (Variable ec) = annotate <span class="nottickedoff">PPS.ExtCnsStyle</span> &lt;$&gt; ppExtCns ec</span></span>
<span class="lineno">  535 </span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>-- | Internal function to recursively pretty-print a term
<span class="lineno">  538 </span>ppTerm' :: Prec -&gt; Term -&gt; PPM PPS.Doc
<span class="lineno">  539 </span><span class="decl"><span class="istickedoff">ppTerm' prec = atNextDepthM <span class="nottickedoff">&quot;...&quot;</span> . ppTerm'' where</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="istickedoff">ppTerm'' (Unshared tf) = ppTermF prec tf</span>
<span class="lineno">  541 </span><span class="spaces">  </span><span class="istickedoff">ppTerm'' (STApp {stAppIndex = idx, stAppTermF = tf}) =</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="istickedoff">do maybe_memo_var &lt;- memoLookupM idx</span>
<span class="lineno">  543 </span><span class="spaces">       </span><span class="istickedoff">case maybe_memo_var of</span>
<span class="lineno">  544 </span><span class="spaces">         </span><span class="istickedoff">Just memo_var -&gt; ppMemoVar memo_var</span>
<span class="lineno">  545 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; ppTermF prec tf</span></span>
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>--------------------------------------------------------------------------------
<span class="lineno">  549 </span>-- * Memoization Tables and Dealing with Binders in Terms
<span class="lineno">  550 </span>--------------------------------------------------------------------------------
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>-- | An occurrence map maps each shared term index to its term and how many
<span class="lineno">  553 </span>-- times that term occurred
<span class="lineno">  554 </span>type OccurrenceMap = IntMap (Term, Int)
<span class="lineno">  555 </span>
<span class="lineno">  556 </span>-- | Returns map that associates each term index appearing in the term
<span class="lineno">  557 </span>-- to the number of occurrences in the shared term.
<span class="lineno">  558 </span>-- Partially-applied functions are excluded, because let-binding such
<span class="lineno">  559 </span>-- subterms makes terms harder to read.
<span class="lineno">  560 </span>-- The boolean flag indicates whether to descend under lambdas and
<span class="lineno">  561 </span>-- other binders.
<span class="lineno">  562 </span>scTermCount :: Bool -&gt; Term -&gt; OccurrenceMap
<span class="lineno">  563 </span><span class="decl"><span class="istickedoff">scTermCount doBinders t = execState (scTermCountAux doBinders [t]) IntMap.empty</span></span>
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>scTermCountAux :: Bool -&gt; [Term] -&gt; State OccurrenceMap ()
<span class="lineno">  566 </span><span class="decl"><span class="istickedoff">scTermCountAux doBinders = go</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="istickedoff">where go :: [Term] -&gt; State OccurrenceMap ()</span>
<span class="lineno">  568 </span><span class="spaces">        </span><span class="istickedoff">go [] = return <span class="nottickedoff">()</span></span>
<span class="lineno">  569 </span><span class="spaces">        </span><span class="istickedoff">go (t:r) =</span>
<span class="lineno">  570 </span><span class="spaces">          </span><span class="istickedoff">case t of</span>
<span class="lineno">  571 </span><span class="spaces">            </span><span class="istickedoff">Unshared _ -&gt; recurse</span>
<span class="lineno">  572 </span><span class="spaces">            </span><span class="istickedoff">STApp{ stAppIndex = i } -&gt; do</span>
<span class="lineno">  573 </span><span class="spaces">              </span><span class="istickedoff">m &lt;- get</span>
<span class="lineno">  574 </span><span class="spaces">              </span><span class="istickedoff">case IntMap.lookup i m of</span>
<span class="lineno">  575 </span><span class="spaces">                </span><span class="istickedoff">Just (_, n) -&gt; do</span>
<span class="lineno">  576 </span><span class="spaces">                  </span><span class="istickedoff">put $ n `seq` IntMap.insert i (t, n+1) m</span>
<span class="lineno">  577 </span><span class="spaces">                  </span><span class="istickedoff">go r</span>
<span class="lineno">  578 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; do</span>
<span class="lineno">  579 </span><span class="spaces">                  </span><span class="istickedoff">put (IntMap.insert i (<span class="nottickedoff">t</span>, 1) m)</span>
<span class="lineno">  580 </span><span class="spaces">                  </span><span class="istickedoff">recurse</span>
<span class="lineno">  581 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  582 </span><span class="spaces">            </span><span class="istickedoff">recurse = go (r ++ argsAndSubterms t)</span>
<span class="lineno">  583 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  584 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms :: Term -&gt; [Term]</span>
<span class="lineno">  585 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms (asApplyAll -&gt; (f, args)) | not (null args) = f : args</span>
<span class="lineno">  586 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms h =</span>
<span class="lineno">  587 </span><span class="spaces">          </span><span class="istickedoff">case unwrapTermF h of</span>
<span class="lineno">  588 </span><span class="spaces">            </span><span class="istickedoff">Lambda _ t1 _ | not doBinders  -&gt; [t1]</span>
<span class="lineno">  589 </span><span class="spaces">            </span><span class="istickedoff">Pi _ t1 _     | not doBinders  -&gt; [t1]</span>
<span class="lineno">  590 </span><span class="spaces">            </span><span class="istickedoff">Constant{}                     -&gt; []</span>
<span class="lineno">  591 </span><span class="spaces">            </span><span class="istickedoff">FTermF (Recursor _)            -&gt; []</span>
<span class="lineno">  592 </span><span class="spaces">            </span><span class="istickedoff">tf                             -&gt; Fold.toList tf</span></span>
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>
<span class="lineno">  595 </span>-- | Return true if the printing of the given term should be memoized; we do not
<span class="lineno">  596 </span>-- want to memoize the printing of terms that are &quot;too small&quot;
<span class="lineno">  597 </span>shouldMemoizeTerm :: Term -&gt; Bool
<span class="lineno">  598 </span><span class="decl"><span class="istickedoff">shouldMemoizeTerm t =</span>
<span class="lineno">  599 </span><span class="spaces">  </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  600 </span><span class="spaces">    </span><span class="istickedoff">FTermF UnitValue -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="istickedoff">FTermF UnitType -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  602 </span><span class="spaces">    </span><span class="istickedoff">FTermF Sort{} -&gt; False</span>
<span class="lineno">  603 </span><span class="spaces">    </span><span class="istickedoff">FTermF NatLit{} -&gt; False</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="istickedoff">FTermF (ArrayValue _ v) | <span class="nottickedoff">V.length v == 0</span> -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="istickedoff">FTermF StringLit{} -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="istickedoff">Constant{} -&gt; False</span>
<span class="lineno">  607 </span><span class="spaces">    </span><span class="istickedoff">LocalVar{} -&gt; False</span>
<span class="lineno">  608 </span><span class="spaces">    </span><span class="istickedoff">Variable{} -&gt; False</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; True</span></span>
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>-- | Compute a memoization table for a term, and pretty-print the term using the
<span class="lineno">  612 </span>-- table to memoize the printing. Also print the table itself as a sequence of
<span class="lineno">  613 </span>-- let-bindings for the entries in the memoization table. If the flag is true,
<span class="lineno">  614 </span>-- compute a global table, otherwise compute a local table.
<span class="lineno">  615 </span>ppTermWithMemoTable :: Prec -&gt; Bool -&gt; Term -&gt; PPM PPS.Doc
<span class="lineno">  616 </span><span class="decl"><span class="istickedoff">ppTermWithMemoTable prec global_p trm = do</span>
<span class="lineno">  617 </span><span class="spaces">     </span><span class="istickedoff">min_occs &lt;- PPS.ppMinSharing &lt;$&gt; ppOpts &lt;$&gt; ask</span>
<span class="lineno">  618 </span><span class="spaces">     </span><span class="istickedoff">let occPairs = IntMap.assocs $ filterOccurenceMap min_occs global_p $ scTermCount global_p trm</span>
<span class="lineno">  619 </span><span class="spaces">     </span><span class="istickedoff">ppLets global_p occPairs [] (ppTerm' prec trm)</span></span>
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>-- Filter an occurrence map, filtering out terms that only occur
<span class="lineno">  622 </span>-- once, that are &quot;too small&quot; to memoize, and, for the global table, terms
<span class="lineno">  623 </span>-- that are not closed
<span class="lineno">  624 </span>filterOccurenceMap :: Int -&gt; Bool -&gt; OccurrenceMap -&gt; OccurrenceMap
<span class="lineno">  625 </span><span class="decl"><span class="istickedoff">filterOccurenceMap min_occs global_p =</span>
<span class="lineno">  626 </span><span class="spaces">    </span><span class="istickedoff">IntMap.filter</span>
<span class="lineno">  627 </span><span class="spaces">      </span><span class="istickedoff">(\(t,cnt) -&gt;</span>
<span class="lineno">  628 </span><span class="spaces">        </span><span class="istickedoff">cnt &gt;= min_occs &amp;&amp; shouldMemoizeTerm t &amp;&amp;</span>
<span class="lineno">  629 </span><span class="spaces">        </span><span class="istickedoff">(if global_p then termIsClosed t else True))</span></span>
<span class="lineno">  630 </span>
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>-- For each (TermIndex, Term) pair in the occurrence map, pretty-print the
<span class="lineno">  633 </span>-- Term and then add it to the memoization table of subsequent printing. The
<span class="lineno">  634 </span>-- pretty-printing of these terms is reverse-accumulated in the second
<span class="lineno">  635 </span>-- list. Finally, print the given base document in the context of let-bindings
<span class="lineno">  636 </span>-- for the bound terms.
<span class="lineno">  637 </span>ppLets :: Bool -&gt; [(TermIndex, (Term, Int))] -&gt; [(MemoVar, PPS.Doc)] -&gt; PPM PPS.Doc -&gt; PPM PPS.Doc
<span class="lineno">  638 </span>
<span class="lineno">  639 </span>-- Special case: don't print let-binding if there are no bound vars
<span class="lineno">  640 </span><span class="decl"><span class="istickedoff">ppLets _ [] [] baseDoc = baseDoc</span>
<span class="lineno">  641 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  642 </span><span class="spaces"></span><span class="istickedoff">-- When we have run out of (idx,term) pairs, pretty-print a let binding for</span>
<span class="lineno">  643 </span><span class="spaces"></span><span class="istickedoff">-- all the accumulated bindings around the term</span>
<span class="lineno">  644 </span><span class="spaces"></span><span class="istickedoff">ppLets _ [] bindings baseDoc = ppLetBlock (reverse bindings) =&lt;&lt; baseDoc</span>
<span class="lineno">  645 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  646 </span><span class="spaces"></span><span class="istickedoff">-- To add an (idx,term) pair, first check if idx is already bound, and, if</span>
<span class="lineno">  647 </span><span class="spaces"></span><span class="istickedoff">-- not, add a new MemoVar bind it to idx</span>
<span class="lineno">  648 </span><span class="spaces"></span><span class="istickedoff">ppLets global_p ((termIdx, (term,_)):idxs) bindings baseDoc =</span>
<span class="lineno">  649 </span><span class="spaces">  </span><span class="istickedoff">do isBound &lt;- isJust &lt;$&gt; memoLookupM termIdx</span>
<span class="lineno">  650 </span><span class="spaces">     </span><span class="istickedoff">if isBound then ppLets global_p idxs bindings baseDoc else</span>
<span class="lineno">  651 </span><span class="spaces">       </span><span class="istickedoff">do termDoc &lt;- ppTerm' PrecTerm term</span>
<span class="lineno">  652 </span><span class="spaces">          </span><span class="istickedoff">withMemoVar global_p termIdx <span class="nottickedoff">(hash term)</span> $ \memoVarM -&gt;</span>
<span class="lineno">  653 </span><span class="spaces">            </span><span class="istickedoff">let bindings' = case memoVarM of</span>
<span class="lineno">  654 </span><span class="spaces">                  </span><span class="istickedoff">Just memoVar -&gt; (memoVar, termDoc):bindings</span>
<span class="lineno">  655 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">bindings</span></span>
<span class="lineno">  656 </span><span class="spaces">            </span><span class="istickedoff">in  ppLets global_p idxs bindings' baseDoc</span></span>
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>-- | Pretty-print a term inside a binder for a variable of the given name,
<span class="lineno">  659 </span>-- returning both the result of pretty-printing and the fresh name actually used
<span class="lineno">  660 </span>-- for the newly bound variable. If the variable occurs in the term, then do not
<span class="lineno">  661 </span>-- use an underscore for it, and use &quot;_x&quot; instead.
<span class="lineno">  662 </span>--
<span class="lineno">  663 </span>-- Also, pretty-print let-bindings around the term for all subterms that occur
<span class="lineno">  664 </span>-- more than once at the same binding level.
<span class="lineno">  665 </span>ppTermInBinder :: Prec -&gt; LocalName -&gt; Term -&gt; PPM (LocalName, PPS.Doc)
<span class="lineno">  666 </span><span class="decl"><span class="istickedoff">ppTermInBinder prec basename trm =</span>
<span class="lineno">  667 </span><span class="spaces">  </span><span class="istickedoff">let nm = if <span class="tickonlyfalse">basename == &quot;_&quot; &amp;&amp; inBitSet 0 (looseVars trm)</span> then <span class="nottickedoff">&quot;_x&quot;</span></span>
<span class="lineno">  668 </span><span class="spaces">           </span><span class="istickedoff">else basename in</span>
<span class="lineno">  669 </span><span class="spaces">  </span><span class="istickedoff">withBoundVarM nm $ ppTermWithMemoTable prec False trm</span></span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>-- | Pretty-print a term, also adding let-bindings for all subterms that occur
<span class="lineno">  672 </span>-- more than once at the same binding level
<span class="lineno">  673 </span>ppTerm :: PPS.Opts -&gt; Term -&gt; PPS.Doc
<span class="lineno">  674 </span><span class="decl"><span class="istickedoff">ppTerm opts = ppTermWithNames opts emptyDisplayNameEnv</span></span>
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>-- | Like 'ppTerm', but also supply a context of bound names, where the most
<span class="lineno">  677 </span>-- recently-bound variable is listed first in the context
<span class="lineno">  678 </span>ppTermInCtx :: PPS.Opts -&gt; [LocalName] -&gt; Term -&gt; PPS.Doc
<span class="lineno">  679 </span><span class="decl"><span class="nottickedoff">ppTermInCtx opts ctx trm =</span>
<span class="lineno">  680 </span><span class="spaces">  </span><span class="nottickedoff">runPPM opts emptyDisplayNameEnv $</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="nottickedoff">withVarNames (Set.toList (termVarNames trm)) $</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="nottickedoff">flip (Fold.foldl' (\m x -&gt; snd &lt;$&gt; withBoundVarM x m)) ctx $</span>
<span class="lineno">  683 </span><span class="spaces">  </span><span class="nottickedoff">ppTermWithMemoTable PrecTerm True trm</span></span>
<span class="lineno">  684 </span>
<span class="lineno">  685 </span>-- | Pretty-print a term and render it to a string, using the given options
<span class="lineno">  686 </span>scPrettyTerm :: PPS.Opts -&gt; Term -&gt; String
<span class="lineno">  687 </span><span class="decl"><span class="istickedoff">scPrettyTerm opts t =</span>
<span class="lineno">  688 </span><span class="spaces">  </span><span class="istickedoff">PPS.render opts $ ppTerm opts t</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>-- | Like 'scPrettyTerm', but also supply a context of bound names, where the
<span class="lineno">  691 </span>-- most recently-bound variable is listed first in the context
<span class="lineno">  692 </span>scPrettyTermInCtx :: PPS.Opts -&gt; [LocalName] -&gt; Term -&gt; String
<span class="lineno">  693 </span><span class="decl"><span class="istickedoff">scPrettyTermInCtx opts ctx trm =</span>
<span class="lineno">  694 </span><span class="spaces">  </span><span class="istickedoff">PPS.render opts $</span>
<span class="lineno">  695 </span><span class="spaces">  </span><span class="istickedoff">runPPM opts emptyDisplayNameEnv $</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="istickedoff">withVarNames (Set.toList (termVarNames trm)) $</span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="istickedoff">flip (Fold.foldl' <span class="nottickedoff">(\m x -&gt; snd &lt;$&gt; withBoundVarM x m)</span>) ctx $</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="istickedoff">ppTermWithMemoTable PrecTerm False trm</span></span>
<span class="lineno">  699 </span>
<span class="lineno">  700 </span>
<span class="lineno">  701 </span>-- | Pretty-print a term and render it to a string
<span class="lineno">  702 </span>showTerm :: Term -&gt; String
<span class="lineno">  703 </span><span class="decl"><span class="istickedoff">showTerm t = scPrettyTerm PPS.defaultOpts t</span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>
<span class="lineno">  706 </span>--------------------------------------------------------------------------------
<span class="lineno">  707 </span>-- * Pretty-printers with naming environments
<span class="lineno">  708 </span>--------------------------------------------------------------------------------
<span class="lineno">  709 </span>
<span class="lineno">  710 </span>-- | Pretty-print a term, also adding let-bindings for all subterms that occur
<span class="lineno">  711 </span>-- more than once at the same binding level
<span class="lineno">  712 </span>ppTermWithNames :: PPS.Opts -&gt; DisplayNameEnv -&gt; Term -&gt; PPS.Doc
<span class="lineno">  713 </span><span class="decl"><span class="istickedoff">ppTermWithNames opts ne trm =</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff">runPPM opts ne $</span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="istickedoff">withVarNames (Set.toList (termVarNames trm)) $</span>
<span class="lineno">  716 </span><span class="spaces">  </span><span class="istickedoff">ppTermWithMemoTable PrecTerm True trm</span></span>
<span class="lineno">  717 </span>
<span class="lineno">  718 </span>showTermWithNames :: PPS.Opts -&gt; DisplayNameEnv -&gt; Term -&gt; String
<span class="lineno">  719 </span><span class="decl"><span class="istickedoff">showTermWithNames opts ne trm =</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">PPS.render opts $ ppTermWithNames opts ne trm</span></span>
<span class="lineno">  721 </span>
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>ppTermContainerWithNames ::
<span class="lineno">  724 </span>  (Traversable m) =&gt;
<span class="lineno">  725 </span>  (m PPS.Doc -&gt; PPS.Doc) -&gt;
<span class="lineno">  726 </span>  PPS.Opts -&gt; DisplayNameEnv -&gt; m Term -&gt; PPS.Doc
<span class="lineno">  727 </span><span class="decl"><span class="istickedoff">ppTermContainerWithNames ppContainer opts ne trms =</span>
<span class="lineno">  728 </span><span class="spaces">  </span><span class="istickedoff">let min_occs = PPS.ppMinSharing opts</span>
<span class="lineno">  729 </span><span class="spaces">      </span><span class="istickedoff">global_p = True</span>
<span class="lineno">  730 </span><span class="spaces">      </span><span class="istickedoff">occPairs = IntMap.assocs $</span>
<span class="lineno">  731 </span><span class="spaces">                   </span><span class="istickedoff">filterOccurenceMap min_occs global_p $</span>
<span class="lineno">  732 </span><span class="spaces">                   </span><span class="istickedoff">flip execState mempty $</span>
<span class="lineno">  733 </span><span class="spaces">                   </span><span class="istickedoff">traverse (\t -&gt; scTermCountAux global_p [t]) $</span>
<span class="lineno">  734 </span><span class="spaces">                   </span><span class="istickedoff">trms</span>
<span class="lineno">  735 </span><span class="spaces">   </span><span class="istickedoff">in runPPM opts ne $</span>
<span class="lineno">  736 </span><span class="spaces">      </span><span class="istickedoff">withVarNames (Set.toList (Fold.foldMap termVarNames trms)) $</span>
<span class="lineno">  737 </span><span class="spaces">      </span><span class="istickedoff">ppLets global_p occPairs []</span>
<span class="lineno">  738 </span><span class="spaces">        </span><span class="istickedoff">(ppContainer &lt;$&gt; traverse (ppTerm' PrecTerm) trms)</span></span>

</pre>
</body>
</html>
