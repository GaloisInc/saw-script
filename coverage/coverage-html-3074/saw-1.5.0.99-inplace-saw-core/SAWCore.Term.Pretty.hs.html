<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    2 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    3 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    4 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    5 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    6 </span>
<span class="lineno">    7 </span>{- |
<span class="lineno">    8 </span>Module      : SAWCore.Term.Pretty
<span class="lineno">    9 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">   10 </span>License     : BSD3
<span class="lineno">   11 </span>Maintainer  : huffman@galois.com
<span class="lineno">   12 </span>Stability   : experimental
<span class="lineno">   13 </span>Portability : non-portable (language extensions)
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>Guidance for folks wishing to print SAWCore terms:
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>If you have the `SharedContext` and can afford to run in `IO`, use
<span class="lineno">   18 </span>`ppTerm`, or `prettyTerm` if you want a `Doc`. These functions are
<span class="lineno">   19 </span>found in `SAWCore.Term.Certified` (rather than here) so they can get
<span class="lineno">   20 </span>the printing environment from the `SharedContext`, and should be
<span class="lineno">   21 </span>imported from `SAWCore.SharedTerm`.
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>If you do not have the `SharedContext`, or are trying to print from
<span class="lineno">   24 </span>pure code and changing this is infeasible, use the pure versions
<span class="lineno">   25 </span>defined herein: `ppTermPure` or `prettyTermPure` for a `Doc`.
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>If you do not have the prettyprinting options value either, there is
<span class="lineno">   28 </span>`ppTermPureDefaults`, which uses the default prettyprinting options.
<span class="lineno">   29 </span>Use of this should be minimized, because if we're going to give the
<span class="lineno">   30 </span>user control over printing we should actually honor their settings.
<span class="lineno">   31 </span>This function may be removed in the long run.
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>(Referencing SAWSupport.Pretty's defaultOpts value explicitly instead
<span class="lineno">   34 </span>is probably preferred, because that makes it clear to passersby that
<span class="lineno">   35 </span>it isn't really right.)
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>The following additional functions allow explicit manipulation of the
<span class="lineno">   38 </span>name context used by the SAWCore term prettyprinting logic, and should
<span class="lineno">   39 </span>therefore only be used from code where that makes sense:
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>- `ppTermWithNames` (formerly @showTermWithNames@) takes an explicit
<span class="lineno">   42 </span>  `DisplayNameEnv`.
<span class="lineno">   43 </span>- `prettyTermWithEnv` (formerly @ppTermWithNames@) is the `Doc` version.
<span class="lineno">   44 </span>- `prettyTermWithNameList` (formerly @ppTermInCtx@) takes a list of
<span class="lineno">   45 </span>  `VarName` to prepare a `DisplayNameEnv`.
<span class="lineno">   46 </span>- `prettyTermContainerWithEnv` (formerly @ppTermContainerWithNames@)
<span class="lineno">   47 </span>  takes an explicit `DisplayNameEnv` and prints a `Traversable` full of
<span class="lineno">   48 </span>  terms.
<span class="lineno">   49 </span>-}
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>module SAWCore.Term.Pretty
<span class="lineno">   52 </span>  ( prettyTermPure
<span class="lineno">   53 </span>  , ppTermPure
<span class="lineno">   54 </span>  , ppTermPureDefaults
<span class="lineno">   55 </span>  , ppTermWithEnv
<span class="lineno">   56 </span>  , prettyNameWithEnv
<span class="lineno">   57 </span>  , prettyTermWithEnv
<span class="lineno">   58 </span>  , prettyTermWithNameList
<span class="lineno">   59 </span>  , prettyTermContainerWithEnv
<span class="lineno">   60 </span>  , scTermCount
<span class="lineno">   61 </span>  , shouldMemoizeTerm
<span class="lineno">   62 </span>  ) where
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>import Data.Char (intToDigit, isDigit)
<span class="lineno">   65 </span>import Data.List ((\\))
<span class="lineno">   66 </span>import Data.Maybe (isJust)
<span class="lineno">   67 </span>import Control.Monad.Reader (MonadReader(..), Reader, asks, runReader)
<span class="lineno">   68 </span>import Control.Monad.State.Strict (MonadState(..), State, evalState, execState, get, modify)
<span class="lineno">   69 </span>import qualified Data.Foldable as Fold
<span class="lineno">   70 </span>import Data.Hashable (hash)
<span class="lineno">   71 </span>import Data.IntSet (IntSet)
<span class="lineno">   72 </span>import qualified Data.IntSet as IntSet
<span class="lineno">   73 </span>import qualified Data.Text as Text
<span class="lineno">   74 </span>import qualified Data.Map as Map
<span class="lineno">   75 </span>import Data.Set (Set)
<span class="lineno">   76 </span>import qualified Data.Set as Set
<span class="lineno">   77 </span>import qualified Data.Vector as V
<span class="lineno">   78 </span>import Numeric (showHex)
<span class="lineno">   79 </span>import Prettyprinter
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">   82 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>import SAWSupport.Pretty (prettyNat, prettyTypeConstraint)
<span class="lineno">   85 </span>import qualified SAWSupport.Pretty as PPS (
<span class="lineno">   86 </span>    Style(..), Doc, MemoStyle(..), Opts(..), defaultOpts, render, prettyLetBlock
<span class="lineno">   87 </span> )
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>import SAWCore.Panic (panic)
<span class="lineno">   90 </span>import SAWCore.Name
<span class="lineno">   91 </span>import SAWCore.Recognizer
<span class="lineno">   92 </span>import SAWCore.Term.Functor
<span class="lineno">   93 </span>import SAWCore.Term.Raw
<span class="lineno">   94 </span>import SAWCore.URI
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- | Test if a depth is &quot;allowed&quot;, meaning not greater than the max depth
<span class="lineno">   97 </span>depthAllowed :: PPS.Opts -&gt; Int -&gt; Bool
<span class="lineno">   98 </span><span class="decl"><span class="istickedoff">depthAllowed (PPS.Opts { ppMaxDepth = Just max_d }) d = d &lt; max_d</span>
<span class="lineno">   99 </span><span class="spaces"></span><span class="istickedoff">depthAllowed _ _ = True</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- | Precedence levels, each of which corresponds to a parsing nonterminal
<span class="lineno">  102 </span>data Prec
<span class="lineno">  103 </span>  = PrecCommas -- ^ Nonterminal @sepBy(Term, \',\')@
<span class="lineno">  104 </span>  | PrecTerm   -- ^ Nonterminal @Term@
<span class="lineno">  105 </span>  | PrecLambda -- ^ Nonterminal @LTerm@
<span class="lineno">  106 </span>  | PrecProd   -- ^ Nonterminal @ProdTerm@
<span class="lineno">  107 </span>  | PrecApp    -- ^ Nonterminal @AppTerm@
<span class="lineno">  108 </span>  | PrecArg    -- ^ Nonterminal @AtomTerm@
<span class="lineno">  109 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- | Test if the first precedence &quot;contains&quot; the second, meaning that terms at
<span class="lineno">  112 </span>-- the latter precedence level can be printed in the context of the former
<span class="lineno">  113 </span>-- without parentheses.
<span class="lineno">  114 </span>precContains :: Prec -&gt; Prec -&gt; Bool
<span class="lineno">  115 </span><span class="decl"><span class="istickedoff">precContains x y = x &lt;= y</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- | Optionally print parentheses around a document, iff the incoming, outer
<span class="lineno">  118 </span>-- precedence (listed first) contains (as in 'precContains') the required
<span class="lineno">  119 </span>-- precedence (listed second) for printing the given document.
<span class="lineno">  120 </span>--
<span class="lineno">  121 </span>-- Stated differently: @prettyParensPrec p1 p2 d@ means we are pretty-printing in a
<span class="lineno">  122 </span>-- term context that requires precedence @p1@, but @d@ was pretty-printed at
<span class="lineno">  123 </span>-- precedence level @p2@. If @p1@ does not contain @p2@ (e.g., if @p1@ is
<span class="lineno">  124 </span>-- 'PrecArg', meaning we are pretty-printing the argument of an application, and
<span class="lineno">  125 </span>-- @p2@ is 'PrecLambda', meaning the construct we are pretty-printing is a
<span class="lineno">  126 </span>-- lambda or pi abstraction) then add parentheses.
<span class="lineno">  127 </span>prettyParensPrec :: Prec -&gt; Prec -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  128 </span><span class="decl"><span class="istickedoff">prettyParensPrec p1 p2 d</span>
<span class="lineno">  129 </span><span class="spaces">  </span><span class="istickedoff">| precContains p1 p2 = d</span>
<span class="lineno">  130 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = parens $ align d</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>----------------------------------------------------------------------
<span class="lineno">  134 </span>-- * Local Variable Namings
<span class="lineno">  135 </span>----------------------------------------------------------------------
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>-- | Local variable namings, which map each deBruijn index in scope to a unique
<span class="lineno">  138 </span>-- string to be used to print it. This mapping is given by position in a list.
<span class="lineno">  139 </span>-- Renamings for named variables are in an 'IntMap' indexed by 'VarIndex'.
<span class="lineno">  140 </span>-- The third argument caches the set of all used or reserved names;
<span class="lineno">  141 </span>-- fresh 'LocalName's are chosen while avoiding names in this set.
<span class="lineno">  142 </span>data VarNaming = VarNaming [LocalName] (IntMap LocalName) (Set LocalName)
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>-- | The empty local variable context
<span class="lineno">  145 </span>emptyVarNaming :: Set LocalName -&gt; VarNaming
<span class="lineno">  146 </span><span class="decl"><span class="istickedoff">emptyVarNaming reserved = VarNaming <span class="nottickedoff">[]</span> IntMap.empty reserved</span></span>
<span class="lineno">  147 </span>
<span class="lineno">  148 </span>-- | Look up a string to use for a 'VarName'.
<span class="lineno">  149 </span>lookupVarName :: VarNaming -&gt; VarName -&gt; LocalName
<span class="lineno">  150 </span><span class="decl"><span class="istickedoff">lookupVarName (VarNaming _ renames _) vn =</span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="istickedoff">case IntMap.lookup (vnIndex vn) renames of</span>
<span class="lineno">  152 </span><span class="spaces">    </span><span class="istickedoff">Just alias -&gt; alias</span>
<span class="lineno">  153 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">vnName vn</span></span></span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>-- | Generate a fresh name from a base name that does not clash with any names
<span class="lineno">  156 </span>-- already in a given list, unless it is &quot;_&quot;, in which case return it as is
<span class="lineno">  157 </span>freshName :: Set LocalName -&gt; LocalName -&gt; LocalName
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">freshName used name</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">| name == &quot;_&quot; = name</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">| Set.member name used = freshName used (nextName name)</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = name</span></span>
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>-- | Generate a variant of a name by incrementing the number at the
<span class="lineno">  164 </span>-- end, or appending the number 1 if there is none.
<span class="lineno">  165 </span>nextName :: LocalName -&gt; LocalName
<span class="lineno">  166 </span><span class="decl"><span class="istickedoff">nextName = Text.pack . reverse . go . reverse . Text.unpack</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">go :: String -&gt; String</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">go (c : cs)</span>
<span class="lineno">  170 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">c == '9'</span>  = <span class="nottickedoff">'0' : go cs</span></span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">isDigit c</span> = <span class="nottickedoff">succ c : cs</span></span>
<span class="lineno">  172 </span><span class="spaces">    </span><span class="istickedoff">go cs = '1' : cs</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- | Add a new variable with the given 'VarName' to the 'VarNaming',
<span class="lineno">  175 </span>-- returning both the chosen fresh name and the new 'VarNaming'.
<span class="lineno">  176 </span>-- As a special case, if the base name is &quot;_&quot;, it is not modified.
<span class="lineno">  177 </span>insertVarNaming :: VarNaming -&gt; VarName -&gt; (LocalName, VarNaming)
<span class="lineno">  178 </span><span class="decl"><span class="istickedoff">insertVarNaming (VarNaming names renames used) (VarName i name) =</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">let nm = freshName used name</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">in (nm, VarNaming <span class="nottickedoff">names</span> (IntMap.insert i nm renames) (Set.insert nm used))</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>-- | Compute the set of all free 'VarName's in a term.
<span class="lineno">  183 </span>termVarNames :: Term -&gt; Set VarName
<span class="lineno">  184 </span><span class="decl"><span class="istickedoff">termVarNames t0 = evalState (go t0) IntMap.empty</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">go :: Term -&gt; State (IntMap (Set VarName)) (Set VarName)</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">go tm =</span>
<span class="lineno">  188 </span><span class="spaces">      </span><span class="istickedoff">case tm of</span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">STApp { stAppIndex = i, stAppTermF = tf } -&gt;</span>
<span class="lineno">  190 </span><span class="spaces">          </span><span class="istickedoff">do memo &lt;- get</span>
<span class="lineno">  191 </span><span class="spaces">             </span><span class="istickedoff">case IntMap.lookup i memo of</span>
<span class="lineno">  192 </span><span class="spaces">               </span><span class="istickedoff">Just vars -&gt; pure vars</span>
<span class="lineno">  193 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  194 </span><span class="spaces">                 </span><span class="istickedoff">do vars &lt;- termf &lt;$&gt; traverse go tf</span>
<span class="lineno">  195 </span><span class="spaces">                    </span><span class="istickedoff">modify (IntMap.insert i vars)</span>
<span class="lineno">  196 </span><span class="spaces">                    </span><span class="istickedoff">pure vars</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">termf :: TermF (Set VarName) -&gt; Set VarName</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">termf tf =</span>
<span class="lineno">  199 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno">  200 </span><span class="spaces">        </span><span class="istickedoff">FTermF ftf -&gt; Fold.fold ftf</span>
<span class="lineno">  201 </span><span class="spaces">        </span><span class="istickedoff">App e1 e2 -&gt; Set.union e1 e2</span>
<span class="lineno">  202 </span><span class="spaces">        </span><span class="istickedoff">Lambda x e1 e2 -&gt; Set.union e1 (Set.delete x e2)</span>
<span class="lineno">  203 </span><span class="spaces">        </span><span class="istickedoff">Pi x e1 e2 -&gt; Set.union e1 (Set.delete x e2)</span>
<span class="lineno">  204 </span><span class="spaces">        </span><span class="istickedoff">Constant _ -&gt; Set.empty</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="istickedoff">Variable vn e1 -&gt; Set.insert vn e1</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>--------------------------------------------------------------------------------
<span class="lineno">  208 </span>-- * Pretty-printing monad
<span class="lineno">  209 </span>--------------------------------------------------------------------------------
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | Memoization variables contain several pieces of information about the term
<span class="lineno">  212 </span>-- they bind. What subset is displayed when they're printed is governed by the
<span class="lineno">  213 </span>-- 'ppMemoStyle' field of 'PPS.Opts', in tandem with 'ppMemoVar'.
<span class="lineno">  214 </span>data MemoVar =
<span class="lineno">  215 </span>  MemoVar
<span class="lineno">  216 </span>    {
<span class="lineno">  217 </span>      -- | A unique value - like a deBruijn index, but evinced only during
<span class="lineno">  218 </span>      -- printing when a term is to be memoized.
<span class="lineno">  219 </span>      <span class="nottickedoff"><span class="decl"><span class="nottickedoff">memoFresh</span></span></span> :: Int,
<span class="lineno">  220 </span>      -- | A likely-unique value - the hash of the term this 'MemoVar'
<span class="lineno">  221 </span>      -- represents.
<span class="lineno">  222 </span>      <span class="nottickedoff"><span class="decl"><span class="nottickedoff">memoHash</span></span></span> :: Int }
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | The local state used by pretty-printing computations
<span class="lineno">  225 </span>data PPState =
<span class="lineno">  226 </span>  PPState
<span class="lineno">  227 </span>  {
<span class="lineno">  228 </span>    -- | The global pretty-printing options
<span class="lineno">  229 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppOpts</span></span></span> :: PPS.Opts,
<span class="lineno">  230 </span>    -- | The current depth of printing
<span class="lineno">  231 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppDepth</span></span></span> :: Int,
<span class="lineno">  232 </span>    -- | The current naming for the local variables
<span class="lineno">  233 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppNaming</span></span></span> :: VarNaming,
<span class="lineno">  234 </span>    -- | The top-level naming environment
<span class="lineno">  235 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppNamingEnv</span></span></span> :: DisplayNameEnv,
<span class="lineno">  236 </span>    -- | A source of freshness for memoization variables
<span class="lineno">  237 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppMemoFresh</span></span></span> :: Int,
<span class="lineno">  238 </span>    -- | Memoization table for the global, closed terms, mapping term indices to
<span class="lineno">  239 </span>    -- &quot;memoization variables&quot; that are in scope
<span class="lineno">  240 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppGlobalMemoTable</span></span></span> :: IntMap MemoVar,
<span class="lineno">  241 </span>    -- | Memoization table for terms at the current binding level, mapping term
<span class="lineno">  242 </span>    -- indices to &quot;memoization variables&quot; that are in scope
<span class="lineno">  243 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppLocalMemoTable</span></span></span> :: IntMap MemoVar,
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>    -- | Terms to not inline because they're memoized (see 'withMemoVar')
<span class="lineno">  246 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">ppNoInlineIdx</span></span></span> :: Set TermIndex
<span class="lineno">  247 </span>  }
<span class="lineno">  248 </span>
<span class="lineno">  249 </span>emptyPPState :: PPS.Opts -&gt; DisplayNameEnv -&gt; PPState
<span class="lineno">  250 </span><span class="decl"><span class="istickedoff">emptyPPState opts ne =</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">PPState { ppOpts = opts,</span>
<span class="lineno">  252 </span><span class="spaces">            </span><span class="istickedoff">ppDepth = 0,</span>
<span class="lineno">  253 </span><span class="spaces">            </span><span class="istickedoff">ppNaming = emptyVarNaming (Map.keysSet (displayIndexes ne)),</span>
<span class="lineno">  254 </span><span class="spaces">            </span><span class="istickedoff">ppNamingEnv = ne,</span>
<span class="lineno">  255 </span><span class="spaces">            </span><span class="istickedoff">ppMemoFresh = 1,</span>
<span class="lineno">  256 </span><span class="spaces">            </span><span class="istickedoff">ppGlobalMemoTable = IntMap.empty,</span>
<span class="lineno">  257 </span><span class="spaces">            </span><span class="istickedoff">ppLocalMemoTable = IntMap.empty,</span>
<span class="lineno">  258 </span><span class="spaces">            </span><span class="istickedoff">ppNoInlineIdx = mempty</span>
<span class="lineno">  259 </span><span class="spaces">   </span><span class="istickedoff">}</span></span>
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>-- | The pretty-printing monad
<span class="lineno">  262 </span>--
<span class="lineno">  263 </span>-- XXX: let's find a better name than PPM
<span class="lineno">  264 </span>newtype PPM a = PPM (Reader PPState a)
<span class="lineno">  265 </span>              deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>)
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>-- | Run a pretty-printing computation in a top-level, empty context
<span class="lineno">  268 </span>runPPM :: PPS.Opts -&gt; DisplayNameEnv -&gt; PPM a -&gt; a
<span class="lineno">  269 </span><span class="decl"><span class="istickedoff">runPPM opts ne (PPM m) = runReader m $ emptyPPState opts ne</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>instance <span class="decl"><span class="istickedoff">MonadReader PPState PPM</span></span> where
<span class="lineno">  272 </span>  <span class="decl"><span class="istickedoff">ask = PPM ask</span></span>
<span class="lineno">  273 </span>  <span class="decl"><span class="istickedoff">local f (PPM m) = PPM $ local f m</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | Test if a given term index is memoized, returning its memoization variable
<span class="lineno">  276 </span>-- if so and otherwise returning 'Nothing'
<span class="lineno">  277 </span>memoLookupM :: TermIndex -&gt; PPM (Maybe MemoVar)
<span class="lineno">  278 </span><span class="decl"><span class="istickedoff">memoLookupM idx =</span>
<span class="lineno">  279 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- ask</span>
<span class="lineno">  280 </span><span class="spaces">     </span><span class="istickedoff">return $ case (IntMap.lookup idx (ppGlobalMemoTable s),</span>
<span class="lineno">  281 </span><span class="spaces">                    </span><span class="istickedoff">IntMap.lookup idx (ppLocalMemoTable s)) of</span>
<span class="lineno">  282 </span><span class="spaces">       </span><span class="istickedoff">(res@(Just _), _) -&gt; res</span>
<span class="lineno">  283 </span><span class="spaces">       </span><span class="istickedoff">(_, res@(Just _)) -&gt; res</span>
<span class="lineno">  284 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>-- | Run a pretty-printing computation at the next greater depth, returning the
<span class="lineno">  287 </span>-- default value if the max depth has been exceeded
<span class="lineno">  288 </span>atNextDepthM :: a -&gt; PPM a -&gt; PPM a
<span class="lineno">  289 </span><span class="decl"><span class="istickedoff">atNextDepthM dflt m =</span>
<span class="lineno">  290 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- ask</span>
<span class="lineno">  291 </span><span class="spaces">     </span><span class="istickedoff">let new_depth = ppDepth s + 1</span>
<span class="lineno">  292 </span><span class="spaces">     </span><span class="istickedoff">if <span class="tickonlytrue">depthAllowed (ppOpts s) new_depth</span></span>
<span class="lineno">  293 </span><span class="spaces">       </span><span class="istickedoff">then local (\_ -&gt; s { ppDepth = new_depth }) m</span>
<span class="lineno">  294 </span><span class="spaces">       </span><span class="istickedoff">else <span class="nottickedoff">return dflt</span></span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Run a pretty-printing computation in the context of a new bound variable,
<span class="lineno">  297 </span>-- also erasing the local memoization table (which is no longer valid in an
<span class="lineno">  298 </span>-- extended variable context) during that computation. Return the result of the
<span class="lineno">  299 </span>-- computation and also the name that was actually used for the bound variable.
<span class="lineno">  300 </span>withBoundVarM :: VarName -&gt; PPM a -&gt; PPM (LocalName, a)
<span class="lineno">  301 </span><span class="decl"><span class="istickedoff">withBoundVarM basename m =</span>
<span class="lineno">  302 </span><span class="spaces">  </span><span class="istickedoff">do st &lt;- ask</span>
<span class="lineno">  303 </span><span class="spaces">     </span><span class="istickedoff">let (var, naming) = insertVarNaming (ppNaming st) basename</span>
<span class="lineno">  304 </span><span class="spaces">     </span><span class="istickedoff">ret &lt;- local (\_ -&gt; st { ppNaming = naming,</span>
<span class="lineno">  305 </span><span class="spaces">                              </span><span class="istickedoff">ppLocalMemoTable = IntMap.empty }) m</span>
<span class="lineno">  306 </span><span class="spaces">     </span><span class="istickedoff">return (var, ret)</span></span>
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>-- | Run a pretty-printing computation in a context with an additional
<span class="lineno">  309 </span>-- declared 'VarName'.
<span class="lineno">  310 </span>withVarName :: VarName -&gt; PPM a -&gt; PPM a
<span class="lineno">  311 </span><span class="decl"><span class="istickedoff">withVarName vn =</span>
<span class="lineno">  312 </span><span class="spaces">  </span><span class="istickedoff">local (\s -&gt; s { ppNaming = snd (insertVarNaming (ppNaming s) vn) })</span></span>
<span class="lineno">  313 </span>
<span class="lineno">  314 </span>-- | Run a pretty-printing computation in a context with multiple
<span class="lineno">  315 </span>-- additional declared 'VarName's.
<span class="lineno">  316 </span>-- Names are reserved in left-to-right order, so names near the head
<span class="lineno">  317 </span>-- of the list take priority in case of duplicate base names.
<span class="lineno">  318 </span>withVarNames :: [VarName] -&gt; PPM a -&gt; PPM a
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">withVarNames vs m = foldr withVarName m vs</span></span>
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>-- | Attempt to memoize the given term (index) 'termIdx' and run a computation
<span class="lineno">  322 </span>-- in the context that the attempt produces. If memoization succeeds, the
<span class="lineno">  323 </span>-- context will contain a binding (global in scope if 'global_p' is set, local
<span class="lineno">  324 </span>-- if not) of a fresh memoization variable to the term, and the fresh variable
<span class="lineno">  325 </span>-- will be supplied to the computation. If memoization fails, the context will
<span class="lineno">  326 </span>-- not contain such a binding, and no fresh variable will be supplied.
<span class="lineno">  327 </span>withMemoVar :: Bool -&gt; TermIndex -&gt; Int -&gt; (Maybe MemoVar -&gt; PPM a) -&gt; PPM a
<span class="lineno">  328 </span><span class="decl"><span class="istickedoff">withMemoVar global_p termIdx termHash f =</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno">  330 </span><span class="spaces">    </span><span class="istickedoff">memoFresh &lt;- asks ppMemoFresh</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">let memoVar = MemoVar { memoFresh = memoFresh, memoHash = <span class="nottickedoff">termHash</span> }</span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="istickedoff">memoFreshSkips &lt;- asks (PPS.ppNoInlineMemoFresh . ppOpts)</span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">termIdxSkips &lt;- asks ppNoInlineIdx</span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="istickedoff">case memoFreshSkips of</span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="istickedoff">-- Even if we must skip this memoization variable, we still want to</span>
<span class="lineno">  336 </span><span class="spaces">      </span><span class="istickedoff">-- &quot;pretend&quot; we memoized by calling `freshen`, so that non-inlined</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="istickedoff">-- memoization identifiers are kept constant between two</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="istickedoff">-- otherwise-identical terms with differing inline strategies.</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff">(skip:skips)</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">skip == memoFresh</span> -&gt;</span>
<span class="lineno">  341 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">local (freshen . addIdxSkip . setMemoFreshSkips skips) (f Nothing)</span></span>
<span class="lineno">  342 </span><span class="spaces">      </span><span class="istickedoff">_</span>
<span class="lineno">  343 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlyfalse">termIdx `Set.member` termIdxSkips</span> -&gt; <span class="nottickedoff">f Nothing</span></span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; local (freshen . bind memoVar) (f (Just memoVar))</span>
<span class="lineno">  345 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  346 </span><span class="spaces">    </span><span class="istickedoff">bind = if global_p then bindGlobal else bindLocal</span>
<span class="lineno">  347 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">bindGlobal memoVar PPState{ .. } =</span>
<span class="lineno">  349 </span><span class="spaces">      </span><span class="istickedoff">PPState { ppGlobalMemoTable = IntMap.insert termIdx memoVar ppGlobalMemoTable, .. }</span>
<span class="lineno">  350 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">bindLocal memoVar PPState{ .. } =</span>
<span class="lineno">  352 </span><span class="spaces">      </span><span class="istickedoff">PPState { ppLocalMemoTable = IntMap.insert termIdx memoVar ppLocalMemoTable, <span class="nottickedoff"><span class="istickedoff">..</span></span> }</span>
<span class="lineno">  353 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">setMemoFreshSkips memoSkips PPState{ ppOpts = PPS.Opts{ .. }, .. } =</span></span>
<span class="lineno">  355 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PPState { ppOpts = PPS.Opts { ppNoInlineMemoFresh = memoSkips, ..}, ..}</span></span>
<span class="lineno">  356 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">addIdxSkip PPState{ .. } =</span></span>
<span class="lineno">  358 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">PPState { ppNoInlineIdx = Set.insert termIdx ppNoInlineIdx, .. }</span></span>
<span class="lineno">  359 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">freshen PPState{ .. } =</span>
<span class="lineno">  361 </span><span class="spaces">      </span><span class="istickedoff">PPState { ppMemoFresh = ppMemoFresh + 1, .. }</span></span>
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>--------------------------------------------------------------------------------
<span class="lineno">  364 </span>-- * The Pretty-Printing of Specific Constructs
<span class="lineno">  365 </span>--------------------------------------------------------------------------------
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>-- | Pretty-print an identifier
<span class="lineno">  368 </span>prettyIdent :: Ident -&gt; PPS.Doc
<span class="lineno">  369 </span><span class="decl"><span class="istickedoff">prettyIdent = viaShow</span></span>
<span class="lineno">  370 </span>
<span class="lineno">  371 </span>-- | Pretty-print a memoization variable, according to 'ppMemoStyle'
<span class="lineno">  372 </span>prettyMemoVar :: MemoVar -&gt; PPM PPS.Doc
<span class="lineno">  373 </span><span class="decl"><span class="istickedoff">prettyMemoVar MemoVar{..} = asks (PPS.ppMemoStyle . ppOpts) &gt;&gt;= \case</span>
<span class="lineno">  374 </span><span class="spaces">  </span><span class="istickedoff">PPS.Incremental -&gt;</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="istickedoff">pure (&quot;x@&quot; &lt;&gt; pretty memoFresh)</span>
<span class="lineno">  376 </span><span class="spaces">  </span><span class="istickedoff">PPS.Hash prefixLen -&gt;</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (&quot;x@&quot; &lt;&gt; pretty (take prefixLen hashStr))</span></span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">PPS.HashIncremental prefixLen -&gt;</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">pure (&quot;x&quot; &lt;&gt; pretty memoFresh &lt;&gt; &quot;@&quot; &lt;&gt; pretty (take prefixLen hashStr))</span></span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">hashStr = showHex (abs memoHash) &quot;&quot;</span></span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>-- | Pretty-print an application to 0 or more arguments at the given precedence
<span class="lineno">  384 </span>prettyAppList :: Prec -&gt; PPS.Doc -&gt; [PPS.Doc] -&gt; PPS.Doc
<span class="lineno">  385 </span><span class="decl"><span class="istickedoff">prettyAppList _ f [] = <span class="nottickedoff">f</span></span>
<span class="lineno">  386 </span><span class="spaces"></span><span class="istickedoff">prettyAppList p f args = prettyParensPrec p PrecApp $ group $ hang 2 $ vsep (f : args)</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>-- | Pretty-print &quot;let x = t ... x' = t' in body&quot;
<span class="lineno">  389 </span>prettyLetBlock :: [(MemoVar, PPS.Doc)] -&gt; PPS.Doc -&gt; PPM PPS.Doc
<span class="lineno">  390 </span><span class="decl"><span class="istickedoff">prettyLetBlock defs body =</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno">  392 </span><span class="spaces">    </span><span class="istickedoff">lets &lt;- mapM ppEqn defs</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="istickedoff">pure $ PPS.prettyLetBlock lets body</span>
<span class="lineno">  394 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="istickedoff">ppEqn (var,d) =</span>
<span class="lineno">  396 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno">  397 </span><span class="spaces">        </span><span class="istickedoff">mv &lt;- prettyMemoVar var</span>
<span class="lineno">  398 </span><span class="spaces">        </span><span class="istickedoff">pure $ (mv, d)</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>-- | Pretty-print pairs as &quot;(x, y)&quot;
<span class="lineno">  402 </span>prettyPair :: Prec -&gt; PPS.Doc -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  403 </span><span class="decl"><span class="istickedoff">prettyPair prec x y = prettyParensPrec prec PrecCommas (group (vcat [x &lt;&gt; pretty ',', y]))</span></span>
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>-- | Pretty-print pair types as &quot;x * y&quot;
<span class="lineno">  406 </span>prettyPairType :: Prec -&gt; PPS.Doc -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  407 </span><span class="decl"><span class="istickedoff">prettyPairType prec x y = prettyParensPrec prec PrecProd (x &lt;+&gt; pretty '*' &lt;+&gt; y)</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>-- | Pretty-print records (if the flag is 'False') or record types (if the flag
<span class="lineno">  410 </span>-- is 'True'), where the latter are preceded by the string @#@, either as:
<span class="lineno">  411 </span>--
<span class="lineno">  412 </span>-- * @(val1, val2, .., valn)@, if the record represents a tuple; OR
<span class="lineno">  413 </span>--
<span class="lineno">  414 </span>-- * @{ fld1 op val1, ..., fldn op valn }@ otherwise, where @op@ is @::@ for
<span class="lineno">  415 </span>--   types and @=@ for values.
<span class="lineno">  416 </span>prettyRecord :: Bool -&gt; [(FieldName, PPS.Doc)] -&gt; PPS.Doc
<span class="lineno">  417 </span><span class="decl"><span class="istickedoff">prettyRecord type_p alist =</span>
<span class="lineno">  418 </span><span class="spaces">  </span><span class="istickedoff">(if type_p then (pretty '#' &lt;&gt;) else id) $</span>
<span class="lineno">  419 </span><span class="spaces">  </span><span class="istickedoff">group $</span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="istickedoff">encloseSep (flatAlt &quot;{ &quot; &quot;{&quot;) (flatAlt &quot; }&quot; &quot;}&quot;) &quot;, &quot; $ map ppField alist</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="istickedoff">ppField (fld, rhs) = group (nest 2 (vsep [pretty fld &lt;+&gt; op_str, rhs]))</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="istickedoff">op_str = if type_p then &quot;:&quot; else &quot;=&quot;</span></span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>-- | Pretty-print a projection / selector &quot;x.f&quot;
<span class="lineno">  426 </span>prettyProj :: FieldName -&gt; PPS.Doc -&gt; PPS.Doc
<span class="lineno">  427 </span><span class="decl"><span class="istickedoff">prettyProj sel doc = doc &lt;&gt; pretty '.' &lt;&gt; pretty sel</span></span>
<span class="lineno">  428 </span>
<span class="lineno">  429 </span>-- | Pretty-print an array value @[v1, ..., vn]@
<span class="lineno">  430 </span>prettyArrayValue :: [PPS.Doc] -&gt; PPS.Doc
<span class="lineno">  431 </span><span class="decl"><span class="istickedoff">prettyArrayValue = list</span></span>
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>-- | Pretty-print a lambda abstraction as @\(x :: tp) -&gt; body@, where the
<span class="lineno">  434 </span>-- variable name to use for @x@ is bundled with @body@
<span class="lineno">  435 </span>prettyLambda :: PPS.Doc -&gt; (LocalName, PPS.Doc) -&gt; PPS.Doc
<span class="lineno">  436 </span><span class="decl"><span class="istickedoff">prettyLambda tp (name, body) =</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">group $ hang 2 $</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="istickedoff">vsep [&quot;\\&quot; &lt;&gt; parens (prettyTypeConstraint (pretty name) tp) &lt;+&gt; &quot;-&gt;&quot;, body]</span></span>
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>-- | Pretty-print a pi abstraction as @(x :: tp) -&gt; body@, or as @tp -&gt; body@ if
<span class="lineno">  441 </span>-- @x == &quot;_&quot;@
<span class="lineno">  442 </span>prettyPi :: PPS.Doc -&gt; (LocalName, PPS.Doc) -&gt; PPS.Doc
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">prettyPi tp (name, body) = vsep [lhs, &quot;-&gt;&quot; &lt;+&gt; body]</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">lhs = if name == &quot;_&quot; then tp else parens (prettyTypeConstraint (pretty name) tp)</span></span>
<span class="lineno">  446 </span>
<span class="lineno">  447 </span>
<span class="lineno">  448 </span>--------------------------------------------------------------------------------
<span class="lineno">  449 </span>-- * Pretty-Printing Terms
<span class="lineno">  450 </span>--------------------------------------------------------------------------------
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>-- | Pretty-print a built-in atomic construct
<span class="lineno">  453 </span>prettyFlatTermF :: Prec -&gt; FlatTermF Term -&gt; PPM PPS.Doc
<span class="lineno">  454 </span><span class="decl"><span class="istickedoff">prettyFlatTermF prec tf =</span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">UnitValue     -&gt; <span class="nottickedoff">return &quot;(-empty-)&quot;</span></span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">UnitType      -&gt; <span class="nottickedoff">return &quot;#(-empty-)&quot;</span></span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">PairValue x y -&gt; prettyPair prec &lt;$&gt; prettyTerm' <span class="nottickedoff">PrecTerm</span> x &lt;*&gt; prettyTerm' PrecCommas y</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">PairType x y  -&gt; prettyPairType prec &lt;$&gt; prettyTerm' PrecApp x &lt;*&gt; prettyTerm' PrecProd y</span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="istickedoff">PairLeft t    -&gt; prettyProj &quot;1&quot; &lt;$&gt; prettyTerm' PrecArg t</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">PairRight t   -&gt; <span class="nottickedoff">prettyProj &quot;2&quot; &lt;$&gt; prettyTerm' PrecArg t</span></span>
<span class="lineno">  462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">Recursor (CompiledRecursor d s _params _nixs _ctorOrder) -&gt;</span>
<span class="lineno">  464 </span><span class="spaces">      </span><span class="istickedoff">do nm &lt;- prettyBestName d</span>
<span class="lineno">  465 </span><span class="spaces">         </span><span class="istickedoff">let suffix =</span>
<span class="lineno">  466 </span><span class="spaces">               </span><span class="istickedoff">case s of</span>
<span class="lineno">  467 </span><span class="spaces">                 </span><span class="istickedoff">TypeSort 0 -&gt; &quot;#rec&quot;</span>
<span class="lineno">  468 </span><span class="spaces">                 </span><span class="istickedoff">TypeSort n -&gt; <span class="nottickedoff">&quot;#rec&quot; &lt;&gt; pretty n</span></span>
<span class="lineno">  469 </span><span class="spaces">                 </span><span class="istickedoff">PropSort -&gt; <span class="nottickedoff">&quot;#ind&quot;</span></span>
<span class="lineno">  470 </span><span class="spaces">         </span><span class="istickedoff">return $</span>
<span class="lineno">  471 </span><span class="spaces">           </span><span class="istickedoff">annotate <span class="nottickedoff">PPS.RecursorStyle</span> (nm &lt;&gt; suffix)</span>
<span class="lineno">  472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">Sort s h -&gt; return (viaShow h &lt;&gt; viaShow s)</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue (asBoolType -&gt; Just _) args</span>
<span class="lineno">  475 </span><span class="spaces">      </span><span class="istickedoff">| Just bits &lt;- <span class="nottickedoff">mapM asBool $ V.toList args</span> -&gt;</span>
<span class="lineno">  476 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">if length bits `mod` 4 == 0 then</span></span>
<span class="lineno">  477 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ pretty (&quot;0x&quot; ++ ppBitsToHex bits)</span></span>
<span class="lineno">  478 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">else</span></span>
<span class="lineno">  479 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return $ pretty (&quot;0b&quot; ++ map (\b -&gt; if b then '1' else '0') bits)</span></span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue _ args   -&gt;</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">prettyArrayValue &lt;$&gt; mapM (prettyTerm' PrecTerm) (V.toList args)</span>
<span class="lineno">  482 </span><span class="spaces">    </span><span class="istickedoff">StringLit s -&gt; return $ viaShow s</span></span>
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>-- | Pretty-print a big endian list of bit values as a hexadecimal number
<span class="lineno">  485 </span>ppBitsToHex :: [Bool] -&gt; String
<span class="lineno">  486 </span><span class="decl"><span class="nottickedoff">ppBitsToHex (b8:b4:b2:b1:bits') =</span>
<span class="lineno">  487 </span><span class="spaces">  </span><span class="nottickedoff">intToDigit (8 * toInt b8 + 4 * toInt b4 + 2 * toInt b2 + toInt b1) :</span>
<span class="lineno">  488 </span><span class="spaces">  </span><span class="nottickedoff">ppBitsToHex bits'</span>
<span class="lineno">  489 </span><span class="spaces">  </span><span class="nottickedoff">where toInt True = 1</span>
<span class="lineno">  490 </span><span class="spaces">        </span><span class="nottickedoff">toInt False = 0</span>
<span class="lineno">  491 </span><span class="spaces"></span><span class="nottickedoff">ppBitsToHex [] = &quot;&quot;</span>
<span class="lineno">  492 </span><span class="spaces"></span><span class="nottickedoff">ppBitsToHex bits =</span>
<span class="lineno">  493 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;ppBitsToHex&quot; [</span>
<span class="lineno">  494 </span><span class="spaces">      </span><span class="nottickedoff">&quot;length of bit list &quot; &lt;&gt; bits' &lt;&gt; &quot; is not a multiple of 4&quot;</span>
<span class="lineno">  495 </span><span class="spaces">  </span><span class="nottickedoff">]</span>
<span class="lineno">  496 </span><span class="spaces">  </span><span class="nottickedoff">where bits' = Text.pack (show bits)</span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | Pretty-print a 'VarName' according to the current 'VarNaming'.
<span class="lineno">  499 </span>prettyVarName :: VarName -&gt; PPM PPS.Doc
<span class="lineno">  500 </span><span class="decl"><span class="istickedoff">prettyVarName vn =</span>
<span class="lineno">  501 </span><span class="spaces">  </span><span class="istickedoff">do naming &lt;- asks ppNaming</span>
<span class="lineno">  502 </span><span class="spaces">     </span><span class="istickedoff">pure $ pretty (lookupVarName naming vn)</span></span>
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>-- | Pretty-print a 'Name', using the best unambiguous alias from the
<span class="lineno">  505 </span>-- naming environment.
<span class="lineno">  506 </span>prettyBestName :: Name -&gt; PPM PPS.Doc
<span class="lineno">  507 </span><span class="decl"><span class="istickedoff">prettyBestName nm =</span>
<span class="lineno">  508 </span><span class="spaces">  </span><span class="istickedoff">do ne &lt;- asks ppNamingEnv</span>
<span class="lineno">  509 </span><span class="spaces">     </span><span class="istickedoff">case bestDisplayName ne (nameIndex nm) of</span>
<span class="lineno">  510 </span><span class="spaces">       </span><span class="istickedoff">Just alias -&gt; pure $ pretty alias</span>
<span class="lineno">  511 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure $ prettyName (nameInfo nm)</span></span>
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>prettyName :: NameInfo -&gt; PPS.Doc
<span class="lineno">  514 </span><span class="decl"><span class="istickedoff">prettyName (ModuleIdentifier i) = prettyIdent i</span>
<span class="lineno">  515 </span><span class="spaces"></span><span class="istickedoff">prettyName (ImportedName absName _) = <span class="nottickedoff">pretty (renderURI absName)</span></span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>-- | Pretty-print a non-shared term
<span class="lineno">  518 </span>prettyTermF :: Prec -&gt; TermF Term -&gt; PPM PPS.Doc
<span class="lineno">  519 </span><span class="decl"><span class="istickedoff">prettyTermF prec (FTermF ftf) = prettyFlatTermF prec ftf</span>
<span class="lineno">  520 </span><span class="spaces"></span><span class="istickedoff">prettyTermF prec (App e1 e2) =</span>
<span class="lineno">  521 </span><span class="spaces">  </span><span class="istickedoff">prettyAppList prec &lt;$&gt; prettyTerm' PrecApp e1 &lt;*&gt; mapM (prettyTerm' PrecArg) [e2]</span>
<span class="lineno">  522 </span><span class="spaces"></span><span class="istickedoff">prettyTermF prec (Lambda x tp body) =</span>
<span class="lineno">  523 </span><span class="spaces">  </span><span class="istickedoff">prettyParensPrec prec PrecLambda &lt;$&gt;</span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="istickedoff">(prettyLambda &lt;$&gt; prettyTerm' PrecApp tp &lt;*&gt; prettyTermInBinder PrecLambda x body)</span>
<span class="lineno">  525 </span><span class="spaces"></span><span class="istickedoff">prettyTermF prec (Pi x tp body) =</span>
<span class="lineno">  526 </span><span class="spaces">  </span><span class="istickedoff">prettyParensPrec prec PrecLambda &lt;$&gt;</span>
<span class="lineno">  527 </span><span class="spaces">  </span><span class="istickedoff">(prettyPi &lt;$&gt; prettyTerm' PrecApp tp &lt;*&gt;</span>
<span class="lineno">  528 </span><span class="spaces">   </span><span class="istickedoff">prettyTermInBinder PrecLambda x body)</span>
<span class="lineno">  529 </span><span class="spaces"></span><span class="istickedoff">prettyTermF _ (Constant nm) = annotate <span class="nottickedoff">PPS.ConstantStyle</span> &lt;$&gt; prettyBestName nm</span>
<span class="lineno">  530 </span><span class="spaces"></span><span class="istickedoff">prettyTermF _ (Variable vn _tp) = annotate <span class="nottickedoff">PPS.VariableStyle</span> &lt;$&gt; prettyVarName vn</span></span>
<span class="lineno">  531 </span>
<span class="lineno">  532 </span>-- | Internal function to recursively pretty-print a term
<span class="lineno">  533 </span>prettyTerm' :: Prec -&gt; Term -&gt; PPM PPS.Doc
<span class="lineno">  534 </span><span class="decl"><span class="istickedoff">prettyTerm' prec = atNextDepthM <span class="nottickedoff">&quot;...&quot;</span> . prettyTerm''</span>
<span class="lineno">  535 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  536 </span><span class="spaces">    </span><span class="istickedoff">prettyTerm'' :: Term -&gt; PPM PPS.Doc</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">prettyTerm'' t =</span>
<span class="lineno">  538 </span><span class="spaces">      </span><span class="istickedoff">do maybe_memo_var &lt;- memoLookupM (termIndex t)</span>
<span class="lineno">  539 </span><span class="spaces">         </span><span class="istickedoff">case maybe_memo_var of</span>
<span class="lineno">  540 </span><span class="spaces">           </span><span class="istickedoff">Just memo_var -&gt; prettyMemoVar memo_var</span>
<span class="lineno">  541 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  542 </span><span class="spaces">             </span><span class="istickedoff">case t of</span>
<span class="lineno">  543 </span><span class="spaces">               </span><span class="istickedoff">(asNat -&gt; Just n) -&gt;</span>
<span class="lineno">  544 </span><span class="spaces">                 </span><span class="istickedoff">prettyNat &lt;$&gt; asks ppOpts &lt;*&gt; pure (toInteger n)</span>
<span class="lineno">  545 </span><span class="spaces">               </span><span class="istickedoff">(asRecordType -&gt; Just alist) -&gt;</span>
<span class="lineno">  546 </span><span class="spaces">                 </span><span class="istickedoff">prettyRecord True &lt;$&gt; traverse (traverse (prettyTerm' PrecTerm)) alist</span>
<span class="lineno">  547 </span><span class="spaces">               </span><span class="istickedoff">(asRecordValue -&gt; Just alist) -&gt;</span>
<span class="lineno">  548 </span><span class="spaces">                 </span><span class="istickedoff">prettyRecord False &lt;$&gt; traverse (traverse (prettyTerm' PrecTerm)) alist</span>
<span class="lineno">  549 </span><span class="spaces">               </span><span class="istickedoff">(asRecordSelector -&gt; Just (e, fname)) -&gt;</span>
<span class="lineno">  550 </span><span class="spaces">                 </span><span class="istickedoff">prettyProj fname &lt;$&gt; prettyTerm' PrecArg e</span>
<span class="lineno">  551 </span><span class="spaces">               </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  552 </span><span class="spaces">                 </span><span class="istickedoff">prettyTermF prec (unwrapTermF t)</span></span>
<span class="lineno">  553 </span>
<span class="lineno">  554 </span>
<span class="lineno">  555 </span>--------------------------------------------------------------------------------
<span class="lineno">  556 </span>-- * Memoization Tables and Dealing with Binders in Terms
<span class="lineno">  557 </span>--------------------------------------------------------------------------------
<span class="lineno">  558 </span>
<span class="lineno">  559 </span>-- | An occurrence map maps each shared term index to its term and how many
<span class="lineno">  560 </span>-- times that term occurred
<span class="lineno">  561 </span>type OccurrenceMap = IntMap (Term, Int)
<span class="lineno">  562 </span>
<span class="lineno">  563 </span>-- | Returns map that associates each term index appearing in the term
<span class="lineno">  564 </span>-- to the number of occurrences in the shared term.
<span class="lineno">  565 </span>-- Partially-applied functions are excluded, because let-binding such
<span class="lineno">  566 </span>-- subterms makes terms harder to read.
<span class="lineno">  567 </span>-- The boolean flag indicates whether to descend under lambdas and
<span class="lineno">  568 </span>-- other binders.
<span class="lineno">  569 </span>scTermCount :: Bool -&gt; Term -&gt; OccurrenceMap
<span class="lineno">  570 </span><span class="decl"><span class="istickedoff">scTermCount doBinders t = execState (scTermCountAux doBinders [t]) IntMap.empty</span></span>
<span class="lineno">  571 </span>
<span class="lineno">  572 </span>scTermCountAux :: Bool -&gt; [Term] -&gt; State OccurrenceMap ()
<span class="lineno">  573 </span><span class="decl"><span class="istickedoff">scTermCountAux doBinders = go</span>
<span class="lineno">  574 </span><span class="spaces">  </span><span class="istickedoff">where go :: [Term] -&gt; State OccurrenceMap ()</span>
<span class="lineno">  575 </span><span class="spaces">        </span><span class="istickedoff">go [] = return <span class="nottickedoff">()</span></span>
<span class="lineno">  576 </span><span class="spaces">        </span><span class="istickedoff">go (t : ts) =</span>
<span class="lineno">  577 </span><span class="spaces">          </span><span class="istickedoff">do m &lt;- get</span>
<span class="lineno">  578 </span><span class="spaces">             </span><span class="istickedoff">let i = termIndex t</span>
<span class="lineno">  579 </span><span class="spaces">             </span><span class="istickedoff">case IntMap.lookup i m of</span>
<span class="lineno">  580 </span><span class="spaces">               </span><span class="istickedoff">Just (_, n) -&gt;</span>
<span class="lineno">  581 </span><span class="spaces">                 </span><span class="istickedoff">do put $ n `seq` IntMap.insert i (t, n+1) m</span>
<span class="lineno">  582 </span><span class="spaces">                    </span><span class="istickedoff">go ts</span>
<span class="lineno">  583 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  584 </span><span class="spaces">                 </span><span class="istickedoff">do put (IntMap.insert i (t, 1) m)</span>
<span class="lineno">  585 </span><span class="spaces">                    </span><span class="istickedoff">go (ts ++ argsAndSubterms t)</span>
<span class="lineno">  586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  587 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms :: Term -&gt; [Term]</span>
<span class="lineno">  588 </span><span class="spaces">        </span><span class="istickedoff">-- Skip type arguments in record syntax</span>
<span class="lineno">  589 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms (asRecordSelector -&gt; Just (t1, _)) = [t1]</span>
<span class="lineno">  590 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms (asRecordValue -&gt; Just fields) = map snd fields</span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="istickedoff">-- Skip partially-applied function terms</span>
<span class="lineno">  592 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms (asApp -&gt; Just (t1@(asApp -&gt; Just _), t2)) =</span>
<span class="lineno">  593 </span><span class="spaces">          </span><span class="istickedoff">argsAndSubterms t1 ++ [t2]</span>
<span class="lineno">  594 </span><span class="spaces">        </span><span class="istickedoff">argsAndSubterms h =</span>
<span class="lineno">  595 </span><span class="spaces">          </span><span class="istickedoff">case unwrapTermF h of</span>
<span class="lineno">  596 </span><span class="spaces">            </span><span class="istickedoff">Lambda _ t1 _ | not doBinders  -&gt; [t1]</span>
<span class="lineno">  597 </span><span class="spaces">            </span><span class="istickedoff">Pi _ t1 _     | not doBinders  -&gt; [t1]</span>
<span class="lineno">  598 </span><span class="spaces">            </span><span class="istickedoff">Constant{}                     -&gt; []</span>
<span class="lineno">  599 </span><span class="spaces">            </span><span class="istickedoff">Variable{}                     -&gt; []</span>
<span class="lineno">  600 </span><span class="spaces">            </span><span class="istickedoff">FTermF (Recursor _)            -&gt; []</span>
<span class="lineno">  601 </span><span class="spaces">            </span><span class="istickedoff">tf                             -&gt; Fold.toList tf</span></span>
<span class="lineno">  602 </span>
<span class="lineno">  603 </span>
<span class="lineno">  604 </span>-- | Return true if the printing of the given term should be memoized; we do not
<span class="lineno">  605 </span>-- want to memoize the printing of terms that are &quot;too small&quot;
<span class="lineno">  606 </span>shouldMemoizeTerm :: Term -&gt; Bool
<span class="lineno">  607 </span><span class="decl"><span class="istickedoff">shouldMemoizeTerm t =</span>
<span class="lineno">  608 </span><span class="spaces">  </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="istickedoff">FTermF UnitValue -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="istickedoff">FTermF UnitType -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="istickedoff">FTermF Sort{} -&gt; False</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="istickedoff">FTermF (ArrayValue _ v) | <span class="tickonlyfalse">V.length v == 0</span> -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff">FTermF StringLit{} -&gt; False</span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="istickedoff">FTermF Recursor{} -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="istickedoff">Constant{} -&gt; False</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">Variable{} -&gt; False</span>
<span class="lineno">  617 </span><span class="spaces">    </span><span class="istickedoff">App (isGlobalDef &quot;Prelude.NatPos&quot; -&gt; Just ()) _ -&gt; False</span>
<span class="lineno">  618 </span><span class="spaces">    </span><span class="istickedoff">App (isGlobalDef &quot;Prelude.Bit0&quot; -&gt; Just ()) _ -&gt; False</span>
<span class="lineno">  619 </span><span class="spaces">    </span><span class="istickedoff">App (isGlobalDef &quot;Prelude.Bit1&quot; -&gt; Just ()) _ -&gt; False</span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; True</span></span>
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>-- | Compute a memoization table for a term, and pretty-print the term using the
<span class="lineno">  623 </span>-- table to memoize the printing. Also print the table itself as a sequence of
<span class="lineno">  624 </span>-- let-bindings for the entries in the memoization table. If the flag is true,
<span class="lineno">  625 </span>-- compute a global table, otherwise compute a local table.
<span class="lineno">  626 </span>prettyTermWithMemoTable :: Prec -&gt; Bool -&gt; Term -&gt; PPM PPS.Doc
<span class="lineno">  627 </span><span class="decl"><span class="istickedoff">prettyTermWithMemoTable prec global_p trm =</span>
<span class="lineno">  628 </span><span class="spaces">  </span><span class="istickedoff">do min_occs &lt;- PPS.ppMinSharing &lt;$&gt; ppOpts &lt;$&gt; ask</span>
<span class="lineno">  629 </span><span class="spaces">     </span><span class="istickedoff">let occPairs = IntMap.assocs $ filterOccurrenceMap min_occs global_p' $ scTermCount global_p trm</span>
<span class="lineno">  630 </span><span class="spaces">     </span><span class="istickedoff">prettyLets global_p occPairs [] (prettyTerm' prec trm)</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="istickedoff">global_p' = if global_p then Just (freeVars trm) else Nothing</span></span>
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>-- | Filter an occurrence map, filtering out terms that only occur
<span class="lineno">  635 </span>-- once, that are &quot;too small&quot; to memoize, and, for the global table, terms
<span class="lineno">  636 </span>-- that are not closed.
<span class="lineno">  637 </span>-- The second argument says whether we want the 'OccurrenceMap' for a
<span class="lineno">  638 </span>-- global or local table:
<span class="lineno">  639 </span>-- @Nothing@ means we are building a local table, and should not do
<span class="lineno">  640 </span>-- extra filtering.
<span class="lineno">  641 </span>-- @Just s@ means we are building a global table, and should filter
<span class="lineno">  642 </span>-- out any term @t@ that mentions any local bound variables.
<span class="lineno">  643 </span>-- The set @s@ enumerates the variables considered to have global
<span class="lineno">  644 </span>-- scope; in a global table we keep subterms @t@ whose free variables
<span class="lineno">  645 </span>-- are a subset of @s@.
<span class="lineno">  646 </span>filterOccurrenceMap :: Int -&gt; Maybe IntSet -&gt; OccurrenceMap -&gt; OccurrenceMap
<span class="lineno">  647 </span><span class="decl"><span class="istickedoff">filterOccurrenceMap min_occs global_p =</span>
<span class="lineno">  648 </span><span class="spaces">    </span><span class="istickedoff">IntMap.filter</span>
<span class="lineno">  649 </span><span class="spaces">      </span><span class="istickedoff">(\(t,cnt) -&gt;</span>
<span class="lineno">  650 </span><span class="spaces">        </span><span class="istickedoff">cnt &gt;= min_occs &amp;&amp; shouldMemoizeTerm t &amp;&amp;</span>
<span class="lineno">  651 </span><span class="spaces">        </span><span class="istickedoff">maybe True (IntSet.isSubsetOf (freeVars t)) global_p)</span></span>
<span class="lineno">  652 </span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>-- For each (TermIndex, Term) pair in the occurrence map, pretty-print the
<span class="lineno">  655 </span>-- Term and then add it to the memoization table of subsequent printing. The
<span class="lineno">  656 </span>-- pretty-printing of these terms is reverse-accumulated in the second
<span class="lineno">  657 </span>-- list. Finally, print the given base document in the context of let-bindings
<span class="lineno">  658 </span>-- for the bound terms.
<span class="lineno">  659 </span>prettyLets :: Bool -&gt; [(TermIndex, (Term, Int))] -&gt; [(MemoVar, PPS.Doc)] -&gt; PPM PPS.Doc -&gt; PPM PPS.Doc
<span class="lineno">  660 </span>
<span class="lineno">  661 </span>-- Special case: don't print let-binding if there are no bound vars
<span class="lineno">  662 </span><span class="decl"><span class="istickedoff">prettyLets _ [] [] baseDoc = baseDoc</span>
<span class="lineno">  663 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  664 </span><span class="spaces"></span><span class="istickedoff">-- When we have run out of (idx,term) pairs, pretty-print a let binding for</span>
<span class="lineno">  665 </span><span class="spaces"></span><span class="istickedoff">-- all the accumulated bindings around the term</span>
<span class="lineno">  666 </span><span class="spaces"></span><span class="istickedoff">prettyLets _ [] bindings baseDoc = prettyLetBlock (reverse bindings) =&lt;&lt; baseDoc</span>
<span class="lineno">  667 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  668 </span><span class="spaces"></span><span class="istickedoff">-- To add an (idx,term) pair, first check if idx is already bound, and, if</span>
<span class="lineno">  669 </span><span class="spaces"></span><span class="istickedoff">-- not, add a new MemoVar bind it to idx</span>
<span class="lineno">  670 </span><span class="spaces"></span><span class="istickedoff">prettyLets global_p ((termIdx, (term,_)):idxs) bindings baseDoc =</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="istickedoff">do isBound &lt;- isJust &lt;$&gt; memoLookupM termIdx</span>
<span class="lineno">  672 </span><span class="spaces">     </span><span class="istickedoff">if isBound then prettyLets global_p idxs bindings baseDoc else</span>
<span class="lineno">  673 </span><span class="spaces">       </span><span class="istickedoff">do termDoc &lt;- prettyTerm' PrecTerm term</span>
<span class="lineno">  674 </span><span class="spaces">          </span><span class="istickedoff">withMemoVar global_p termIdx <span class="nottickedoff">(hash term)</span> $ \memoVarM -&gt;</span>
<span class="lineno">  675 </span><span class="spaces">            </span><span class="istickedoff">let bindings' = case memoVarM of</span>
<span class="lineno">  676 </span><span class="spaces">                  </span><span class="istickedoff">Just memoVar -&gt; (memoVar, termDoc):bindings</span>
<span class="lineno">  677 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">bindings</span></span>
<span class="lineno">  678 </span><span class="spaces">            </span><span class="istickedoff">in  prettyLets global_p idxs bindings' baseDoc</span></span>
<span class="lineno">  679 </span>
<span class="lineno">  680 </span>-- | Pretty-print a term inside a binder for a variable of the given name,
<span class="lineno">  681 </span>-- returning both the result of pretty-printing and the fresh name actually used
<span class="lineno">  682 </span>-- for the newly bound variable. If the variable occurs in the term, then do not
<span class="lineno">  683 </span>-- use an underscore for it, and use &quot;_x&quot; instead.
<span class="lineno">  684 </span>--
<span class="lineno">  685 </span>-- Also, pretty-print let-bindings around the term for all subterms that occur
<span class="lineno">  686 </span>-- more than once at the same binding level.
<span class="lineno">  687 </span>prettyTermInBinder :: Prec -&gt; VarName -&gt; Term -&gt; PPM (LocalName, PPS.Doc)
<span class="lineno">  688 </span><span class="decl"><span class="istickedoff">prettyTermInBinder prec (VarName i basename) trm =</span>
<span class="lineno">  689 </span><span class="spaces">  </span><span class="istickedoff">let nm = if <span class="tickonlyfalse">basename == &quot;_&quot; &amp;&amp; IntSet.member i (freeVars trm)</span> then <span class="nottickedoff">&quot;_x&quot;</span></span>
<span class="lineno">  690 </span><span class="spaces">           </span><span class="istickedoff">else basename in</span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="istickedoff">withBoundVarM (VarName i nm) $ prettyTermWithMemoTable prec False trm</span></span>
<span class="lineno">  692 </span>
<span class="lineno">  693 </span>-- | Pretty-print a term, also adding let-bindings for all subterms that occur
<span class="lineno">  694 </span>--   more than once at the same binding level.
<span class="lineno">  695 </span>--
<span class="lineno">  696 </span>--   Does not integrate the current `DisplayNameEnv` from the
<span class="lineno">  697 </span>--   `SharedContext`; use prettyTerm instead unless you really can't
<span class="lineno">  698 </span>--   get the `SharedContext` and/or can't afford to be in `IO`.
<span class="lineno">  699 </span>prettyTermPure :: PPS.Opts -&gt; Term -&gt; PPS.Doc
<span class="lineno">  700 </span><span class="decl"><span class="istickedoff">prettyTermPure opts = prettyTermWithEnv opts emptyDisplayNameEnv</span></span>
<span class="lineno">  701 </span>
<span class="lineno">  702 </span>-- | Like 'prettyTermPure', but also supply a context of bound names, where
<span class="lineno">  703 </span>-- the earliest-bound variable is listed first in the context.
<span class="lineno">  704 </span>prettyTermWithNameList :: PPS.Opts -&gt; [VarName] -&gt; Term -&gt; PPS.Doc
<span class="lineno">  705 </span><span class="decl"><span class="nottickedoff">prettyTermWithNameList opts ctx trm =</span>
<span class="lineno">  706 </span><span class="spaces">  </span><span class="nottickedoff">runPPM opts emptyDisplayNameEnv $</span>
<span class="lineno">  707 </span><span class="spaces">  </span><span class="nottickedoff">-- reserve names from ctx first, so that they get priority naming</span>
<span class="lineno">  708 </span><span class="spaces">  </span><span class="nottickedoff">withVarNames ctx $</span>
<span class="lineno">  709 </span><span class="spaces">  </span><span class="nottickedoff">-- reserve other free variables next, so they are disambiguated</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="nottickedoff">withVarNames (Set.toList (termVarNames trm) \\ ctx) $</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="nottickedoff">prettyTermWithMemoTable PrecTerm True trm</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>-- | Pretty-print a term and render it to a string, using the given options.
<span class="lineno">  714 </span>--
<span class="lineno">  715 </span>--   Does not integrate the current `DisplayNameEnv` from the
<span class="lineno">  716 </span>--   `SharedContext`; use ppTerm instead unless you really can't get
<span class="lineno">  717 </span>--   the `SharedContext` and/or can't afford to be in `IO`.
<span class="lineno">  718 </span>ppTermPure :: PPS.Opts -&gt; Term -&gt; String
<span class="lineno">  719 </span><span class="decl"><span class="istickedoff">ppTermPure opts t =</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">PPS.render opts $ prettyTermPure opts t</span></span>
<span class="lineno">  721 </span>
<span class="lineno">  722 </span>-- | Pretty-print a term and render it to a string, using default options.
<span class="lineno">  723 </span>--
<span class="lineno">  724 </span>--   Does not integrate the current `DisplayNameEnv` from the
<span class="lineno">  725 </span>--   `SharedContext`; use ppTerm instead unless you really can't get
<span class="lineno">  726 </span>--   the `SharedContext` and/or can't afford to be in `IO`.
<span class="lineno">  727 </span>--
<span class="lineno">  728 </span>--   Even then, use `ppTermPure` unless you really don't have the
<span class="lineno">  729 </span>--   prettyprinting options and can't get them.
<span class="lineno">  730 </span>ppTermPureDefaults :: Term -&gt; String
<span class="lineno">  731 </span><span class="decl"><span class="istickedoff">ppTermPureDefaults t = ppTermPure PPS.defaultOpts t</span></span>
<span class="lineno">  732 </span>
<span class="lineno">  733 </span>
<span class="lineno">  734 </span>--------------------------------------------------------------------------------
<span class="lineno">  735 </span>-- * Pretty-printers with naming environments
<span class="lineno">  736 </span>--------------------------------------------------------------------------------
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>-- | Pretty-print a `NameInfo`, using the `DisplayNameEnv` to figure
<span class="lineno">  739 </span>--   how much name to print.
<span class="lineno">  740 </span>prettyNameWithEnv :: PPS.Opts -&gt; DisplayNameEnv -&gt; Name -&gt; PPS.Doc
<span class="lineno">  741 </span><span class="decl"><span class="istickedoff">prettyNameWithEnv opts env name =</span>
<span class="lineno">  742 </span><span class="spaces">  </span><span class="istickedoff">runPPM <span class="nottickedoff">opts</span> env $ prettyBestName name</span></span>
<span class="lineno">  743 </span>
<span class="lineno">  744 </span>-- | Pretty-print a term, also adding let-bindings for all subterms that occur
<span class="lineno">  745 </span>-- more than once at the same binding level
<span class="lineno">  746 </span>prettyTermWithEnv :: PPS.Opts -&gt; DisplayNameEnv -&gt; Term -&gt; PPS.Doc
<span class="lineno">  747 </span><span class="decl"><span class="istickedoff">prettyTermWithEnv opts ne trm =</span>
<span class="lineno">  748 </span><span class="spaces">  </span><span class="istickedoff">runPPM opts ne $</span>
<span class="lineno">  749 </span><span class="spaces">  </span><span class="istickedoff">withVarNames (Set.toList (termVarNames trm)) $</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff">prettyTermWithMemoTable PrecTerm True trm</span></span>
<span class="lineno">  751 </span>
<span class="lineno">  752 </span>ppTermWithEnv :: PPS.Opts -&gt; DisplayNameEnv -&gt; Term -&gt; String
<span class="lineno">  753 </span><span class="decl"><span class="nottickedoff">ppTermWithEnv opts ne trm =</span>
<span class="lineno">  754 </span><span class="spaces">  </span><span class="nottickedoff">PPS.render opts $ prettyTermWithEnv opts ne trm</span></span>
<span class="lineno">  755 </span>
<span class="lineno">  756 </span>
<span class="lineno">  757 </span>prettyTermContainerWithEnv ::
<span class="lineno">  758 </span>  (Traversable m) =&gt;
<span class="lineno">  759 </span>  (m PPS.Doc -&gt; PPS.Doc) -&gt;
<span class="lineno">  760 </span>  PPS.Opts -&gt; DisplayNameEnv -&gt; m Term -&gt; PPS.Doc
<span class="lineno">  761 </span><span class="decl"><span class="istickedoff">prettyTermContainerWithEnv prettyContainer opts ne trms =</span>
<span class="lineno">  762 </span><span class="spaces">  </span><span class="istickedoff">let min_occs = PPS.ppMinSharing opts</span>
<span class="lineno">  763 </span><span class="spaces">      </span><span class="istickedoff">global_p = True</span>
<span class="lineno">  764 </span><span class="spaces">      </span><span class="istickedoff">global_p' = Just (Fold.foldMap freeVars trms)</span>
<span class="lineno">  765 </span><span class="spaces">      </span><span class="istickedoff">occPairs = IntMap.assocs $</span>
<span class="lineno">  766 </span><span class="spaces">                   </span><span class="istickedoff">filterOccurrenceMap min_occs global_p' $</span>
<span class="lineno">  767 </span><span class="spaces">                   </span><span class="istickedoff">flip execState mempty $</span>
<span class="lineno">  768 </span><span class="spaces">                   </span><span class="istickedoff">traverse (\t -&gt; scTermCountAux global_p [t]) $</span>
<span class="lineno">  769 </span><span class="spaces">                   </span><span class="istickedoff">trms</span>
<span class="lineno">  770 </span><span class="spaces">   </span><span class="istickedoff">in runPPM opts ne $</span>
<span class="lineno">  771 </span><span class="spaces">      </span><span class="istickedoff">withVarNames (Set.toList (Fold.foldMap termVarNames trms)) $</span>
<span class="lineno">  772 </span><span class="spaces">      </span><span class="istickedoff">prettyLets global_p occPairs []</span>
<span class="lineno">  773 </span><span class="spaces">        </span><span class="istickedoff">(prettyContainer &lt;$&gt; traverse (prettyTerm' PrecTerm) trms)</span></span>

</pre>
</body>
</html>
