<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    2 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">    3 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">    4 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    5 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">    6 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">    7 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    8 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">    9 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   10 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">   11 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   12 </span>{-# LANGUAGE DeriveGeneric #-}
<span class="lineno">   13 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   14 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   15 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   16 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>{- |
<span class="lineno">   19 </span>Module      : CryptolSAWCore.Monadify
<span class="lineno">   20 </span>Copyright   : Galois, Inc. 2021
<span class="lineno">   21 </span>License     : BSD3
<span class="lineno">   22 </span>Maintainer  : westbrook@galois.com
<span class="lineno">   23 </span>Stability   : experimental
<span class="lineno">   24 </span>Portability : non-portable (language extensions)
<span class="lineno">   25 </span>
<span class="lineno">   26 </span>This module implements a &quot;monadification&quot; transformation, which converts &quot;pure&quot;
<span class="lineno">   27 </span>SAW core terms that use inconsistent operations like @fix@ and convert them to
<span class="lineno">   28 </span>monadic SAW core terms that use monadic versions of these operations that are
<span class="lineno">   29 </span>consistent. The monad that is used is the @SpecM@ monad that is axiomatized in
<span class="lineno">   30 </span>the SAW core prelude. This is only a partial transformation, meaning that it
<span class="lineno">   31 </span>will fail on some SAW core terms. Specifically, it requires that all
<span class="lineno">   32 </span>applications @f arg@ in a term either have a non-dependent function type for @f@
<span class="lineno">   33 </span>(i.e., a function with type @'Pi' x a b@ where @x@ does not occur in @b@) or a
<span class="lineno">   34 </span>pure argument @arg@ that does not use any of the inconsistent operations.
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>Monadification is easiest to understand as a transformation on types that at a
<span class="lineno">   37 </span>high level replaces any function type of the form @a1 -&gt; ... -&gt; an -&gt; b@ with
<span class="lineno">   38 </span>the monadic function type @a1' -&gt; ... -&gt; an' -&gt; SpecM b'@, where @b'@ and each
<span class="lineno">   39 </span>@ai'@ are the result of monadifying @b@ and @ai@, respectively. Non-function
<span class="lineno">   40 </span>type constructors like pairs or vectors are monadified to themselves, though
<span class="lineno">   41 </span>their type arguments are also monadified. One slight complexity here is in
<span class="lineno">   42 </span>handling sequence types, which are either vectors for finite sequences or
<span class="lineno">   43 </span>functions from a natural number index to the element at that index for infinite
<span class="lineno">   44 </span>sequences. Since function types become monadic function types, infinite
<span class="lineno">   45 </span>sequences become monadic functions from a natural numbers to elements, i.e.,
<span class="lineno">   46 </span>streams of computations. This is all handled by defining the type @mseq@ of
<span class="lineno">   47 </span>&quot;monadified sequences&quot; that use vectors for finite lengths and streams of
<span class="lineno">   48 </span>computations for the infinite length.
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>In more detail, this transformation is defined with two type-level
<span class="lineno">   51 </span>transformations, @MT(a)@ and @CompMT(a)@, which define the &quot;argument&quot; and
<span class="lineno">   52 </span>&quot;computational&quot; monadification of @a@. The former is used to monadify arguments
<span class="lineno">   53 </span>in function types, and is also used to define _the_ monadification of a type.
<span class="lineno">   54 </span>The latter is used to monadify the return type of a function type, and adds a
<span class="lineno">   55 </span>@SpecM@ to that return type. These functions are defined as follows:
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>&gt; MT(Pi x (sort 0) b) = Pi x (sort 0) CompMT(b)
<span class="lineno">   58 </span>&gt; MT(Pi x Num b) = Pi x Num CompMT(b)
<span class="lineno">   59 </span>&gt; MT(Pi _ a b) = MT(a) -&gt; CompMT(b)
<span class="lineno">   60 </span>&gt; MT(#(a,b)) = #(MT(a),MT(b))
<span class="lineno">   61 </span>&gt; MT(seq n a) = mseq n MT(a)
<span class="lineno">   62 </span>&gt; MT(f arg) = f MT(arg)  -- For pure type function f
<span class="lineno">   63 </span>&gt; MT(cnst) = cnst
<span class="lineno">   64 </span>&gt; MT(dt args) = dt MT(args)
<span class="lineno">   65 </span>&gt; MT(x) = x
<span class="lineno">   66 </span>&gt; MT(_) = error
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>&gt; CompMT(tp = Pi _ _ _) = MT(tp)
<span class="lineno">   69 </span>&gt; CompMT(n : Num) = n
<span class="lineno">   70 </span>&gt; CompMT(tp) = SpecM MT(tp)
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>The way monadification of types is implemented here is in two pieces. The first
<span class="lineno">   73 </span>is the 'monadifyType' function and its associated helpers, which converts a SAW
<span class="lineno">   74 </span>core type into an internal representation captured by the Haskell type
<span class="lineno">   75 </span>'MonType'. The second piece is the functions 'toArgType' and 'toCompType', which
<span class="lineno">   76 </span>map a 'MonType' generated from SAW type @a@ to the result of applying @MT(a)@
<span class="lineno">   77 </span>and @CompMT(a)@, respectively.
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>FIXME: explain the term-level transformation below
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>Term-level translation:
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>MonArg(t : tp) ==&gt; MT(tp)
<span class="lineno">   85 </span>MonArg(t) =
<span class="lineno">   86 </span>  case Mon(t) of
<span class="lineno">   87 </span>    m : SpecM MT(a) =&gt; shift \k -&gt; m &gt;&gt;= \x -&gt; k x
<span class="lineno">   88 </span>    _ =&gt; t
<span class="lineno">   89 </span>
<span class="lineno">   90 </span>Mon(t : tp) ==&gt; MT(tp) or CompMT(tp)  (which are the same type for pis)
<span class="lineno">   91 </span>Mon((f : Pi x a b) arg) = Mon(f) MT(arg)
<span class="lineno">   92 </span>Mon((f : Pi _ a b) arg) = Mon(f) MonArg(arg)
<span class="lineno">   93 </span>Mon(Lambda x a t) = Lambda x MT(a) Mon(t)
<span class="lineno">   94 </span>Mon((t,u)) = (MonArg(t),MonArg(u))
<span class="lineno">   95 </span>Mon(c args) = c MonArg(args)
<span class="lineno">   96 </span>Mon(x) = x
<span class="lineno">   97 </span>Mon(fix) = fixM (of some form...)
<span class="lineno">   98 </span>Mon(cnst) = cnstM  if cnst is impure and monadifies to constM
<span class="lineno">   99 </span>Mon(cnst) = cnst   otherwise
<span class="lineno">  100 </span>-}
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>module CryptolSAWCore.Monadify where
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>import Numeric.Natural
<span class="lineno">  105 </span>import Data.Map.Strict (Map)
<span class="lineno">  106 </span>import qualified Data.Map.Strict as Map
<span class="lineno">  107 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">  108 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">  109 </span>import qualified Data.Text as Text
<span class="lineno">  110 </span>import Control.Monad (forM_, unless, zipWithM)
<span class="lineno">  111 </span>import Control.Monad.Cont (Cont, cont, runCont)
<span class="lineno">  112 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">  113 </span>import Control.Monad.Reader (MonadReader(..), ReaderT(..))
<span class="lineno">  114 </span>import Control.Monad.State (MonadState(..), StateT(..), evalStateT, modify)
<span class="lineno">  115 </span>import Control.Monad.Trans (MonadTrans(..))
<span class="lineno">  116 </span>import qualified Control.Monad.Fail as Fail
<span class="lineno">  117 </span>-- import Control.Monad.IO.Class (MonadIO, liftIO)
<span class="lineno">  118 </span>import Data.Maybe (isJust)
<span class="lineno">  119 </span>import qualified Data.Text as T
<span class="lineno">  120 </span>import qualified Text.URI as URI
<span class="lineno">  121 </span>import Data.Type.Equality
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts)
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>import SAWCore.Module (ModuleMap, Def(..), ResolvedName(..), requireNameInMap, resolvedNameType)
<span class="lineno">  126 </span>import SAWCore.Name
<span class="lineno">  127 </span>import SAWCore.Term.Functor
<span class="lineno">  128 </span>import SAWCore.SharedTerm
<span class="lineno">  129 </span>import SAWCore.OpenTerm
<span class="lineno">  130 </span>import SAWCore.Term.Pretty (scPrettyTermInCtx)
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>import CryptolSAWCore.Panic
<span class="lineno">  133 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  134 </span>import CryptolSAWCore.Cryptol (Env)
<span class="lineno">  135 </span>import SAWCore.Recognizer
<span class="lineno">  136 </span>-- import SAWCore.Position
<span class="lineno">  137 </span>import CryptolSAWCore.PreludeM
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>import GHC.Stack
<span class="lineno">  140 </span>-- import Debug.Trace
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>-- FIXME: move to OpenTerm.hs
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>-- | A global definition, which is either a primitive or a constant.
<span class="lineno">  145 </span>data GlobalDef = GlobalDef { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">globalDefName</span></span></span> :: Name,
<span class="lineno">  146 </span>                             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">globalDefType</span></span></span> :: Term,
<span class="lineno">  147 </span>                             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">globalDefTerm</span></span></span> :: Term }
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>instance <span class="decl"><span class="nottickedoff">Eq GlobalDef</span></span> where
<span class="lineno">  150 </span>  <span class="decl"><span class="nottickedoff">gd1 == gd2 = globalDefName gd1 == globalDefName gd2</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord GlobalDef</span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  153 </span>  <span class="decl"><span class="nottickedoff">compare gd1 gd2 = compare (globalDefName gd1) (globalDefName gd2)</span></span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show GlobalDef</span></span></span></span> where
<span class="lineno">  156 </span>  <span class="decl"><span class="nottickedoff">show = show . globalDefName</span></span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- | Get the 'String' name of a 'GlobalDef'
<span class="lineno">  159 </span>globalDefString :: GlobalDef -&gt; String
<span class="lineno">  160 </span><span class="decl"><span class="nottickedoff">globalDefString = T.unpack . toAbsoluteName . nameInfo . globalDefName</span></span>
<span class="lineno">  161 </span>
<span class="lineno">  162 </span>-- | Build an 'OpenTerm' from a 'GlobalDef'
<span class="lineno">  163 </span>globalDefOpenTerm :: GlobalDef -&gt; OpenTerm
<span class="lineno">  164 </span><span class="decl"><span class="nottickedoff">globalDefOpenTerm = closedOpenTerm . globalDefTerm</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | Recognize a named global definition, including its type
<span class="lineno">  167 </span>asTypedGlobalDef :: (?mm :: ModuleMap) =&gt; Recognizer Term GlobalDef
<span class="lineno">  168 </span><span class="decl"><span class="nottickedoff">asTypedGlobalDef t =</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="nottickedoff">case unwrapTermF t of</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="nottickedoff">Constant nm -&gt;</span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="nottickedoff">let ty = resolvedNameType (requireNameInMap nm ?mm)</span>
<span class="lineno">  172 </span><span class="spaces">      </span><span class="nottickedoff">in Just $ GlobalDef nm ty t</span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="nottickedoff">Variable ec -&gt;</span>
<span class="lineno">  174 </span><span class="spaces">      </span><span class="nottickedoff">Just $ GlobalDef (ecName ec) (ecType ec) t</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>-- FIXME HERE NOW: remove these if no longer needed
<span class="lineno">  178 </span>{-
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>----------------------------------------------------------------------
<span class="lineno">  181 </span>-- * Typing All Subterms
<span class="lineno">  182 </span>----------------------------------------------------------------------
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- | A SAW core term where all of the subterms are typed
<span class="lineno">  185 </span>data TypedSubsTerm
<span class="lineno">  186 </span>  = TypedSubsTerm { tpSubsIndex :: Maybe TermIndex,
<span class="lineno">  187 </span>                    tpSubsFreeVars :: BitSet,
<span class="lineno">  188 </span>                    tpSubsTermF :: TermF TypedSubsTerm,
<span class="lineno">  189 </span>                    tpSubsTypeF :: TermF TypedSubsTerm,
<span class="lineno">  190 </span>                    tpSubsSort :: Sort }
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- | Convert a 'Term' to a 'TypedSubsTerm'
<span class="lineno">  193 </span>typeAllSubterms :: SharedContext -&gt; Term -&gt; IO TypedSubsTerm
<span class="lineno">  194 </span>typeAllSubterms = error &quot;FIXME HERE&quot;
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>-- | Convert a 'TypedSubsTerm' back to a 'Term'
<span class="lineno">  197 </span>typedSubsTermTerm :: TypedSubsTerm -&gt; Term
<span class="lineno">  198 </span>typedSubsTermTerm = error &quot;FIXME HERE&quot;
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>-- | Get the type of a 'TypedSubsTerm' as a 'TypedSubsTerm'
<span class="lineno">  201 </span>typedSubsTermType :: TypedSubsTerm -&gt; TypedSubsTerm
<span class="lineno">  202 </span>typedSubsTermType tst =
<span class="lineno">  203 </span>  TypedSubsTerm { tpSubsIndex = Nothing, tpSubsFreeVars = tpSubsFreeVars tst,
<span class="lineno">  204 </span>                  tpSubsTermF = tpSubsTypeF tst,
<span class="lineno">  205 </span>                  tpSubsTypeF = FTermF (Sort (tpSubsSort tst) noFlags),
<span class="lineno">  206 </span>                  tpSubsSort = sortOf (tpSubsSort tst) }
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | Count the number of right-nested pi-abstractions of a 'TypedSubsTerm'
<span class="lineno">  209 </span>typedSubsTermArity :: TypedSubsTerm -&gt; Int
<span class="lineno">  210 </span>typedSubsTermArity (TypedSubsTerm { tpSubsTermF = Pi _ _ tst }) =
<span class="lineno">  211 </span>  1 + typedSubsTermArity tst
<span class="lineno">  212 </span>typedSubsTermArity _ = 0
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>-- | Count the number of right-nested pi abstractions in a term, which
<span class="lineno">  215 </span>-- represents a type. This assumes that the type is in WHNF.
<span class="lineno">  216 </span>typeArity :: Term -&gt; Int
<span class="lineno">  217 </span>typeArity tp = length $ fst $ asPiList tp
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>class ToTerm a where
<span class="lineno">  220 </span>  toTerm :: a -&gt; Term
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>instance ToTerm Term where
<span class="lineno">  223 </span>  toTerm = id
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>instance ToTerm TypedSubsTerm where
<span class="lineno">  226 </span>  toTerm = typedSubsTermTerm
<span class="lineno">  227 </span>
<span class="lineno">  228 </span>unsharedApply :: Term -&gt; Term -&gt; Term
<span class="lineno">  229 </span>unsharedApply f arg = Unshared $ App f arg
<span class="lineno">  230 </span>-}
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>----------------------------------------------------------------------
<span class="lineno">  234 </span>-- * Monadifying Types
<span class="lineno">  235 </span>----------------------------------------------------------------------
<span class="lineno">  236 </span>
<span class="lineno">  237 </span>-- | Test if a 'Term' is a first-order function type
<span class="lineno">  238 </span>isFirstOrderType :: Term -&gt; Bool
<span class="lineno">  239 </span><span class="decl"><span class="nottickedoff">isFirstOrderType (asPi -&gt; Just (_, asPi -&gt; Just _, _)) = False</span>
<span class="lineno">  240 </span><span class="spaces"></span><span class="nottickedoff">isFirstOrderType (asPi -&gt; Just (_, _, tp_out)) = isFirstOrderType tp_out</span>
<span class="lineno">  241 </span><span class="spaces"></span><span class="nottickedoff">isFirstOrderType _ = True</span></span>
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>-- | The implicit argument version of 'EventType'
<span class="lineno">  244 </span>type HasSpecMEvType = (?specMEvType :: EventType)
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>-- | The kinds used in monadification, i.e., the types of 'MonType's. These
<span class="lineno">  247 </span>-- correspond to constructors of the SAW core type @KindDesc@, though we only
<span class="lineno">  248 </span>-- use the subset that occur in Cryptol types here
<span class="lineno">  249 </span>data MonKind = MKType | MKNum deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>type MKType = 'MKType
<span class="lineno">  252 </span>type MKNum = 'MKNum
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>-- | The @Num@ type as a SAW core term
<span class="lineno">  255 </span>numTypeOpenTerm :: OpenTerm
<span class="lineno">  256 </span><span class="decl"><span class="nottickedoff">numTypeOpenTerm = dataTypeOpenTerm &quot;Cryptol.Num&quot; []</span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>-- | Representing type-level kinds at the data level
<span class="lineno">  259 </span>data KindRepr (k :: MonKind) where
<span class="lineno">  260 </span>  MKTypeRepr :: KindRepr MKType
<span class="lineno">  261 </span>  MKNumRepr :: KindRepr MKNum
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>-- | Convert a 'KindRepr' to the SAW core type it represents
<span class="lineno">  264 </span>kindReprOpenTerm :: KindRepr k -&gt; OpenTerm
<span class="lineno">  265 </span><span class="decl"><span class="nottickedoff">kindReprOpenTerm MKTypeRepr = sortOpenTerm $ mkSort 0</span>
<span class="lineno">  266 </span><span class="spaces"></span><span class="nottickedoff">kindReprOpenTerm MKNumRepr = numTypeOpenTerm</span></span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>instance TestEquality KindRepr where
<span class="lineno">  269 </span>  -- NOTE: we write the patterns like this so that there are still 2*n cases for
<span class="lineno">  270 </span>  -- n constructors but if we add a new constructor coverage checking will fail
<span class="lineno">  271 </span>  <span class="decl"><span class="nottickedoff">testEquality MKTypeRepr MKTypeRepr = Just Refl</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="nottickedoff">testEquality MKTypeRepr _ = Nothing</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="nottickedoff">testEquality MKNumRepr MKNumRepr = Just Refl</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="nottickedoff">testEquality MKNumRepr _ = Nothing</span></span>
<span class="lineno">  275 </span>
<span class="lineno">  276 </span>-- | A 'KindRepr' for a kind that is determined at runtime
<span class="lineno">  277 </span>data SomeKindRepr where SomeKindRepr :: KindRepr k -&gt; SomeKindRepr
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>-- | A binary operation on @Num@ expressions
<span class="lineno">  280 </span>data NumBinOp = NBinOp_Add | NBinOp_Mul
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>-- | A representation of type-level @Num@ expressions, i.e., SAW core terms of
<span class="lineno">  283 </span>-- type @TpExpr Kind_num@
<span class="lineno">  284 </span>data NumTpExpr
<span class="lineno">  285 </span>     -- | A type-level deBrujn level (not index; see docs on 'MTyVarLvl', below)
<span class="lineno">  286 </span>  = NExpr_VarLvl Natural
<span class="lineno">  287 </span>    -- | A @Num@ value as an expression
<span class="lineno">  288 </span>  | NExpr_Const OpenTerm
<span class="lineno">  289 </span>    -- | A binary operation on @Num@s
<span class="lineno">  290 </span>  | NExpr_BinOp NumBinOp NumTpExpr NumTpExpr
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>-- | The internal (to monadification) representation of a SAW core type that is
<span class="lineno">  293 </span>-- being monadified. Most of these constructors have corresponding constructors
<span class="lineno">  294 </span>-- in the SAW core inductive type @TpDesc@ of type descriptions, other than
<span class="lineno">  295 </span>-- 'MTyIndesc', which represents indescribable types
<span class="lineno">  296 </span>data MonType
<span class="lineno">  297 </span>  = forall k. MTyForall LocalName (KindRepr k) (TpExpr k -&gt; MonType)
<span class="lineno">  298 </span>  | MTyArrow MonType MonType
<span class="lineno">  299 </span>  | MTySeq NumTpExpr MonType
<span class="lineno">  300 </span>  | MTyBool
<span class="lineno">  301 </span>  | MTyBV Natural
<span class="lineno">  302 </span>  | MTyTuple [MonType]
<span class="lineno">  303 </span>  | MTySum MonType MonType
<span class="lineno">  304 </span>    -- | A type with no type description, meaning it cannot be used in a
<span class="lineno">  305 </span>    -- fixpoint
<span class="lineno">  306 </span>  | MTyIndesc OpenTerm
<span class="lineno">  307 </span>    -- | A type-level deBruijn level, where 0 refers to the outermost binding
<span class="lineno">  308 </span>    -- (as opposed to deBruijn indices, where 0 refers to the innermost
<span class="lineno">  309 </span>    -- binding); only used by 'toTpDesc' to convert a 'MonType' to a type
<span class="lineno">  310 </span>    -- description, and should never be seen outside of that function
<span class="lineno">  311 </span>  | MTyVarLvl Natural
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>-- | A type-level expression of the given kind; corresponds to the SAW core type
<span class="lineno">  314 </span>-- @kindElem K@
<span class="lineno">  315 </span>type family TpExpr (k::MonKind) where
<span class="lineno">  316 </span>  TpExpr MKType = MonType
<span class="lineno">  317 </span>  TpExpr MKNum = NumTpExpr
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>-- | A type-level expression whose kind is determined dynamically
<span class="lineno">  320 </span>data SomeTpExpr where SomeTpExpr :: KindRepr k -&gt; TpExpr k -&gt; SomeTpExpr
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>-- | Build a deBruijn level as a type-level expression of a given kind
<span class="lineno">  323 </span>kindVar :: KindRepr k -&gt; Natural -&gt; TpExpr k
<span class="lineno">  324 </span><span class="decl"><span class="nottickedoff">kindVar MKTypeRepr = MTyVarLvl</span>
<span class="lineno">  325 </span><span class="spaces"></span><span class="nottickedoff">kindVar MKNumRepr = NExpr_VarLvl</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | Build a type-level expression from a value of kind @k@
<span class="lineno">  328 </span>kindOfVal :: KindRepr k -&gt; OpenTerm -&gt; TpExpr k
<span class="lineno">  329 </span><span class="decl"><span class="nottickedoff">kindOfVal MKTypeRepr = MTyIndesc</span>
<span class="lineno">  330 </span><span class="spaces"></span><span class="nottickedoff">kindOfVal MKNumRepr = NExpr_Const</span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>-- | Test if a monadification type @tp@ is considered a base type, meaning that
<span class="lineno">  333 </span>-- @CompMT(tp) = CompM MT(tp)@
<span class="lineno">  334 </span>isBaseType :: MonType -&gt; Bool
<span class="lineno">  335 </span><span class="decl"><span class="nottickedoff">isBaseType (MTyForall _ _ _) = False</span>
<span class="lineno">  336 </span><span class="spaces"></span><span class="nottickedoff">isBaseType (MTyArrow _ _) = False</span>
<span class="lineno">  337 </span><span class="spaces"></span><span class="nottickedoff">isBaseType _ = True</span></span>
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>-- | Convert a SAW core 'Term' to a monadification kind, if possible
<span class="lineno">  340 </span>monadifyKind :: Term -&gt; Maybe SomeKindRepr
<span class="lineno">  341 </span><span class="decl"><span class="nottickedoff">monadifyKind (asGlobalApply &quot;Cryptol.Num&quot; -&gt; Just []) = Just $ SomeKindRepr MKNumRepr</span>
<span class="lineno">  342 </span><span class="spaces"></span><span class="nottickedoff">monadifyKind (asSort -&gt; Just s) | s == mkSort 0 = Just $ SomeKindRepr MKTypeRepr</span>
<span class="lineno">  343 </span><span class="spaces"></span><span class="nottickedoff">monadifyKind _ = Nothing</span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>-- | Convert a numeric binary operation to a SAW core binary function on @Num@
<span class="lineno">  346 </span>numBinOpOp :: NumBinOp -&gt; OpenTerm
<span class="lineno">  347 </span><span class="decl"><span class="nottickedoff">numBinOpOp NBinOp_Add = globalOpenTerm &quot;Cryptol.tcAdd&quot;</span>
<span class="lineno">  348 </span><span class="spaces"></span><span class="nottickedoff">numBinOpOp NBinOp_Mul = globalOpenTerm &quot;Cryptol.tcMul&quot;</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>-- | Convert a numeric type expression to a SAW core @Num@ term; it is an error
<span class="lineno">  351 </span>-- if it contains a deBruijn level
<span class="lineno">  352 </span>numExprVal :: NumTpExpr -&gt; OpenTerm
<span class="lineno">  353 </span><span class="decl"><span class="nottickedoff">numExprVal (NExpr_VarLvl _) =</span>
<span class="lineno">  354 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;numExprVal&quot; [&quot;Unexpected deBruijn variable&quot;]</span>
<span class="lineno">  355 </span><span class="spaces"></span><span class="nottickedoff">numExprVal (NExpr_Const n) = n</span>
<span class="lineno">  356 </span><span class="spaces"></span><span class="nottickedoff">numExprVal (NExpr_BinOp op e1 e2) =</span>
<span class="lineno">  357 </span><span class="spaces">  </span><span class="nottickedoff">applyOpenTermMulti (numBinOpOp op) [numExprVal e1, numExprVal e2]</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>-- | Convert a 'MonType' to the argument type @MT(tp)@ it represents; should
<span class="lineno">  360 </span>-- only ever be applied to a 'MonType' that represents a valid SAW core type,
<span class="lineno">  361 </span>-- i.e., one not containing 'MTyNum' or 'MTyVarLvl'
<span class="lineno">  362 </span>toArgType :: HasSpecMEvType =&gt; MonType -&gt; OpenTerm
<span class="lineno">  363 </span><span class="decl"><span class="nottickedoff">toArgType (MTyForall x k body) =</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="nottickedoff">piOpenTerm x (kindReprOpenTerm k) (\e -&gt; toCompType (body $ kindOfVal k e))</span>
<span class="lineno">  365 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTyArrow t1 t2) =</span>
<span class="lineno">  366 </span><span class="spaces">  </span><span class="nottickedoff">arrowOpenTerm &quot;_&quot; (toArgType t1) (toCompType t2)</span>
<span class="lineno">  367 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTySeq n t) =</span>
<span class="lineno">  368 </span><span class="spaces">  </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;SpecM.mseq&quot;)</span>
<span class="lineno">  369 </span><span class="spaces">  </span><span class="nottickedoff">[evTypeTerm ?specMEvType, numExprVal n, toArgType t]</span>
<span class="lineno">  370 </span><span class="spaces"></span><span class="nottickedoff">toArgType MTyBool = boolTypeOpenTerm</span>
<span class="lineno">  371 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTyBV n) = bitvectorTypeOpenTerm $ natOpenTerm n</span>
<span class="lineno">  372 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTyTuple mtps) =</span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="nottickedoff">tupleTypeOpenTerm (map toArgType mtps)</span>
<span class="lineno">  374 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTySum mtp1 mtp2) =</span>
<span class="lineno">  375 </span><span class="spaces">  </span><span class="nottickedoff">dataTypeOpenTerm &quot;Prelude.Either&quot; [toArgType mtp1, toArgType mtp2]</span>
<span class="lineno">  376 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTyIndesc t) = t</span>
<span class="lineno">  377 </span><span class="spaces"></span><span class="nottickedoff">toArgType (MTyVarLvl _) = panic &quot;toArgType&quot; [&quot;Unexpected deBruijn index&quot;]</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>-- | Convert a 'MonType' to the computation type @CompMT(tp)@ it represents
<span class="lineno">  380 </span>toCompType :: HasSpecMEvType =&gt; MonType -&gt; OpenTerm
<span class="lineno">  381 </span><span class="decl"><span class="nottickedoff">toCompType mtp@(MTyForall _ _ _) = toArgType mtp</span>
<span class="lineno">  382 </span><span class="spaces"></span><span class="nottickedoff">toCompType mtp@(MTyArrow _ _) = toArgType mtp</span>
<span class="lineno">  383 </span><span class="spaces"></span><span class="nottickedoff">toCompType mtp = specMTypeOpenTerm ?specMEvType $ toArgType mtp</span></span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>-- | Convert a 'TpExpr' to either an argument type or a @Num@ term, depending on
<span class="lineno">  386 </span>-- its kind
<span class="lineno">  387 </span>tpExprVal :: HasSpecMEvType =&gt; KindRepr k -&gt; TpExpr k -&gt; OpenTerm
<span class="lineno">  388 </span><span class="decl"><span class="nottickedoff">tpExprVal MKTypeRepr = toArgType</span>
<span class="lineno">  389 </span><span class="spaces"></span><span class="nottickedoff">tpExprVal MKNumRepr = numExprVal</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>-- | Convert a 'SomeTpExpr' to either an argument type or a @Num@ term,
<span class="lineno">  392 </span>-- depending on its kind
<span class="lineno">  393 </span>someTpExprVal :: HasSpecMEvType =&gt; SomeTpExpr -&gt; OpenTerm
<span class="lineno">  394 </span><span class="decl"><span class="nottickedoff">someTpExprVal (SomeTpExpr k e) = tpExprVal k e</span></span>
<span class="lineno">  395 </span>
<span class="lineno">  396 </span>-- | Convert a 'MonKind' to the kind description it represents
<span class="lineno">  397 </span>toKindDesc :: KindRepr k -&gt; OpenTerm
<span class="lineno">  398 </span><span class="decl"><span class="nottickedoff">toKindDesc MKTypeRepr = tpKindDesc</span>
<span class="lineno">  399 </span><span class="spaces"></span><span class="nottickedoff">toKindDesc MKNumRepr = numKindDesc</span></span>
<span class="lineno">  400 </span>
<span class="lineno">  401 </span>-- | Convert a numeric binary operation to a SAW core term of type @TpExprBinOp@
<span class="lineno">  402 </span>numBinOpExpr :: NumBinOp -&gt; OpenTerm
<span class="lineno">  403 </span><span class="decl"><span class="nottickedoff">numBinOpExpr NBinOp_Add = ctorOpenTerm &quot;SpecM.BinOp_AddNum&quot; []</span>
<span class="lineno">  404 </span><span class="spaces"></span><span class="nottickedoff">numBinOpExpr NBinOp_Mul = ctorOpenTerm &quot;SpecM.BinOp_MulNum&quot; []</span></span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>-- | Convert a numeric type expression to a type-level expression, i.e., a SAW
<span class="lineno">  407 </span>-- core term of type @TpExpr Kind_num@, assuming the supplied number of bound
<span class="lineno">  408 </span>-- deBruijn levels
<span class="lineno">  409 </span>numExprExpr :: Natural -&gt; NumTpExpr -&gt; OpenTerm
<span class="lineno">  410 </span><span class="decl"><span class="nottickedoff">numExprExpr lvl (NExpr_VarLvl l) =</span>
<span class="lineno">  411 </span><span class="spaces">  </span><span class="nottickedoff">-- Convert to a deBruijn index instead of a level (we use levels because they</span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="nottickedoff">-- are invariant under substitution): since there are lvl free variables, the</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">-- most recently bound is lvl - 1, so this has deBruijn index 0, while the</span>
<span class="lineno">  414 </span><span class="spaces">  </span><span class="nottickedoff">-- least recently bound is 0, so this has deBruijn index lvl - 1; lvl - l - 1</span>
<span class="lineno">  415 </span><span class="spaces">  </span><span class="nottickedoff">-- thus gives us what we need</span>
<span class="lineno">  416 </span><span class="spaces">  </span><span class="nottickedoff">varTpExpr numExprKind (lvl - l - 1)</span>
<span class="lineno">  417 </span><span class="spaces"></span><span class="nottickedoff">numExprExpr _ (NExpr_Const n) = constTpExpr numExprKind n</span>
<span class="lineno">  418 </span><span class="spaces"></span><span class="nottickedoff">numExprExpr lvl (NExpr_BinOp op e1 e2) =</span>
<span class="lineno">  419 </span><span class="spaces">  </span><span class="nottickedoff">binOpTpExpr (numBinOpExpr op) numKindDesc numKindDesc numKindDesc</span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="nottickedoff">(numExprExpr lvl e1) (numExprExpr lvl e2)</span></span>
<span class="lineno">  421 </span>
<span class="lineno">  422 </span>-- | Main implementation of 'toTpDesc'. Convert a 'MonType' to the type
<span class="lineno">  423 </span>-- description it represents, assuming the supplied number of bound deBruijn
<span class="lineno">  424 </span>-- indices. The 'Bool' flag indicates whether the 'MonType' should be treated
<span class="lineno">  425 </span>-- like a function type, meaning that the @Tp_M@ constructor should be added if
<span class="lineno">  426 </span>-- the type is not already a function type.
<span class="lineno">  427 </span>toTpDescH :: Natural -&gt; Bool -&gt; MonType -&gt; OpenTerm
<span class="lineno">  428 </span><span class="decl"><span class="nottickedoff">toTpDescH lvl _ (MTyForall _ k body) =</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="nottickedoff">piTpDesc (toKindDesc k) $ toTpDescH (lvl+1) True $ body $ kindVar k lvl</span>
<span class="lineno">  430 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH lvl _ (MTyArrow mtp1 mtp2) =</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="nottickedoff">arrowTpDesc (toTpDescH lvl False mtp1) (toTpDescH lvl True mtp2)</span>
<span class="lineno">  432 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH lvl True mtp =</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="nottickedoff">-- Convert a non-functional type to a functional one by making a nullary</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="nottickedoff">-- monadic function, i.e., applying the @SpecM@ type constructor</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="nottickedoff">mTpDesc $ toTpDescH lvl False mtp</span>
<span class="lineno">  436 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH lvl False (MTySeq n mtp) =</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="nottickedoff">seqTpDesc (numExprExpr lvl n) (toTpDescH lvl False mtp)</span>
<span class="lineno">  438 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH _ False MTyBool = boolTpDesc</span>
<span class="lineno">  439 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH _ False (MTyBV w) = bvTpDesc w</span>
<span class="lineno">  440 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH lvl False (MTyTuple mtps) =</span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="nottickedoff">tupleTpDesc (map (toTpDescH lvl False) mtps)</span>
<span class="lineno">  442 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH lvl False (MTySum mtp1 mtp2) =</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="nottickedoff">sumTpDesc (toTpDescH lvl False mtp1) (toTpDescH lvl False mtp2)</span>
<span class="lineno">  444 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH _ _ (MTyIndesc trm) =</span>
<span class="lineno">  445 </span><span class="spaces">  </span><span class="nottickedoff">bindPPOpenTerm trm $ \pp_trm -&gt;</span>
<span class="lineno">  446 </span><span class="spaces">  </span><span class="nottickedoff">failOpenTerm (&quot;toTpDescH: indescribable type:\n&quot; ++ pp_trm)</span>
<span class="lineno">  447 </span><span class="spaces"></span><span class="nottickedoff">toTpDescH lvl False (MTyVarLvl l) =</span>
<span class="lineno">  448 </span><span class="spaces">  </span><span class="nottickedoff">-- Convert a deBruijn level to a deBruijn index; see comments in numExprExpr</span>
<span class="lineno">  449 </span><span class="spaces">  </span><span class="nottickedoff">varTpDesc (lvl - l - 1)</span></span>
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>-- | Convert a 'MonType' to the type description it represents
<span class="lineno">  452 </span>toTpDesc :: MonType -&gt; OpenTerm
<span class="lineno">  453 </span><span class="decl"><span class="nottickedoff">toTpDesc = toTpDescH 0 False</span></span>
<span class="lineno">  454 </span>
<span class="lineno">  455 </span>-- | The mapping for monadifying Cryptol typeclasses
<span class="lineno">  456 </span>-- FIXME: this is no longer needed, as it is now the identity
<span class="lineno">  457 </span>typeclassMonMap :: [(Ident,Ident)]
<span class="lineno">  458 </span><span class="decl"><span class="nottickedoff">typeclassMonMap =</span>
<span class="lineno">  459 </span><span class="spaces">  </span><span class="nottickedoff">[(&quot;Cryptol.PEq&quot;, &quot;Cryptol.PEq&quot;),</span>
<span class="lineno">  460 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PCmp&quot;, &quot;Cryptol.PCmp&quot;),</span>
<span class="lineno">  461 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PSignedCmp&quot;, &quot;Cryptol.PSignedCmp&quot;),</span>
<span class="lineno">  462 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PZero&quot;, &quot;Cryptol.PZero&quot;),</span>
<span class="lineno">  463 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PLogic&quot;, &quot;Cryptol.PLogic&quot;),</span>
<span class="lineno">  464 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PRing&quot;, &quot;Cryptol.PRing&quot;),</span>
<span class="lineno">  465 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PIntegral&quot;, &quot;Cryptol.PIntegral&quot;),</span>
<span class="lineno">  466 </span><span class="spaces">   </span><span class="nottickedoff">(&quot;Cryptol.PLiteral&quot;, &quot;Cryptol.PLiteral&quot;)]</span></span>
<span class="lineno">  467 </span>
<span class="lineno">  468 </span>-- | The mapping for monadifying type-level binary @Num@ operations
<span class="lineno">  469 </span>numBinOpMonMap :: [(Ident,NumBinOp)]
<span class="lineno">  470 </span><span class="decl"><span class="nottickedoff">numBinOpMonMap =</span>
<span class="lineno">  471 </span><span class="spaces">  </span><span class="nottickedoff">[(&quot;Cryptol.tcAdd&quot;, NBinOp_Add), (&quot;Cryptol.tcMul&quot;, NBinOp_Mul)</span>
<span class="lineno">  472 </span><span class="spaces">   </span><span class="nottickedoff">-- FIXME: handle the others:</span>
<span class="lineno">  473 </span><span class="spaces">   </span><span class="nottickedoff">-- &quot;Cryptol.tcSub&quot;, &quot;Cryptol.tcDiv&quot;, &quot;Cryptol.tcMod&quot;, &quot;Cryptol.tcExp&quot;,</span>
<span class="lineno">  474 </span><span class="spaces">   </span><span class="nottickedoff">-- &quot;Cryptol.tcMin&quot;, &quot;Cryptol.tcMax&quot;</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="nottickedoff">]</span></span>
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>-- | A context of local variables used for monadifying types, which includes the
<span class="lineno">  478 </span>-- variable names, their original types (before monadification), and an optional
<span class="lineno">  479 </span>-- 'MonType' bound to the variable if its type corresponds to a 'MonKind',
<span class="lineno">  480 </span>-- meaning its binding site is being translated into an 'MTyForall'.
<span class="lineno">  481 </span>--
<span class="lineno">  482 </span>-- NOTE: the reason this type is different from 'MonadifyCtx', the context type
<span class="lineno">  483 </span>-- for monadifying terms, is that monadifying arrow types does not introduce a
<span class="lineno">  484 </span>-- local 'MonTerm' argument, since they are not dependent functions and so do
<span class="lineno">  485 </span>-- not use a HOAS encoding.
<span class="lineno">  486 </span>type MonadifyTypeCtx = [(LocalName, Term, Maybe SomeTpExpr)]
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>-- | Pretty-print a 'Term' relative to a 'MonadifyTypeCtx'
<span class="lineno">  489 </span>ppTermInTypeCtx :: MonadifyTypeCtx -&gt; Term -&gt; String
<span class="lineno">  490 </span><span class="decl"><span class="nottickedoff">ppTermInTypeCtx ctx t =</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="nottickedoff">scPrettyTermInCtx PPS.defaultOpts (map (\(x,_,_) -&gt; x) ctx) t</span></span>
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>-- | Extract the variables and their original types from a 'MonadifyTypeCtx'
<span class="lineno">  494 </span>typeCtxPureCtx :: MonadifyTypeCtx -&gt; [(LocalName,Term)]
<span class="lineno">  495 </span><span class="decl"><span class="nottickedoff">typeCtxPureCtx = map (\(x,tp,_) -&gt; (x,tp))</span></span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | Monadify a type and convert it to its corresponding argument type
<span class="lineno">  499 </span>monadifyTypeArgType :: (HasCallStack, HasSpecMEvType) =&gt; MonadifyTypeCtx -&gt;
<span class="lineno">  500 </span>                       Term -&gt; OpenTerm
<span class="lineno">  501 </span><span class="decl"><span class="nottickedoff">monadifyTypeArgType ctx t = toArgType $ monadifyType ctx t</span></span>
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>-- | Check if a type-level operation, given by identifier, matching a 'NumBinOp'
<span class="lineno">  504 </span>monadifyNumBinOp :: Ident -&gt; Maybe NumBinOp
<span class="lineno">  505 </span><span class="decl"><span class="nottickedoff">monadifyNumBinOp i = lookup i numBinOpMonMap</span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>-- | Convert a SAW core 'Term' to a type-level expression of some kind, or panic
<span class="lineno">  509 </span>-- if this is not possible
<span class="lineno">  510 </span>monadifyTpExpr :: (HasCallStack, HasSpecMEvType) =&gt; MonadifyTypeCtx -&gt; Term -&gt;
<span class="lineno">  511 </span>                  SomeTpExpr
<span class="lineno">  512 </span>{-
<span class="lineno">  513 </span>monadifyTpExpr ctx t
<span class="lineno">  514 </span>  | trace (&quot;\nmonadifyTpExpr:\n&quot; ++ ppTermInTypeCtx ctx t) False = undefined
<span class="lineno">  515 </span>-}
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>-- Type cases
<span class="lineno">  518 </span><span class="decl"><span class="nottickedoff">monadifyTpExpr ctx (asPi -&gt; Just (x, tp_in, tp_out))</span>
<span class="lineno">  519 </span><span class="spaces">  </span><span class="nottickedoff">| Just (SomeKindRepr k) &lt;- monadifyKind tp_in =</span>
<span class="lineno">  520 </span><span class="spaces">    </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $</span>
<span class="lineno">  521 </span><span class="spaces">    </span><span class="nottickedoff">MTyForall x k (\tp' -&gt;</span>
<span class="lineno">  522 </span><span class="spaces">                    </span><span class="nottickedoff">let ctx' = (x,tp_in,Just (SomeTpExpr k tp')):ctx in</span>
<span class="lineno">  523 </span><span class="spaces">                    </span><span class="nottickedoff">monadifyType ctx' tp_out)</span>
<span class="lineno">  524 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx tp@(asPi -&gt; Just (_, _, tp_out))</span>
<span class="lineno">  525 </span><span class="spaces">  </span><span class="nottickedoff">| inBitSet 0 (looseVars tp_out) =</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: make this a failure instead of an error</span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;monadifyType: &quot; ++</span>
<span class="lineno">  528 </span><span class="spaces">           </span><span class="nottickedoff">&quot;dependent function type with non-kind argument type: &quot; ++</span>
<span class="lineno">  529 </span><span class="spaces">           </span><span class="nottickedoff">ppTermInTypeCtx ctx tp)</span>
<span class="lineno">  530 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx tp@(asPi -&gt; Just (x, tp_in, tp_out)) =</span>
<span class="lineno">  531 </span><span class="spaces">  </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $</span>
<span class="lineno">  532 </span><span class="spaces">  </span><span class="nottickedoff">MTyArrow (monadifyType ctx tp_in) (monadifyType ((x,tp,Nothing):ctx) tp_out)</span>
<span class="lineno">  533 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asTupleType -&gt; Just tps) =</span>
<span class="lineno">  534 </span><span class="spaces">  </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $ MTyTuple (map (monadifyType ctx) tps)</span>
<span class="lineno">  535 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno">  536 </span><span class="spaces"></span><span class="nottickedoff">monadifyType ctx (asRecordType -&gt; Just tps) =</span>
<span class="lineno">  537 </span><span class="spaces">  </span><span class="nottickedoff">MTyRecord $ map (\(fld,tp) -&gt; (fld, monadifyType ctx tp)) $ Map.toList tps</span>
<span class="lineno">  538 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  539 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asGlobalApply &quot;Prelude.Eq&quot; -&gt; Just [k_trm, tp1, tp2])</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="nottickedoff">| isJust (monadifyKind k_trm) =</span>
<span class="lineno">  541 </span><span class="spaces">    </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="nottickedoff">-- NOTE: technically this is a Prop and not a sort 0, but it doesn't matter</span>
<span class="lineno">  543 </span><span class="spaces">    </span><span class="nottickedoff">MTyIndesc $ dataTypeOpenTerm &quot;Prelude.Eq&quot; [monadifyTypeArgType ctx tp1,</span>
<span class="lineno">  544 </span><span class="spaces">                                               </span><span class="nottickedoff">monadifyTypeArgType ctx tp2]</span>
<span class="lineno">  545 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr _ (asBitvectorType -&gt; Just w) =</span>
<span class="lineno">  546 </span><span class="spaces">  </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $ MTyBV w</span>
<span class="lineno">  547 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asVectorType -&gt; Just (asNat -&gt; Just n, a)) =</span>
<span class="lineno">  548 </span><span class="spaces">  </span><span class="nottickedoff">let nM = NExpr_Const $ ctorOpenTerm &quot;Cryptol.TCNum&quot; [natOpenTerm n]</span>
<span class="lineno">  549 </span><span class="spaces">   </span><span class="nottickedoff">in SomeTpExpr MKTypeRepr $ MTySeq nM (monadifyType ctx a)</span>
<span class="lineno">  550 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asApplyAll -&gt; ((asGlobalDef -&gt; Just seq_id), [n, a]))</span>
<span class="lineno">  551 </span><span class="spaces">  </span><span class="nottickedoff">| seq_id == &quot;Cryptol.seq&quot; =</span>
<span class="lineno">  552 </span><span class="spaces">    </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $ MTySeq (monadifyNum ctx n) (monadifyType ctx a)</span>
<span class="lineno">  553 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asApp -&gt; Just ((asGlobalDef -&gt; Just f), arg))</span>
<span class="lineno">  554 </span><span class="spaces">  </span><span class="nottickedoff">| Just f_trans &lt;- lookup f typeclassMonMap =</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $ MTyIndesc $</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="nottickedoff">applyOpenTerm (globalOpenTerm f_trans) $ monadifyTypeArgType ctx arg</span>
<span class="lineno">  557 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr _ (asGlobalDef -&gt; Just bool_id)</span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="nottickedoff">| bool_id == &quot;Prelude.Bool&quot; = </span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $ MTyBool</span>
<span class="lineno">  560 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr _ (asGlobalDef -&gt; Just integer_id)</span>
<span class="lineno">  561 </span><span class="spaces">  </span><span class="nottickedoff">| integer_id == &quot;Prelude.Integer&quot; =</span>
<span class="lineno">  562 </span><span class="spaces">    </span><span class="nottickedoff">SomeTpExpr MKTypeRepr $ MTyIndesc $ globalOpenTerm &quot;Prelude.Integer&quot;</span>
<span class="lineno">  563 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno">  564 </span><span class="spaces"></span><span class="nottickedoff">monadifyType ctx (asApplyAll -&gt; (f, args))</span>
<span class="lineno">  565 </span><span class="spaces">  </span><span class="nottickedoff">| Just glob &lt;- asTypedGlobalDef f</span>
<span class="lineno">  566 </span><span class="spaces">  </span><span class="nottickedoff">, Just ec_k &lt;- monadifyKind $ globalDefType glob</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="nottickedoff">, margs &lt;- map (monadifyType ctx) args</span>
<span class="lineno">  568 </span><span class="spaces">  </span><span class="nottickedoff">, Just k_out &lt;- applyKinds ec_k margs =</span>
<span class="lineno">  569 </span><span class="spaces">    </span><span class="nottickedoff">MTyBase k_out (applyOpenTermMulti (globalDefOpenTerm glob) $</span>
<span class="lineno">  570 </span><span class="spaces">                   </span><span class="nottickedoff">map toArgType margs)</span>
<span class="lineno">  571 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno">  572 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  573 </span><span class="spaces"></span><span class="nottickedoff">-- Num cases</span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr _ (asGlobalApply &quot;Cryptol.TCInf&quot; -&gt; Just [])</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="nottickedoff">= SomeTpExpr MKNumRepr $ NExpr_Const $ ctorOpenTerm &quot;Cryptol.TCInf&quot; []</span>
<span class="lineno">  576 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr _ (asGlobalApply &quot;Cryptol.TCNum&quot; -&gt; Just [asNat -&gt; Just n])</span>
<span class="lineno">  577 </span><span class="spaces">  </span><span class="nottickedoff">= SomeTpExpr MKNumRepr $ NExpr_Const $ ctorOpenTerm &quot;Cryptol.TCNum&quot; [natOpenTerm n]</span>
<span class="lineno">  578 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asApplyAll -&gt; ((asGlobalDef -&gt; Just f), [arg1, arg2]))</span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="nottickedoff">| Just op &lt;- monadifyNumBinOp f</span>
<span class="lineno">  580 </span><span class="spaces">  </span><span class="nottickedoff">= SomeTpExpr MKNumRepr $ NExpr_BinOp op (monadifyNum ctx arg1) (monadifyNum ctx arg2)</span>
<span class="lineno">  581 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx (asLocalVar -&gt; Just i)</span>
<span class="lineno">  582 </span><span class="spaces">  </span><span class="nottickedoff">| i &lt; length ctx</span>
<span class="lineno">  583 </span><span class="spaces">  </span><span class="nottickedoff">, (_,_,Just (SomeTpExpr k e)) &lt;- ctx!!i = SomeTpExpr k e</span>
<span class="lineno">  584 </span><span class="spaces"></span><span class="nottickedoff">monadifyTpExpr ctx tp =</span>
<span class="lineno">  585 </span><span class="spaces">  </span><span class="nottickedoff">-- XXX this doesn't look like it should be a panic</span>
<span class="lineno">  586 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;monadifyTpExpr&quot; [</span>
<span class="lineno">  587 </span><span class="spaces">      </span><span class="nottickedoff">&quot;Not a valid type or numeric expression for monadification: &quot; &lt;&gt;</span>
<span class="lineno">  588 </span><span class="spaces">          </span><span class="nottickedoff">T.pack (ppTermInTypeCtx ctx tp)</span>
<span class="lineno">  589 </span><span class="spaces">  </span><span class="nottickedoff">]</span></span>
<span class="lineno">  590 </span>
<span class="lineno">  591 </span>-- | Convert a SAW core 'Term' to a monadification type, or panic if this is not
<span class="lineno">  592 </span>-- possible
<span class="lineno">  593 </span>monadifyType :: (HasCallStack, HasSpecMEvType) =&gt; MonadifyTypeCtx -&gt; Term -&gt;
<span class="lineno">  594 </span>                MonType
<span class="lineno">  595 </span><span class="decl"><span class="nottickedoff">monadifyType ctx t</span>
<span class="lineno">  596 </span><span class="spaces">  </span><span class="nottickedoff">| SomeTpExpr MKTypeRepr tp &lt;- monadifyTpExpr ctx t = tp</span>
<span class="lineno">  597 </span><span class="spaces"></span><span class="nottickedoff">monadifyType ctx t =</span>
<span class="lineno">  598 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;monadifyType&quot; [&quot;Not a type: &quot; &lt;&gt; T.pack (ppTermInTypeCtx ctx t)]</span></span>
<span class="lineno">  599 </span>
<span class="lineno">  600 </span>-- | Convert a SAW core 'Term' to a type-level numeric expression, or panic if
<span class="lineno">  601 </span>-- this is not possible
<span class="lineno">  602 </span>monadifyNum :: (HasCallStack, HasSpecMEvType) =&gt; MonadifyTypeCtx -&gt; Term -&gt;
<span class="lineno">  603 </span>               NumTpExpr
<span class="lineno">  604 </span><span class="decl"><span class="nottickedoff">monadifyNum ctx t</span>
<span class="lineno">  605 </span><span class="spaces">  </span><span class="nottickedoff">| SomeTpExpr MKNumRepr e &lt;- monadifyTpExpr ctx t = e</span>
<span class="lineno">  606 </span><span class="spaces"></span><span class="nottickedoff">monadifyNum ctx t =</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;monadifyNum&quot; [&quot;Not a numeric expression: &quot; &lt;&gt; T.pack (ppTermInTypeCtx ctx t)]</span></span>
<span class="lineno">  608 </span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>----------------------------------------------------------------------
<span class="lineno">  611 </span>-- * Monadified Terms
<span class="lineno">  612 </span>----------------------------------------------------------------------
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>-- | A representation of a term that has been translated to argument type
<span class="lineno">  615 </span>-- @MT(tp)@
<span class="lineno">  616 </span>data ArgMonTerm
<span class="lineno">  617 </span>    -- | A monadification term of a base type @MT(tp)@
<span class="lineno">  618 </span>  = BaseMonTerm MonType OpenTerm
<span class="lineno">  619 </span>    -- | A monadification term of non-depedent function type
<span class="lineno">  620 </span>  | FunMonTerm LocalName MonType MonType (ArgMonTerm -&gt; MonTerm)
<span class="lineno">  621 </span>    -- | A monadification term of polymorphic type
<span class="lineno">  622 </span>  | forall k. ForallMonTerm LocalName (KindRepr k) (TpExpr k -&gt; MonTerm)
<span class="lineno">  623 </span>
<span class="lineno">  624 </span>-- | A representation of a term that has been translated to computational type
<span class="lineno">  625 </span>-- @CompMT(tp)@
<span class="lineno">  626 </span>data MonTerm
<span class="lineno">  627 </span>  = ArgMonTerm ArgMonTerm
<span class="lineno">  628 </span>  | CompMonTerm MonType OpenTerm
<span class="lineno">  629 </span>
<span class="lineno">  630 </span>-- | An argument to a 'MonTerm' of functional type
<span class="lineno">  631 </span>data MonArg
<span class="lineno">  632 </span>     -- | A type-level expression argument to a polymorphic function
<span class="lineno">  633 </span>  = forall k. TpArg (KindRepr k) (TpExpr k)
<span class="lineno">  634 </span>    -- | A term-level argument to a non-dependent function
<span class="lineno">  635 </span>  | TrmArg ArgMonTerm
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>-- | Convert a 'SomeTpExpr' to a type-level 'MonArg' argument
<span class="lineno">  638 </span>tpExprToArg :: SomeTpExpr -&gt; MonArg
<span class="lineno">  639 </span><span class="decl"><span class="nottickedoff">tpExprToArg (SomeTpExpr k e) = TpArg k e</span></span>
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>-- | Convert a numeric expression to a type-level 'MonArg' argument
<span class="lineno">  642 </span>numToArg :: NumTpExpr -&gt; MonArg
<span class="lineno">  643 </span><span class="decl"><span class="nottickedoff">numToArg = TpArg MKNumRepr</span></span>
<span class="lineno">  644 </span>
<span class="lineno">  645 </span>-- | Get the monadification type of a monadification term
<span class="lineno">  646 </span>class GetMonType a where
<span class="lineno">  647 </span>  getMonType :: a -&gt; MonType
<span class="lineno">  648 </span>
<span class="lineno">  649 </span>instance GetMonType ArgMonTerm where
<span class="lineno">  650 </span>  <span class="decl"><span class="nottickedoff">getMonType (BaseMonTerm tp _) = tp</span>
<span class="lineno">  651 </span><span class="spaces">  </span><span class="nottickedoff">getMonType (ForallMonTerm x k body) = MTyForall x k (getMonType . body)</span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="nottickedoff">getMonType (FunMonTerm _ tp_in tp_out _) = MTyArrow tp_in tp_out</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>instance GetMonType MonTerm where
<span class="lineno">  655 </span>  <span class="decl"><span class="nottickedoff">getMonType (ArgMonTerm t) = getMonType t</span>
<span class="lineno">  656 </span><span class="spaces">  </span><span class="nottickedoff">getMonType (CompMonTerm tp _) = tp</span></span>
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>
<span class="lineno">  659 </span>-- | Convert a monadification term to a SAW core term of type @CompMT(tp)@
<span class="lineno">  660 </span>class ToCompTerm a where
<span class="lineno">  661 </span>  toCompTerm :: HasSpecMEvType =&gt; a -&gt; OpenTerm
<span class="lineno">  662 </span>
<span class="lineno">  663 </span>instance ToCompTerm ArgMonTerm where
<span class="lineno">  664 </span>  <span class="decl"><span class="nottickedoff">toCompTerm (BaseMonTerm mtp t) =</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="nottickedoff">retSOpenTerm ?specMEvType (toArgType mtp) t</span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="nottickedoff">toCompTerm (FunMonTerm x tp_in _ body) =</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="nottickedoff">lambdaOpenTerm x (toArgType tp_in) (toCompTerm . body . fromArgTerm tp_in)</span>
<span class="lineno">  668 </span><span class="spaces">  </span><span class="nottickedoff">toCompTerm (ForallMonTerm x k body) =</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="nottickedoff">lambdaOpenTerm x (kindReprOpenTerm k) (toCompTerm . body . kindOfVal k)</span></span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>instance ToCompTerm MonTerm where
<span class="lineno">  672 </span>  <span class="decl"><span class="nottickedoff">toCompTerm (ArgMonTerm amtrm) = toCompTerm amtrm</span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="nottickedoff">toCompTerm (CompMonTerm _ trm) = trm</span></span>
<span class="lineno">  674 </span>
<span class="lineno">  675 </span>
<span class="lineno">  676 </span>-- | Convert an 'ArgMonTerm' to a SAW core term of type @MT(tp)@
<span class="lineno">  677 </span>toArgTerm :: HasSpecMEvType =&gt; ArgMonTerm -&gt; OpenTerm
<span class="lineno">  678 </span><span class="decl"><span class="nottickedoff">toArgTerm (BaseMonTerm _ t) = t</span>
<span class="lineno">  679 </span><span class="spaces"></span><span class="nottickedoff">toArgTerm t = toCompTerm t</span></span>
<span class="lineno">  680 </span>
<span class="lineno">  681 </span>
<span class="lineno">  682 </span>-- | Build a monadification term from a term of type @MT(tp)@
<span class="lineno">  683 </span>class FromArgTerm a where
<span class="lineno">  684 </span>  fromArgTerm :: HasSpecMEvType =&gt; MonType -&gt; OpenTerm -&gt; a
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>instance FromArgTerm ArgMonTerm where
<span class="lineno">  687 </span>  <span class="decl"><span class="nottickedoff">fromArgTerm (MTyForall x k body) t =</span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="nottickedoff">ForallMonTerm x k (\tp -&gt; fromCompTerm (body tp) (applyOpenTerm t $</span>
<span class="lineno">  689 </span><span class="spaces">                                                      </span><span class="nottickedoff">tpExprVal k tp))</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="nottickedoff">fromArgTerm (MTyArrow t1 t2) t =</span>
<span class="lineno">  691 </span><span class="spaces">    </span><span class="nottickedoff">FunMonTerm &quot;_&quot; t1 t2 (\x -&gt; fromCompTerm t2 (applyOpenTerm t $ toArgTerm x))</span>
<span class="lineno">  692 </span><span class="spaces">  </span><span class="nottickedoff">fromArgTerm tp t = BaseMonTerm tp t</span></span>
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>instance FromArgTerm MonTerm where
<span class="lineno">  695 </span>  <span class="decl"><span class="nottickedoff">fromArgTerm mtp t = ArgMonTerm $ fromArgTerm mtp t</span></span>
<span class="lineno">  696 </span>
<span class="lineno">  697 </span>-- | Build a monadification term from a computational term of type @CompMT(tp)@
<span class="lineno">  698 </span>fromCompTerm :: HasSpecMEvType =&gt; MonType -&gt; OpenTerm -&gt; MonTerm
<span class="lineno">  699 </span><span class="decl"><span class="nottickedoff">fromCompTerm mtp t | isBaseType mtp = CompMonTerm mtp t</span>
<span class="lineno">  700 </span><span class="spaces"></span><span class="nottickedoff">fromCompTerm mtp t = ArgMonTerm $ fromArgTerm mtp t</span></span>
<span class="lineno">  701 </span>
<span class="lineno">  702 </span>-- | Test if a monadification type @tp@ is pure, meaning @MT(tp)=tp@
<span class="lineno">  703 </span>monTypeIsPure :: MonType -&gt; Bool
<span class="lineno">  704 </span><span class="decl"><span class="nottickedoff">monTypeIsPure (MTyForall _ _ _) = False</span>
<span class="lineno">  705 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTyArrow _ _) = False</span>
<span class="lineno">  706 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTySeq _ _) = False</span>
<span class="lineno">  707 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure MTyBool = True</span>
<span class="lineno">  708 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTyBV _) = True</span>
<span class="lineno">  709 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTyTuple mtps) = all monTypeIsPure mtps</span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTySum mtp1 mtp2) = monTypeIsPure mtp1 &amp;&amp; monTypeIsPure mtp2</span>
<span class="lineno">  711 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTyIndesc _) = True</span>
<span class="lineno">  712 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsPure (MTyVarLvl _) =</span>
<span class="lineno">  713 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;monTypeIsPure&quot; [&quot;Unexpected type variable&quot;]</span></span>
<span class="lineno">  714 </span>
<span class="lineno">  715 </span>-- | Test if a monadification type @tp@ is semi-pure, meaning @SemiP(tp) = tp@,
<span class="lineno">  716 </span>-- where @SemiP@ is defined in the documentation for 'fromSemiPureTermFun' below
<span class="lineno">  717 </span>monTypeIsSemiPure :: MonType -&gt; Bool
<span class="lineno">  718 </span><span class="decl"><span class="nottickedoff">monTypeIsSemiPure (MTyForall _ k tp_f) =</span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="nottickedoff">monTypeIsSemiPure $ tp_f $ kindOfVal k $</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="nottickedoff">-- This dummy OpenTerm should never be inspected by the recursive call</span>
<span class="lineno">  721 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;monTypeIsSemiPure&quot;</span>
<span class="lineno">  722 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTyArrow tp_in tp_out) =</span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="nottickedoff">monTypeIsPure tp_in &amp;&amp; monTypeIsSemiPure tp_out</span>
<span class="lineno">  724 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTySeq _ _) = False</span>
<span class="lineno">  725 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure MTyBool = True</span>
<span class="lineno">  726 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTyBV _) = True</span>
<span class="lineno">  727 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTyTuple mtps) =</span>
<span class="lineno">  728 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: functions in pairs are not semi-pure; only pure types in pairs are</span>
<span class="lineno">  729 </span><span class="spaces">  </span><span class="nottickedoff">-- semi-pure</span>
<span class="lineno">  730 </span><span class="spaces">  </span><span class="nottickedoff">all monTypeIsPure mtps</span>
<span class="lineno">  731 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTySum mtp1 mtp2) =</span>
<span class="lineno">  732 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: same as pairs</span>
<span class="lineno">  733 </span><span class="spaces">  </span><span class="nottickedoff">monTypeIsPure mtp1 &amp;&amp; monTypeIsPure mtp2</span>
<span class="lineno">  734 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTyIndesc _) = True</span>
<span class="lineno">  735 </span><span class="spaces"></span><span class="nottickedoff">monTypeIsSemiPure (MTyVarLvl _) =</span>
<span class="lineno">  736 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;monTypeIsSemiPure&quot; [&quot;Unexpected type variable&quot;]</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>-- | Build a monadification term from a function on terms which, when viewed as
<span class="lineno">  739 </span>-- a lambda, is a &quot;semi-pure&quot; function of the given monadification type, meaning
<span class="lineno">  740 </span>-- it maps terms of argument type @MT(tp)@ to an output value of argument type;
<span class="lineno">  741 </span>-- i.e., it has type @SemiP(tp)@, defined as:
<span class="lineno">  742 </span>--
<span class="lineno">  743 </span>-- &gt; SemiP(Pi x (sort 0) b) = Pi x (sort 0) SemiP(b)
<span class="lineno">  744 </span>-- &gt; SemiP(Pi x Num b) = Pi x Num SemiP(b)
<span class="lineno">  745 </span>-- &gt; SemiP(Pi _ a b) = MT(a) -&gt; SemiP(b)
<span class="lineno">  746 </span>-- &gt; SemiP(a) = MT(a)
<span class="lineno">  747 </span>fromSemiPureTermFun :: HasSpecMEvType =&gt; MonType -&gt; ([OpenTerm] -&gt; OpenTerm) -&gt;
<span class="lineno">  748 </span>                       ArgMonTerm
<span class="lineno">  749 </span><span class="decl"><span class="nottickedoff">fromSemiPureTermFun (MTyForall x k body) f =</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="nottickedoff">ForallMonTerm x k $ \e -&gt;</span>
<span class="lineno">  751 </span><span class="spaces">  </span><span class="nottickedoff">ArgMonTerm $ fromSemiPureTermFun (body e) (f . (tpExprVal k e:))</span>
<span class="lineno">  752 </span><span class="spaces"></span><span class="nottickedoff">fromSemiPureTermFun (MTyArrow t1 t2) f =</span>
<span class="lineno">  753 </span><span class="spaces">  </span><span class="nottickedoff">FunMonTerm &quot;_&quot; t1 t2 $ \x -&gt;</span>
<span class="lineno">  754 </span><span class="spaces">  </span><span class="nottickedoff">ArgMonTerm $ fromSemiPureTermFun t2 (f . (toArgTerm x:))</span>
<span class="lineno">  755 </span><span class="spaces"></span><span class="nottickedoff">fromSemiPureTermFun tp f = BaseMonTerm tp (f [])</span></span>
<span class="lineno">  756 </span>
<span class="lineno">  757 </span>-- | Like 'fromSemiPureTermFun' but use a term rather than a term function
<span class="lineno">  758 </span>fromSemiPureTerm :: HasSpecMEvType =&gt; MonType -&gt; OpenTerm -&gt; ArgMonTerm
<span class="lineno">  759 </span><span class="decl"><span class="nottickedoff">fromSemiPureTerm mtp t = fromSemiPureTermFun mtp (applyOpenTermMulti t)</span></span>
<span class="lineno">  760 </span>
<span class="lineno">  761 </span>-- | Build an 'ArgMonTerm' that 'fail's when converted to a term
<span class="lineno">  762 </span>failArgMonTerm :: HasSpecMEvType =&gt; MonType -&gt; String -&gt; ArgMonTerm
<span class="lineno">  763 </span><span class="decl"><span class="nottickedoff">failArgMonTerm tp str = BaseMonTerm tp (failOpenTerm str)</span></span>
<span class="lineno">  764 </span>
<span class="lineno">  765 </span>-- | Build a 'MonTerm' that 'fail's when converted to a term
<span class="lineno">  766 </span>failMonTerm :: HasSpecMEvType =&gt; MonType -&gt; String -&gt; MonTerm
<span class="lineno">  767 </span><span class="decl"><span class="nottickedoff">failMonTerm tp str = ArgMonTerm $ failArgMonTerm tp str</span></span>
<span class="lineno">  768 </span>
<span class="lineno">  769 </span>-- | Apply a monadified type to a type or term argument in the sense of
<span class="lineno">  770 </span>-- 'applyPiOpenTerm', meaning give the type of applying @f@ of a type to a
<span class="lineno">  771 </span>-- particular argument @arg@
<span class="lineno">  772 </span>applyMonType :: HasCallStack =&gt; MonType -&gt; MonArg -&gt; MonType
<span class="lineno">  773 </span><span class="decl"><span class="nottickedoff">applyMonType (MTyForall _ k1 f) (TpArg k2 t)</span>
<span class="lineno">  774 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality k1 k2 = f t</span>
<span class="lineno">  775 </span><span class="spaces"></span><span class="nottickedoff">applyMonType (MTyArrow _ tp_ret) (TrmArg _) = tp_ret</span>
<span class="lineno">  776 </span><span class="spaces"></span><span class="nottickedoff">applyMonType _ _ = error &quot;applyMonType: application at incorrect type&quot;</span></span>
<span class="lineno">  777 </span>
<span class="lineno">  778 </span>-- | Apply a monadified term to a type or term argument
<span class="lineno">  779 </span>applyMonTerm :: HasCallStack =&gt; MonTerm -&gt; MonArg -&gt; MonTerm
<span class="lineno">  780 </span><span class="decl"><span class="nottickedoff">applyMonTerm (ArgMonTerm (ForallMonTerm _ k1 f)) (TpArg k2 e)</span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality k1 k2 = f e</span>
<span class="lineno">  782 </span><span class="spaces"></span><span class="nottickedoff">applyMonTerm (ArgMonTerm (FunMonTerm _ _ _ f)) (TrmArg arg) = f arg</span>
<span class="lineno">  783 </span><span class="spaces"></span><span class="nottickedoff">applyMonTerm (ArgMonTerm (ForallMonTerm _ _ _)) _ =</span>
<span class="lineno">  784 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;applyMonTerm&quot; [&quot;Application of term at incorrect type&quot;]</span>
<span class="lineno">  785 </span><span class="spaces"></span><span class="nottickedoff">applyMonTerm (ArgMonTerm (FunMonTerm _ _ _ _)) _ =</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;applyMonTerm&quot; [&quot;Application of term at incorrect type&quot;]</span>
<span class="lineno">  787 </span><span class="spaces"></span><span class="nottickedoff">applyMonTerm (ArgMonTerm (BaseMonTerm _ _)) _ =</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;applyMonTerm&quot; [&quot;Application of non-functional pure term&quot;]</span>
<span class="lineno">  789 </span><span class="spaces"></span><span class="nottickedoff">applyMonTerm (CompMonTerm _ _) _ =</span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="nottickedoff">panic &quot;applyMonTerm&quot; [&quot;Application of non-functional computational term&quot;]</span></span>
<span class="lineno">  791 </span>
<span class="lineno">  792 </span>-- | Apply a monadified term to 0 or more arguments
<span class="lineno">  793 </span>applyMonTermMulti :: HasCallStack =&gt; MonTerm -&gt; [MonArg] -&gt; MonTerm
<span class="lineno">  794 </span><span class="decl"><span class="nottickedoff">applyMonTermMulti = foldl applyMonTerm</span></span>
<span class="lineno">  795 </span>
<span class="lineno">  796 </span>-- | Build a 'MonTerm' from a global of a given argument type, applying it to
<span class="lineno">  797 </span>-- the current 'EventType' if the 'Bool' flag is 'True'
<span class="lineno">  798 </span>mkGlobalArgMonTerm :: HasSpecMEvType =&gt; MonType -&gt; Ident -&gt; Bool -&gt; ArgMonTerm
<span class="lineno">  799 </span><span class="decl"><span class="nottickedoff">mkGlobalArgMonTerm tp ident params_p =</span>
<span class="lineno">  800 </span><span class="spaces">  </span><span class="nottickedoff">fromArgTerm tp (if params_p</span>
<span class="lineno">  801 </span><span class="spaces">                  </span><span class="nottickedoff">then applyGlobalOpenTerm ident [evTypeTerm ?specMEvType]</span>
<span class="lineno">  802 </span><span class="spaces">                  </span><span class="nottickedoff">else globalOpenTerm ident)</span></span>
<span class="lineno">  803 </span>
<span class="lineno">  804 </span>-- | Build a 'MonTerm' from a 'GlobalDef' of semi-pure type, applying it to the
<span class="lineno">  805 </span>-- current 'EventType' if the 'Bool' flag is 'True'
<span class="lineno">  806 </span>mkSemiPureGlobalDefTerm :: HasSpecMEvType =&gt; GlobalDef -&gt; Bool -&gt; ArgMonTerm
<span class="lineno">  807 </span><span class="decl"><span class="nottickedoff">mkSemiPureGlobalDefTerm glob params_p =</span>
<span class="lineno">  808 </span><span class="spaces">  </span><span class="nottickedoff">fromSemiPureTerm (monadifyType [] $ globalDefType glob)</span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="nottickedoff">(if params_p</span>
<span class="lineno">  810 </span><span class="spaces">   </span><span class="nottickedoff">then applyOpenTermMulti (globalDefOpenTerm glob) [evTypeTerm ?specMEvType]</span>
<span class="lineno">  811 </span><span class="spaces">   </span><span class="nottickedoff">else globalDefOpenTerm glob)</span></span>
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>-- | Build a 'MonTerm' from a constructor with the given 'ExtCns'
<span class="lineno">  814 </span>mkCtorArgMonTerm :: HasSpecMEvType =&gt; ExtCns Term -&gt; ArgMonTerm
<span class="lineno">  815 </span><span class="decl"><span class="nottickedoff">mkCtorArgMonTerm ec</span>
<span class="lineno">  816 </span><span class="spaces">  </span><span class="nottickedoff">| not (isFirstOrderType (ecType ec)) =</span>
<span class="lineno">  817 </span><span class="spaces">    </span><span class="nottickedoff">failArgMonTerm (monadifyType [] $ ecType ec)</span>
<span class="lineno">  818 </span><span class="spaces">    </span><span class="nottickedoff">(&quot;monadification failed: cannot handle constructor &quot;</span>
<span class="lineno">  819 </span><span class="spaces">     </span><span class="nottickedoff">++ Text.unpack (toAbsoluteName (ecNameInfo ec)) ++ &quot; with higher-order type&quot;)</span>
<span class="lineno">  820 </span><span class="spaces"></span><span class="nottickedoff">mkCtorArgMonTerm ec =</span>
<span class="lineno">  821 </span><span class="spaces">  </span><span class="nottickedoff">case ecNameInfo ec of</span>
<span class="lineno">  822 </span><span class="spaces">    </span><span class="nottickedoff">ModuleIdentifier ident -&gt;</span>
<span class="lineno">  823 </span><span class="spaces">      </span><span class="nottickedoff">fromSemiPureTermFun (monadifyType [] $ ecType ec) (ctorOpenTerm ident)</span>
<span class="lineno">  824 </span><span class="spaces">    </span><span class="nottickedoff">ImportedName{} -&gt;</span>
<span class="lineno">  825 </span><span class="spaces">      </span><span class="nottickedoff">failArgMonTerm (monadifyType [] $ ecType ec)</span>
<span class="lineno">  826 </span><span class="spaces">      </span><span class="nottickedoff">(&quot;monadification failed: cannot handle constructor &quot;</span>
<span class="lineno">  827 </span><span class="spaces">       </span><span class="nottickedoff">++ Text.unpack (toAbsoluteName (ecNameInfo ec)) ++ &quot; with non-ident name&quot;)</span></span>
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>
<span class="lineno">  830 </span>----------------------------------------------------------------------
<span class="lineno">  831 </span>-- * Monadification Environments and Contexts
<span class="lineno">  832 </span>----------------------------------------------------------------------
<span class="lineno">  833 </span>
<span class="lineno">  834 </span>-- | A monadification macro is a function that inspects its first @N@ arguments
<span class="lineno">  835 </span>-- before deciding how to monadify itself
<span class="lineno">  836 </span>data MonMacro = MonMacro {
<span class="lineno">  837 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">macroNumArgs</span></span></span> :: Int,
<span class="lineno">  838 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">macroApply</span></span></span> :: GlobalDef -&gt; [Term] -&gt; MonadifyM MonTerm }
<span class="lineno">  839 </span>
<span class="lineno">  840 </span>-- | Make a simple 'MonMacro' that inspects 0 arguments and just returns a term
<span class="lineno">  841 </span>monMacro0 :: MonTerm -&gt; MonMacro
<span class="lineno">  842 </span><span class="decl"><span class="nottickedoff">monMacro0 mtrm = MonMacro 0 $ \_ _ -&gt; usingEvType $ return mtrm</span></span>
<span class="lineno">  843 </span>
<span class="lineno">  844 </span>-- | Make a 'MonMacro' that maps a named global to a global of semi-pure type.
<span class="lineno">  845 </span>-- (See 'fromSemiPureTermFun'.) Because we can't get access to the type of the
<span class="lineno">  846 </span>-- global until we apply the macro, we monadify its type at macro application
<span class="lineno">  847 </span>-- time. The 'Bool' flag indicates whether the current 'EventType' should also
<span class="lineno">  848 </span>-- be passed as the first argument to the &quot;to&quot; global.
<span class="lineno">  849 </span>semiPureGlobalMacro :: Ident -&gt; Ident -&gt; Bool -&gt; MonMacro
<span class="lineno">  850 </span><span class="decl"><span class="nottickedoff">semiPureGlobalMacro from to params_p =</span>
<span class="lineno">  851 </span><span class="spaces">  </span><span class="nottickedoff">MonMacro 0 $ \glob args -&gt; usingEvType $</span>
<span class="lineno">  852 </span><span class="spaces">  </span><span class="nottickedoff">if nameInfo (globalDefName glob) == ModuleIdentifier from &amp;&amp; args == [] then</span>
<span class="lineno">  853 </span><span class="spaces">    </span><span class="nottickedoff">return $ ArgMonTerm $</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="nottickedoff">fromSemiPureTerm (monadifyType [] $ globalDefType glob)</span>
<span class="lineno">  855 </span><span class="spaces">    </span><span class="nottickedoff">(if params_p then applyGlobalOpenTerm to [evTypeTerm ?specMEvType]</span>
<span class="lineno">  856 </span><span class="spaces">     </span><span class="nottickedoff">else globalOpenTerm to)</span>
<span class="lineno">  857 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;Monadification macro for &quot; ++ show from ++ &quot; applied incorrectly&quot;)</span></span>
<span class="lineno">  859 </span>
<span class="lineno">  860 </span>-- | Make a 'MonMacro' that maps a named global to a global of argument type.
<span class="lineno">  861 </span>-- Because we can't get access to the type of the global until we apply the
<span class="lineno">  862 </span>-- macro, we monadify its type at macro application time. The 'Bool' flag
<span class="lineno">  863 </span>-- indicates whether the &quot;to&quot; global is polymorphic in the event type, in which
<span class="lineno">  864 </span>-- case the current 'EventType' is passed as its first argument.
<span class="lineno">  865 </span>argGlobalMacro :: NameInfo -&gt; Ident -&gt; Bool -&gt; MonMacro
<span class="lineno">  866 </span><span class="decl"><span class="nottickedoff">argGlobalMacro from to params_p =</span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="nottickedoff">MonMacro 0 $ \glob args -&gt; usingEvType $</span>
<span class="lineno">  868 </span><span class="spaces">  </span><span class="nottickedoff">if nameInfo (globalDefName glob) == from &amp;&amp; args == [] then</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="nottickedoff">return $ ArgMonTerm $</span>
<span class="lineno">  870 </span><span class="spaces">    </span><span class="nottickedoff">mkGlobalArgMonTerm (monadifyType [] $ globalDefType glob) to params_p</span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno">  872 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;Monadification macro for &quot; ++ show from ++ &quot; applied incorrectly&quot;)</span></span>
<span class="lineno">  873 </span>
<span class="lineno">  874 </span>-- | An environment for monadification
<span class="lineno">  875 </span>data MonadifyEnv = MonadifyEnv {
<span class="lineno">  876 </span>  -- | How to monadify named functions
<span class="lineno">  877 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">monEnvMonTable</span></span></span> :: Map NameInfo MonMacro,
<span class="lineno">  878 </span>  -- | The @EvType@ used for monadification
<span class="lineno">  879 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">monEnvEvType</span></span></span> :: EventType
<span class="lineno">  880 </span>  }
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>-- | Look up the monadification of a name in a 'MonadifyEnv'
<span class="lineno">  883 </span>monEnvLookup :: NameInfo -&gt; MonadifyEnv -&gt; Maybe MonMacro
<span class="lineno">  884 </span><span class="decl"><span class="nottickedoff">monEnvLookup nmi env = Map.lookup nmi (monEnvMonTable env)</span></span>
<span class="lineno">  885 </span>
<span class="lineno">  886 </span>-- | Add a monadification for a name to a 'MonadifyEnv'
<span class="lineno">  887 </span>monEnvAdd :: NameInfo -&gt; MonMacro -&gt; MonadifyEnv -&gt; MonadifyEnv
<span class="lineno">  888 </span><span class="decl"><span class="nottickedoff">monEnvAdd nmi macro env =</span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="nottickedoff">env { monEnvMonTable = Map.insert nmi macro (monEnvMonTable env) }</span></span>
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>-- | A context for monadifying 'Term's which maintains, for each deBruijn index
<span class="lineno">  892 </span>-- in scope, both its original un-monadified type along with either a 'MonTerm'
<span class="lineno">  893 </span>-- or 'MonType' for the translation of the variable to a local variable of
<span class="lineno">  894 </span>-- monadified type or monadified kind
<span class="lineno">  895 </span>type MonadifyCtx = [(LocalName,Term,MonArg)]
<span class="lineno">  896 </span>
<span class="lineno">  897 </span>-- | Convert a 'MonadifyCtx' to a 'MonadifyTypeCtx'
<span class="lineno">  898 </span>ctxToTypeCtx :: MonadifyCtx -&gt; MonadifyTypeCtx
<span class="lineno">  899 </span><span class="decl"><span class="nottickedoff">ctxToTypeCtx = map (\(x,tp,arg) -&gt;</span>
<span class="lineno">  900 </span><span class="spaces">                     </span><span class="nottickedoff">(x,tp,case arg of</span>
<span class="lineno">  901 </span><span class="spaces">                         </span><span class="nottickedoff">TpArg k mtp -&gt; Just (SomeTpExpr k mtp)</span>
<span class="lineno">  902 </span><span class="spaces">                         </span><span class="nottickedoff">TrmArg _ -&gt; Nothing))</span></span>
<span class="lineno">  903 </span>
<span class="lineno">  904 </span>-- | Pretty-print a 'Term' relative to a 'MonadifyCtx'
<span class="lineno">  905 </span>ppTermInMonCtx :: MonadifyCtx -&gt; Term -&gt; String
<span class="lineno">  906 </span><span class="decl"><span class="nottickedoff">ppTermInMonCtx ctx t =</span>
<span class="lineno">  907 </span><span class="spaces">  </span><span class="nottickedoff">scPrettyTermInCtx PPS.defaultOpts (map (\(x,_,_) -&gt; x) ctx) t</span></span>
<span class="lineno">  908 </span>
<span class="lineno">  909 </span>-- | A memoization table for monadifying terms: a map from 'TermIndex'es to
<span class="lineno">  910 </span>-- 'MonTerm's and, possibly, corresponding 'ArgMonTerm's. The latter are simply
<span class="lineno">  911 </span>-- the result of calling 'argifyMonTerm' on the former, but are only added when
<span class="lineno">  912 </span>-- needed (i.e. when 'memoArgMonTerm' is called, e.g. in 'monadifyArg').
<span class="lineno">  913 </span>type MonadifyMemoTable = IntMap (MonTerm, Maybe ArgMonTerm)
<span class="lineno">  914 </span>
<span class="lineno">  915 </span>-- | The empty memoization table
<span class="lineno">  916 </span>emptyMemoTable :: MonadifyMemoTable
<span class="lineno">  917 </span><span class="decl"><span class="nottickedoff">emptyMemoTable = IntMap.empty</span></span>
<span class="lineno">  918 </span>
<span class="lineno">  919 </span>
<span class="lineno">  920 </span>----------------------------------------------------------------------
<span class="lineno">  921 </span>-- * The Monadification Monad
<span class="lineno">  922 </span>----------------------------------------------------------------------
<span class="lineno">  923 </span>
<span class="lineno">  924 </span>-- | The read-only state of a monadification computation
<span class="lineno">  925 </span>data MonadifyROState = MonadifyROState {
<span class="lineno">  926 </span>  -- | The monadification environment
<span class="lineno">  927 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">monStEnv</span></span></span> :: MonadifyEnv,
<span class="lineno">  928 </span>  -- | The monadification context
<span class="lineno">  929 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">monStCtx</span></span></span> :: MonadifyCtx,
<span class="lineno">  930 </span>  -- | The monadified return type of the top-level term being monadified; that
<span class="lineno">  931 </span>  -- is, we are inside a call to 'monadifyTerm' applied to some function of SAW
<span class="lineno">  932 </span>  -- core type @a1 -&gt; ... -&gt; an -&gt; b@, and this is the type @b@
<span class="lineno">  933 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">monStTopRetType</span></span></span> :: MonType
<span class="lineno">  934 </span>}
<span class="lineno">  935 </span>
<span class="lineno">  936 </span>-- | Get the monadification table from a 'MonadifyROState'
<span class="lineno">  937 </span>monStMonTable :: MonadifyROState -&gt; Map NameInfo MonMacro
<span class="lineno">  938 </span><span class="decl"><span class="nottickedoff">monStMonTable = monEnvMonTable . monStEnv</span></span>
<span class="lineno">  939 </span>
<span class="lineno">  940 </span>-- | The monad for monadifying SAW core terms
<span class="lineno">  941 </span>newtype MonadifyM a =
<span class="lineno">  942 </span>  MonadifyM { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unMonadifyM</span></span></span> ::
<span class="lineno">  943 </span>                ReaderT MonadifyROState (StateT MonadifyMemoTable
<span class="lineno">  944 </span>                                         (Cont MonTerm)) a }
<span class="lineno">  945 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monad</span></span></span></span></span></span>,
<span class="lineno">  946 </span>            <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadReader MonadifyROState</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadState MonadifyMemoTable</span></span></span></span></span></span>)
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>-- | Get the current 'EventType' in a 'MonadifyM' computation
<span class="lineno">  949 </span>askEvType :: MonadifyM EventType
<span class="lineno">  950 </span><span class="decl"><span class="nottickedoff">askEvType = monEnvEvType &lt;$&gt; monStEnv &lt;$&gt; ask</span></span>
<span class="lineno">  951 </span>
<span class="lineno">  952 </span>-- | Run a 'MonadifyM' computation with the current 'EventType'
<span class="lineno">  953 </span>usingEvType :: (HasSpecMEvType =&gt; MonadifyM a) -&gt; MonadifyM a
<span class="lineno">  954 </span><span class="decl"><span class="nottickedoff">usingEvType m =</span>
<span class="lineno">  955 </span><span class="spaces">  </span><span class="nottickedoff">do ev &lt;- askEvType</span>
<span class="lineno">  956 </span><span class="spaces">     </span><span class="nottickedoff">let ?specMEvType = ev in m</span></span>
<span class="lineno">  957 </span>
<span class="lineno">  958 </span>instance Fail.MonadFail MonadifyM where
<span class="lineno">  959 </span>  <span class="decl"><span class="nottickedoff">fail str =</span>
<span class="lineno">  960 </span><span class="spaces">    </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="nottickedoff">do ret_tp &lt;- topRetType</span>
<span class="lineno">  962 </span><span class="spaces">       </span><span class="nottickedoff">shiftMonadifyM $ \_ -&gt; failMonTerm ret_tp str</span></span>
<span class="lineno">  963 </span>
<span class="lineno">  964 </span>-- | Capture the current continuation and pass it to a function, which must
<span class="lineno">  965 </span>-- return the final computation result. Note that this is slightly differnet
<span class="lineno">  966 </span>-- from normal shift, and I think corresponds to the C operator, but my quick
<span class="lineno">  967 </span>-- googling couldn't find the right name...
<span class="lineno">  968 </span>shiftMonadifyM :: ((a -&gt; MonTerm) -&gt; MonTerm) -&gt; MonadifyM a
<span class="lineno">  969 </span><span class="decl"><span class="nottickedoff">shiftMonadifyM f = MonadifyM $ lift $ lift $ cont f</span></span>
<span class="lineno">  970 </span>
<span class="lineno">  971 </span>-- | Locally run a 'MonadifyM' computation with an empty memoization table,
<span class="lineno">  972 </span>-- making all binds be local to that computation, and return the result
<span class="lineno">  973 </span>resetMonadifyM :: MonType -&gt; MonadifyM MonTerm -&gt; MonadifyM MonTerm
<span class="lineno">  974 </span><span class="decl"><span class="nottickedoff">resetMonadifyM ret_tp m =</span>
<span class="lineno">  975 </span><span class="spaces">  </span><span class="nottickedoff">do ro_st &lt;- ask</span>
<span class="lineno">  976 </span><span class="spaces">     </span><span class="nottickedoff">return $ runMonadifyM (monStEnv ro_st) (monStCtx ro_st) ret_tp m</span></span>
<span class="lineno">  977 </span>
<span class="lineno">  978 </span>-- | Get the monadified return type of the top-level term being monadified
<span class="lineno">  979 </span>topRetType :: MonadifyM MonType
<span class="lineno">  980 </span><span class="decl"><span class="nottickedoff">topRetType = monStTopRetType &lt;$&gt; ask</span></span>
<span class="lineno">  981 </span>
<span class="lineno">  982 </span>-- | Run a monadification computation
<span class="lineno">  983 </span>--
<span class="lineno">  984 </span>-- FIXME: document the arguments
<span class="lineno">  985 </span>runMonadifyM :: MonadifyEnv -&gt; MonadifyCtx -&gt; MonType -&gt;
<span class="lineno">  986 </span>                MonadifyM MonTerm -&gt; MonTerm
<span class="lineno">  987 </span><span class="decl"><span class="nottickedoff">runMonadifyM env ctx top_ret_tp m =</span>
<span class="lineno">  988 </span><span class="spaces">  </span><span class="nottickedoff">let ro_st = MonadifyROState env ctx top_ret_tp in</span>
<span class="lineno">  989 </span><span class="spaces">  </span><span class="nottickedoff">runCont (evalStateT (runReaderT (unMonadifyM m) ro_st) emptyMemoTable) id</span></span>
<span class="lineno">  990 </span>
<span class="lineno">  991 </span>-- | Run a monadification computation using a mapping for identifiers that have
<span class="lineno">  992 </span>-- already been monadified and generate a SAW core term
<span class="lineno">  993 </span>runCompleteMonadifyM :: MonadIO m =&gt; SharedContext -&gt; MonadifyEnv -&gt;
<span class="lineno">  994 </span>                        Term -&gt; MonadifyM MonTerm -&gt;
<span class="lineno">  995 </span>                        m Term
<span class="lineno">  996 </span><span class="decl"><span class="nottickedoff">runCompleteMonadifyM sc env top_ret_tp m =</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="nottickedoff">let ?specMEvType = monEnvEvType env in</span>
<span class="lineno">  998 </span><span class="spaces">  </span><span class="nottickedoff">liftIO $ completeOpenTerm sc $ toCompTerm $</span>
<span class="lineno">  999 </span><span class="spaces">  </span><span class="nottickedoff">runMonadifyM env [] (monadifyType [] top_ret_tp) m</span></span>
<span class="lineno"> 1000 </span>
<span class="lineno"> 1001 </span>-- | Memoize a computation of the monadified term associated with a 'TermIndex'
<span class="lineno"> 1002 </span>memoMonTerm :: TermIndex -&gt; MonadifyM MonTerm -&gt; MonadifyM MonTerm
<span class="lineno"> 1003 </span><span class="decl"><span class="nottickedoff">memoMonTerm i m =</span>
<span class="lineno"> 1004 </span><span class="spaces">  </span><span class="nottickedoff">(IntMap.lookup i &lt;$&gt; get) &gt;&gt;= \case</span>
<span class="lineno"> 1005 </span><span class="spaces">  </span><span class="nottickedoff">Just (mtm, _) -&gt;</span>
<span class="lineno"> 1006 </span><span class="spaces">    </span><span class="nottickedoff">return mtm</span>
<span class="lineno"> 1007 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 1008 </span><span class="spaces">    </span><span class="nottickedoff">do mtm &lt;- m</span>
<span class="lineno"> 1009 </span><span class="spaces">       </span><span class="nottickedoff">modify (IntMap.insert i (mtm, Nothing))</span>
<span class="lineno"> 1010 </span><span class="spaces">       </span><span class="nottickedoff">return mtm</span></span>
<span class="lineno"> 1011 </span>
<span class="lineno"> 1012 </span>-- | Memoize a computation of the monadified term of argument type associated
<span class="lineno"> 1013 </span>-- with a 'TermIndex', using a memoized 'ArgTerm' directly if it exists or
<span class="lineno"> 1014 </span>-- applying 'argifyMonTerm' to a memoized 'MonTerm' (and memoizing the result)
<span class="lineno"> 1015 </span>-- if it exists
<span class="lineno"> 1016 </span>memoArgMonTerm :: TermIndex -&gt; MonadifyM MonTerm -&gt; MonadifyM ArgMonTerm
<span class="lineno"> 1017 </span><span class="decl"><span class="nottickedoff">memoArgMonTerm i m =</span>
<span class="lineno"> 1018 </span><span class="spaces">  </span><span class="nottickedoff">(IntMap.lookup i &lt;$&gt; get) &gt;&gt;= \case</span>
<span class="lineno"> 1019 </span><span class="spaces">  </span><span class="nottickedoff">Just (_, Just argmtm) -&gt;</span>
<span class="lineno"> 1020 </span><span class="spaces">    </span><span class="nottickedoff">return argmtm</span>
<span class="lineno"> 1021 </span><span class="spaces">  </span><span class="nottickedoff">Just (mtm, Nothing) -&gt;</span>
<span class="lineno"> 1022 </span><span class="spaces">    </span><span class="nottickedoff">do argmtm &lt;- argifyMonTerm mtm</span>
<span class="lineno"> 1023 </span><span class="spaces">       </span><span class="nottickedoff">modify (IntMap.insert i (mtm, Just argmtm))</span>
<span class="lineno"> 1024 </span><span class="spaces">       </span><span class="nottickedoff">return argmtm</span>
<span class="lineno"> 1025 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 1026 </span><span class="spaces">    </span><span class="nottickedoff">do mtm &lt;- m</span>
<span class="lineno"> 1027 </span><span class="spaces">       </span><span class="nottickedoff">argmtm &lt;- argifyMonTerm mtm</span>
<span class="lineno"> 1028 </span><span class="spaces">       </span><span class="nottickedoff">modify (IntMap.insert i (mtm, Just argmtm))</span>
<span class="lineno"> 1029 </span><span class="spaces">       </span><span class="nottickedoff">return argmtm</span></span>
<span class="lineno"> 1030 </span>
<span class="lineno"> 1031 </span>-- | Turn a 'MonTerm' of type @CompMT(tp)@ to a term of argument type @MT(tp)@
<span class="lineno"> 1032 </span>-- by inserting a monadic bind if the 'MonTerm' is computational
<span class="lineno"> 1033 </span>argifyMonTerm :: MonTerm -&gt; MonadifyM ArgMonTerm
<span class="lineno"> 1034 </span><span class="decl"><span class="nottickedoff">argifyMonTerm (ArgMonTerm mtrm) = return mtrm</span>
<span class="lineno"> 1035 </span><span class="spaces"></span><span class="nottickedoff">argifyMonTerm (CompMonTerm mtp trm) =</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="nottickedoff">do let tp = toArgType mtp</span>
<span class="lineno"> 1038 </span><span class="spaces">     </span><span class="nottickedoff">top_ret_tp &lt;- topRetType</span>
<span class="lineno"> 1039 </span><span class="spaces">     </span><span class="nottickedoff">shiftMonadifyM $ \k -&gt;</span>
<span class="lineno"> 1040 </span><span class="spaces">       </span><span class="nottickedoff">CompMonTerm top_ret_tp $</span>
<span class="lineno"> 1041 </span><span class="spaces">       </span><span class="nottickedoff">bindSOpenTerm ?specMEvType tp (toArgType top_ret_tp) trm $</span>
<span class="lineno"> 1042 </span><span class="spaces">       </span><span class="nottickedoff">lambdaOpenTerm &quot;x&quot; tp (toCompTerm . k . fromArgTerm mtp)</span></span>
<span class="lineno"> 1043 </span>
<span class="lineno"> 1044 </span>-- | Build a proof of @isFinite n@ by calling @assertFiniteS@ and binding the
<span class="lineno"> 1045 </span>-- result to an 'ArgMonTerm'
<span class="lineno"> 1046 </span>assertIsFinite :: HasSpecMEvType =&gt; NumTpExpr -&gt; MonadifyM ArgMonTerm
<span class="lineno"> 1047 </span><span class="decl"><span class="nottickedoff">assertIsFinite e =</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="nottickedoff">let n = numExprVal e in</span>
<span class="lineno"> 1049 </span><span class="spaces">  </span><span class="nottickedoff">argifyMonTerm (CompMonTerm</span>
<span class="lineno"> 1050 </span><span class="spaces">                 </span><span class="nottickedoff">(MTyIndesc (applyOpenTerm</span>
<span class="lineno"> 1051 </span><span class="spaces">                             </span><span class="nottickedoff">(globalOpenTerm &quot;CryptolM.isFinite&quot;) n))</span>
<span class="lineno"> 1052 </span><span class="spaces">                 </span><span class="nottickedoff">(applyGlobalOpenTerm &quot;CryptolM.assertFiniteS&quot;</span>
<span class="lineno"> 1053 </span><span class="spaces">                  </span><span class="nottickedoff">[evTypeTerm ?specMEvType, n]))</span></span>
<span class="lineno"> 1054 </span>
<span class="lineno"> 1055 </span>
<span class="lineno"> 1056 </span>----------------------------------------------------------------------
<span class="lineno"> 1057 </span>-- * Monadification
<span class="lineno"> 1058 </span>----------------------------------------------------------------------
<span class="lineno"> 1059 </span>
<span class="lineno"> 1060 </span>-- | Apply a monadifying operation (like 'monadifyTpExpr') in a 'MonadifyM'
<span class="lineno"> 1061 </span>monadifyOpM :: HasCallStack =&gt;
<span class="lineno"> 1062 </span>               (HasSpecMEvType =&gt; MonadifyTypeCtx -&gt; Term -&gt; a) -&gt;
<span class="lineno"> 1063 </span>               Term -&gt; MonadifyM a
<span class="lineno"> 1064 </span><span class="decl"><span class="nottickedoff">monadifyOpM f tm =</span>
<span class="lineno"> 1065 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno"> 1066 </span><span class="spaces">  </span><span class="nottickedoff">do ctx &lt;- monStCtx &lt;$&gt; ask</span>
<span class="lineno"> 1067 </span><span class="spaces">     </span><span class="nottickedoff">return $ f (ctxToTypeCtx ctx) tm</span></span>
<span class="lineno"> 1068 </span>
<span class="lineno"> 1069 </span>-- | Monadify a type-level expression in the context of the 'MonadifyM' monad
<span class="lineno"> 1070 </span>monadifyTpExprM :: HasCallStack =&gt; Term -&gt; MonadifyM SomeTpExpr
<span class="lineno"> 1071 </span><span class="decl"><span class="nottickedoff">monadifyTpExprM = monadifyOpM monadifyTpExpr</span></span>
<span class="lineno"> 1072 </span>
<span class="lineno"> 1073 </span>-- | Monadify a type in the context of the 'MonadifyM' monad
<span class="lineno"> 1074 </span>monadifyTypeM :: HasCallStack =&gt; Term -&gt; MonadifyM MonType
<span class="lineno"> 1075 </span><span class="decl"><span class="nottickedoff">monadifyTypeM = monadifyOpM monadifyType</span></span>
<span class="lineno"> 1076 </span>
<span class="lineno"> 1077 </span>-- | Monadify a numeric expression in the context of the 'MonadifyM' monad
<span class="lineno"> 1078 </span>monadifyNumM :: HasCallStack =&gt; Term -&gt; MonadifyM NumTpExpr
<span class="lineno"> 1079 </span><span class="decl"><span class="nottickedoff">monadifyNumM = monadifyOpM monadifyNum</span></span>
<span class="lineno"> 1080 </span>
<span class="lineno"> 1081 </span>-- | Monadify a term to a monadified term of argument type
<span class="lineno"> 1082 </span>monadifyArg :: HasCallStack =&gt; (?mm :: ModuleMap) =&gt; Maybe MonType -&gt; Term -&gt; MonadifyM ArgMonTerm
<span class="lineno"> 1083 </span>{-
<span class="lineno"> 1084 </span>monadifyArg _ t
<span class="lineno"> 1085 </span>  | trace (&quot;Monadifying term of argument type: &quot; ++ showTerm t) False
<span class="lineno"> 1086 </span>  = undefined
<span class="lineno"> 1087 </span>-}
<span class="lineno"> 1088 </span><span class="decl"><span class="nottickedoff">monadifyArg mtp t@(STApp { stAppIndex = ix }) =</span>
<span class="lineno"> 1089 </span><span class="spaces">  </span><span class="nottickedoff">memoArgMonTerm ix $ usingEvType $ monadifyTerm' mtp t</span>
<span class="lineno"> 1090 </span><span class="spaces"></span><span class="nottickedoff">monadifyArg mtp t =</span>
<span class="lineno"> 1091 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType (monadifyTerm' mtp t) &gt;&gt;= argifyMonTerm</span></span>
<span class="lineno"> 1092 </span>
<span class="lineno"> 1093 </span>-- | Monadify a term to argument type and convert back to a term
<span class="lineno"> 1094 </span>monadifyArgTerm ::
<span class="lineno"> 1095 </span>  HasCallStack =&gt; (?mm :: ModuleMap) =&gt;
<span class="lineno"> 1096 </span>  Maybe MonType -&gt; Term -&gt; MonadifyM OpenTerm
<span class="lineno"> 1097 </span><span class="decl"><span class="nottickedoff">monadifyArgTerm mtp t = usingEvType (toArgTerm &lt;$&gt; monadifyArg mtp t)</span></span>
<span class="lineno"> 1098 </span>
<span class="lineno"> 1099 </span>-- | Monadify a term
<span class="lineno"> 1100 </span>monadifyTerm :: (?mm :: ModuleMap) =&gt; Maybe MonType -&gt; Term -&gt; MonadifyM MonTerm
<span class="lineno"> 1101 </span>{-
<span class="lineno"> 1102 </span>monadifyTerm _ t
<span class="lineno"> 1103 </span>  | trace (&quot;Monadifying term: &quot; ++ showTerm t) False
<span class="lineno"> 1104 </span>  = undefined
<span class="lineno"> 1105 </span>-}
<span class="lineno"> 1106 </span><span class="decl"><span class="nottickedoff">monadifyTerm mtp t@(STApp { stAppIndex = ix }) =</span>
<span class="lineno"> 1107 </span><span class="spaces">  </span><span class="nottickedoff">memoMonTerm ix $ usingEvType $ monadifyTerm' mtp t</span>
<span class="lineno"> 1108 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm mtp t =</span>
<span class="lineno"> 1109 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $ monadifyTerm' mtp t</span></span>
<span class="lineno"> 1110 </span>
<span class="lineno"> 1111 </span>-- | The main implementation of 'monadifyTerm', which monadifies a term given an
<span class="lineno"> 1112 </span>-- optional monadification type. The type must be given for introduction forms
<span class="lineno"> 1113 </span>-- (i.e.,, lambdas, pairs, and records), but is optional for elimination forms
<span class="lineno"> 1114 </span>-- (i.e., applications, projections, and also in this case variables). Note that
<span class="lineno"> 1115 </span>-- this means monadification will fail on terms with beta or tuple redexes.
<span class="lineno"> 1116 </span>monadifyTerm' :: HasCallStack =&gt; HasSpecMEvType =&gt; (?mm :: ModuleMap) =&gt;
<span class="lineno"> 1117 </span>                 Maybe MonType -&gt; Term -&gt; MonadifyM MonTerm
<span class="lineno"> 1118 </span><span class="decl"><span class="nottickedoff">monadifyTerm' (Just mtp) t@(asLambda -&gt; Just _) =</span>
<span class="lineno"> 1119 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \(MonadifyROState { monStEnv = env, monStCtx = ctx }) -&gt;</span>
<span class="lineno"> 1120 </span><span class="spaces">  </span><span class="nottickedoff">return $ monadifyLambdas env ctx mtp t</span>
<span class="lineno"> 1121 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 1122 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' (Just mtp@(MTyForall _ _ _)) t =</span>
<span class="lineno"> 1123 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \ro_st -&gt;</span>
<span class="lineno"> 1124 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \table -&gt;</span>
<span class="lineno"> 1125 </span><span class="spaces">  </span><span class="nottickedoff">return $ monadifyLambdas (monStEnv ro_st) table (monStCtx ro_st) mtp t</span>
<span class="lineno"> 1126 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' (Just mtp@(MTyArrow _ _)) t =</span>
<span class="lineno"> 1127 </span><span class="spaces">  </span><span class="nottickedoff">ask &gt;&gt;= \ro_st -&gt;</span>
<span class="lineno"> 1128 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \table -&gt;</span>
<span class="lineno"> 1129 </span><span class="spaces">  </span><span class="nottickedoff">return $ monadifyLambdas (monStEnv ro_st) table (monStCtx ro_st) mtp t</span>
<span class="lineno"> 1130 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1131 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' (Just mtp@(MTyTuple mtps)) (asTupleValue -&gt; Just trms)</span>
<span class="lineno"> 1132 </span><span class="spaces">  </span><span class="nottickedoff">| length mtps == length trms =</span>
<span class="lineno"> 1133 </span><span class="spaces">    </span><span class="nottickedoff">fromArgTerm mtp &lt;$&gt;</span>
<span class="lineno"> 1134 </span><span class="spaces">    </span><span class="nottickedoff">tupleOpenTerm &lt;$&gt;</span>
<span class="lineno"> 1135 </span><span class="spaces">    </span><span class="nottickedoff">zipWithM monadifyArgTerm (map Just mtps) trms</span>
<span class="lineno"> 1136 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 1137 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' (Just mtp@(MTyRecord fs_mtps)) (asRecordValue -&gt; Just trm_map)</span>
<span class="lineno"> 1138 </span><span class="spaces">  </span><span class="nottickedoff">| length fs_mtps == Map.size trm_map</span>
<span class="lineno"> 1139 </span><span class="spaces">  </span><span class="nottickedoff">, (fs,mtps) &lt;- unzip fs_mtps</span>
<span class="lineno"> 1140 </span><span class="spaces">  </span><span class="nottickedoff">, Just trms &lt;- mapM (\f -&gt; Map.lookup f trm_map) fs =</span>
<span class="lineno"> 1141 </span><span class="spaces">    </span><span class="nottickedoff">fromArgTerm mtp &lt;$&gt; recordOpenTerm &lt;$&gt; zip fs &lt;$&gt;</span>
<span class="lineno"> 1142 </span><span class="spaces">    </span><span class="nottickedoff">zipWithM monadifyArgTerm (map Just mtps) trms</span>
<span class="lineno"> 1143 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1144 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ (asTupleSelector -&gt; Just (trm, i)) =</span>
<span class="lineno"> 1145 </span><span class="spaces">  </span><span class="nottickedoff">do mtrm &lt;- monadifyArg Nothing trm</span>
<span class="lineno"> 1146 </span><span class="spaces">     </span><span class="nottickedoff">mtp &lt;- case getMonType mtrm of</span>
<span class="lineno"> 1147 </span><span class="spaces">       </span><span class="nottickedoff">MTyTuple ts | i &lt; length ts -&gt; pure (ts !! i)</span>
<span class="lineno"> 1148 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; fail &quot;Monadification failed: projection on term of non-tuple type&quot;</span>
<span class="lineno"> 1149 </span><span class="spaces">     </span><span class="nottickedoff">pure $ fromArgTerm mtp $ projTupleOpenTerm (toInteger i) $ toArgTerm mtrm</span>
<span class="lineno"> 1150 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' (Just mtp@(MTySeq n mtp_elem)) (asFTermF -&gt;</span>
<span class="lineno"> 1151 </span><span class="spaces">                                              </span><span class="nottickedoff">Just (ArrayValue _ trms)) =</span>
<span class="lineno"> 1152 </span><span class="spaces">  </span><span class="nottickedoff">do trms' &lt;- traverse (monadifyArgTerm $ Just mtp_elem) trms</span>
<span class="lineno"> 1153 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromArgTerm mtp $</span>
<span class="lineno"> 1154 </span><span class="spaces">       </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;CryptolM.seqToMseq&quot;)</span>
<span class="lineno"> 1155 </span><span class="spaces">       </span><span class="nottickedoff">[evTypeTerm ?specMEvType, numExprVal n, toArgType mtp_elem,</span>
<span class="lineno"> 1156 </span><span class="spaces">        </span><span class="nottickedoff">flatOpenTerm $ ArrayValue (toArgType mtp_elem) trms']</span>
<span class="lineno"> 1157 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 1158 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ (asRecordSelector -&gt; Just (trm, fld)) =</span>
<span class="lineno"> 1159 </span><span class="spaces">  </span><span class="nottickedoff">do mtrm &lt;- monadifyArg Nothing trm</span>
<span class="lineno"> 1160 </span><span class="spaces">     </span><span class="nottickedoff">mtp &lt;- case getMonType mtrm of</span>
<span class="lineno"> 1161 </span><span class="spaces">       </span><span class="nottickedoff">MTyRecord mtps | Just mtp &lt;- lookup fld mtps -&gt; return mtp</span>
<span class="lineno"> 1162 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; fail (&quot;Monadification failed: &quot; ++</span>
<span class="lineno"> 1163 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;record projection on term of incorrect type&quot;)</span>
<span class="lineno"> 1164 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromArgTerm mtp $ projRecordOpenTerm (toArgTerm mtrm) fld</span>
<span class="lineno"> 1165 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1166 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ (asLocalVar -&gt; Just ix) =</span>
<span class="lineno"> 1167 </span><span class="spaces">  </span><span class="nottickedoff">(monStCtx &lt;$&gt; ask) &gt;&gt;= \case</span>
<span class="lineno"> 1168 </span><span class="spaces">  </span><span class="nottickedoff">ctx | ix &gt;= length ctx -&gt; fail &quot;Monadification failed: vaiable out of scope!&quot;</span>
<span class="lineno"> 1169 </span><span class="spaces">  </span><span class="nottickedoff">ctx | (_,_,TrmArg mtrm) &lt;- ctx !! ix -&gt; return $ ArgMonTerm mtrm</span>
<span class="lineno"> 1170 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; fail &quot;Monadification failed: type variable used in term position!&quot;</span>
<span class="lineno"> 1171 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 1172 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ (asCtor -&gt; Just (ec, args)) =</span>
<span class="lineno"> 1173 </span><span class="spaces">  </span><span class="nottickedoff">monadifyApply (ArgMonTerm $ mkCtorArgMonTerm ec) args</span>
<span class="lineno"> 1174 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1175 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ (asApplyAll -&gt; (asTypedGlobalDef -&gt; Just glob, args)) =</span>
<span class="lineno"> 1176 </span><span class="spaces">  </span><span class="nottickedoff">(Map.lookup (nameInfo (globalDefName glob)) &lt;$&gt; monStMonTable &lt;$&gt; ask) &gt;&gt;= \case</span>
<span class="lineno"> 1177 </span><span class="spaces">  </span><span class="nottickedoff">Just macro -&gt;</span>
<span class="lineno"> 1178 </span><span class="spaces">    </span><span class="nottickedoff">do let (macro_args, reg_args) = splitAt (macroNumArgs macro) args</span>
<span class="lineno"> 1179 </span><span class="spaces">       </span><span class="nottickedoff">mtrm_f &lt;- macroApply macro glob macro_args</span>
<span class="lineno"> 1180 </span><span class="spaces">       </span><span class="nottickedoff">monadifyApply mtrm_f reg_args</span>
<span class="lineno"> 1181 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 1182 </span><span class="spaces">    </span><span class="nottickedoff">monadifyTypeM (globalDefType glob) &gt;&gt;= \glob_mtp -&gt;</span>
<span class="lineno"> 1183 </span><span class="spaces">    </span><span class="nottickedoff">if monTypeIsSemiPure glob_mtp then</span>
<span class="lineno"> 1184 </span><span class="spaces">      </span><span class="nottickedoff">monadifyApply (ArgMonTerm $ fromSemiPureTerm glob_mtp $</span>
<span class="lineno"> 1185 </span><span class="spaces">                     </span><span class="nottickedoff">globalDefOpenTerm glob) args</span>
<span class="lineno"> 1186 </span><span class="spaces">    </span><span class="nottickedoff">else error (&quot;Monadification failed: unhandled constant: &quot;</span>
<span class="lineno"> 1187 </span><span class="spaces">                </span><span class="nottickedoff">++ globalDefString glob)</span>
<span class="lineno"> 1188 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ (asApp -&gt; Just (f, arg)) =</span>
<span class="lineno"> 1189 </span><span class="spaces">  </span><span class="nottickedoff">do mtrm_f &lt;- monadifyTerm Nothing f</span>
<span class="lineno"> 1190 </span><span class="spaces">     </span><span class="nottickedoff">monadifyApply mtrm_f [arg]</span>
<span class="lineno"> 1191 </span><span class="spaces"></span><span class="nottickedoff">monadifyTerm' _ t =</span>
<span class="lineno"> 1192 </span><span class="spaces">  </span><span class="nottickedoff">(monStCtx &lt;$&gt; ask) &gt;&gt;= \ctx -&gt;</span>
<span class="lineno"> 1193 </span><span class="spaces">  </span><span class="nottickedoff">fail (&quot;Monadifiction failed: no case for term: &quot; ++ ppTermInMonCtx ctx t)</span></span>
<span class="lineno"> 1194 </span>
<span class="lineno"> 1195 </span>
<span class="lineno"> 1196 </span>-- | Monadify the application of a monadified term to a list of terms, using the
<span class="lineno"> 1197 </span>-- type of the already monadified to monadify the arguments
<span class="lineno"> 1198 </span>monadifyApply :: HasCallStack =&gt; (?mm :: ModuleMap) =&gt; MonTerm -&gt; [Term] -&gt; MonadifyM MonTerm
<span class="lineno"> 1199 </span><span class="decl"><span class="nottickedoff">monadifyApply f (t : ts)</span>
<span class="lineno"> 1200 </span><span class="spaces">  </span><span class="nottickedoff">| MTyArrow tp_in _ &lt;- getMonType f =</span>
<span class="lineno"> 1201 </span><span class="spaces">    </span><span class="nottickedoff">do mtrm &lt;- monadifyArg (Just tp_in) t</span>
<span class="lineno"> 1202 </span><span class="spaces">       </span><span class="nottickedoff">monadifyApply (applyMonTerm f (TrmArg mtrm)) ts</span>
<span class="lineno"> 1203 </span><span class="spaces"></span><span class="nottickedoff">monadifyApply f (t : ts)</span>
<span class="lineno"> 1204 </span><span class="spaces">  </span><span class="nottickedoff">| MTyForall _ _ _ &lt;- getMonType f =</span>
<span class="lineno"> 1205 </span><span class="spaces">    </span><span class="nottickedoff">do arg &lt;- tpExprToArg &lt;$&gt; monadifyTpExprM t</span>
<span class="lineno"> 1206 </span><span class="spaces">       </span><span class="nottickedoff">monadifyApply (applyMonTerm f arg) ts</span>
<span class="lineno"> 1207 </span><span class="spaces"></span><span class="nottickedoff">monadifyApply _ (_:_) = fail &quot;monadifyApply: application at incorrect type&quot;</span>
<span class="lineno"> 1208 </span><span class="spaces"></span><span class="nottickedoff">monadifyApply f [] = return f</span></span>
<span class="lineno"> 1209 </span>
<span class="lineno"> 1210 </span>
<span class="lineno"> 1211 </span>-- | Monadify a nested lambda abstraction by monadifying its body. This is done
<span class="lineno"> 1212 </span>-- outside the 'MonadifyM' monad, since all of its state (including the eventual
<span class="lineno"> 1213 </span>-- return type) will be reset when we monadify this body.
<span class="lineno"> 1214 </span>monadifyLambdas ::
<span class="lineno"> 1215 </span>  HasCallStack =&gt; (?mm :: ModuleMap) =&gt;
<span class="lineno"> 1216 </span>  MonadifyEnv -&gt; MonadifyCtx -&gt;
<span class="lineno"> 1217 </span>  MonType -&gt; Term -&gt; MonTerm
<span class="lineno"> 1218 </span><span class="decl"><span class="nottickedoff">monadifyLambdas env ctx (MTyForall _ k tp_f) (asLambda -&gt;</span>
<span class="lineno"> 1219 </span><span class="spaces">                                              </span><span class="nottickedoff">Just (x, x_tp, body)) =</span>
<span class="lineno"> 1220 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: check that monadifyKind x_tp == k</span>
<span class="lineno"> 1221 </span><span class="spaces">  </span><span class="nottickedoff">ArgMonTerm $ ForallMonTerm x k $ \mtp -&gt;</span>
<span class="lineno"> 1222 </span><span class="spaces">  </span><span class="nottickedoff">monadifyLambdas env ((x,x_tp,TpArg k mtp) : ctx) (tp_f mtp) body</span>
<span class="lineno"> 1223 </span><span class="spaces"></span><span class="nottickedoff">monadifyLambdas env ctx (MTyArrow tp_in tp_out) (asLambda -&gt;</span>
<span class="lineno"> 1224 </span><span class="spaces">                                                 </span><span class="nottickedoff">Just (x, x_tp, body)) =</span>
<span class="lineno"> 1225 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: check that monadifyType x_tp == tp_in</span>
<span class="lineno"> 1226 </span><span class="spaces">  </span><span class="nottickedoff">ArgMonTerm $ FunMonTerm x tp_in tp_out $ \arg -&gt;</span>
<span class="lineno"> 1227 </span><span class="spaces">  </span><span class="nottickedoff">monadifyLambdas env ((x,x_tp,TrmArg arg) : ctx) tp_out body</span>
<span class="lineno"> 1228 </span><span class="spaces"></span><span class="nottickedoff">monadifyLambdas env ctx tp t =</span>
<span class="lineno"> 1229 </span><span class="spaces">  </span><span class="nottickedoff">monadifyEtaExpand env ctx tp tp t []</span></span>
<span class="lineno"> 1230 </span>
<span class="lineno"> 1231 </span>-- | Monadify a term of functional type by lambda-abstracting its arguments,
<span class="lineno"> 1232 </span>-- monadifying it, and applying the result to those lambda-abstracted arguments;
<span class="lineno"> 1233 </span>-- i.e., by eta-expanding it. This ensures that the 'MonadifyM' computation is
<span class="lineno"> 1234 </span>-- run in a context where the return type is not functional, which in turn
<span class="lineno"> 1235 </span>-- ensures that any monadic binds inserted by 'argifyMonTerm' all happen inside
<span class="lineno"> 1236 </span>-- the function. The first 'MonType' is the top-level functional type of the
<span class="lineno"> 1237 </span>-- 'Term' being monadified, while the second 'MonType' is the type after the
<span class="lineno"> 1238 </span>-- 'Term' is applied to the list of 'MonArg's, which represents all the
<span class="lineno"> 1239 </span>-- variables generated by eta-expansion.
<span class="lineno"> 1240 </span>monadifyEtaExpand ::
<span class="lineno"> 1241 </span>  HasCallStack =&gt; (?mm :: ModuleMap) =&gt;
<span class="lineno"> 1242 </span>  MonadifyEnv -&gt; MonadifyCtx -&gt;
<span class="lineno"> 1243 </span>  MonType -&gt; MonType -&gt; Term -&gt; [MonArg] -&gt; MonTerm
<span class="lineno"> 1244 </span><span class="decl"><span class="nottickedoff">monadifyEtaExpand env ctx top_mtp (MTyForall x k tp_f) t args =</span>
<span class="lineno"> 1245 </span><span class="spaces">  </span><span class="nottickedoff">ArgMonTerm $ ForallMonTerm x k $ \mtp -&gt;</span>
<span class="lineno"> 1246 </span><span class="spaces">  </span><span class="nottickedoff">monadifyEtaExpand env ctx top_mtp (tp_f mtp) t (args ++ [TpArg k mtp])</span>
<span class="lineno"> 1247 </span><span class="spaces"></span><span class="nottickedoff">monadifyEtaExpand env ctx top_mtp (MTyArrow tp_in tp_out) t args =</span>
<span class="lineno"> 1248 </span><span class="spaces">  </span><span class="nottickedoff">ArgMonTerm $ FunMonTerm &quot;_&quot; tp_in tp_out $ \arg -&gt;</span>
<span class="lineno"> 1249 </span><span class="spaces">  </span><span class="nottickedoff">monadifyEtaExpand env ctx top_mtp tp_out t (args ++ [TrmArg arg])</span>
<span class="lineno"> 1250 </span><span class="spaces"></span><span class="nottickedoff">monadifyEtaExpand env ctx top_mtp mtp t args =</span>
<span class="lineno"> 1251 </span><span class="spaces">  </span><span class="nottickedoff">let ?specMEvType = monEnvEvType env in</span>
<span class="lineno"> 1252 </span><span class="spaces">  </span><span class="nottickedoff">applyMonTermMulti (runMonadifyM env ctx mtp</span>
<span class="lineno"> 1253 </span><span class="spaces">                     </span><span class="nottickedoff">(monadifyTerm (Just top_mtp) t)) args</span></span>
<span class="lineno"> 1254 </span>
<span class="lineno"> 1255 </span>
<span class="lineno"> 1256 </span>----------------------------------------------------------------------
<span class="lineno"> 1257 </span>-- * Handling the Primitives
<span class="lineno"> 1258 </span>----------------------------------------------------------------------
<span class="lineno"> 1259 </span>
<span class="lineno"> 1260 </span>-- | The macro for unsafeAssert, which checks the type of the objects being
<span class="lineno"> 1261 </span>-- compared and dispatches to the proper comparison function
<span class="lineno"> 1262 </span>unsafeAssertMacro :: MonMacro
<span class="lineno"> 1263 </span><span class="decl"><span class="nottickedoff">unsafeAssertMacro = MonMacro 1 $ \_ ts -&gt;</span>
<span class="lineno"> 1264 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno"> 1265 </span><span class="spaces">  </span><span class="nottickedoff">let numFunType =</span>
<span class="lineno"> 1266 </span><span class="spaces">        </span><span class="nottickedoff">MTyForall &quot;n&quot; MKNumRepr $ \n -&gt; MTyForall &quot;m&quot; MKNumRepr $ \m -&gt;</span>
<span class="lineno"> 1267 </span><span class="spaces">        </span><span class="nottickedoff">MTyIndesc $</span>
<span class="lineno"> 1268 </span><span class="spaces">        </span><span class="nottickedoff">dataTypeOpenTerm &quot;Prelude.Eq&quot;</span>
<span class="lineno"> 1269 </span><span class="spaces">        </span><span class="nottickedoff">[dataTypeOpenTerm &quot;Cryptol.Num&quot; [],</span>
<span class="lineno"> 1270 </span><span class="spaces">         </span><span class="nottickedoff">numExprVal n, numExprVal m] in</span>
<span class="lineno"> 1271 </span><span class="spaces">  </span><span class="nottickedoff">case ts of</span>
<span class="lineno"> 1272 </span><span class="spaces">    </span><span class="nottickedoff">[(asGlobalApply &quot;Cryptol.Num&quot; -&gt; Just [])] -&gt;</span>
<span class="lineno"> 1273 </span><span class="spaces">        </span><span class="nottickedoff">return $ ArgMonTerm $</span>
<span class="lineno"> 1274 </span><span class="spaces">        </span><span class="nottickedoff">mkGlobalArgMonTerm numFunType &quot;CryptolM.numAssertEqS&quot; True</span>
<span class="lineno"> 1275 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 1276 </span><span class="spaces">      </span><span class="nottickedoff">fail &quot;Monadification failed: unsafeAssert applied to non-Num type&quot;</span></span>
<span class="lineno"> 1277 </span>
<span class="lineno"> 1278 </span>-- | The macro for if-then-else, which contains any binds in a branch to that
<span class="lineno"> 1279 </span>-- branch
<span class="lineno"> 1280 </span>iteMacro :: (?mm :: ModuleMap) =&gt; MonMacro
<span class="lineno"> 1281 </span><span class="decl"><span class="nottickedoff">iteMacro = MonMacro 4 $ \_ args -&gt; usingEvType $</span>
<span class="lineno"> 1282 </span><span class="spaces">  </span><span class="nottickedoff">do let (tp, cond, branch1, branch2) =</span>
<span class="lineno"> 1283 </span><span class="spaces">           </span><span class="nottickedoff">case args of</span>
<span class="lineno"> 1284 </span><span class="spaces">             </span><span class="nottickedoff">[t1, t2, t3, t4] -&gt; (t1, t2, t3, t4)</span>
<span class="lineno"> 1285 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;iteMacro: wrong number of arguments!&quot;</span>
<span class="lineno"> 1286 </span><span class="spaces">     </span><span class="nottickedoff">atrm_cond &lt;- monadifyArg (Just MTyBool) cond</span>
<span class="lineno"> 1287 </span><span class="spaces">     </span><span class="nottickedoff">mtp &lt;- monadifyTypeM tp</span>
<span class="lineno"> 1288 </span><span class="spaces">     </span><span class="nottickedoff">mtrm1 &lt;- resetMonadifyM mtp $ monadifyTerm (Just mtp) branch1</span>
<span class="lineno"> 1289 </span><span class="spaces">     </span><span class="nottickedoff">mtrm2 &lt;- resetMonadifyM mtp $ monadifyTerm (Just mtp) branch2</span>
<span class="lineno"> 1290 </span><span class="spaces">     </span><span class="nottickedoff">case (mtrm1, mtrm2) of</span>
<span class="lineno"> 1291 </span><span class="spaces">       </span><span class="nottickedoff">(ArgMonTerm atrm1, ArgMonTerm atrm2) -&gt;</span>
<span class="lineno"> 1292 </span><span class="spaces">         </span><span class="nottickedoff">return $ fromArgTerm mtp $</span>
<span class="lineno"> 1293 </span><span class="spaces">         </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.ite&quot;)</span>
<span class="lineno"> 1294 </span><span class="spaces">         </span><span class="nottickedoff">[toArgType mtp, toArgTerm atrm_cond, toArgTerm atrm1, toArgTerm atrm2]</span>
<span class="lineno"> 1295 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 1296 </span><span class="spaces">         </span><span class="nottickedoff">return $ fromCompTerm mtp $</span>
<span class="lineno"> 1297 </span><span class="spaces">         </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;Prelude.ite&quot;)</span>
<span class="lineno"> 1298 </span><span class="spaces">         </span><span class="nottickedoff">[toCompType mtp, toArgTerm atrm_cond,</span>
<span class="lineno"> 1299 </span><span class="spaces">          </span><span class="nottickedoff">toCompTerm mtrm1, toCompTerm mtrm2]</span></span>
<span class="lineno"> 1300 </span>
<span class="lineno"> 1301 </span>-- | The macro for the either elimination function, which converts the
<span class="lineno"> 1302 </span>-- application @either a b c@ to @either a b (CompM c)@
<span class="lineno"> 1303 </span>eitherMacro :: MonMacro
<span class="lineno"> 1304 </span><span class="decl"><span class="nottickedoff">eitherMacro = MonMacro 3 $ \_ args -&gt;</span>
<span class="lineno"> 1305 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno"> 1306 </span><span class="spaces">  </span><span class="nottickedoff">do let (tp_a, tp_b, tp_c) =</span>
<span class="lineno"> 1307 </span><span class="spaces">           </span><span class="nottickedoff">case args of</span>
<span class="lineno"> 1308 </span><span class="spaces">             </span><span class="nottickedoff">[t1, t2, t3] -&gt; (t1, t2, t3)</span>
<span class="lineno"> 1309 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;eitherMacro: wrong number of arguments!&quot;</span>
<span class="lineno"> 1310 </span><span class="spaces">     </span><span class="nottickedoff">mtp_a &lt;- monadifyTypeM tp_a</span>
<span class="lineno"> 1311 </span><span class="spaces">     </span><span class="nottickedoff">mtp_b &lt;- monadifyTypeM tp_b</span>
<span class="lineno"> 1312 </span><span class="spaces">     </span><span class="nottickedoff">mtp_c &lt;- monadifyTypeM tp_c</span>
<span class="lineno"> 1313 </span><span class="spaces">     </span><span class="nottickedoff">let eith_app = applyGlobalOpenTerm &quot;Prelude.either&quot; [toArgType mtp_a,</span>
<span class="lineno"> 1314 </span><span class="spaces">                                                          </span><span class="nottickedoff">toArgType mtp_b,</span>
<span class="lineno"> 1315 </span><span class="spaces">                                                          </span><span class="nottickedoff">toCompType mtp_c]</span>
<span class="lineno"> 1316 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromCompTerm (MTyArrow (MTyArrow mtp_a mtp_c)</span>
<span class="lineno"> 1317 </span><span class="spaces">                            </span><span class="nottickedoff">(MTyArrow (MTyArrow mtp_b mtp_c)</span>
<span class="lineno"> 1318 </span><span class="spaces">                             </span><span class="nottickedoff">(MTyArrow (MTySum mtp_a mtp_b) mtp_c))) eith_app</span></span>
<span class="lineno"> 1319 </span>
<span class="lineno"> 1320 </span>-- | The macro for uncurry, which converts the application @uncurry a b c@
<span class="lineno"> 1321 </span>-- to @uncurry a b (CompM c)@
<span class="lineno"> 1322 </span>uncurryMacro :: MonMacro
<span class="lineno"> 1323 </span><span class="decl"><span class="nottickedoff">uncurryMacro = MonMacro 3 $ \_ args -&gt;</span>
<span class="lineno"> 1324 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno"> 1325 </span><span class="spaces">  </span><span class="nottickedoff">do let (tp_a, tp_b, tp_c) =</span>
<span class="lineno"> 1326 </span><span class="spaces">           </span><span class="nottickedoff">case args of</span>
<span class="lineno"> 1327 </span><span class="spaces">             </span><span class="nottickedoff">[t1, t2, t3] -&gt; (t1, t2, t3)</span>
<span class="lineno"> 1328 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;uncurryMacro: wrong number of arguments!&quot;</span>
<span class="lineno"> 1329 </span><span class="spaces">     </span><span class="nottickedoff">mtp_a &lt;- monadifyTypeM tp_a</span>
<span class="lineno"> 1330 </span><span class="spaces">     </span><span class="nottickedoff">mtp_b &lt;- monadifyTypeM tp_b</span>
<span class="lineno"> 1331 </span><span class="spaces">     </span><span class="nottickedoff">mtp_c &lt;- monadifyTypeM tp_c</span>
<span class="lineno"> 1332 </span><span class="spaces">     </span><span class="nottickedoff">let unc_app = applyGlobalOpenTerm &quot;Prelude.uncurry&quot; [toArgType mtp_a,</span>
<span class="lineno"> 1333 </span><span class="spaces">                                                          </span><span class="nottickedoff">toArgType mtp_b,</span>
<span class="lineno"> 1334 </span><span class="spaces">                                                          </span><span class="nottickedoff">toCompType mtp_c]</span>
<span class="lineno"> 1335 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromCompTerm (MTyArrow (MTyArrow mtp_a (MTyArrow mtp_b mtp_c))</span>
<span class="lineno"> 1336 </span><span class="spaces">                            </span><span class="nottickedoff">(MTyArrow (MTyTuple [mtp_a, mtp_b]) mtp_c)) unc_app</span></span>
<span class="lineno"> 1337 </span>
<span class="lineno"> 1338 </span>-- | The macro for invariantHint, which converts @invariantHint a cond m@
<span class="lineno"> 1339 </span>-- to @invariantHint (CompM a) cond m@ and which contains any binds in the body
<span class="lineno"> 1340 </span>-- to the body
<span class="lineno"> 1341 </span>invariantHintMacro :: (?mm :: ModuleMap) =&gt; MonMacro
<span class="lineno"> 1342 </span><span class="decl"><span class="nottickedoff">invariantHintMacro = MonMacro 3 $ \_ args -&gt; usingEvType $</span>
<span class="lineno"> 1343 </span><span class="spaces">  </span><span class="nottickedoff">do let (tp, cond, m) =</span>
<span class="lineno"> 1344 </span><span class="spaces">           </span><span class="nottickedoff">case args of</span>
<span class="lineno"> 1345 </span><span class="spaces">             </span><span class="nottickedoff">[t1, t2, t3] -&gt; (t1, t2, t3)</span>
<span class="lineno"> 1346 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;invariantHintMacro: wrong number of arguments!&quot;</span>
<span class="lineno"> 1347 </span><span class="spaces">     </span><span class="nottickedoff">atrm_cond &lt;- monadifyArg (Just MTyBool) cond</span>
<span class="lineno"> 1348 </span><span class="spaces">     </span><span class="nottickedoff">mtp &lt;- monadifyTypeM tp</span>
<span class="lineno"> 1349 </span><span class="spaces">     </span><span class="nottickedoff">mtrm &lt;- resetMonadifyM mtp $ monadifyTerm (Just mtp) m</span>
<span class="lineno"> 1350 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromCompTerm mtp $</span>
<span class="lineno"> 1351 </span><span class="spaces">       </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;SpecM.invariantHint&quot;)</span>
<span class="lineno"> 1352 </span><span class="spaces">       </span><span class="nottickedoff">[toCompType mtp, toArgTerm atrm_cond, toCompTerm mtrm]</span></span>
<span class="lineno"> 1353 </span>
<span class="lineno"> 1354 </span>-- | The macro for @asserting@ or @assuming@, which converts @asserting@ to
<span class="lineno"> 1355 </span>-- @assertingM@ or @assuming@ to @assumingM@ (depending on whether the given
<span class="lineno"> 1356 </span>-- 'Bool' is true or false, respectively) and which contains any binds in the
<span class="lineno"> 1357 </span>-- body to the body
<span class="lineno"> 1358 </span>assertingOrAssumingMacro :: (?mm :: ModuleMap) =&gt; Bool -&gt; MonMacro
<span class="lineno"> 1359 </span><span class="decl"><span class="nottickedoff">assertingOrAssumingMacro doAsserting = MonMacro 3 $ \_ args -&gt;</span>
<span class="lineno"> 1360 </span><span class="spaces">  </span><span class="nottickedoff">usingEvType $</span>
<span class="lineno"> 1361 </span><span class="spaces">  </span><span class="nottickedoff">do let (tp, cond, m) =</span>
<span class="lineno"> 1362 </span><span class="spaces">           </span><span class="nottickedoff">case args of</span>
<span class="lineno"> 1363 </span><span class="spaces">             </span><span class="nottickedoff">[t1, t2, t3] -&gt; (t1, t2, t3)</span>
<span class="lineno"> 1364 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; error &quot;assertingOrAssumingMacro: wrong number of arguments!&quot;</span>
<span class="lineno"> 1365 </span><span class="spaces">     </span><span class="nottickedoff">atrm_cond &lt;- monadifyArg (Just MTyBool) cond</span>
<span class="lineno"> 1366 </span><span class="spaces">     </span><span class="nottickedoff">mtp &lt;- monadifyTypeM tp</span>
<span class="lineno"> 1367 </span><span class="spaces">     </span><span class="nottickedoff">mtrm &lt;- resetMonadifyM mtp $ monadifyTerm (Just mtp) m</span>
<span class="lineno"> 1368 </span><span class="spaces">     </span><span class="nottickedoff">ev &lt;- askEvType</span>
<span class="lineno"> 1369 </span><span class="spaces">     </span><span class="nottickedoff">let ident = if doAsserting then &quot;SpecM.assertingS&quot;</span>
<span class="lineno"> 1370 </span><span class="spaces">                                </span><span class="nottickedoff">else &quot;SpecM.assumingS&quot;</span>
<span class="lineno"> 1371 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromCompTerm mtp $</span>
<span class="lineno"> 1372 </span><span class="spaces">       </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm ident)</span>
<span class="lineno"> 1373 </span><span class="spaces">       </span><span class="nottickedoff">[evTypeTerm ev, toArgType mtp, toArgTerm atrm_cond, toCompTerm mtrm]</span></span>
<span class="lineno"> 1374 </span>
<span class="lineno"> 1375 </span>-- | @finMacro b i j from to params_p@ makes a 'MonMacro' that maps a named
<span class="lineno"> 1376 </span>-- global @from@ whose @i@th through @(i+j-1)@th arguments are @Num@s, to a
<span class="lineno"> 1377 </span>-- named global @to@, which is of semi-pure type if and only if @b@ is 'True',
<span class="lineno"> 1378 </span>-- that takes an additional argument of type @isFinite n@ after each of the
<span class="lineno"> 1379 </span>-- aforementioned @Num@ arguments. The @params_p@ flag indicates whether the
<span class="lineno"> 1380 </span>-- current 'EventType' should be passed as the first argument to @to@.
<span class="lineno"> 1381 </span>finMacro :: Bool -&gt; Int -&gt; Int -&gt; Ident -&gt; Ident -&gt; Bool -&gt; MonMacro
<span class="lineno"> 1382 </span><span class="decl"><span class="nottickedoff">finMacro isSemiPure i j from to params_p =</span>
<span class="lineno"> 1383 </span><span class="spaces">  </span><span class="nottickedoff">MonMacro (i+j) $ \glob args -&gt; usingEvType $</span>
<span class="lineno"> 1384 </span><span class="spaces">  </span><span class="nottickedoff">do if nameInfo (globalDefName glob) == ModuleIdentifier from &amp;&amp; length args == i+j then</span>
<span class="lineno"> 1385 </span><span class="spaces">       </span><span class="nottickedoff">return ()</span>
<span class="lineno"> 1386 </span><span class="spaces">       </span><span class="nottickedoff">else error (&quot;Monadification macro for &quot; ++ show from ++</span>
<span class="lineno"> 1387 </span><span class="spaces">                   </span><span class="nottickedoff">&quot; applied incorrectly&quot;)</span>
<span class="lineno"> 1388 </span><span class="spaces">     </span><span class="nottickedoff">let (init_args_tms, fin_args_tms) = splitAt i args</span>
<span class="lineno"> 1389 </span><span class="spaces">     </span><span class="nottickedoff">-- Monadify the first @i@ args</span>
<span class="lineno"> 1390 </span><span class="spaces">     </span><span class="nottickedoff">init_args &lt;- mapM monadifyTpExprM init_args_tms</span>
<span class="lineno"> 1391 </span><span class="spaces">     </span><span class="nottickedoff">-- Monadify the @i@th through @(i+j-1)@th args and build proofs that they are finite</span>
<span class="lineno"> 1392 </span><span class="spaces">     </span><span class="nottickedoff">fin_args &lt;- mapM monadifyNumM fin_args_tms</span>
<span class="lineno"> 1393 </span><span class="spaces">     </span><span class="nottickedoff">fin_pfs &lt;- mapM assertIsFinite fin_args</span>
<span class="lineno"> 1394 </span><span class="spaces">     </span><span class="nottickedoff">-- Apply the type of @glob@ to the monadified arguments and apply @to@ to the</span>
<span class="lineno"> 1395 </span><span class="spaces">     </span><span class="nottickedoff">-- monadified arguments along with the proofs that the latter arguments are finite</span>
<span class="lineno"> 1396 </span><span class="spaces">     </span><span class="nottickedoff">let glob_tp = monadifyType [] $ globalDefType glob</span>
<span class="lineno"> 1397 </span><span class="spaces">     </span><span class="nottickedoff">let glob_args = map tpExprToArg init_args ++ map numToArg fin_args</span>
<span class="lineno"> 1398 </span><span class="spaces">     </span><span class="nottickedoff">let glob_tp_app = foldl applyMonType glob_tp glob_args</span>
<span class="lineno"> 1399 </span><span class="spaces">     </span><span class="nottickedoff">let to_args =</span>
<span class="lineno"> 1400 </span><span class="spaces">           </span><span class="nottickedoff">map someTpExprVal init_args ++</span>
<span class="lineno"> 1401 </span><span class="spaces">           </span><span class="nottickedoff">concatMap (\(n,pf) -&gt; [numExprVal n,</span>
<span class="lineno"> 1402 </span><span class="spaces">                                  </span><span class="nottickedoff">toArgTerm pf]) (zip fin_args fin_pfs)</span>
<span class="lineno"> 1403 </span><span class="spaces">     </span><span class="nottickedoff">let to_app =</span>
<span class="lineno"> 1404 </span><span class="spaces">           </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm to)</span>
<span class="lineno"> 1405 </span><span class="spaces">           </span><span class="nottickedoff">((if params_p then (evTypeTerm ?specMEvType :) else id) to_args)</span>
<span class="lineno"> 1406 </span><span class="spaces">     </span><span class="nottickedoff">-- Finally, return the result as semi-pure dependent on @isSemiPure@</span>
<span class="lineno"> 1407 </span><span class="spaces">     </span><span class="nottickedoff">return $ if isSemiPure</span>
<span class="lineno"> 1408 </span><span class="spaces">              </span><span class="nottickedoff">then ArgMonTerm $ fromSemiPureTerm glob_tp_app to_app</span>
<span class="lineno"> 1409 </span><span class="spaces">              </span><span class="nottickedoff">else ArgMonTerm $ fromArgTerm glob_tp_app to_app</span></span>
<span class="lineno"> 1410 </span>
<span class="lineno"> 1411 </span>-- FIXME HERE NOW: add a case for a fix of a record type of functions, which
<span class="lineno"> 1412 </span>-- should translate to MultiFixS
<span class="lineno"> 1413 </span>
<span class="lineno"> 1414 </span>-- | The macro for fix
<span class="lineno"> 1415 </span>--
<span class="lineno"> 1416 </span>-- FIXME: does not yet handle mutual recursion
<span class="lineno"> 1417 </span>fixMacro :: (?mm :: ModuleMap) =&gt; MonMacro
<span class="lineno"> 1418 </span><span class="decl"><span class="nottickedoff">fixMacro = MonMacro 2 $ \_ args -&gt; case args of</span>
<span class="lineno"> 1419 </span><span class="spaces">  </span><span class="nottickedoff">[tp@(asPi -&gt; Just _), f] -&gt;</span>
<span class="lineno"> 1420 </span><span class="spaces">    </span><span class="nottickedoff">do ev &lt;- askEvType</span>
<span class="lineno"> 1421 </span><span class="spaces">       </span><span class="nottickedoff">mtp &lt;- monadifyTypeM tp</span>
<span class="lineno"> 1422 </span><span class="spaces">       </span><span class="nottickedoff">usingEvType $ do</span>
<span class="lineno"> 1423 </span><span class="spaces">         </span><span class="nottickedoff">amtrm_f &lt;- monadifyArg (Just $ MTyArrow mtp mtp) f</span>
<span class="lineno"> 1424 </span><span class="spaces">         </span><span class="nottickedoff">return $ fromCompTerm mtp $</span>
<span class="lineno"> 1425 </span><span class="spaces">           </span><span class="nottickedoff">applyOpenTermMulti (globalOpenTerm &quot;SpecM.FixS&quot;)</span>
<span class="lineno"> 1426 </span><span class="spaces">           </span><span class="nottickedoff">[evTypeTerm ev, toTpDesc mtp, toCompTerm amtrm_f]</span>
<span class="lineno"> 1427 </span><span class="spaces">  </span><span class="nottickedoff">[(asRecordType -&gt; Just _), _] -&gt;</span>
<span class="lineno"> 1428 </span><span class="spaces">    </span><span class="nottickedoff">fail &quot;Monadification failed: cannot yet handle mutual recursion&quot;</span>
<span class="lineno"> 1429 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;fixMacro: malformed arguments!&quot;</span></span>
<span class="lineno"> 1430 </span>
<span class="lineno"> 1431 </span>-- | A &quot;macro mapping&quot; maps a single pure identifier to a 'MonMacro' for it
<span class="lineno"> 1432 </span>type MacroMapping = (NameInfo, MonMacro)
<span class="lineno"> 1433 </span>
<span class="lineno"> 1434 </span>-- | Build a 'MacroMapping' for an identifier to a semi-pure named function
<span class="lineno"> 1435 </span>mmSemiPure :: Ident -&gt; Ident -&gt; Bool -&gt; MacroMapping
<span class="lineno"> 1436 </span><span class="decl"><span class="nottickedoff">mmSemiPure from_id to_id params_p =</span>
<span class="lineno"> 1437 </span><span class="spaces">  </span><span class="nottickedoff">(ModuleIdentifier from_id, semiPureGlobalMacro from_id to_id params_p)</span></span>
<span class="lineno"> 1438 </span>
<span class="lineno"> 1439 </span>-- | Build a 'MacroMapping' for an identifier to a semi-pure named function
<span class="lineno"> 1440 </span>-- whose @i@th through @(i+j-1)@th arguments are @Num@s that require
<span class="lineno"> 1441 </span>-- @isFinite@ proofs
<span class="lineno"> 1442 </span>mmSemiPureFin :: Int -&gt; Int -&gt; Ident -&gt; Ident -&gt; Bool -&gt; MacroMapping
<span class="lineno"> 1443 </span><span class="decl"><span class="nottickedoff">mmSemiPureFin i j from_id to_id params_p =</span>
<span class="lineno"> 1444 </span><span class="spaces">  </span><span class="nottickedoff">(ModuleIdentifier from_id, finMacro True i j from_id to_id params_p)</span></span>
<span class="lineno"> 1445 </span>
<span class="lineno"> 1446 </span>-- | Build a 'MacroMapping' for an identifier to itself as a semi-pure function
<span class="lineno"> 1447 </span>mmSelf :: Ident -&gt; MacroMapping
<span class="lineno"> 1448 </span><span class="decl"><span class="nottickedoff">mmSelf self_id =</span>
<span class="lineno"> 1449 </span><span class="spaces">  </span><span class="nottickedoff">(ModuleIdentifier self_id, semiPureGlobalMacro self_id self_id False)</span></span>
<span class="lineno"> 1450 </span>
<span class="lineno"> 1451 </span>-- | Build a 'MacroMapping' from an identifier to a function of argument type,
<span class="lineno"> 1452 </span>-- where the 'Bool' flag indicates whether the current 'SpecMArgs' should be
<span class="lineno"> 1453 </span>-- passed as additional arguments to the &quot;to&quot; identifier
<span class="lineno"> 1454 </span>mmArg :: Ident -&gt; Ident -&gt; Bool -&gt; MacroMapping
<span class="lineno"> 1455 </span><span class="decl"><span class="nottickedoff">mmArg from_id to_id params_p =</span>
<span class="lineno"> 1456 </span><span class="spaces">  </span><span class="nottickedoff">(ModuleIdentifier from_id,</span>
<span class="lineno"> 1457 </span><span class="spaces">   </span><span class="nottickedoff">argGlobalMacro (ModuleIdentifier from_id) to_id params_p)</span></span>
<span class="lineno"> 1458 </span>
<span class="lineno"> 1459 </span>-- | Build a 'MacroMapping' for an identifier to a function of argument type,
<span class="lineno"> 1460 </span>-- whose @i@th through @(i+j-1)@th arguments are @Num@s that require
<span class="lineno"> 1461 </span>-- @isFinite@ proofs, where the 'Bool' flag indicates whether the current
<span class="lineno"> 1462 </span>-- 'SpecMArgs' should be passed as additional arguments to the &quot;to&quot; identifier
<span class="lineno"> 1463 </span>mmArgFin :: Int -&gt; Int -&gt; Ident -&gt; Ident -&gt; Bool -&gt; MacroMapping
<span class="lineno"> 1464 </span><span class="decl"><span class="nottickedoff">mmArgFin i j from_id to_id params_p =</span>
<span class="lineno"> 1465 </span><span class="spaces">  </span><span class="nottickedoff">(ModuleIdentifier from_id, finMacro False i j from_id to_id params_p)</span></span>
<span class="lineno"> 1466 </span>
<span class="lineno"> 1467 </span>-- | Build a 'MacroMapping' from an identifier and a custom 'MonMacro'
<span class="lineno"> 1468 </span>mmCustom :: Ident -&gt; MonMacro -&gt; MacroMapping
<span class="lineno"> 1469 </span><span class="decl"><span class="nottickedoff">mmCustom from_id macro = (ModuleIdentifier from_id, macro)</span></span>
<span class="lineno"> 1470 </span>
<span class="lineno"> 1471 </span>-- | The default monadification environment
<span class="lineno"> 1472 </span>defaultMonEnv :: (?mm :: ModuleMap) =&gt; MonadifyEnv
<span class="lineno"> 1473 </span><span class="decl"><span class="nottickedoff">defaultMonEnv = MonadifyEnv { monEnvMonTable = defaultMonTable,</span>
<span class="lineno"> 1474 </span><span class="spaces">                              </span><span class="nottickedoff">monEnvEvType = defaultSpecMEventType }</span></span>
<span class="lineno"> 1475 </span>
<span class="lineno"> 1476 </span>-- | The default primitive monadification table
<span class="lineno"> 1477 </span>defaultMonTable :: (?mm :: ModuleMap) =&gt; Map NameInfo MonMacro
<span class="lineno"> 1478 </span><span class="decl"><span class="nottickedoff">defaultMonTable =</span>
<span class="lineno"> 1479 </span><span class="spaces">  </span><span class="nottickedoff">Map.fromList</span>
<span class="lineno"> 1480 </span><span class="spaces">  </span><span class="nottickedoff">[</span>
<span class="lineno"> 1481 </span><span class="spaces">    </span><span class="nottickedoff">-- Prelude functions</span>
<span class="lineno"> 1482 </span><span class="spaces">    </span><span class="nottickedoff">mmCustom &quot;Prelude.unsafeAssert&quot; unsafeAssertMacro</span>
<span class="lineno"> 1483 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;Prelude.ite&quot; iteMacro</span>
<span class="lineno"> 1484 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;Prelude.fix&quot; fixMacro</span>
<span class="lineno"> 1485 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;Prelude.either&quot; eitherMacro</span>
<span class="lineno"> 1486 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;Prelude.uncurry&quot; uncurryMacro</span>
<span class="lineno"> 1487 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;SpecM.invariantHint&quot; invariantHintMacro</span>
<span class="lineno"> 1488 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;SpecM.asserting&quot; (assertingOrAssumingMacro True)</span>
<span class="lineno"> 1489 </span><span class="spaces">  </span><span class="nottickedoff">, mmCustom &quot;SpecM.assuming&quot; (assertingOrAssumingMacro False)</span>
<span class="lineno"> 1490 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1491 </span><span class="spaces">    </span><span class="nottickedoff">-- Top-level sequence functions</span>
<span class="lineno"> 1492 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.seqMap&quot; &quot;CryptolM.seqMapM&quot; True</span>
<span class="lineno"> 1493 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.seq_cong1&quot; &quot;CryptolM.mseq_cong1&quot; True</span>
<span class="lineno"> 1494 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.eListSel&quot; &quot;CryptolM.eListSelM&quot; True</span>
<span class="lineno"> 1495 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1496 </span><span class="spaces">    </span><span class="nottickedoff">-- List comprehensions</span>
<span class="lineno"> 1497 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.from&quot; &quot;CryptolM.fromM&quot; True</span>
<span class="lineno"> 1498 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.mlet&quot; &quot;CryptolM.mletM&quot; True</span>
<span class="lineno"> 1499 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.seqZip&quot; &quot;CryptolM.seqZipM&quot; True</span>
<span class="lineno"> 1500 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.seqZipSame&quot; &quot;CryptolM.seqZipSameM&quot; True</span>
<span class="lineno"> 1501 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1502 </span><span class="spaces">    </span><span class="nottickedoff">-- PEq constraints</span>
<span class="lineno"> 1503 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PEqSeq&quot; &quot;CryptolM.PEqMSeq&quot; True</span>
<span class="lineno"> 1504 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PEqSeqBool&quot; &quot;CryptolM.PEqMSeqBool&quot; True</span>
<span class="lineno"> 1505 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1506 </span><span class="spaces">    </span><span class="nottickedoff">-- PCmp constraints</span>
<span class="lineno"> 1507 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PCmpSeq&quot; &quot;CryptolM.PCmpMSeq&quot; True</span>
<span class="lineno"> 1508 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PCmpSeqBool&quot; &quot;CryptolM.PCmpMSeqBool&quot; True</span>
<span class="lineno"> 1509 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1510 </span><span class="spaces">    </span><span class="nottickedoff">-- PSignedCmp constraints</span>
<span class="lineno"> 1511 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PSignedCmpSeq&quot; &quot;CryptolM.PSignedCmpMSeq&quot; True</span>
<span class="lineno"> 1512 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PSignedCmpSeqBool&quot; &quot;CryptolM.PSignedCmpMSeqBool&quot; True</span>
<span class="lineno"> 1513 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1514 </span><span class="spaces">    </span><span class="nottickedoff">-- PZero constraints</span>
<span class="lineno"> 1515 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.PZeroSeq&quot; &quot;CryptolM.PZeroMSeq&quot; True</span>
<span class="lineno"> 1516 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PZeroSeqBool&quot; &quot;CryptolM.PZeroMSeqBool&quot; True</span>
<span class="lineno"> 1517 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1518 </span><span class="spaces">    </span><span class="nottickedoff">-- PLogic constraints</span>
<span class="lineno"> 1519 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.PLogicSeq&quot; &quot;CryptolM.PLogicMSeq&quot; True</span>
<span class="lineno"> 1520 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PLogicSeqBool&quot; &quot;CryptolM.PLogicMSeqBool&quot; True</span>
<span class="lineno"> 1521 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1522 </span><span class="spaces">    </span><span class="nottickedoff">-- PRing constraints</span>
<span class="lineno"> 1523 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.PRingSeq&quot; &quot;CryptolM.PRingMSeq&quot; True</span>
<span class="lineno"> 1524 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PRingSeqBool&quot; &quot;CryptolM.PRingMSeqBool&quot; True</span>
<span class="lineno"> 1525 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1526 </span><span class="spaces">    </span><span class="nottickedoff">-- PIntegral constraints</span>
<span class="lineno"> 1527 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PIntegeralSeqBool&quot; &quot;CryptolM.PIntegeralMSeqBool&quot; True</span>
<span class="lineno"> 1528 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1529 </span><span class="spaces">    </span><span class="nottickedoff">-- PLiteral constraints</span>
<span class="lineno"> 1530 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.PLiteralSeqBool&quot; &quot;CryptolM.PLiteralSeqBoolM&quot; True</span>
<span class="lineno"> 1531 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="nottickedoff">-- The Cryptol Literal primitives</span>
<span class="lineno"> 1533 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecNumber&quot;</span>
<span class="lineno"> 1534 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecFromZ&quot;</span>
<span class="lineno"> 1535 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1536 </span><span class="spaces">    </span><span class="nottickedoff">-- The Ring primitives</span>
<span class="lineno"> 1537 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecPlus&quot;</span>
<span class="lineno"> 1538 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecMinus&quot;</span>
<span class="lineno"> 1539 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecMul&quot;</span>
<span class="lineno"> 1540 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecNeg&quot;</span>
<span class="lineno"> 1541 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecToInteger&quot;</span>
<span class="lineno"> 1542 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1543 </span><span class="spaces">    </span><span class="nottickedoff">-- The comparison primitives</span>
<span class="lineno"> 1544 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecEq&quot;</span>
<span class="lineno"> 1545 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecNotEq&quot;</span>
<span class="lineno"> 1546 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecLt&quot;</span>
<span class="lineno"> 1547 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecLtEq&quot;</span>
<span class="lineno"> 1548 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecGt&quot;</span>
<span class="lineno"> 1549 </span><span class="spaces">  </span><span class="nottickedoff">, mmSelf &quot;Cryptol.ecGtEq&quot;</span>
<span class="lineno"> 1550 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1551 </span><span class="spaces">    </span><span class="nottickedoff">-- Sequences</span>
<span class="lineno"> 1552 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.ecShiftL&quot; &quot;CryptolM.ecShiftLM&quot; True</span>
<span class="lineno"> 1553 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.ecShiftR&quot; &quot;CryptolM.ecShiftRM&quot; True</span>
<span class="lineno"> 1554 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.ecSShiftR&quot; &quot;CryptolM.ecSShiftRM&quot; True</span>
<span class="lineno"> 1555 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecRotL&quot; &quot;CryptolM.ecRotLM&quot; True</span>
<span class="lineno"> 1556 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecRotR&quot; &quot;CryptolM.ecRotRM&quot; True</span>
<span class="lineno"> 1557 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecCat&quot; &quot;CryptolM.ecCatM&quot; True</span>
<span class="lineno"> 1558 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.ecTake&quot; &quot;CryptolM.ecTakeM&quot; True</span>
<span class="lineno"> 1559 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecDrop&quot; &quot;CryptolM.ecDropM&quot; True</span>
<span class="lineno"> 1560 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecDrop&quot; &quot;CryptolM.ecDropM&quot; True</span>
<span class="lineno"> 1561 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 1 1 &quot;Cryptol.ecJoin&quot; &quot;CryptolM.ecJoinM&quot; True</span>
<span class="lineno"> 1562 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 1 1 &quot;Cryptol.ecSplit&quot; &quot;CryptolM.ecSplitM&quot; True</span>
<span class="lineno"> 1563 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecReverse&quot; &quot;CryptolM.ecReverseM&quot; True</span>
<span class="lineno"> 1564 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.ecTranspose&quot; &quot;CryptolM.ecTransposeM&quot; True</span>
<span class="lineno"> 1565 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.ecAt&quot; &quot;CryptolM.ecAtM&quot; True</span>
<span class="lineno"> 1566 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.ecUpdate&quot; &quot;CryptolM.ecUpdateM&quot; True</span>
<span class="lineno"> 1567 </span><span class="spaces">  </span><span class="nottickedoff">, mmArgFin 0 1 &quot;Cryptol.ecAtBack&quot; &quot;CryptolM.ecAtBackM&quot; True</span>
<span class="lineno"> 1568 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 2 &quot;Cryptol.ecFromTo&quot; &quot;CryptolM.ecFromToM&quot; True</span>
<span class="lineno"> 1569 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 0 1 &quot;Cryptol.ecFromToLessThan&quot; &quot;CryptolM.ecFromToLessThanM&quot; True</span>
<span class="lineno"> 1570 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPureFin 4 1 &quot;Cryptol.ecFromThenTo&quot; &quot;CryptolM.ecFromThenToM&quot; True</span>
<span class="lineno"> 1571 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.ecInfFrom&quot; &quot;CryptolM.ecInfFromM&quot; True</span>
<span class="lineno"> 1572 </span><span class="spaces">  </span><span class="nottickedoff">, mmSemiPure &quot;Cryptol.ecInfFromThen&quot; &quot;CryptolM.ecInfFromThenM&quot; True</span>
<span class="lineno"> 1573 </span><span class="spaces">  </span><span class="nottickedoff">, mmArg &quot;Cryptol.ecError&quot; &quot;CryptolM.ecErrorM&quot; True</span>
<span class="lineno"> 1574 </span><span class="spaces">  </span><span class="nottickedoff">]</span></span>
<span class="lineno"> 1575 </span>
<span class="lineno"> 1576 </span>
<span class="lineno"> 1577 </span>----------------------------------------------------------------------
<span class="lineno"> 1578 </span>-- * Top-Level Entrypoints
<span class="lineno"> 1579 </span>----------------------------------------------------------------------
<span class="lineno"> 1580 </span>
<span class="lineno"> 1581 </span>-- | Ensure that the @CryptolM@ module is loaded
<span class="lineno"> 1582 </span>ensureCryptolMLoaded :: SharedContext -&gt; IO ()
<span class="lineno"> 1583 </span><span class="decl"><span class="istickedoff">ensureCryptolMLoaded sc =</span>
<span class="lineno"> 1584 </span><span class="spaces">  </span><span class="istickedoff">scModuleIsLoaded sc (mkModuleName [&quot;CryptolM&quot;]) &gt;&gt;= \is_loaded -&gt;</span>
<span class="lineno"> 1585 </span><span class="spaces">  </span><span class="istickedoff">if <span class="tickonlyfalse">is_loaded</span> then <span class="nottickedoff">return ()</span> else</span>
<span class="lineno"> 1586 </span><span class="spaces">    </span><span class="istickedoff">scLoadSpecMModule sc &gt;&gt; scLoadCryptolMModule sc</span></span>
<span class="lineno"> 1587 </span>
<span class="lineno"> 1588 </span>-- | Monadify a type to its argument type and complete it to a 'Term',
<span class="lineno"> 1589 </span>-- additionally quantifying over the event type and function stack if the
<span class="lineno"> 1590 </span>-- supplied 'Bool' is 'True'
<span class="lineno"> 1591 </span>monadifyCompleteArgType :: SharedContext -&gt; MonadifyEnv -&gt; Term -&gt; Bool -&gt;
<span class="lineno"> 1592 </span>                           IO Term
<span class="lineno"> 1593 </span><span class="decl"><span class="nottickedoff">monadifyCompleteArgType sc env tp poly_p =</span>
<span class="lineno"> 1594 </span><span class="spaces">  </span><span class="nottickedoff">(ensureCryptolMLoaded sc &gt;&gt;) $</span>
<span class="lineno"> 1595 </span><span class="spaces">  </span><span class="nottickedoff">completeOpenTerm sc $</span>
<span class="lineno"> 1596 </span><span class="spaces">  </span><span class="nottickedoff">if poly_p then</span>
<span class="lineno"> 1597 </span><span class="spaces">    </span><span class="nottickedoff">-- Parameter polymorphism means pi-quantification over E</span>
<span class="lineno"> 1598 </span><span class="spaces">    </span><span class="nottickedoff">(piOpenTerm &quot;E&quot; (dataTypeOpenTerm &quot;SpecM.EvType&quot; []) $ \e -&gt;</span>
<span class="lineno"> 1599 </span><span class="spaces">      </span><span class="nottickedoff">let ?specMEvType = EventType e in</span>
<span class="lineno"> 1600 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: even though E is a free variable here, it can not be free in tp,</span>
<span class="lineno"> 1601 </span><span class="spaces">      </span><span class="nottickedoff">-- which is a closed term, so we do not list it in the MonadifyTypeCtx</span>
<span class="lineno"> 1602 </span><span class="spaces">      </span><span class="nottickedoff">-- argument of monadifyTypeArgType</span>
<span class="lineno"> 1603 </span><span class="spaces">      </span><span class="nottickedoff">monadifyTypeArgType [] tp)</span>
<span class="lineno"> 1604 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="nottickedoff">let ?specMEvType = monEnvEvType env in monadifyTypeArgType [] tp</span></span>
<span class="lineno"> 1606 </span>
<span class="lineno"> 1607 </span>-- | Monadify a term of the specified type to a 'MonTerm' and then complete that
<span class="lineno"> 1608 </span>-- 'MonTerm' to a SAW core 'Term', or 'fail' if this is not possible
<span class="lineno"> 1609 </span>monadifyCompleteTerm :: SharedContext -&gt; MonadifyEnv -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1610 </span><span class="decl"><span class="nottickedoff">monadifyCompleteTerm sc env trm tp =</span>
<span class="lineno"> 1611 </span><span class="spaces">  </span><span class="nottickedoff">do ensureCryptolMLoaded sc</span>
<span class="lineno"> 1612 </span><span class="spaces">     </span><span class="nottickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1613 </span><span class="spaces">     </span><span class="nottickedoff">let ?mm = mm</span>
<span class="lineno"> 1614 </span><span class="spaces">     </span><span class="nottickedoff">runCompleteMonadifyM sc env tp $ usingEvType $</span>
<span class="lineno"> 1615 </span><span class="spaces">       </span><span class="nottickedoff">monadifyTerm (Just $ monadifyType [] tp) trm</span></span>
<span class="lineno"> 1616 </span>
<span class="lineno"> 1617 </span>-- | Convert a name of a definition to the name of its monadified version
<span class="lineno"> 1618 </span>monadifyName :: NameInfo -&gt; IO NameInfo
<span class="lineno"> 1619 </span><span class="decl"><span class="nottickedoff">monadifyName (ModuleIdentifier ident) =</span>
<span class="lineno"> 1620 </span><span class="spaces">  </span><span class="nottickedoff">return $ ModuleIdentifier $ mkIdent (identModule ident) $</span>
<span class="lineno"> 1621 </span><span class="spaces">  </span><span class="nottickedoff">T.append (identBaseName ident) (T.pack &quot;M&quot;)</span>
<span class="lineno"> 1622 </span><span class="spaces"></span><span class="nottickedoff">monadifyName (ImportedName uri aliases) =</span>
<span class="lineno"> 1623 </span><span class="spaces">  </span><span class="nottickedoff">do frag &lt;- URI.mkFragment (T.pack &quot;M&quot;)</span>
<span class="lineno"> 1624 </span><span class="spaces">     </span><span class="nottickedoff">let aliases' = concatMap (\a -&gt; [a, T.append a (T.pack &quot;#M&quot;)]) aliases</span>
<span class="lineno"> 1625 </span><span class="spaces">     </span><span class="nottickedoff">return $ ImportedName (uri { URI.uriFragment = Just frag }) aliases'</span></span>
<span class="lineno"> 1626 </span>
<span class="lineno"> 1627 </span>-- | The implementation of 'monadifyNamedTerm' in the @StateT MonadifyEnv IO@ monad
<span class="lineno"> 1628 </span>monadifyNamedTermH :: SharedContext -&gt; NameInfo -&gt; Maybe Term -&gt; Term -&gt;
<span class="lineno"> 1629 </span>                      StateT MonadifyEnv IO MonTerm
<span class="lineno"> 1630 </span><span class="decl"><span class="nottickedoff">monadifyNamedTermH sc nmi maybe_trm tp =</span>
<span class="lineno"> 1631 </span><span class="spaces">  </span><span class="nottickedoff">-- trace (&quot;Monadifying &quot; ++ T.unpack (toAbsoluteName nmi)) $</span>
<span class="lineno"> 1632 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \env -&gt; let ?specMEvType = monEnvEvType env in</span>
<span class="lineno"> 1633 </span><span class="spaces">  </span><span class="nottickedoff">do let mtp = monadifyType [] tp</span>
<span class="lineno"> 1634 </span><span class="spaces">     </span><span class="nottickedoff">nmi' &lt;- lift $ monadifyName nmi</span>
<span class="lineno"> 1635 </span><span class="spaces">     </span><span class="nottickedoff">comp_tp &lt;- lift $ completeOpenTerm sc $ toCompType mtp</span>
<span class="lineno"> 1636 </span><span class="spaces">     </span><span class="nottickedoff">const_trm &lt;-</span>
<span class="lineno"> 1637 </span><span class="spaces">       </span><span class="nottickedoff">case maybe_trm of</span>
<span class="lineno"> 1638 </span><span class="spaces">         </span><span class="nottickedoff">Just trm -&gt;</span>
<span class="lineno"> 1639 </span><span class="spaces">          </span><span class="nottickedoff">--  trace (&quot;&quot; ++ ppTermInMonCtx env trm ++ &quot;\n\n&quot;) $</span>
<span class="lineno"> 1640 </span><span class="spaces">           </span><span class="nottickedoff">do trm' &lt;- monadifyTermInEnvH sc trm tp</span>
<span class="lineno"> 1641 </span><span class="spaces">              </span><span class="nottickedoff">lift $ scConstant' sc nmi' trm' comp_tp</span>
<span class="lineno"> 1642 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt; lift $ scOpaqueConstant sc nmi' comp_tp</span>
<span class="lineno"> 1643 </span><span class="spaces">     </span><span class="nottickedoff">return $ fromCompTerm mtp $ closedOpenTerm const_trm</span></span>
<span class="lineno"> 1644 </span>
<span class="lineno"> 1645 </span>-- | Monadify a 'Term' of the specified type with an optional body, bind the
<span class="lineno"> 1646 </span>-- result to a fresh SAW core constant generated from the supplied name, and
<span class="lineno"> 1647 </span>-- then convert that constant back to a 'MonTerm'. Like 'monadifyTermInEnv',
<span class="lineno"> 1648 </span>-- this function also monadifies all constants the body contains, and adds
<span class="lineno"> 1649 </span>-- the monadifications of those constants to the monadification environment.
<span class="lineno"> 1650 </span>monadifyNamedTerm :: SharedContext -&gt; MonadifyEnv -&gt;
<span class="lineno"> 1651 </span>                     NameInfo -&gt; Maybe Term -&gt; Term -&gt;
<span class="lineno"> 1652 </span>                     IO (MonTerm, MonadifyEnv)
<span class="lineno"> 1653 </span><span class="decl"><span class="nottickedoff">monadifyNamedTerm sc env nmi maybe_trm tp =</span>
<span class="lineno"> 1654 </span><span class="spaces">  </span><span class="nottickedoff">(ensureCryptolMLoaded sc &gt;&gt;) $</span>
<span class="lineno"> 1655 </span><span class="spaces">  </span><span class="nottickedoff">flip runStateT env $ monadifyNamedTermH sc nmi maybe_trm tp</span></span>
<span class="lineno"> 1656 </span>
<span class="lineno"> 1657 </span>-- | The implementation of 'monadifyTermInEnv' in the @StateT MonadifyEnv IO@ monad
<span class="lineno"> 1658 </span>monadifyTermInEnvH :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1659 </span>                      StateT MonadifyEnv IO Term
<span class="lineno"> 1660 </span><span class="decl"><span class="nottickedoff">monadifyTermInEnvH sc top_trm top_tp =</span>
<span class="lineno"> 1661 </span><span class="spaces">  </span><span class="nottickedoff">do lift $ ensureCryptolMLoaded sc</span>
<span class="lineno"> 1662 </span><span class="spaces">     </span><span class="nottickedoff">mm &lt;- lift $ scGetModuleMap sc</span>
<span class="lineno"> 1663 </span><span class="spaces">     </span><span class="nottickedoff">let const_infos = Map.toAscList $ getConstantSet top_trm</span>
<span class="lineno"> 1664 </span><span class="spaces">     </span><span class="nottickedoff">forM_ const_infos $ \(vi, nmi) -&gt;</span>
<span class="lineno"> 1665 </span><span class="spaces">       </span><span class="nottickedoff">do let r = requireNameInMap (Name vi nmi) mm</span>
<span class="lineno"> 1666 </span><span class="spaces">          </span><span class="nottickedoff">let tp = resolvedNameType r</span>
<span class="lineno"> 1667 </span><span class="spaces">          </span><span class="nottickedoff">let maybe_body =</span>
<span class="lineno"> 1668 </span><span class="spaces">                </span><span class="nottickedoff">case r of</span>
<span class="lineno"> 1669 </span><span class="spaces">                  </span><span class="nottickedoff">ResolvedDef d -&gt; defBody d</span>
<span class="lineno"> 1670 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 1671 </span><span class="spaces">          </span><span class="nottickedoff">env &lt;- get</span>
<span class="lineno"> 1672 </span><span class="spaces">          </span><span class="nottickedoff">unless (isPreludeName nmi || Map.member nmi (monEnvMonTable env)) $</span>
<span class="lineno"> 1673 </span><span class="spaces">            </span><span class="nottickedoff">do mtrm &lt;- monadifyNamedTermH sc nmi maybe_body tp</span>
<span class="lineno"> 1674 </span><span class="spaces">               </span><span class="nottickedoff">modify $ monEnvAdd nmi (monMacro0 mtrm)</span>
<span class="lineno"> 1675 </span><span class="spaces">     </span><span class="nottickedoff">env &lt;- get</span>
<span class="lineno"> 1676 </span><span class="spaces">     </span><span class="nottickedoff">lift $ monadifyCompleteTerm sc env top_trm top_tp</span>
<span class="lineno"> 1677 </span><span class="spaces">  </span><span class="nottickedoff">where preludeModules = mkModuleName &lt;$&gt; [[&quot;Prelude&quot;], [&quot;Cryptol&quot;]]</span>
<span class="lineno"> 1678 </span><span class="spaces">        </span><span class="nottickedoff">isPreludeName = \case</span>
<span class="lineno"> 1679 </span><span class="spaces">          </span><span class="nottickedoff">ModuleIdentifier ident -&gt; identModule ident `elem` preludeModules</span>
<span class="lineno"> 1680 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; False</span></span>
<span class="lineno"> 1681 </span>
<span class="lineno"> 1682 </span>-- | Monadify a term with the specified type along with all constants it
<span class="lineno"> 1683 </span>-- contains, adding the monadifications of those constants to the monadification
<span class="lineno"> 1684 </span>-- environment
<span class="lineno"> 1685 </span>monadifyTermInEnv :: SharedContext -&gt; MonadifyEnv -&gt;
<span class="lineno"> 1686 </span>                     Term -&gt; Term -&gt; IO (Term, MonadifyEnv)
<span class="lineno"> 1687 </span><span class="decl"><span class="nottickedoff">monadifyTermInEnv sc top_env top_trm top_tp =</span>
<span class="lineno"> 1688 </span><span class="spaces">  </span><span class="nottickedoff">flip runStateT top_env $ monadifyTermInEnvH sc top_trm top_tp</span></span>
<span class="lineno"> 1689 </span>
<span class="lineno"> 1690 </span>-- | The implementation of 'monadifyCryptolModule' in the @StateT MonadifyEnv IO@ monad
<span class="lineno"> 1691 </span>monadifyCryptolModuleH :: SharedContext -&gt; Env -&gt; CryptolModule -&gt;
<span class="lineno"> 1692 </span>                          StateT MonadifyEnv IO CryptolModule
<span class="lineno"> 1693 </span><span class="decl"><span class="nottickedoff">monadifyCryptolModuleH sc cry_env (CryptolModule tysyns top_tts) =</span>
<span class="lineno"> 1694 </span><span class="spaces">  </span><span class="nottickedoff">fmap (CryptolModule tysyns) $ flip mapM top_tts $ \top_tt -&gt;</span>
<span class="lineno"> 1695 </span><span class="spaces">    </span><span class="nottickedoff">do let top_tm = ttTerm top_tt</span>
<span class="lineno"> 1696 </span><span class="spaces">       </span><span class="nottickedoff">top_tp &lt;- lift $ ttTypeAsTerm sc cry_env top_tt</span>
<span class="lineno"> 1697 </span><span class="spaces">       </span><span class="nottickedoff">tm &lt;- monadifyTermInEnvH sc top_tm top_tp</span>
<span class="lineno"> 1698 </span><span class="spaces">       </span><span class="nottickedoff">tm' &lt;- lift $ mkTypedTerm sc tm</span>
<span class="lineno"> 1699 </span><span class="spaces">       </span><span class="nottickedoff">return tm'</span></span>
<span class="lineno"> 1700 </span>
<span class="lineno"> 1701 </span>-- | Monadify each term in the given 'CryptolModule' along with all constants each
<span class="lineno"> 1702 </span>-- contains, returning a new module which each term monadified, and adding the
<span class="lineno"> 1703 </span>-- monadifications of all encountered constants to the monadification environment
<span class="lineno"> 1704 </span>monadifyCryptolModule :: SharedContext -&gt; Env -&gt; MonadifyEnv -&gt;
<span class="lineno"> 1705 </span>                         CryptolModule -&gt; IO (CryptolModule, MonadifyEnv)
<span class="lineno"> 1706 </span><span class="decl"><span class="nottickedoff">monadifyCryptolModule sc cry_env top_env cry_mod =</span>
<span class="lineno"> 1707 </span><span class="spaces">  </span><span class="nottickedoff">flip runStateT top_env $ monadifyCryptolModuleH sc cry_env cry_mod</span></span>

</pre>
</body>
</html>
