<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Proof
<span class="lineno">    3 </span>Description : Representations of SAW-Script proof states.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# LANGUAGE BlockArguments #-}
<span class="lineno">   10 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   11 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   12 </span>{-# LANGUAGE ParallelListComp #-}
<span class="lineno">   13 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   14 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>module SAWCentral.Proof
<span class="lineno">   17 </span>  ( Prop
<span class="lineno">   18 </span>  , splitConj
<span class="lineno">   19 </span>  , splitDisj
<span class="lineno">   20 </span>  , unfoldProp
<span class="lineno">   21 </span>  , unfoldFixOnceProp
<span class="lineno">   22 </span>  , simplifyProp
<span class="lineno">   23 </span>  , hoistIfsInProp
<span class="lineno">   24 </span>  , evalProp
<span class="lineno">   25 </span>  , betaReduceProp
<span class="lineno">   26 </span>  , falseProp
<span class="lineno">   27 </span>  , termToProp
<span class="lineno">   28 </span>  , termToMaybeProp
<span class="lineno">   29 </span>  , propToTerm
<span class="lineno">   30 </span>  , propToRewriteRule
<span class="lineno">   31 </span>  , propSize
<span class="lineno">   32 </span>  , prettyProp
<span class="lineno">   33 </span>  , ppProp
<span class="lineno">   34 </span>  , propToSATQuery
<span class="lineno">   35 </span>  , normalizeProp
<span class="lineno">   36 </span>  , checkProp
<span class="lineno">   37 </span>  , unProp
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>  , Sequent
<span class="lineno">   40 </span>  , sequentGetFocus
<span class="lineno">   41 </span>  , sequentToProp
<span class="lineno">   42 </span>  , sequentToSATQuery
<span class="lineno">   43 </span>  , sequentSharedSize
<span class="lineno">   44 </span>  , sequentTreeSize
<span class="lineno">   45 </span>  , prettySequent
<span class="lineno">   46 </span>  , ppSequent
<span class="lineno">   47 </span>  , propToSequent
<span class="lineno">   48 </span>  , traverseSequent
<span class="lineno">   49 </span>  , traverseSequentWithFocus
<span class="lineno">   50 </span>  , checkSequent
<span class="lineno">   51 </span>  , sequentConstantSet
<span class="lineno">   52 </span>  , booleansToSequent
<span class="lineno">   53 </span>  , unfocusSequent
<span class="lineno">   54 </span>  , focusOnConcl
<span class="lineno">   55 </span>  , focusOnHyp
<span class="lineno">   56 </span>  , normalizeSequent
<span class="lineno">   57 </span>  , filterHyps
<span class="lineno">   58 </span>  , filterConcls
<span class="lineno">   59 </span>  , localHypSimpset
<span class="lineno">   60 </span>  , SequentState(..)
<span class="lineno">   61 </span>  , sequentState
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>  , CofinSet(..)
<span class="lineno">   64 </span>  , cofinSetMember
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>  , TheoremDB
<span class="lineno">   67 </span>  , emptyTheoremDB
<span class="lineno">   68 </span>  , reachableTheorems
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>  , Theorem
<span class="lineno">   71 </span>  , thmProp
<span class="lineno">   72 </span>  , thmStats
<span class="lineno">   73 </span>  , thmEvidence
<span class="lineno">   74 </span>  , thmLocation
<span class="lineno">   75 </span>  , thmProgramLoc
<span class="lineno">   76 </span>  , thmReason
<span class="lineno">   77 </span>  , thmNonce
<span class="lineno">   78 </span>  , thmDepends
<span class="lineno">   79 </span>  , thmElapsedTime
<span class="lineno">   80 </span>  , thmSummary
<span class="lineno">   81 </span>  , TheoremNonce
<span class="lineno">   82 </span>  , TheoremSummary(..)
<span class="lineno">   83 </span>
<span class="lineno">   84 </span>  , admitTheorem
<span class="lineno">   85 </span>  , solverTheorem
<span class="lineno">   86 </span>  , proofByTerm
<span class="lineno">   87 </span>  , constructTheorem
<span class="lineno">   88 </span>  , validateTheorem
<span class="lineno">   89 </span>  , specializeTheorem
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>  , Evidence(..)
<span class="lineno">   92 </span>  , checkEvidence
<span class="lineno">   93 </span>  , structuralEvidence
<span class="lineno">   94 </span>  , leafEvidence
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>  , Tactic(..)
<span class="lineno">   97 </span>  , withFirstGoal
<span class="lineno">   98 </span>  , tacticIntro
<span class="lineno">   99 </span>  , tacticApply
<span class="lineno">  100 </span>  , tacticApplyHyp
<span class="lineno">  101 </span>  , tacticSplit
<span class="lineno">  102 </span>  , tacticCut
<span class="lineno">  103 </span>  , tacticTrivial
<span class="lineno">  104 </span>  , tacticId
<span class="lineno">  105 </span>  , tacticChange
<span class="lineno">  106 </span>  , tacticSolve
<span class="lineno">  107 </span>  , tacticExact
<span class="lineno">  108 </span>  , tacticIntroHyps
<span class="lineno">  109 </span>  , tacticRevertHyp
<span class="lineno">  110 </span>  , tacticInsert
<span class="lineno">  111 </span>  , tacticSpecializeHyp
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>  , Quantification(..)
<span class="lineno">  114 </span>  , predicateToProp
<span class="lineno">  115 </span>  , boolToProp
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>  , ProofState
<span class="lineno">  118 </span>  , psTimeout
<span class="lineno">  119 </span>  , psGoals
<span class="lineno">  120 </span>  , psStats
<span class="lineno">  121 </span>  , setProofTimeout
<span class="lineno">  122 </span>  , ProofGoal(..)
<span class="lineno">  123 </span>  , startProof
<span class="lineno">  124 </span>  , finishProof
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>  , CEX
<span class="lineno">  127 </span>  , ProofResult(..)
<span class="lineno">  128 </span>  , SolveResult(..)
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>  , predicateToSATQuery
<span class="lineno">  131 </span>  ) where
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>import           Control.Monad (foldM, forM_, unless)
<span class="lineno">  134 </span>import qualified Control.Monad.Fail as F
<span class="lineno">  135 </span>import           Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">  136 </span>import           Control.Monad.Except (ExceptT, MonadError(..), runExceptT)
<span class="lineno">  137 </span>import           Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">  138 </span>import qualified Data.Foldable as Fold
<span class="lineno">  139 </span>import           Data.List
<span class="lineno">  140 </span>import           Data.Maybe (fromMaybe)
<span class="lineno">  141 </span>import           Data.Map (Map)
<span class="lineno">  142 </span>import qualified Data.Map as Map
<span class="lineno">  143 </span>import           Data.Set (Set)
<span class="lineno">  144 </span>import qualified Data.Set as Set
<span class="lineno">  145 </span>import           Data.Text (Text)
<span class="lineno">  146 </span>import qualified Data.Text as Text
<span class="lineno">  147 </span>import           Data.Time.Clock
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>import Prettyprinter
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>import Data.Parameterized.Nonce
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>import SAWCore.Prelude (scApplyPrelude_False)
<span class="lineno">  154 </span>import SAWCore.Recognizer
<span class="lineno">  155 </span>import SAWCore.Rewriter
<span class="lineno">  156 </span>import SAWCore.SATQuery
<span class="lineno">  157 </span>import SAWCore.Name (SAWNamingEnv)
<span class="lineno">  158 </span>import SAWCore.SharedTerm
<span class="lineno">  159 </span>import SAWCore.TypedAST
<span class="lineno">  160 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  161 </span>import SAWCore.FiniteValue (FirstOrderValue)
<span class="lineno">  162 </span>import SAWCore.Term.Pretty
<span class="lineno">  163 </span>  (SawDoc, renderSawDoc, ppTermWithNames, ppTermContainerWithNames)
<span class="lineno">  164 </span>import qualified SAWCore.SCTypeCheck as TC
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>import SAWCore.Simulator.Concrete (evalSharedTerm)
<span class="lineno">  167 </span>import SAWCore.Simulator.Value (asFirstOrderTypeValue, Value(..), TValue(..))
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>import What4.ProgramLoc (ProgramLoc)
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>import SAWCentral.Position
<span class="lineno">  172 </span>import SAWCentral.Prover.SolverStats
<span class="lineno">  173 </span>import qualified SAWCentral.MRSolver.Evidence as MRSolver
<span class="lineno">  174 </span>import SAWCentral.Crucible.Common as Common
<span class="lineno">  175 </span>import qualified SAWCore.Simulator.TermModel as TM
<span class="lineno">  176 </span>import qualified SAWCoreWhat4.What4 as W4Sim
<span class="lineno">  177 </span>import qualified SAWCoreWhat4.ReturnTrip as W4Sim
<span class="lineno">  178 </span>import SAWCentral.Panic(panic)
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>-- | A proposition is a saw-core type of type `Prop`.
<span class="lineno">  181 </span>-- In particular, this includes any pi type whose result
<span class="lineno">  182 </span>-- type is a proposition. The argument of a pi type represents
<span class="lineno">  183 </span>-- a universally quantified variable.
<span class="lineno">  184 </span>newtype Prop = Prop Term
<span class="lineno">  185 </span>  -- INVARIANT: The type of the given term is `Prop`
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>unProp :: Prop -&gt; Term
<span class="lineno">  188 </span><span class="decl"><span class="istickedoff">unProp (Prop tm) = tm</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | Turn a saw-core term into a proposition under the type-as-propositions
<span class="lineno">  191 </span>--   regime.  The given term must be a type, which means that its own type
<span class="lineno">  192 </span>--   is a sort.
<span class="lineno">  193 </span>termToProp :: SharedContext -&gt; Term -&gt; IO Prop
<span class="lineno">  194 </span><span class="decl"><span class="istickedoff">termToProp sc tm =</span>
<span class="lineno">  195 </span><span class="spaces">   </span><span class="istickedoff">do ty &lt;- scWhnf <span class="nottickedoff">sc</span> =&lt;&lt; scTypeOf sc tm</span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="istickedoff">case asSort ty of</span>
<span class="lineno">  197 </span><span class="spaces">        </span><span class="istickedoff">Just s | <span class="tickonlytrue">s == propSort</span> -&gt; return (Prop tm)</span>
<span class="lineno">  198 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  199 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case asLambda tm of</span></span>
<span class="lineno">  200 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt;</span></span>
<span class="lineno">  201 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;termToProp: Term is not a proposition.&quot;</span></span>
<span class="lineno">  202 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: the given term is a lambda; try using Pi terms instead.&quot;</span></span>
<span class="lineno">  203 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">, showTerm tm, showTerm ty</span></span>
<span class="lineno">  204 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  205 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno">  206 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;termToProp: Term is not a proposition&quot;, showTerm tm, showTerm ty ]</span></span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | Turn a saw-core term into a proposition under the type-as-propositions
<span class="lineno">  209 </span>--   regime.  The given term must be a type, which means that its own type
<span class="lineno">  210 </span>--   is a sort.  If it is not, return @Nothing@.
<span class="lineno">  211 </span>termToMaybeProp :: SharedContext -&gt; Term -&gt; IO (Maybe Prop)
<span class="lineno">  212 </span><span class="decl"><span class="istickedoff">termToMaybeProp sc tm =</span>
<span class="lineno">  213 </span><span class="spaces">   </span><span class="istickedoff">do ty &lt;- scWhnf <span class="nottickedoff">sc</span> =&lt;&lt; scTypeOf sc tm</span>
<span class="lineno">  214 </span><span class="spaces">      </span><span class="istickedoff">case asSort ty of</span>
<span class="lineno">  215 </span><span class="spaces">        </span><span class="istickedoff">Just s | <span class="tickonlytrue">s == propSort</span> -&gt; return (Just (Prop tm))</span>
<span class="lineno">  216 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">return Nothing</span></span></span>
<span class="lineno">  217 </span>
<span class="lineno">  218 </span>-- | Turn a boolean-valued saw-core term into a proposition by asserting
<span class="lineno">  219 </span>--   that it is equal to the true boolean value.  Generalize the proposition
<span class="lineno">  220 </span>--   by universally quantifying over the variables given in the list.
<span class="lineno">  221 </span>boolToProp :: SharedContext -&gt; [ExtCns Term] -&gt; Term -&gt; IO Prop
<span class="lineno">  222 </span><span class="decl"><span class="istickedoff">boolToProp sc vars tm =</span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff">do mmap &lt;- scGetModuleMap sc</span>
<span class="lineno">  224 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scTypeOf sc tm</span>
<span class="lineno">  225 </span><span class="spaces">     </span><span class="istickedoff">case evalSharedTerm <span class="nottickedoff">mmap</span> mempty <span class="nottickedoff">mempty</span> ty of</span>
<span class="lineno">  226 </span><span class="spaces">       </span><span class="istickedoff">TValue VBoolType -&gt;</span>
<span class="lineno">  227 </span><span class="spaces">         </span><span class="istickedoff">do p0 &lt;- scEqTrue sc tm</span>
<span class="lineno">  228 </span><span class="spaces">            </span><span class="istickedoff">Prop &lt;$&gt; scGeneralizeExts <span class="nottickedoff">sc</span> vars p0</span>
<span class="lineno">  229 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ unlines [ &quot;boolToProp: Term is not a boolean&quot;, showTerm tm, showTerm ty ]</span></span></span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- | Return the saw-core term that represents this proposition.
<span class="lineno">  232 </span>propToTerm :: SharedContext -&gt; Prop -&gt; IO Term
<span class="lineno">  233 </span><span class="decl"><span class="nottickedoff">propToTerm _sc (Prop tm) = pure tm</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>-- | Attempt to interpret a proposition as a rewrite rule.
<span class="lineno">  236 </span>propToRewriteRule :: SharedContext -&gt; Prop -&gt; Maybe a -&gt; IO (Maybe (RewriteRule a))
<span class="lineno">  237 </span><span class="decl"><span class="istickedoff">propToRewriteRule sc (Prop tm) = ruleOfProp sc tm</span></span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>-- | Attempt to split an if/then/else proposition.
<span class="lineno">  240 </span>--   If it succeeds to find a term like &quot;EqTrue (ite Bool b x y)&quot;,
<span class="lineno">  241 </span>--   then it returns two pairs consisting of &quot;(EqTrue b, EqTrue x)&quot;
<span class="lineno">  242 </span>--   and &quot;(EqTrue (not b), EqTrue y)&quot;
<span class="lineno">  243 </span>splitIte :: SharedContext -&gt; Prop -&gt; IO (Maybe ((Prop, Prop), (Prop, Prop)))
<span class="lineno">  244 </span><span class="decl"><span class="nottickedoff">splitIte sc (Prop p) =</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="nottickedoff">case (isGlobalDef &quot;Prelude.ite&quot; &lt;@&gt; return &lt;@&gt; return &lt;@&gt; return &lt;@&gt; return) =&lt;&lt; asEqTrue p of</span>
<span class="lineno">  246 </span><span class="spaces">     </span><span class="nottickedoff">Nothing -&gt; pure Nothing</span>
<span class="lineno">  247 </span><span class="spaces">     </span><span class="nottickedoff">Just (_ :*: _tp :*: b :*: x :*: y) -&gt; -- tp must be &quot;Bool&quot;</span>
<span class="lineno">  248 </span><span class="spaces">       </span><span class="nottickedoff">do nb  &lt;- scNot sc b</span>
<span class="lineno">  249 </span><span class="spaces">          </span><span class="nottickedoff">b'  &lt;- scEqTrue sc b</span>
<span class="lineno">  250 </span><span class="spaces">          </span><span class="nottickedoff">nb' &lt;- scEqTrue sc nb</span>
<span class="lineno">  251 </span><span class="spaces">          </span><span class="nottickedoff">x'  &lt;- scEqTrue sc x</span>
<span class="lineno">  252 </span><span class="spaces">          </span><span class="nottickedoff">y'  &lt;- scEqTrue sc y</span>
<span class="lineno">  253 </span><span class="spaces">          </span><span class="nottickedoff">return (Just ((Prop b', Prop x'), (Prop nb', Prop y')))</span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>-- | Attempt to split a conjunctive proposition into two propositions.
<span class="lineno">  256 </span>splitConj :: SharedContext -&gt; Prop -&gt; IO (Maybe (Prop, Prop))
<span class="lineno">  257 </span><span class="decl"><span class="nottickedoff">splitConj sc (Prop p) =</span>
<span class="lineno">  258 </span><span class="spaces">  </span><span class="nottickedoff">do let (vars, body) = asPiList p</span>
<span class="lineno">  259 </span><span class="spaces">     </span><span class="nottickedoff">case (isGlobalDef &quot;Prelude.and&quot; &lt;@&gt; return &lt;@&gt; return) =&lt;&lt; asEqTrue body of</span>
<span class="lineno">  260 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; pure Nothing</span>
<span class="lineno">  261 </span><span class="spaces">       </span><span class="nottickedoff">Just (_ :*: p1 :*: p2) -&gt;</span>
<span class="lineno">  262 </span><span class="spaces">         </span><span class="nottickedoff">do t1 &lt;- scPiList sc vars =&lt;&lt; scEqTrue sc p1</span>
<span class="lineno">  263 </span><span class="spaces">            </span><span class="nottickedoff">t2 &lt;- scPiList sc vars =&lt;&lt; scEqTrue sc p2</span>
<span class="lineno">  264 </span><span class="spaces">            </span><span class="nottickedoff">return (Just (Prop t1,Prop t2))</span></span>
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>-- | Attempt to split a disjunctive proposition into two propositions.
<span class="lineno">  267 </span>splitDisj :: SharedContext -&gt; Prop -&gt; IO (Maybe (Prop, Prop))
<span class="lineno">  268 </span><span class="decl"><span class="nottickedoff">splitDisj sc (Prop p) =</span>
<span class="lineno">  269 </span><span class="spaces">  </span><span class="nottickedoff">do let (vars, body) = asPiList p</span>
<span class="lineno">  270 </span><span class="spaces">     </span><span class="nottickedoff">case (isGlobalDef &quot;Prelude.or&quot; &lt;@&gt; return &lt;@&gt; return) =&lt;&lt; asEqTrue body of</span>
<span class="lineno">  271 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; pure Nothing</span>
<span class="lineno">  272 </span><span class="spaces">       </span><span class="nottickedoff">Just (_ :*: p1 :*: p2) -&gt;</span>
<span class="lineno">  273 </span><span class="spaces">         </span><span class="nottickedoff">do t1 &lt;- scPiList sc vars =&lt;&lt; scEqTrue sc p1</span>
<span class="lineno">  274 </span><span class="spaces">            </span><span class="nottickedoff">t2 &lt;- scPiList sc vars =&lt;&lt; scEqTrue sc p2</span>
<span class="lineno">  275 </span><span class="spaces">            </span><span class="nottickedoff">return (Just (Prop t1,Prop t2))</span></span>
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>-- | Attempt to split an implication into a hypothesis and a conclusion
<span class="lineno">  278 </span>splitImpl :: SharedContext -&gt; Prop -&gt; IO (Maybe (Prop, Prop))
<span class="lineno">  279 </span><span class="decl"><span class="nottickedoff">splitImpl sc (Prop p)</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="nottickedoff">| Just ( _ :*: h :*: c) &lt;- (isGlobalDef &quot;Prelude.implies&quot; &lt;@&gt; return &lt;@&gt; return) =&lt;&lt; asEqTrue p</span>
<span class="lineno">  281 </span><span class="spaces">  </span><span class="nottickedoff">= do h' &lt;- scEqTrue sc h</span>
<span class="lineno">  282 </span><span class="spaces">       </span><span class="nottickedoff">c' &lt;- scEqTrue sc c</span>
<span class="lineno">  283 </span><span class="spaces">       </span><span class="nottickedoff">return (Just (Prop h', Prop c'))</span>
<span class="lineno">  284 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="nottickedoff">-- or (not h) c == implies h c</span>
<span class="lineno">  286 </span><span class="spaces">  </span><span class="nottickedoff">| Just ( _ :*: (_ :*: h) :*: c) &lt;- (isGlobalDef &quot;Prelude.or&quot; &lt;@&gt; (isGlobalDef &quot;Prelude.not&quot; &lt;@&gt; return) &lt;@&gt; return) =&lt;&lt; asEqTrue p</span>
<span class="lineno">  287 </span><span class="spaces">  </span><span class="nottickedoff">= do h' &lt;- scEqTrue sc h</span>
<span class="lineno">  288 </span><span class="spaces">       </span><span class="nottickedoff">c' &lt;- scEqTrue sc c</span>
<span class="lineno">  289 </span><span class="spaces">       </span><span class="nottickedoff">return (Just (Prop h', Prop c'))</span>
<span class="lineno">  290 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  291 </span><span class="spaces">  </span><span class="nottickedoff">-- or c (not h) == implies h c</span>
<span class="lineno">  292 </span><span class="spaces">  </span><span class="nottickedoff">| Just ( _ :*: c :*: (_ :*: h)) &lt;- (isGlobalDef &quot;Prelude.or&quot; &lt;@&gt; return &lt;@&gt; (isGlobalDef &quot;Prelude.not&quot; &lt;@&gt; return)) =&lt;&lt; asEqTrue p</span>
<span class="lineno">  293 </span><span class="spaces">  </span><span class="nottickedoff">= do h' &lt;- scEqTrue sc h</span>
<span class="lineno">  294 </span><span class="spaces">       </span><span class="nottickedoff">c' &lt;- scEqTrue sc c</span>
<span class="lineno">  295 </span><span class="spaces">       </span><span class="nottickedoff">return (Just (Prop h', Prop c'))</span>
<span class="lineno">  296 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  297 </span><span class="spaces">  </span><span class="nottickedoff">-- Handle the case of (H1 -&gt; H2), where H1 and H2 are in Prop</span>
<span class="lineno">  298 </span><span class="spaces">  </span><span class="nottickedoff">| Just (_nm, arg, c) &lt;- asPi p</span>
<span class="lineno">  299 </span><span class="spaces">  </span><span class="nottickedoff">, termIsClosed c -- make sure this is a nondependent Pi (AKA arrow type)</span>
<span class="lineno">  300 </span><span class="spaces">  </span><span class="nottickedoff">= termToMaybeProp sc arg &gt;&gt;= \case</span>
<span class="lineno">  301 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno">  302 </span><span class="spaces">      </span><span class="nottickedoff">Just h  -&gt; return (Just (h, Prop c))</span>
<span class="lineno">  303 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  304 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  305 </span><span class="spaces">  </span><span class="nottickedoff">= return Nothing</span></span>
<span class="lineno">  306 </span>
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>-- | Attempt to split a sequent into two subgoals. This will only work
<span class="lineno">  309 </span>--   on focused sequents. If the sequent is focused on a hypothesis,
<span class="lineno">  310 </span>--   the hypothesis must be a disjunction, if/then/else, or implication term.
<span class="lineno">  311 </span>--   If the sequent is focused on a conclusion, the conclusion must be
<span class="lineno">  312 </span>--   a conjunction or if/then/else.
<span class="lineno">  313 </span>--
<span class="lineno">  314 </span>--   If this process succeeds, then a proof of the two included sequents
<span class="lineno">  315 </span>--   should be sufficient to prove the input sequent.
<span class="lineno">  316 </span>splitSequent :: SharedContext -&gt; Sequent -&gt; IO (Maybe (Sequent, Sequent))
<span class="lineno">  317 </span><span class="decl"><span class="nottickedoff">splitSequent sc sqt =</span>
<span class="lineno">  318 </span><span class="spaces">  </span><span class="nottickedoff">case sqt of</span>
<span class="lineno">  319 </span><span class="spaces">    </span><span class="nottickedoff">ConclFocusedSequent hs (FB gs1 g gs2) -&gt;</span>
<span class="lineno">  320 </span><span class="spaces">      </span><span class="nottickedoff">splitConj sc g &gt;&gt;= \case</span>
<span class="lineno">  321 </span><span class="spaces">        </span><span class="nottickedoff">--     HS |- GS1, X, GS2</span>
<span class="lineno">  322 </span><span class="spaces">        </span><span class="nottickedoff">--     HS |- GS1, Y, GS2</span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="nottickedoff">--   --------------------------- (Conj-R)</span>
<span class="lineno">  324 </span><span class="spaces">        </span><span class="nottickedoff">--     HS |- GS1, X /\ Y, GS2</span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="nottickedoff">Just (x, y) -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">            </span><span class="nottickedoff">return (Just ( ConclFocusedSequent hs (FB gs1 x gs2)</span>
<span class="lineno">  327 </span><span class="spaces">                         </span><span class="nottickedoff">, ConclFocusedSequent hs (FB gs1 y gs2)</span>
<span class="lineno">  328 </span><span class="spaces">                         </span><span class="nottickedoff">))</span>
<span class="lineno">  329 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  330 </span><span class="spaces">          </span><span class="nottickedoff">splitIte sc g &gt;&gt;= \case</span>
<span class="lineno">  331 </span><span class="spaces">            </span><span class="nottickedoff">--     HS, B     |- GS1, X, GS2</span>
<span class="lineno">  332 </span><span class="spaces">            </span><span class="nottickedoff">--     HS, not B |- GS1, Y, GS2</span>
<span class="lineno">  333 </span><span class="spaces">            </span><span class="nottickedoff">--   -------------------------------------- (Ite-R)</span>
<span class="lineno">  334 </span><span class="spaces">            </span><span class="nottickedoff">--     HS |- GS1, if B then X else Y, GS2</span>
<span class="lineno">  335 </span><span class="spaces">            </span><span class="nottickedoff">Just ((b, x), (nb, y)) -&gt;</span>
<span class="lineno">  336 </span><span class="spaces">              </span><span class="nottickedoff">return (Just ( ConclFocusedSequent (hs ++ [b])  (FB gs1 x gs2)</span>
<span class="lineno">  337 </span><span class="spaces">                           </span><span class="nottickedoff">, ConclFocusedSequent (hs ++ [nb]) (FB gs1 y gs2)</span>
<span class="lineno">  338 </span><span class="spaces">                           </span><span class="nottickedoff">))</span>
<span class="lineno">  339 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno">  340 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="nottickedoff">HypFocusedSequent (FB hs1 h hs2) gs -&gt;</span>
<span class="lineno">  342 </span><span class="spaces">      </span><span class="nottickedoff">splitDisj sc h &gt;&gt;= \case</span>
<span class="lineno">  343 </span><span class="spaces">        </span><span class="nottickedoff">--     HS1, X, HS2 |- GS</span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="nottickedoff">--     HS1, Y, HS2 |- GS</span>
<span class="lineno">  345 </span><span class="spaces">        </span><span class="nottickedoff">--   --------------------------- (Disj-L)</span>
<span class="lineno">  346 </span><span class="spaces">        </span><span class="nottickedoff">--     HS1, X \/ Y, HS2 |- GS</span>
<span class="lineno">  347 </span><span class="spaces">        </span><span class="nottickedoff">Just (x, y) -&gt;</span>
<span class="lineno">  348 </span><span class="spaces">          </span><span class="nottickedoff">return (Just ( HypFocusedSequent (FB hs1 x hs2) gs</span>
<span class="lineno">  349 </span><span class="spaces">                       </span><span class="nottickedoff">, HypFocusedSequent (FB hs1 y hs2) gs</span>
<span class="lineno">  350 </span><span class="spaces">                       </span><span class="nottickedoff">))</span>
<span class="lineno">  351 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  352 </span><span class="spaces">          </span><span class="nottickedoff">--     HS1, X, HS2, B     |- GS</span>
<span class="lineno">  353 </span><span class="spaces">          </span><span class="nottickedoff">--     HS1, Y, HS2, not B |- GS</span>
<span class="lineno">  354 </span><span class="spaces">          </span><span class="nottickedoff">--   ------------------------------------- (Ite-L)</span>
<span class="lineno">  355 </span><span class="spaces">          </span><span class="nottickedoff">--     HS1, if B then X else Y, HS2 |- GS</span>
<span class="lineno">  356 </span><span class="spaces">          </span><span class="nottickedoff">splitIte sc h &gt;&gt;= \case</span>
<span class="lineno">  357 </span><span class="spaces">            </span><span class="nottickedoff">Just ((b,x), (nb, y)) -&gt;</span>
<span class="lineno">  358 </span><span class="spaces">              </span><span class="nottickedoff">return (Just ( HypFocusedSequent (FB hs1 x (hs2 ++ [b])) gs</span>
<span class="lineno">  359 </span><span class="spaces">                           </span><span class="nottickedoff">, HypFocusedSequent (FB hs1 y (hs2 ++ [nb])) gs</span>
<span class="lineno">  360 </span><span class="spaces">                           </span><span class="nottickedoff">))</span>
<span class="lineno">  361 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  362 </span><span class="spaces">              </span><span class="nottickedoff">--     HS1, Y, HS2        |- GS</span>
<span class="lineno">  363 </span><span class="spaces">              </span><span class="nottickedoff">--     HS1, X -&gt; Y, HS2   |- GS, X</span>
<span class="lineno">  364 </span><span class="spaces">              </span><span class="nottickedoff">--   ------------------------------ (Impl-L) AKA modus ponens</span>
<span class="lineno">  365 </span><span class="spaces">              </span><span class="nottickedoff">--     HS1, X -&gt; Y, HS2   |- GS</span>
<span class="lineno">  366 </span><span class="spaces">              </span><span class="nottickedoff">splitImpl sc h &gt;&gt;= \case</span>
<span class="lineno">  367 </span><span class="spaces">                </span><span class="nottickedoff">Just (x, y) -&gt;</span>
<span class="lineno">  368 </span><span class="spaces">                  </span><span class="nottickedoff">return (Just ( HypFocusedSequent (FB hs1 y hs2) gs</span>
<span class="lineno">  369 </span><span class="spaces">                               </span><span class="nottickedoff">, ConclFocusedSequent (hs1 ++ [h] ++ hs2) (FB gs x [])</span>
<span class="lineno">  370 </span><span class="spaces">                               </span><span class="nottickedoff">))</span>
<span class="lineno">  371 </span><span class="spaces">                </span><span class="nottickedoff">Nothing -&gt; return Nothing</span>
<span class="lineno">  372 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  373 </span><span class="spaces">    </span><span class="nottickedoff">UnfocusedSequent _ _ -&gt; return Nothing</span></span>
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>-- | Unfold all the constants appearing in the proposition
<span class="lineno">  376 </span>--   whose VarIndex is found in the given set.
<span class="lineno">  377 </span>unfoldProp :: SharedContext -&gt; Set VarIndex -&gt; Prop -&gt; IO Prop
<span class="lineno">  378 </span><span class="decl"><span class="istickedoff">unfoldProp sc unints (Prop tm) =</span>
<span class="lineno">  379 </span><span class="spaces">  </span><span class="istickedoff">do tm' &lt;- scUnfoldConstantSet sc True unints tm</span>
<span class="lineno">  380 </span><span class="spaces">     </span><span class="istickedoff">return (Prop tm')</span></span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>-- | Unfold one time all the fixpoint constants appearing in the proposition
<span class="lineno">  383 </span>-- whose VarIndex is found in the given set.
<span class="lineno">  384 </span>unfoldFixOnceProp :: SharedContext -&gt; Set VarIndex -&gt; Prop -&gt; IO Prop
<span class="lineno">  385 </span><span class="decl"><span class="istickedoff">unfoldFixOnceProp sc unints (Prop tm) =</span>
<span class="lineno">  386 </span><span class="spaces">  </span><span class="istickedoff">do tm' &lt;- scUnfoldOnceFixConstantSet sc True unints tm</span>
<span class="lineno">  387 </span><span class="spaces">     </span><span class="istickedoff">return (Prop tm')</span></span>
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>-- | Rewrite the proposition using the provided Simpset
<span class="lineno">  390 </span>simplifyProp :: Ord a =&gt; SharedContext -&gt; Simpset a -&gt; Prop -&gt; IO (Set a, Prop)
<span class="lineno">  391 </span><span class="decl"><span class="istickedoff">simplifyProp sc ss (Prop tm) =</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="istickedoff">do (a, tm') &lt;- rewriteSharedTerm sc ss tm</span>
<span class="lineno">  393 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">a</span>, Prop tm')</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>-- | Rewrite the propositions using the provided Simpset
<span class="lineno">  396 </span>simplifyProps :: Ord a =&gt; SharedContext -&gt; Simpset a -&gt; [Prop] -&gt; IO (Set a, [Prop])
<span class="lineno">  397 </span><span class="decl"><span class="nottickedoff">simplifyProps _sc _ss [] = return (mempty, [])</span>
<span class="lineno">  398 </span><span class="spaces"></span><span class="nottickedoff">simplifyProps sc ss (p:ps) =</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="nottickedoff">do (a, p')  &lt;- simplifyProp sc ss p</span>
<span class="lineno">  400 </span><span class="spaces">     </span><span class="nottickedoff">(b, ps') &lt;- simplifyProps sc ss ps</span>
<span class="lineno">  401 </span><span class="spaces">     </span><span class="nottickedoff">return (Set.union a b, p' : ps')</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>-- | Add hypotheses from the given sequent as rewrite rules
<span class="lineno">  404 </span>--   to the given simpset.
<span class="lineno">  405 </span>localHypSimpset :: SharedContext -&gt; Sequent -&gt; [Integer] -&gt; Simpset a -&gt; IO (Simpset a)
<span class="lineno">  406 </span><span class="decl"><span class="istickedoff">localHypSimpset sc sqt hs ss0 = Fold.foldlM <span class="nottickedoff">processHyp</span> ss0 nhyps</span>
<span class="lineno">  407 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  408 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  409 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">processHyp ss (n,h) =</span></span>
<span class="lineno">  410 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ruleOfProp sc (unProp h) Nothing &gt;&gt;= \case</span></span>
<span class="lineno">  411 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; fail $ &quot;Hypothesis &quot; ++ show n ++ &quot;cannot be used as a rewrite rule.&quot;</span></span>
<span class="lineno">  412 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just r  -&gt; return (addRule r ss)</span></span>
<span class="lineno">  413 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">nhyps = [ <span class="nottickedoff">(n,h)</span></span>
<span class="lineno">  415 </span><span class="spaces">            </span><span class="istickedoff">| (n,h) &lt;- zip [0..] hyps</span>
<span class="lineno">  416 </span><span class="spaces">            </span><span class="istickedoff">, <span class="nottickedoff">Set.member n hset</span></span>
<span class="lineno">  417 </span><span class="spaces">            </span><span class="istickedoff">]</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">RawSequent hyps _ = sequentToRawSequent sqt</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">hset = Set.fromList hs</span></span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>-- | Rewrite in the sequent using the provided Simpset
<span class="lineno">  422 </span>simplifySequent :: Ord a =&gt; SharedContext -&gt; Simpset a -&gt; Sequent -&gt; IO (Set a, Sequent)
<span class="lineno">  423 </span><span class="decl"><span class="istickedoff">simplifySequent sc ss (UnfocusedSequent hs gs) =</span>
<span class="lineno">  424 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do (a, hs') &lt;- simplifyProps sc ss hs</span></span>
<span class="lineno">  425 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">(b, gs') &lt;- simplifyProps sc ss gs</span></span>
<span class="lineno">  426 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">return (Set.union a b, UnfocusedSequent hs' gs')</span></span>
<span class="lineno">  427 </span><span class="spaces"></span><span class="istickedoff">simplifySequent sc ss (ConclFocusedSequent hs (FB gs1 g gs2)) =</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">do (a, g') &lt;- simplifyProp sc ss g</span>
<span class="lineno">  429 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">a</span>, ConclFocusedSequent hs (FB gs1 g' gs2))</span>
<span class="lineno">  430 </span><span class="spaces"></span><span class="istickedoff">simplifySequent sc ss (HypFocusedSequent (FB hs1 h hs2) gs) =</span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do (a, h') &lt;- simplifyProp sc ss h</span></span>
<span class="lineno">  432 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">return (a, HypFocusedSequent (FB hs1 h' hs2) gs)</span></span></span>
<span class="lineno">  433 </span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>hoistIfsInProp :: SharedContext -&gt; Prop -&gt; IO Prop
<span class="lineno">  436 </span><span class="decl"><span class="istickedoff">hoistIfsInProp sc p = do</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">(ecs, body) &lt;- unbindAndFreshenProp sc p</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="istickedoff">body' &lt;-</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff">case asEqTrue body of</span>
<span class="lineno">  440 </span><span class="spaces">      </span><span class="istickedoff">Just t -&gt; pure t</span>
<span class="lineno">  441 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;hoistIfsInProp: expected EqTrue&quot;</span></span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="istickedoff">t1 &lt;- hoistIfs sc body'</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">t2 &lt;- scEqTrue sc t1</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">t3 &lt;- scGeneralizeExts sc ecs t2</span>
<span class="lineno">  445 </span><span class="spaces">  </span><span class="istickedoff">return (Prop t3)</span></span>
<span class="lineno">  446 </span>
<span class="lineno">  447 </span>-- | Turn any leading Pi binders in the given prop into
<span class="lineno">  448 </span>--   fresh ExtCns values, being careful to ensure that
<span class="lineno">  449 </span>--   dependent types are properly substituted.
<span class="lineno">  450 </span>unbindAndFreshenProp :: SharedContext -&gt; Prop -&gt; IO ([ExtCns Term], Term)
<span class="lineno">  451 </span><span class="decl"><span class="istickedoff">unbindAndFreshenProp sc (Prop p0) = loop [] [] p0</span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">loop ecs vs p =</span>
<span class="lineno">  454 </span><span class="spaces">      </span><span class="istickedoff">case asPi p of</span>
<span class="lineno">  455 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  456 </span><span class="spaces">          </span><span class="istickedoff">case vs of</span>
<span class="lineno">  457 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; return ([], p)</span>
<span class="lineno">  458 </span><span class="spaces">            </span><span class="istickedoff">_  -&gt; do p' &lt;- instantiateVarList sc 0 vs p</span>
<span class="lineno">  459 </span><span class="spaces">                     </span><span class="istickedoff">return (reverse ecs, p')</span>
<span class="lineno">  460 </span><span class="spaces">        </span><span class="istickedoff">Just (nm, tp, tm) -&gt;</span>
<span class="lineno">  461 </span><span class="spaces">          </span><span class="istickedoff">do tp' &lt;- instantiateVarList sc 0 vs tp</span>
<span class="lineno">  462 </span><span class="spaces">             </span><span class="istickedoff">ec  &lt;- scFreshEC sc nm tp'</span>
<span class="lineno">  463 </span><span class="spaces">             </span><span class="istickedoff">v   &lt;- scExtCns sc ec</span>
<span class="lineno">  464 </span><span class="spaces">             </span><span class="istickedoff">loop (ec:ecs) (v:vs) tm</span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>-- | Evaluate the given proposition by round-tripping
<span class="lineno">  467 </span>--   through the What4 formula representation.  This will
<span class="lineno">  468 </span>--   perform a variety of simplifications and rewrites.
<span class="lineno">  469 </span>evalProp :: SharedContext -&gt; Bool -&gt; Set VarIndex -&gt; Prop -&gt; IO Prop
<span class="lineno">  470 </span><span class="decl"><span class="istickedoff">evalProp sc what4PushMuxOps unints p =</span>
<span class="lineno">  471 </span><span class="spaces">  </span><span class="istickedoff">do (ecs, body) &lt;- unbindAndFreshenProp sc p</span>
<span class="lineno">  472 </span><span class="spaces">     </span><span class="istickedoff">body' &lt;-</span>
<span class="lineno">  473 </span><span class="spaces">       </span><span class="istickedoff">case asEqTrue body of</span>
<span class="lineno">  474 </span><span class="spaces">         </span><span class="istickedoff">Just t -&gt; pure t</span>
<span class="lineno">  475 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail (&quot;goal_eval: expected EqTrue\n&quot; ++ scPrettyTerm defaultPPOpts (unProp p))</span></span>
<span class="lineno">  476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  477 </span><span class="spaces">     </span><span class="istickedoff">sym &lt;- Common.newSAWCoreExprBuilder sc what4PushMuxOps</span>
<span class="lineno">  478 </span><span class="spaces">     </span><span class="istickedoff">st &lt;- Common.sawCoreState sym</span>
<span class="lineno">  479 </span><span class="spaces">     </span><span class="istickedoff">(_names, (_mlabels, p')) &lt;- W4Sim.w4Eval sym st sc mempty unints body'</span>
<span class="lineno">  480 </span><span class="spaces">     </span><span class="istickedoff">t1 &lt;- W4Sim.toSC <span class="nottickedoff">sym</span> st p'</span>
<span class="lineno">  481 </span><span class="spaces">     </span><span class="istickedoff">t2 &lt;- scEqTrue sc t1</span>
<span class="lineno">  482 </span><span class="spaces">     </span><span class="istickedoff">-- turn the free variables we generated back into pi-bound variables</span>
<span class="lineno">  483 </span><span class="spaces">     </span><span class="istickedoff">t3 &lt;- scGeneralizeExts sc ecs t2</span>
<span class="lineno">  484 </span><span class="spaces">     </span><span class="istickedoff">return (Prop t3)</span></span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>-- | Perform beta normalization on the given proposition.
<span class="lineno">  487 </span>betaReduceProp :: SharedContext -&gt; Prop -&gt; IO Prop
<span class="lineno">  488 </span><span class="decl"><span class="nottickedoff">betaReduceProp sc (Prop tm) =</span>
<span class="lineno">  489 </span><span class="spaces">  </span><span class="nottickedoff">do tm' &lt;- betaNormalize sc tm</span>
<span class="lineno">  490 </span><span class="spaces">     </span><span class="nottickedoff">return (Prop tm')</span></span>
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>-- | Return the contant false proposition.
<span class="lineno">  493 </span>falseProp :: SharedContext -&gt; IO Prop
<span class="lineno">  494 </span><span class="decl"><span class="nottickedoff">falseProp sc = Prop &lt;$&gt; (scEqTrue sc =&lt;&lt; scApplyPrelude_False sc)</span></span>
<span class="lineno">  495 </span>
<span class="lineno">  496 </span>-- | Compute the shared-term size of the proposition.
<span class="lineno">  497 </span>propSize :: Prop -&gt; Integer
<span class="lineno">  498 </span><span class="decl"><span class="nottickedoff">propSize (Prop tm) = scSharedSize tm</span></span>
<span class="lineno">  499 </span>
<span class="lineno">  500 </span>trivialProofTerm :: SharedContext -&gt; Prop -&gt; IO (Either String Term)
<span class="lineno">  501 </span><span class="decl"><span class="istickedoff">trivialProofTerm sc (Prop p) = runExceptT (loop =&lt;&lt; lift (scWhnf sc p))</span>
<span class="lineno">  502 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">loop (asPi -&gt; Just (nm, tp, tm)) =</span>
<span class="lineno">  504 </span><span class="spaces">      </span><span class="istickedoff">do pf &lt;- loop =&lt;&lt; lift (scWhnf sc tm)</span>
<span class="lineno">  505 </span><span class="spaces">         </span><span class="istickedoff">lift $ scLambda sc nm tp pf</span>
<span class="lineno">  506 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff">loop (asEq -&gt; Just (tp, x, _y)) =</span>
<span class="lineno">  508 </span><span class="spaces">      </span><span class="istickedoff">-- NB, we don't check if x is convertable to y here, as that will</span>
<span class="lineno">  509 </span><span class="spaces">      </span><span class="istickedoff">-- be done later in @tacticTrivial@ during the type-checking step</span>
<span class="lineno">  510 </span><span class="spaces">      </span><span class="istickedoff">lift $ scCtorApp sc &quot;Prelude.Refl&quot; [tp, x]</span>
<span class="lineno">  511 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  512 </span><span class="spaces">    </span><span class="istickedoff">loop _ = <span class="nottickedoff">throwError $ unlines</span></span>
<span class="lineno">  513 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The trivial tactic can only prove quantified equalities, but&quot;</span></span>
<span class="lineno">  514 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given goal is not in the correct form.&quot;</span></span>
<span class="lineno">  515 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, showTerm p</span></span>
<span class="lineno">  516 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>normalizeProp :: SharedContext -&gt; ModuleMap -&gt; Set VarIndex -&gt; Prop -&gt; IO Prop
<span class="lineno">  519 </span><span class="decl"><span class="istickedoff">normalizeProp sc modmap opaqueSet (Prop tm) =</span>
<span class="lineno">  520 </span><span class="spaces">  </span><span class="istickedoff">do tm' &lt;- TM.normalizeSharedTerm sc modmap mempty <span class="nottickedoff">mempty</span> opaqueSet tm</span>
<span class="lineno">  521 </span><span class="spaces">     </span><span class="istickedoff">termToProp sc tm'</span></span>
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>-- | Pretty print the given proposition as a string.
<span class="lineno">  524 </span>prettyProp :: PPOpts -&gt; SAWNamingEnv -&gt; Prop -&gt; String
<span class="lineno">  525 </span><span class="decl"><span class="istickedoff">prettyProp opts nenv p = renderSawDoc opts (ppProp opts nenv p)</span></span>
<span class="lineno">  526 </span>
<span class="lineno">  527 </span>-- | Pretty print the given proposition as a @SawDoc@.
<span class="lineno">  528 </span>ppProp :: PPOpts -&gt; SAWNamingEnv -&gt; Prop -&gt; SawDoc
<span class="lineno">  529 </span><span class="decl"><span class="istickedoff">ppProp opts nenv (Prop tm) = ppTermWithNames opts nenv tm</span></span>
<span class="lineno">  530 </span>
<span class="lineno">  531 </span>-- TODO, I'd like to add metadata here
<span class="lineno">  532 </span>type SequentBranch = Prop
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>-- | The representation of either hypotheses or conclusions with a focus
<span class="lineno">  535 </span>--   point. A @FB xs y zs@ represents a collection of propositions
<span class="lineno">  536 </span>--   where @xs@ come before the focus point @y@, and @zs@ is the
<span class="lineno">  537 </span>--   collection of propositions following the focus point.
<span class="lineno">  538 </span>data FocusedBranch = FB ![SequentBranch] !SequentBranch ![SequentBranch]
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>-- | This datatype represents sequents in the style of Gentzen.  Sequents
<span class="lineno">  541 </span>--   are used to represent the intermediate states of a proof, and are the
<span class="lineno">  542 </span>--   primary objects manipulated by the proof tactic system.
<span class="lineno">  543 </span>--
<span class="lineno">  544 </span>--   A sequent essentially represents a logical claim which is in the process
<span class="lineno">  545 </span>--   of being proved.  A sequent has some (possibly 0) number of
<span class="lineno">  546 </span>--   &quot;hypotheses&quot; and some number (possibly 0) of &quot;conclusions&quot;. In mathematical
<span class="lineno">  547 </span>--   notation, the hypotheses are separated from the conclusions by a turnstile
<span class="lineno">  548 </span>--   character, and the individual hypotheses and conclusions are separated from
<span class="lineno">  549 </span>--   each other by a comma. So, a typical sequent may look like:
<span class="lineno">  550 </span>--
<span class="lineno">  551 </span>--      H1, H2, H3, |- C1, C2
<span class="lineno">  552 </span>--
<span class="lineno">  553 </span>--   The logical meaning of a sequent is that the conjunction of all the hypotheses
<span class="lineno">  554 </span>--   implies the disjunction of the conclusions. The multi-conclusion form
<span class="lineno">  555 </span>--   of sequent (as is presented here) is typical of a classical logic.
<span class="lineno">  556 </span>--
<span class="lineno">  557 </span>--   In a Gentzen-style proof system (such as the sequent calculus), the method by
<span class="lineno">  558 </span>--   which proof proceeds is to apply inference rules. Each rule applies to a goal
<span class="lineno">  559 </span>--   sequent (the thing to be proved) and has 0 or more subgoals that must be proved
<span class="lineno">  560 </span>--   to apply the rule. Part of a proof is completed when a rule is applied which has 0
<span class="lineno">  561 </span>--   subgoals. When doing proofs in SAW using the tactic system, there is a stack of
<span class="lineno">  562 </span>--   currently outstanding proof goals (each in the form of a sequent to be proved).
<span class="lineno">  563 </span>--   Executing a tactic will modify or apply a proof rule to the top goal on the stack;
<span class="lineno">  564 </span>--   if that subgoal is finished, then the next subgoal becomes active.
<span class="lineno">  565 </span>--   If applying a rule causes more than one subgoal to be generated, the remaining
<span class="lineno">  566 </span>--   ones are pushed onto the stack of goals to be proved. An entire proof is completed
<span class="lineno">  567 </span>--   when the stack of outstanding goals to prove is empty.
<span class="lineno">  568 </span>--
<span class="lineno">  569 </span>--   This particular presentation of sequents is a &quot;focused&quot; sequent calculus.
<span class="lineno">  570 </span>--   This means that a sequent may optionally have a focus on a particular
<span class="lineno">  571 </span>--   hypothesis or conclusion. Some manipulations of sequents require a focus
<span class="lineno">  572 </span>--   point to indicate where some manipulation should be carried out, and others
<span class="lineno">  573 </span>--   will apply in both focused or unfocused states.
<span class="lineno">  574 </span>data Sequent
<span class="lineno">  575 </span>  = -- | A sequent in the unfocused state
<span class="lineno">  576 </span>    UnfocusedSequent   ![SequentBranch] ![SequentBranch]
<span class="lineno">  577 </span>    -- | A sequent focused on a particular conclusion
<span class="lineno">  578 </span>  | ConclFocusedSequent ![SequentBranch] !FocusedBranch
<span class="lineno">  579 </span>    -- | A sequent focused on a particular hypothesis
<span class="lineno">  580 </span>  | HypFocusedSequent  !FocusedBranch   ![SequentBranch]
<span class="lineno">  581 </span>
<span class="lineno">  582 </span>-- | A RawSequent is a data-structure representing a sequent, but without
<span class="lineno">  583 </span>--   the ability to focus on a particular hypothesis or conclusion.
<span class="lineno">  584 </span>--
<span class="lineno">  585 </span>--   This data-structure is parametric in the type of propositions,
<span class="lineno">  586 </span>--   which enables some convenient patterns using traversals, etc.
<span class="lineno">  587 </span>data RawSequent a = RawSequent [a] [a]
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>instance <span class="decl"><span class="nottickedoff">Functor RawSequent</span></span> where
<span class="lineno">  590 </span>  <span class="decl"><span class="istickedoff">fmap f (RawSequent hs gs) = RawSequent (fmap <span class="nottickedoff">f</span> hs) (fmap f gs)</span></span>
<span class="lineno">  591 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable RawSequent</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> where
<span class="lineno">  592 </span>  <span class="decl"><span class="nottickedoff">foldMap f (RawSequent hs gs) = Fold.foldMap f (hs ++ gs)</span></span>
<span class="lineno">  593 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Traversable RawSequent</span></span></span></span></span></span> where
<span class="lineno">  594 </span>  <span class="decl"><span class="istickedoff">traverse f (RawSequent hs gs) = RawSequent &lt;$&gt; traverse <span class="nottickedoff">f</span> hs &lt;*&gt; traverse f gs</span></span>
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>sequentToRawSequent :: Sequent -&gt; RawSequent Prop
<span class="lineno">  597 </span><span class="decl"><span class="istickedoff">sequentToRawSequent sqt =</span>
<span class="lineno">  598 </span><span class="spaces">   </span><span class="istickedoff">case sqt of</span>
<span class="lineno">  599 </span><span class="spaces">     </span><span class="istickedoff">UnfocusedSequent   hs gs              -&gt; <span class="nottickedoff">RawSequent hs gs</span></span>
<span class="lineno">  600 </span><span class="spaces">     </span><span class="istickedoff">ConclFocusedSequent hs (FB gs1 g gs2) -&gt; RawSequent hs (gs1 ++ g : gs2)</span>
<span class="lineno">  601 </span><span class="spaces">     </span><span class="istickedoff">HypFocusedSequent  (FB hs1 h hs2) gs  -&gt; <span class="nottickedoff">RawSequent (hs1 ++ h : hs2) gs</span></span></span>
<span class="lineno">  602 </span>
<span class="lineno">  603 </span>unfocusSequent :: Sequent -&gt; Sequent
<span class="lineno">  604 </span><span class="decl"><span class="nottickedoff">unfocusSequent sqt = UnfocusedSequent hs gs</span>
<span class="lineno">  605 </span><span class="spaces">  </span><span class="nottickedoff">where RawSequent hs gs = sequentToRawSequent sqt</span></span>
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>focusOnConcl :: Integer -&gt; Sequent -&gt; Maybe Sequent
<span class="lineno">  608 </span><span class="decl"><span class="nottickedoff">focusOnConcl i sqt =</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="nottickedoff">let RawSequent hs gs = sequentToRawSequent sqt in</span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="nottickedoff">case genericSplitAt i gs of</span>
<span class="lineno">  611 </span><span class="spaces">      </span><span class="nottickedoff">(gs1, g:gs2) -&gt; Just (ConclFocusedSequent hs (FB gs1 g gs2))</span>
<span class="lineno">  612 </span><span class="spaces">      </span><span class="nottickedoff">(_  , [])    -&gt; Nothing</span></span>
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>focusOnHyp :: Integer -&gt; Sequent -&gt; Maybe Sequent
<span class="lineno">  615 </span><span class="decl"><span class="nottickedoff">focusOnHyp i sqt =</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="nottickedoff">let RawSequent hs gs = sequentToRawSequent sqt in</span>
<span class="lineno">  617 </span><span class="spaces">    </span><span class="nottickedoff">case genericSplitAt i hs of</span>
<span class="lineno">  618 </span><span class="spaces">      </span><span class="nottickedoff">(hs1,h:hs2) -&gt; Just (HypFocusedSequent (FB hs1 h hs2) gs)</span>
<span class="lineno">  619 </span><span class="spaces">      </span><span class="nottickedoff">(_  , [])   -&gt; Nothing</span></span>
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>sequentConstantSet :: Sequent -&gt; Map VarIndex (NameInfo, Term, Maybe Term)
<span class="lineno">  622 </span><span class="decl"><span class="nottickedoff">sequentConstantSet sqt = foldr (\p m -&gt; Map.union (getConstantSet (unProp p)) m) mempty (hs++gs)</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  624 </span><span class="spaces">    </span><span class="nottickedoff">RawSequent hs gs = sequentToRawSequent sqt</span></span>
<span class="lineno">  625 </span>
<span class="lineno">  626 </span>convertibleProps :: SharedContext -&gt; [Prop] -&gt; [Prop] -&gt; IO Bool
<span class="lineno">  627 </span><span class="decl"><span class="nottickedoff">convertibleProps _sc [] [] = return True</span>
<span class="lineno">  628 </span><span class="spaces"></span><span class="nottickedoff">convertibleProps sc (p1:ps1) (p2:ps2) =</span>
<span class="lineno">  629 </span><span class="spaces">  </span><span class="nottickedoff">do ok1 &lt;- scConvertible sc True (unProp p1) (unProp p2)</span>
<span class="lineno">  630 </span><span class="spaces">     </span><span class="nottickedoff">ok2 &lt;- convertibleProps sc ps1 ps2</span>
<span class="lineno">  631 </span><span class="spaces">     </span><span class="nottickedoff">return (ok1 &amp;&amp; ok2)</span>
<span class="lineno">  632 </span><span class="spaces"></span><span class="nottickedoff">convertibleProps _sc _ _ = return False</span></span>
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>convertibleSequents :: SharedContext -&gt; Sequent -&gt; Sequent -&gt; IO Bool
<span class="lineno">  635 </span><span class="decl"><span class="nottickedoff">convertibleSequents sc sqt1 sqt2 =</span>
<span class="lineno">  636 </span><span class="spaces">  </span><span class="nottickedoff">do ok1 &lt;- convertibleProps sc hs1 hs2</span>
<span class="lineno">  637 </span><span class="spaces">     </span><span class="nottickedoff">ok2 &lt;- convertibleProps sc gs1 gs2</span>
<span class="lineno">  638 </span><span class="spaces">     </span><span class="nottickedoff">return (ok1 &amp;&amp; ok2)</span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  640 </span><span class="spaces">    </span><span class="nottickedoff">RawSequent hs1 gs1 = sequentToRawSequent sqt1</span>
<span class="lineno">  641 </span><span class="spaces">    </span><span class="nottickedoff">RawSequent hs2 gs2 = sequentToRawSequent sqt2</span></span>
<span class="lineno">  642 </span>
<span class="lineno">  643 </span>
<span class="lineno">  644 </span>-- | A helper data structure for working with sequents when a focus
<span class="lineno">  645 </span>--   point is expected. When a conclusion or hypothesis is focused,
<span class="lineno">  646 </span>--   return the focused proposition; and return a function which
<span class="lineno">  647 </span>--   allows building a new sequent by replacing the proposition under
<span class="lineno">  648 </span>--   focus.
<span class="lineno">  649 </span>data SequentState
<span class="lineno">  650 </span>  = Unfocused
<span class="lineno">  651 </span>  | ConclFocus Prop (Prop -&gt; Sequent)
<span class="lineno">  652 </span>  | HypFocus   Prop (Prop -&gt; Sequent)
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>-- | Build a sequent with the given proposition as the
<span class="lineno">  655 </span>--   only conclusion, and place it under focus.
<span class="lineno">  656 </span>propToSequent :: Prop -&gt; Sequent
<span class="lineno">  657 </span><span class="decl"><span class="istickedoff">propToSequent p = ConclFocusedSequent [] (FB [] p [])</span></span>
<span class="lineno">  658 </span>
<span class="lineno">  659 </span>-- | Give in a collection of boolean terms, construct a sequent
<span class="lineno">  660 </span>--   with corresponding hypotheses and conclusions.  If there
<span class="lineno">  661 </span>--   is exactly one conclusion term, put it under focus.
<span class="lineno">  662 </span>booleansToSequent :: SharedContext -&gt; [Term] -&gt; [Term] -&gt; IO Sequent
<span class="lineno">  663 </span><span class="decl"><span class="nottickedoff">booleansToSequent sc hs gs =</span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="nottickedoff">do hs' &lt;- mapM (boolToProp sc []) hs</span>
<span class="lineno">  665 </span><span class="spaces">     </span><span class="nottickedoff">gs' &lt;- mapM (boolToProp sc []) gs</span>
<span class="lineno">  666 </span><span class="spaces">     </span><span class="nottickedoff">case gs' of</span>
<span class="lineno">  667 </span><span class="spaces">       </span><span class="nottickedoff">[g] -&gt; return (ConclFocusedSequent hs' (FB [] g []))</span>
<span class="lineno">  668 </span><span class="spaces">       </span><span class="nottickedoff">_   -&gt; return (UnfocusedSequent hs' gs')</span></span>
<span class="lineno">  669 </span>
<span class="lineno">  670 </span>-- | Given a sequent, render its semantics as a proposition.
<span class="lineno">  671 </span>--
<span class="lineno">  672 </span>--   Currently this can only handle sequents with 0 or 1 conclusion
<span class="lineno">  673 </span>--   (this is not a fundamental limitation, but we need a Prop-level disjunction
<span class="lineno">  674 </span>--   in SAWCore to fix this).
<span class="lineno">  675 </span>--
<span class="lineno">  676 </span>--   Given a sequent like @H1, H2 ..., Hn |- C@, this will build a corresponding
<span class="lineno">  677 </span>--   proposition @H1 -&gt; H2 -&gt; ... Hn -&gt; C@. If the list of conclusions is empty,
<span class="lineno">  678 </span>--   the proposition will be @H1 -&gt; H2 -&gt; ... Hn -&gt; False@.
<span class="lineno">  679 </span>sequentToProp :: SharedContext -&gt; Sequent -&gt; IO Prop
<span class="lineno">  680 </span><span class="decl"><span class="nottickedoff">sequentToProp sc sqt =</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="nottickedoff">do let RawSequent hs gs = sequentToRawSequent sqt</span>
<span class="lineno">  682 </span><span class="spaces">     </span><span class="nottickedoff">case gs of</span>
<span class="lineno">  683 </span><span class="spaces">       </span><span class="nottickedoff">[]  -&gt; do g &lt;- boolToProp sc [] =&lt;&lt; scBool sc False</span>
<span class="lineno">  684 </span><span class="spaces">                 </span><span class="nottickedoff">loop hs g</span>
<span class="lineno">  685 </span><span class="spaces">       </span><span class="nottickedoff">[g] -&gt; loop hs g</span>
<span class="lineno">  686 </span><span class="spaces">              </span><span class="nottickedoff">-- TODO, we should add a prop-level disjunction to the SAWCore prelude</span>
<span class="lineno">  687 </span><span class="spaces">       </span><span class="nottickedoff">_   -&gt; fail &quot;seqentToProp: cannot handle multi-conclusion sequents&quot;</span>
<span class="lineno">  688 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  689 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  690 </span><span class="spaces">   </span><span class="nottickedoff">loop [] g = return g</span>
<span class="lineno">  691 </span><span class="spaces">   </span><span class="nottickedoff">loop (h:hs) g =</span>
<span class="lineno">  692 </span><span class="spaces">     </span><span class="nottickedoff">do g' &lt;- loop hs g</span>
<span class="lineno">  693 </span><span class="spaces">        </span><span class="nottickedoff">Prop &lt;$&gt; scFun sc (unProp h) (unProp g')</span></span>
<span class="lineno">  694 </span>
<span class="lineno">  695 </span>-- | Pretty print the given proposition as a string.
<span class="lineno">  696 </span>prettySequent :: PPOpts -&gt; SAWNamingEnv -&gt; Sequent -&gt; String
<span class="lineno">  697 </span><span class="decl"><span class="istickedoff">prettySequent opts nenv sqt = renderSawDoc opts (ppSequent opts nenv sqt)</span></span>
<span class="lineno">  698 </span>
<span class="lineno">  699 </span>-- | Pretty print the given proposition as a @SawDoc@.
<span class="lineno">  700 </span>ppSequent :: PPOpts -&gt; SAWNamingEnv -&gt; Sequent -&gt; SawDoc
<span class="lineno">  701 </span><span class="decl"><span class="istickedoff">ppSequent opts nenv sqt =</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="istickedoff">ppTermContainerWithNames</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">(ppRawSequent <span class="nottickedoff">sqt</span>)</span>
<span class="lineno">  704 </span><span class="spaces">    </span><span class="istickedoff">opts</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">nenv</span>
<span class="lineno">  706 </span><span class="spaces">    </span><span class="istickedoff">(fmap unProp (sequentToRawSequent sqt))</span></span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>ppRawSequent :: Sequent -&gt; RawSequent SawDoc -&gt; SawDoc
<span class="lineno">  709 </span><span class="decl"><span class="istickedoff">ppRawSequent _sqt (RawSequent [] [g]) = g</span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff">ppRawSequent sqt (RawSequent hs gs)  =</span>
<span class="lineno">  711 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">align (vcat (map ppHyp (zip [0..] hs) ++ turnstile ++ map ppConcl (zip [0..] gs)))</span></span>
<span class="lineno">  712 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  713 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">turnstile  = [ pretty (take 40 (repeat '=')) ]</span></span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">focused doc = &quot;&lt;&lt;&quot; &lt;&gt; doc &lt;&gt; &quot;&gt;&gt;&quot;</span></span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ppHyp (i, tm)</span></span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">| HypFocusedSequent (FB hs1 _h _hs2) _gs &lt;- sqt</span></span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, length hs1 == i</span></span>
<span class="lineno">  718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">= focused (&quot;H&quot; &lt;&gt; pretty i) &lt;+&gt; tm</span></span>
<span class="lineno">  719 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">| otherwise</span></span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">= &quot;H&quot; &lt;&gt; pretty i &lt;&gt; &quot;:&quot; &lt;+&gt; tm</span></span>
<span class="lineno">  722 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ppConcl (i, tm)</span></span>
<span class="lineno">  724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">| ConclFocusedSequent _hs (FB gs1 _g _gs2) &lt;- sqt</span></span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, length gs1 == i</span></span>
<span class="lineno">  726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">= focused (&quot;C&quot; &lt;&gt; pretty i) &lt;+&gt; tm</span></span>
<span class="lineno">  727 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">| otherwise</span></span>
<span class="lineno">  729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">= &quot;C&quot; &lt;&gt; pretty i &lt;&gt; &quot;:&quot; &lt;+&gt; tm</span></span></span>
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>-- | A datatype for representing finte or cofinite sets.
<span class="lineno">  733 </span>data CofinSet a
<span class="lineno">  734 </span>  = -- | A whitelist represents exactly the values in the given set
<span class="lineno">  735 </span>    WhiteList (Set a)
<span class="lineno">  736 </span>    -- | A blacklist represents all the values NOT found in the given set.
<span class="lineno">  737 </span>  | BlackList (Set a)
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>-- | Test for membership in a finite/cofinite set
<span class="lineno">  740 </span>cofinSetMember :: Ord a =&gt; a -&gt; CofinSet a -&gt; Bool
<span class="lineno">  741 </span><span class="decl"><span class="nottickedoff">cofinSetMember a (WhiteList xs) = Set.member a xs</span>
<span class="lineno">  742 </span><span class="spaces"></span><span class="nottickedoff">cofinSetMember a (BlackList xs) = not (Set.member a xs)</span></span>
<span class="lineno">  743 </span>
<span class="lineno">  744 </span>-- | Given a set of positions, filter the given list
<span class="lineno">  745 </span>--   so that it retains just those values that are in
<span class="lineno">  746 </span>--   positions contained in the set.  The given integer
<span class="lineno">  747 </span>--   indicates what position to start counting at.
<span class="lineno">  748 </span>filterPosList :: CofinSet Integer -&gt; Integer -&gt; [a] -&gt; [a]
<span class="lineno">  749 </span><span class="decl"><span class="nottickedoff">filterPosList pss start xs = map snd $ filter f $ zip [start..] xs</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  751 </span><span class="spaces">    </span><span class="nottickedoff">f (i,_) = cofinSetMember i pss</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>-- | Given a set of positions, filter the given focused branch
<span class="lineno">  754 </span>--   and retain just those positions in the set.
<span class="lineno">  755 </span>--   If the given branch was focused and the focus point was retained,
<span class="lineno">  756 </span>--   return a @Right@ value with the new focused branch.  If the
<span class="lineno">  757 </span>--   given branch was unfocused to start, or of the focused point
<span class="lineno">  758 </span>--   was removed, return a @Left@ value with a bare list.
<span class="lineno">  759 </span>filterFocusedList :: CofinSet Integer -&gt; FocusedBranch -&gt; Either [SequentBranch] FocusedBranch
<span class="lineno">  760 </span><span class="decl"><span class="nottickedoff">filterFocusedList pss (FB xs1 x xs2) =</span>
<span class="lineno">  761 </span><span class="spaces">   </span><span class="nottickedoff">if cofinSetMember idx pss then</span>
<span class="lineno">  762 </span><span class="spaces">     </span><span class="nottickedoff">Right (FB xs1' x xs2')</span>
<span class="lineno">  763 </span><span class="spaces">   </span><span class="nottickedoff">else</span>
<span class="lineno">  764 </span><span class="spaces">     </span><span class="nottickedoff">Left (xs1' ++ xs2')</span>
<span class="lineno">  765 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  766 </span><span class="spaces">    </span><span class="nottickedoff">idx  = genericLength xs1</span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="nottickedoff">xs1' = filterPosList pss 0 xs1</span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="nottickedoff">xs2' = filterPosList pss (idx+1) xs2</span></span>
<span class="lineno">  769 </span>
<span class="lineno">  770 </span>-- | Filter the list of hypotheses in a sequent, retaining
<span class="lineno">  771 </span>--   only those in the given set.
<span class="lineno">  772 </span>filterHyps :: CofinSet Integer -&gt; Sequent -&gt; Sequent
<span class="lineno">  773 </span><span class="decl"><span class="nottickedoff">filterHyps pss (UnfocusedSequent hs gs) =</span>
<span class="lineno">  774 </span><span class="spaces">  </span><span class="nottickedoff">UnfocusedSequent (filterPosList pss 0 hs) gs</span>
<span class="lineno">  775 </span><span class="spaces"></span><span class="nottickedoff">filterHyps pss (ConclFocusedSequent hs gs) =</span>
<span class="lineno">  776 </span><span class="spaces">  </span><span class="nottickedoff">ConclFocusedSequent (filterPosList pss 0 hs) gs</span>
<span class="lineno">  777 </span><span class="spaces"></span><span class="nottickedoff">filterHyps pss (HypFocusedSequent hs gs) =</span>
<span class="lineno">  778 </span><span class="spaces">  </span><span class="nottickedoff">case filterFocusedList pss hs of</span>
<span class="lineno">  779 </span><span class="spaces">    </span><span class="nottickedoff">Left  hs' -&gt; UnfocusedSequent hs' gs</span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="nottickedoff">Right hs' -&gt; HypFocusedSequent hs' gs</span></span>
<span class="lineno">  781 </span>
<span class="lineno">  782 </span>-- | Filter the list of conclusions in a sequent, retaining
<span class="lineno">  783 </span>--   only those in the given set.
<span class="lineno">  784 </span>filterConcls :: CofinSet Integer -&gt; Sequent -&gt; Sequent
<span class="lineno">  785 </span><span class="decl"><span class="nottickedoff">filterConcls pss (UnfocusedSequent hs gs) =</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="nottickedoff">UnfocusedSequent hs (filterPosList pss 0 gs)</span>
<span class="lineno">  787 </span><span class="spaces"></span><span class="nottickedoff">filterConcls pss (HypFocusedSequent hs gs) =</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="nottickedoff">HypFocusedSequent hs (filterPosList pss 0 gs)</span>
<span class="lineno">  789 </span><span class="spaces"></span><span class="nottickedoff">filterConcls pss (ConclFocusedSequent hs gs) =</span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="nottickedoff">case filterFocusedList pss gs of</span>
<span class="lineno">  791 </span><span class="spaces">    </span><span class="nottickedoff">Left  gs' -&gt; UnfocusedSequent hs gs'</span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="nottickedoff">Right gs' -&gt; ConclFocusedSequent hs gs'</span></span>
<span class="lineno">  793 </span>
<span class="lineno">  794 </span>-- | Add a new hypothesis to the list of hypotheses in a sequent
<span class="lineno">  795 </span>addHypothesis :: Prop -&gt; Sequent -&gt; Sequent
<span class="lineno">  796 </span><span class="decl"><span class="istickedoff">addHypothesis p (UnfocusedSequent hs gs)   = <span class="nottickedoff">UnfocusedSequent (hs ++ [p]) gs</span></span>
<span class="lineno">  797 </span><span class="spaces"></span><span class="istickedoff">addHypothesis p (ConclFocusedSequent hs gs) = ConclFocusedSequent (hs ++ [p]) gs</span>
<span class="lineno">  798 </span><span class="spaces"></span><span class="istickedoff">addHypothesis p (HypFocusedSequent (FB hs1 h hs2) gs) = <span class="nottickedoff">HypFocusedSequent (FB hs1 h (hs2++[p])) gs</span></span></span>
<span class="lineno">  799 </span>
<span class="lineno">  800 </span>-- | Add a new conclusion to the end of the conclusion list and focus on it
<span class="lineno">  801 </span>addNewFocusedConcl :: Prop -&gt; Sequent -&gt; Sequent
<span class="lineno">  802 </span><span class="decl"><span class="istickedoff">addNewFocusedConcl p sqt =</span>
<span class="lineno">  803 </span><span class="spaces">  </span><span class="istickedoff">let RawSequent hs gs = sequentToRawSequent sqt</span>
<span class="lineno">  804 </span><span class="spaces">   </span><span class="istickedoff">in ConclFocusedSequent hs (FB gs p [])</span></span>
<span class="lineno">  805 </span>
<span class="lineno">  806 </span>-- | If the sequent is focused, return the prop under focus,
<span class="lineno">  807 </span>--   together with its index value.
<span class="lineno">  808 </span>--   A @Left@ value indicates a hypothesis under focus, and
<span class="lineno">  809 </span>--   a @Right@ value is a conclusion under focus.
<span class="lineno">  810 </span>sequentGetFocus :: Sequent -&gt; Maybe (Either (Integer,Prop) (Integer, Prop))
<span class="lineno">  811 </span><span class="decl"><span class="nottickedoff">sequentGetFocus (UnfocusedSequent _ _) =</span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="nottickedoff">Nothing</span>
<span class="lineno">  813 </span><span class="spaces"></span><span class="nottickedoff">sequentGetFocus (HypFocusedSequent (FB hs1 h _) _)  =</span>
<span class="lineno">  814 </span><span class="spaces">  </span><span class="nottickedoff">Just (Left (genericLength hs1, h))</span>
<span class="lineno">  815 </span><span class="spaces"></span><span class="nottickedoff">sequentGetFocus (ConclFocusedSequent _ (FB gs1 g _)) =</span>
<span class="lineno">  816 </span><span class="spaces">  </span><span class="nottickedoff">Just (Right (genericLength gs1, g))</span></span>
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>sequentState :: Sequent -&gt; SequentState
<span class="lineno">  819 </span><span class="decl"><span class="istickedoff">sequentState (UnfocusedSequent _ _) = <span class="nottickedoff">Unfocused</span></span>
<span class="lineno">  820 </span><span class="spaces"></span><span class="istickedoff">sequentState (ConclFocusedSequent hs (FB gs1 g gs2)) =</span>
<span class="lineno">  821 </span><span class="spaces">  </span><span class="istickedoff">ConclFocus g (\g' -&gt; ConclFocusedSequent hs (FB gs1 g' gs2))</span>
<span class="lineno">  822 </span><span class="spaces"></span><span class="istickedoff">sequentState (HypFocusedSequent (FB hs1 h hs2) gs) =</span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">HypFocus h (\h' -&gt; HypFocusedSequent (FB hs1 h' hs2) gs)</span></span></span>
<span class="lineno">  824 </span>
<span class="lineno">  825 </span>sequentSharedSize :: Sequent -&gt; Integer
<span class="lineno">  826 </span><span class="decl"><span class="istickedoff">sequentSharedSize sqt = scSharedSizeMany (map unProp (hs ++ gs))</span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  828 </span><span class="spaces">   </span><span class="istickedoff">RawSequent hs gs = sequentToRawSequent sqt</span></span>
<span class="lineno">  829 </span>
<span class="lineno">  830 </span>sequentTreeSize :: Sequent -&gt; Integer
<span class="lineno">  831 </span><span class="decl"><span class="nottickedoff">sequentTreeSize sqt = scTreeSizeMany (map unProp (hs ++ gs))</span>
<span class="lineno">  832 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  833 </span><span class="spaces">   </span><span class="nottickedoff">RawSequent hs gs = sequentToRawSequent sqt</span></span>
<span class="lineno">  834 </span>
<span class="lineno">  835 </span>-- | Given an operation on propositions, apply the operation to the sequent.
<span class="lineno">  836 </span>--   If the sequent is focused, apply the operation just to the focused
<span class="lineno">  837 </span>--   hypothesis or conclusion. If the sequent is unfocused, apply the operation
<span class="lineno">  838 </span>--   to all the hypotheses and conclusions in the sequent.
<span class="lineno">  839 </span>traverseSequentWithFocus :: Applicative m =&gt; (Prop -&gt; m Prop) -&gt; Sequent -&gt; m Sequent
<span class="lineno">  840 </span><span class="decl"><span class="istickedoff">traverseSequentWithFocus f (UnfocusedSequent hs gs) =</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">UnfocusedSequent &lt;$&gt; traverse f hs &lt;*&gt; traverse f gs</span></span>
<span class="lineno">  842 </span><span class="spaces"></span><span class="istickedoff">traverseSequentWithFocus f (ConclFocusedSequent hs (FB gs1 g gs2)) =</span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="istickedoff">(\g' -&gt; ConclFocusedSequent hs (FB gs1 g' gs2)) &lt;$&gt; f g</span>
<span class="lineno">  844 </span><span class="spaces"></span><span class="istickedoff">traverseSequentWithFocus f (HypFocusedSequent (FB hs1 h hs2) gs) =</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">(\h' -&gt; HypFocusedSequent (FB hs1 h' hs2) gs) &lt;$&gt; f h</span></span></span>
<span class="lineno">  846 </span>
<span class="lineno">  847 </span>-- | Given an operation on propositions, apply the operation to all the
<span class="lineno">  848 </span>--   hypotheses and conclusions in the sequent.
<span class="lineno">  849 </span>traverseSequent :: Applicative m =&gt; (Prop -&gt; m Prop) -&gt; Sequent -&gt; m Sequent
<span class="lineno">  850 </span><span class="decl"><span class="nottickedoff">traverseSequent f (UnfocusedSequent hs gs) =</span>
<span class="lineno">  851 </span><span class="spaces">  </span><span class="nottickedoff">UnfocusedSequent &lt;$&gt; traverse f hs &lt;*&gt; traverse f gs</span>
<span class="lineno">  852 </span><span class="spaces"></span><span class="nottickedoff">traverseSequent f (ConclFocusedSequent hs (FB gs1 g gs2)) =</span>
<span class="lineno">  853 </span><span class="spaces">  </span><span class="nottickedoff">ConclFocusedSequent &lt;$&gt;</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="nottickedoff">(traverse f hs) &lt;*&gt;</span>
<span class="lineno">  855 </span><span class="spaces">    </span><span class="nottickedoff">( FB &lt;$&gt; traverse f gs1 &lt;*&gt; f g &lt;*&gt; traverse f gs2)</span>
<span class="lineno">  856 </span><span class="spaces"></span><span class="nottickedoff">traverseSequent f (HypFocusedSequent (FB hs1 h hs2) gs) =</span>
<span class="lineno">  857 </span><span class="spaces">  </span><span class="nottickedoff">HypFocusedSequent &lt;$&gt;</span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="nottickedoff">( FB &lt;$&gt; traverse f hs1 &lt;*&gt; f h &lt;*&gt; traverse f hs2) &lt;*&gt;</span>
<span class="lineno">  859 </span><span class="spaces">    </span><span class="nottickedoff">(traverse f gs)</span></span>
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>-- | Typecheck a sequent.  This will typecheck all the terms
<span class="lineno">  862 </span>--   appearing in the sequent to ensure that they are propositions.
<span class="lineno">  863 </span>--   This check should always succeed, unless some programming
<span class="lineno">  864 </span>--   mistake has allowed us to build an ill-typed sequent.
<span class="lineno">  865 </span>checkSequent :: SharedContext -&gt; PPOpts -&gt; Sequent -&gt; IO ()
<span class="lineno">  866 </span><span class="decl"><span class="istickedoff">checkSequent sc ppOpts (UnfocusedSequent hs gs) =</span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do forM_ hs (checkProp sc ppOpts)</span></span>
<span class="lineno">  868 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">forM_ gs (checkProp sc ppOpts)</span></span>
<span class="lineno">  869 </span><span class="spaces"></span><span class="istickedoff">checkSequent sc ppOpts (ConclFocusedSequent hs (FB gs1 g gs2)) =</span>
<span class="lineno">  870 </span><span class="spaces">  </span><span class="istickedoff">do forM_ hs <span class="nottickedoff">(checkProp sc ppOpts)</span></span>
<span class="lineno">  871 </span><span class="spaces">     </span><span class="istickedoff">forM_ gs1 <span class="nottickedoff">(checkProp sc ppOpts)</span></span>
<span class="lineno">  872 </span><span class="spaces">     </span><span class="istickedoff">checkProp sc <span class="nottickedoff">ppOpts</span> g</span>
<span class="lineno">  873 </span><span class="spaces">     </span><span class="istickedoff">forM_ gs2 <span class="nottickedoff">(checkProp sc ppOpts)</span></span>
<span class="lineno">  874 </span><span class="spaces"></span><span class="istickedoff">checkSequent sc ppOpts (HypFocusedSequent (FB hs1 h hs2) gs) =</span>
<span class="lineno">  875 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do forM_ hs1 (checkProp sc ppOpts)</span></span>
<span class="lineno">  876 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">checkProp sc ppOpts h</span></span>
<span class="lineno">  877 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">forM_ hs2 (checkProp sc ppOpts)</span></span>
<span class="lineno">  878 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">forM_ gs  (checkProp sc ppOpts)</span></span></span>
<span class="lineno">  879 </span>
<span class="lineno">  880 </span>-- | Check that a @Prop@ value is actually a proposition.
<span class="lineno">  881 </span>--   This check should always succeed, unless some programming
<span class="lineno">  882 </span>--   mistake has allowed us to build an ill-typed Prop.
<span class="lineno">  883 </span>checkProp :: SharedContext -&gt; PPOpts -&gt; Prop -&gt; IO ()
<span class="lineno">  884 </span><span class="decl"><span class="istickedoff">checkProp sc ppOpts (Prop t) =</span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- TC.scTypeCheckError sc t</span>
<span class="lineno">  886 </span><span class="spaces">     </span><span class="istickedoff">case asSort ty of</span>
<span class="lineno">  887 </span><span class="spaces">        </span><span class="istickedoff">Just s | <span class="tickonlytrue">s == propSort</span> -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  888 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ unlines [&quot;Term is not a prop!&quot;, scPrettyTerm ppOpts t, scPrettyTerm ppOpts ty]</span></span></span>
<span class="lineno">  889 </span>
<span class="lineno">  890 </span>type TheoremNonce = Nonce GlobalNonceGenerator Theorem
<span class="lineno">  891 </span>
<span class="lineno">  892 </span>-- | A theorem is a proposition which has been wrapped in a
<span class="lineno">  893 </span>--   constructor indicating that it has already been proved,
<span class="lineno">  894 </span>--   and contains @Evidence@ for its truth.
<span class="lineno">  895 </span>data Theorem =
<span class="lineno">  896 </span>  Theorem
<span class="lineno">  897 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">_thmProp</span></span></span> :: Prop
<span class="lineno">  898 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmStats</span></span></span> :: SolverStats
<span class="lineno">  899 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmEvidence</span></span></span> :: Evidence
<span class="lineno">  900 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmLocation</span></span></span> :: Pos
<span class="lineno">  901 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmProgramLoc</span></span></span> :: Maybe ProgramLoc
<span class="lineno">  902 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmReason</span></span></span>   :: Text
<span class="lineno">  903 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmNonce</span></span></span>    :: TheoremNonce
<span class="lineno">  904 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmDepends</span></span></span>  :: Set TheoremNonce
<span class="lineno">  905 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmElapsedTime</span></span></span> :: NominalDiffTime
<span class="lineno">  906 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_thmSummary</span></span></span> :: TheoremSummary
<span class="lineno">  907 </span>  } -- INVARIANT: the provided evidence is valid for the included proposition
<span class="lineno">  908 </span>
<span class="lineno">  909 </span>-- | A theorem database is intended to track theorems that may be used
<span class="lineno">  910 </span>--   in the proof of later theorems or verification conditions. This is
<span class="lineno">  911 </span>--   ultimately used to produce verification summaries, which capture
<span class="lineno">  912 </span>--   the dependency graph between theorems and verifications.
<span class="lineno">  913 </span>data TheoremDB =
<span class="lineno">  914 </span>  TheoremDB
<span class="lineno">  915 </span>  -- TODO, maybe this should be a summary or something simpler?
<span class="lineno">  916 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">theoremMap</span></span></span> :: Map.Map TheoremNonce Theorem
<span class="lineno">  917 </span>  }
<span class="lineno">  918 </span>
<span class="lineno">  919 </span>emptyTheoremDB :: TheoremDB
<span class="lineno">  920 </span><span class="decl"><span class="istickedoff">emptyTheoremDB = TheoremDB <span class="nottickedoff">mempty</span></span></span>
<span class="lineno">  921 </span>
<span class="lineno">  922 </span>recordTheorem :: TheoremDB -&gt; Theorem -&gt; TheoremDB
<span class="lineno">  923 </span><span class="decl"><span class="istickedoff">recordTheorem db thm@Theorem{ _thmNonce = n } = TheoremDB <span class="nottickedoff">(Map.insert n thm (theoremMap db))</span></span></span>
<span class="lineno">  924 </span>
<span class="lineno">  925 </span>-- | Given a set of root values, find all the theorems in this database
<span class="lineno">  926 </span>--   that are transitively used in the proofs of those theorems.
<span class="lineno">  927 </span>--   This function will panic if any of the roots or reachable theorems
<span class="lineno">  928 </span>--   are not found in the database.
<span class="lineno">  929 </span>reachableTheorems :: TheoremDB -&gt; Set TheoremNonce -&gt; Map TheoremNonce Theorem
<span class="lineno">  930 </span><span class="decl"><span class="nottickedoff">reachableTheorems db roots = Set.foldl' (loop (theoremMap db)) mempty roots</span>
<span class="lineno">  931 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  932 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  933 </span><span class="spaces">   </span><span class="nottickedoff">loop m visited curr</span>
<span class="lineno">  934 </span><span class="spaces">     </span><span class="nottickedoff">| Just _ &lt;- Map.lookup curr visited = visited</span>
<span class="lineno">  935 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  936 </span><span class="spaces">     </span><span class="nottickedoff">| Just thm &lt;- Map.lookup curr m =</span>
<span class="lineno">  937 </span><span class="spaces">         </span><span class="nottickedoff">Set.foldl' (loop m)</span>
<span class="lineno">  938 </span><span class="spaces">            </span><span class="nottickedoff">(Map.insert curr thm visited)</span>
<span class="lineno">  939 </span><span class="spaces">            </span><span class="nottickedoff">(thmDepends thm)</span>
<span class="lineno">  940 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  941 </span><span class="spaces">     </span><span class="nottickedoff">| otherwise =</span>
<span class="lineno">  942 </span><span class="spaces">         </span><span class="nottickedoff">panic &quot;reachableTheorems&quot; [&quot;Could not find theorem with identifier&quot;, show (indexValue curr)]</span></span>
<span class="lineno">  943 </span>
<span class="lineno">  944 </span>
<span class="lineno">  945 </span>-- | Check that the purported theorem is valid.
<span class="lineno">  946 </span>--
<span class="lineno">  947 </span>--   This validates that the included evidence actually supports
<span class="lineno">  948 </span>--   the proposition.  Note, however, this validation procedure
<span class="lineno">  949 </span>--   does not totally guarantee the theorem is true, as it does
<span class="lineno">  950 </span>--   not verify any solver-provided proofs, and it accepts admitted
<span class="lineno">  951 </span>--   propositions and quickchecked propositions as valid.
<span class="lineno">  952 </span>validateTheorem :: SharedContext -&gt; Bool -&gt; TheoremDB -&gt; Theorem -&gt; IO ()
<span class="lineno">  953 </span>
<span class="lineno">  954 </span><span class="decl"><span class="nottickedoff">validateTheorem sc what4PushMuxOps db Theorem{ _thmProp = p, _thmEvidence = e, _thmDepends = thmDep } =</span>
<span class="lineno">  955 </span><span class="spaces">   </span><span class="nottickedoff">do let hyps = Map.keysSet (theoremMap db)</span>
<span class="lineno">  956 </span><span class="spaces">      </span><span class="nottickedoff">(deps,_) &lt;- checkEvidence sc what4PushMuxOps e p</span>
<span class="lineno">  957 </span><span class="spaces">      </span><span class="nottickedoff">unless (Set.isSubsetOf deps thmDep &amp;&amp; Set.isSubsetOf thmDep hyps)</span>
<span class="lineno">  958 </span><span class="spaces">             </span><span class="nottickedoff">(fail $ unlines [&quot;Theorem failed to declare its dependencies correctly&quot;</span>
<span class="lineno">  959 </span><span class="spaces">                             </span><span class="nottickedoff">, show deps, show thmDep ])</span></span>
<span class="lineno">  960 </span>
<span class="lineno">  961 </span>data TheoremSummary
<span class="lineno">  962 </span>  = AdmittedTheorem Text
<span class="lineno">  963 </span>  | TestedTheorem Integer
<span class="lineno">  964 </span>  | ProvedTheorem SolverStats
<span class="lineno">  965 </span>
<span class="lineno">  966 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Monoid TheoremSummary</span></span></span></span> where
<span class="lineno">  967 </span>  <span class="decl"><span class="nottickedoff">mempty = ProvedTheorem mempty</span></span>
<span class="lineno">  968 </span>
<span class="lineno">  969 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Semigroup TheoremSummary</span></span></span></span> where
<span class="lineno">  970 </span>  <span class="decl"><span class="nottickedoff">AdmittedTheorem msg &lt;&gt; _ = AdmittedTheorem msg</span>
<span class="lineno">  971 </span><span class="spaces">  </span><span class="nottickedoff">_ &lt;&gt; AdmittedTheorem msg = AdmittedTheorem msg</span>
<span class="lineno">  972 </span><span class="spaces">  </span><span class="nottickedoff">TestedTheorem x &lt;&gt; TestedTheorem y = TestedTheorem (min x y)</span>
<span class="lineno">  973 </span><span class="spaces">  </span><span class="nottickedoff">TestedTheorem x &lt;&gt; _ = TestedTheorem x</span>
<span class="lineno">  974 </span><span class="spaces">  </span><span class="nottickedoff">_ &lt;&gt; TestedTheorem y = TestedTheorem y</span>
<span class="lineno">  975 </span><span class="spaces">  </span><span class="nottickedoff">ProvedTheorem s1 &lt;&gt; ProvedTheorem s2 = ProvedTheorem (s1&lt;&gt;s2)</span></span>
<span class="lineno">  976 </span>
<span class="lineno">  977 </span>
<span class="lineno">  978 </span>-- | This datatype records evidence for the truth of a proposition.
<span class="lineno">  979 </span>data Evidence
<span class="lineno">  980 </span>  = -- | The given term provides a direct programs-as-proofs witness
<span class="lineno">  981 </span>    --   for the truth of its type (qua proposition). This will
<span class="lineno">  982 </span>    --   succeed when applied to sequent with a conclusion focus whose
<span class="lineno">  983 </span>    --   statement matches the type of the given term.
<span class="lineno">  984 </span>    ProofTerm !Term
<span class="lineno">  985 </span>
<span class="lineno">  986 </span>    -- | This type of evidence is produced when the given sequent
<span class="lineno">  987 </span>    --   has been dispatched to a solver which has indicated that it
<span class="lineno">  988 </span>    --   was able to prove the sequent. The included @SolverStats@
<span class="lineno">  989 </span>    --   give some details about the solver run.
<span class="lineno">  990 </span>  | SolverEvidence !SolverStats !Sequent
<span class="lineno">  991 </span>
<span class="lineno">  992 </span>    -- | This type of evidence is produced when the given sequent
<span class="lineno">  993 </span>    --   has been randomly tested against input vectors in the style
<span class="lineno">  994 </span>    --   of quickcheck. The included number is the number of successfully
<span class="lineno">  995 </span>    --   passed test vectors.
<span class="lineno">  996 </span>  | QuickcheckEvidence !Integer !Sequent
<span class="lineno">  997 </span>
<span class="lineno">  998 </span>    -- | This type of evidence is produced when the given sequent
<span class="lineno">  999 </span>    --   has been explicitly assumed without other evidence, at the
<span class="lineno"> 1000 </span>    --   user's direction.
<span class="lineno"> 1001 </span>  | Admitted !Text !Pos !Sequent
<span class="lineno"> 1002 </span>
<span class="lineno"> 1003 </span>    -- | This type of evidence is produced when the focused hypothesis
<span class="lineno"> 1004 </span>    --   or conclusion proposition can be deconstructed (along a
<span class="lineno"> 1005 </span>    --   conjunction, disjunction, if/then/else or implication) into
<span class="lineno"> 1006 </span>    --   two subgoals, each of which is supported by the included
<span class="lineno"> 1007 </span>    --   evidence.
<span class="lineno"> 1008 </span>  | SplitEvidence !Evidence !Evidence
<span class="lineno"> 1009 </span>
<span class="lineno"> 1010 </span>    -- | This type of evidence is produced when a previously-proved
<span class="lineno"> 1011 </span>    --   theorem is applied via backward reasoning to prove a focused
<span class="lineno"> 1012 </span>    --   conclusion.  Pi-quantified variables of the theorem may be
<span class="lineno"> 1013 </span>    --   specialized either by giving an explicit @Term@ to
<span class="lineno"> 1014 </span>    --   instantiate the variable, or by giving @Evidence@ for @Prop@
<span class="lineno"> 1015 </span>    --   hypotheses. After specializing the given @Theorem@ the
<span class="lineno"> 1016 </span>    --   result must match the current focued conclusion.
<span class="lineno"> 1017 </span>  | ApplyEvidence !Theorem ![Either Term Evidence]
<span class="lineno"> 1018 </span>
<span class="lineno"> 1019 </span>    -- | This type of evidence is produced when a local hypothesis is
<span class="lineno"> 1020 </span>    --   applied via backward reasoning to prove a focused conclusion.
<span class="lineno"> 1021 </span>    --   Pi-quantified variables of the hypothesis may be specialized
<span class="lineno"> 1022 </span>    --   either by giving an explicit @Term@ to instantiate the
<span class="lineno"> 1023 </span>    --   variable, or by giving @Evidence@ for @Prop@ hypotheses.
<span class="lineno"> 1024 </span>    --   After specializing the given @Theorem@ the result must match
<span class="lineno"> 1025 </span>    --   the current focused conclusion.
<span class="lineno"> 1026 </span>  | ApplyHypEvidence Integer ![Either Term Evidence]
<span class="lineno"> 1027 </span>
<span class="lineno"> 1028 </span>    -- | This type of evidence is used to prove a universally-quantified conclusion.
<span class="lineno"> 1029 </span>    --   The included ExtCns should be a fresh variable used to instantiate the
<span class="lineno"> 1030 </span>    --   quantified proposition.
<span class="lineno"> 1031 </span>  | IntroEvidence !(ExtCns Term) !Evidence
<span class="lineno"> 1032 </span>
<span class="lineno"> 1033 </span>    -- | This type of evidence is used to apply the &quot;cut rule&quot; of sequent calculus.
<span class="lineno"> 1034 </span>    --   The given proposition is added to the hypothesis list in the first
<span class="lineno"> 1035 </span>    --   derivation, and into the conclusion list in the second, where it is focused.
<span class="lineno"> 1036 </span>  | CutEvidence !Prop !Evidence !Evidence
<span class="lineno"> 1037 </span>
<span class="lineno"> 1038 </span>    -- | This type of evidence is used to modify a sequent to prove via
<span class="lineno"> 1039 </span>    --   rewriting. The sequent is rewritten by the given
<span class="lineno"> 1040 </span>    --   simpset; then the provided evidence is used to check the
<span class="lineno"> 1041 </span>    --   modified sequent. The list of integers indicate local
<span class="lineno"> 1042 </span>    --   hypotheses that should also be treated as rewrite rules.
<span class="lineno"> 1043 </span>  | RewriteEvidence ![Integer] !(Simpset TheoremNonce) !Evidence
<span class="lineno"> 1044 </span>
<span class="lineno"> 1045 </span>    -- | This type of evidence is used to modify a sequent via unfolding
<span class="lineno"> 1046 </span>    --   constant definitions.  The sequent is modified by unfolding
<span class="lineno"> 1047 </span>    --   constants identified via the given set of @VarIndex@; then the provided
<span class="lineno"> 1048 </span>    --   evidence is used to check the modified sequent.
<span class="lineno"> 1049 </span>  | UnfoldEvidence !(Set VarIndex) !Evidence
<span class="lineno"> 1050 </span>
<span class="lineno"> 1051 </span>    -- | This type of evidence is used to modify a sequent via unfolding fixpoint
<span class="lineno"> 1052 </span>    --   constant definitions once.  The sequent is modified by unfolding
<span class="lineno"> 1053 </span>    --   constants identified via the given set of @VarIndex@; then the provided
<span class="lineno"> 1054 </span>    --   evidence is used to check the modified sequent.
<span class="lineno"> 1055 </span>  | UnfoldFixOnceEvidence !(Set VarIndex) !Evidence
<span class="lineno"> 1056 </span>
<span class="lineno"> 1057 </span>    -- | This type of evidence is used to modify a sequent via evaluation
<span class="lineno"> 1058 </span>    --   into the the What4 formula representation. During evaluation, the
<span class="lineno"> 1059 </span>    --   constants identified by the given set of @VarIndex@ are held
<span class="lineno"> 1060 </span>    --   uninterpreted (i.e., will not be unfolded).  Then, the provided
<span class="lineno"> 1061 </span>    --   evidence is use to check the modified sequent.
<span class="lineno"> 1062 </span>  | EvalEvidence !(Set VarIndex) !Evidence
<span class="lineno"> 1063 </span>
<span class="lineno"> 1064 </span>    -- | This type of evidence is used to modify a focused part of the sequent.
<span class="lineno"> 1065 </span>    --   The modified sequent should be equivalent up to conversion.
<span class="lineno"> 1066 </span>  | ConversionEvidence !Sequent !Evidence
<span class="lineno"> 1067 </span>
<span class="lineno"> 1068 </span>    -- | This type of evidence is used to modify a goal to prove by applying
<span class="lineno"> 1069 </span>    --   'hoistIfsInProp'.
<span class="lineno"> 1070 </span>  | HoistIfsEvidence !Evidence
<span class="lineno"> 1071 </span>
<span class="lineno"> 1072 </span>    -- | Change the state of the sequent in some &quot;structural&quot; way. This
<span class="lineno"> 1073 </span>    --   can involve changing focus, reordering or applying weakening rules.
<span class="lineno"> 1074 </span>  | StructuralEvidence !Sequent !Evidence
<span class="lineno"> 1075 </span>
<span class="lineno"> 1076 </span>    -- | Change the state of the sequent in some way that is governed by
<span class="lineno"> 1077 </span>    --   the &quot;reversible&quot; L/R rules of the sequent calculus, e.g.,
<span class="lineno"> 1078 </span>    --   conjunctions in hypotheses can be split into multiple hypotheses,
<span class="lineno"> 1079 </span>    --   negated conclusions become positive hypotheses, etc.
<span class="lineno"> 1080 </span>  | NormalizeSequentEvidence !Sequent !Evidence
<span class="lineno"> 1081 </span>
<span class="lineno"> 1082 </span>    -- | Change the state of the sequent by invoking the term evaluator
<span class="lineno"> 1083 </span>    --   on the focused sequent branch (or all branches, if unfocused).
<span class="lineno"> 1084 </span>    --   Treat the given variable indexes as opaque.
<span class="lineno"> 1085 </span>  | NormalizePropEvidence !(Set VarIndex) !Evidence
<span class="lineno"> 1086 </span>
<span class="lineno"> 1087 </span>    -- | This type of evidence is used when the current sequent, after
<span class="lineno"> 1088 </span>    --   applying structural rules, is an instance of the basic
<span class="lineno"> 1089 </span>    --   sequent calculus axiom, which connects a hypothesis to a conclusion.
<span class="lineno"> 1090 </span>  | AxiomEvidence
<span class="lineno"> 1091 </span>
<span class="lineno"> 1092 </span>    -- | Evidence generated by running the @mrsolver@ tactic.
<span class="lineno"> 1093 </span>    --   FIXME: Add a @[Evidence]@ here when MRSolver is updated to support
<span class="lineno"> 1094 </span>    --   returning unsolved goals.
<span class="lineno"> 1095 </span>  | MrSolverEvidence !(MRSolver.MREvidence TheoremNonce)
<span class="lineno"> 1096 </span>
<span class="lineno"> 1097 </span>-- | The the proposition proved by a given theorem.
<span class="lineno"> 1098 </span>thmProp :: Theorem -&gt; Prop
<span class="lineno"> 1099 </span><span class="decl"><span class="istickedoff">thmProp Theorem{ _thmProp = p } = p</span></span>
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>-- | Retrieve any solver stats from the proved theorem.
<span class="lineno"> 1102 </span>thmStats :: Theorem -&gt; SolverStats
<span class="lineno"> 1103 </span><span class="decl"><span class="nottickedoff">thmStats Theorem{ _thmStats = stats } = stats</span></span>
<span class="lineno"> 1104 </span>
<span class="lineno"> 1105 </span>-- | Retrive the evidence associated with this theorem.
<span class="lineno"> 1106 </span>thmEvidence :: Theorem -&gt; Evidence
<span class="lineno"> 1107 </span><span class="decl"><span class="nottickedoff">thmEvidence Theorem{ _thmEvidence = e } = e</span></span>
<span class="lineno"> 1108 </span>
<span class="lineno"> 1109 </span>-- | The SAW source location that generated this theorem
<span class="lineno"> 1110 </span>thmLocation :: Theorem -&gt; Pos
<span class="lineno"> 1111 </span><span class="decl"><span class="nottickedoff">thmLocation Theorem{ _thmLocation = loc } = loc</span></span>
<span class="lineno"> 1112 </span>
<span class="lineno"> 1113 </span>-- | The program location (if any) of the program under
<span class="lineno"> 1114 </span>--   verification giving rise to this theorem
<span class="lineno"> 1115 </span>thmProgramLoc :: Theorem -&gt; Maybe ProgramLoc
<span class="lineno"> 1116 </span><span class="decl"><span class="nottickedoff">thmProgramLoc Theorem{ _thmProgramLoc = ploc } = ploc</span></span>
<span class="lineno"> 1117 </span>
<span class="lineno"> 1118 </span>-- | Describes the reason this theorem was generated
<span class="lineno"> 1119 </span>thmReason :: Theorem -&gt; Text
<span class="lineno"> 1120 </span><span class="decl"><span class="nottickedoff">thmReason Theorem{ _thmReason = r } = r</span></span>
<span class="lineno"> 1121 </span>
<span class="lineno"> 1122 </span>-- | Returns a unique identifier for this theorem
<span class="lineno"> 1123 </span>thmNonce :: Theorem -&gt; TheoremNonce
<span class="lineno"> 1124 </span><span class="decl"><span class="istickedoff">thmNonce Theorem{ _thmNonce = n } = n</span></span>
<span class="lineno"> 1125 </span>
<span class="lineno"> 1126 </span>-- | Returns the set of theorem identifiers that this theorem depends on
<span class="lineno"> 1127 </span>thmDepends :: Theorem -&gt; Set TheoremNonce
<span class="lineno"> 1128 </span><span class="decl"><span class="nottickedoff">thmDepends Theorem { _thmDepends = s } = s</span></span>
<span class="lineno"> 1129 </span>
<span class="lineno"> 1130 </span>-- | Returns the amount of time elapsed during the proof of this theorem
<span class="lineno"> 1131 </span>thmElapsedTime :: Theorem -&gt; NominalDiffTime
<span class="lineno"> 1132 </span><span class="decl"><span class="nottickedoff">thmElapsedTime Theorem{ _thmElapsedTime = tm } = tm</span></span>
<span class="lineno"> 1133 </span>
<span class="lineno"> 1134 </span>thmSummary :: Theorem -&gt; TheoremSummary
<span class="lineno"> 1135 </span><span class="decl"><span class="nottickedoff">thmSummary Theorem { _thmSummary = sy } = sy</span></span>
<span class="lineno"> 1136 </span>
<span class="lineno"> 1137 </span>splitEvidence :: [Evidence] -&gt; IO Evidence
<span class="lineno"> 1138 </span><span class="decl"><span class="nottickedoff">splitEvidence [e1,e2] = pure (SplitEvidence e1 e2)</span>
<span class="lineno"> 1139 </span><span class="spaces"></span><span class="nottickedoff">splitEvidence _ = fail &quot;splitEvidence: expected two evidence values&quot;</span></span>
<span class="lineno"> 1140 </span>
<span class="lineno"> 1141 </span>introEvidence :: ExtCns Term -&gt; [Evidence] -&gt; IO Evidence
<span class="lineno"> 1142 </span><span class="decl"><span class="istickedoff">introEvidence x [e] = pure (IntroEvidence x e)</span>
<span class="lineno"> 1143 </span><span class="spaces"></span><span class="istickedoff">introEvidence _ _ = <span class="nottickedoff">fail &quot;introEvidence: expected one evidence value&quot;</span></span></span>
<span class="lineno"> 1144 </span>
<span class="lineno"> 1145 </span>cutEvidence :: Prop -&gt; [Evidence] -&gt; IO Evidence
<span class="lineno"> 1146 </span><span class="decl"><span class="nottickedoff">cutEvidence p [e1,e2] = pure (CutEvidence p e1 e2)</span>
<span class="lineno"> 1147 </span><span class="spaces"></span><span class="nottickedoff">cutEvidence _ _ = fail &quot;cutEvidence: expected two evidence values&quot;</span></span>
<span class="lineno"> 1148 </span>
<span class="lineno"> 1149 </span>insertEvidence :: Theorem -&gt; Prop -&gt; [Term] -&gt; [Evidence] -&gt; IO Evidence
<span class="lineno"> 1150 </span><span class="decl"><span class="istickedoff">insertEvidence thm h ts [e] = pure (CutEvidence h e (ApplyEvidence thm (map <span class="nottickedoff">Left</span> ts)))</span>
<span class="lineno"> 1151 </span><span class="spaces"></span><span class="istickedoff">insertEvidence _ _ _ _ = <span class="nottickedoff">fail &quot;insertEvidence: expected one evidence value&quot;</span></span></span>
<span class="lineno"> 1152 </span>
<span class="lineno"> 1153 </span>specializeHypEvidence :: Integer -&gt; Prop -&gt; [Term] -&gt; [Evidence] -&gt; IO Evidence
<span class="lineno"> 1154 </span><span class="decl"><span class="nottickedoff">specializeHypEvidence n h ts [e] = pure (CutEvidence h e (ApplyHypEvidence n (map Left ts)))</span>
<span class="lineno"> 1155 </span><span class="spaces"></span><span class="nottickedoff">specializeHypEvidence _ _ _ _ = fail &quot;specializeHypEvidence: expected one evidence value&quot;</span></span>
<span class="lineno"> 1156 </span>
<span class="lineno"> 1157 </span>structuralEvidence :: Sequent -&gt; Evidence -&gt; Evidence
<span class="lineno"> 1158 </span>-- If we apply some structural evidence to an already existing structural evidence, we can
<span class="lineno"> 1159 </span>-- just omit the new one because the checking procedure doesn't need the intermediate state.
<span class="lineno"> 1160 </span><span class="decl"><span class="nottickedoff">structuralEvidence _sqt (StructuralEvidence sqt' e) = StructuralEvidence sqt' e</span>
<span class="lineno"> 1161 </span><span class="spaces"></span><span class="nottickedoff">structuralEvidence sqt e = StructuralEvidence sqt e</span></span>
<span class="lineno"> 1162 </span>
<span class="lineno"> 1163 </span>-- | Construct a theorem directly via a proof term.
<span class="lineno"> 1164 </span>proofByTerm :: SharedContext -&gt; TheoremDB -&gt; Term -&gt; Pos -&gt; Text -&gt; IO (Theorem, TheoremDB)
<span class="lineno"> 1165 </span><span class="decl"><span class="nottickedoff">proofByTerm sc db prf loc rsn =</span>
<span class="lineno"> 1166 </span><span class="spaces">  </span><span class="nottickedoff">do ty &lt;- scTypeOf sc prf</span>
<span class="lineno"> 1167 </span><span class="spaces">     </span><span class="nottickedoff">p  &lt;- termToProp sc ty</span>
<span class="lineno"> 1168 </span><span class="spaces">     </span><span class="nottickedoff">n  &lt;- freshNonce globalNonceGenerator</span>
<span class="lineno"> 1169 </span><span class="spaces">     </span><span class="nottickedoff">let thm =</span>
<span class="lineno"> 1170 </span><span class="spaces">          </span><span class="nottickedoff">Theorem</span>
<span class="lineno"> 1171 </span><span class="spaces">          </span><span class="nottickedoff">{ _thmProp      = p</span>
<span class="lineno"> 1172 </span><span class="spaces">          </span><span class="nottickedoff">, _thmStats     = mempty</span>
<span class="lineno"> 1173 </span><span class="spaces">          </span><span class="nottickedoff">, _thmEvidence  = ProofTerm prf</span>
<span class="lineno"> 1174 </span><span class="spaces">          </span><span class="nottickedoff">, _thmLocation  = loc</span>
<span class="lineno"> 1175 </span><span class="spaces">          </span><span class="nottickedoff">, _thmProgramLoc = Nothing</span>
<span class="lineno"> 1176 </span><span class="spaces">          </span><span class="nottickedoff">, _thmReason    = rsn</span>
<span class="lineno"> 1177 </span><span class="spaces">          </span><span class="nottickedoff">, _thmNonce     = n</span>
<span class="lineno"> 1178 </span><span class="spaces">          </span><span class="nottickedoff">, _thmDepends   = mempty</span>
<span class="lineno"> 1179 </span><span class="spaces">          </span><span class="nottickedoff">, _thmElapsedTime = 0</span>
<span class="lineno"> 1180 </span><span class="spaces">          </span><span class="nottickedoff">, _thmSummary = ProvedTheorem mempty</span>
<span class="lineno"> 1181 </span><span class="spaces">          </span><span class="nottickedoff">}</span>
<span class="lineno"> 1182 </span><span class="spaces">     </span><span class="nottickedoff">let db' = recordTheorem db thm</span>
<span class="lineno"> 1183 </span><span class="spaces">     </span><span class="nottickedoff">pure (thm, db')</span></span>
<span class="lineno"> 1184 </span>
<span class="lineno"> 1185 </span>-- | Construct a theorem directly from a proposition and evidence
<span class="lineno"> 1186 </span>--   for that proposition.  The evidence will be validated to
<span class="lineno"> 1187 </span>--   check that it supports the given proposition; if not, an
<span class="lineno"> 1188 </span>--   error will be raised.
<span class="lineno"> 1189 </span>constructTheorem ::
<span class="lineno"> 1190 </span>  SharedContext -&gt;
<span class="lineno"> 1191 </span>  Bool -&gt;
<span class="lineno"> 1192 </span>  TheoremDB -&gt;
<span class="lineno"> 1193 </span>  Prop -&gt;
<span class="lineno"> 1194 </span>  Evidence -&gt;
<span class="lineno"> 1195 </span>  Pos -&gt;
<span class="lineno"> 1196 </span>  Maybe ProgramLoc -&gt;
<span class="lineno"> 1197 </span>  Text -&gt;
<span class="lineno"> 1198 </span>  NominalDiffTime -&gt;
<span class="lineno"> 1199 </span>  IO (Theorem, TheoremDB)
<span class="lineno"> 1200 </span><span class="decl"><span class="nottickedoff">constructTheorem sc what4PushMuxOps db p e loc ploc rsn elapsed =</span>
<span class="lineno"> 1201 </span><span class="spaces">  </span><span class="nottickedoff">do (deps,sy) &lt;- checkEvidence sc what4PushMuxOps e p</span>
<span class="lineno"> 1202 </span><span class="spaces">     </span><span class="nottickedoff">n  &lt;- freshNonce globalNonceGenerator</span>
<span class="lineno"> 1203 </span><span class="spaces">     </span><span class="nottickedoff">let thm =</span>
<span class="lineno"> 1204 </span><span class="spaces">          </span><span class="nottickedoff">Theorem</span>
<span class="lineno"> 1205 </span><span class="spaces">          </span><span class="nottickedoff">{ _thmProp  = p</span>
<span class="lineno"> 1206 </span><span class="spaces">          </span><span class="nottickedoff">, _thmStats = mempty</span>
<span class="lineno"> 1207 </span><span class="spaces">          </span><span class="nottickedoff">, _thmEvidence = e</span>
<span class="lineno"> 1208 </span><span class="spaces">          </span><span class="nottickedoff">, _thmLocation = loc</span>
<span class="lineno"> 1209 </span><span class="spaces">          </span><span class="nottickedoff">, _thmProgramLoc = ploc</span>
<span class="lineno"> 1210 </span><span class="spaces">          </span><span class="nottickedoff">, _thmReason   = rsn</span>
<span class="lineno"> 1211 </span><span class="spaces">          </span><span class="nottickedoff">, _thmNonce    = n</span>
<span class="lineno"> 1212 </span><span class="spaces">          </span><span class="nottickedoff">, _thmDepends  = deps</span>
<span class="lineno"> 1213 </span><span class="spaces">          </span><span class="nottickedoff">, _thmElapsedTime = elapsed</span>
<span class="lineno"> 1214 </span><span class="spaces">          </span><span class="nottickedoff">, _thmSummary  = sy</span>
<span class="lineno"> 1215 </span><span class="spaces">          </span><span class="nottickedoff">}</span>
<span class="lineno"> 1216 </span><span class="spaces">     </span><span class="nottickedoff">let db' = recordTheorem db thm</span>
<span class="lineno"> 1217 </span><span class="spaces">     </span><span class="nottickedoff">pure (thm, db')</span></span>
<span class="lineno"> 1218 </span>
<span class="lineno"> 1219 </span>
<span class="lineno"> 1220 </span>-- | Given a theorem with quantified variables, build a new theorem that
<span class="lineno"> 1221 </span>--   specializes the leading quantifiers with the given terms.
<span class="lineno"> 1222 </span>--   This will fail if the given terms to not match the quantifier structure
<span class="lineno"> 1223 </span>--   of the given theorem.
<span class="lineno"> 1224 </span>specializeTheorem :: SharedContext -&gt; Bool -&gt; TheoremDB -&gt; Pos -&gt; Text -&gt; Theorem -&gt; [Term] -&gt; IO (Theorem, TheoremDB)
<span class="lineno"> 1225 </span><span class="decl"><span class="nottickedoff">specializeTheorem _sc _what4PushMuxOps db _loc _rsn thm [] = return (thm, db)</span>
<span class="lineno"> 1226 </span><span class="spaces"></span><span class="nottickedoff">specializeTheorem sc what4PushMuxOps db loc rsn thm ts =</span>
<span class="lineno"> 1227 </span><span class="spaces">  </span><span class="nottickedoff">do res &lt;- specializeProp sc (_thmProp thm) ts</span>
<span class="lineno"> 1228 </span><span class="spaces">     </span><span class="nottickedoff">case res of</span>
<span class="lineno"> 1229 </span><span class="spaces">       </span><span class="nottickedoff">Left err -&gt; fail (unlines ([&quot;specialize_theorem: failed to specialize&quot;] ++ TC.prettyTCError err))</span>
<span class="lineno"> 1230 </span><span class="spaces">       </span><span class="nottickedoff">Right p' -&gt;</span>
<span class="lineno"> 1231 </span><span class="spaces">         </span><span class="nottickedoff">constructTheorem sc what4PushMuxOps db p' (ApplyEvidence thm (map Left ts)) loc Nothing rsn 0</span></span>
<span class="lineno"> 1232 </span>
<span class="lineno"> 1233 </span>specializeProp :: SharedContext -&gt; Prop -&gt; [Term] -&gt; IO (Either TC.TCError Prop)
<span class="lineno"> 1234 </span><span class="decl"><span class="istickedoff">specializeProp sc (Prop p0) ts0 = TC.runTCM (loop p0 ts0) <span class="nottickedoff">sc</span> <span class="nottickedoff">Nothing</span> <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1235 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno"> 1236 </span><span class="spaces">  </span><span class="istickedoff">loop p [] = return (Prop p)</span>
<span class="lineno"> 1237 </span><span class="spaces">  </span><span class="istickedoff">loop p (t:ts) =</span>
<span class="lineno"> 1238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">do prop &lt;- liftIO (scSort sc propSort)</span></span>
<span class="lineno"> 1239 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">t' &lt;- TC.typeInferComplete t</span></span>
<span class="lineno"> 1240 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">p' &lt;- TC.applyPiTyped (TC.NotFuncTypeInApp (TC.TypedTerm p prop) t') p t'</span></span>
<span class="lineno"> 1241 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">loop p' ts</span></span></span>
<span class="lineno"> 1242 </span>
<span class="lineno"> 1243 </span>-- | Admit the given theorem without evidence.
<span class="lineno"> 1244 </span>--   The provided message allows the user to
<span class="lineno"> 1245 </span>--   explain why this proposition is being admitted.
<span class="lineno"> 1246 </span>admitTheorem ::
<span class="lineno"> 1247 </span>  TheoremDB -&gt;
<span class="lineno"> 1248 </span>  Text -&gt;
<span class="lineno"> 1249 </span>  Prop -&gt;
<span class="lineno"> 1250 </span>  Pos -&gt;
<span class="lineno"> 1251 </span>  Text -&gt;
<span class="lineno"> 1252 </span>  IO (Theorem, TheoremDB)
<span class="lineno"> 1253 </span><span class="decl"><span class="istickedoff">admitTheorem db msg p loc rsn =</span>
<span class="lineno"> 1254 </span><span class="spaces">  </span><span class="istickedoff">do n  &lt;- freshNonce globalNonceGenerator</span>
<span class="lineno"> 1255 </span><span class="spaces">     </span><span class="istickedoff">let thm =</span>
<span class="lineno"> 1256 </span><span class="spaces">          </span><span class="istickedoff">Theorem</span>
<span class="lineno"> 1257 </span><span class="spaces">          </span><span class="istickedoff">{ _thmProp        = p</span>
<span class="lineno"> 1258 </span><span class="spaces">          </span><span class="istickedoff">, _thmStats       = <span class="nottickedoff">solverStats &quot;ADMITTED&quot; (propSize p)</span></span>
<span class="lineno"> 1259 </span><span class="spaces">          </span><span class="istickedoff">, _thmEvidence    = <span class="nottickedoff">Admitted msg loc (propToSequent p)</span></span>
<span class="lineno"> 1260 </span><span class="spaces">          </span><span class="istickedoff">, _thmLocation    = <span class="nottickedoff">loc</span></span>
<span class="lineno"> 1261 </span><span class="spaces">          </span><span class="istickedoff">, _thmProgramLoc  = <span class="nottickedoff">Nothing</span></span>
<span class="lineno"> 1262 </span><span class="spaces">          </span><span class="istickedoff">, _thmReason      = <span class="nottickedoff">rsn</span></span>
<span class="lineno"> 1263 </span><span class="spaces">          </span><span class="istickedoff">, _thmNonce       = <span class="nottickedoff">n</span></span>
<span class="lineno"> 1264 </span><span class="spaces">          </span><span class="istickedoff">, _thmDepends     = <span class="nottickedoff">mempty</span></span>
<span class="lineno"> 1265 </span><span class="spaces">          </span><span class="istickedoff">, _thmElapsedTime = <span class="nottickedoff">0</span></span>
<span class="lineno"> 1266 </span><span class="spaces">          </span><span class="istickedoff">, _thmSummary     = <span class="nottickedoff">AdmittedTheorem msg</span></span>
<span class="lineno"> 1267 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno"> 1268 </span><span class="spaces">     </span><span class="istickedoff">let db' = recordTheorem <span class="nottickedoff">db</span> thm</span>
<span class="lineno"> 1269 </span><span class="spaces">     </span><span class="istickedoff">pure (thm, db')</span></span>
<span class="lineno"> 1270 </span>
<span class="lineno"> 1271 </span>-- | Construct a theorem that an external solver has proved.
<span class="lineno"> 1272 </span>solverTheorem ::
<span class="lineno"> 1273 </span>  TheoremDB -&gt;
<span class="lineno"> 1274 </span>  Prop -&gt;
<span class="lineno"> 1275 </span>  SolverStats -&gt;
<span class="lineno"> 1276 </span>  Pos -&gt;
<span class="lineno"> 1277 </span>  Text -&gt;
<span class="lineno"> 1278 </span>  NominalDiffTime -&gt;
<span class="lineno"> 1279 </span>  IO (Theorem, TheoremDB)
<span class="lineno"> 1280 </span><span class="decl"><span class="nottickedoff">solverTheorem db p stats loc rsn elapsed =</span>
<span class="lineno"> 1281 </span><span class="spaces">  </span><span class="nottickedoff">do n  &lt;- freshNonce globalNonceGenerator</span>
<span class="lineno"> 1282 </span><span class="spaces">     </span><span class="nottickedoff">let thm =</span>
<span class="lineno"> 1283 </span><span class="spaces">          </span><span class="nottickedoff">Theorem</span>
<span class="lineno"> 1284 </span><span class="spaces">          </span><span class="nottickedoff">{ _thmProp      = p</span>
<span class="lineno"> 1285 </span><span class="spaces">          </span><span class="nottickedoff">, _thmStats     = stats</span>
<span class="lineno"> 1286 </span><span class="spaces">          </span><span class="nottickedoff">, _thmEvidence  = SolverEvidence stats (propToSequent p)</span>
<span class="lineno"> 1287 </span><span class="spaces">          </span><span class="nottickedoff">, _thmLocation  = loc</span>
<span class="lineno"> 1288 </span><span class="spaces">          </span><span class="nottickedoff">, _thmReason    = rsn</span>
<span class="lineno"> 1289 </span><span class="spaces">          </span><span class="nottickedoff">, _thmProgramLoc = Nothing</span>
<span class="lineno"> 1290 </span><span class="spaces">          </span><span class="nottickedoff">, _thmNonce     = n</span>
<span class="lineno"> 1291 </span><span class="spaces">          </span><span class="nottickedoff">, _thmDepends   = mempty</span>
<span class="lineno"> 1292 </span><span class="spaces">          </span><span class="nottickedoff">, _thmElapsedTime = elapsed</span>
<span class="lineno"> 1293 </span><span class="spaces">          </span><span class="nottickedoff">, _thmSummary = ProvedTheorem stats</span>
<span class="lineno"> 1294 </span><span class="spaces">          </span><span class="nottickedoff">}</span>
<span class="lineno"> 1295 </span><span class="spaces">     </span><span class="nottickedoff">let db' = recordTheorem db thm</span>
<span class="lineno"> 1296 </span><span class="spaces">     </span><span class="nottickedoff">pure (thm, db')</span></span>
<span class="lineno"> 1297 </span>
<span class="lineno"> 1298 </span>-- | A @ProofGoal@ contains a proposition to be proved, along with
<span class="lineno"> 1299 </span>-- some metadata.
<span class="lineno"> 1300 </span>data ProofGoal =
<span class="lineno"> 1301 </span>  ProofGoal
<span class="lineno"> 1302 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">goalNum</span></span></span>  :: Int
<span class="lineno"> 1303 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">goalType</span></span></span> :: String
<span class="lineno"> 1304 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">goalName</span></span></span> :: String
<span class="lineno"> 1305 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">goalLoc</span></span></span>  :: String
<span class="lineno"> 1306 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">goalDesc</span></span></span> :: String
<span class="lineno"> 1307 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">goalTags</span></span></span> :: Set String
<span class="lineno"> 1308 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">goalSequent</span></span></span> :: !Sequent
<span class="lineno"> 1309 </span>  }
<span class="lineno"> 1310 </span>
<span class="lineno"> 1311 </span>
<span class="lineno"> 1312 </span>data Quantification = Existential | Universal
<span class="lineno"> 1313 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 1314 </span>
<span class="lineno"> 1315 </span>
<span class="lineno"> 1316 </span>-- | Convert a term with a function type of any arity into a pi type.
<span class="lineno"> 1317 </span>-- Negate the term if the result type is @Bool@ and the quantification
<span class="lineno"> 1318 </span>-- is 'Existential'.
<span class="lineno"> 1319 </span>predicateToProp :: SharedContext -&gt; Quantification -&gt; Term -&gt; IO Prop
<span class="lineno"> 1320 </span><span class="decl"><span class="istickedoff">predicateToProp sc quant = loop <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1322 </span><span class="spaces">  </span><span class="istickedoff">loop env t =</span>
<span class="lineno"> 1323 </span><span class="spaces">    </span><span class="istickedoff">case asLambda t of</span>
<span class="lineno"> 1324 </span><span class="spaces">      </span><span class="istickedoff">Just (x, ty, body) -&gt;</span>
<span class="lineno"> 1325 </span><span class="spaces">        </span><span class="istickedoff">do Prop body' &lt;- loop <span class="nottickedoff">(ty : env)</span> body</span>
<span class="lineno"> 1326 </span><span class="spaces">           </span><span class="istickedoff">Prop &lt;$&gt; scPi sc x ty body'</span>
<span class="lineno"> 1327 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1328 </span><span class="spaces">        </span><span class="istickedoff">do (argTs, resT) &lt;- asPiList &lt;$&gt; scTypeOf' sc <span class="nottickedoff">env</span> t</span>
<span class="lineno"> 1329 </span><span class="spaces">           </span><span class="istickedoff">let toPi [] t0 =</span>
<span class="lineno"> 1330 </span><span class="spaces">                 </span><span class="istickedoff">case asBoolType resT of</span>
<span class="lineno"> 1331 </span><span class="spaces">                   </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ unlines [&quot;predicateToProp : Expected boolean result type but got&quot;, showTerm resT]</span></span>
<span class="lineno"> 1332 </span><span class="spaces">                   </span><span class="istickedoff">Just () -&gt;</span>
<span class="lineno"> 1333 </span><span class="spaces">                     </span><span class="istickedoff">case quant of</span>
<span class="lineno"> 1334 </span><span class="spaces">                       </span><span class="istickedoff">Universal -&gt; scEqTrue sc t0</span>
<span class="lineno"> 1335 </span><span class="spaces">                       </span><span class="istickedoff">Existential -&gt; scEqTrue sc =&lt;&lt; scNot sc t0</span>
<span class="lineno"> 1336 </span><span class="spaces">               </span><span class="istickedoff">toPi ((x, xT) : tys) t0 =</span>
<span class="lineno"> 1337 </span><span class="spaces">                 </span><span class="istickedoff">do t1 &lt;- incVars sc 0 1 t0</span>
<span class="lineno"> 1338 </span><span class="spaces">                    </span><span class="istickedoff">t2 &lt;- scApply sc t1 =&lt;&lt; scLocalVar sc 0</span>
<span class="lineno"> 1339 </span><span class="spaces">                    </span><span class="istickedoff">t3 &lt;- toPi tys t2</span>
<span class="lineno"> 1340 </span><span class="spaces">                    </span><span class="istickedoff">scPi sc x xT t3</span>
<span class="lineno"> 1341 </span><span class="spaces">           </span><span class="istickedoff">Prop &lt;$&gt; toPi argTs t</span></span>
<span class="lineno"> 1342 </span>
<span class="lineno"> 1343 </span>
<span class="lineno"> 1344 </span>-- | A ProofState consists of a sequence of goals, each represented by a sequent.
<span class="lineno"> 1345 </span>--   If each subgoal is provable, that implies the ultimate conclusion.
<span class="lineno"> 1346 </span>data ProofState =
<span class="lineno"> 1347 </span>  ProofState
<span class="lineno"> 1348 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">_psGoals</span></span></span> :: ![ProofGoal]
<span class="lineno"> 1349 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_psConcl</span></span></span> :: (Sequent,Pos,Maybe ProgramLoc,Text)
<span class="lineno"> 1350 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_psStats</span></span></span> :: SolverStats
<span class="lineno"> 1351 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">_psTimeout</span></span></span> :: Maybe Integer
<span class="lineno"> 1352 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_psEvidence</span></span></span> :: [Evidence] -&gt; IO Evidence
<span class="lineno"> 1353 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_psStartTime</span></span></span> :: UTCTime
<span class="lineno"> 1354 </span>  }
<span class="lineno"> 1355 </span>
<span class="lineno"> 1356 </span>psTimeout :: ProofState -&gt; Maybe Integer
<span class="lineno"> 1357 </span><span class="decl"><span class="istickedoff">psTimeout = _psTimeout</span></span>
<span class="lineno"> 1358 </span>
<span class="lineno"> 1359 </span>psGoals :: ProofState -&gt; [ProofGoal]
<span class="lineno"> 1360 </span><span class="decl"><span class="istickedoff">psGoals = _psGoals</span></span>
<span class="lineno"> 1361 </span>
<span class="lineno"> 1362 </span>psStats :: ProofState -&gt; SolverStats
<span class="lineno"> 1363 </span><span class="decl"><span class="nottickedoff">psStats = _psStats</span></span>
<span class="lineno"> 1364 </span>
<span class="lineno"> 1365 </span>-- forall x in ps1, exists y in ps2 where x == y
<span class="lineno"> 1366 </span>propsSubset :: SharedContext -&gt; [Prop] -&gt; [Prop] -&gt; IO Bool
<span class="lineno"> 1367 </span><span class="decl"><span class="istickedoff">propsSubset sc ps1 ps2 =</span>
<span class="lineno"> 1368 </span><span class="spaces">  </span><span class="istickedoff">-- For each x, check if x exists in ps2 by checking term identity using stAppIndex</span>
<span class="lineno"> 1369 </span><span class="spaces">  </span><span class="istickedoff">-- If the check succeeds, return True. Otherwise use propsElem to do the more expensive</span>
<span class="lineno"> 1370 </span><span class="spaces">  </span><span class="istickedoff">-- convertibility check.</span>
<span class="lineno"> 1371 </span><span class="spaces">  </span><span class="istickedoff">and &lt;$&gt; sequence [ if idSubset (unProp x) then pure True else propsElem sc x ps2 | x &lt;- ps1 ]</span>
<span class="lineno"> 1372 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1373 </span><span class="spaces">    </span><span class="istickedoff">ps2Ids = foldr (\x idents -&gt; case (unProp x) of</span>
<span class="lineno"> 1374 </span><span class="spaces">                                   </span><span class="istickedoff">STApp{ stAppIndex = ident } -&gt; Set.insert ident idents</span>
<span class="lineno"> 1375 </span><span class="spaces">                                   </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">idents</span>)</span>
<span class="lineno"> 1376 </span><span class="spaces">                   </span><span class="istickedoff">Set.empty ps2</span>
<span class="lineno"> 1377 </span><span class="spaces">    </span><span class="istickedoff">idSubset STApp{ stAppIndex = ident } = Set.member ident ps2Ids</span>
<span class="lineno"> 1378 </span><span class="spaces">    </span><span class="istickedoff">idSubset _ = <span class="nottickedoff">False</span></span></span>
<span class="lineno"> 1379 </span>
<span class="lineno"> 1380 </span>-- exists y in ps where x == y
<span class="lineno"> 1381 </span>propsElem :: SharedContext -&gt; Prop -&gt; [Prop] -&gt; IO Bool
<span class="lineno"> 1382 </span><span class="decl"><span class="istickedoff">propsElem sc x ps =</span>
<span class="lineno"> 1383 </span><span class="spaces">  </span><span class="istickedoff">or &lt;$&gt; sequence [ scConvertible sc <span class="nottickedoff">True</span> (unProp x) (unProp y) | y &lt;- ps ]</span></span>
<span class="lineno"> 1384 </span>
<span class="lineno"> 1385 </span>-- | Test if a sequent is an instance of the sequent calculus axiom.
<span class="lineno"> 1386 </span>--   This occurs precisely when some hypothesis is convertible
<span class="lineno"> 1387 </span>--   to some conclusion.
<span class="lineno"> 1388 </span>sequentIsAxiom :: SharedContext -&gt; Sequent -&gt; IO Bool
<span class="lineno"> 1389 </span><span class="decl"><span class="nottickedoff">sequentIsAxiom sc sqt =</span>
<span class="lineno"> 1390 </span><span class="spaces">  </span><span class="nottickedoff">do let RawSequent hs gs = sequentToRawSequent sqt</span>
<span class="lineno"> 1391 </span><span class="spaces">     </span><span class="nottickedoff">or &lt;$&gt; sequence [ scConvertible sc True (unProp x) (unProp y) | x &lt;- hs, y &lt;- gs ]</span></span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>-- | Test if the first given sequent subsumes the
<span class="lineno"> 1394 </span>--   second given sequent. This is a shallow syntactic
<span class="lineno"> 1395 </span>--   check that is sufficient to show that a proof
<span class="lineno"> 1396 </span>--   of the first sequent is sufficient to prove the second
<span class="lineno"> 1397 </span>sequentSubsumes :: SharedContext -&gt; Sequent -&gt; Sequent -&gt; IO Bool
<span class="lineno"> 1398 </span><span class="decl"><span class="istickedoff">sequentSubsumes sc sqt1 sqt2 =</span>
<span class="lineno"> 1399 </span><span class="spaces">  </span><span class="istickedoff">do let RawSequent hs1 gs1 = sequentToRawSequent sqt1</span>
<span class="lineno"> 1400 </span><span class="spaces">     </span><span class="istickedoff">let RawSequent hs2 gs2 = sequentToRawSequent sqt2</span>
<span class="lineno"> 1401 </span><span class="spaces">     </span><span class="istickedoff">hypsOK  &lt;- propsSubset <span class="nottickedoff">sc</span> hs1 hs2</span>
<span class="lineno"> 1402 </span><span class="spaces">     </span><span class="istickedoff">conclOK &lt;- propsSubset sc gs1 gs2</span>
<span class="lineno"> 1403 </span><span class="spaces">     </span><span class="istickedoff">return (hypsOK &amp;&amp; conclOK)</span></span>
<span class="lineno"> 1404 </span>
<span class="lineno"> 1405 </span>-- | Test if the first given sequent subsumes the
<span class="lineno"> 1406 </span>--   second given sequent. This is a shallow syntactic
<span class="lineno"> 1407 </span>--   check that is sufficient to show that a proof
<span class="lineno"> 1408 </span>--   of the first sequent is sufficient to prove the second
<span class="lineno"> 1409 </span>normalizeSequentSubsumes :: SharedContext -&gt; Sequent -&gt; Sequent -&gt; IO Bool
<span class="lineno"> 1410 </span><span class="decl"><span class="nottickedoff">normalizeSequentSubsumes sc sqt1 sqt2 =</span>
<span class="lineno"> 1411 </span><span class="spaces">  </span><span class="nottickedoff">do RawSequent hs1 gs1 &lt;- normalizeRawSequent sc (sequentToRawSequent sqt1)</span>
<span class="lineno"> 1412 </span><span class="spaces">     </span><span class="nottickedoff">RawSequent hs2 gs2 &lt;- normalizeRawSequent sc (sequentToRawSequent sqt2)</span>
<span class="lineno"> 1413 </span><span class="spaces">     </span><span class="nottickedoff">hypsOK  &lt;- propsSubset sc hs1 hs2</span>
<span class="lineno"> 1414 </span><span class="spaces">     </span><span class="nottickedoff">conclOK &lt;- propsSubset sc gs1 gs2</span>
<span class="lineno"> 1415 </span><span class="spaces">     </span><span class="nottickedoff">return (hypsOK &amp;&amp; conclOK)</span></span>
<span class="lineno"> 1416 </span>
<span class="lineno"> 1417 </span>-- | Computes a &quot;normalized&quot; sequent. This applies the reversible
<span class="lineno"> 1418 </span>--   L/R sequent calculus rules listed below. The resulting sequent
<span class="lineno"> 1419 </span>--   is always unfocused.
<span class="lineno"> 1420 </span>--
<span class="lineno"> 1421 </span>--       HS1, X, Y, HS2   |- GS
<span class="lineno"> 1422 </span>--       ---------------------- (Conj-L)
<span class="lineno"> 1423 </span>--       HS1, X /\ Y, HS2 |- GS
<span class="lineno"> 1424 </span>--
<span class="lineno"> 1425 </span>--       HS |- GS1, X, Y, GS2
<span class="lineno"> 1426 </span>--       ---------------------- (Disj-R)
<span class="lineno"> 1427 </span>--       HS |- GS1, X \/ Y, GS2
<span class="lineno"> 1428 </span>--
<span class="lineno"> 1429 </span>--       HS, X  |- GS1, GS2
<span class="lineno"> 1430 </span>--       -------------------------- (Neg-R)
<span class="lineno"> 1431 </span>--       HS     |- GS1, not X, GS2
<span class="lineno"> 1432 </span>--
<span class="lineno"> 1433 </span>--       HS1, HS2        |- GS, X
<span class="lineno"> 1434 </span>--       -------------------------- (Neg-L)
<span class="lineno"> 1435 </span>--       HS1, not X, HS2 |- GS
<span class="lineno"> 1436 </span>--
<span class="lineno"> 1437 </span>--       HS, X |- GS1, Y, GS2
<span class="lineno"> 1438 </span>--       -------------------------- (Impl-R)
<span class="lineno"> 1439 </span>--       HS    |- GS1, X -&gt; Y, GS2
<span class="lineno"> 1440 </span>normalizeSequent :: SharedContext -&gt; Sequent -&gt; IO Sequent
<span class="lineno"> 1441 </span><span class="decl"><span class="nottickedoff">normalizeSequent sc sqt =</span>
<span class="lineno"> 1442 </span><span class="spaces">  </span><span class="nottickedoff">-- TODO, if/when we add metadata to sequent branches, this will need to change</span>
<span class="lineno"> 1443 </span><span class="spaces">  </span><span class="nottickedoff">do RawSequent hs gs &lt;- normalizeRawSequent sc (sequentToRawSequent sqt)</span>
<span class="lineno"> 1444 </span><span class="spaces">     </span><span class="nottickedoff">return (UnfocusedSequent hs gs)</span></span>
<span class="lineno"> 1445 </span>
<span class="lineno"> 1446 </span>normalizeRawSequent :: SharedContext -&gt; RawSequent Prop -&gt; IO (RawSequent Prop)
<span class="lineno"> 1447 </span><span class="decl"><span class="nottickedoff">normalizeRawSequent sc (RawSequent hs gs) =</span>
<span class="lineno"> 1448 </span><span class="spaces">  </span><span class="nottickedoff">do hs' &lt;- mapM (normalizeHyp sc) hs</span>
<span class="lineno"> 1449 </span><span class="spaces">     </span><span class="nottickedoff">gs' &lt;- mapM (normalizeConcl sc) gs</span>
<span class="lineno"> 1450 </span><span class="spaces">     </span><span class="nottickedoff">return (joinSequents (hs' ++ gs'))</span></span>
<span class="lineno"> 1451 </span>
<span class="lineno"> 1452 </span>joinSequent :: RawSequent Prop -&gt; RawSequent Prop -&gt; RawSequent Prop
<span class="lineno"> 1453 </span><span class="decl"><span class="nottickedoff">joinSequent (RawSequent hs1 gs1) (RawSequent hs2 gs2) = RawSequent (hs1 ++ hs2) (gs1 ++ gs2)</span></span>
<span class="lineno"> 1454 </span>
<span class="lineno"> 1455 </span>joinSequents :: [RawSequent Prop] -&gt; RawSequent Prop
<span class="lineno"> 1456 </span><span class="decl"><span class="nottickedoff">joinSequents = foldl joinSequent (RawSequent [] [])</span></span>
<span class="lineno"> 1457 </span>
<span class="lineno"> 1458 </span>
<span class="lineno"> 1459 </span>normalizeHyp :: SharedContext -&gt; Prop -&gt; IO (RawSequent Prop)
<span class="lineno"> 1460 </span><span class="decl"><span class="nottickedoff">normalizeHyp sc p =</span>
<span class="lineno"> 1461 </span><span class="spaces">  </span><span class="nottickedoff">do t &lt;- scWhnf sc (unProp p)</span>
<span class="lineno"> 1462 </span><span class="spaces">     </span><span class="nottickedoff">case asEqTrue t of</span>
<span class="lineno"> 1463 </span><span class="spaces">       </span><span class="nottickedoff">Just b -&gt; normalizeHypBool sc b &gt;&gt;= \case</span>
<span class="lineno"> 1464 </span><span class="spaces">                   </span><span class="nottickedoff">Just sqt -&gt; return sqt</span>
<span class="lineno"> 1465 </span><span class="spaces">                   </span><span class="nottickedoff">Nothing  -&gt; return (RawSequent [p] [])</span>
<span class="lineno"> 1466 </span><span class="spaces">       </span><span class="nottickedoff">_      -&gt; return (RawSequent [p] [])</span></span>
<span class="lineno"> 1467 </span>
<span class="lineno"> 1468 </span>normalizeConcl :: SharedContext -&gt; Prop -&gt; IO (RawSequent Prop)
<span class="lineno"> 1469 </span><span class="decl"><span class="nottickedoff">normalizeConcl sc p =</span>
<span class="lineno"> 1470 </span><span class="spaces">  </span><span class="nottickedoff">do t &lt;- scWhnf sc (unProp p)</span>
<span class="lineno"> 1471 </span><span class="spaces">     </span><span class="nottickedoff">case asEqTrue t of</span>
<span class="lineno"> 1472 </span><span class="spaces">       </span><span class="nottickedoff">Just b -&gt; normalizeConclBool sc b &gt;&gt;= \case</span>
<span class="lineno"> 1473 </span><span class="spaces">                   </span><span class="nottickedoff">Just sqt -&gt; return sqt</span>
<span class="lineno"> 1474 </span><span class="spaces">                   </span><span class="nottickedoff">Nothing  -&gt; return (RawSequent [] [p])</span>
<span class="lineno"> 1475 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 1476 </span><span class="spaces">         </span><span class="nottickedoff">-- handle the case of (H1 -&gt; H2), where H1 and H2 are in Prop</span>
<span class="lineno"> 1477 </span><span class="spaces">         </span><span class="nottickedoff">case asPi t of</span>
<span class="lineno"> 1478 </span><span class="spaces">           </span><span class="nottickedoff">Just (_nm, arg, body)</span>
<span class="lineno"> 1479 </span><span class="spaces">             </span><span class="nottickedoff">-- check that this is non-dependent Pi (AKA arrow type)</span>
<span class="lineno"> 1480 </span><span class="spaces">             </span><span class="nottickedoff">| termIsClosed body -&gt;</span>
<span class="lineno"> 1481 </span><span class="spaces">             </span><span class="nottickedoff">termToMaybeProp sc arg &gt;&gt;= \case</span>
<span class="lineno"> 1482 </span><span class="spaces">               </span><span class="nottickedoff">Nothing -&gt; return (RawSequent [] [p])</span>
<span class="lineno"> 1483 </span><span class="spaces">               </span><span class="nottickedoff">Just h  -&gt;</span>
<span class="lineno"> 1484 </span><span class="spaces">                 </span><span class="nottickedoff">do hsqt &lt;- normalizeHyp sc h</span>
<span class="lineno"> 1485 </span><span class="spaces">                    </span><span class="nottickedoff">gsqt &lt;- normalizeConcl sc (Prop body)</span>
<span class="lineno"> 1486 </span><span class="spaces">                    </span><span class="nottickedoff">return (joinSequent hsqt gsqt)</span>
<span class="lineno"> 1487 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; return (RawSequent [] [p])</span></span>
<span class="lineno"> 1488 </span>
<span class="lineno"> 1489 </span>normalizeHypBool :: SharedContext -&gt; Term -&gt; IO (Maybe (RawSequent Prop))
<span class="lineno"> 1490 </span><span class="decl"><span class="nottickedoff">normalizeHypBool sc b =</span>
<span class="lineno"> 1491 </span><span class="spaces">  </span><span class="nottickedoff">do body &lt;- scWhnf sc b</span>
<span class="lineno"> 1492 </span><span class="spaces">     </span><span class="nottickedoff">case () of</span>
<span class="lineno"> 1493 </span><span class="spaces">       </span><span class="nottickedoff">_ | Just (_ :*: p1) &lt;- (isGlobalDef &quot;Prelude.not&quot; &lt;@&gt; return) body</span>
<span class="lineno"> 1494 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; Just &lt;$&gt; normalizeConclBoolCommit sc p1</span>
<span class="lineno"> 1495 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1496 </span><span class="spaces">         </span><span class="nottickedoff">| Just (_ :*: p1 :*: p2) &lt;- (isGlobalDef &quot;Prelude.and&quot; &lt;@&gt; return &lt;@&gt; return) body</span>
<span class="lineno"> 1497 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; Just &lt;$&gt; (joinSequent &lt;$&gt; normalizeHypBoolCommit sc p1 &lt;*&gt; normalizeHypBoolCommit sc p2)</span>
<span class="lineno"> 1498 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1499 </span><span class="spaces">         </span><span class="nottickedoff">| otherwise</span>
<span class="lineno"> 1500 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; return Nothing</span></span>
<span class="lineno"> 1501 </span>
<span class="lineno"> 1502 </span>normalizeHypBoolCommit :: SharedContext -&gt; Term -&gt; IO (RawSequent Prop)
<span class="lineno"> 1503 </span><span class="decl"><span class="nottickedoff">normalizeHypBoolCommit sc b =</span>
<span class="lineno"> 1504 </span><span class="spaces">  </span><span class="nottickedoff">normalizeHypBool sc b &gt;&gt;= \case</span>
<span class="lineno"> 1505 </span><span class="spaces">    </span><span class="nottickedoff">Just sqt -&gt; return sqt</span>
<span class="lineno"> 1506 </span><span class="spaces">    </span><span class="nottickedoff">Nothing  -&gt; do p &lt;- boolToProp sc [] b</span>
<span class="lineno"> 1507 </span><span class="spaces">                   </span><span class="nottickedoff">return (RawSequent [p] [])</span></span>
<span class="lineno"> 1508 </span>
<span class="lineno"> 1509 </span>normalizeConclBool :: SharedContext -&gt; Term -&gt; IO (Maybe (RawSequent Prop))
<span class="lineno"> 1510 </span><span class="decl"><span class="nottickedoff">normalizeConclBool sc b =</span>
<span class="lineno"> 1511 </span><span class="spaces">  </span><span class="nottickedoff">do body &lt;- scWhnf sc b</span>
<span class="lineno"> 1512 </span><span class="spaces">     </span><span class="nottickedoff">case () of</span>
<span class="lineno"> 1513 </span><span class="spaces">       </span><span class="nottickedoff">_ | Just (_ :*: p1) &lt;- (isGlobalDef &quot;Prelude.not&quot; &lt;@&gt; return) body</span>
<span class="lineno"> 1514 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; Just &lt;$&gt; normalizeHypBoolCommit sc p1</span>
<span class="lineno"> 1515 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1516 </span><span class="spaces">         </span><span class="nottickedoff">| Just (_ :*: p1 :*: p2) &lt;- (isGlobalDef &quot;Prelude.or&quot; &lt;@&gt; return &lt;@&gt; return) body</span>
<span class="lineno"> 1517 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; Just &lt;$&gt; (joinSequent &lt;$&gt; normalizeConclBoolCommit sc p1 &lt;*&gt; normalizeConclBoolCommit sc p2)</span>
<span class="lineno"> 1518 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1519 </span><span class="spaces">         </span><span class="nottickedoff">| otherwise</span>
<span class="lineno"> 1520 </span><span class="spaces">         </span><span class="nottickedoff">-&gt; return Nothing</span></span>
<span class="lineno"> 1521 </span>
<span class="lineno"> 1522 </span>normalizeConclBoolCommit :: SharedContext -&gt; Term -&gt; IO (RawSequent Prop)
<span class="lineno"> 1523 </span><span class="decl"><span class="nottickedoff">normalizeConclBoolCommit sc b =</span>
<span class="lineno"> 1524 </span><span class="spaces">  </span><span class="nottickedoff">normalizeConclBool sc b &gt;&gt;= \case</span>
<span class="lineno"> 1525 </span><span class="spaces">    </span><span class="nottickedoff">Just sqt -&gt; return sqt</span>
<span class="lineno"> 1526 </span><span class="spaces">    </span><span class="nottickedoff">Nothing  -&gt; do p &lt;- boolToProp sc [] b</span>
<span class="lineno"> 1527 </span><span class="spaces">                   </span><span class="nottickedoff">return (RawSequent [] [p])</span></span>
<span class="lineno"> 1528 </span>
<span class="lineno"> 1529 </span>
<span class="lineno"> 1530 </span>-- | Verify that the given evidence in fact supports the given proposition.
<span class="lineno"> 1531 </span>--   Returns the identifiers of all the theorems depended on while checking evidence.
<span class="lineno"> 1532 </span>checkEvidence :: SharedContext -&gt; Bool -&gt; Evidence -&gt; Prop -&gt; IO (Set TheoremNonce, TheoremSummary)
<span class="lineno"> 1533 </span><span class="decl"><span class="istickedoff">checkEvidence sc what4PushMuxOps = \e p -&gt; do</span>
<span class="lineno"> 1534 </span><span class="spaces">                              </span><span class="istickedoff">nenv &lt;- scGetNamingEnv sc</span>
<span class="lineno"> 1535 </span><span class="spaces">                              </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e (propToSequent p)</span>
<span class="lineno"> 1536 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1537 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1538 </span><span class="spaces">    </span><span class="istickedoff">checkApply _nenv _mkSqt (Prop p) [] = return (<span class="nottickedoff">mempty</span>, <span class="nottickedoff">mempty</span>, p)</span>
<span class="lineno"> 1539 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1540 </span><span class="spaces">    </span><span class="istickedoff">-- Check a theorem applied to &quot;Evidence&quot;.</span>
<span class="lineno"> 1541 </span><span class="spaces">    </span><span class="istickedoff">-- The given prop must be an implication</span>
<span class="lineno"> 1542 </span><span class="spaces">    </span><span class="istickedoff">-- (i.e., nondependent Pi quantifying over a Prop)</span>
<span class="lineno"> 1543 </span><span class="spaces">    </span><span class="istickedoff">-- and the given evidence must match the expected prop.</span>
<span class="lineno"> 1544 </span><span class="spaces">    </span><span class="istickedoff">checkApply nenv mkSqt (Prop p) (Right e:es)</span>
<span class="lineno"> 1545 </span><span class="spaces">      </span><span class="istickedoff">| Just (_lnm, tp, body) &lt;- asPi p</span>
<span class="lineno"> 1546 </span><span class="spaces">      </span><span class="istickedoff">, <span class="tickonlytrue">termIsClosed body</span></span>
<span class="lineno"> 1547 </span><span class="spaces">      </span><span class="istickedoff">= do (d1,sy1) &lt;- check <span class="nottickedoff">nenv</span> e . mkSqt =&lt;&lt; termToProp sc tp</span>
<span class="lineno"> 1548 </span><span class="spaces">           </span><span class="istickedoff">(d2,sy2,p') &lt;- checkApply <span class="nottickedoff">nenv</span> mkSqt (Prop body) es</span>
<span class="lineno"> 1549 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">Set.union d1 d2</span>, <span class="nottickedoff">sy1 &lt;&gt; sy2</span>, p')</span>
<span class="lineno"> 1550 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1551 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply evidence mismatch: non-function or dependent function&quot;</span></span>
<span class="lineno"> 1552 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">, showTerm p</span></span>
<span class="lineno"> 1553 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1554 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1555 </span><span class="spaces">    </span><span class="istickedoff">-- Check a theorem applied to a term. This explicitly instantiates</span>
<span class="lineno"> 1556 </span><span class="spaces">    </span><span class="istickedoff">-- a Pi binder with the given term.</span>
<span class="lineno"> 1557 </span><span class="spaces">    </span><span class="istickedoff">checkApply nenv mkSqt (Prop p) (Left tm:es) =</span>
<span class="lineno"> 1558 </span><span class="spaces">      </span><span class="istickedoff">do propTerm &lt;- scSort sc propSort</span>
<span class="lineno"> 1559 </span><span class="spaces">         </span><span class="istickedoff">let m = do tm' &lt;- TC.typeInferComplete tm</span>
<span class="lineno"> 1560 </span><span class="spaces">                    </span><span class="istickedoff">let <span class="nottickedoff">err = TC.NotFuncTypeInApp (TC.TypedTerm p propTerm) tm'</span></span>
<span class="lineno"> 1561 </span><span class="spaces">                    </span><span class="istickedoff">TC.applyPiTyped <span class="nottickedoff">err</span> p tm'</span>
<span class="lineno"> 1562 </span><span class="spaces">         </span><span class="istickedoff">res &lt;- TC.runTCM m sc <span class="nottickedoff">Nothing</span> <span class="nottickedoff">[]</span></span>
<span class="lineno"> 1563 </span><span class="spaces">         </span><span class="istickedoff">case res of</span>
<span class="lineno"> 1564 </span><span class="spaces">           </span><span class="istickedoff">Left msg -&gt; <span class="nottickedoff">fail (unlines (TC.prettyTCError msg))</span></span>
<span class="lineno"> 1565 </span><span class="spaces">           </span><span class="istickedoff">Right p' -&gt; checkApply <span class="nottickedoff">nenv</span> mkSqt (Prop p') es</span>
<span class="lineno"> 1566 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1567 </span><span class="spaces">    </span><span class="istickedoff">check ::</span>
<span class="lineno"> 1568 </span><span class="spaces">      </span><span class="istickedoff">SAWNamingEnv -&gt;</span>
<span class="lineno"> 1569 </span><span class="spaces">      </span><span class="istickedoff">Evidence -&gt;</span>
<span class="lineno"> 1570 </span><span class="spaces">      </span><span class="istickedoff">Sequent -&gt;</span>
<span class="lineno"> 1571 </span><span class="spaces">      </span><span class="istickedoff">IO (Set TheoremNonce, TheoremSummary)</span>
<span class="lineno"> 1572 </span><span class="spaces">    </span><span class="istickedoff">check nenv e sqt = case e of</span>
<span class="lineno"> 1573 </span><span class="spaces">      </span><span class="istickedoff">ProofTerm tm -&gt;</span>
<span class="lineno"> 1574 </span><span class="spaces">        </span><span class="istickedoff">case sequentState sqt of</span>
<span class="lineno"> 1575 </span><span class="spaces">          </span><span class="istickedoff">ConclFocus (Prop ptm) _ -&gt;</span>
<span class="lineno"> 1576 </span><span class="spaces">            </span><span class="istickedoff">do ty &lt;- TC.scTypeCheckError sc tm</span>
<span class="lineno"> 1577 </span><span class="spaces">               </span><span class="istickedoff">ok &lt;- scConvertible sc <span class="nottickedoff">True</span> ptm ty</span>
<span class="lineno"> 1578 </span><span class="spaces">               </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1579 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Proof term does not prove the required proposition&quot;</span></span>
<span class="lineno"> 1580 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, showTerm ptm</span></span>
<span class="lineno"> 1581 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, showTerm tm</span></span>
<span class="lineno"> 1582 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1583 </span><span class="spaces">               </span><span class="istickedoff">return (<span class="nottickedoff">mempty</span>, <span class="nottickedoff">ProvedTheorem mempty</span>)</span>
<span class="lineno"> 1584 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;Sequent must be conclusion-focused for proof term evidence&quot;</span></span>
<span class="lineno"> 1585 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1586 </span><span class="spaces">      </span><span class="istickedoff">SolverEvidence stats sqt' -&gt;</span>
<span class="lineno"> 1587 </span><span class="spaces">        </span><span class="istickedoff">do ok &lt;- sequentSubsumes sc sqt' sqt</span>
<span class="lineno"> 1588 </span><span class="spaces">           </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1589 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Solver proof does not prove the required sequent&quot;</span></span>
<span class="lineno"> 1590 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1591 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt'</span></span>
<span class="lineno"> 1592 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1593 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">mempty</span>, <span class="nottickedoff">ProvedTheorem stats</span>)</span>
<span class="lineno"> 1594 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1595 </span><span class="spaces">      </span><span class="istickedoff">Admitted msg pos sqt' -&gt;</span>
<span class="lineno"> 1596 </span><span class="spaces">        </span><span class="istickedoff">do ok &lt;- sequentSubsumes <span class="nottickedoff">sc</span> sqt' sqt</span>
<span class="lineno"> 1597 </span><span class="spaces">           </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1598 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Admitted proof does not match the required sequent &quot; ++ show pos</span></span>
<span class="lineno"> 1599 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, Text.unpack msg</span></span>
<span class="lineno"> 1600 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1601 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt'</span></span>
<span class="lineno"> 1602 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1603 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">mempty</span>, <span class="nottickedoff">AdmittedTheorem msg</span>)</span>
<span class="lineno"> 1604 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1605 </span><span class="spaces">      </span><span class="istickedoff">QuickcheckEvidence n sqt' -&gt;</span>
<span class="lineno"> 1606 </span><span class="spaces">        </span><span class="istickedoff">do ok &lt;- sequentSubsumes <span class="nottickedoff">sc</span> sqt' sqt</span>
<span class="lineno"> 1607 </span><span class="spaces">           </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1608 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quickcheck evidence does not match the required sequent&quot;</span></span>
<span class="lineno"> 1609 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1610 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt'</span></span>
<span class="lineno"> 1611 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1612 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">mempty</span>, <span class="nottickedoff">TestedTheorem n</span>)</span>
<span class="lineno"> 1613 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1614 </span><span class="spaces">      </span><span class="istickedoff">SplitEvidence e1 e2 -&gt;</span>
<span class="lineno"> 1615 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">splitSequent sc sqt &gt;&gt;= \case</span></span>
<span class="lineno"> 1616 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; fail $ unlines</span></span>
<span class="lineno"> 1617 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Split evidence does not apply&quot;</span></span>
<span class="lineno"> 1618 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1619 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1620 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Just (sqt1,sqt2) -&gt;</span></span>
<span class="lineno"> 1621 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do d1 &lt;- check nenv e1 sqt1</span></span>
<span class="lineno"> 1622 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">d2 &lt;- check nenv e2 sqt2</span></span>
<span class="lineno"> 1623 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">return (d1 &lt;&gt; d2)</span></span>
<span class="lineno"> 1624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1625 </span><span class="spaces">      </span><span class="istickedoff">ApplyHypEvidence n es -&gt;</span>
<span class="lineno"> 1626 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case sqt of</span></span>
<span class="lineno"> 1627 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">ConclFocusedSequent hs (FB gs1 g gs2) -&gt;</span></span>
<span class="lineno"> 1628 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">case genericDrop n hs of</span></span>
<span class="lineno"> 1629 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">(h:_) -&gt;</span></span>
<span class="lineno"> 1630 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">do (d,sy,p') &lt;- checkApply nenv (\g' -&gt; ConclFocusedSequent hs (FB gs1 g' gs2)) h es</span></span>
<span class="lineno"> 1631 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">ok &lt;- scConvertible sc False (unProp g) p'</span></span>
<span class="lineno"> 1632 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">unless ok $ fail $ unlines</span></span>
<span class="lineno"> 1633 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply evidence does not match the required proposition&quot;</span></span>
<span class="lineno"> 1634 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">, showTerm (unProp g)</span></span>
<span class="lineno"> 1635 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">, showTerm p'</span></span>
<span class="lineno"> 1636 </span><span class="spaces">                       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1637 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">return (d, sy)</span></span>
<span class="lineno"> 1638 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 1639 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; fail $ unlines $</span></span>
<span class="lineno"> 1640 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Not enough hypotheses in apply hypothesis: &quot; ++ show n</span></span>
<span class="lineno"> 1641 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1642 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1643 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; fail $ unlines $</span></span>
<span class="lineno"> 1644 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply hypothesis evidence requires a conclusion-focused sequent.&quot;</span></span>
<span class="lineno"> 1645 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1646 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1647 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1648 </span><span class="spaces">      </span><span class="istickedoff">ApplyEvidence thm es -&gt;</span>
<span class="lineno"> 1649 </span><span class="spaces">        </span><span class="istickedoff">case sequentState sqt of</span>
<span class="lineno"> 1650 </span><span class="spaces">          </span><span class="istickedoff">ConclFocus p mkSqt -&gt;</span>
<span class="lineno"> 1651 </span><span class="spaces">            </span><span class="istickedoff">do (d,sy,p') &lt;- checkApply <span class="nottickedoff">nenv</span> mkSqt (thmProp thm) es</span>
<span class="lineno"> 1652 </span><span class="spaces">               </span><span class="istickedoff">ok &lt;- scConvertible sc <span class="nottickedoff">False</span> (unProp p) p'</span>
<span class="lineno"> 1653 </span><span class="spaces">               </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1654 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply evidence does not match the required proposition&quot;</span></span>
<span class="lineno"> 1655 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, showTerm (unProp p)</span></span>
<span class="lineno"> 1656 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, showTerm p'</span></span>
<span class="lineno"> 1657 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1658 </span><span class="spaces">               </span><span class="istickedoff">return (<span class="nottickedoff">Set.insert (thmNonce thm) d</span>, <span class="nottickedoff">sy</span>)</span>
<span class="lineno"> 1659 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ unlines $</span></span>
<span class="lineno"> 1660 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply evidence requires a conclusion-focused sequent&quot;</span></span>
<span class="lineno"> 1661 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1662 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1663 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1664 </span><span class="spaces">      </span><span class="istickedoff">UnfoldEvidence vars e' -&gt;</span>
<span class="lineno"> 1665 </span><span class="spaces">        </span><span class="istickedoff">do sqt' &lt;- traverseSequentWithFocus (unfoldProp sc vars) sqt</span>
<span class="lineno"> 1666 </span><span class="spaces">           </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e' sqt'</span>
<span class="lineno"> 1667 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1668 </span><span class="spaces">      </span><span class="istickedoff">UnfoldFixOnceEvidence vars e' -&gt;</span>
<span class="lineno"> 1669 </span><span class="spaces">        </span><span class="istickedoff">do sqt' &lt;- traverseSequentWithFocus (unfoldFixOnceProp sc vars) sqt</span>
<span class="lineno"> 1670 </span><span class="spaces">           </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e' sqt'</span>
<span class="lineno"> 1671 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1672 </span><span class="spaces">      </span><span class="istickedoff">NormalizePropEvidence opqueSet e' -&gt;</span>
<span class="lineno"> 1673 </span><span class="spaces">        </span><span class="istickedoff">do modmap &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1674 </span><span class="spaces">           </span><span class="istickedoff">sqt' &lt;- traverseSequentWithFocus (normalizeProp sc modmap opqueSet) sqt</span>
<span class="lineno"> 1675 </span><span class="spaces">           </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e' sqt'</span>
<span class="lineno"> 1676 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1677 </span><span class="spaces">      </span><span class="istickedoff">RewriteEvidence hs ss e' -&gt;</span>
<span class="lineno"> 1678 </span><span class="spaces">        </span><span class="istickedoff">do ss' &lt;- localHypSimpset <span class="nottickedoff">sc</span> sqt <span class="nottickedoff">hs</span> ss</span>
<span class="lineno"> 1679 </span><span class="spaces">           </span><span class="istickedoff">(d1,sqt') &lt;- simplifySequent sc ss' sqt</span>
<span class="lineno"> 1680 </span><span class="spaces">           </span><span class="istickedoff">(d2,sy) &lt;- check <span class="nottickedoff">nenv</span> e' sqt'</span>
<span class="lineno"> 1681 </span><span class="spaces">           </span><span class="istickedoff">return (<span class="nottickedoff">Set.union d1 d2</span>, <span class="nottickedoff">sy</span>)</span>
<span class="lineno"> 1682 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1683 </span><span class="spaces">      </span><span class="istickedoff">HoistIfsEvidence e' -&gt;</span>
<span class="lineno"> 1684 </span><span class="spaces">        </span><span class="istickedoff">do sqt' &lt;- traverseSequentWithFocus (hoistIfsInProp sc) sqt</span>
<span class="lineno"> 1685 </span><span class="spaces">           </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e' sqt'</span>
<span class="lineno"> 1686 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1687 </span><span class="spaces">      </span><span class="istickedoff">EvalEvidence vars e' -&gt;</span>
<span class="lineno"> 1688 </span><span class="spaces">        </span><span class="istickedoff">do sqt' &lt;- traverseSequentWithFocus (evalProp sc what4PushMuxOps vars) sqt</span>
<span class="lineno"> 1689 </span><span class="spaces">           </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e' sqt'</span>
<span class="lineno"> 1690 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1691 </span><span class="spaces">      </span><span class="istickedoff">ConversionEvidence sqt' e' -&gt;</span>
<span class="lineno"> 1692 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do ok &lt;- convertibleSequents sc sqt sqt'</span></span>
<span class="lineno"> 1693 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">unless ok $ fail $ unlines</span></span>
<span class="lineno"> 1694 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Converted sequent does not match goal&quot;</span></span>
<span class="lineno"> 1695 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1696 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt'</span></span>
<span class="lineno"> 1697 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1698 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">check nenv e' sqt'</span></span>
<span class="lineno"> 1699 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1700 </span><span class="spaces">      </span><span class="istickedoff">NormalizeSequentEvidence sqt' e' -&gt;</span>
<span class="lineno"> 1701 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do ok &lt;- normalizeSequentSubsumes sc sqt' sqt</span></span>
<span class="lineno"> 1702 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">unless ok $ fail $ unlines</span></span>
<span class="lineno"> 1703 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalized sequent does not subsume goal&quot;</span></span>
<span class="lineno"> 1704 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1705 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt'</span></span>
<span class="lineno"> 1706 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1707 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">check nenv e' sqt'</span></span>
<span class="lineno"> 1708 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1709 </span><span class="spaces">      </span><span class="istickedoff">StructuralEvidence sqt' e' -&gt;</span>
<span class="lineno"> 1710 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do ok &lt;- sequentSubsumes sc sqt' sqt</span></span>
<span class="lineno"> 1711 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">unless ok $ fail $ unlines</span></span>
<span class="lineno"> 1712 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Sequent does not subsume goal&quot;</span></span>
<span class="lineno"> 1713 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1714 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt'</span></span>
<span class="lineno"> 1715 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1716 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">check nenv e' sqt'</span></span>
<span class="lineno"> 1717 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1718 </span><span class="spaces">      </span><span class="istickedoff">AxiomEvidence -&gt;</span>
<span class="lineno"> 1719 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do ok &lt;- sequentIsAxiom sc sqt</span></span>
<span class="lineno"> 1720 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">unless ok $ fail $ unlines</span></span>
<span class="lineno"> 1721 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Sequent is not an instance of the sequent calculus axiom&quot;</span></span>
<span class="lineno"> 1722 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1723 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1724 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">return (mempty, ProvedTheorem mempty)</span></span>
<span class="lineno"> 1725 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1726 </span><span class="spaces">      </span><span class="istickedoff">MrSolverEvidence mre -&gt;</span>
<span class="lineno"> 1727 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case sequentState sqt of</span></span>
<span class="lineno"> 1728 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">ConclFocus _p _mkSqt -&gt;</span></span>
<span class="lineno"> 1729 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do (d, stats) &lt;- MRSolver.checkMREvidence mre</span></span>
<span class="lineno"> 1730 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">-- FIXME: Check that p actually does match the MRSolverEvidence</span></span>
<span class="lineno"> 1731 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">return (d, ProvedTheorem stats)</span></span>
<span class="lineno"> 1732 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; fail $ unlines $</span></span>
<span class="lineno"> 1733 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;MRSolver evidence requires a conclusion-focused sequent&quot;</span></span>
<span class="lineno"> 1734 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">, prettySequent defaultPPOpts nenv sqt</span></span>
<span class="lineno"> 1735 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1736 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1737 </span><span class="spaces">      </span><span class="istickedoff">CutEvidence p ehyp egl -&gt;</span>
<span class="lineno"> 1738 </span><span class="spaces">        </span><span class="istickedoff">do d1 &lt;- check <span class="nottickedoff">nenv</span> ehyp (addHypothesis p sqt)</span>
<span class="lineno"> 1739 </span><span class="spaces">           </span><span class="istickedoff">d2 &lt;- check <span class="nottickedoff">nenv</span> egl  (addNewFocusedConcl p sqt)</span>
<span class="lineno"> 1740 </span><span class="spaces">           </span><span class="istickedoff">return (d1 &lt;&gt; d2)</span>
<span class="lineno"> 1741 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1742 </span><span class="spaces">      </span><span class="istickedoff">IntroEvidence x e' -&gt;</span>
<span class="lineno"> 1743 </span><span class="spaces">        </span><span class="istickedoff">-- TODO! Check that the given ExtCns is fresh for the sequent.</span>
<span class="lineno"> 1744 </span><span class="spaces">        </span><span class="istickedoff">--</span>
<span class="lineno"> 1745 </span><span class="spaces">        </span><span class="istickedoff">--   On soundness: I am concerned that just checking that 'x' is fresh for 'sqt'</span>
<span class="lineno"> 1746 </span><span class="spaces">        </span><span class="istickedoff">--   isn't enough, as 'x' may nonetheless appear in other values in the ambient</span>
<span class="lineno"> 1747 </span><span class="spaces">        </span><span class="istickedoff">--   context, such as defined constants, or in the type of other things, etc.</span>
<span class="lineno"> 1748 </span><span class="spaces">        </span><span class="istickedoff">--</span>
<span class="lineno"> 1749 </span><span class="spaces">        </span><span class="istickedoff">--   The most reliable way to actually do this freshness check, then, is to produce</span>
<span class="lineno"> 1750 </span><span class="spaces">        </span><span class="istickedoff">--   a brand-new guaranteed fresh value (call it 'y') and replace 'x' with 'y'</span>
<span class="lineno"> 1751 </span><span class="spaces">        </span><span class="istickedoff">--   everywhere in the remaining evidence checking process. This is going to require</span>
<span class="lineno"> 1752 </span><span class="spaces">        </span><span class="istickedoff">--   quite a bit of additional infrastructure to do the necessary replacements, and we</span>
<span class="lineno"> 1753 </span><span class="spaces">        </span><span class="istickedoff">--   will need to be pretty careful if we want to avoid repeated traversals (which</span>
<span class="lineno"> 1754 </span><span class="spaces">        </span><span class="istickedoff">--   could cause substantial performance issues).</span>
<span class="lineno"> 1755 </span><span class="spaces">        </span><span class="istickedoff">case sequentState sqt of</span>
<span class="lineno"> 1756 </span><span class="spaces">          </span><span class="istickedoff">Unfocused -&gt; <span class="nottickedoff">fail &quot;Intro evidence requires a focused sequent&quot;</span></span>
<span class="lineno"> 1757 </span><span class="spaces">          </span><span class="istickedoff">HypFocus _ _ -&gt; <span class="nottickedoff">fail &quot;Intro evidence apply in hypothesis&quot;</span></span>
<span class="lineno"> 1758 </span><span class="spaces">          </span><span class="istickedoff">ConclFocus (Prop ptm) mkSqt -&gt;</span>
<span class="lineno"> 1759 </span><span class="spaces">            </span><span class="istickedoff">case asPi ptm of</span>
<span class="lineno"> 1760 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ unlines [&quot;Intro evidence expected function prop&quot;, showTerm ptm]</span></span>
<span class="lineno"> 1761 </span><span class="spaces">              </span><span class="istickedoff">Just (_lnm, ty, body) -&gt;</span>
<span class="lineno"> 1762 </span><span class="spaces">                </span><span class="istickedoff">do let ty' = ecType x</span>
<span class="lineno"> 1763 </span><span class="spaces">                   </span><span class="istickedoff">ok &lt;- scConvertible <span class="nottickedoff">sc</span> <span class="nottickedoff">False</span> ty ty'</span>
<span class="lineno"> 1764 </span><span class="spaces">                   </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1765 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">[&quot;Intro evidence types do not match&quot;</span></span>
<span class="lineno"> 1766 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">, showTerm ty'</span></span>
<span class="lineno"> 1767 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">, showTerm ty</span></span>
<span class="lineno"> 1768 </span><span class="spaces">                     </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1769 </span><span class="spaces">                   </span><span class="istickedoff">x' &lt;- scExtCns sc x</span>
<span class="lineno"> 1770 </span><span class="spaces">                   </span><span class="istickedoff">body' &lt;- instantiateVar sc 0 x' body</span>
<span class="lineno"> 1771 </span><span class="spaces">                   </span><span class="istickedoff">check <span class="nottickedoff">nenv</span> e' (mkSqt (Prop body'))</span></span>
<span class="lineno"> 1772 </span>
<span class="lineno"> 1773 </span>passthroughEvidence :: [Evidence] -&gt; IO Evidence
<span class="lineno"> 1774 </span><span class="decl"><span class="istickedoff">passthroughEvidence [e] = pure e</span>
<span class="lineno"> 1775 </span><span class="spaces"></span><span class="istickedoff">passthroughEvidence _   = <span class="nottickedoff">fail &quot;passthroughEvidence: incorrect arity&quot;</span></span></span>
<span class="lineno"> 1776 </span>
<span class="lineno"> 1777 </span>updateEvidence :: (Evidence -&gt; Evidence) -&gt; [Evidence] -&gt; IO Evidence
<span class="lineno"> 1778 </span><span class="decl"><span class="istickedoff">updateEvidence f [e] = pure (f e)</span>
<span class="lineno"> 1779 </span><span class="spaces"></span><span class="istickedoff">updateEvidence _ _ = <span class="nottickedoff">fail &quot;updateEvidence: incorrect arity&quot;</span></span></span>
<span class="lineno"> 1780 </span>
<span class="lineno"> 1781 </span>leafEvidence :: Evidence -&gt; [Evidence] -&gt; IO Evidence
<span class="lineno"> 1782 </span><span class="decl"><span class="istickedoff">leafEvidence e [] = pure e</span>
<span class="lineno"> 1783 </span><span class="spaces"></span><span class="istickedoff">leafEvidence _ _  = <span class="nottickedoff">fail &quot;leafEvidence: incorrect arity&quot;</span></span></span>
<span class="lineno"> 1784 </span>
<span class="lineno"> 1785 </span>setProofTimeout :: Integer -&gt; ProofState -&gt; ProofState
<span class="lineno"> 1786 </span><span class="decl"><span class="nottickedoff">setProofTimeout to ps = ps { _psTimeout = Just to }</span></span>
<span class="lineno"> 1787 </span>
<span class="lineno"> 1788 </span>-- | Initialize a proof state with a single goal to prove.
<span class="lineno"> 1789 </span>startProof :: ProofGoal -&gt; Pos -&gt; Maybe ProgramLoc -&gt; Text -&gt; IO ProofState
<span class="lineno"> 1790 </span><span class="decl"><span class="istickedoff">startProof g pos ploc rsn =</span>
<span class="lineno"> 1791 </span><span class="spaces">  </span><span class="istickedoff">do start &lt;- getCurrentTime</span>
<span class="lineno"> 1792 </span><span class="spaces">     </span><span class="istickedoff">pure (ProofState [g] (<span class="nottickedoff">goalSequent g</span>,<span class="nottickedoff">pos</span>,<span class="nottickedoff">ploc</span>,<span class="nottickedoff">rsn</span>) <span class="nottickedoff">mempty</span> Nothing passthroughEvidence <span class="nottickedoff">start</span>)</span></span>
<span class="lineno"> 1793 </span>
<span class="lineno"> 1794 </span>-- | Attempt to complete a proof by checking that all subgoals have been discharged,
<span class="lineno"> 1795 </span>--   and validate the computed evidence to ensure that it supports the original
<span class="lineno"> 1796 </span>--   proposition.  If successful, return the completed @Theorem@ and a summary
<span class="lineno"> 1797 </span>--   of solver resources used in the proof.
<span class="lineno"> 1798 </span>--
<span class="lineno"> 1799 </span>--   If first boolean argument is @False@, the resulting theorem will not be
<span class="lineno"> 1800 </span>--   recored in the theorem database. This should only be done when you are
<span class="lineno"> 1801 </span>--   sure that the theorem will not be used as part of the proof of other theorems,
<span class="lineno"> 1802 </span>--   or later steps will fail. This is intended for proofs of verification conditions,
<span class="lineno"> 1803 </span>--   which are not exposed for reuse, and where it requires a significant memory
<span class="lineno"> 1804 </span>--   burden to record them. In particular commands like @llvm_verify@, @jvm_verify@, etc
<span class="lineno"> 1805 </span>--   that produce and verify verification conditions should set this argument to
<span class="lineno"> 1806 </span>--   @False@ to reduce memory pressure.
<span class="lineno"> 1807 </span>--
<span class="lineno"> 1808 </span>--   The final boolean argument indicates if the proof state needs a sequent normalization
<span class="lineno"> 1809 </span>--   step as the final step in its evidence chain to check.  This is useful for goals that
<span class="lineno"> 1810 </span>--   start with a nontrivial sequent (e.g., when enable_sequent_goals is turned on). For some
<span class="lineno"> 1811 </span>--   goals, this step is expensive, so we avoid it unless necessary.
<span class="lineno"> 1812 </span>finishProof ::
<span class="lineno"> 1813 </span>  SharedContext -&gt;
<span class="lineno"> 1814 </span>  TheoremDB -&gt;
<span class="lineno"> 1815 </span>  Prop -&gt;
<span class="lineno"> 1816 </span>  ProofState -&gt;
<span class="lineno"> 1817 </span>  Bool {- ^ should we record the theorem in the database? -} -&gt;
<span class="lineno"> 1818 </span>  Bool {- ^ do we need to normalize the sequent to match the final goal ? -} -&gt;
<span class="lineno"> 1819 </span>  Bool {- ^ If 'True', push certain @ExprBuilder@ operations (e.g., @zext@) down
<span class="lineno"> 1820 </span>            to the branches of @ite@ expressions -} -&gt;
<span class="lineno"> 1821 </span>  IO (ProofResult, TheoremDB)
<span class="lineno"> 1822 </span><span class="decl"><span class="istickedoff">finishProof sc db conclProp</span>
<span class="lineno"> 1823 </span><span class="spaces">    </span><span class="istickedoff">ps@(ProofState gs (concl,loc,ploc,rsn) stats _ checkEv start)</span>
<span class="lineno"> 1824 </span><span class="spaces">    </span><span class="istickedoff">recordThm useSequentGoals what4PushMuxOps =</span>
<span class="lineno"> 1825 </span><span class="spaces">  </span><span class="istickedoff">case gs of</span>
<span class="lineno"> 1826 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt;</span>
<span class="lineno"> 1827 </span><span class="spaces">      </span><span class="istickedoff">do e &lt;- checkEv []</span>
<span class="lineno"> 1828 </span><span class="spaces">         </span><span class="istickedoff">let e' = if <span class="tickonlyfalse">useSequentGoals</span></span>
<span class="lineno"> 1829 </span><span class="spaces">                   </span><span class="istickedoff">then <span class="nottickedoff">NormalizeSequentEvidence concl e</span></span>
<span class="lineno"> 1830 </span><span class="spaces">                   </span><span class="istickedoff">else e</span>
<span class="lineno"> 1831 </span><span class="spaces">         </span><span class="istickedoff">(deps,sy) &lt;- checkEvidence sc what4PushMuxOps e' conclProp</span>
<span class="lineno"> 1832 </span><span class="spaces">         </span><span class="istickedoff">n &lt;- freshNonce globalNonceGenerator</span>
<span class="lineno"> 1833 </span><span class="spaces">         </span><span class="istickedoff">end &lt;- getCurrentTime</span>
<span class="lineno"> 1834 </span><span class="spaces">         </span><span class="istickedoff">let theorem =</span>
<span class="lineno"> 1835 </span><span class="spaces">                   </span><span class="istickedoff">Theorem</span>
<span class="lineno"> 1836 </span><span class="spaces">                   </span><span class="istickedoff">{ _thmProp = conclProp</span>
<span class="lineno"> 1837 </span><span class="spaces">                   </span><span class="istickedoff">, _thmStats = <span class="nottickedoff">stats</span></span>
<span class="lineno"> 1838 </span><span class="spaces">                   </span><span class="istickedoff">, _thmEvidence = <span class="nottickedoff">e'</span></span>
<span class="lineno"> 1839 </span><span class="spaces">                   </span><span class="istickedoff">, _thmLocation = <span class="nottickedoff">loc</span></span>
<span class="lineno"> 1840 </span><span class="spaces">                   </span><span class="istickedoff">, _thmProgramLoc = <span class="nottickedoff">ploc</span></span>
<span class="lineno"> 1841 </span><span class="spaces">                   </span><span class="istickedoff">, _thmReason = <span class="nottickedoff">rsn</span></span>
<span class="lineno"> 1842 </span><span class="spaces">                   </span><span class="istickedoff">, _thmNonce = n</span>
<span class="lineno"> 1843 </span><span class="spaces">                   </span><span class="istickedoff">, _thmDepends = <span class="nottickedoff">deps</span></span>
<span class="lineno"> 1844 </span><span class="spaces">                   </span><span class="istickedoff">, _thmElapsedTime = <span class="nottickedoff">diffUTCTime end start</span></span>
<span class="lineno"> 1845 </span><span class="spaces">                   </span><span class="istickedoff">, _thmSummary = <span class="nottickedoff">sy</span></span>
<span class="lineno"> 1846 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno"> 1847 </span><span class="spaces">         </span><span class="istickedoff">let db' = if recordThm then recordTheorem <span class="nottickedoff">db</span> theorem else db</span>
<span class="lineno"> 1848 </span><span class="spaces">         </span><span class="istickedoff">pure (ValidProof <span class="nottickedoff">stats</span> theorem, db')</span>
<span class="lineno"> 1849 </span><span class="spaces">    </span><span class="istickedoff">_ : _ -&gt;</span>
<span class="lineno"> 1850 </span><span class="spaces">         </span><span class="istickedoff">pure (UnfinishedProof ps, db)</span></span>
<span class="lineno"> 1851 </span>
<span class="lineno"> 1852 </span>-- | A type describing counterexamples.
<span class="lineno"> 1853 </span>type CEX = [(ExtCns Term, FirstOrderValue)]
<span class="lineno"> 1854 </span>
<span class="lineno"> 1855 </span>-- | The results that can occur after a proof attempt.
<span class="lineno"> 1856 </span>data ProofResult
<span class="lineno"> 1857 </span>  = -- | The proof was completed and results in a theorem
<span class="lineno"> 1858 </span>    ValidProof SolverStats Theorem
<span class="lineno"> 1859 </span>    -- | The proof failed, and we found a counterexample to
<span class="lineno"> 1860 </span>    --   one of the proof's subgoals.
<span class="lineno"> 1861 </span>  | InvalidProof SolverStats CEX ProofState
<span class="lineno"> 1862 </span>    -- | The proof was not completed, but we did not find
<span class="lineno"> 1863 </span>    --   a counterexample.
<span class="lineno"> 1864 </span>  | UnfinishedProof ProofState
<span class="lineno"> 1865 </span>
<span class="lineno"> 1866 </span>-- | A @Tactic@ is a computation that examines, simplifies
<span class="lineno"> 1867 </span>--   and/or solves a proof goal.  Given a goal, it does some
<span class="lineno"> 1868 </span>--   work and returns 0 or more subgoals which, if they are all proved,
<span class="lineno"> 1869 </span>--   imply the original goal.  Moreover, it returns a way to compute
<span class="lineno"> 1870 </span>--   evidence for the original goal when given evidence for the generated
<span class="lineno"> 1871 </span>--   subgoal.  An important special case is a tactic that returns 0 subgoals,
<span class="lineno"> 1872 </span>--   and therefore completely solves the goal.
<span class="lineno"> 1873 </span>newtype Tactic m a =
<span class="lineno"> 1874 </span>  Tactic (ProofGoal -&gt; ExceptT (SolverStats, CEX) m (a, SolverStats, [ProofGoal], [Evidence] -&gt; IO Evidence))
<span class="lineno"> 1875 </span>
<span class="lineno"> 1876 </span>-- | Choose the first subgoal in the current proof state and apply the given
<span class="lineno"> 1877 </span>--   proof tactic.
<span class="lineno"> 1878 </span>withFirstGoal :: F.MonadFail m =&gt; Tactic m a -&gt; ProofState -&gt; m (Either (SolverStats, CEX) (a, ProofState))
<span class="lineno"> 1879 </span><span class="decl"><span class="istickedoff">withFirstGoal (Tactic f) (ProofState goals concl stats timeout evidenceCont start) =</span>
<span class="lineno"> 1880 </span><span class="spaces">     </span><span class="istickedoff">case goals of</span>
<span class="lineno"> 1881 </span><span class="spaces">       </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">fail &quot;ProofScript failed: no subgoal&quot;</span></span>
<span class="lineno"> 1882 </span><span class="spaces">       </span><span class="istickedoff">g : gs -&gt; runExceptT (f g) &gt;&gt;= \case</span>
<span class="lineno"> 1883 </span><span class="spaces">         </span><span class="istickedoff">Left cex -&gt; return (Left cex)</span>
<span class="lineno"> 1884 </span><span class="spaces">         </span><span class="istickedoff">Right (x, stats', gs', buildTacticEvidence) -&gt;</span>
<span class="lineno"> 1885 </span><span class="spaces">           </span><span class="istickedoff">do let evidenceCont' es =</span>
<span class="lineno"> 1886 </span><span class="spaces">                      </span><span class="istickedoff">do let (es1, es2) = splitAt (length gs') es</span>
<span class="lineno"> 1887 </span><span class="spaces">                         </span><span class="istickedoff">e &lt;- buildTacticEvidence es1</span>
<span class="lineno"> 1888 </span><span class="spaces">                         </span><span class="istickedoff">evidenceCont (e:es2)</span>
<span class="lineno"> 1889 </span><span class="spaces">              </span><span class="istickedoff">let ps' = ProofState (gs' &lt;&gt; gs) concl <span class="nottickedoff">(stats &lt;&gt; stats')</span> timeout evidenceCont' <span class="nottickedoff">start</span></span>
<span class="lineno"> 1890 </span><span class="spaces">              </span><span class="istickedoff">seq ps' (return (Right (<span class="nottickedoff">x</span>, ps')))</span></span>
<span class="lineno"> 1891 </span>
<span class="lineno"> 1892 </span>predicateToSATQuery :: SharedContext -&gt; Set VarIndex -&gt; Term -&gt; IO SATQuery
<span class="lineno"> 1893 </span><span class="decl"><span class="istickedoff">predicateToSATQuery sc unintSet tm0 =</span>
<span class="lineno"> 1894 </span><span class="spaces">    </span><span class="istickedoff">do mmap &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1895 </span><span class="spaces">       </span><span class="istickedoff">(initVars, abstractVars) &lt;- filterFirstOrderVars <span class="nottickedoff">mmap</span> mempty mempty (getAllExts tm0)</span>
<span class="lineno"> 1896 </span><span class="spaces">       </span><span class="istickedoff">(finalVars, tm') &lt;- processTerm <span class="nottickedoff">mmap</span> initVars tm0</span>
<span class="lineno"> 1897 </span><span class="spaces">       </span><span class="istickedoff">return SATQuery</span>
<span class="lineno"> 1898 </span><span class="spaces">              </span><span class="istickedoff">{ satVariables = finalVars</span>
<span class="lineno"> 1899 </span><span class="spaces">              </span><span class="istickedoff">, satUninterp  = Set.union unintSet abstractVars</span>
<span class="lineno"> 1900 </span><span class="spaces">              </span><span class="istickedoff">, satAsserts   = [BoolAssert tm']</span>
<span class="lineno"> 1901 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 1902 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1903 </span><span class="spaces">    </span><span class="istickedoff">evalFOT mmap t =</span>
<span class="lineno"> 1904 </span><span class="spaces">      </span><span class="istickedoff">asFirstOrderTypeValue (evalSharedTerm <span class="nottickedoff">mmap</span> mempty <span class="nottickedoff">mempty</span> t)</span>
<span class="lineno"> 1905 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1906 </span><span class="spaces">    </span><span class="istickedoff">filterFirstOrderVars _ fovars absvars [] = pure (fovars, absvars)</span>
<span class="lineno"> 1907 </span><span class="spaces">    </span><span class="istickedoff">filterFirstOrderVars mmap fovars absvars (e:es) =</span>
<span class="lineno"> 1908 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case evalFOT mmap (ecType e) of</span></span>
<span class="lineno"> 1909 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing  -&gt; filterFirstOrderVars mmap fovars (Set.insert (ecVarIndex e) absvars) es</span></span>
<span class="lineno"> 1910 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just fot -&gt; filterFirstOrderVars mmap (Map.insert e fot fovars) absvars es</span></span>
<span class="lineno"> 1911 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1912 </span><span class="spaces">    </span><span class="istickedoff">processTerm mmap vars tm =</span>
<span class="lineno"> 1913 </span><span class="spaces">      </span><span class="istickedoff">case asLambda tm of</span>
<span class="lineno"> 1914 </span><span class="spaces">        </span><span class="istickedoff">Just (lnm,tp,body) -&gt;</span>
<span class="lineno"> 1915 </span><span class="spaces">          </span><span class="istickedoff">case evalFOT <span class="nottickedoff">mmap</span> tp of</span>
<span class="lineno"> 1916 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail (&quot;predicateToSATQuery: expected first order type: &quot; ++ showTerm tp)</span></span>
<span class="lineno"> 1917 </span><span class="spaces">            </span><span class="istickedoff">Just fot -&gt;</span>
<span class="lineno"> 1918 </span><span class="spaces">              </span><span class="istickedoff">do ec  &lt;- scFreshEC sc lnm tp</span>
<span class="lineno"> 1919 </span><span class="spaces">                 </span><span class="istickedoff">etm &lt;- scExtCns sc ec</span>
<span class="lineno"> 1920 </span><span class="spaces">                 </span><span class="istickedoff">body' &lt;- instantiateVar sc 0 etm body</span>
<span class="lineno"> 1921 </span><span class="spaces">                 </span><span class="istickedoff">processTerm <span class="nottickedoff">mmap</span> (Map.insert ec fot vars) body'</span>
<span class="lineno"> 1922 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1923 </span><span class="spaces">          </span><span class="istickedoff">-- TODO: check that the type is a boolean</span>
<span class="lineno"> 1924 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1925 </span><span class="spaces">          </span><span class="istickedoff">do ty &lt;- scTypeOf sc tm</span>
<span class="lineno"> 1926 </span><span class="spaces">             </span><span class="istickedoff">ok &lt;- scConvertible <span class="nottickedoff">sc</span> <span class="nottickedoff">True</span> ty =&lt;&lt; scBoolType sc</span>
<span class="lineno"> 1927 </span><span class="spaces">             </span><span class="istickedoff">unless ok $ <span class="nottickedoff">fail $ unlines</span></span>
<span class="lineno"> 1928 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">[ &quot;predicateToSATQuery: expected boolean result but got:&quot;</span></span>
<span class="lineno"> 1929 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, showTerm ty</span></span>
<span class="lineno"> 1930 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">, showTerm tm0</span></span>
<span class="lineno"> 1931 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1932 </span><span class="spaces">             </span><span class="istickedoff">return (vars, tm)</span></span>
<span class="lineno"> 1933 </span>
<span class="lineno"> 1934 </span>-- | Given a proposition, compute a SAT query which will prove the proposition
<span class="lineno"> 1935 </span>--   iff the SAT query is unsatisfiable.
<span class="lineno"> 1936 </span>propToSATQuery :: SharedContext -&gt; Set VarIndex -&gt; Prop -&gt; IO SATQuery
<span class="lineno"> 1937 </span><span class="decl"><span class="nottickedoff">propToSATQuery sc unintSet prop = sequentToSATQuery sc unintSet (propToSequent prop)</span></span>
<span class="lineno"> 1938 </span>
<span class="lineno"> 1939 </span>-- | Given a proposition, compute a SAT query which will prove the proposition
<span class="lineno"> 1940 </span>--   iff the SAT query is unsatisfiable.
<span class="lineno"> 1941 </span>sequentToSATQuery :: SharedContext -&gt; Set VarIndex -&gt; Sequent -&gt; IO SATQuery
<span class="lineno"> 1942 </span><span class="decl"><span class="istickedoff">sequentToSATQuery sc unintSet sqt =</span>
<span class="lineno"> 1943 </span><span class="spaces">    </span><span class="istickedoff">do let RawSequent hs gs = sequentToRawSequent sqt</span>
<span class="lineno"> 1944 </span><span class="spaces">       </span><span class="istickedoff">mmap &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1945 </span><span class="spaces">       </span><span class="istickedoff">let exts = foldMap getAllExtSet (map unProp (hs ++ gs))</span>
<span class="lineno"> 1946 </span><span class="spaces">       </span><span class="istickedoff">(initVars, abstractVars) &lt;- filterFirstOrderVars <span class="nottickedoff">mmap</span> mempty mempty (Set.toList exts)</span>
<span class="lineno"> 1947 </span><span class="spaces">       </span><span class="istickedoff">-- NB, the following reversals make the order of assertions more closely match the input sequent,</span>
<span class="lineno"> 1948 </span><span class="spaces">       </span><span class="istickedoff">-- but should otherwise not be semantically relevant</span>
<span class="lineno"> 1949 </span><span class="spaces">       </span><span class="istickedoff">hypAsserts &lt;- mapM (processAssert <span class="nottickedoff">mmap</span>) (reverse (map unProp hs))</span>
<span class="lineno"> 1950 </span><span class="spaces">       </span><span class="istickedoff">(finalVars, asserts) &lt;- foldM (processConcl mmap) (initVars, hypAsserts) (map unProp gs)</span>
<span class="lineno"> 1951 </span><span class="spaces">       </span><span class="istickedoff">return SATQuery</span>
<span class="lineno"> 1952 </span><span class="spaces">              </span><span class="istickedoff">{ satVariables = finalVars</span>
<span class="lineno"> 1953 </span><span class="spaces">              </span><span class="istickedoff">, satUninterp  = Set.union unintSet abstractVars</span>
<span class="lineno"> 1954 </span><span class="spaces">              </span><span class="istickedoff">, satAsserts   = asserts</span>
<span class="lineno"> 1955 </span><span class="spaces">              </span><span class="istickedoff">}</span>
<span class="lineno"> 1956 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1957 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1958 </span><span class="spaces">    </span><span class="istickedoff">evalFOT mmap t =</span>
<span class="lineno"> 1959 </span><span class="spaces">      </span><span class="istickedoff">asFirstOrderTypeValue (evalSharedTerm mmap mempty <span class="nottickedoff">mempty</span> t)</span>
<span class="lineno"> 1960 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1961 </span><span class="spaces">    </span><span class="istickedoff">filterFirstOrderVars _ fovars absvars [] = pure (fovars, absvars)</span>
<span class="lineno"> 1962 </span><span class="spaces">    </span><span class="istickedoff">filterFirstOrderVars mmap fovars absvars (e:es) =</span>
<span class="lineno"> 1963 </span><span class="spaces">      </span><span class="istickedoff">case evalFOT <span class="nottickedoff">mmap</span> (ecType e) of</span>
<span class="lineno"> 1964 </span><span class="spaces">         </span><span class="istickedoff">Nothing  -&gt; <span class="nottickedoff">filterFirstOrderVars mmap fovars (Set.insert (ecVarIndex e) absvars) es</span></span>
<span class="lineno"> 1965 </span><span class="spaces">         </span><span class="istickedoff">Just fot -&gt; filterFirstOrderVars <span class="nottickedoff">mmap</span> (Map.insert e fot fovars) absvars es</span>
<span class="lineno"> 1966 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1967 </span><span class="spaces">    </span><span class="istickedoff">processAssert mmap tp =</span>
<span class="lineno"> 1968 </span><span class="spaces">      </span><span class="istickedoff">case asEqTrue tp of</span>
<span class="lineno"> 1969 </span><span class="spaces">        </span><span class="istickedoff">Just x -&gt; return (BoolAssert x)</span>
<span class="lineno"> 1970 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; processUnivAssert <span class="nottickedoff">mmap</span> [] [] tp</span>
<span class="lineno"> 1971 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1972 </span><span class="spaces">    </span><span class="istickedoff">processUnivAssert mmap vars xs tm =</span>
<span class="lineno"> 1973 </span><span class="spaces">      </span><span class="istickedoff">do -- TODO: See related TODO in processConcl</span>
<span class="lineno"> 1974 </span><span class="spaces">         </span><span class="istickedoff">let tm' = tm</span>
<span class="lineno"> 1975 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1976 </span><span class="spaces">         </span><span class="istickedoff">case asPi tm' of</span>
<span class="lineno"> 1977 </span><span class="spaces">           </span><span class="istickedoff">Just (lnm, tp, body) -&gt;</span>
<span class="lineno"> 1978 </span><span class="spaces">             </span><span class="istickedoff">do -- TOOD, same issue</span>
<span class="lineno"> 1979 </span><span class="spaces">                </span><span class="istickedoff">let tp' = tp</span>
<span class="lineno"> 1980 </span><span class="spaces">                </span><span class="istickedoff">case evalFOT <span class="nottickedoff">mmap</span> tp' of</span>
<span class="lineno"> 1981 </span><span class="spaces">                  </span><span class="istickedoff">Just fot -&gt;</span>
<span class="lineno"> 1982 </span><span class="spaces">                    </span><span class="istickedoff">do ec  &lt;- scFreshEC sc lnm tp'</span>
<span class="lineno"> 1983 </span><span class="spaces">                       </span><span class="istickedoff">etm &lt;- scExtCns sc ec</span>
<span class="lineno"> 1984 </span><span class="spaces">                       </span><span class="istickedoff">body' &lt;- instantiateVar sc 0 etm body</span>
<span class="lineno"> 1985 </span><span class="spaces">                       </span><span class="istickedoff">processUnivAssert <span class="nottickedoff">mmap</span> ((ec,fot):vars) xs body'</span>
<span class="lineno"> 1986 </span><span class="spaces">                  </span><span class="istickedoff">Nothing</span>
<span class="lineno"> 1987 </span><span class="spaces">                    </span><span class="istickedoff">| <span class="nottickedoff">termIsClosed body</span> -&gt;</span>
<span class="lineno"> 1988 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">case asEqTrue tp' of</span></span>
<span class="lineno"> 1989 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Just x  -&gt; processUnivAssert mmap vars (x:xs) body</span></span>
<span class="lineno"> 1990 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno"> 1991 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">fail (&quot;sequentToSATQuery: expected first order type or assertion:\n&quot; ++ showTerm tp')</span></span>
<span class="lineno"> 1992 </span><span class="spaces">                    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno"> 1993 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">fail (&quot;sequentToSATQuery: expected first order type or assertion:\n&quot; ++ showTerm tp')</span></span>
<span class="lineno"> 1994 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1995 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1996 </span><span class="spaces">             </span><span class="istickedoff">case asEqTrue tm' of</span>
<span class="lineno"> 1997 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;sequentToSATQuery: expected EqTrue, actual:\n&quot; ++ showTerm tm'</span></span>
<span class="lineno"> 1998 </span><span class="spaces">               </span><span class="istickedoff">Just tmBool -&gt; return (UniversalAssert (reverse vars) (reverse xs) tmBool)</span>
<span class="lineno"> 1999 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2000 </span><span class="spaces">    </span><span class="istickedoff">processConcl mmap (vars,xs) tm =</span>
<span class="lineno"> 2001 </span><span class="spaces">      </span><span class="istickedoff">do -- TODO: I would like to WHNF here, but that evaluates too aggressively</span>
<span class="lineno"> 2002 </span><span class="spaces">         </span><span class="istickedoff">-- because scWhnf evaluates strictly through the `Eq` datatype former.</span>
<span class="lineno"> 2003 </span><span class="spaces">         </span><span class="istickedoff">-- This breaks some proof examples by unfolding things that need to</span>
<span class="lineno"> 2004 </span><span class="spaces">         </span><span class="istickedoff">-- be uninterpreted.</span>
<span class="lineno"> 2005 </span><span class="spaces">         </span><span class="istickedoff">-- tm' &lt;- scWhnf sc tm</span>
<span class="lineno"> 2006 </span><span class="spaces">         </span><span class="istickedoff">let tm' = tm</span>
<span class="lineno"> 2007 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2008 </span><span class="spaces">         </span><span class="istickedoff">case asPi tm' of</span>
<span class="lineno"> 2009 </span><span class="spaces">           </span><span class="istickedoff">Just (lnm, tp, body) -&gt;</span>
<span class="lineno"> 2010 </span><span class="spaces">             </span><span class="istickedoff">do -- same issue with WHNF</span>
<span class="lineno"> 2011 </span><span class="spaces">                </span><span class="istickedoff">-- tp' &lt;- scWhnf sc tp</span>
<span class="lineno"> 2012 </span><span class="spaces">                </span><span class="istickedoff">let tp' = tp</span>
<span class="lineno"> 2013 </span><span class="spaces">                </span><span class="istickedoff">case evalFOT mmap tp' of</span>
<span class="lineno"> 2014 </span><span class="spaces">                  </span><span class="istickedoff">Just fot -&gt;</span>
<span class="lineno"> 2015 </span><span class="spaces">                    </span><span class="istickedoff">do ec  &lt;- scFreshEC sc lnm tp'</span>
<span class="lineno"> 2016 </span><span class="spaces">                       </span><span class="istickedoff">etm &lt;- scExtCns sc ec</span>
<span class="lineno"> 2017 </span><span class="spaces">                       </span><span class="istickedoff">body' &lt;- instantiateVar sc 0 etm body</span>
<span class="lineno"> 2018 </span><span class="spaces">                       </span><span class="istickedoff">processConcl mmap (Map.insert ec fot vars, xs) body'</span>
<span class="lineno"> 2019 </span><span class="spaces">                  </span><span class="istickedoff">Nothing</span>
<span class="lineno"> 2020 </span><span class="spaces">                    </span><span class="istickedoff">| <span class="tickonlytrue">termIsClosed body</span> -&gt;</span>
<span class="lineno"> 2021 </span><span class="spaces">                        </span><span class="istickedoff">do asrt &lt;- processAssert <span class="nottickedoff">mmap</span> tp</span>
<span class="lineno"> 2022 </span><span class="spaces">                           </span><span class="istickedoff">processConcl <span class="nottickedoff">mmap</span> (vars, asrt : xs) body</span>
<span class="lineno"> 2023 </span><span class="spaces">                    </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno"> 2024 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">fail (&quot;sequentToSATQuery: expected first order type or assertion:\n&quot; ++ showTerm tp')</span></span>
<span class="lineno"> 2025 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2026 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2027 </span><span class="spaces">             </span><span class="istickedoff">case asEqTrue tm' of</span>
<span class="lineno"> 2028 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;sequentToSATQuery: expected EqTrue, actual:\n&quot; ++ showTerm tm'</span></span>
<span class="lineno"> 2029 </span><span class="spaces">               </span><span class="istickedoff">Just tmBool -&gt;</span>
<span class="lineno"> 2030 </span><span class="spaces">                 </span><span class="istickedoff">do tmNeg &lt;- scNot sc tmBool</span>
<span class="lineno"> 2031 </span><span class="spaces">                    </span><span class="istickedoff">return (vars, reverse (BoolAssert tmNeg : xs))</span></span>
<span class="lineno"> 2032 </span>
<span class="lineno"> 2033 </span>-- | Given a prop to prove, attempt to apply another given proposition, producing
<span class="lineno"> 2034 </span>--   new subgoals for any necessary hypotheses of the proposition.  Returns
<span class="lineno"> 2035 </span>--   @Nothing@ if the given proposition does not apply to the goal.
<span class="lineno"> 2036 </span>propApply ::
<span class="lineno"> 2037 </span>  SharedContext -&gt;
<span class="lineno"> 2038 </span>  Prop {- ^ propsition to apply (usually a quantified and/or implication term) -} -&gt;
<span class="lineno"> 2039 </span>  Prop {- ^ goal to apply the proposition to -} -&gt;
<span class="lineno"> 2040 </span>  IO (Maybe [Either Term Prop])
<span class="lineno"> 2041 </span><span class="decl"><span class="istickedoff">propApply sc rule goal = applyFirst (asPiLists (unProp rule))</span>
<span class="lineno"> 2042 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2043 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2044 </span><span class="spaces">    </span><span class="istickedoff">applyFirst [] = <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno"> 2045 </span><span class="spaces">    </span><span class="istickedoff">applyFirst ((ruleArgs, ruleConcl) : rest) =</span>
<span class="lineno"> 2046 </span><span class="spaces">      </span><span class="istickedoff">do result &lt;- scMatch <span class="nottickedoff">sc</span> ruleConcl (unProp goal)</span>
<span class="lineno"> 2047 </span><span class="spaces">         </span><span class="istickedoff">case result of</span>
<span class="lineno"> 2048 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">applyFirst rest</span></span>
<span class="lineno"> 2049 </span><span class="spaces">           </span><span class="istickedoff">Just inst -&gt;</span>
<span class="lineno"> 2050 </span><span class="spaces">             </span><span class="istickedoff">do let inst' = [ Map.lookup i inst | i &lt;- take (length ruleArgs) [0..] ]</span>
<span class="lineno"> 2051 </span><span class="spaces">                </span><span class="istickedoff">dummy &lt;- scUnitType sc</span>
<span class="lineno"> 2052 </span><span class="spaces">                </span><span class="istickedoff">let mkNewGoals (Nothing : mts) ((nm, prop) : args) =</span>
<span class="lineno"> 2053 </span><span class="spaces">                      </span><span class="istickedoff">do c0 &lt;- instantiateVarList sc 0 (map (fromMaybe <span class="nottickedoff">dummy</span>) mts) prop</span>
<span class="lineno"> 2054 </span><span class="spaces">                         </span><span class="istickedoff">mp &lt;- termToMaybeProp sc c0</span>
<span class="lineno"> 2055 </span><span class="spaces">                         </span><span class="istickedoff">case mp of</span>
<span class="lineno"> 2056 </span><span class="spaces">                           </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2057 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">fail (&quot;goal_apply: could not find instantiation for &quot; ++ show nm)</span></span>
<span class="lineno"> 2058 </span><span class="spaces">                           </span><span class="istickedoff">Just p -&gt;</span>
<span class="lineno"> 2059 </span><span class="spaces">                             </span><span class="istickedoff">do cs &lt;- mkNewGoals mts args</span>
<span class="lineno"> 2060 </span><span class="spaces">                                </span><span class="istickedoff">return (Right p : cs)</span>
<span class="lineno"> 2061 </span><span class="spaces">                    </span><span class="istickedoff">mkNewGoals (Just tm : mts) (_ : args) =</span>
<span class="lineno"> 2062 </span><span class="spaces">                      </span><span class="istickedoff">do cs &lt;- mkNewGoals mts args</span>
<span class="lineno"> 2063 </span><span class="spaces">                         </span><span class="istickedoff">return (Left tm : cs)</span>
<span class="lineno"> 2064 </span><span class="spaces">                    </span><span class="istickedoff">mkNewGoals _ _ = return []</span>
<span class="lineno"> 2065 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2066 </span><span class="spaces">                </span><span class="istickedoff">newgoalterms &lt;- mkNewGoals inst' (reverse ruleArgs)</span>
<span class="lineno"> 2067 </span><span class="spaces">                </span><span class="istickedoff">return (Just (reverse newgoalterms))</span>
<span class="lineno"> 2068 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2069 </span><span class="spaces">    </span><span class="istickedoff">asPiLists :: Term -&gt; [([(Text, Term)], Term)]</span>
<span class="lineno"> 2070 </span><span class="spaces">    </span><span class="istickedoff">asPiLists t =</span>
<span class="lineno"> 2071 </span><span class="spaces">      </span><span class="istickedoff">case asPi t of</span>
<span class="lineno"> 2072 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; [([], t)]</span>
<span class="lineno"> 2073 </span><span class="spaces">        </span><span class="istickedoff">Just (nm, tp, body) -&gt;</span>
<span class="lineno"> 2074 </span><span class="spaces">          </span><span class="istickedoff">[ ((<span class="nottickedoff">nm</span>, tp) : args, concl) | (args, concl) &lt;- asPiLists body ] ++ <span class="nottickedoff">[([], t)]</span></span></span>
<span class="lineno"> 2075 </span>
<span class="lineno"> 2076 </span>
<span class="lineno"> 2077 </span>-- | Attempt to prove a universally quantified goal by introducing a fresh variable
<span class="lineno"> 2078 </span>--   for the binder. Return the generated fresh term.
<span class="lineno"> 2079 </span>tacticIntro :: (F.MonadFail m, MonadIO m) =&gt;
<span class="lineno"> 2080 </span>  SharedContext -&gt;
<span class="lineno"> 2081 </span>  Text {- ^ Name to give to the variable.  If empty, will be chosen automatically from the goal. -} -&gt;
<span class="lineno"> 2082 </span>  Tactic m TypedTerm
<span class="lineno"> 2083 </span><span class="decl"><span class="istickedoff">tacticIntro sc usernm = Tactic \goal -&gt;</span>
<span class="lineno"> 2084 </span><span class="spaces">  </span><span class="istickedoff">case sequentState (goalSequent goal) of</span>
<span class="lineno"> 2085 </span><span class="spaces">    </span><span class="istickedoff">ConclFocus p mkSqt -&gt;</span>
<span class="lineno"> 2086 </span><span class="spaces">      </span><span class="istickedoff">case asPi (unProp p) of</span>
<span class="lineno"> 2087 </span><span class="spaces">        </span><span class="istickedoff">Just (nm, tp, body) -&gt;</span>
<span class="lineno"> 2088 </span><span class="spaces">          </span><span class="istickedoff">do let name = if <span class="tickonlyfalse">Text.null usernm</span> then <span class="nottickedoff">nm</span> else usernm</span>
<span class="lineno"> 2089 </span><span class="spaces">             </span><span class="istickedoff">xv &lt;- liftIO $ scFreshEC sc name tp</span>
<span class="lineno"> 2090 </span><span class="spaces">             </span><span class="istickedoff">x  &lt;- liftIO $ scExtCns sc xv</span>
<span class="lineno"> 2091 </span><span class="spaces">             </span><span class="istickedoff">tt &lt;- liftIO $ mkTypedTerm sc x</span>
<span class="lineno"> 2092 </span><span class="spaces">             </span><span class="istickedoff">body' &lt;- liftIO $ instantiateVar sc 0 x body</span>
<span class="lineno"> 2093 </span><span class="spaces">             </span><span class="istickedoff">let goal' = goal { goalSequent = mkSqt (Prop body') }</span>
<span class="lineno"> 2094 </span><span class="spaces">             </span><span class="istickedoff">return (<span class="nottickedoff">tt</span>, <span class="nottickedoff">mempty</span>, [goal'], introEvidence xv)</span>
<span class="lineno"> 2095 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2096 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;intro tactic failed: not a function&quot;</span></span>
<span class="lineno"> 2097 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2098 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;intro tactic: conclusion focus required&quot;</span></span></span>
<span class="lineno"> 2099 </span>
<span class="lineno"> 2100 </span>-- | Given a focused conclusion, decompose the conclusion along implications by
<span class="lineno"> 2101 </span>--   introducing new hypotheses.  The given integer indicates how many hypotheses
<span class="lineno"> 2102 </span>--   to introduce.
<span class="lineno"> 2103 </span>tacticIntroHyps :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Integer -&gt; Tactic m ()
<span class="lineno"> 2104 </span><span class="decl"><span class="nottickedoff">tacticIntroHyps sc n = Tactic \goal -&gt;</span>
<span class="lineno"> 2105 </span><span class="spaces">  </span><span class="nottickedoff">case goalSequent goal of</span>
<span class="lineno"> 2106 </span><span class="spaces">    </span><span class="nottickedoff">ConclFocusedSequent hs (FB gs1 g gs2) -&gt;</span>
<span class="lineno"> 2107 </span><span class="spaces">      </span><span class="nottickedoff">do (newhs, g') &lt;- liftIO (loop n g)</span>
<span class="lineno"> 2108 </span><span class="spaces">         </span><span class="nottickedoff">let sqt' = ConclFocusedSequent (hs ++ newhs) (FB gs1 g' gs2)</span>
<span class="lineno"> 2109 </span><span class="spaces">         </span><span class="nottickedoff">let goal' = goal{ goalSequent = sqt' }</span>
<span class="lineno"> 2110 </span><span class="spaces">         </span><span class="nottickedoff">return ((), mempty, [goal'], updateEvidence (NormalizeSequentEvidence sqt'))</span>
<span class="lineno"> 2111 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail &quot;goal_intro_hyps: conclusion focus required&quot;</span>
<span class="lineno"> 2112 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2113 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno"> 2114 </span><span class="spaces">   </span><span class="nottickedoff">loop i g</span>
<span class="lineno"> 2115 </span><span class="spaces">     </span><span class="nottickedoff">| i &lt;= 0 = return ([],g)</span>
<span class="lineno"> 2116 </span><span class="spaces">     </span><span class="nottickedoff">| otherwise =</span>
<span class="lineno"> 2117 </span><span class="spaces">         </span><span class="nottickedoff">splitImpl sc g &gt;&gt;= \case</span>
<span class="lineno"> 2118 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; fail &quot;intro_hyps: could not find enough hypotheses to introduce&quot;</span>
<span class="lineno"> 2119 </span><span class="spaces">           </span><span class="nottickedoff">Just (h,g') -&gt;</span>
<span class="lineno"> 2120 </span><span class="spaces">             </span><span class="nottickedoff">do (hs,g'') &lt;- loop (i-1) g'</span>
<span class="lineno"> 2121 </span><span class="spaces">                </span><span class="nottickedoff">return (h:hs, g'')</span></span>
<span class="lineno"> 2122 </span>
<span class="lineno"> 2123 </span>tacticRevertHyp :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Integer -&gt; Tactic m ()
<span class="lineno"> 2124 </span><span class="decl"><span class="nottickedoff">tacticRevertHyp sc i = Tactic \goal -&gt;</span>
<span class="lineno"> 2125 </span><span class="spaces">  </span><span class="nottickedoff">case goalSequent goal of</span>
<span class="lineno"> 2126 </span><span class="spaces">    </span><span class="nottickedoff">ConclFocusedSequent hs (FB gs1 g gs2) -&gt;</span>
<span class="lineno"> 2127 </span><span class="spaces">      </span><span class="nottickedoff">case genericDrop i hs of</span>
<span class="lineno"> 2128 </span><span class="spaces">        </span><span class="nottickedoff">(h:_) -&gt;</span>
<span class="lineno"> 2129 </span><span class="spaces">          </span><span class="nottickedoff">case (asEqTrue (unProp h), asEqTrue (unProp g)) of</span>
<span class="lineno"> 2130 </span><span class="spaces">            </span><span class="nottickedoff">(Just h', Just g') -&gt;</span>
<span class="lineno"> 2131 </span><span class="spaces">              </span><span class="nottickedoff">do g'' &lt;- liftIO (Prop &lt;$&gt; (scEqTrue sc =&lt;&lt; scImplies sc h' g'))</span>
<span class="lineno"> 2132 </span><span class="spaces">                 </span><span class="nottickedoff">let sqt' = ConclFocusedSequent hs (FB gs1 g'' gs2)</span>
<span class="lineno"> 2133 </span><span class="spaces">                 </span><span class="nottickedoff">let goal' = goal{ goalSequent = sqt' }</span>
<span class="lineno"> 2134 </span><span class="spaces">                 </span><span class="nottickedoff">return ((), mempty, [goal'], updateEvidence (NormalizeSequentEvidence sqt'))</span>
<span class="lineno"> 2135 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2136 </span><span class="spaces">            </span><span class="nottickedoff">_ -&gt; fail &quot;goal_revert_hyp: expected EqTrue props&quot;</span>
<span class="lineno"> 2137 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; fail &quot;goal_revert_hyp: not enough hypotheses&quot;</span>
<span class="lineno"> 2138 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail &quot;goal_revert_hyp: conclusion focus required&quot;</span></span>
<span class="lineno"> 2139 </span>
<span class="lineno"> 2140 </span>
<span class="lineno"> 2141 </span>-- | Attempt to prove a goal by applying a local hypothesis.  Any hypotheses of
<span class="lineno"> 2142 </span>--   the applied proposition will generate additional subgoals.
<span class="lineno"> 2143 </span>tacticApplyHyp :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Integer -&gt; Tactic m ()
<span class="lineno"> 2144 </span><span class="decl"><span class="nottickedoff">tacticApplyHyp sc n = Tactic \goal -&gt;</span>
<span class="lineno"> 2145 </span><span class="spaces">  </span><span class="nottickedoff">case goalSequent goal of</span>
<span class="lineno"> 2146 </span><span class="spaces">    </span><span class="nottickedoff">UnfocusedSequent{} -&gt; fail &quot;apply hyp tactic: focus required&quot;</span>
<span class="lineno"> 2147 </span><span class="spaces">    </span><span class="nottickedoff">HypFocusedSequent{} -&gt; fail &quot;apply hyp tactic: cannot apply in a hypothesis&quot;</span>
<span class="lineno"> 2148 </span><span class="spaces">    </span><span class="nottickedoff">ConclFocusedSequent hs (FB gs1 g gs2) -&gt;</span>
<span class="lineno"> 2149 </span><span class="spaces">      </span><span class="nottickedoff">case genericDrop n hs of</span>
<span class="lineno"> 2150 </span><span class="spaces">        </span><span class="nottickedoff">(h:_) -&gt;</span>
<span class="lineno"> 2151 </span><span class="spaces">          </span><span class="nottickedoff">liftIO (propApply sc h g) &gt;&gt;= \case</span>
<span class="lineno"> 2152 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt; fail &quot;apply hyp tactic: no match&quot;</span>
<span class="lineno"> 2153 </span><span class="spaces">            </span><span class="nottickedoff">Just newterms -&gt;</span>
<span class="lineno"> 2154 </span><span class="spaces">              </span><span class="nottickedoff">let newgoals =</span>
<span class="lineno"> 2155 </span><span class="spaces">                    </span><span class="nottickedoff">[ goal{ goalSequent = ConclFocusedSequent hs (FB gs1 p gs2)</span>
<span class="lineno"> 2156 </span><span class="spaces">                          </span><span class="nottickedoff">, goalType = goalType goal ++ &quot;.subgoal&quot; ++ show i</span>
<span class="lineno"> 2157 </span><span class="spaces">                          </span><span class="nottickedoff">}</span>
<span class="lineno"> 2158 </span><span class="spaces">                    </span><span class="nottickedoff">| Right p &lt;- newterms</span>
<span class="lineno"> 2159 </span><span class="spaces">                    </span><span class="nottickedoff">| i &lt;- [0::Integer ..]</span>
<span class="lineno"> 2160 </span><span class="spaces">                    </span><span class="nottickedoff">] in</span>
<span class="lineno"> 2161 </span><span class="spaces">              </span><span class="nottickedoff">return ((), mempty, newgoals, \es -&gt; ApplyHypEvidence n &lt;$&gt; processEvidence newterms es)</span>
<span class="lineno"> 2162 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; fail &quot;apply hyp tactic: not enough hypotheses&quot;</span>
<span class="lineno"> 2163 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2164 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno"> 2165 </span><span class="spaces">   </span><span class="nottickedoff">processEvidence :: [Either Term Prop] -&gt; [Evidence] -&gt; IO [Either Term Evidence]</span>
<span class="lineno"> 2166 </span><span class="spaces">   </span><span class="nottickedoff">processEvidence (Left tm : xs) es     = (Left tm :) &lt;$&gt; processEvidence xs es</span>
<span class="lineno"> 2167 </span><span class="spaces">   </span><span class="nottickedoff">processEvidence (Right _ : xs) (e:es) = (Right e :) &lt;$&gt; processEvidence xs es</span>
<span class="lineno"> 2168 </span><span class="spaces">   </span><span class="nottickedoff">processEvidence []             []     = pure []</span>
<span class="lineno"> 2169 </span><span class="spaces">   </span><span class="nottickedoff">processEvidence _ _ = fail &quot;apply hyp tactic failed: evidence mismatch&quot;</span></span>
<span class="lineno"> 2170 </span>
<span class="lineno"> 2171 </span>
<span class="lineno"> 2172 </span>-- | Attempt to prove a goal by applying the given theorem.  Any hypotheses of
<span class="lineno"> 2173 </span>--   the theorem will generate additional subgoals.
<span class="lineno"> 2174 </span>tacticApply :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Theorem -&gt; Tactic m ()
<span class="lineno"> 2175 </span><span class="decl"><span class="istickedoff">tacticApply sc thm = Tactic \goal -&gt;</span>
<span class="lineno"> 2176 </span><span class="spaces">  </span><span class="istickedoff">case sequentState (goalSequent goal) of</span>
<span class="lineno"> 2177 </span><span class="spaces">    </span><span class="istickedoff">Unfocused -&gt; <span class="nottickedoff">fail &quot;apply tactic: focus required&quot;</span></span>
<span class="lineno"> 2178 </span><span class="spaces">    </span><span class="istickedoff">HypFocus _ _ -&gt; <span class="nottickedoff">fail &quot;apply tactic: cannot apply in a hypothesis&quot;</span></span>
<span class="lineno"> 2179 </span><span class="spaces">    </span><span class="istickedoff">ConclFocus gl mkSqt -&gt;</span>
<span class="lineno"> 2180 </span><span class="spaces">      </span><span class="istickedoff">liftIO (propApply sc (thmProp thm) gl) &gt;&gt;= \case</span>
<span class="lineno"> 2181 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;apply tactic failed: no match&quot;</span></span>
<span class="lineno"> 2182 </span><span class="spaces">        </span><span class="istickedoff">Just newterms -&gt;</span>
<span class="lineno"> 2183 </span><span class="spaces">          </span><span class="istickedoff">let newgoals =</span>
<span class="lineno"> 2184 </span><span class="spaces">                </span><span class="istickedoff">[ goal{ goalSequent = mkSqt p, goalType = <span class="nottickedoff">goalType goal ++ &quot;.subgoal&quot; ++ show i</span> }</span>
<span class="lineno"> 2185 </span><span class="spaces">                </span><span class="istickedoff">| Right p &lt;- newterms</span>
<span class="lineno"> 2186 </span><span class="spaces">                </span><span class="istickedoff">| i &lt;- [0::Integer ..]</span>
<span class="lineno"> 2187 </span><span class="spaces">                </span><span class="istickedoff">] in</span>
<span class="lineno"> 2188 </span><span class="spaces">          </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, <span class="nottickedoff">mempty</span>, newgoals, \es -&gt; ApplyEvidence thm &lt;$&gt; processEvidence newterms es)</span>
<span class="lineno"> 2189 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2190 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno"> 2191 </span><span class="spaces">   </span><span class="istickedoff">processEvidence :: [Either Term Prop] -&gt; [Evidence] -&gt; IO [Either Term Evidence]</span>
<span class="lineno"> 2192 </span><span class="spaces">   </span><span class="istickedoff">processEvidence (Left tm : xs) es     = (Left tm :) &lt;$&gt; processEvidence xs es</span>
<span class="lineno"> 2193 </span><span class="spaces">   </span><span class="istickedoff">processEvidence (Right _ : xs) (e:es) = (Right e :) &lt;$&gt; processEvidence xs es</span>
<span class="lineno"> 2194 </span><span class="spaces">   </span><span class="istickedoff">processEvidence []             []     = pure []</span>
<span class="lineno"> 2195 </span><span class="spaces">   </span><span class="istickedoff">processEvidence _ _ = <span class="nottickedoff">fail &quot;apply tactic failed: evidence mismatch&quot;</span></span></span>
<span class="lineno"> 2196 </span>
<span class="lineno"> 2197 </span>-- | Attempt to simplify a goal by splitting it along conjunctions, disjunctions,
<span class="lineno"> 2198 </span>--   implication or if/then/else.  If successful, two subgoals will be produced,
<span class="lineno"> 2199 </span>--   representing the two subgoals that must be proved.
<span class="lineno"> 2200 </span>tacticSplit :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Tactic m ()
<span class="lineno"> 2201 </span><span class="decl"><span class="nottickedoff">tacticSplit sc = Tactic \gl -&gt;</span>
<span class="lineno"> 2202 </span><span class="spaces">  </span><span class="nottickedoff">liftIO (splitSequent sc (goalSequent gl)) &gt;&gt;= \case</span>
<span class="lineno"> 2203 </span><span class="spaces">    </span><span class="nottickedoff">Just (sqt1, sqt2) -&gt;</span>
<span class="lineno"> 2204 </span><span class="spaces">      </span><span class="nottickedoff">do let g1 = gl{ goalType = goalType gl ++ &quot;.l&quot;, goalSequent = sqt1 }</span>
<span class="lineno"> 2205 </span><span class="spaces">         </span><span class="nottickedoff">let g2 = gl{ goalType = goalType gl ++ &quot;.r&quot;, goalSequent = sqt2 }</span>
<span class="lineno"> 2206 </span><span class="spaces">         </span><span class="nottickedoff">return ((), mempty, [g1,g2], splitEvidence)</span>
<span class="lineno"> 2207 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail &quot;split tactic failed&quot;</span></span>
<span class="lineno"> 2208 </span>
<span class="lineno"> 2209 </span>-- | Specialize a focused hypothesis with the given terms. A new specialized
<span class="lineno"> 2210 </span>--   hypothesis will be added to the sequent; the original hypothesis will
<span class="lineno"> 2211 </span>--   remain focused.
<span class="lineno"> 2212 </span>tacticSpecializeHyp ::
<span class="lineno"> 2213 </span>  (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; [Term] -&gt; Tactic m ()
<span class="lineno"> 2214 </span><span class="decl"><span class="nottickedoff">tacticSpecializeHyp sc ts = Tactic \gl -&gt;</span>
<span class="lineno"> 2215 </span><span class="spaces">  </span><span class="nottickedoff">case goalSequent gl of</span>
<span class="lineno"> 2216 </span><span class="spaces">    </span><span class="nottickedoff">HypFocusedSequent (FB hs1 h hs2) gs -&gt;</span>
<span class="lineno"> 2217 </span><span class="spaces">      </span><span class="nottickedoff">do res &lt;- liftIO (specializeProp sc h ts)</span>
<span class="lineno"> 2218 </span><span class="spaces">         </span><span class="nottickedoff">case res of</span>
<span class="lineno"> 2219 </span><span class="spaces">           </span><span class="nottickedoff">Left err -&gt;</span>
<span class="lineno"> 2220 </span><span class="spaces">             </span><span class="nottickedoff">fail (unlines ([&quot;specialize_hyp tactic: failed to specialize&quot;] ++ TC.prettyTCError err))</span>
<span class="lineno"> 2221 </span><span class="spaces">           </span><span class="nottickedoff">Right h' -&gt;</span>
<span class="lineno"> 2222 </span><span class="spaces">             </span><span class="nottickedoff">do let gl' = gl{ goalSequent = HypFocusedSequent (FB hs1 h (hs2++[h'])) gs }</span>
<span class="lineno"> 2223 </span><span class="spaces">                </span><span class="nottickedoff">return ((), mempty, [gl'], specializeHypEvidence (genericLength hs1) h' ts)</span>
<span class="lineno"> 2224 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; fail &quot;specialize_hyp tactic failed: requires hypothesis focus&quot;</span></span>
<span class="lineno"> 2225 </span>
<span class="lineno"> 2226 </span>
<span class="lineno"> 2227 </span>-- | This tactic adds a new hypothesis to the current goal by first specializing the
<span class="lineno"> 2228 </span>--   given theorem with the list of terms provided and then using cut to add the
<span class="lineno"> 2229 </span>--   hypothesis, discharging the produced additional goal by applying the theorem.
<span class="lineno"> 2230 </span>tacticInsert :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Theorem -&gt; [Term] -&gt; Tactic m ()
<span class="lineno"> 2231 </span><span class="decl"><span class="istickedoff">tacticInsert sc thm ts = Tactic \gl -&gt;</span>
<span class="lineno"> 2232 </span><span class="spaces">  </span><span class="istickedoff">do res &lt;- liftIO (specializeProp <span class="nottickedoff">sc</span> (_thmProp thm) ts)</span>
<span class="lineno"> 2233 </span><span class="spaces">     </span><span class="istickedoff">case res of</span>
<span class="lineno"> 2234 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt;</span>
<span class="lineno"> 2235 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">fail (unlines ([&quot;goal_insert_and_specialize tactic: failed to specialize&quot;] ++</span></span>
<span class="lineno"> 2236 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff">TC.prettyTCError err))</span></span>
<span class="lineno"> 2237 </span><span class="spaces">       </span><span class="istickedoff">Right h -&gt;</span>
<span class="lineno"> 2238 </span><span class="spaces">         </span><span class="istickedoff">do let gl' = gl{ goalSequent = addHypothesis h (goalSequent gl) }</span>
<span class="lineno"> 2239 </span><span class="spaces">            </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, <span class="nottickedoff">mempty</span>, [gl'], insertEvidence thm h ts)</span></span>
<span class="lineno"> 2240 </span>
<span class="lineno"> 2241 </span>-- | This tactic implements the &quot;cut rule&quot; of sequent calculus.  The given
<span class="lineno"> 2242 </span>--   proposition is used to split the current goal into two goals, one where
<span class="lineno"> 2243 </span>--   the given proposition is assumed as a new hypothesis, and a second
<span class="lineno"> 2244 </span>--   where the proposition is added as a new conclusion to prove.
<span class="lineno"> 2245 </span>--
<span class="lineno"> 2246 </span>--         HS, X |- GS
<span class="lineno"> 2247 </span>--         HS    |- GS, X
<span class="lineno"> 2248 </span>--       ------------------ (Cut)
<span class="lineno"> 2249 </span>--         HS    |- GS
<span class="lineno"> 2250 </span>tacticCut :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Prop -&gt; Tactic m ()
<span class="lineno"> 2251 </span><span class="decl"><span class="nottickedoff">tacticCut _sc p = Tactic \gl -&gt;</span>
<span class="lineno"> 2252 </span><span class="spaces">  </span><span class="nottickedoff">let sqt1 = addHypothesis p (goalSequent gl)</span>
<span class="lineno"> 2253 </span><span class="spaces">      </span><span class="nottickedoff">sqt2 = addNewFocusedConcl p (goalSequent gl)</span>
<span class="lineno"> 2254 </span><span class="spaces">      </span><span class="nottickedoff">g1 = gl{ goalType = goalType gl ++ &quot;.cutH&quot;, goalSequent = sqt1 }</span>
<span class="lineno"> 2255 </span><span class="spaces">      </span><span class="nottickedoff">g2 = gl{ goalType = goalType gl ++ &quot;.cutG&quot;, goalSequent = sqt2 }</span>
<span class="lineno"> 2256 </span><span class="spaces">   </span><span class="nottickedoff">in return ((), mempty, [g1, g2], cutEvidence p)</span></span>
<span class="lineno"> 2257 </span>
<span class="lineno"> 2258 </span>-- | Attempt to solve a goal by recognizing it as a trivially true proposition.
<span class="lineno"> 2259 </span>tacticTrivial :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Tactic m ()
<span class="lineno"> 2260 </span><span class="decl"><span class="istickedoff">tacticTrivial sc = Tactic \goal -&gt;</span>
<span class="lineno"> 2261 </span><span class="spaces">  </span><span class="istickedoff">case sequentState (goalSequent goal) of</span>
<span class="lineno"> 2262 </span><span class="spaces">    </span><span class="istickedoff">Unfocused -&gt; <span class="nottickedoff">fail &quot;trivial tactic: focus required&quot;</span></span>
<span class="lineno"> 2263 </span><span class="spaces">    </span><span class="istickedoff">HypFocus _ _ -&gt; <span class="nottickedoff">fail &quot;trivial tactic: cannot apply trivial in a hypothesis&quot;</span></span>
<span class="lineno"> 2264 </span><span class="spaces">    </span><span class="istickedoff">ConclFocus g _ -&gt;</span>
<span class="lineno"> 2265 </span><span class="spaces">      </span><span class="istickedoff">liftIO (trivialProofTerm sc g) &gt;&gt;= \case</span>
<span class="lineno"> 2266 </span><span class="spaces">        </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">fail err</span></span>
<span class="lineno"> 2267 </span><span class="spaces">        </span><span class="istickedoff">Right pf -&gt;</span>
<span class="lineno"> 2268 </span><span class="spaces">           </span><span class="istickedoff">do let gp = unProp g</span>
<span class="lineno"> 2269 </span><span class="spaces">              </span><span class="istickedoff">ty &lt;- liftIO $ TC.scTypeCheckError sc pf</span>
<span class="lineno"> 2270 </span><span class="spaces">              </span><span class="istickedoff">ok &lt;- liftIO $ scConvertible sc <span class="nottickedoff">True</span> gp ty</span>
<span class="lineno"> 2271 </span><span class="spaces">              </span><span class="istickedoff">unless ok $ fail $ unlines</span>
<span class="lineno"> 2272 </span><span class="spaces">                </span><span class="istickedoff">[ &quot;The trivial tactic cannot prove this equality&quot;</span>
<span class="lineno"> 2273 </span><span class="spaces">                </span><span class="istickedoff">, showTerm gp</span>
<span class="lineno"> 2274 </span><span class="spaces">                </span><span class="istickedoff">]</span>
<span class="lineno"> 2275 </span><span class="spaces">              </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, <span class="nottickedoff">mempty</span>, [], leafEvidence (ProofTerm pf))</span></span>
<span class="lineno"> 2276 </span>
<span class="lineno"> 2277 </span>-- | Attempt to prove a goal by giving a direct proof term.
<span class="lineno"> 2278 </span>tacticExact :: (F.MonadFail m, MonadIO m) =&gt; SharedContext -&gt; Term -&gt; Tactic m ()
<span class="lineno"> 2279 </span><span class="decl"><span class="nottickedoff">tacticExact sc tm = Tactic \goal -&gt;</span>
<span class="lineno"> 2280 </span><span class="spaces">  </span><span class="nottickedoff">case sequentState (goalSequent goal) of</span>
<span class="lineno"> 2281 </span><span class="spaces">    </span><span class="nottickedoff">Unfocused -&gt; fail &quot;tactic exact: focus required&quot;</span>
<span class="lineno"> 2282 </span><span class="spaces">    </span><span class="nottickedoff">HypFocus _ _ -&gt; fail &quot;tactic exact: cannot apply exact in a hypothesis&quot;</span>
<span class="lineno"> 2283 </span><span class="spaces">    </span><span class="nottickedoff">ConclFocus g _ -&gt;</span>
<span class="lineno"> 2284 </span><span class="spaces">      </span><span class="nottickedoff">do let gp = unProp g</span>
<span class="lineno"> 2285 </span><span class="spaces">         </span><span class="nottickedoff">ty &lt;- liftIO $ TC.scTypeCheckError sc tm</span>
<span class="lineno"> 2286 </span><span class="spaces">         </span><span class="nottickedoff">ok &lt;- liftIO $ scConvertible sc True gp ty</span>
<span class="lineno"> 2287 </span><span class="spaces">         </span><span class="nottickedoff">unless ok $ fail $ unlines</span>
<span class="lineno"> 2288 </span><span class="spaces">             </span><span class="nottickedoff">[ &quot;Proof term does not prove the required proposition&quot;</span>
<span class="lineno"> 2289 </span><span class="spaces">             </span><span class="nottickedoff">, showTerm gp</span>
<span class="lineno"> 2290 </span><span class="spaces">             </span><span class="nottickedoff">, showTerm tm</span>
<span class="lineno"> 2291 </span><span class="spaces">             </span><span class="nottickedoff">]</span>
<span class="lineno"> 2292 </span><span class="spaces">         </span><span class="nottickedoff">return ((), mempty, [], leafEvidence (ProofTerm tm))</span></span>
<span class="lineno"> 2293 </span>
<span class="lineno"> 2294 </span>
<span class="lineno"> 2295 </span>-- | Examine the given proof goal and potentially do some work with it,
<span class="lineno"> 2296 </span>--   but do not alter the proof state.
<span class="lineno"> 2297 </span>tacticId :: Monad m =&gt; (ProofGoal -&gt; m a) -&gt; Tactic m a
<span class="lineno"> 2298 </span><span class="decl"><span class="istickedoff">tacticId f = Tactic \gl -&gt;</span>
<span class="lineno"> 2299 </span><span class="spaces">  </span><span class="istickedoff">do x &lt;- lift (f gl)</span>
<span class="lineno"> 2300 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">x</span>, <span class="nottickedoff">mempty</span>, [gl], passthroughEvidence)</span></span>
<span class="lineno"> 2301 </span>
<span class="lineno"> 2302 </span>data SolveResult
<span class="lineno"> 2303 </span>  = SolveSuccess Evidence
<span class="lineno"> 2304 </span>  | SolveCounterexample CEX
<span class="lineno"> 2305 </span>  | SolveUnknown
<span class="lineno"> 2306 </span>
<span class="lineno"> 2307 </span>-- | Attempt to solve the given goal, usually via an automatic solver.
<span class="lineno"> 2308 </span>--   If the goal is discharged, return evidence for the goal.  If there
<span class="lineno"> 2309 </span>--   is a counterexample for the goal, the counterexample will be used
<span class="lineno"> 2310 </span>--   to indicate the goal is unsolvable. Otherwise, the goal will remain unchanged.
<span class="lineno"> 2311 </span>tacticSolve :: Monad m =&gt; (ProofGoal -&gt; m (SolverStats, SolveResult)) -&gt; Tactic m ()
<span class="lineno"> 2312 </span><span class="decl"><span class="istickedoff">tacticSolve f = Tactic \gl -&gt;</span>
<span class="lineno"> 2313 </span><span class="spaces">  </span><span class="istickedoff">do (stats, sres) &lt;- lift (f gl)</span>
<span class="lineno"> 2314 </span><span class="spaces">     </span><span class="istickedoff">case sres of</span>
<span class="lineno"> 2315 </span><span class="spaces">       </span><span class="istickedoff">SolveSuccess e -&gt; return (<span class="nottickedoff">()</span>, <span class="nottickedoff">stats</span>, [], leafEvidence e)</span>
<span class="lineno"> 2316 </span><span class="spaces">       </span><span class="istickedoff">SolveUnknown   -&gt; <span class="nottickedoff">return ((), stats, [gl], passthroughEvidence)</span></span>
<span class="lineno"> 2317 </span><span class="spaces">       </span><span class="istickedoff">SolveCounterexample cex -&gt; throwError (stats, cex)</span></span>
<span class="lineno"> 2318 </span>
<span class="lineno"> 2319 </span>-- | Attempt to simplify a proof goal via computation, rewriting or similar.
<span class="lineno"> 2320 </span>--   The tactic should return a new proposition to prove and a method for
<span class="lineno"> 2321 </span>--   transferring evidence for the modified proposition into a evidence for
<span class="lineno"> 2322 </span>--   the original goal.
<span class="lineno"> 2323 </span>tacticChange :: Monad m =&gt; (ProofGoal -&gt; m (Sequent, Evidence -&gt; Evidence)) -&gt; Tactic m ()
<span class="lineno"> 2324 </span><span class="decl"><span class="istickedoff">tacticChange f = Tactic \gl -&gt;</span>
<span class="lineno"> 2325 </span><span class="spaces">  </span><span class="istickedoff">do (sqt, ef) &lt;- lift (f gl)</span>
<span class="lineno"> 2326 </span><span class="spaces">     </span><span class="istickedoff">return (<span class="nottickedoff">()</span>, <span class="nottickedoff">mempty</span>, [ gl{ goalSequent = sqt } ], updateEvidence ef)</span></span>

</pre>
</body>
</html>
