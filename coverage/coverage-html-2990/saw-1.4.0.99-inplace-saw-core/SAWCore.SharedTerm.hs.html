<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    2 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    3 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    4 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>{- |
<span class="lineno">    7 </span>Module      : SAWCore.SharedTerm
<span class="lineno">    8 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    9 </span>License     : BSD3
<span class="lineno">   10 </span>Maintainer  : saw@galois.com
<span class="lineno">   11 </span>Stability   : experimental
<span class="lineno">   12 </span>Portability : non-portable (language extensions)
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>&quot;SAWCore.SharedTerm&quot; is the standard API for building and using
<span class="lineno">   15 </span>SAWCore terms.
<span class="lineno">   16 </span>The API is built around 'SharedContext' and 'IO': Most functions take
<span class="lineno">   17 </span>a 'SharedContext' as the first argument and return results in the 'IO'
<span class="lineno">   18 </span>monad.
<span class="lineno">   19 </span>Functions with types of this form are recognized by the @sc@ prefix.
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>The API guarantees that all 'Term's are well-formed and well-typed
<span class="lineno">   22 </span>with respect to the declarations in the 'SharedContext' they were
<span class="lineno">   23 </span>constructed with.
<span class="lineno">   24 </span>Attempting to construct an invalid term will result in a failure
<span class="lineno">   25 </span>thrown in the 'IO' monad with a pretty-printed error message.
<span class="lineno">   26 </span>-}
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>module SAWCore.SharedTerm
<span class="lineno">   29 </span>  ( -- * Terms
<span class="lineno">   30 </span>    Term -- exported as abstract
<span class="lineno">   31 </span>  , TermF(..)
<span class="lineno">   32 </span>  , Ident, mkIdent
<span class="lineno">   33 </span>  , VarIndex
<span class="lineno">   34 </span>  , NameInfo(..)
<span class="lineno">   35 </span>  , TermIndex
<span class="lineno">   36 </span>  , unwrapTermF
<span class="lineno">   37 </span>  , termIndex
<span class="lineno">   38 </span>  , varTypes
<span class="lineno">   39 </span>  , freeVars
<span class="lineno">   40 </span>  , closedTerm
<span class="lineno">   41 </span>  , termSortOrType
<span class="lineno">   42 </span>  , alphaEquiv
<span class="lineno">   43 </span>    -- * SharedContext
<span class="lineno">   44 </span>  , SharedContext -- abstract type
<span class="lineno">   45 </span>  , mkSharedContext
<span class="lineno">   46 </span>  , scGetModuleMap
<span class="lineno">   47 </span>  , scGetNamingEnv
<span class="lineno">   48 </span>  -- * Pretty printing
<span class="lineno">   49 </span>  , ppTerm
<span class="lineno">   50 </span>  , prettyTerm
<span class="lineno">   51 </span>  , ppTermError
<span class="lineno">   52 </span>  , prettyTermError
<span class="lineno">   53 </span>    -- * Checkpointing
<span class="lineno">   54 </span>  , SharedContextCheckpoint -- abstract type
<span class="lineno">   55 </span>  , checkpointSharedContext
<span class="lineno">   56 </span>  , restoreSharedContext
<span class="lineno">   57 </span>    -- * Names
<span class="lineno">   58 </span>  , scRegisterName
<span class="lineno">   59 </span>  , scFreshName
<span class="lineno">   60 </span>  , scFreshVarName
<span class="lineno">   61 </span>  , scFreshenGlobalIdent
<span class="lineno">   62 </span>  , scResolveName
<span class="lineno">   63 </span>  , scResolveNameByURI
<span class="lineno">   64 </span>    -- * Term builders
<span class="lineno">   65 </span>  , scTermF
<span class="lineno">   66 </span>  , scFlatTermF
<span class="lineno">   67 </span>    -- ** Application
<span class="lineno">   68 </span>  , scApply
<span class="lineno">   69 </span>  , scApplyAll
<span class="lineno">   70 </span>    -- ** Lambda
<span class="lineno">   71 </span>  , scLambda
<span class="lineno">   72 </span>  , scLambdaList
<span class="lineno">   73 </span>  , scLambdaListEtaCollapse
<span class="lineno">   74 </span>  , scAbstractTerms
<span class="lineno">   75 </span>    -- ** Pi
<span class="lineno">   76 </span>  , scPi
<span class="lineno">   77 </span>  , scPiList
<span class="lineno">   78 </span>  , scGeneralizeTerms
<span class="lineno">   79 </span>  , scFun
<span class="lineno">   80 </span>  , scFunAll
<span class="lineno">   81 </span>    -- ** Variables
<span class="lineno">   82 </span>  , scVariable
<span class="lineno">   83 </span>  , scVariables
<span class="lineno">   84 </span>  , scFreshVariable
<span class="lineno">   85 </span>    -- ** Constants
<span class="lineno">   86 </span>  , scConst
<span class="lineno">   87 </span>  , scConstApply
<span class="lineno">   88 </span>  , scGlobalDef
<span class="lineno">   89 </span>  , scGlobalApply
<span class="lineno">   90 </span>    -- ** Sorts
<span class="lineno">   91 </span>  , scSort
<span class="lineno">   92 </span>  , scISort
<span class="lineno">   93 </span>  , scSortWithFlags
<span class="lineno">   94 </span>    -- ** Tuples
<span class="lineno">   95 </span>  , scUnitValue
<span class="lineno">   96 </span>  , scUnitType
<span class="lineno">   97 </span>  , scPairValue
<span class="lineno">   98 </span>  , scPairType
<span class="lineno">   99 </span>  , scPairLeft
<span class="lineno">  100 </span>  , scPairRight
<span class="lineno">  101 </span>  , scPairValueReduced
<span class="lineno">  102 </span>  , scTuple
<span class="lineno">  103 </span>  , scTupleType
<span class="lineno">  104 </span>  , scTupleSelector
<span class="lineno">  105 </span>  , scTupleReduced
<span class="lineno">  106 </span>    -- ** Records
<span class="lineno">  107 </span>  , scRecord
<span class="lineno">  108 </span>  , scRecordValue
<span class="lineno">  109 </span>  , scRecordSelect
<span class="lineno">  110 </span>  , scRecordType
<span class="lineno">  111 </span>    -- ** Recursors
<span class="lineno">  112 </span>  , scRecursor
<span class="lineno">  113 </span>    -- ** Strings
<span class="lineno">  114 </span>  , scString
<span class="lineno">  115 </span>  , scStringType
<span class="lineno">  116 </span>    -- ** Vectors
<span class="lineno">  117 </span>  , scVector
<span class="lineno">  118 </span>  , scVecType
<span class="lineno">  119 </span>  , scVectorReduced
<span class="lineno">  120 </span>    -- * Global declarations
<span class="lineno">  121 </span>  , scDeclarePrim
<span class="lineno">  122 </span>  , scFreshConstant
<span class="lineno">  123 </span>  , scDefineConstant
<span class="lineno">  124 </span>  , scOpaqueConstant
<span class="lineno">  125 </span>  , CtorSpec(..)
<span class="lineno">  126 </span>  , DataTypeSpec(..)
<span class="lineno">  127 </span>  , scDefineDataType
<span class="lineno">  128 </span>    -- * Reduction
<span class="lineno">  129 </span>  , scWhnf
<span class="lineno">  130 </span>  , scConvertible
<span class="lineno">  131 </span>  , scSubtype
<span class="lineno">  132 </span>  , betaNormalize
<span class="lineno">  133 </span>  , scApplyBeta
<span class="lineno">  134 </span>  , scApplyAllBeta
<span class="lineno">  135 </span>  , scInstantiate
<span class="lineno">  136 </span>  , scInstantiateBeta
<span class="lineno">  137 </span>  , scReduceRecursor
<span class="lineno">  138 </span>  , allowedElimSort
<span class="lineno">  139 </span>  , scBuildCtor
<span class="lineno">  140 </span>  , scUnfoldConstants
<span class="lineno">  141 </span>  , scUnfoldConstantsBeta
<span class="lineno">  142 </span>  , scUnfoldOnceFixConstantSet
<span class="lineno">  143 </span>    -- * Type checking
<span class="lineno">  144 </span>  , scTypeOf
<span class="lineno">  145 </span>  , scAscribe
<span class="lineno">  146 </span>  , asSort
<span class="lineno">  147 </span>  , reducePi
<span class="lineno">  148 </span>  , scTypeOfIdent
<span class="lineno">  149 </span>  , scTypeOfName
<span class="lineno">  150 </span>    -- * Modules
<span class="lineno">  151 </span>  , scLoadModule
<span class="lineno">  152 </span>  , scImportModule
<span class="lineno">  153 </span>  , scModuleIsLoaded
<span class="lineno">  154 </span>  , scFindModule
<span class="lineno">  155 </span>  , scFindDef
<span class="lineno">  156 </span>  , scFindDataType
<span class="lineno">  157 </span>  , scFindCtor
<span class="lineno">  158 </span>  , scRequireDef
<span class="lineno">  159 </span>  , scRequireDataType
<span class="lineno">  160 </span>  , scRequireCtor
<span class="lineno">  161 </span>  , scInjectCode
<span class="lineno">  162 </span>    -- * Inspecting terms
<span class="lineno">  163 </span>  , isConstFoldTerm
<span class="lineno">  164 </span>  , getAllVars
<span class="lineno">  165 </span>  , getAllVarsMap
<span class="lineno">  166 </span>  , getConstantSet
<span class="lineno">  167 </span>  , scSharedSize
<span class="lineno">  168 </span>  , scSharedSizeAux
<span class="lineno">  169 </span>  , scSharedSizeMany
<span class="lineno">  170 </span>  , scTreeSize
<span class="lineno">  171 </span>  , scTreeSizeAux
<span class="lineno">  172 </span>  , scTreeSizeMany
<span class="lineno">  173 </span>    -- * Prelude operations
<span class="lineno">  174 </span>    -- ** Booleans
<span class="lineno">  175 </span>  , scEqTrue
<span class="lineno">  176 </span>  , scBool
<span class="lineno">  177 </span>  , scBoolType
<span class="lineno">  178 </span>  , scNot
<span class="lineno">  179 </span>  , scAnd
<span class="lineno">  180 </span>  , scOr
<span class="lineno">  181 </span>  , scImplies
<span class="lineno">  182 </span>  , scXor
<span class="lineno">  183 </span>  , scBoolEq
<span class="lineno">  184 </span>  , scIte
<span class="lineno">  185 </span>  , scAndList
<span class="lineno">  186 </span>  , scOrList
<span class="lineno">  187 </span>  -- ** Natural numbers
<span class="lineno">  188 </span>  , scNat
<span class="lineno">  189 </span>  , scNatType
<span class="lineno">  190 </span>  , scAddNat
<span class="lineno">  191 </span>  , scSubNat
<span class="lineno">  192 </span>  , scMulNat
<span class="lineno">  193 </span>  , scDivNat
<span class="lineno">  194 </span>  , scModNat
<span class="lineno">  195 </span>  , scDivModNat
<span class="lineno">  196 </span>  , scEqualNat
<span class="lineno">  197 </span>  , scLtNat
<span class="lineno">  198 </span>  , scMinNat
<span class="lineno">  199 </span>  , scMaxNat
<span class="lineno">  200 </span>  , scUpdNatFun
<span class="lineno">  201 </span>    -- ** Integers
<span class="lineno">  202 </span>  , scIntegerType
<span class="lineno">  203 </span>  , scIntegerConst
<span class="lineno">  204 </span>  , scIntAdd, scIntSub, scIntMul
<span class="lineno">  205 </span>  , scIntDiv, scIntMod, scIntNeg
<span class="lineno">  206 </span>  , scIntAbs, scIntMin, scIntMax
<span class="lineno">  207 </span>  , scIntEq, scIntLe, scIntLt
<span class="lineno">  208 </span>  , scIntToNat, scNatToInt
<span class="lineno">  209 </span>  , scIntToBv, scBvToInt, scSbvToInt
<span class="lineno">  210 </span>    -- ** IntMod
<span class="lineno">  211 </span>  , scIntModType
<span class="lineno">  212 </span>  , scToIntMod
<span class="lineno">  213 </span>  , scFromIntMod
<span class="lineno">  214 </span>  , scIntModEq
<span class="lineno">  215 </span>  , scIntModAdd
<span class="lineno">  216 </span>  , scIntModSub
<span class="lineno">  217 </span>  , scIntModMul
<span class="lineno">  218 </span>  , scIntModNeg
<span class="lineno">  219 </span>    -- ** Vectors
<span class="lineno">  220 </span>  , scAppend
<span class="lineno">  221 </span>  , scJoin
<span class="lineno">  222 </span>  , scSplit
<span class="lineno">  223 </span>  , scGet
<span class="lineno">  224 </span>  , scAtWithDefault
<span class="lineno">  225 </span>  , scAt
<span class="lineno">  226 </span>  , scSingle
<span class="lineno">  227 </span>  , scSlice
<span class="lineno">  228 </span>    -- ** Bitvectors
<span class="lineno">  229 </span>  , scBitvector
<span class="lineno">  230 </span>  , scBvNat
<span class="lineno">  231 </span>  , scBvToNat
<span class="lineno">  232 </span>  , scBvAt
<span class="lineno">  233 </span>  , scBvConst
<span class="lineno">  234 </span>  , scBvLit
<span class="lineno">  235 </span>  , scBvForall
<span class="lineno">  236 </span>  , scUpdBvFun
<span class="lineno">  237 </span>  , scBvNonzero, scBvBool
<span class="lineno">  238 </span>  , scBvAdd, scBvSub, scBvMul, scBvNeg
<span class="lineno">  239 </span>  , scBvURem, scBvUDiv, scBvSRem, scBvSDiv
<span class="lineno">  240 </span>  , scBvOr, scBvAnd, scBvXor
<span class="lineno">  241 </span>  , scBvNot
<span class="lineno">  242 </span>  , scBvEq, scBvUGe, scBvUGt, scBvULe, scBvULt
<span class="lineno">  243 </span>  , scBvSGt, scBvSGe, scBvSLt, scBvSLe
<span class="lineno">  244 </span>  , scBvShl, scBvShr, scBvSShr
<span class="lineno">  245 </span>  , scBvUExt, scBvSExt
<span class="lineno">  246 </span>  , scBvTrunc
<span class="lineno">  247 </span>  , scBvLg2
<span class="lineno">  248 </span>  , scBvPopcount
<span class="lineno">  249 </span>  , scBvCountLeadingZeros
<span class="lineno">  250 </span>  , scBvCountTrailingZeros
<span class="lineno">  251 </span>  , scLsb, scMsb
<span class="lineno">  252 </span>    -- ** Arrays
<span class="lineno">  253 </span>  , scArrayType
<span class="lineno">  254 </span>  , scArrayConstant
<span class="lineno">  255 </span>  , scArrayLookup
<span class="lineno">  256 </span>  , scArrayUpdate
<span class="lineno">  257 </span>  , scArrayEq
<span class="lineno">  258 </span>  , scArrayCopy
<span class="lineno">  259 </span>  , scArraySet
<span class="lineno">  260 </span>  , scArrayRangeEq
<span class="lineno">  261 </span>  -- * Miscellaneous
<span class="lineno">  262 </span>  , alistAllFields
<span class="lineno">  263 </span>  , scImport
<span class="lineno">  264 </span>  ) where
<span class="lineno">  265 </span>
<span class="lineno">  266 </span>import Control.Applicative
<span class="lineno">  267 </span>-- ((&lt;$&gt;), pure, (&lt;*&gt;))
<span class="lineno">  268 </span>import Control.Exception
<span class="lineno">  269 </span>import Control.Lens
<span class="lineno">  270 </span>import Control.Monad (foldM)
<span class="lineno">  271 </span>import qualified Control.Monad.State.Strict as State
<span class="lineno">  272 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">  273 </span>import Data.Bits
<span class="lineno">  274 </span>import Data.Maybe
<span class="lineno">  275 </span>import qualified Data.Foldable as Fold
<span class="lineno">  276 </span>import Data.Foldable (foldl', foldlM, foldrM)
<span class="lineno">  277 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">  278 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">  279 </span>import qualified Data.IntSet as IntSet
<span class="lineno">  280 </span>import Data.Map (Map)
<span class="lineno">  281 </span>import qualified Data.Map as Map
<span class="lineno">  282 </span>import Data.Ref ( C )
<span class="lineno">  283 </span>import Data.Set (Set)
<span class="lineno">  284 </span>import Data.Text (Text)
<span class="lineno">  285 </span>import qualified Data.Set as Set
<span class="lineno">  286 </span>import Numeric.Natural (Natural)
<span class="lineno">  287 </span>import Prelude hiding (maximum)
<span class="lineno">  288 </span>import qualified Prettyprinter as PP
<span class="lineno">  289 </span>import Text.URI
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>import qualified SAWSupport.IntRangeSet as IntRangeSet
<span class="lineno">  292 </span>import qualified SAWSupport.Pretty as PPS (Doc, Opts, defaultOpts, render)
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>import SAWCore.Cache
<span class="lineno">  295 </span>import SAWCore.Change
<span class="lineno">  296 </span>import SAWCore.Module
<span class="lineno">  297 </span>  ( ctorName
<span class="lineno">  298 </span>  , moduleIsLoaded
<span class="lineno">  299 </span>  , lookupVarIndexInMap
<span class="lineno">  300 </span>  , findCtorInMap
<span class="lineno">  301 </span>  , findDataTypeInMap
<span class="lineno">  302 </span>  , findDefInMap
<span class="lineno">  303 </span>  , findModule
<span class="lineno">  304 </span>  , resolvedNameType
<span class="lineno">  305 </span>  , resolveNameInMap
<span class="lineno">  306 </span>  , CtorArg(..)
<span class="lineno">  307 </span>  , CtorArgStruct(..)
<span class="lineno">  308 </span>  , Ctor(..)
<span class="lineno">  309 </span>  , DataType(..)
<span class="lineno">  310 </span>  , Def(..)
<span class="lineno">  311 </span>  , DefQualifier
<span class="lineno">  312 </span>  , Module
<span class="lineno">  313 </span>  , ResolvedName(..)
<span class="lineno">  314 </span>  )
<span class="lineno">  315 </span>import SAWCore.Name
<span class="lineno">  316 </span>import SAWCore.Prelude.Constants
<span class="lineno">  317 </span>import SAWCore.Recognizer
<span class="lineno">  318 </span>import SAWCore.Term.Certified
<span class="lineno">  319 </span>import SAWCore.Term.Functor
<span class="lineno">  320 </span>import SAWCore.Term.Pretty
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>--------------------------------------------------------------------------------
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>ppTermError :: TermError -&gt; String
<span class="lineno">  325 </span><span class="decl"><span class="nottickedoff">ppTermError err =</span>
<span class="lineno">  326 </span><span class="spaces">  </span><span class="nottickedoff">PPS.render PPS.defaultOpts $</span>
<span class="lineno">  327 </span><span class="spaces">  </span><span class="nottickedoff">prettyTermError PPS.defaultOpts emptyDisplayNameEnv err</span></span>
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>prettyTermError :: PPS.Opts -&gt; DisplayNameEnv -&gt; TermError -&gt; PPS.Doc
<span class="lineno">  330 </span><span class="decl"><span class="istickedoff">prettyTermError opts ne err =</span>
<span class="lineno">  331 </span><span class="spaces">  </span><span class="istickedoff">PP.vsep $</span>
<span class="lineno">  332 </span><span class="spaces">  </span><span class="istickedoff">case err of</span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">StaleTerm t s -&gt;</span>
<span class="lineno">  334 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Stale term encountered:&quot;</span></span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Index:&quot;</span></span>
<span class="lineno">  336 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 (PP.pretty (termIndex t))</span></span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Valid indexes:&quot;</span></span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 (PP.pretty (IntRangeSet.toList s))</span></span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;For term:&quot;</span></span>
<span class="lineno">  340 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow t</span></span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="istickedoff">VariableContextMismatch msg i t1 t2 -&gt;</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ PP.pretty msg &lt;&gt; &quot;: variable typing context mismatch&quot;</span></span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;VarIndex:&quot;</span></span>
<span class="lineno">  345 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 (PP.pretty i)</span></span>
<span class="lineno">  346 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Type 1:&quot;</span></span>
<span class="lineno">  347 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow t1</span></span>
<span class="lineno">  348 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Type 2:&quot;</span></span>
<span class="lineno">  349 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow t2</span></span>
<span class="lineno">  350 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">ApplyNotPiType f arg -&gt;</span>
<span class="lineno">  352 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Function application with non-function type&quot;</span>
<span class="lineno">  353 </span><span class="spaces">      </span><span class="istickedoff">, &quot;For term:&quot;</span>
<span class="lineno">  354 </span><span class="spaces">      </span><span class="istickedoff">, ishow f</span>
<span class="lineno">  355 </span><span class="spaces">      </span><span class="istickedoff">, &quot;With type:&quot;</span>
<span class="lineno">  356 </span><span class="spaces">      </span><span class="istickedoff">, tyshow f</span>
<span class="lineno">  357 </span><span class="spaces">      </span><span class="istickedoff">, &quot;To argument:&quot;</span>
<span class="lineno">  358 </span><span class="spaces">      </span><span class="istickedoff">, ishow arg ]</span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="istickedoff">ApplyNotSubtype f expected arg -&gt;</span>
<span class="lineno">  360 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Argument type not subtype of expected type&quot;</span>
<span class="lineno">  361 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Expected:&quot;</span>
<span class="lineno">  362 </span><span class="spaces">      </span><span class="istickedoff">, ishow expected</span>
<span class="lineno">  363 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Actual:&quot;</span>
<span class="lineno">  364 </span><span class="spaces">      </span><span class="istickedoff">, tyshow arg</span>
<span class="lineno">  365 </span><span class="spaces">      </span><span class="istickedoff">, &quot;For term:&quot;</span>
<span class="lineno">  366 </span><span class="spaces">      </span><span class="istickedoff">, ishow arg</span>
<span class="lineno">  367 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Passed to function:&quot;</span>
<span class="lineno">  368 </span><span class="spaces">      </span><span class="istickedoff">, ishow f</span>
<span class="lineno">  369 </span><span class="spaces">      </span><span class="istickedoff">, &quot;With type:&quot;</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">, tyshow f</span>
<span class="lineno">  371 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="istickedoff">VectorNotSubtype expected arg -&gt;</span>
<span class="lineno">  373 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Vector element type not subtype of expected type&quot;</span></span>
<span class="lineno">  374 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected:&quot;</span></span>
<span class="lineno">  375 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow expected</span></span>
<span class="lineno">  376 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Actual:&quot;</span></span>
<span class="lineno">  377 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, tyshow arg</span></span>
<span class="lineno">  378 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;For term:&quot;</span></span>
<span class="lineno">  379 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow arg</span></span>
<span class="lineno">  380 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">AscriptionNotSubtype expected body -&gt;</span>
<span class="lineno">  382 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Expression type not subtype of ascribed type&quot;</span></span>
<span class="lineno">  383 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Expected:&quot;</span></span>
<span class="lineno">  384 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow expected</span></span>
<span class="lineno">  385 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Actual:&quot;</span></span>
<span class="lineno">  386 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, tyshow body</span></span>
<span class="lineno">  387 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;For term:&quot;</span></span>
<span class="lineno">  388 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow body</span></span>
<span class="lineno">  389 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  390 </span><span class="spaces">    </span><span class="istickedoff">VariableFreeInContext x body -&gt;</span>
<span class="lineno">  391 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Variable occurs free in typing context&quot;</span></span>
<span class="lineno">  392 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Variable:&quot;</span></span>
<span class="lineno">  393 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.pretty (show (vnName x))</span></span>
<span class="lineno">  394 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;For term:&quot;</span></span>
<span class="lineno">  395 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow body</span></span>
<span class="lineno">  396 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  397 </span><span class="spaces">    </span><span class="istickedoff">NotType t -&gt;</span>
<span class="lineno">  398 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Type of term is not a sort&quot;</span>
<span class="lineno">  399 </span><span class="spaces">      </span><span class="istickedoff">, &quot;For term:&quot;</span>
<span class="lineno">  400 </span><span class="spaces">      </span><span class="istickedoff">, ishow t</span>
<span class="lineno">  401 </span><span class="spaces">      </span><span class="istickedoff">, &quot;With type:&quot;</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="istickedoff">, tyshow t</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  404 </span><span class="spaces">    </span><span class="istickedoff">NameNotFound nm -&gt;</span>
<span class="lineno">  405 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;No such constant:&quot; PP.&lt;+&gt; PP.pretty (toAbsoluteName (nameInfo nm)) ]</span></span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="istickedoff">IdentNotFound ident -&gt;</span>
<span class="lineno">  407 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;No such global:&quot; PP.&lt;+&gt; PP.pretty (show ident) ]</span></span>
<span class="lineno">  408 </span><span class="spaces">    </span><span class="istickedoff">NotPairType t -&gt;</span>
<span class="lineno">  409 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Tuple field projection with non-tuple&quot;</span>
<span class="lineno">  410 </span><span class="spaces">      </span><span class="istickedoff">, &quot;For term:&quot;</span>
<span class="lineno">  411 </span><span class="spaces">      </span><span class="istickedoff">, ishow t</span>
<span class="lineno">  412 </span><span class="spaces">      </span><span class="istickedoff">, &quot;With type:&quot;</span>
<span class="lineno">  413 </span><span class="spaces">      </span><span class="istickedoff">, tyshow t</span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">NotRecord t -&gt;</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Record field projection with non-record&quot;</span>
<span class="lineno">  417 </span><span class="spaces">      </span><span class="istickedoff">, &quot;For term:&quot;</span>
<span class="lineno">  418 </span><span class="spaces">      </span><span class="istickedoff">, ishow t</span>
<span class="lineno">  419 </span><span class="spaces">      </span><span class="istickedoff">, &quot;With type:&quot;</span>
<span class="lineno">  420 </span><span class="spaces">      </span><span class="istickedoff">, tyshow t</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="istickedoff">FieldNotFound t fname -&gt;</span>
<span class="lineno">  423 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;No such record field:&quot; PP.&lt;+&gt; PP.pretty fname</span>
<span class="lineno">  424 </span><span class="spaces">      </span><span class="istickedoff">, &quot;For term:&quot;</span>
<span class="lineno">  425 </span><span class="spaces">      </span><span class="istickedoff">, ishow t</span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="istickedoff">, &quot;With type:&quot;</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="istickedoff">, tyshow t</span>
<span class="lineno">  428 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="istickedoff">DataTypeNotFound d -&gt;</span>
<span class="lineno">  430 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;No such data type:&quot; PP.&lt;+&gt; PP.pretty (show d) ]</span></span>
<span class="lineno">  431 </span><span class="spaces">    </span><span class="istickedoff">RecursorPropElim d s -&gt;</span>
<span class="lineno">  432 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Invalid recursor with disallowed propositional elimination&quot;</span>
<span class="lineno">  433 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type:&quot;</span>
<span class="lineno">  434 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo d))</span>
<span class="lineno">  435 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Elimination sort:&quot;</span>
<span class="lineno">  436 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (show s)</span>
<span class="lineno">  437 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  438 </span><span class="spaces">    </span><span class="istickedoff">ConstantNotClosed nm body -&gt;</span>
<span class="lineno">  439 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Definition body contains free variables&quot;</span></span>
<span class="lineno">  440 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Name:&quot;</span></span>
<span class="lineno">  441 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo nm))</span></span>
<span class="lineno">  442 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;For term:&quot;</span></span>
<span class="lineno">  443 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow body</span></span>
<span class="lineno">  444 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;With type:&quot;</span></span>
<span class="lineno">  445 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, tyshow body</span></span>
<span class="lineno">  446 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">DuplicateURI uri -&gt;</span>
<span class="lineno">  448 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Attempt to register name with duplicate URI&quot;</span>
<span class="lineno">  449 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (render uri)</span>
<span class="lineno">  450 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">AlreadyDefined nm -&gt;</span>
<span class="lineno">  452 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Attempt to redefine existing constant&quot;</span></span>
<span class="lineno">  453 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo nm))</span></span>
<span class="lineno">  454 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  455 </span><span class="spaces">    </span><span class="istickedoff">DataTypeKindNotClosed dname dtype -&gt;</span>
<span class="lineno">  456 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Kind of data type contains free variables&quot;</span></span>
<span class="lineno">  457 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Name:&quot;</span></span>
<span class="lineno">  458 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo dname))</span></span>
<span class="lineno">  459 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Kind:&quot;</span></span>
<span class="lineno">  460 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow dtype</span></span>
<span class="lineno">  461 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">DataTypeParameterSort dname dsort pname ptype -&gt;</span>
<span class="lineno">  463 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Universe level of parameters greater than data type sort&quot;</span>
<span class="lineno">  464 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type name:&quot;</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo dname))</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type sort:&quot;</span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (show dsort)</span>
<span class="lineno">  468 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Parameter name:&quot;</span>
<span class="lineno">  469 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (vnName pname)</span>
<span class="lineno">  470 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Parameter type:&quot;</span>
<span class="lineno">  471 </span><span class="spaces">      </span><span class="istickedoff">, ishow ptype</span>
<span class="lineno">  472 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">DataTypeIndexSort dname dsort iname itype -&gt;</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Universe level of indices not contained in data type sort&quot;</span>
<span class="lineno">  475 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type name:&quot;</span>
<span class="lineno">  476 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo dname))</span>
<span class="lineno">  477 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type sort:&quot;</span>
<span class="lineno">  478 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (show dsort)</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Index name:&quot;</span>
<span class="lineno">  480 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (vnName iname)</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Index type:&quot;</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">, ishow itype</span>
<span class="lineno">  483 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Index sort:&quot;</span>
<span class="lineno">  484 </span><span class="spaces">      </span><span class="istickedoff">, tyshow itype</span>
<span class="lineno">  485 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  486 </span><span class="spaces">    </span><span class="istickedoff">DataTypeCtorNotClosed dname cname ctype -&gt;</span>
<span class="lineno">  487 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Data constructor type contains free variables&quot;</span></span>
<span class="lineno">  488 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Data type name:&quot;</span></span>
<span class="lineno">  489 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo dname))</span></span>
<span class="lineno">  490 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Constructor name:&quot;</span></span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo cname))</span></span>
<span class="lineno">  492 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;Constructor type:&quot;</span></span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, ishow ctype</span></span>
<span class="lineno">  494 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  495 </span><span class="spaces">    </span><span class="istickedoff">DataTypeCtorSort dname dsort cname ctype -&gt;</span>
<span class="lineno">  496 </span><span class="spaces">      </span><span class="istickedoff">[ &quot;Universe level of constructor not contained in data type sort&quot;</span>
<span class="lineno">  497 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type name:&quot;</span>
<span class="lineno">  498 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo dname))</span>
<span class="lineno">  499 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Data type sort:&quot;</span>
<span class="lineno">  500 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (show dsort)</span>
<span class="lineno">  501 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Constructor name:&quot;</span>
<span class="lineno">  502 </span><span class="spaces">      </span><span class="istickedoff">, PP.indent 2 $ PP.pretty (toAbsoluteName (nameInfo cname))</span>
<span class="lineno">  503 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Constructor type:&quot;</span>
<span class="lineno">  504 </span><span class="spaces">      </span><span class="istickedoff">, ishow ctype</span>
<span class="lineno">  505 </span><span class="spaces">      </span><span class="istickedoff">, &quot;Constructor sort:&quot;</span>
<span class="lineno">  506 </span><span class="spaces">      </span><span class="istickedoff">, tyshow ctype</span>
<span class="lineno">  507 </span><span class="spaces">      </span><span class="istickedoff">]</span>
<span class="lineno">  508 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  509 </span><span class="spaces">    </span><span class="istickedoff">ishow :: Term -&gt; PPS.Doc</span>
<span class="lineno">  510 </span><span class="spaces">    </span><span class="istickedoff">ishow t = PP.indent 2 $ prettyTermWithEnv opts ne t</span>
<span class="lineno">  511 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  512 </span><span class="spaces">    </span><span class="istickedoff">tyshow :: Term -&gt; PPS.Doc</span>
<span class="lineno">  513 </span><span class="spaces">    </span><span class="istickedoff">tyshow t =</span>
<span class="lineno">  514 </span><span class="spaces">      </span><span class="istickedoff">case termSortOrType t of</span>
<span class="lineno">  515 </span><span class="spaces">        </span><span class="istickedoff">Left s -&gt; PP.indent 2 $ PP.pretty (show s)</span>
<span class="lineno">  516 </span><span class="spaces">        </span><span class="istickedoff">Right ty -&gt; ishow ty</span></span>
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>execSCM :: SharedContext -&gt; SCM a -&gt; IO a
<span class="lineno">  519 </span><span class="decl"><span class="istickedoff">execSCM sc m =</span>
<span class="lineno">  520 </span><span class="spaces">  </span><span class="istickedoff">do result &lt;- runSCM sc m</span>
<span class="lineno">  521 </span><span class="spaces">     </span><span class="istickedoff">case result of</span>
<span class="lineno">  522 </span><span class="spaces">       </span><span class="istickedoff">Left err -&gt;</span>
<span class="lineno">  523 </span><span class="spaces">         </span><span class="istickedoff">do ne &lt;- scGetNamingEnv sc</span>
<span class="lineno">  524 </span><span class="spaces">            </span><span class="istickedoff">let opts = PPS.defaultOpts -- TODO: obtain opts from SharedContext</span>
<span class="lineno">  525 </span><span class="spaces">            </span><span class="istickedoff">fail (PPS.render opts (prettyTermError <span class="nottickedoff">opts</span> <span class="nottickedoff">ne</span> err))</span>
<span class="lineno">  526 </span><span class="spaces">       </span><span class="istickedoff">Right a -&gt; pure a</span></span>
<span class="lineno">  527 </span>
<span class="lineno">  528 </span>-- | Build a variant of a 'Term' with a specific type.
<span class="lineno">  529 </span>-- The first term's type must be a subtype of the second term.
<span class="lineno">  530 </span>scAscribe :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  531 </span><span class="decl"><span class="istickedoff">scAscribe sc t0 ty = execSCM sc (scmAscribe t0 ty)</span></span>
<span class="lineno">  532 </span>
<span class="lineno">  533 </span>-- | Build a new 'Term' value from the given 'TermF'.
<span class="lineno">  534 </span>-- Reuse a 'Term' from the cache if an identical one already exists.
<span class="lineno">  535 </span>scTermF :: SharedContext -&gt; TermF Term -&gt; IO Term
<span class="lineno">  536 </span><span class="decl"><span class="istickedoff">scTermF sc tf = execSCM sc (scmTermF tf)</span></span>
<span class="lineno">  537 </span>
<span class="lineno">  538 </span>-- | Create a new term from a lower-level 'FlatTermF' term.
<span class="lineno">  539 </span>scFlatTermF :: SharedContext -&gt; FlatTermF Term -&gt; IO Term
<span class="lineno">  540 </span><span class="decl"><span class="istickedoff">scFlatTermF sc ftf = execSCM sc (scmFlatTermF ftf)</span></span>
<span class="lineno">  541 </span>
<span class="lineno">  542 </span>-- | Create a function application term.
<span class="lineno">  543 </span>scApply ::
<span class="lineno">  544 </span>  SharedContext -&gt;
<span class="lineno">  545 </span>  Term {- ^ The function to apply -} -&gt;
<span class="lineno">  546 </span>  Term {- ^ The argument to apply to -} -&gt;
<span class="lineno">  547 </span>  IO Term
<span class="lineno">  548 </span><span class="decl"><span class="istickedoff">scApply sc t1 t2 = execSCM sc (scmApply t1 t2)</span></span>
<span class="lineno">  549 </span>
<span class="lineno">  550 </span>-- | Create a lambda term from a parameter name (as a 'VarName'),
<span class="lineno">  551 </span>-- parameter type (as a 'Term'), and a body ('Term').
<span class="lineno">  552 </span>-- All free variables with the same 'VarName' in the body become
<span class="lineno">  553 </span>-- bound.
<span class="lineno">  554 </span>scLambda ::
<span class="lineno">  555 </span>  SharedContext -&gt;
<span class="lineno">  556 </span>  VarName {- ^ The parameter name -} -&gt;
<span class="lineno">  557 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  558 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  559 </span>  IO Term
<span class="lineno">  560 </span><span class="decl"><span class="istickedoff">scLambda sc x t body = execSCM sc (scmLambda x t body)</span></span>
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>-- | Create a lambda term of multiple arguments (curried) from a list
<span class="lineno">  563 </span>-- associating parameter names to types (as 'Term's) and a body.
<span class="lineno">  564 </span>-- The parameters are listed outermost first.
<span class="lineno">  565 </span>-- Variable names in the parameter list are in scope for all parameter
<span class="lineno">  566 </span>-- types occurring later in the list.
<span class="lineno">  567 </span>scLambdaList ::
<span class="lineno">  568 </span>  SharedContext -&gt;
<span class="lineno">  569 </span>  [(VarName, Term)] {- ^ List of parameter / parameter type pairs -} -&gt;
<span class="lineno">  570 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  571 </span>  IO Term
<span class="lineno">  572 </span><span class="decl"><span class="istickedoff">scLambdaList _ [] body = pure body</span>
<span class="lineno">  573 </span><span class="spaces"></span><span class="istickedoff">scLambdaList sc ((x, t) : xts) body =</span>
<span class="lineno">  574 </span><span class="spaces">  </span><span class="istickedoff">scLambda sc x t =&lt;&lt; scLambdaList sc xts body</span></span>
<span class="lineno">  575 </span>
<span class="lineno">  576 </span>-- | Create a (possibly dependent) function given a parameter name,
<span class="lineno">  577 </span>-- parameter type (as a 'Term'), and a body ('Term').
<span class="lineno">  578 </span>-- All free variables with the same 'VarName' in the body become
<span class="lineno">  579 </span>-- bound.
<span class="lineno">  580 </span>scPi ::
<span class="lineno">  581 </span>  SharedContext -&gt;
<span class="lineno">  582 </span>  VarName {- ^ The parameter name -} -&gt;
<span class="lineno">  583 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  584 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  585 </span>  IO Term
<span class="lineno">  586 </span><span class="decl"><span class="istickedoff">scPi sc x t body = execSCM sc (scmPi x t body)</span></span>
<span class="lineno">  587 </span>
<span class="lineno">  588 </span>-- | Create a term representing the type of a non-dependent function, given a
<span class="lineno">  589 </span>-- parameter and result type (as 'Term's).
<span class="lineno">  590 </span>scFun ::
<span class="lineno">  591 </span>  SharedContext -&gt;
<span class="lineno">  592 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  593 </span>  Term {- ^ The result type -} -&gt;
<span class="lineno">  594 </span>  IO Term
<span class="lineno">  595 </span><span class="decl"><span class="istickedoff">scFun sc a b = scPi sc wildcardVarName a b</span></span>
<span class="lineno">  596 </span>
<span class="lineno">  597 </span>-- | Create a term representing the type of a non-dependent n-ary function,
<span class="lineno">  598 </span>-- given a list of parameter types and a result type (as terms).
<span class="lineno">  599 </span>scFunAll ::
<span class="lineno">  600 </span>  SharedContext -&gt;
<span class="lineno">  601 </span>  [Term] {- ^ The parameter types -} -&gt;
<span class="lineno">  602 </span>  Term {- ^ The result type -} -&gt;
<span class="lineno">  603 </span>  IO Term
<span class="lineno">  604 </span><span class="decl"><span class="istickedoff">scFunAll sc argTypes resultType = foldrM (scFun sc) resultType argTypes</span></span>
<span class="lineno">  605 </span>
<span class="lineno">  606 </span>-- | Create a constant 'Term' from a 'Name'.
<span class="lineno">  607 </span>scConst :: SharedContext -&gt; Name -&gt; IO Term
<span class="lineno">  608 </span><span class="decl"><span class="istickedoff">scConst sc nm = execSCM sc (scmConst nm)</span></span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>-- | Create a function application term from the 'Name' of a global
<span class="lineno">  611 </span>-- constant and a list of 'Term' arguments.
<span class="lineno">  612 </span>scConstApply :: SharedContext -&gt; Name -&gt; [Term] -&gt; IO Term
<span class="lineno">  613 </span><span class="decl"><span class="istickedoff">scConstApply sc i ts =</span>
<span class="lineno">  614 </span><span class="spaces">  </span><span class="istickedoff">do c &lt;- scConst sc i</span>
<span class="lineno">  615 </span><span class="spaces">     </span><span class="istickedoff">scApplyAll sc c ts</span></span>
<span class="lineno">  616 </span>
<span class="lineno">  617 </span>-- | Create a named variable 'Term' from a 'VarName' and a type.
<span class="lineno">  618 </span>scVariable :: SharedContext -&gt; VarName -&gt; Term -&gt; IO Term
<span class="lineno">  619 </span><span class="decl"><span class="istickedoff">scVariable sc x t = execSCM sc (scmVariable x t)</span></span>
<span class="lineno">  620 </span>
<span class="lineno">  621 </span>-- | Create a list of named variables from a list of names and types.
<span class="lineno">  622 </span>scVariables :: Traversable t =&gt; SharedContext -&gt; t (VarName, Term) -&gt; IO (t Term)
<span class="lineno">  623 </span><span class="decl"><span class="istickedoff">scVariables sc = traverse (\(v, t) -&gt; scVariable sc v t)</span></span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>-- | Generate a 'Name' with a fresh 'VarIndex' for the given
<span class="lineno">  626 </span>-- 'NameInfo' and register everything together in the naming
<span class="lineno">  627 </span>-- environment of the 'SharedContext'.
<span class="lineno">  628 </span>-- Throws an exception if the URI in the 'NameInfo' is already
<span class="lineno">  629 </span>-- registered.
<span class="lineno">  630 </span>scRegisterName :: SharedContext -&gt; NameInfo -&gt; IO Name
<span class="lineno">  631 </span><span class="decl"><span class="nottickedoff">scRegisterName sc nmi = execSCM sc (scmRegisterName nmi)</span></span>
<span class="lineno">  632 </span>
<span class="lineno">  633 </span>-- | Create a unique global name with the given base name.
<span class="lineno">  634 </span>scFreshName :: SharedContext -&gt; Text -&gt; IO Name
<span class="lineno">  635 </span><span class="decl"><span class="nottickedoff">scFreshName sc x = execSCM sc (scmFreshName x)</span></span>
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>-- | Create a 'VarName' with the given identifier (which may be &quot;_&quot;).
<span class="lineno">  638 </span>scFreshVarName :: SharedContext -&gt; Text -&gt; IO VarName
<span class="lineno">  639 </span><span class="decl"><span class="istickedoff">scFreshVarName sc x = execSCM sc (scmFreshVarName x)</span></span>
<span class="lineno">  640 </span>
<span class="lineno">  641 </span>-- | Create a 'Term' for the global constant with the given 'Ident'.
<span class="lineno">  642 </span>scGlobalDef :: SharedContext -&gt; Ident -&gt; IO Term
<span class="lineno">  643 </span><span class="decl"><span class="istickedoff">scGlobalDef sc ident = execSCM sc (scmGlobalDef ident)</span></span>
<span class="lineno">  644 </span>
<span class="lineno">  645 </span>-- | Create a recursor for the data type of the given 'Name', which
<span class="lineno">  646 </span>-- eliminates to the given 'Sort'.
<span class="lineno">  647 </span>scRecursor :: SharedContext -&gt; Name -&gt; Sort -&gt; IO Term
<span class="lineno">  648 </span><span class="decl"><span class="nottickedoff">scRecursor sc nm s = execSCM sc (scmRecursor nm s)</span></span>
<span class="lineno">  649 </span>
<span class="lineno">  650 </span>-- | Create a term from a 'Sort', and set the given advisory flags
<span class="lineno">  651 </span>scSortWithFlags :: SharedContext -&gt; Sort -&gt; SortFlags -&gt; IO Term
<span class="lineno">  652 </span><span class="decl"><span class="istickedoff">scSortWithFlags sc s flags = execSCM sc (scmSortWithFlags s flags)</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>-- | Create a literal term from a 'Natural'.
<span class="lineno">  655 </span>scNat :: SharedContext -&gt; Natural -&gt; IO Term
<span class="lineno">  656 </span><span class="decl"><span class="istickedoff">scNat sc 0 = scGlobalDef sc &quot;Prelude.Zero&quot;</span>
<span class="lineno">  657 </span><span class="spaces"></span><span class="istickedoff">scNat sc n =</span>
<span class="lineno">  658 </span><span class="spaces">  </span><span class="istickedoff">do p &lt;- scPos sc n</span>
<span class="lineno">  659 </span><span class="spaces">     </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.NatPos&quot; [p]</span></span>
<span class="lineno">  660 </span>
<span class="lineno">  661 </span>scPos :: SharedContext -&gt; Natural -&gt; IO Term
<span class="lineno">  662 </span><span class="decl"><span class="istickedoff">scPos sc n</span>
<span class="lineno">  663 </span><span class="spaces">  </span><span class="istickedoff">| n &lt;= 1    = scGlobalDef sc &quot;Prelude.One&quot;</span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">do arg &lt;- scPos sc (div n 2)</span>
<span class="lineno">  666 </span><span class="spaces">       </span><span class="istickedoff">let ident = if even n then &quot;Prelude.Bit0&quot; else &quot;Prelude.Bit1&quot;</span>
<span class="lineno">  667 </span><span class="spaces">       </span><span class="istickedoff">scGlobalApply sc ident [arg]</span></span>
<span class="lineno">  668 </span>
<span class="lineno">  669 </span>-- | Create a term from a 'Sort'.
<span class="lineno">  670 </span>scSort :: SharedContext -&gt; Sort -&gt; IO Term
<span class="lineno">  671 </span><span class="decl"><span class="istickedoff">scSort sc s = scSortWithFlags sc s noFlags</span></span>
<span class="lineno">  672 </span>
<span class="lineno">  673 </span>-- | Create a literal term (of saw-core type @String@) from a 'Text'.
<span class="lineno">  674 </span>scString :: SharedContext -&gt; Text -&gt; IO Term
<span class="lineno">  675 </span><span class="decl"><span class="istickedoff">scString sc s = execSCM sc (scmString s)</span></span>
<span class="lineno">  676 </span>
<span class="lineno">  677 </span>-- | Create a term representing the primitive saw-core type @String@.
<span class="lineno">  678 </span>scStringType :: SharedContext -&gt; IO Term
<span class="lineno">  679 </span><span class="decl"><span class="nottickedoff">scStringType sc = scGlobalDef sc preludeStringIdent</span></span>
<span class="lineno">  680 </span>
<span class="lineno">  681 </span>-- | Create a vector term from a type (as a 'Term') and a list of 'Term's of
<span class="lineno">  682 </span>-- that type.
<span class="lineno">  683 </span>scVector :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno">  684 </span><span class="decl"><span class="istickedoff">scVector sc e xs = execSCM sc (scmVector e xs)</span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>-- | Create a record term from a 'Map' from 'FieldName's to 'Term's.
<span class="lineno">  687 </span>scRecord :: SharedContext -&gt; Map FieldName Term -&gt; IO Term
<span class="lineno">  688 </span><span class="decl"><span class="istickedoff">scRecord sc (Map.toList -&gt; fields) = execSCM sc (scmRecordValue fields)</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>-- | Create a record term from a list of 'FieldName's and 'Term's.
<span class="lineno">  691 </span>scRecordValue :: SharedContext -&gt; [(FieldName, Term)] -&gt; IO Term
<span class="lineno">  692 </span><span class="decl"><span class="nottickedoff">scRecordValue sc fields = execSCM sc (scmRecordValue fields)</span></span>
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>-- | Create a record field access term from a 'Term' representing a record and
<span class="lineno">  695 </span>-- a 'FieldName'.
<span class="lineno">  696 </span>scRecordSelect :: SharedContext -&gt; Term -&gt; FieldName -&gt; IO Term
<span class="lineno">  697 </span><span class="decl"><span class="istickedoff">scRecordSelect sc t fname = execSCM sc (scmRecordSelect t fname)</span></span>
<span class="lineno">  698 </span>
<span class="lineno">  699 </span>-- | Create a term representing the type of a record from a list associating
<span class="lineno">  700 </span>-- field names (as 'FieldName's) and types (as 'Term's). Note that the order of
<span class="lineno">  701 </span>-- the given list is irrelevant, as record fields are not ordered.
<span class="lineno">  702 </span>scRecordType :: SharedContext -&gt; [(FieldName, Term)] -&gt; IO Term
<span class="lineno">  703 </span><span class="decl"><span class="istickedoff">scRecordType sc fields = execSCM sc (scmRecordType fields)</span></span>
<span class="lineno">  704 </span>
<span class="lineno">  705 </span>-- | Create a unit-valued term.
<span class="lineno">  706 </span>scUnitValue :: SharedContext -&gt; IO Term
<span class="lineno">  707 </span><span class="decl"><span class="istickedoff">scUnitValue sc = execSCM sc scmUnitValue</span></span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>-- | Create a term representing the unit type.
<span class="lineno">  710 </span>scUnitType :: SharedContext -&gt; IO Term
<span class="lineno">  711 </span><span class="decl"><span class="istickedoff">scUnitType sc = execSCM sc scmUnitType</span></span>
<span class="lineno">  712 </span>
<span class="lineno">  713 </span>-- | Create a pair term from two terms.
<span class="lineno">  714 </span>scPairValue ::
<span class="lineno">  715 </span>  SharedContext -&gt;
<span class="lineno">  716 </span>  Term {- ^ The left projection -} -&gt;
<span class="lineno">  717 </span>  Term {- ^ The right projection -} -&gt;
<span class="lineno">  718 </span>  IO Term
<span class="lineno">  719 </span><span class="decl"><span class="istickedoff">scPairValue sc t1 t2 = execSCM sc (scmPairValue t1 t2)</span></span>
<span class="lineno">  720 </span>
<span class="lineno">  721 </span>-- | Create a term representing a pair type from two other terms, each
<span class="lineno">  722 </span>-- representing a type.
<span class="lineno">  723 </span>scPairType ::
<span class="lineno">  724 </span>  SharedContext -&gt;
<span class="lineno">  725 </span>  Term {- ^ Left projection type -} -&gt;
<span class="lineno">  726 </span>  Term {- ^ Right projection type -} -&gt;
<span class="lineno">  727 </span>  IO Term
<span class="lineno">  728 </span><span class="decl"><span class="istickedoff">scPairType sc t1 t2 = execSCM sc (scmPairType t1 t2)</span></span>
<span class="lineno">  729 </span>
<span class="lineno">  730 </span>-- | Create a term giving the left projection of a 'Term' representing a pair.
<span class="lineno">  731 </span>scPairLeft :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  732 </span><span class="decl"><span class="istickedoff">scPairLeft sc t = execSCM sc (scmPairLeft t)</span></span>
<span class="lineno">  733 </span>
<span class="lineno">  734 </span>-- | Create a term giving the right projection of a 'Term' representing a pair.
<span class="lineno">  735 </span>scPairRight :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  736 </span><span class="decl"><span class="istickedoff">scPairRight sc t = execSCM sc (scmPairRight t)</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>-- | Create a (possibly dependent) function of multiple arguments (curried)
<span class="lineno">  739 </span>-- from a list associating parameter names to types (as 'Term's) and a body.
<span class="lineno">  740 </span>-- Variable names in the parameter list are in scope for all parameter
<span class="lineno">  741 </span>-- types occurring later in the list.
<span class="lineno">  742 </span>scPiList ::
<span class="lineno">  743 </span>  SharedContext -&gt;
<span class="lineno">  744 </span>  [(VarName, Term)] {- ^ List of parameter / parameter type pairs -} -&gt;
<span class="lineno">  745 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  746 </span>  IO Term
<span class="lineno">  747 </span><span class="decl"><span class="istickedoff">scPiList sc binds body = execSCM sc (scmPiList binds body)</span></span>
<span class="lineno">  748 </span>
<span class="lineno">  749 </span>-- | Define a global constant with the specified base name (as
<span class="lineno">  750 </span>-- 'Text') and body.
<span class="lineno">  751 </span>-- The term for the body must not have any free variables.
<span class="lineno">  752 </span>-- A globally-unique name with the specified base name will be created
<span class="lineno">  753 </span>-- using 'scFreshName'.
<span class="lineno">  754 </span>-- The type of the body determines the type of the constant; to
<span class="lineno">  755 </span>-- specify a different formulation of the type, use 'scAscribe'.
<span class="lineno">  756 </span>scFreshConstant ::
<span class="lineno">  757 </span>  SharedContext -&gt;
<span class="lineno">  758 </span>  Text {- ^ The base name -} -&gt;
<span class="lineno">  759 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  760 </span>  IO Term
<span class="lineno">  761 </span><span class="decl"><span class="nottickedoff">scFreshConstant sc name rhs = execSCM sc (scmFreshConstant name rhs)</span></span>
<span class="lineno">  762 </span>
<span class="lineno">  763 </span>-- | Define a global constant with the specified name (as 'NameInfo')
<span class="lineno">  764 </span>-- and body.
<span class="lineno">  765 </span>-- The URI in the given 'NameInfo' must be globally unique.
<span class="lineno">  766 </span>-- The term for the body must not have any free variables.
<span class="lineno">  767 </span>-- The type of the body determines the type of the constant; to
<span class="lineno">  768 </span>-- specify a different formulation of the type, use 'scAscribe'.
<span class="lineno">  769 </span>scDefineConstant ::
<span class="lineno">  770 </span>  SharedContext -&gt;
<span class="lineno">  771 </span>  NameInfo {- ^ The name -} -&gt;
<span class="lineno">  772 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  773 </span>  IO Term
<span class="lineno">  774 </span><span class="decl"><span class="istickedoff">scDefineConstant sc nmi rhs = execSCM sc (scmDefineConstant nmi rhs)</span></span>
<span class="lineno">  775 </span>
<span class="lineno">  776 </span>-- | Declare a SAW core primitive of the specified type.
<span class="lineno">  777 </span>scDeclarePrim :: SharedContext -&gt; Ident -&gt; DefQualifier -&gt; Term -&gt; IO ()
<span class="lineno">  778 </span><span class="decl"><span class="istickedoff">scDeclarePrim sc ident q ty = execSCM sc (scmDeclarePrim ident <span class="nottickedoff">q</span> ty)</span></span>
<span class="lineno">  779 </span>
<span class="lineno">  780 </span>-- | Declare a global opaque constant with the specified name (as
<span class="lineno">  781 </span>-- 'NameInfo') and type.
<span class="lineno">  782 </span>-- Such a constant has no definition, but unlike a variable it may be
<span class="lineno">  783 </span>-- used in other constant definitions and is not subject to
<span class="lineno">  784 </span>-- lambda-binding or substitution.
<span class="lineno">  785 </span>scOpaqueConstant ::
<span class="lineno">  786 </span>  SharedContext -&gt;
<span class="lineno">  787 </span>  NameInfo -&gt;
<span class="lineno">  788 </span>  Term {- ^ type of the constant -} -&gt;
<span class="lineno">  789 </span>  IO Term
<span class="lineno">  790 </span><span class="decl"><span class="istickedoff">scOpaqueConstant sc nmi ty = execSCM sc (scmOpaqueConstant nmi ty)</span></span>
<span class="lineno">  791 </span>
<span class="lineno">  792 </span>-- | Define a new data type with constructors in the global context.
<span class="lineno">  793 </span>-- Return the type constructor and data constructors as 'Term's.
<span class="lineno">  794 </span>scDefineDataType :: SharedContext -&gt; DataTypeSpec -&gt; IO (Term, [Term])
<span class="lineno">  795 </span><span class="decl"><span class="nottickedoff">scDefineDataType sc spec = execSCM sc (scmDefineDataType spec)</span></span>
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>-- | Create a function application term from a global identifier and a list of
<span class="lineno">  798 </span>-- arguments (as 'Term's).
<span class="lineno">  799 </span>scGlobalApply :: SharedContext -&gt; Ident -&gt; [Term] -&gt; IO Term
<span class="lineno">  800 </span><span class="decl"><span class="istickedoff">scGlobalApply sc i ts =</span>
<span class="lineno">  801 </span><span class="spaces">  </span><span class="istickedoff">do c &lt;- scGlobalDef sc i</span>
<span class="lineno">  802 </span><span class="spaces">     </span><span class="istickedoff">scApplyAll sc c ts</span></span>
<span class="lineno">  803 </span>
<span class="lineno">  804 </span>scResolveName :: SharedContext -&gt; Text -&gt; IO [VarIndex]
<span class="lineno">  805 </span><span class="decl"><span class="istickedoff">scResolveName sc nm =</span>
<span class="lineno">  806 </span><span class="spaces">  </span><span class="istickedoff">do env &lt;- scGetNamingEnv sc</span>
<span class="lineno">  807 </span><span class="spaces">     </span><span class="istickedoff">pure (resolveDisplayName env nm)</span></span>
<span class="lineno">  808 </span>
<span class="lineno">  809 </span>-- | Create a fresh variable with the given identifier (which may be &quot;_&quot;) and type.
<span class="lineno">  810 </span>scFreshVariable :: SharedContext -&gt; Text -&gt; Term -&gt; IO Term
<span class="lineno">  811 </span><span class="decl"><span class="istickedoff">scFreshVariable sc x tp =</span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff">do nm &lt;- scFreshVarName sc x</span>
<span class="lineno">  813 </span><span class="spaces">     </span><span class="istickedoff">scVariable sc nm tp</span></span>
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>-- | Test if a module is loaded in the current shared context
<span class="lineno">  816 </span>scModuleIsLoaded :: SharedContext -&gt; ModuleName -&gt; IO Bool
<span class="lineno">  817 </span><span class="decl"><span class="istickedoff">scModuleIsLoaded sc name =</span>
<span class="lineno">  818 </span><span class="spaces">  </span><span class="istickedoff">moduleIsLoaded name &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  819 </span>
<span class="lineno">  820 </span>-- | Look up a module by name, raising an error if it is not loaded
<span class="lineno">  821 </span>scFindModule :: SharedContext -&gt; ModuleName -&gt; IO Module
<span class="lineno">  822 </span><span class="decl"><span class="istickedoff">scFindModule sc name =</span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="istickedoff">do maybe_mod &lt;- findModule name &lt;$&gt; scGetModuleMap sc</span>
<span class="lineno">  824 </span><span class="spaces">     </span><span class="istickedoff">case maybe_mod of</span>
<span class="lineno">  825 </span><span class="spaces">       </span><span class="istickedoff">Just m -&gt; return m</span>
<span class="lineno">  826 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  827 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">error (&quot;scFindModule: module &quot; ++ show name ++ &quot; not found!&quot;)</span></span></span>
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>-- | Look up a definition by its identifier
<span class="lineno">  830 </span>scFindDef :: SharedContext -&gt; Ident -&gt; IO (Maybe Def)
<span class="lineno">  831 </span><span class="decl"><span class="istickedoff">scFindDef sc i = findDefInMap i &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  832 </span>
<span class="lineno">  833 </span>-- | Look up a 'Def' by its identifier, throwing an error if it is not found
<span class="lineno">  834 </span>scRequireDef :: SharedContext -&gt; Ident -&gt; IO Def
<span class="lineno">  835 </span><span class="decl"><span class="nottickedoff">scRequireDef sc i =</span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="nottickedoff">scFindDef sc i &gt;&gt;= \maybe_d -&gt;</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_d of</span>
<span class="lineno">  838 </span><span class="spaces">    </span><span class="nottickedoff">Just d -&gt; return d</span>
<span class="lineno">  839 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail (&quot;Could not find definition: &quot; ++ show i)</span></span>
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>-- | Look up a datatype by its identifier
<span class="lineno">  842 </span>scFindDataType :: SharedContext -&gt; Ident -&gt; IO (Maybe DataType)
<span class="lineno">  843 </span><span class="decl"><span class="nottickedoff">scFindDataType sc i = findDataTypeInMap i &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  844 </span>
<span class="lineno">  845 </span>-- | Look up a datatype by its identifier, throwing an error if it is not found
<span class="lineno">  846 </span>scRequireDataType :: SharedContext -&gt; Ident -&gt; IO DataType
<span class="lineno">  847 </span><span class="decl"><span class="nottickedoff">scRequireDataType sc i =</span>
<span class="lineno">  848 </span><span class="spaces">  </span><span class="nottickedoff">scFindDataType sc i &gt;&gt;= \maybe_d -&gt;</span>
<span class="lineno">  849 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_d of</span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="nottickedoff">Just d -&gt; return d</span>
<span class="lineno">  851 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail (&quot;Could not find datatype: &quot; ++ show i)</span></span>
<span class="lineno">  852 </span>
<span class="lineno">  853 </span>-- | Look up a constructor by its identifier
<span class="lineno">  854 </span>scFindCtor :: SharedContext -&gt; Ident -&gt; IO (Maybe Ctor)
<span class="lineno">  855 </span><span class="decl"><span class="nottickedoff">scFindCtor sc i = findCtorInMap i &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>-- | Look up a constructor by its identifier, throwing an error if not found
<span class="lineno">  858 </span>scRequireCtor :: SharedContext -&gt; Ident -&gt; IO Ctor
<span class="lineno">  859 </span><span class="decl"><span class="nottickedoff">scRequireCtor sc i =</span>
<span class="lineno">  860 </span><span class="spaces">  </span><span class="nottickedoff">scFindCtor sc i &gt;&gt;= \maybe_ctor -&gt;</span>
<span class="lineno">  861 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_ctor of</span>
<span class="lineno">  862 </span><span class="spaces">    </span><span class="nottickedoff">Just ctor -&gt; return ctor</span>
<span class="lineno">  863 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail (&quot;Could not find constructor: &quot; ++ show i)</span></span>
<span class="lineno">  864 </span>
<span class="lineno">  865 </span>----------------------------------------------------------------------
<span class="lineno">  866 </span>-- Printing
<span class="lineno">  867 </span>
<span class="lineno">  868 </span>-- | The preferred printing mechanism for `Term`, if you want a `Doc`.
<span class="lineno">  869 </span>--
<span class="lineno">  870 </span>--   Note that there are two naming conventions in conflict here: the
<span class="lineno">  871 </span>--   convention that things using the `SharedContext` and in `IO`
<span class="lineno">  872 </span>--   should be named `sc`, and the convention that the preferred way
<span class="lineno">  873 </span>--   to prettyprint an object of type @Foo@ to a `Doc` should be
<span class="lineno">  874 </span>--   called @prettyFoo@. For the time being at least we've concluded
<span class="lineno">  875 </span>--   that the latter is more important.
<span class="lineno">  876 </span>prettyTerm :: SharedContext -&gt; PPS.Opts -&gt; Term -&gt; IO PPS.Doc
<span class="lineno">  877 </span><span class="decl"><span class="istickedoff">prettyTerm sc opts t =</span>
<span class="lineno">  878 </span><span class="spaces">  </span><span class="istickedoff">do env &lt;- scGetNamingEnv sc</span>
<span class="lineno">  879 </span><span class="spaces">     </span><span class="istickedoff">pure (prettyTermWithEnv opts env t)</span></span>
<span class="lineno">  880 </span>
<span class="lineno">  881 </span>-- | The preferred printing mechanism for `Term`, if you want text.
<span class="lineno">  882 </span>--
<span class="lineno">  883 </span>--   The same naming considerations as `prettyTerm` apply.
<span class="lineno">  884 </span>ppTerm :: SharedContext -&gt; PPS.Opts -&gt; Term -&gt; IO String
<span class="lineno">  885 </span><span class="decl"><span class="istickedoff">ppTerm sc opts t =</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">PPS.render opts &lt;$&gt; prettyTerm sc opts t</span></span>
<span class="lineno">  887 </span>
<span class="lineno">  888 </span>--------------------------------------------------------------------------------
<span class="lineno">  889 </span>-- Recursors
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>-- | Test whether a 'DataType' can be eliminated to the given sort. The rules
<span class="lineno">  892 </span>-- are that you can only eliminate propositional datatypes to the proposition
<span class="lineno">  893 </span>-- sort, unless your propositional data type is the empty type. This differs
<span class="lineno">  894 </span>-- slightly from the Rocq rules, which allow elimination of propositional
<span class="lineno">  895 </span>-- datatypes with a single constructor that has only propositional arguments,
<span class="lineno">  896 </span>-- but this Rocq behavior can be simulated with the behavior we are using here.
<span class="lineno">  897 </span>allowedElimSort :: DataType -&gt; Sort -&gt; Bool
<span class="lineno">  898 </span><span class="decl"><span class="nottickedoff">allowedElimSort dt s =</span>
<span class="lineno">  899 </span><span class="spaces">  </span><span class="nottickedoff">if dtSort dt == propSort &amp;&amp; s /= propSort then</span>
<span class="lineno">  900 </span><span class="spaces">    </span><span class="nottickedoff">length (dtCtors dt) == 1</span>
<span class="lineno">  901 </span><span class="spaces">  </span><span class="nottickedoff">else True</span></span>
<span class="lineno">  902 </span>
<span class="lineno">  903 </span>-- | Internal: Compute the type of a constructor from the name of its
<span class="lineno">  904 </span>-- datatype and its 'CtorArgStruct'.
<span class="lineno">  905 </span>ctxCtorType :: SharedContext -&gt; Name -&gt; CtorArgStruct -&gt; IO Term
<span class="lineno">  906 </span><span class="decl"><span class="nottickedoff">ctxCtorType sc d (CtorArgStruct{..}) =</span>
<span class="lineno">  907 </span><span class="spaces">  </span><span class="nottickedoff">do params &lt;- scVariables sc ctorParams</span>
<span class="lineno">  908 </span><span class="spaces">     </span><span class="nottickedoff">d_params &lt;- scConstApply sc d params</span>
<span class="lineno">  909 </span><span class="spaces">     </span><span class="nottickedoff">d_params_ixs &lt;- scApplyAll sc d_params ctorIndices</span>
<span class="lineno">  910 </span><span class="spaces">     </span><span class="nottickedoff">let ctorArgType :: CtorArg -&gt; IO Term</span>
<span class="lineno">  911 </span><span class="spaces">         </span><span class="nottickedoff">ctorArgType (ConstArg tp) = pure tp</span>
<span class="lineno">  912 </span><span class="spaces">         </span><span class="nottickedoff">ctorArgType (RecursiveArg zs_ctx ixs) =</span>
<span class="lineno">  913 </span><span class="spaces">           </span><span class="nottickedoff">scPiList sc zs_ctx =&lt;&lt; scApplyAll sc d_params ixs</span>
<span class="lineno">  914 </span><span class="spaces">     </span><span class="nottickedoff">bs &lt;- traverse (traverse ctorArgType) ctorArgs</span>
<span class="lineno">  915 </span><span class="spaces">     </span><span class="nottickedoff">body &lt;- scPiList sc bs d_params_ixs</span>
<span class="lineno">  916 </span><span class="spaces">     </span><span class="nottickedoff">scPiList sc ctorParams body</span></span>
<span class="lineno">  917 </span>
<span class="lineno">  918 </span>-- | Build a 'Ctor' from a 'CtorArgStruct' and a list of the other constructor
<span class="lineno">  919 </span>-- names of the 'DataType'. Note that we cannot look up the latter information,
<span class="lineno">  920 </span>-- as 'scBuildCtor' is called during construction of the 'DataType'.
<span class="lineno">  921 </span>scBuildCtor ::
<span class="lineno">  922 </span>  SharedContext -&gt;
<span class="lineno">  923 </span>  Name {- ^ data type -} -&gt;
<span class="lineno">  924 </span>  Ident {- ^ constructor name -} -&gt;
<span class="lineno">  925 </span>  CtorArgStruct {- ^ constructor formal arguments -} -&gt;
<span class="lineno">  926 </span>  IO Ctor
<span class="lineno">  927 </span><span class="decl"><span class="nottickedoff">scBuildCtor sc d c arg_struct =</span>
<span class="lineno">  928 </span><span class="spaces">  </span><span class="nottickedoff">do</span>
<span class="lineno">  929 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 0: allocate a fresh unique variable index for this constructor</span>
<span class="lineno">  930 </span><span class="spaces">    </span><span class="nottickedoff">-- and register its name in the naming environment</span>
<span class="lineno">  931 </span><span class="spaces">    </span><span class="nottickedoff">cname &lt;- scRegisterName sc (ModuleIdentifier c)</span>
<span class="lineno">  932 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  933 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 1: build the types for the constructor and the type required</span>
<span class="lineno">  934 </span><span class="spaces">    </span><span class="nottickedoff">-- of its eliminator functions</span>
<span class="lineno">  935 </span><span class="spaces">    </span><span class="nottickedoff">tp &lt;- ctxCtorType sc d arg_struct</span>
<span class="lineno">  936 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  937 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, return the required Ctor record</span>
<span class="lineno">  938 </span><span class="spaces">    </span><span class="nottickedoff">return $ Ctor</span>
<span class="lineno">  939 </span><span class="spaces">      </span><span class="nottickedoff">{ ctorName = cname</span>
<span class="lineno">  940 </span><span class="spaces">      </span><span class="nottickedoff">, ctorArgStruct = arg_struct</span>
<span class="lineno">  941 </span><span class="spaces">      </span><span class="nottickedoff">, ctorDataType = d</span>
<span class="lineno">  942 </span><span class="spaces">      </span><span class="nottickedoff">, ctorType = tp</span>
<span class="lineno">  943 </span><span class="spaces">      </span><span class="nottickedoff">}</span></span>
<span class="lineno">  944 </span>
<span class="lineno">  945 </span>-- | Reduce an application of a recursor. This is known in the Rocq literature as
<span class="lineno">  946 </span>-- an iota reduction. More specifically, the call
<span class="lineno">  947 </span>--
<span class="lineno">  948 </span>-- &gt; scReduceRecursor sc rec crec ci [x1, .., xk]
<span class="lineno">  949 </span>--
<span class="lineno">  950 </span>-- reduces the term @(Recursor r elims ixs (CtorApp ci ps xs))@ to
<span class="lineno">  951 </span>--
<span class="lineno">  952 </span>-- &gt; fi x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  953 </span>--
<span class="lineno">  954 </span>-- where @maybe rec_tm_i@ indicates an optional recursive call of the recursor
<span class="lineno">  955 </span>-- on one of the @xi@.
<span class="lineno">  956 </span>-- These recursive calls only exist for those arguments @xi@.
<span class="lineno">  957 </span>scReduceRecursor ::
<span class="lineno">  958 </span>  SharedContext -&gt;
<span class="lineno">  959 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno">  960 </span>  CompiledRecursor {- ^ concrete data included in the recursor term -} -&gt;
<span class="lineno">  961 </span>  [Term] {- ^ datatype parameters -} -&gt;
<span class="lineno">  962 </span>  Term {- ^ motive function -} -&gt;
<span class="lineno">  963 </span>  [Term] {- ^ eliminator functions -} -&gt;
<span class="lineno">  964 </span>  Name {- ^ constructor name -} -&gt;
<span class="lineno">  965 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  966 </span>  IO Term
<span class="lineno">  967 </span><span class="decl"><span class="istickedoff">scReduceRecursor sc r crec params motive elims c args =</span>
<span class="lineno">  968 </span><span class="spaces">  </span><span class="istickedoff">execSCM sc (scmReduceRecursor r crec params motive elims c args)</span></span>
<span class="lineno">  969 </span>
<span class="lineno">  970 </span>--------------------------------------------------------------------------------
<span class="lineno">  971 </span>-- Type checking
<span class="lineno">  972 </span>
<span class="lineno">  973 </span>-- | Return the type of a term.
<span class="lineno">  974 </span>scTypeOf :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  975 </span><span class="decl"><span class="istickedoff">scTypeOf sc t =</span>
<span class="lineno">  976 </span><span class="spaces">  </span><span class="istickedoff">case termSortOrType t of</span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="istickedoff">Right ty -&gt; pure ty</span>
<span class="lineno">  978 </span><span class="spaces">    </span><span class="istickedoff">Left s -&gt; scSort sc s</span></span>
<span class="lineno">  979 </span>
<span class="lineno">  980 </span>-- | @reducePi sc (Pi x tp body) t@ returns @[t/x]body@, and otherwise fails
<span class="lineno">  981 </span>reducePi :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  982 </span><span class="decl"><span class="istickedoff">reducePi sc t arg = do</span>
<span class="lineno">  983 </span><span class="spaces">  </span><span class="istickedoff">t' &lt;- scWhnf <span class="nottickedoff">sc</span> t</span>
<span class="lineno">  984 </span><span class="spaces">  </span><span class="istickedoff">case asPi t' of</span>
<span class="lineno">  985 </span><span class="spaces">    </span><span class="istickedoff">Just (vn, _, body) -&gt;</span>
<span class="lineno">  986 </span><span class="spaces">      </span><span class="istickedoff">scInstantiateBeta sc (IntMap.singleton (vnIndex vn) arg) body</span>
<span class="lineno">  987 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  988 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">t'' &lt;- ppTerm sc PPS.defaultOpts t'</span></span>
<span class="lineno">  989 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [&quot;reducePi: not a Pi term&quot;, t'']</span></span></span>
<span class="lineno">  990 </span>
<span class="lineno">  991 </span>
<span class="lineno">  992 </span>-- | Look up the type of a global constant, primitive, data type, or
<span class="lineno">  993 </span>-- data constructor, given its name as an 'Ident'.
<span class="lineno">  994 </span>scTypeOfIdent :: SharedContext -&gt; Ident -&gt; IO Term
<span class="lineno">  995 </span><span class="decl"><span class="istickedoff">scTypeOfIdent sc ident =</span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="istickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  997 </span><span class="spaces">     </span><span class="istickedoff">case resolveNameInMap mm ident of</span>
<span class="lineno">  998 </span><span class="spaces">       </span><span class="istickedoff">Just r -&gt; pure (resolvedNameType r)</span>
<span class="lineno">  999 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail (&quot;scTypeOfIdent: Identifier not found: &quot; ++ show ident)</span></span></span>
<span class="lineno"> 1000 </span>
<span class="lineno"> 1001 </span>-- | Look up the type of a global constant, given its 'Name'.
<span class="lineno"> 1002 </span>scTypeOfName :: SharedContext -&gt; Name -&gt; IO Term
<span class="lineno"> 1003 </span><span class="decl"><span class="nottickedoff">scTypeOfName sc nm =</span>
<span class="lineno"> 1004 </span><span class="spaces">  </span><span class="nottickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1005 </span><span class="spaces">     </span><span class="nottickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 1006 </span><span class="spaces">       </span><span class="nottickedoff">Just r -&gt; pure (resolvedNameType r)</span>
<span class="lineno"> 1007 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; fail (&quot;scTypeOfName: Name not found: &quot; ++ show nm)</span></span>
<span class="lineno"> 1008 </span>
<span class="lineno"> 1009 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1010 </span>
<span class="lineno"> 1011 </span>-- | Imports a term built in a different shared context into the given
<span class="lineno"> 1012 </span>-- shared context. The caller must ensure that all the global constants
<span class="lineno"> 1013 </span>-- appearing in the term are valid in the new context.
<span class="lineno"> 1014 </span>scImport :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1015 </span><span class="decl"><span class="nottickedoff">scImport sc t0 =</span>
<span class="lineno"> 1016 </span><span class="spaces">    </span><span class="nottickedoff">do cache &lt;- newIntCache</span>
<span class="lineno"> 1017 </span><span class="spaces">       </span><span class="nottickedoff">go cache t0</span>
<span class="lineno"> 1018 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="nottickedoff">go :: IntCache IO Term -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 1020 </span><span class="spaces">    </span><span class="nottickedoff">go cache t =</span>
<span class="lineno"> 1021 </span><span class="spaces">      </span><span class="nottickedoff">useIntCache cache (termIndex t) (scTermF sc =&lt;&lt; traverse (go cache) (unwrapTermF t))</span></span>
<span class="lineno"> 1022 </span>
<span class="lineno"> 1023 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1024 </span>-- Normalization
<span class="lineno"> 1025 </span>
<span class="lineno"> 1026 </span>-- | Reduces beta-redexes, tuple/record selectors, recursor applications, and
<span class="lineno"> 1027 </span>-- definitions at the top level of a term.
<span class="lineno"> 1028 </span>scWhnf :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1029 </span><span class="decl"><span class="istickedoff">scWhnf sc t = execSCM sc (scmWhnf t)</span></span>
<span class="lineno"> 1030 </span>
<span class="lineno"> 1031 </span>-- | Test if two terms are convertible according to the SAWCore type
<span class="lineno"> 1032 </span>-- system rules.
<span class="lineno"> 1033 </span>-- The convertibility test uses the same set of reductions performed
<span class="lineno"> 1034 </span>-- by 'scWhnf'.
<span class="lineno"> 1035 </span>scConvertible ::
<span class="lineno"> 1036 </span>  SharedContext -&gt;
<span class="lineno"> 1037 </span>  Term -&gt;
<span class="lineno"> 1038 </span>  Term -&gt;
<span class="lineno"> 1039 </span>  IO Bool
<span class="lineno"> 1040 </span><span class="decl"><span class="istickedoff">scConvertible sc t1 t2 =</span>
<span class="lineno"> 1041 </span><span class="spaces">  </span><span class="istickedoff">execSCM sc (scmConvertible t1 t2)</span></span>
<span class="lineno"> 1042 </span>
<span class="lineno"> 1043 </span>-- | Check whether one type is a subtype of another: Either they are
<span class="lineno"> 1044 </span>-- convertible, or they are both Pi types with convertible argument
<span class="lineno"> 1045 </span>-- types and result sorts @s1@ and @s2@ with @s1 &lt;= s2@.
<span class="lineno"> 1046 </span>scSubtype :: SharedContext -&gt; Term -&gt; Term -&gt; IO Bool
<span class="lineno"> 1047 </span><span class="decl"><span class="istickedoff">scSubtype sc t1 t2 = execSCM sc (scmSubtype t1 t2)</span></span>
<span class="lineno"> 1048 </span>
<span class="lineno"> 1049 </span>-- | Apply a function to an argument, beta-reducing if the function is
<span class="lineno"> 1050 </span>-- a lambda.
<span class="lineno"> 1051 </span>-- If both input terms are in beta-normal form, then the result will
<span class="lineno"> 1052 </span>-- also be beta-normal.
<span class="lineno"> 1053 </span>scApplyBeta :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1054 </span><span class="decl"><span class="nottickedoff">scApplyBeta sc f arg = scApplyAllBeta sc f [arg]</span></span>
<span class="lineno"> 1055 </span>
<span class="lineno"> 1056 </span>-- | Internal function: Instantiate free variables within a term,
<span class="lineno"> 1057 </span>-- apply it to a list of arguments, and beta-normalize the result.
<span class="lineno"> 1058 </span>-- Precondition: All terms in the substitution map and the list of
<span class="lineno"> 1059 </span>-- arguments are already in beta-normal form.
<span class="lineno"> 1060 </span>scBetaNormalizeAux ::
<span class="lineno"> 1061 </span>  SharedContext -&gt; IntMap Term -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1062 </span><span class="decl"><span class="istickedoff">scBetaNormalizeAux sc sub t0 args0 =</span>
<span class="lineno"> 1063 </span><span class="spaces">  </span><span class="istickedoff">do let rangeVars = foldMap freeVars sub</span>
<span class="lineno"> 1064 </span><span class="spaces">     </span><span class="istickedoff">-- The cache memoizes the result of normalizing a given</span>
<span class="lineno"> 1065 </span><span class="spaces">     </span><span class="istickedoff">-- expression under the current substitution; recursive calls</span>
<span class="lineno"> 1066 </span><span class="spaces">     </span><span class="istickedoff">-- that change the substitution must start a new memo table.</span>
<span class="lineno"> 1067 </span><span class="spaces">     </span><span class="istickedoff">cache &lt;- newIntCache</span>
<span class="lineno"> 1068 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; IO Term</span>
<span class="lineno"> 1069 </span><span class="spaces">         </span><span class="istickedoff">memo t = useIntCache cache (termIndex t) (go t [])</span>
<span class="lineno"> 1070 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; [Term] -&gt; IO Term</span>
<span class="lineno"> 1071 </span><span class="spaces">         </span><span class="istickedoff">go t args =</span>
<span class="lineno"> 1072 </span><span class="spaces">           </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1073 </span><span class="spaces">             </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno"> 1074 </span><span class="spaces">               </span><span class="istickedoff">do ftf' &lt;- traverse <span class="nottickedoff">memo</span> ftf</span>
<span class="lineno"> 1075 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scFlatTermF sc ftf'</span>
<span class="lineno"> 1076 </span><span class="spaces">                  </span><span class="istickedoff">scApplyAll <span class="nottickedoff">sc</span> t' args</span>
<span class="lineno"> 1077 </span><span class="spaces">             </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno"> 1078 </span><span class="spaces">               </span><span class="istickedoff">do t2' &lt;- memo t2</span>
<span class="lineno"> 1079 </span><span class="spaces">                  </span><span class="istickedoff">go t1 (t2' : args)</span>
<span class="lineno"> 1080 </span><span class="spaces">             </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 1081 </span><span class="spaces">               </span><span class="istickedoff">case args of</span>
<span class="lineno"> 1082 </span><span class="spaces">                 </span><span class="istickedoff">arg : args' -&gt;</span>
<span class="lineno"> 1083 </span><span class="spaces">                   </span><span class="istickedoff">-- No possibility of capture here, as the binder is</span>
<span class="lineno"> 1084 </span><span class="spaces">                   </span><span class="istickedoff">-- going away. If x is already in the map,</span>
<span class="lineno"> 1085 </span><span class="spaces">                   </span><span class="istickedoff">-- overwriting that entry is what we want.</span>
<span class="lineno"> 1086 </span><span class="spaces">                   </span><span class="istickedoff">do let sub' = IntMap.insert (vnIndex x) arg sub</span>
<span class="lineno"> 1087 </span><span class="spaces">                      </span><span class="istickedoff">scBetaNormalizeAux sc sub' t2 args'</span>
<span class="lineno"> 1088 </span><span class="spaces">                 </span><span class="istickedoff">[] -&gt;</span>
<span class="lineno"> 1089 </span><span class="spaces">                   </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1090 </span><span class="spaces">                      </span><span class="istickedoff">-- Freshen bound variable if it can capture.</span>
<span class="lineno"> 1091 </span><span class="spaces">                      </span><span class="istickedoff">x' &lt;-</span>
<span class="lineno"> 1092 </span><span class="spaces">                        </span><span class="istickedoff">if <span class="tickonlyfalse">IntSet.member (vnIndex x) rangeVars</span></span>
<span class="lineno"> 1093 </span><span class="spaces">                        </span><span class="istickedoff">then <span class="nottickedoff">scFreshVarName sc (vnName x)</span></span>
<span class="lineno"> 1094 </span><span class="spaces">                        </span><span class="istickedoff">else pure x</span>
<span class="lineno"> 1095 </span><span class="spaces">                      </span><span class="istickedoff">var &lt;- scVariable sc x' t1'</span>
<span class="lineno"> 1096 </span><span class="spaces">                      </span><span class="istickedoff">let sub' = IntMap.insert (vnIndex x) var sub</span>
<span class="lineno"> 1097 </span><span class="spaces">                      </span><span class="istickedoff">t2' &lt;- scBetaNormalizeAux sc sub' t2 []</span>
<span class="lineno"> 1098 </span><span class="spaces">                      </span><span class="istickedoff">scLambda sc x' t1' t2'</span>
<span class="lineno"> 1099 </span><span class="spaces">             </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 1100 </span><span class="spaces">               </span><span class="istickedoff">-- Pi expressions may never be applied to arguments</span>
<span class="lineno"> 1101 </span><span class="spaces">               </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1102 </span><span class="spaces">                  </span><span class="istickedoff">-- Freshen bound variable if it can capture.</span>
<span class="lineno"> 1103 </span><span class="spaces">                  </span><span class="istickedoff">x' &lt;-</span>
<span class="lineno"> 1104 </span><span class="spaces">                    </span><span class="istickedoff">if IntSet.member (vnIndex x) rangeVars</span>
<span class="lineno"> 1105 </span><span class="spaces">                    </span><span class="istickedoff">then scFreshVarName sc (vnName x)</span>
<span class="lineno"> 1106 </span><span class="spaces">                    </span><span class="istickedoff">else pure x</span>
<span class="lineno"> 1107 </span><span class="spaces">                  </span><span class="istickedoff">var &lt;- scVariable sc x' t1'</span>
<span class="lineno"> 1108 </span><span class="spaces">                  </span><span class="istickedoff">let sub' = IntMap.insert (vnIndex x) var sub</span>
<span class="lineno"> 1109 </span><span class="spaces">                  </span><span class="istickedoff">t2' &lt;- scBetaNormalizeAux sc sub' t2 []</span>
<span class="lineno"> 1110 </span><span class="spaces">                  </span><span class="istickedoff">scPi sc x' t1' t2'</span>
<span class="lineno"> 1111 </span><span class="spaces">             </span><span class="istickedoff">Constant{} -&gt;</span>
<span class="lineno"> 1112 </span><span class="spaces">               </span><span class="istickedoff">scApplyAll sc t args</span>
<span class="lineno"> 1113 </span><span class="spaces">             </span><span class="istickedoff">Variable x _ -&gt;</span>
<span class="lineno"> 1114 </span><span class="spaces">               </span><span class="istickedoff">-- All bound variables will be present in the map.</span>
<span class="lineno"> 1115 </span><span class="spaces">               </span><span class="istickedoff">-- To preserve term invariants, free variables must</span>
<span class="lineno"> 1116 </span><span class="spaces">               </span><span class="istickedoff">-- have their type annotations left unmodified.</span>
<span class="lineno"> 1117 </span><span class="spaces">               </span><span class="istickedoff">case IntMap.lookup (vnIndex x) sub of</span>
<span class="lineno"> 1118 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1119 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">scApplyAll sc t args</span></span>
<span class="lineno"> 1120 </span><span class="spaces">                 </span><span class="istickedoff">Just t' -&gt;</span>
<span class="lineno"> 1121 </span><span class="spaces">                   </span><span class="istickedoff">scApplyAllBeta sc t' args</span>
<span class="lineno"> 1122 </span><span class="spaces">     </span><span class="istickedoff">go t0 args0</span></span>
<span class="lineno"> 1123 </span>
<span class="lineno"> 1124 </span>-- | Beta-reduce a term to normal form.
<span class="lineno"> 1125 </span>betaNormalize :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1126 </span><span class="decl"><span class="istickedoff">betaNormalize sc t = scBetaNormalizeAux sc IntMap.empty t []</span></span>
<span class="lineno"> 1127 </span>
<span class="lineno"> 1128 </span>-- | Apply a function 'Term' to a list of zero or more arguments.
<span class="lineno"> 1129 </span>-- If the function is a lambda term, then beta reduce the arguments
<span class="lineno"> 1130 </span>-- into the function body.
<span class="lineno"> 1131 </span>-- If all input terms are in beta-normal form, then the result will
<span class="lineno"> 1132 </span>-- also be beta-normal.
<span class="lineno"> 1133 </span>scApplyAllBeta :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1134 </span><span class="decl"><span class="istickedoff">scApplyAllBeta sc t args = execSCM sc (scmApplyAllBeta t args)</span></span>
<span class="lineno"> 1135 </span>
<span class="lineno"> 1136 </span>-- | Instantiate some of the named variables in the term.
<span class="lineno"> 1137 </span>-- The 'IntMap' is keyed by 'VarIndex'.
<span class="lineno"> 1138 </span>-- Note: The replacement is _not_ applied recursively
<span class="lineno"> 1139 </span>-- to the terms in the substitution map.
<span class="lineno"> 1140 </span>scInstantiate :: SharedContext -&gt; IntMap Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1141 </span><span class="decl"><span class="istickedoff">scInstantiate sc vmap t0 = execSCM sc (scmInstantiate vmap t0)</span></span>
<span class="lineno"> 1142 </span>
<span class="lineno"> 1143 </span>-- | Instantiate some of the named variables in the term, reducing any
<span class="lineno"> 1144 </span>-- new beta redexes created in the process.
<span class="lineno"> 1145 </span>-- The substitution 'IntMap' is keyed by 'VarIndex'.
<span class="lineno"> 1146 </span>-- If the input term and all terms in the substitution are in
<span class="lineno"> 1147 </span>-- beta-normal form, then the result will also be beta-normal.
<span class="lineno"> 1148 </span>-- If a substituted term is a lambda, and it is substituted into the
<span class="lineno"> 1149 </span>-- left side of an application, creating a new beta redex, then it
<span class="lineno"> 1150 </span>-- will trigger further beta reduction.
<span class="lineno"> 1151 </span>-- Existing beta redexes in the input term or substitution are
<span class="lineno"> 1152 </span>-- not reduced.
<span class="lineno"> 1153 </span>scInstantiateBeta :: SharedContext -&gt; IntMap Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1154 </span><span class="decl"><span class="istickedoff">scInstantiateBeta sc sub t0 = execSCM sc (scmInstantiateBeta sub t0)</span></span>
<span class="lineno"> 1155 </span>
<span class="lineno"> 1156 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1157 </span>-- Building shared terms
<span class="lineno"> 1158 </span>
<span class="lineno"> 1159 </span>-- | Apply a function 'Term' to zero or more argument 'Term's.
<span class="lineno"> 1160 </span>scApplyAll :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1161 </span><span class="decl"><span class="istickedoff">scApplyAll sc = foldlM (scApply sc)</span></span>
<span class="lineno"> 1162 </span>
<span class="lineno"> 1163 </span>-- | Create a term from a 'Sort', and set the advisory &quot;inhabited&quot; flag
<span class="lineno"> 1164 </span>scISort :: SharedContext -&gt; Sort -&gt; IO Term
<span class="lineno"> 1165 </span><span class="decl"><span class="istickedoff">scISort sc s = scSortWithFlags sc s $ noFlags { flagInhabited = True }</span></span>
<span class="lineno"> 1166 </span>
<span class="lineno"> 1167 </span>-- | Create an n-place tuple from a list (of length n) of 'Term's.
<span class="lineno"> 1168 </span>-- Note that tuples are nested pairs, associating to the right e.g.
<span class="lineno"> 1169 </span>-- @(a, (b, (c, d)))@.
<span class="lineno"> 1170 </span>scTuple :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1171 </span><span class="decl"><span class="istickedoff">scTuple sc [] = scUnitValue sc</span>
<span class="lineno"> 1172 </span><span class="spaces"></span><span class="istickedoff">scTuple _ [t] = return t</span>
<span class="lineno"> 1173 </span><span class="spaces"></span><span class="istickedoff">scTuple sc (t : ts) = scPairValue sc t =&lt;&lt; scTuple sc ts</span></span>
<span class="lineno"> 1174 </span>
<span class="lineno"> 1175 </span>-- | Create a term representing the type of an n-place tuple, from a list
<span class="lineno"> 1176 </span>-- (of length n) of 'Term's, each representing a type.
<span class="lineno"> 1177 </span>scTupleType :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1178 </span><span class="decl"><span class="istickedoff">scTupleType sc [] = scUnitType sc</span>
<span class="lineno"> 1179 </span><span class="spaces"></span><span class="istickedoff">scTupleType _ [t] = return t</span>
<span class="lineno"> 1180 </span><span class="spaces"></span><span class="istickedoff">scTupleType sc (t : ts) = scPairType sc t =&lt;&lt; scTupleType sc ts</span></span>
<span class="lineno"> 1181 </span>
<span class="lineno"> 1182 </span>-- | @scTupleSelector sc t i n@ returns a term selecting the @i@th component of
<span class="lineno"> 1183 </span>-- an @n@-place tuple 'Term', @t@.
<span class="lineno"> 1184 </span>scTupleSelector ::
<span class="lineno"> 1185 </span>  SharedContext -&gt; Term -&gt;
<span class="lineno"> 1186 </span>  Int {- ^ 1-based index -} -&gt;
<span class="lineno"> 1187 </span>  Int {- ^ tuple size -} -&gt;
<span class="lineno"> 1188 </span>  IO Term
<span class="lineno"> 1189 </span><span class="decl"><span class="istickedoff">scTupleSelector sc t i n</span>
<span class="lineno"> 1190 </span><span class="spaces">  </span><span class="istickedoff">| n == 1    = return t</span>
<span class="lineno"> 1191 </span><span class="spaces">  </span><span class="istickedoff">| i == 1    = scPairLeft sc t</span>
<span class="lineno"> 1192 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">i &gt; 1</span>     = do t' &lt;- scPairRight sc t</span>
<span class="lineno"> 1193 </span><span class="spaces">                   </span><span class="istickedoff">scTupleSelector sc t' (i - 1) (n - 1)</span>
<span class="lineno"> 1194 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">fail &quot;scTupleSelector: non-positive index&quot;</span></span></span>
<span class="lineno"> 1195 </span>
<span class="lineno"> 1196 </span>-- | An optimized variant of 'scPairValue' that will reduce pairs of
<span class="lineno"> 1197 </span>-- the form @(x.L, x.R)@ to @x@.
<span class="lineno"> 1198 </span>scPairValueReduced :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1199 </span><span class="decl"><span class="istickedoff">scPairValueReduced sc x y =</span>
<span class="lineno"> 1200 </span><span class="spaces">  </span><span class="istickedoff">case (unwrapTermF x, unwrapTermF y) of</span>
<span class="lineno"> 1201 </span><span class="spaces">    </span><span class="istickedoff">(FTermF (PairLeft a), FTermF (PairRight b)) | <span class="tickonlytrue">a == b</span> -&gt; return a</span>
<span class="lineno"> 1202 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; scPairValue sc x y</span></span>
<span class="lineno"> 1203 </span>
<span class="lineno"> 1204 </span>-- | An optimized variant of 'scTuple' that will reduce tuples of
<span class="lineno"> 1205 </span>-- the form @(x.1, x.2, x.3)@ to @x@.
<span class="lineno"> 1206 </span>scTupleReduced :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1207 </span><span class="decl"><span class="istickedoff">scTupleReduced sc [] = scUnitValue sc</span>
<span class="lineno"> 1208 </span><span class="spaces"></span><span class="istickedoff">scTupleReduced _ [t] = return t</span>
<span class="lineno"> 1209 </span><span class="spaces"></span><span class="istickedoff">scTupleReduced sc (t : ts) = scPairValueReduced sc t =&lt;&lt; scTupleReduced sc ts</span></span>
<span class="lineno"> 1210 </span>
<span class="lineno"> 1211 </span>-- | An optimized variant of 'scVector' that will reduce vectors of
<span class="lineno"> 1212 </span>-- the form @[at x 0, at x 1, at x 2, at x 3]@ to just @x@.
<span class="lineno"> 1213 </span>scVectorReduced :: SharedContext -&gt; Term {- ^ element type -} -&gt; [Term] {- ^ elements -} -&gt; IO Term
<span class="lineno"> 1214 </span><span class="decl"><span class="istickedoff">scVectorReduced sc ety xs</span>
<span class="lineno"> 1215 </span><span class="spaces">  </span><span class="istickedoff">| (hd : _) &lt;- xs</span>
<span class="lineno"> 1216 </span><span class="spaces">  </span><span class="istickedoff">, Just ((arr_sz :*: arr_tm) :*: 0) &lt;- asAtOrBvAt hd</span>
<span class="lineno"> 1217 </span><span class="spaces">  </span><span class="istickedoff">, fromIntegral (length xs) == arr_sz</span>
<span class="lineno"> 1218 </span><span class="spaces">  </span><span class="istickedoff">, iall (\i x -&gt; asAtOrBvAt x == Just ((arr_sz :*: arr_tm) :*: fromIntegral i)) xs =</span>
<span class="lineno"> 1219 </span><span class="spaces">    </span><span class="istickedoff">return arr_tm</span>
<span class="lineno"> 1220 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = scVector sc ety xs</span>
<span class="lineno"> 1221 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1222 </span><span class="spaces">    </span><span class="istickedoff">asAny :: Term -&gt; Maybe ()</span>
<span class="lineno"> 1223 </span><span class="spaces">    </span><span class="istickedoff">asAny _ = Just <span class="nottickedoff">()</span></span>
<span class="lineno"> 1224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1225 </span><span class="spaces">    </span><span class="istickedoff">asAt :: Term -&gt; Maybe ((Natural :*: Term) :*: Natural)</span>
<span class="lineno"> 1226 </span><span class="spaces">    </span><span class="istickedoff">asAt = (((isGlobalDef &quot;Prelude.at&quot; @&gt; asNat) &lt;@ asAny) &lt;@&gt; return) &lt;@&gt; asNat</span>
<span class="lineno"> 1227 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1228 </span><span class="spaces">    </span><span class="istickedoff">asBvAt :: Term -&gt; Maybe ((Natural :*: Term) :*: Natural)</span>
<span class="lineno"> 1229 </span><span class="spaces">    </span><span class="istickedoff">asBvAt = ((((isGlobalDef &quot;Prelude.bvAt&quot; @&gt; <span class="nottickedoff">asNat</span>) &lt;@ <span class="nottickedoff">asAny</span>) &lt;@ <span class="nottickedoff">asAny</span>) &lt;@&gt; <span class="nottickedoff">return</span>) &lt;@&gt; <span class="nottickedoff">asUnsignedConcreteBv</span></span>
<span class="lineno"> 1230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1231 </span><span class="spaces">    </span><span class="istickedoff">asAtOrBvAt :: Term -&gt; Maybe ((Natural :*: Term) :*: Natural)</span>
<span class="lineno"> 1232 </span><span class="spaces">    </span><span class="istickedoff">asAtOrBvAt term</span>
<span class="lineno"> 1233 </span><span class="spaces">      </span><span class="istickedoff">| res@Just{} &lt;- asAt term = res</span>
<span class="lineno"> 1234 </span><span class="spaces">      </span><span class="istickedoff">| res@Just{} &lt;- asBvAt term = <span class="nottickedoff">res</span></span>
<span class="lineno"> 1235 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Nothing</span></span>
<span class="lineno"> 1236 </span>
<span class="lineno"> 1237 </span>------------------------------------------------------------
<span class="lineno"> 1238 </span>-- Building terms using prelude functions
<span class="lineno"> 1239 </span>
<span class="lineno"> 1240 </span>-- | Create a term applying @Prelude.EqTrue@ to the given term.
<span class="lineno"> 1241 </span>--
<span class="lineno"> 1242 </span>-- &gt; EqTrue : Bool -&gt; sort 1;
<span class="lineno"> 1243 </span>scEqTrue :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1244 </span><span class="decl"><span class="istickedoff">scEqTrue sc t = scGlobalApply sc &quot;Prelude.EqTrue&quot; [t]</span></span>
<span class="lineno"> 1245 </span>
<span class="lineno"> 1246 </span>-- | Create a @Prelude.Bool@-typed term from the given Boolean: @Prelude.True@
<span class="lineno"> 1247 </span>-- for @True@, @Prelude.False@ for @False@.
<span class="lineno"> 1248 </span>scBool :: SharedContext -&gt; Bool -&gt; IO Term
<span class="lineno"> 1249 </span><span class="decl"><span class="istickedoff">scBool sc True  = scGlobalDef sc &quot;Prelude.True&quot;</span>
<span class="lineno"> 1250 </span><span class="spaces"></span><span class="istickedoff">scBool sc False = scGlobalDef sc &quot;Prelude.False&quot;</span></span>
<span class="lineno"> 1251 </span>
<span class="lineno"> 1252 </span>-- | Create a term representing the prelude Boolean type, @Prelude.Bool@.
<span class="lineno"> 1253 </span>scBoolType :: SharedContext -&gt; IO Term
<span class="lineno"> 1254 </span><span class="decl"><span class="istickedoff">scBoolType sc = scGlobalDef sc &quot;Prelude.Bool&quot;</span></span>
<span class="lineno"> 1255 </span>
<span class="lineno"> 1256 </span>-- | Create a term representing the prelude Natural type.
<span class="lineno"> 1257 </span>scNatType :: SharedContext -&gt; IO Term
<span class="lineno"> 1258 </span><span class="decl"><span class="nottickedoff">scNatType sc = scGlobalDef sc preludeNatIdent</span></span>
<span class="lineno"> 1259 </span>
<span class="lineno"> 1260 </span>-- | Create a term representing a vector type, from a term giving the length
<span class="lineno"> 1261 </span>-- and a term giving the element type.
<span class="lineno"> 1262 </span>scVecType :: SharedContext
<span class="lineno"> 1263 </span>          -&gt; Term -- ^ The length of the vector
<span class="lineno"> 1264 </span>          -&gt; Term -- ^ The element type
<span class="lineno"> 1265 </span>          -&gt; IO Term
<span class="lineno"> 1266 </span><span class="decl"><span class="istickedoff">scVecType sc n e = scGlobalApply sc preludeVecIdent [n, e]</span></span>
<span class="lineno"> 1267 </span>
<span class="lineno"> 1268 </span>-- | Create a term applying @Prelude.not@ to the given term.
<span class="lineno"> 1269 </span>--
<span class="lineno"> 1270 </span>-- &gt; not : Bool -&gt; Bool;
<span class="lineno"> 1271 </span>scNot :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1272 </span><span class="decl"><span class="istickedoff">scNot sc t = scGlobalApply sc &quot;Prelude.not&quot; [t]</span></span>
<span class="lineno"> 1273 </span>
<span class="lineno"> 1274 </span>-- | Create a term applying @Prelude.and@ to the two given terms.
<span class="lineno"> 1275 </span>--
<span class="lineno"> 1276 </span>-- &gt; and : Bool -&gt; Bool -&gt; Bool;
<span class="lineno"> 1277 </span>scAnd :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1278 </span><span class="decl"><span class="istickedoff">scAnd sc x y = scGlobalApply sc &quot;Prelude.and&quot; [x,y]</span></span>
<span class="lineno"> 1279 </span>
<span class="lineno"> 1280 </span>-- | Create a term applying @Prelude.or@ to the two given terms.
<span class="lineno"> 1281 </span>--
<span class="lineno"> 1282 </span>-- &gt; or : Bool -&gt; Bool -&gt; Bool;
<span class="lineno"> 1283 </span>scOr :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1284 </span><span class="decl"><span class="istickedoff">scOr sc x y = scGlobalApply sc &quot;Prelude.or&quot; [x,y]</span></span>
<span class="lineno"> 1285 </span>
<span class="lineno"> 1286 </span>-- | Create a term applying @Prelude.implies@ to the two given terms.
<span class="lineno"> 1287 </span>--
<span class="lineno"> 1288 </span>-- &gt; implies : Bool -&gt; Bool -&gt; Bool;
<span class="lineno"> 1289 </span>scImplies :: SharedContext -&gt; Term -&gt; Term
<span class="lineno"> 1290 </span>          -&gt; IO Term
<span class="lineno"> 1291 </span><span class="decl"><span class="istickedoff">scImplies sc x y = scGlobalApply sc &quot;Prelude.implies&quot; [x,y]</span></span>
<span class="lineno"> 1292 </span>
<span class="lineno"> 1293 </span>-- | Create a term applying @Prelude.xor@ to the two given terms.
<span class="lineno"> 1294 </span>--
<span class="lineno"> 1295 </span>-- &gt; xor : Bool -&gt; Bool -&gt; Bool;
<span class="lineno"> 1296 </span>scXor :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1297 </span><span class="decl"><span class="nottickedoff">scXor sc x y = scGlobalApply sc &quot;Prelude.xor&quot; [x,y]</span></span>
<span class="lineno"> 1298 </span>
<span class="lineno"> 1299 </span>-- | Create a term applying @Prelude.boolEq@ to the two given terms.
<span class="lineno"> 1300 </span>--
<span class="lineno"> 1301 </span>-- &gt; boolEq : Bool -&gt; Bool -&gt; Bool;
<span class="lineno"> 1302 </span>scBoolEq :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1303 </span><span class="decl"><span class="istickedoff">scBoolEq sc x y = scGlobalApply sc &quot;Prelude.boolEq&quot; [x,y]</span></span>
<span class="lineno"> 1304 </span>
<span class="lineno"> 1305 </span>-- | Create a universally quantified bitvector term.
<span class="lineno"> 1306 </span>--
<span class="lineno"> 1307 </span>-- &gt; bvForall : (n : Nat) -&gt; (Vec n Bool -&gt; Bool) -&gt; Bool;
<span class="lineno"> 1308 </span>scBvForall :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1309 </span><span class="decl"><span class="nottickedoff">scBvForall sc w f = scGlobalApply sc &quot;Prelude.bvForall&quot; [w, f]</span></span>
<span class="lineno"> 1310 </span>
<span class="lineno"> 1311 </span>-- | Create a non-dependent if-then-else term.
<span class="lineno"> 1312 </span>--
<span class="lineno"> 1313 </span>-- &gt; ite : (a : sort 1) -&gt; Bool -&gt; a -&gt; a -&gt; a;
<span class="lineno"> 1314 </span>scIte :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1315 </span>         Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1316 </span><span class="decl"><span class="istickedoff">scIte sc t b x y = scGlobalApply sc &quot;Prelude.ite&quot; [t, b, x, y]</span></span>
<span class="lineno"> 1317 </span>
<span class="lineno"> 1318 </span>-- | Build a conjunction from a list of boolean terms.
<span class="lineno"> 1319 </span>scAndList :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1320 </span><span class="decl"><span class="istickedoff">scAndList sc = conj . filter nontrivial</span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1322 </span><span class="spaces">    </span><span class="istickedoff">nontrivial x = asBool x /= Just <span class="nottickedoff">True</span></span>
<span class="lineno"> 1323 </span><span class="spaces">    </span><span class="istickedoff">conj [] = scBool sc True</span>
<span class="lineno"> 1324 </span><span class="spaces">    </span><span class="istickedoff">conj [x] = return x</span>
<span class="lineno"> 1325 </span><span class="spaces">    </span><span class="istickedoff">conj (x : xs) = foldM (scAnd sc) x xs</span></span>
<span class="lineno"> 1326 </span>
<span class="lineno"> 1327 </span>-- | Build a conjunction from a list of boolean terms.
<span class="lineno"> 1328 </span>scOrList :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1329 </span><span class="decl"><span class="nottickedoff">scOrList sc = disj . filter nontrivial</span>
<span class="lineno"> 1330 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1331 </span><span class="spaces">    </span><span class="nottickedoff">nontrivial x = asBool x /= Just False</span>
<span class="lineno"> 1332 </span><span class="spaces">    </span><span class="nottickedoff">disj [] = scBool sc False</span>
<span class="lineno"> 1333 </span><span class="spaces">    </span><span class="nottickedoff">disj [x] = return x</span>
<span class="lineno"> 1334 </span><span class="spaces">    </span><span class="nottickedoff">disj (x : xs) = foldM (scOr sc) x xs</span></span>
<span class="lineno"> 1335 </span>
<span class="lineno"> 1336 </span>
<span class="lineno"> 1337 </span>-- | Create a term applying @Prelude.append@ to two vectors.
<span class="lineno"> 1338 </span>--
<span class="lineno"> 1339 </span>-- &gt; append : (m n : Nat) -&gt; (e : sort 0) -&gt; Vec m e -&gt; Vec n e -&gt; Vec (addNat m n) e;
<span class="lineno"> 1340 </span>scAppend :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1341 </span>            Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1342 </span><span class="decl"><span class="istickedoff">scAppend sc m n t x y = scGlobalApply sc &quot;Prelude.append&quot; [m, n, t, x, y]</span></span>
<span class="lineno"> 1343 </span>
<span class="lineno"> 1344 </span>-- | Create a term applying @Prelude.join@ to a vector of vectors.
<span class="lineno"> 1345 </span>--
<span class="lineno"> 1346 </span>-- &gt; join  : (m n : Nat) -&gt; (a : sort 0) -&gt; Vec m (Vec n a) -&gt; Vec (mulNat m n) a;
<span class="lineno"> 1347 </span>scJoin :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1348 </span><span class="decl"><span class="istickedoff">scJoin sc m n a v = scGlobalApply sc &quot;Prelude.join&quot; [m, n, a, v]</span></span>
<span class="lineno"> 1349 </span>
<span class="lineno"> 1350 </span>-- | Create a term splitting a vector with @Prelude.split@.
<span class="lineno"> 1351 </span>--
<span class="lineno"> 1352 </span>-- &gt; split : (m n : Nat) -&gt; (a : sort 0) -&gt; Vec (mulNat m n) a -&gt; Vec m (Vec n a);
<span class="lineno"> 1353 </span>scSplit :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1354 </span><span class="decl"><span class="istickedoff">scSplit sc m n a v = scGlobalApply sc &quot;Prelude.split&quot; [m, n, a, v]</span></span>
<span class="lineno"> 1355 </span>
<span class="lineno"> 1356 </span>-- | Create a term selecting a range of values from a vector with @Prelude.slice@.
<span class="lineno"> 1357 </span>--
<span class="lineno"> 1358 </span>-- &gt; slice : (e : sort 1) -&gt; (i n o : Nat) -&gt; Vec (addNat (addNat i n) o) e -&gt; Vec n e;
<span class="lineno"> 1359 </span>scSlice :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1360 </span>           Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1361 </span><span class="decl"><span class="istickedoff">scSlice sc e i n o a = scGlobalApply sc &quot;Prelude.slice&quot; [e, i, n, o, a]</span></span>
<span class="lineno"> 1362 </span>
<span class="lineno"> 1363 </span>-- | Create a term accessing a particular element of a vector with @get@.
<span class="lineno"> 1364 </span>--
<span class="lineno"> 1365 </span>-- &gt; get : (n : Nat) -&gt; (e : sort 0) -&gt; Vec n e -&gt; Fin n -&gt; e;
<span class="lineno"> 1366 </span>scGet :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1367 </span>         Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1368 </span><span class="decl"><span class="nottickedoff">scGet sc n e v i = scGlobalApply sc (mkIdent preludeName &quot;get&quot;) [n, e, v, i]</span></span>
<span class="lineno"> 1369 </span>
<span class="lineno"> 1370 </span>-- | Create a term accessing a particular element of a vector with @bvAt@,
<span class="lineno"> 1371 </span>-- which uses a bitvector for indexing.
<span class="lineno"> 1372 </span>--
<span class="lineno"> 1373 </span>-- &gt; bvAt : (n : Nat) -&gt; (a : sort 0) -&gt; (w : Nat) -&gt; Vec n a -&gt; Vec w Bool -&gt; a;
<span class="lineno"> 1374 </span>scBvAt :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1375 </span>         Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1376 </span><span class="decl"><span class="istickedoff">scBvAt sc n a i xs idx = scGlobalApply sc (mkIdent preludeName &quot;bvAt&quot;) [n, a, i, xs, idx]</span></span>
<span class="lineno"> 1377 </span>
<span class="lineno"> 1378 </span>-- | Create a term accessing a particular element of a vector, with a default
<span class="lineno"> 1379 </span>-- to return if the index is out of bounds.
<span class="lineno"> 1380 </span>--
<span class="lineno"> 1381 </span>-- &gt; atWithDefault : (n : Nat) -&gt; (a : sort 0) -&gt; a -&gt; Vec n a -&gt; Nat -&gt; a;
<span class="lineno"> 1382 </span>scAtWithDefault :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1383 </span><span class="decl"><span class="nottickedoff">scAtWithDefault sc n a v xs idx = scGlobalApply sc (mkIdent preludeName &quot;atWithDefault&quot;) [n, a, v, xs, idx]</span></span>
<span class="lineno"> 1384 </span>
<span class="lineno"> 1385 </span>-- | Create a term accessing a particular element of a vector, failing if the
<span class="lineno"> 1386 </span>-- index is out of bounds.
<span class="lineno"> 1387 </span>--
<span class="lineno"> 1388 </span>-- &gt; at : (n : Nat) -&gt; (a : sort 0) -&gt; Vec n a -&gt; Nat -&gt; a;
<span class="lineno"> 1389 </span>scAt :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno"> 1390 </span>        Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1391 </span><span class="decl"><span class="istickedoff">scAt sc n a xs idx = scGlobalApply sc (mkIdent preludeName &quot;at&quot;) [n, a, xs, idx]</span></span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>-- | Create a term evaluating to a vector containing a single element.
<span class="lineno"> 1394 </span>--
<span class="lineno"> 1395 </span>-- &gt; single : (e : sort 1) -&gt; e -&gt; Vec 1 e;
<span class="lineno"> 1396 </span>scSingle :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1397 </span><span class="decl"><span class="istickedoff">scSingle sc e x = scGlobalApply sc (mkIdent preludeName &quot;single&quot;) [e, x]</span></span>
<span class="lineno"> 1398 </span>
<span class="lineno"> 1399 </span>-- | Create a term computing the least significant bit of a bitvector, given a
<span class="lineno"> 1400 </span>-- length and bitvector.
<span class="lineno"> 1401 </span>--
<span class="lineno"> 1402 </span>-- &gt; lsb : (n : Nat) -&gt; Vec (Succ n) Bool -&gt; Bool;
<span class="lineno"> 1403 </span>scLsb :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1404 </span><span class="decl"><span class="nottickedoff">scLsb sc n x = scGlobalApply sc (mkIdent preludeName &quot;lsb&quot;) [n, x]</span></span>
<span class="lineno"> 1405 </span>
<span class="lineno"> 1406 </span>-- | Create a term computing the most significant bit of a bitvector, given a
<span class="lineno"> 1407 </span>-- length and bitvector.
<span class="lineno"> 1408 </span>--
<span class="lineno"> 1409 </span>-- &gt; msb : (n : Nat) -&gt; Vec (Succ n) Bool -&gt; Bool;
<span class="lineno"> 1410 </span>scMsb :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1411 </span><span class="decl"><span class="nottickedoff">scMsb sc n x = scGlobalApply sc (mkIdent preludeName &quot;lsb&quot;) [n, x]</span></span>
<span class="lineno"> 1412 </span>
<span class="lineno"> 1413 </span>-- Primitive operations on nats
<span class="lineno"> 1414 </span>
<span class="lineno"> 1415 </span>-- | Create a term computing the sum of the two given (natural number) terms.
<span class="lineno"> 1416 </span>--
<span class="lineno"> 1417 </span>-- &gt; addNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno"> 1418 </span>scAddNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1419 </span><span class="decl"><span class="nottickedoff">scAddNat sc x y = scGlobalApply sc &quot;Prelude.addNat&quot; [x,y]</span></span>
<span class="lineno"> 1420 </span>
<span class="lineno"> 1421 </span>-- | Create a term computing the difference between the two given
<span class="lineno"> 1422 </span>-- (natural number) terms.
<span class="lineno"> 1423 </span>--
<span class="lineno"> 1424 </span>-- &gt; subNat : Nat -&gt; Nat -&gt; Nat
<span class="lineno"> 1425 </span>scSubNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1426 </span><span class="decl"><span class="nottickedoff">scSubNat sc x y = scGlobalApply sc &quot;Prelude.subNat&quot; [x,y]</span></span>
<span class="lineno"> 1427 </span>
<span class="lineno"> 1428 </span>-- | Create a term computing the product of the two given (natural number)
<span class="lineno"> 1429 </span>-- terms.
<span class="lineno"> 1430 </span>--
<span class="lineno"> 1431 </span>-- &gt; mulNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno"> 1432 </span>scMulNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1433 </span><span class="decl"><span class="nottickedoff">scMulNat sc x y = scGlobalApply sc &quot;Prelude.mulNat&quot; [x,y]</span></span>
<span class="lineno"> 1434 </span>
<span class="lineno"> 1435 </span>-- | Create a term computing the quotient of the two given (natural number)
<span class="lineno"> 1436 </span>-- terms.
<span class="lineno"> 1437 </span>--
<span class="lineno"> 1438 </span>-- &gt; divNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno"> 1439 </span>scDivNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1440 </span><span class="decl"><span class="nottickedoff">scDivNat sc x y = scGlobalApply sc &quot;Prelude.divNat&quot; [x,y]</span></span>
<span class="lineno"> 1441 </span>
<span class="lineno"> 1442 </span>-- | Create a term computing the remainder upon division of the two given
<span class="lineno"> 1443 </span>-- (natural number) terms.
<span class="lineno"> 1444 </span>--
<span class="lineno"> 1445 </span>-- &gt; modNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno"> 1446 </span>scModNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1447 </span><span class="decl"><span class="nottickedoff">scModNat sc x y = scGlobalApply sc &quot;Prelude.modNat&quot; [x,y]</span></span>
<span class="lineno"> 1448 </span>
<span class="lineno"> 1449 </span>-- | Create a term computing the quotient and remainder upon division of the
<span class="lineno"> 1450 </span>-- two given (natural number) terms, giving the result as a pair.
<span class="lineno"> 1451 </span>--
<span class="lineno"> 1452 </span>-- &gt; divModNat : Nat -&gt; Nat -&gt; Nat * Nat;
<span class="lineno"> 1453 </span>scDivModNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1454 </span><span class="decl"><span class="nottickedoff">scDivModNat sc x y = scGlobalApply sc &quot;Prelude.divModNat&quot; [x,y]</span></span>
<span class="lineno"> 1455 </span>
<span class="lineno"> 1456 </span>-- | Create a term computing whether the two given (natural number) terms are
<span class="lineno"> 1457 </span>-- equal.
<span class="lineno"> 1458 </span>--
<span class="lineno"> 1459 </span>-- &gt; equalNat : Nat -&gt; Nat -&gt; Bool;
<span class="lineno"> 1460 </span>scEqualNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1461 </span><span class="decl"><span class="nottickedoff">scEqualNat sc x y = scGlobalApply sc &quot;Prelude.equalNat&quot; [x,y]</span></span>
<span class="lineno"> 1462 </span>
<span class="lineno"> 1463 </span>-- | Create a term computing whether the first term (a natural number) is less
<span class="lineno"> 1464 </span>-- than the second term (also a natural number).
<span class="lineno"> 1465 </span>--
<span class="lineno"> 1466 </span>-- &gt; ltNat : Nat -&gt; Nat -&gt; Bool;
<span class="lineno"> 1467 </span>scLtNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1468 </span><span class="decl"><span class="nottickedoff">scLtNat sc x y = scGlobalApply sc &quot;Prelude.ltNat&quot; [x,y]</span></span>
<span class="lineno"> 1469 </span>
<span class="lineno"> 1470 </span>-- | Create a term computing the minimum of the two given (natural number)
<span class="lineno"> 1471 </span>-- terms.
<span class="lineno"> 1472 </span>--
<span class="lineno"> 1473 </span>-- &gt; minNat : Nat -&gt; Nat -&gt; Nat
<span class="lineno"> 1474 </span>scMinNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1475 </span><span class="decl"><span class="nottickedoff">scMinNat sc x y = scGlobalApply sc &quot;Prelude.minNat&quot; [x,y]</span></span>
<span class="lineno"> 1476 </span>
<span class="lineno"> 1477 </span>-- | Create a term computing the maximum of the two given (natural number)
<span class="lineno"> 1478 </span>-- terms.
<span class="lineno"> 1479 </span>--
<span class="lineno"> 1480 </span>-- &gt; maxNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno"> 1481 </span>scMaxNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1482 </span><span class="decl"><span class="nottickedoff">scMaxNat sc x y = scGlobalApply sc &quot;Prelude.maxNat&quot; [x,y]</span></span>
<span class="lineno"> 1483 </span>
<span class="lineno"> 1484 </span>-- Primitive operations on Integer
<span class="lineno"> 1485 </span>
<span class="lineno"> 1486 </span>-- | Create a term representing the prelude Integer type.
<span class="lineno"> 1487 </span>scIntegerType :: SharedContext -&gt; IO Term
<span class="lineno"> 1488 </span><span class="decl"><span class="istickedoff">scIntegerType sc = scGlobalDef sc preludeIntegerIdent</span></span>
<span class="lineno"> 1489 </span>
<span class="lineno"> 1490 </span>-- | Create an integer constant term from an 'Integer'.
<span class="lineno"> 1491 </span>scIntegerConst :: SharedContext -&gt; Integer -&gt; IO Term
<span class="lineno"> 1492 </span><span class="decl"><span class="nottickedoff">scIntegerConst sc i</span>
<span class="lineno"> 1493 </span><span class="spaces">  </span><span class="nottickedoff">| i &gt;= 0    = scNatToInt sc =&lt;&lt; scNat sc (fromInteger i)</span>
<span class="lineno"> 1494 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = scIntNeg sc =&lt;&lt; scNatToInt sc =&lt;&lt; scNat sc (fromInteger (- i))</span></span>
<span class="lineno"> 1495 </span>
<span class="lineno"> 1496 </span>-- | Create a term applying the integer addition primitive.
<span class="lineno"> 1497 </span>--
<span class="lineno"> 1498 </span>-- &gt; intAdd : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1499 </span>scIntAdd :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1500 </span><span class="decl"><span class="nottickedoff">scIntAdd sc x y = scGlobalApply sc &quot;Prelude.intAdd&quot; [x, y]</span></span>
<span class="lineno"> 1501 </span>
<span class="lineno"> 1502 </span>-- | Create a term applying the integer subtraction primitive.
<span class="lineno"> 1503 </span>--
<span class="lineno"> 1504 </span>-- &gt; intSub : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1505 </span>scIntSub :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1506 </span><span class="decl"><span class="nottickedoff">scIntSub sc x y = scGlobalApply sc &quot;Prelude.intSub&quot; [x, y]</span></span>
<span class="lineno"> 1507 </span>
<span class="lineno"> 1508 </span>-- | Create a term applying the integer multiplication primitive.
<span class="lineno"> 1509 </span>--
<span class="lineno"> 1510 </span>-- &gt; intMul : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1511 </span>scIntMul :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1512 </span><span class="decl"><span class="nottickedoff">scIntMul sc x y = scGlobalApply sc &quot;Prelude.intMul&quot; [x, y]</span></span>
<span class="lineno"> 1513 </span>
<span class="lineno"> 1514 </span>-- | Create a term applying the integer division primitive.
<span class="lineno"> 1515 </span>--
<span class="lineno"> 1516 </span>-- &gt; intDiv : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1517 </span>scIntDiv :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1518 </span><span class="decl"><span class="nottickedoff">scIntDiv sc x y = scGlobalApply sc &quot;Prelude.intDiv&quot; [x, y]</span></span>
<span class="lineno"> 1519 </span>
<span class="lineno"> 1520 </span>-- | Create a term applying the integer modulus primitive.
<span class="lineno"> 1521 </span>--
<span class="lineno"> 1522 </span>-- &gt; intMod : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1523 </span>scIntMod :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1524 </span><span class="decl"><span class="nottickedoff">scIntMod sc x y = scGlobalApply sc &quot;Prelude.intMod&quot; [x, y]</span></span>
<span class="lineno"> 1525 </span>
<span class="lineno"> 1526 </span>-- | Create a term applying the integer min primitive.
<span class="lineno"> 1527 </span>--
<span class="lineno"> 1528 </span>-- &gt; intMin : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1529 </span>scIntMin :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1530 </span><span class="decl"><span class="nottickedoff">scIntMin sc x y = scGlobalApply sc &quot;Prelude.intMin&quot; [x, y]</span></span>
<span class="lineno"> 1531 </span>
<span class="lineno"> 1532 </span>-- | Create a term applying the integer max primitive.
<span class="lineno"> 1533 </span>--
<span class="lineno"> 1534 </span>-- &gt; intMax : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1535 </span>scIntMax :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1536 </span><span class="decl"><span class="nottickedoff">scIntMax sc x y = scGlobalApply sc &quot;Prelude.intMax&quot; [x, y]</span></span>
<span class="lineno"> 1537 </span>
<span class="lineno"> 1538 </span>-- | Create a term applying the negation integer primitive.
<span class="lineno"> 1539 </span>--
<span class="lineno"> 1540 </span>-- &gt; intNeg : Integer -&gt; Integer;
<span class="lineno"> 1541 </span>scIntNeg :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1542 </span><span class="decl"><span class="istickedoff">scIntNeg sc x = scGlobalApply sc &quot;Prelude.intNeg&quot; [x]</span></span>
<span class="lineno"> 1543 </span>
<span class="lineno"> 1544 </span>-- | Create a term applying the absolute value integer primitive.
<span class="lineno"> 1545 </span>--
<span class="lineno"> 1546 </span>-- &gt; intAbs : Integer -&gt; Integer;
<span class="lineno"> 1547 </span>scIntAbs :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1548 </span><span class="decl"><span class="nottickedoff">scIntAbs sc x = scGlobalApply sc &quot;Prelude.intAbs&quot; [x]</span></span>
<span class="lineno"> 1549 </span>
<span class="lineno"> 1550 </span>-- | Create a term applying the integer equality testing primitive.
<span class="lineno"> 1551 </span>--
<span class="lineno"> 1552 </span>-- &gt; intEq : Integer -&gt; Integer -&gt; Bool;
<span class="lineno"> 1553 </span>scIntEq :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1554 </span><span class="decl"><span class="istickedoff">scIntEq sc x y = scGlobalApply sc &quot;Prelude.intEq&quot; [x, y]</span></span>
<span class="lineno"> 1555 </span>
<span class="lineno"> 1556 </span>-- | Create a term applying the integer less-than-or-equal primitive.
<span class="lineno"> 1557 </span>--
<span class="lineno"> 1558 </span>-- &gt; intLe : Integer -&gt; Integer -&gt; Bool;
<span class="lineno"> 1559 </span>scIntLe :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1560 </span><span class="decl"><span class="nottickedoff">scIntLe sc x y = scGlobalApply sc &quot;Prelude.intLe&quot; [x, y]</span></span>
<span class="lineno"> 1561 </span>
<span class="lineno"> 1562 </span>-- | Create a term applying the integer less-than primitive.
<span class="lineno"> 1563 </span>--
<span class="lineno"> 1564 </span>-- &gt; intLt : Integer -&gt; Integer -&gt; Bool;
<span class="lineno"> 1565 </span>scIntLt :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1566 </span><span class="decl"><span class="nottickedoff">scIntLt sc x y = scGlobalApply sc &quot;Prelude.intLt&quot; [x, y]</span></span>
<span class="lineno"> 1567 </span>
<span class="lineno"> 1568 </span>-- | Create a term computing a @Nat@ from an @Integer@, if possible.
<span class="lineno"> 1569 </span>--
<span class="lineno"> 1570 </span>-- &gt; intToNat : Integer -&gt; Nat;
<span class="lineno"> 1571 </span>scIntToNat
<span class="lineno"> 1572 </span>   :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1573 </span><span class="decl"><span class="nottickedoff">scIntToNat sc x = scGlobalApply sc &quot;Prelude.intToNat&quot; [x]</span></span>
<span class="lineno"> 1574 </span>
<span class="lineno"> 1575 </span>-- | Create a term computing an @Integer@ from a @Nat@.
<span class="lineno"> 1576 </span>--
<span class="lineno"> 1577 </span>-- &gt; natToInt : Nat -&gt; Integer;
<span class="lineno"> 1578 </span>scNatToInt
<span class="lineno"> 1579 </span>   :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1580 </span><span class="decl"><span class="istickedoff">scNatToInt sc x = scGlobalApply sc &quot;Prelude.natToInt&quot; [x]</span></span>
<span class="lineno"> 1581 </span>
<span class="lineno"> 1582 </span>-- | Create a term computing a bitvector of length n from an @Integer@, if
<span class="lineno"> 1583 </span>-- possible.
<span class="lineno"> 1584 </span>--
<span class="lineno"> 1585 </span>-- &gt; intToBv : (n::Nat) -&gt; Integer -&gt; Vec n Bool;
<span class="lineno"> 1586 </span>scIntToBv
<span class="lineno"> 1587 </span>   :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1588 </span><span class="decl"><span class="nottickedoff">scIntToBv sc n x = scGlobalApply sc &quot;Prelude.intToBv&quot; [n,x]</span></span>
<span class="lineno"> 1589 </span>
<span class="lineno"> 1590 </span>-- | Create a term computing an @Integer@ from a bitvector of length n.
<span class="lineno"> 1591 </span>-- This produces the unsigned value of the bitvector.
<span class="lineno"> 1592 </span>--
<span class="lineno"> 1593 </span>-- &gt; bvToInt : (n : Nat) -&gt; Vec n Bool -&gt; Integer;
<span class="lineno"> 1594 </span>scBvToInt
<span class="lineno"> 1595 </span>   :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1596 </span><span class="decl"><span class="nottickedoff">scBvToInt sc n x = scGlobalApply sc &quot;Prelude.bvToInt&quot; [n,x]</span></span>
<span class="lineno"> 1597 </span>
<span class="lineno"> 1598 </span>-- | Create a term computing an @Integer@ from a bitvector of length n.
<span class="lineno"> 1599 </span>-- This produces the 2's complement signed value of the bitvector.
<span class="lineno"> 1600 </span>--
<span class="lineno"> 1601 </span>-- &gt; sbvToInt : (n : Nat) -&gt; Vec n Bool -&gt; Integer;
<span class="lineno"> 1602 </span>scSbvToInt
<span class="lineno"> 1603 </span>   :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1604 </span><span class="decl"><span class="nottickedoff">scSbvToInt sc n x = scGlobalApply sc &quot;Prelude.sbvToInt&quot; [n,x]</span></span>
<span class="lineno"> 1605 </span>
<span class="lineno"> 1606 </span>
<span class="lineno"> 1607 </span>-- Primitive operations on IntMod
<span class="lineno"> 1608 </span>
<span class="lineno"> 1609 </span>-- | Create a term representing the prelude @IntMod@ type.
<span class="lineno"> 1610 </span>--
<span class="lineno"> 1611 </span>-- &gt; IntMod : Nat -&gt; sort 0;
<span class="lineno"> 1612 </span>scIntModType :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1613 </span><span class="decl"><span class="nottickedoff">scIntModType sc n = scGlobalApply sc &quot;Prelude.IntMod&quot; [n]</span></span>
<span class="lineno"> 1614 </span>
<span class="lineno"> 1615 </span>-- | Convert an integer to an integer mod n.
<span class="lineno"> 1616 </span>--
<span class="lineno"> 1617 </span>-- &gt; toIntMod : (n : Nat) -&gt; Integer -&gt; IntMod n;
<span class="lineno"> 1618 </span>scToIntMod :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1619 </span><span class="decl"><span class="nottickedoff">scToIntMod sc n x = scGlobalApply sc &quot;Prelude.toIntMod&quot; [n, x]</span></span>
<span class="lineno"> 1620 </span>
<span class="lineno"> 1621 </span>-- | Convert an integer mod n to an integer.
<span class="lineno"> 1622 </span>--
<span class="lineno"> 1623 </span>-- &gt; fromIntMod : (n : Nat) -&gt; IntMod n -&gt; Integer;
<span class="lineno"> 1624 </span>scFromIntMod :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1625 </span><span class="decl"><span class="nottickedoff">scFromIntMod sc n x = scGlobalApply sc &quot;Prelude.fromIntMod&quot; [n, x]</span></span>
<span class="lineno"> 1626 </span>
<span class="lineno"> 1627 </span>-- | Equality test on the @IntMod@ type
<span class="lineno"> 1628 </span>--
<span class="lineno"> 1629 </span>-- &gt; intModEq  : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; Bool;
<span class="lineno"> 1630 </span>scIntModEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1631 </span><span class="decl"><span class="nottickedoff">scIntModEq sc n x y = scGlobalApply sc &quot;Prelude.intModEq&quot; [n,x,y]</span></span>
<span class="lineno"> 1632 </span>
<span class="lineno"> 1633 </span>-- | Addition of @IntMod@ values
<span class="lineno"> 1634 </span>--
<span class="lineno"> 1635 </span>-- &gt; intModAdd : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1636 </span>scIntModAdd :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1637 </span><span class="decl"><span class="nottickedoff">scIntModAdd sc n x y = scGlobalApply sc &quot;Prelude.intModAdd&quot; [n,x,y]</span></span>
<span class="lineno"> 1638 </span>
<span class="lineno"> 1639 </span>-- | Subtraction of @IntMod@ values
<span class="lineno"> 1640 </span>--
<span class="lineno"> 1641 </span>-- &gt; intModSub : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1642 </span>scIntModSub :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1643 </span><span class="decl"><span class="nottickedoff">scIntModSub sc n x y = scGlobalApply sc &quot;Prelude.intModSub&quot; [n,x,y]</span></span>
<span class="lineno"> 1644 </span>
<span class="lineno"> 1645 </span>-- | Multiplication of @IntMod@ values
<span class="lineno"> 1646 </span>--
<span class="lineno"> 1647 </span>-- &gt; intModMul : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1648 </span>scIntModMul :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1649 </span><span class="decl"><span class="nottickedoff">scIntModMul sc n x y = scGlobalApply sc &quot;Prelude.intModMul&quot; [n,x,y]</span></span>
<span class="lineno"> 1650 </span>
<span class="lineno"> 1651 </span>-- | Negation (additive inverse) of @IntMod@ values
<span class="lineno"> 1652 </span>--
<span class="lineno"> 1653 </span>-- &gt; intModNeg : (n : Nat) -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1654 </span>scIntModNeg :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1655 </span><span class="decl"><span class="nottickedoff">scIntModNeg sc n x = scGlobalApply sc &quot;Prelude.intModNeg&quot; [n,x]</span></span>
<span class="lineno"> 1656 </span>
<span class="lineno"> 1657 </span>
<span class="lineno"> 1658 </span>-- Primitive operations on bitvectors
<span class="lineno"> 1659 </span>
<span class="lineno"> 1660 </span>-- | Create a term computing the type of a length-n bitvector.
<span class="lineno"> 1661 </span>--
<span class="lineno"> 1662 </span>-- &gt; bitvector : (n : Nat) -&gt; sort 1
<span class="lineno"> 1663 </span>scBitvector :: SharedContext -&gt; Natural -&gt; IO Term
<span class="lineno"> 1664 </span><span class="decl"><span class="istickedoff">scBitvector sc size =</span>
<span class="lineno"> 1665 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- scNat sc size</span>
<span class="lineno"> 1666 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- scBoolType sc</span>
<span class="lineno"> 1667 </span><span class="spaces">     </span><span class="istickedoff">scVecType sc s t</span></span>
<span class="lineno"> 1668 </span>
<span class="lineno"> 1669 </span>-- | Create a term computing a bitvector of length x from a @Nat@, if possible.
<span class="lineno"> 1670 </span>--
<span class="lineno"> 1671 </span>-- &gt; bvNat : (n : Nat) -&gt; Nat -&gt; Vec n Bool;
<span class="lineno"> 1672 </span>scBvNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1673 </span><span class="decl"><span class="istickedoff">scBvNat sc x y = scGlobalApply sc &quot;Prelude.bvNat&quot; [x, y]</span></span>
<span class="lineno"> 1674 </span>
<span class="lineno"> 1675 </span>-- | Create a term computing a @Nat@ from a bitvector of length n.
<span class="lineno"> 1676 </span>--
<span class="lineno"> 1677 </span>-- &gt; bvToNat : (n : Nat) -&gt; Vec n Bool -&gt; Nat;
<span class="lineno"> 1678 </span>scBvToNat :: SharedContext -&gt; Natural -&gt; Term -&gt; IO Term
<span class="lineno"> 1679 </span><span class="decl"><span class="istickedoff">scBvToNat sc n x = do</span>
<span class="lineno"> 1680 </span><span class="spaces">    </span><span class="istickedoff">n' &lt;- scNat sc n</span>
<span class="lineno"> 1681 </span><span class="spaces">    </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.bvToNat&quot; [n',x]</span></span>
<span class="lineno"> 1682 </span>
<span class="lineno"> 1683 </span>-- | Create a @bvNat@ term computing a bitvector of the given length
<span class="lineno"> 1684 </span>-- representing the given 'Integer' value (if possible).
<span class="lineno"> 1685 </span>scBvConst :: SharedContext -&gt; Natural -&gt; Integer -&gt; IO Term
<span class="lineno"> 1686 </span><span class="decl"><span class="istickedoff">scBvConst sc w v = assert (w &lt;= fromIntegral (maxBound :: Int)) $ do</span>
<span class="lineno"> 1687 </span><span class="spaces">  </span><span class="istickedoff">x &lt;- scNat sc w</span>
<span class="lineno"> 1688 </span><span class="spaces">  </span><span class="istickedoff">y &lt;- scNat sc $ fromInteger $ v .&amp;. (1 `shiftL` fromIntegral w - 1)</span>
<span class="lineno"> 1689 </span><span class="spaces">  </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.bvNat&quot; [x, y]</span></span>
<span class="lineno"> 1690 </span>
<span class="lineno"> 1691 </span>-- | Create a vector literal term computing a bitvector of the given length
<span class="lineno"> 1692 </span>-- representing the given 'Integer' value (if possible).
<span class="lineno"> 1693 </span>scBvLit :: SharedContext -&gt; Natural -&gt; Integer -&gt; IO Term
<span class="lineno"> 1694 </span><span class="decl"><span class="nottickedoff">scBvLit sc w v = assert (w &lt;= fromIntegral (maxBound :: Int)) $ do</span>
<span class="lineno"> 1695 </span><span class="spaces">  </span><span class="nottickedoff">do bool_tp &lt;- scBoolType sc</span>
<span class="lineno"> 1696 </span><span class="spaces">     </span><span class="nottickedoff">bits &lt;- mapM (scBool sc . testBit v)</span>
<span class="lineno"> 1697 </span><span class="spaces">                  </span><span class="nottickedoff">[(fromIntegral w - 1), (fromIntegral w - 2) .. 0]</span>
<span class="lineno"> 1698 </span><span class="spaces">     </span><span class="nottickedoff">scVector sc bool_tp bits</span></span>
<span class="lineno"> 1699 </span>
<span class="lineno"> 1700 </span>-- | Create a term computing the bitvector of given length representing 0 if
<span class="lineno"> 1701 </span>-- the other given term evaluates to @False@ and representing 1 if the other
<span class="lineno"> 1702 </span>-- given term evaluates to @True@.
<span class="lineno"> 1703 </span>--
<span class="lineno"> 1704 </span>-- &gt; bvBool : (n : Nat) -&gt; Bool -&gt; Vec n Bool;
<span class="lineno"> 1705 </span>scBvBool :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1706 </span><span class="decl"><span class="nottickedoff">scBvBool sc n x = scGlobalApply sc &quot;Prelude.bvBool&quot; [n, x]</span></span>
<span class="lineno"> 1707 </span>
<span class="lineno"> 1708 </span>-- | Create a term returning true if and only if the given bitvector represents
<span class="lineno"> 1709 </span>-- a nonzero value.
<span class="lineno"> 1710 </span>--
<span class="lineno"> 1711 </span>-- &gt; bvNonzero : (n : Nat) -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1712 </span>scBvNonzero :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1713 </span><span class="decl"><span class="istickedoff">scBvNonzero sc n x = scGlobalApply sc &quot;Prelude.bvNonzero&quot; [n, x]</span></span>
<span class="lineno"> 1714 </span>
<span class="lineno"> 1715 </span>-- | Create a term computing the 2's complement negation of the given
<span class="lineno"> 1716 </span>-- bitvector.
<span class="lineno"> 1717 </span>-- &gt; bvNeg : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1718 </span>scBvNeg :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1719 </span><span class="decl"><span class="nottickedoff">scBvNeg sc n x = scGlobalApply sc &quot;Prelude.bvNeg&quot; [n, x]</span></span>
<span class="lineno"> 1720 </span>
<span class="lineno"> 1721 </span>-- | Create a term applying the bitvector addition primitive.
<span class="lineno"> 1722 </span>--
<span class="lineno"> 1723 </span>-- &gt; bvAdd : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1724 </span>scBvAdd :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1725 </span><span class="decl"><span class="istickedoff">scBvAdd sc n x y = scGlobalApply sc &quot;Prelude.bvAdd&quot; [n, x, y]</span></span>
<span class="lineno"> 1726 </span>
<span class="lineno"> 1727 </span>-- | Create a term applying the bitvector subtraction primitive.
<span class="lineno"> 1728 </span>--
<span class="lineno"> 1729 </span>-- &gt; bvSub : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1730 </span>scBvSub :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1731 </span><span class="decl"><span class="istickedoff">scBvSub sc n x y = scGlobalApply sc &quot;Prelude.bvSub&quot; [n, x, y]</span></span>
<span class="lineno"> 1732 </span>
<span class="lineno"> 1733 </span>-- | Create a term applying the bitvector multiplication primitive.
<span class="lineno"> 1734 </span>--
<span class="lineno"> 1735 </span>-- &gt; bvMul : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1736 </span>scBvMul :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1737 </span><span class="decl"><span class="istickedoff">scBvMul sc n x y = scGlobalApply sc &quot;Prelude.bvMul&quot; [n, x, y]</span></span>
<span class="lineno"> 1738 </span>
<span class="lineno"> 1739 </span>-- | Create a term applying the bitvector (unsigned) modulus primitive.
<span class="lineno"> 1740 </span>--
<span class="lineno"> 1741 </span>-- &gt; bvURem : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1742 </span>scBvURem :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1743 </span><span class="decl"><span class="istickedoff">scBvURem sc n x y = scGlobalApply sc &quot;Prelude.bvURem&quot; [n, x, y]</span></span>
<span class="lineno"> 1744 </span>
<span class="lineno"> 1745 </span>-- | Create a term applying the bitvector (unsigned) division primitive.
<span class="lineno"> 1746 </span>--
<span class="lineno"> 1747 </span>-- &gt; bvUDiv : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1748 </span>scBvUDiv :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1749 </span><span class="decl"><span class="istickedoff">scBvUDiv sc n x y = scGlobalApply sc &quot;Prelude.bvUDiv&quot; [n, x, y]</span></span>
<span class="lineno"> 1750 </span>
<span class="lineno"> 1751 </span>-- | Create a term applying the bitvector (signed) modulus primitive.
<span class="lineno"> 1752 </span>--
<span class="lineno"> 1753 </span>-- &gt; bvSRem : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1754 </span>scBvSRem :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1755 </span><span class="decl"><span class="istickedoff">scBvSRem sc n x y = scGlobalApply sc &quot;Prelude.bvSRem&quot; [n, x, y]</span></span>
<span class="lineno"> 1756 </span>
<span class="lineno"> 1757 </span>-- | Create a term applying the bitvector (signed) division primitive.
<span class="lineno"> 1758 </span>--
<span class="lineno"> 1759 </span>-- &gt; bvSDiv : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1760 </span>scBvSDiv :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1761 </span><span class="decl"><span class="nottickedoff">scBvSDiv sc n x y = scGlobalApply sc &quot;Prelude.bvSDiv&quot; [n, x, y]</span></span>
<span class="lineno"> 1762 </span>
<span class="lineno"> 1763 </span>-- | Create a term applying the lg2 bitvector primitive.
<span class="lineno"> 1764 </span>--
<span class="lineno"> 1765 </span>-- &gt; bvLg2 : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1766 </span>scBvLg2 :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1767 </span><span class="decl"><span class="nottickedoff">scBvLg2 sc n x = scGlobalApply sc &quot;Prelude.bvLg2&quot; [n, x]</span></span>
<span class="lineno"> 1768 </span>
<span class="lineno"> 1769 </span>-- | Create a term applying the population count bitvector primitive.
<span class="lineno"> 1770 </span>--
<span class="lineno"> 1771 </span>-- &gt; bvPopcount : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1772 </span>scBvPopcount :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1773 </span><span class="decl"><span class="istickedoff">scBvPopcount sc n x = scGlobalApply sc &quot;Prelude.bvPopcount&quot; [n, x]</span></span>
<span class="lineno"> 1774 </span>
<span class="lineno"> 1775 </span>-- | Create a term applying the leading zero counting bitvector primitive.
<span class="lineno"> 1776 </span>--
<span class="lineno"> 1777 </span>-- &gt; bvCountLeadingZeros : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1778 </span>scBvCountLeadingZeros :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1779 </span><span class="decl"><span class="istickedoff">scBvCountLeadingZeros sc n x = scGlobalApply sc &quot;Prelude.bvCountLeadingZeros&quot; [n, x]</span></span>
<span class="lineno"> 1780 </span>
<span class="lineno"> 1781 </span>-- | Create a term applying the trailing zero counting bitvector primitive.
<span class="lineno"> 1782 </span>--
<span class="lineno"> 1783 </span>-- &gt; bvCountTrailingZeros : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1784 </span>scBvCountTrailingZeros :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1785 </span><span class="decl"><span class="istickedoff">scBvCountTrailingZeros sc n x = scGlobalApply sc &quot;Prelude.bvCountTrailingZeros&quot; [n, x]</span></span>
<span class="lineno"> 1786 </span>
<span class="lineno"> 1787 </span>-- | Create a term applying the bit-wise and primitive.
<span class="lineno"> 1788 </span>--
<span class="lineno"> 1789 </span>-- &gt; bvAnd : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1790 </span>scBvAnd :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1791 </span><span class="decl"><span class="istickedoff">scBvAnd sc n x y = scGlobalApply sc &quot;Prelude.bvAnd&quot; [n, x, y]</span></span>
<span class="lineno"> 1792 </span>
<span class="lineno"> 1793 </span>-- | Create a term applying the bit-wise xor primitive.
<span class="lineno"> 1794 </span>--
<span class="lineno"> 1795 </span>-- &gt; bvXor : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1796 </span>scBvXor :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1797 </span><span class="decl"><span class="istickedoff">scBvXor sc n x y = scGlobalApply sc &quot;Prelude.bvXor&quot; [n, x, y]</span></span>
<span class="lineno"> 1798 </span>
<span class="lineno"> 1799 </span>-- | Create a term applying the bit-wise or primitive.
<span class="lineno"> 1800 </span>--
<span class="lineno"> 1801 </span>-- &gt; bvOr : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1802 </span>scBvOr :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1803 </span><span class="decl"><span class="istickedoff">scBvOr  sc n x y = scGlobalApply sc &quot;Prelude.bvOr&quot;  [n, x, y]</span></span>
<span class="lineno"> 1804 </span>
<span class="lineno"> 1805 </span>-- | Create a term applying the bit-wise negation primitive.
<span class="lineno"> 1806 </span>--
<span class="lineno"> 1807 </span>-- &gt; bvNot : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1808 </span>scBvNot :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1809 </span><span class="decl"><span class="istickedoff">scBvNot sc n x = scGlobalApply sc &quot;Prelude.bvNot&quot; [n, x]</span></span>
<span class="lineno"> 1810 </span>
<span class="lineno"> 1811 </span>-- | Create a term computing whether the two given bitvectors (of equal length)
<span class="lineno"> 1812 </span>-- are equal.
<span class="lineno"> 1813 </span>--
<span class="lineno"> 1814 </span>-- &gt; bvEq : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1815 </span>scBvEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1816 </span><span class="decl"><span class="istickedoff">scBvEq  sc n x y = scGlobalApply sc &quot;Prelude.bvEq&quot;  [n, x, y]</span></span>
<span class="lineno"> 1817 </span>
<span class="lineno"> 1818 </span>-- | Create a term applying the bitvector (unsigned) greater-than-or-equal
<span class="lineno"> 1819 </span>-- primitive.
<span class="lineno"> 1820 </span>--
<span class="lineno"> 1821 </span>-- &gt; bvuge : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1822 </span>scBvUGe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1823 </span><span class="decl"><span class="nottickedoff">scBvUGe sc n x y = scGlobalApply sc &quot;Prelude.bvuge&quot; [n, x, y]</span></span>
<span class="lineno"> 1824 </span>
<span class="lineno"> 1825 </span>-- | Create a term applying the bitvector (unsigned) less-than-or-equal
<span class="lineno"> 1826 </span>-- primitive.
<span class="lineno"> 1827 </span>--
<span class="lineno"> 1828 </span>-- &gt; bvule : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1829 </span>scBvULe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1830 </span><span class="decl"><span class="istickedoff">scBvULe sc n x y = scGlobalApply sc &quot;Prelude.bvule&quot; [n, x, y]</span></span>
<span class="lineno"> 1831 </span>
<span class="lineno"> 1832 </span>-- | Create a term applying the bitvector (unsigned) greater-than primitive.
<span class="lineno"> 1833 </span>--
<span class="lineno"> 1834 </span>-- &gt; bvugt : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1835 </span>scBvUGt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1836 </span><span class="decl"><span class="nottickedoff">scBvUGt sc n x y = scGlobalApply sc &quot;Prelude.bvugt&quot; [n, x, y]</span></span>
<span class="lineno"> 1837 </span>
<span class="lineno"> 1838 </span>-- | Create a term applying the bitvector (unsigned) less-than primitive.
<span class="lineno"> 1839 </span>--
<span class="lineno"> 1840 </span>-- &gt; bvult : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1841 </span>scBvULt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1842 </span><span class="decl"><span class="istickedoff">scBvULt sc n x y = scGlobalApply sc &quot;Prelude.bvult&quot; [n, x, y]</span></span>
<span class="lineno"> 1843 </span>
<span class="lineno"> 1844 </span>-- | Create a term applying the bitvector (signed) greater-than-or-equal
<span class="lineno"> 1845 </span>-- primitive.
<span class="lineno"> 1846 </span>--
<span class="lineno"> 1847 </span>-- &gt; bvsge : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1848 </span>scBvSGe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1849 </span><span class="decl"><span class="nottickedoff">scBvSGe sc n x y = scGlobalApply sc &quot;Prelude.bvsge&quot; [n, x, y]</span></span>
<span class="lineno"> 1850 </span>
<span class="lineno"> 1851 </span>-- | Create a term applying the bitvector (signed) less-than-or-equal
<span class="lineno"> 1852 </span>-- primitive.
<span class="lineno"> 1853 </span>--
<span class="lineno"> 1854 </span>-- &gt; bvsle : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1855 </span>scBvSLe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1856 </span><span class="decl"><span class="nottickedoff">scBvSLe sc n x y = scGlobalApply sc &quot;Prelude.bvsle&quot; [n, x, y]</span></span>
<span class="lineno"> 1857 </span>
<span class="lineno"> 1858 </span>-- | Create a term applying the bitvector (signed) greater-than primitive.
<span class="lineno"> 1859 </span>--
<span class="lineno"> 1860 </span>-- &gt; bvsgt : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1861 </span>scBvSGt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1862 </span><span class="decl"><span class="nottickedoff">scBvSGt sc n x y = scGlobalApply sc &quot;Prelude.bvsgt&quot; [n, x, y]</span></span>
<span class="lineno"> 1863 </span>
<span class="lineno"> 1864 </span>-- | Create a term applying the bitvector (signed) less-than primitive.
<span class="lineno"> 1865 </span>--
<span class="lineno"> 1866 </span>-- &gt; bvslt : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1867 </span>scBvSLt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1868 </span><span class="decl"><span class="istickedoff">scBvSLt sc n x y = scGlobalApply sc &quot;Prelude.bvslt&quot; [n, x, y]</span></span>
<span class="lineno"> 1869 </span>
<span class="lineno"> 1870 </span>-- | Create a term applying the left-shift primitive.
<span class="lineno"> 1871 </span>--
<span class="lineno"> 1872 </span>-- &gt; bvShl : (n : Nat) -&gt; Vec n Bool -&gt; Nat -&gt; Vec n Bool;
<span class="lineno"> 1873 </span>scBvShl :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1874 </span><span class="decl"><span class="istickedoff">scBvShl sc n x y = scGlobalApply sc &quot;Prelude.bvShl&quot; [n, x, y]</span></span>
<span class="lineno"> 1875 </span>
<span class="lineno"> 1876 </span>-- | Create a term applying the logical right-shift primitive.
<span class="lineno"> 1877 </span>--
<span class="lineno"> 1878 </span>-- &gt; bvShr : (n : Nat) -&gt; Vec n Bool -&gt; Nat -&gt; Vec n Bool;
<span class="lineno"> 1879 </span>scBvShr :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1880 </span><span class="decl"><span class="istickedoff">scBvShr sc n x y = scGlobalApply sc &quot;Prelude.bvShr&quot; [n, x, y]</span></span>
<span class="lineno"> 1881 </span>
<span class="lineno"> 1882 </span>-- | Create a term applying the arithmetic/signed right-shift primitive.
<span class="lineno"> 1883 </span>--
<span class="lineno"> 1884 </span>-- &gt; bvSShr : (w : Nat) -&gt; Vec (Succ w) Bool -&gt; Nat -&gt; Vec (Succ w) Bool;
<span class="lineno"> 1885 </span>scBvSShr :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1886 </span><span class="decl"><span class="istickedoff">scBvSShr sc n x y = scGlobalApply sc &quot;Prelude.bvSShr&quot; [n, x, y]</span></span>
<span class="lineno"> 1887 </span>
<span class="lineno"> 1888 </span>-- | Create a term applying the unsigned bitvector extension primitive.
<span class="lineno"> 1889 </span>--
<span class="lineno"> 1890 </span>-- &gt; bvUExt : (m n : Nat) -&gt; Vec n Bool -&gt; Vec (addNat m n) Bool;
<span class="lineno"> 1891 </span>scBvUExt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1892 </span><span class="decl"><span class="istickedoff">scBvUExt sc n m x = scGlobalApply sc &quot;Prelude.bvUExt&quot; [n,m,x]</span></span>
<span class="lineno"> 1893 </span>
<span class="lineno"> 1894 </span>-- | Create a term applying the signed bitvector extension primitive.
<span class="lineno"> 1895 </span>--
<span class="lineno"> 1896 </span>-- &gt; bvSExt : (m n : Nat) -&gt; Vec (Succ n) Bool -&gt; Vec (addNat m (Succ n)) Bool;
<span class="lineno"> 1897 </span>scBvSExt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1898 </span><span class="decl"><span class="istickedoff">scBvSExt sc n m x = scGlobalApply sc &quot;Prelude.bvSExt&quot; [n,m,x]</span></span>
<span class="lineno"> 1899 </span>
<span class="lineno"> 1900 </span>-- | Create a term applying the bitvector truncation primitive. Note that this
<span class="lineno"> 1901 </span>-- truncates starting from the most significant bit.
<span class="lineno"> 1902 </span>--
<span class="lineno"> 1903 </span>-- &gt; bvTrunc : (m n : Nat) -&gt; Vec (addNat m n) Bool -&gt; Vec n Bool;
<span class="lineno"> 1904 </span>scBvTrunc :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1905 </span><span class="decl"><span class="istickedoff">scBvTrunc sc n m x = scGlobalApply sc &quot;Prelude.bvTrunc&quot; [n,m,x]</span></span>
<span class="lineno"> 1906 </span>
<span class="lineno"> 1907 </span>-- | Create a term applying the @updNatFun@ primitive, which satisfies the
<span class="lineno"> 1908 </span>-- following laws:
<span class="lineno"> 1909 </span>--
<span class="lineno"> 1910 </span>-- &gt; updNatFun : (a : sort 0) -&gt; (Nat -&gt; a) -&gt; Nat -&gt; a -&gt; (Nat -&gt; a);
<span class="lineno"> 1911 </span>-- &gt; updNatFun a _ i v i == v
<span class="lineno"> 1912 </span>-- &gt; updNatFun a f i v x == f x, when i != x
<span class="lineno"> 1913 </span>scUpdNatFun :: SharedContext -&gt; Term -&gt; Term
<span class="lineno"> 1914 </span>            -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1915 </span><span class="decl"><span class="nottickedoff">scUpdNatFun sc a f i v = scGlobalApply sc &quot;Prelude.updNatFun&quot; [a, f, i, v]</span></span>
<span class="lineno"> 1916 </span>
<span class="lineno"> 1917 </span>-- | Create a term applying the @updBvFun@ primitive, which has the same
<span class="lineno"> 1918 </span>-- behavior as @updNatFun@ but acts on bitvectors.
<span class="lineno"> 1919 </span>--
<span class="lineno"> 1920 </span>-- &gt; updBvFun : (n : Nat) -&gt; (a : sort 0) -&gt; (Vec n Bool -&gt; a) -&gt; Vec n Bool -&gt; a -&gt; (Vec n Bool -&gt; a);
<span class="lineno"> 1921 </span>scUpdBvFun :: SharedContext -&gt; Term -&gt; Term
<span class="lineno"> 1922 </span>           -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1923 </span><span class="decl"><span class="nottickedoff">scUpdBvFun sc n a f i v = scGlobalApply sc &quot;Prelude.updBvFun&quot; [n, a, f, i, v]</span></span>
<span class="lineno"> 1924 </span>
<span class="lineno"> 1925 </span>-- | Create a term representing the type of arrays, given an index type and
<span class="lineno"> 1926 </span>-- element type (as 'Term's).
<span class="lineno"> 1927 </span>--
<span class="lineno"> 1928 </span>-- &gt; Array : sort 0 -&gt; sort 0 -&gt; sort 0
<span class="lineno"> 1929 </span>scArrayType :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1930 </span><span class="decl"><span class="istickedoff">scArrayType sc a b = scGlobalApply sc &quot;Prelude.Array&quot; [a, b]</span></span>
<span class="lineno"> 1931 </span>
<span class="lineno"> 1932 </span>-- | Create a term computing a constant array, given an index type, element type,
<span class="lineno"> 1933 </span>-- and element (all as 'Term's).
<span class="lineno"> 1934 </span>--
<span class="lineno"> 1935 </span>-- &gt; arrayConstant : (a b : sort 0) -&gt; b -&gt; (Array a b);
<span class="lineno"> 1936 </span>scArrayConstant :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1937 </span><span class="decl"><span class="istickedoff">scArrayConstant sc a b e = scGlobalApply sc &quot;Prelude.arrayConstant&quot; [a, b, e]</span></span>
<span class="lineno"> 1938 </span>
<span class="lineno"> 1939 </span>-- | Create a term computing the value at a particular index of an array.
<span class="lineno"> 1940 </span>--
<span class="lineno"> 1941 </span>-- &gt; arrayLookup : (a b : sort 0) -&gt; (Array a b) -&gt; a -&gt; b;
<span class="lineno"> 1942 </span>scArrayLookup :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1943 </span><span class="decl"><span class="istickedoff">scArrayLookup sc a b f i = scGlobalApply sc &quot;Prelude.arrayLookup&quot; [a, b, f, i]</span></span>
<span class="lineno"> 1944 </span>
<span class="lineno"> 1945 </span>-- | Create a term computing an array updated at a particular index.
<span class="lineno"> 1946 </span>--
<span class="lineno"> 1947 </span>-- &gt; arrayUpdate : (a b : sort 0) -&gt; (Array a b) -&gt; a -&gt; b -&gt; (Array a b);
<span class="lineno"> 1948 </span>scArrayUpdate :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1949 </span><span class="decl"><span class="istickedoff">scArrayUpdate sc a b f i e = scGlobalApply sc &quot;Prelude.arrayUpdate&quot; [a, b, f, i, e]</span></span>
<span class="lineno"> 1950 </span>
<span class="lineno"> 1951 </span>-- | Create a term computing the equality of two arrays.
<span class="lineno"> 1952 </span>--
<span class="lineno"> 1953 </span>-- &gt; arrayEq : (a b : sort 0) -&gt; (Array a b) -&gt; (Array a b) -&gt; Bool;
<span class="lineno"> 1954 </span>scArrayEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1955 </span><span class="decl"><span class="nottickedoff">scArrayEq sc a b x y = scGlobalApply sc &quot;Prelude.arrayEq&quot; [a, b, x, y]</span></span>
<span class="lineno"> 1956 </span>
<span class="lineno"> 1957 </span>-- &gt; arrayCopy : (n : Nat) -&gt; (a : sort 0) -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Array (Vec n Bool) a;
<span class="lineno"> 1958 </span>-- &gt; arrayCopy n a dest_arr dest_idx src_arr src_idx len
<span class="lineno"> 1959 </span>scArrayCopy :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1960 </span><span class="decl"><span class="nottickedoff">scArrayCopy sc n a f i g j l = scGlobalApply sc &quot;Prelude.arrayCopy&quot; [n, a, f, i, g, j, l]</span></span>
<span class="lineno"> 1961 </span>
<span class="lineno"> 1962 </span>-- &gt; arraySet : (n : Nat) -&gt; (a : sort 0) -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; a -&gt; Vec n Bool -&gt; Array (Vec n Bool) a;
<span class="lineno"> 1963 </span>-- &gt; arraySet n a arr idx val len
<span class="lineno"> 1964 </span>scArraySet :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1965 </span><span class="decl"><span class="nottickedoff">scArraySet sc n a f i e l = scGlobalApply sc &quot;Prelude.arraySet&quot; [n, a, f, i, e, l]</span></span>
<span class="lineno"> 1966 </span>
<span class="lineno"> 1967 </span>-- &gt; arrayRangeEq : (n : Nat) -&gt; (a : sort 0) -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1968 </span>-- &gt; arrayRangeEq n a lhs_arr lhs_idx rhs_arr rhs_idx len
<span class="lineno"> 1969 </span>scArrayRangeEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1970 </span><span class="decl"><span class="nottickedoff">scArrayRangeEq sc n a f i g j l = scGlobalApply sc &quot;Prelude.arrayRangeEq&quot; [n, a, f, i, g, j, l]</span></span>
<span class="lineno"> 1971 </span>
<span class="lineno"> 1972 </span>------------------------------------------------------------
<span class="lineno"> 1973 </span>
<span class="lineno"> 1974 </span>useChangeCache :: C m =&gt; IntCache m (Change v) -&gt; Int -&gt; ChangeT m v -&gt; ChangeT m v
<span class="lineno"> 1975 </span><span class="decl"><span class="istickedoff">useChangeCache c k a = ChangeT $ useIntCache c k (runChangeT a)</span></span>
<span class="lineno"> 1976 </span>
<span class="lineno"> 1977 </span>-- | Performs an action when a value has been modified, and otherwise
<span class="lineno"> 1978 </span>-- returns a pure value.
<span class="lineno"> 1979 </span>whenModified :: (Functor m, Monad m) =&gt; b -&gt; (a -&gt; m b) -&gt; ChangeT m a -&gt; ChangeT m b
<span class="lineno"> 1980 </span><span class="decl"><span class="istickedoff">whenModified b f m = ChangeT $ do</span>
<span class="lineno"> 1981 </span><span class="spaces">  </span><span class="istickedoff">ca &lt;- runChangeT m</span>
<span class="lineno"> 1982 </span><span class="spaces">  </span><span class="istickedoff">case ca of</span>
<span class="lineno"> 1983 </span><span class="spaces">    </span><span class="istickedoff">Original{} -&gt; return (Original b)</span>
<span class="lineno"> 1984 </span><span class="spaces">    </span><span class="istickedoff">Modified a -&gt; Modified &lt;$&gt; f a</span></span>
<span class="lineno"> 1985 </span>
<span class="lineno"> 1986 </span>-- | Can this term be evaluated to a constant?
<span class="lineno"> 1987 </span>-- The parameter is a set of names which should be considered opaque---if
<span class="lineno"> 1988 </span>-- we encounter any of these then the term is not considered to evaluate to
<span class="lineno"> 1989 </span>-- a constant.
<span class="lineno"> 1990 </span>isConstFoldTerm :: SharedContext -&gt; Set VarIndex -&gt; Term -&gt; IO Bool
<span class="lineno"> 1991 </span><span class="decl"><span class="istickedoff">isConstFoldTerm sc unint t</span>
<span class="lineno"> 1992 </span><span class="spaces">  </span><span class="istickedoff">| closedTerm t =</span>
<span class="lineno"> 1993 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno"> 1994 </span><span class="spaces">      </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1995 </span><span class="spaces">      </span><span class="istickedoff">let ?mmap = mm</span>
<span class="lineno"> 1996 </span><span class="spaces">      </span><span class="istickedoff">pure (isJust (go mempty t))</span>
<span class="lineno"> 1997 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = pure False</span>
<span class="lineno"> 1998 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1999 </span><span class="spaces">    </span><span class="istickedoff">go !vis term</span>
<span class="lineno"> 2000 </span><span class="spaces">      </span><span class="istickedoff">| IntSet.member (termIndex term) vis = Just vis</span>
<span class="lineno"> 2001 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goF (IntSet.insert (termIndex term) vis) (unwrapTermF term)</span>
<span class="lineno"> 2002 </span><span class="spaces">    </span><span class="istickedoff">goF vis tf =</span>
<span class="lineno"> 2003 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno"> 2004 </span><span class="spaces">        </span><span class="istickedoff">Constant c</span>
<span class="lineno"> 2005 </span><span class="spaces">          </span><span class="istickedoff">| nameIndex c `Set.member` unint -&gt; Nothing</span>
<span class="lineno"> 2006 </span><span class="spaces">          </span><span class="istickedoff">| Just (ResolvedDef d) &lt;- lookupVarIndexInMap (nameIndex c) ?mmap</span>
<span class="lineno"> 2007 </span><span class="spaces">          </span><span class="istickedoff">, Just t1 &lt;- defBody d -&gt; go vis t1</span>
<span class="lineno"> 2008 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; Just vis</span>
<span class="lineno"> 2009 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; foldM go vis tf</span></span>
<span class="lineno"> 2010 </span>
<span class="lineno"> 2011 </span>-- | Return a list of all free variables in the given term along with
<span class="lineno"> 2012 </span>-- their types, sorted by index.
<span class="lineno"> 2013 </span>getAllVars :: Term -&gt; [(VarName, Term)]
<span class="lineno"> 2014 </span><span class="decl"><span class="istickedoff">getAllVars t = Map.toList (getAllVarsMap t)</span></span>
<span class="lineno"> 2015 </span>
<span class="lineno"> 2016 </span>-- | Return a map of all free variables in the given term with their
<span class="lineno"> 2017 </span>-- types.
<span class="lineno"> 2018 </span>getAllVarsMap :: Term -&gt; Map VarName Term
<span class="lineno"> 2019 </span><span class="decl"><span class="istickedoff">getAllVarsMap t0 = State.evalState (go t0) IntMap.empty</span>
<span class="lineno"> 2020 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2021 </span><span class="spaces">    </span><span class="istickedoff">go :: Term -&gt; State.State (IntMap (Map VarName Term)) (Map VarName Term)</span>
<span class="lineno"> 2022 </span><span class="spaces">    </span><span class="istickedoff">go t</span>
<span class="lineno"> 2023 </span><span class="spaces">      </span><span class="istickedoff">| closedTerm t = pure Map.empty</span>
<span class="lineno"> 2024 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 2025 </span><span class="spaces">        </span><span class="istickedoff">do memo &lt;- State.get</span>
<span class="lineno"> 2026 </span><span class="spaces">           </span><span class="istickedoff">let i = termIndex t</span>
<span class="lineno"> 2027 </span><span class="spaces">           </span><span class="istickedoff">case IntMap.lookup i memo of</span>
<span class="lineno"> 2028 </span><span class="spaces">             </span><span class="istickedoff">Just vars -&gt; pure vars</span>
<span class="lineno"> 2029 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 2030 </span><span class="spaces">               </span><span class="istickedoff">do vars &lt;- termf (unwrapTermF t)</span>
<span class="lineno"> 2031 </span><span class="spaces">                  </span><span class="istickedoff">State.modify' (IntMap.insert i vars)</span>
<span class="lineno"> 2032 </span><span class="spaces">                  </span><span class="istickedoff">pure vars</span>
<span class="lineno"> 2033 </span><span class="spaces">    </span><span class="istickedoff">termf :: TermF Term -&gt; State.State (IntMap (Map VarName Term)) (Map VarName Term)</span>
<span class="lineno"> 2034 </span><span class="spaces">    </span><span class="istickedoff">termf tf =</span>
<span class="lineno"> 2035 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno"> 2036 </span><span class="spaces">        </span><span class="istickedoff">Variable x tp -&gt; pure (Map.singleton x tp)</span>
<span class="lineno"> 2037 </span><span class="spaces">        </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 2038 </span><span class="spaces">          </span><span class="istickedoff">do vars1 &lt;- go t1</span>
<span class="lineno"> 2039 </span><span class="spaces">             </span><span class="istickedoff">vars2 &lt;- go t2</span>
<span class="lineno"> 2040 </span><span class="spaces">             </span><span class="istickedoff">pure (vars1 &lt;&gt; Map.delete x vars2)</span>
<span class="lineno"> 2041 </span><span class="spaces">        </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 2042 </span><span class="spaces">          </span><span class="istickedoff">do vars1 &lt;- go t1</span>
<span class="lineno"> 2043 </span><span class="spaces">             </span><span class="istickedoff">vars2 &lt;- go t2</span>
<span class="lineno"> 2044 </span><span class="spaces">             </span><span class="istickedoff">pure (vars1 &lt;&gt; Map.delete x vars2)</span>
<span class="lineno"> 2045 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; Fold.fold &lt;$&gt; traverse go tf</span></span>
<span class="lineno"> 2046 </span>
<span class="lineno"> 2047 </span>getConstantSet :: Term -&gt; Map VarIndex NameInfo
<span class="lineno"> 2048 </span><span class="decl"><span class="nottickedoff">getConstantSet t0 = snd $ go (IntSet.empty, Map.empty) t0</span>
<span class="lineno"> 2049 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2050 </span><span class="spaces">    </span><span class="nottickedoff">go acc@(idxs, names) t</span>
<span class="lineno"> 2051 </span><span class="spaces">      </span><span class="nottickedoff">| IntSet.member (termIndex t) idxs = acc</span>
<span class="lineno"> 2052 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise = termf (IntSet.insert (termIndex t) idxs, names) (unwrapTermF t)</span>
<span class="lineno"> 2053 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2054 </span><span class="spaces">    </span><span class="nottickedoff">termf acc@(idxs, names) tf =</span>
<span class="lineno"> 2055 </span><span class="spaces">      </span><span class="nottickedoff">case tf of</span>
<span class="lineno"> 2056 </span><span class="spaces">        </span><span class="nottickedoff">Constant (Name vidx n) -&gt; (idxs, Map.insert vidx n names)</span>
<span class="lineno"> 2057 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; foldl' go acc tf</span></span>
<span class="lineno"> 2058 </span>
<span class="lineno"> 2059 </span>-- | Create a lambda term by abstracting over the list of arguments,
<span class="lineno"> 2060 </span>-- which must all be named variables (e.g. terms generated by
<span class="lineno"> 2061 </span>-- 'scVariable' or 'scFreshVariable').
<span class="lineno"> 2062 </span>scAbstractTerms :: SharedContext -&gt; [Term] -&gt; Term -&gt; IO Term
<span class="lineno"> 2063 </span><span class="decl"><span class="istickedoff">scAbstractTerms sc args body =</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="istickedoff">do vars &lt;- mapM toVar args</span>
<span class="lineno"> 2065 </span><span class="spaces">     </span><span class="istickedoff">scLambdaList sc vars body</span>
<span class="lineno"> 2066 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2067 </span><span class="spaces">    </span><span class="istickedoff">toVar :: Term -&gt; IO (VarName, Term)</span>
<span class="lineno"> 2068 </span><span class="spaces">    </span><span class="istickedoff">toVar t =</span>
<span class="lineno"> 2069 </span><span class="spaces">      </span><span class="istickedoff">case asVariable t of</span>
<span class="lineno"> 2070 </span><span class="spaces">        </span><span class="istickedoff">Just var -&gt; pure var</span>
<span class="lineno"> 2071 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;scAbstractTerms: expected Variable&quot;</span></span></span>
<span class="lineno"> 2072 </span>
<span class="lineno"> 2073 </span>-- | Abstract over the given list of variables by wrapping the given
<span class="lineno"> 2074 </span>-- term with lambdas.
<span class="lineno"> 2075 </span>-- However, the term will be eta-collapsed as far as possible, so
<span class="lineno"> 2076 </span>-- unnecessary lambdas will simply be omitted.
<span class="lineno"> 2077 </span>scLambdaListEtaCollapse :: SharedContext -&gt; [(VarName, Term)] -&gt; Term -&gt; IO Term
<span class="lineno"> 2078 </span><span class="decl"><span class="nottickedoff">scLambdaListEtaCollapse sc = \vars tm -&gt; loop (reverse vars) tm</span>
<span class="lineno"> 2079 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2080 </span><span class="spaces">    </span><span class="nottickedoff">-- we eta-collapsed all the variables, nothing more to do</span>
<span class="lineno"> 2081 </span><span class="spaces">    </span><span class="nottickedoff">loop [] tm = pure tm</span>
<span class="lineno"> 2082 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2083 </span><span class="spaces">    </span><span class="nottickedoff">-- the final variable to abstract is applied to the</span>
<span class="lineno"> 2084 </span><span class="spaces">    </span><span class="nottickedoff">-- term, and does not appear elsewhere in the term,</span>
<span class="lineno"> 2085 </span><span class="spaces">    </span><span class="nottickedoff">-- so we can eta-collapse.</span>
<span class="lineno"> 2086 </span><span class="spaces">    </span><span class="nottickedoff">loop ((x, _) : vars) (asApp -&gt; Just (f, asVariable -&gt; Just (x', _)))</span>
<span class="lineno"> 2087 </span><span class="spaces">      </span><span class="nottickedoff">| x == x', IntSet.notMember (vnIndex x) (freeVars f)</span>
<span class="lineno"> 2088 </span><span class="spaces">      </span><span class="nottickedoff">= loop vars f</span>
<span class="lineno"> 2089 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2090 </span><span class="spaces">    </span><span class="nottickedoff">-- cannot eta-collapse, do abstraction as usual</span>
<span class="lineno"> 2091 </span><span class="spaces">    </span><span class="nottickedoff">loop vars tm = scLambdaList sc (reverse vars) tm</span></span>
<span class="lineno"> 2092 </span>
<span class="lineno"> 2093 </span>
<span class="lineno"> 2094 </span>-- | Create a pi term by abstracting over the list of arguments, which
<span class="lineno"> 2095 </span>-- must all be named variables (e.g. terms generated by 'scVariable' or
<span class="lineno"> 2096 </span>-- 'scFreshVariable').
<span class="lineno"> 2097 </span>scGeneralizeTerms :: SharedContext -&gt; [Term] -&gt; Term -&gt; IO Term
<span class="lineno"> 2098 </span><span class="decl"><span class="istickedoff">scGeneralizeTerms sc args body =</span>
<span class="lineno"> 2099 </span><span class="spaces">  </span><span class="istickedoff">do vars &lt;- mapM toVar args</span>
<span class="lineno"> 2100 </span><span class="spaces">     </span><span class="istickedoff">scPiList sc vars body</span>
<span class="lineno"> 2101 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2102 </span><span class="spaces">    </span><span class="istickedoff">toVar :: Term -&gt; IO (VarName, Term)</span>
<span class="lineno"> 2103 </span><span class="spaces">    </span><span class="istickedoff">toVar t =</span>
<span class="lineno"> 2104 </span><span class="spaces">      </span><span class="istickedoff">case asVariable t of</span>
<span class="lineno"> 2105 </span><span class="spaces">        </span><span class="istickedoff">Just var -&gt; pure var</span>
<span class="lineno"> 2106 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;scGeneralizeTerms: expected Variable&quot;</span></span></span>
<span class="lineno"> 2107 </span>
<span class="lineno"> 2108 </span>-- | Unfold some of the defined constants within a 'Term'.
<span class="lineno"> 2109 </span>-- The supplied predicate specifies whether or not to unfold each
<span class="lineno"> 2110 </span>-- constant, based on its 'Name'.
<span class="lineno"> 2111 </span>scUnfoldConstants ::
<span class="lineno"> 2112 </span>  SharedContext -&gt;
<span class="lineno"> 2113 </span>  (Name -&gt; Bool) {- ^ whether to unfold a constant with this name -} -&gt;
<span class="lineno"> 2114 </span>  Term -&gt; IO Term
<span class="lineno"> 2115 </span><span class="decl"><span class="istickedoff">scUnfoldConstants sc unfold t0 =</span>
<span class="lineno"> 2116 </span><span class="spaces">  </span><span class="istickedoff">do tcache &lt;- newIntCache</span>
<span class="lineno"> 2117 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 2118 </span><span class="spaces">     </span><span class="istickedoff">let getRhs nm =</span>
<span class="lineno"> 2119 </span><span class="spaces">           </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 2120 </span><span class="spaces">             </span><span class="istickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno"> 2121 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 2122 </span><span class="spaces">     </span><span class="istickedoff">let go :: Term -&gt; ChangeT IO Term</span>
<span class="lineno"> 2123 </span><span class="spaces">         </span><span class="istickedoff">go t =</span>
<span class="lineno"> 2124 </span><span class="spaces">           </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 2125 </span><span class="spaces">             </span><span class="istickedoff">Constant nm</span>
<span class="lineno"> 2126 </span><span class="spaces">               </span><span class="istickedoff">| unfold nm</span>
<span class="lineno"> 2127 </span><span class="spaces">               </span><span class="istickedoff">, Just rhs &lt;- getRhs nm -&gt; taint (go rhs)</span>
<span class="lineno"> 2128 </span><span class="spaces">               </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>             -&gt; pure t</span>
<span class="lineno"> 2129 </span><span class="spaces">             </span><span class="istickedoff">Variable x _</span>
<span class="lineno"> 2130 </span><span class="spaces">               </span><span class="istickedoff">| IntMap.member (vnIndex x) (varTypes t0) -&gt;</span>
<span class="lineno"> 2131 </span><span class="spaces">                 </span><span class="istickedoff">-- Avoid modifying types of free variables to preserve Term invariant</span>
<span class="lineno"> 2132 </span><span class="spaces">                 </span><span class="istickedoff">pure t</span>
<span class="lineno"> 2133 </span><span class="spaces">             </span><span class="istickedoff">tf -&gt;</span>
<span class="lineno"> 2134 </span><span class="spaces">               </span><span class="istickedoff">useChangeCache tcache (termIndex t) $</span>
<span class="lineno"> 2135 </span><span class="spaces">               </span><span class="istickedoff">whenModified t (scTermF sc) (traverse go tf)</span>
<span class="lineno"> 2136 </span><span class="spaces">     </span><span class="istickedoff">commitChangeT (go t0)</span></span>
<span class="lineno"> 2137 </span>
<span class="lineno"> 2138 </span>-- | Unfold some of the defined constants within a 'Term'.
<span class="lineno"> 2139 </span>-- The supplied predicate specifies whether or not to unfold each
<span class="lineno"> 2140 </span>-- constant, based on its 'Name'.
<span class="lineno"> 2141 </span>-- Reduce any beta redexes created by unfolding a constant definition
<span class="lineno"> 2142 </span>-- that is a lambda term.
<span class="lineno"> 2143 </span>scUnfoldConstantsBeta ::
<span class="lineno"> 2144 </span>  SharedContext -&gt;
<span class="lineno"> 2145 </span>  (Name -&gt; Bool) {- ^ whether to unfold a constant with this name -} -&gt;
<span class="lineno"> 2146 </span>  Term -&gt; IO Term
<span class="lineno"> 2147 </span><span class="decl"><span class="istickedoff">scUnfoldConstantsBeta sc unfold t0 =</span>
<span class="lineno"> 2148 </span><span class="spaces">  </span><span class="istickedoff">do tcache &lt;- newIntCache</span>
<span class="lineno"> 2149 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 2150 </span><span class="spaces">     </span><span class="istickedoff">let getRhs nm =</span>
<span class="lineno"> 2151 </span><span class="spaces">           </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 2152 </span><span class="spaces">             </span><span class="istickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno"> 2153 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 2154 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; ChangeT IO Term</span>
<span class="lineno"> 2155 </span><span class="spaces">         </span><span class="istickedoff">memo t = useChangeCache tcache (termIndex t) (go t)</span>
<span class="lineno"> 2156 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; ChangeT IO Term</span>
<span class="lineno"> 2157 </span><span class="spaces">         </span><span class="istickedoff">go (asApplyAll -&gt; (asConstant -&gt; Just nm, args))</span>
<span class="lineno"> 2158 </span><span class="spaces">           </span><span class="istickedoff">| unfold nm, Just rhs &lt;- getRhs nm =</span>
<span class="lineno"> 2159 </span><span class="spaces">               </span><span class="istickedoff">do args' &lt;- traverse memo args</span>
<span class="lineno"> 2160 </span><span class="spaces">                  </span><span class="istickedoff">taint $ lift $ scApplyAllBeta sc rhs args'</span>
<span class="lineno"> 2161 </span><span class="spaces">         </span><span class="istickedoff">go t@(asVariable -&gt; Just (x, _))</span>
<span class="lineno"> 2162 </span><span class="spaces">           </span><span class="istickedoff">| IntMap.member (vnIndex x) (varTypes t0) =</span>
<span class="lineno"> 2163 </span><span class="spaces">               </span><span class="istickedoff">-- Avoid modifying types of free variables to preserve Term invariant</span>
<span class="lineno"> 2164 </span><span class="spaces">               </span><span class="istickedoff">pure <span class="nottickedoff">t</span></span>
<span class="lineno"> 2165 </span><span class="spaces">         </span><span class="istickedoff">go t = whenModified t (scTermF sc) (traverse memo (unwrapTermF t))</span>
<span class="lineno"> 2166 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2167 </span><span class="spaces">     </span><span class="istickedoff">commitChangeT (memo t0)</span></span>
<span class="lineno"> 2168 </span>
<span class="lineno"> 2169 </span>-- | Unfold one time fixpoint constants.
<span class="lineno"> 2170 </span>--
<span class="lineno"> 2171 </span>-- Specifically, if @c = fix a f@, then replace @c@ with @f c@, that is replace
<span class="lineno"> 2172 </span>-- @(fix a f)@ with @f (fix a f)@ while preserving the constant name.  The
<span class="lineno"> 2173 </span>-- signature of @fix@ is @primitive fix : (a : sort 1) -&gt; (a -&gt; a) -&gt; a;@.
<span class="lineno"> 2174 </span>scUnfoldOnceFixConstantSet :: SharedContext
<span class="lineno"> 2175 </span>                           -&gt; Bool  -- ^ True: unfold constants in set. False: unfold constants NOT in set
<span class="lineno"> 2176 </span>                           -&gt; Set VarIndex -- ^ Set of constant names
<span class="lineno"> 2177 </span>                           -&gt; Term
<span class="lineno"> 2178 </span>                           -&gt; IO Term
<span class="lineno"> 2179 </span><span class="decl"><span class="istickedoff">scUnfoldOnceFixConstantSet sc b names t0 = do</span>
<span class="lineno"> 2180 </span><span class="spaces">  </span><span class="istickedoff">cache &lt;- newIntCache</span>
<span class="lineno"> 2181 </span><span class="spaces">  </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 2182 </span><span class="spaces">  </span><span class="istickedoff">let getRhs v =</span>
<span class="lineno"> 2183 </span><span class="spaces">        </span><span class="istickedoff">case lookupVarIndexInMap v mm of</span>
<span class="lineno"> 2184 </span><span class="spaces">          </span><span class="istickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno"> 2185 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 2186 </span><span class="spaces">  </span><span class="istickedoff">let unfold t idx rhs</span>
<span class="lineno"> 2187 </span><span class="spaces">        </span><span class="istickedoff">| Set.member idx names == b</span>
<span class="lineno"> 2188 </span><span class="spaces">        </span><span class="istickedoff">, (isGlobalDef &quot;Prelude.fix&quot; -&gt; Just (), [_, f]) &lt;- asApplyAll rhs =</span>
<span class="lineno"> 2189 </span><span class="spaces">          </span><span class="istickedoff">betaNormalize sc =&lt;&lt; scApply sc f t</span>
<span class="lineno"> 2190 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 2191 </span><span class="spaces">          </span><span class="istickedoff">return t</span>
<span class="lineno"> 2192 </span><span class="spaces">  </span><span class="istickedoff">let go :: Term -&gt; IO Term</span>
<span class="lineno"> 2193 </span><span class="spaces">      </span><span class="istickedoff">go t = useIntCache cache (termIndex t) $</span>
<span class="lineno"> 2194 </span><span class="spaces">        </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 2195 </span><span class="spaces">          </span><span class="istickedoff">Constant (Name nmidx _) | Just rhs &lt;- getRhs nmidx -&gt; unfold t nmidx rhs</span>
<span class="lineno"> 2196 </span><span class="spaces">          </span><span class="istickedoff">tf -&gt; scTermF sc =&lt;&lt; traverse go tf</span>
<span class="lineno"> 2197 </span><span class="spaces">  </span><span class="istickedoff">go t0</span></span>
<span class="lineno"> 2198 </span>
<span class="lineno"> 2199 </span>-- | Return the number of DAG nodes used by the given @Term@.
<span class="lineno"> 2200 </span>scSharedSize :: Term -&gt; Integer
<span class="lineno"> 2201 </span><span class="decl"><span class="istickedoff">scSharedSize = fst . scSharedSizeAux (0, Set.empty)</span></span>
<span class="lineno"> 2202 </span>
<span class="lineno"> 2203 </span>scSharedSizeMany :: [Term] -&gt; Integer
<span class="lineno"> 2204 </span><span class="decl"><span class="istickedoff">scSharedSizeMany = fst . foldl scSharedSizeAux (0, Set.empty)</span></span>
<span class="lineno"> 2205 </span>
<span class="lineno"> 2206 </span>scSharedSizeAux :: (Integer, Set TermIndex) -&gt; Term -&gt; (Integer, Set TermIndex)
<span class="lineno"> 2207 </span><span class="decl"><span class="istickedoff">scSharedSizeAux = go</span>
<span class="lineno"> 2208 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 2209 </span><span class="spaces">    </span><span class="istickedoff">go (sz, seen) t</span>
<span class="lineno"> 2210 </span><span class="spaces">      </span><span class="istickedoff">| Set.member (termIndex t) seen = (sz, seen)</span>
<span class="lineno"> 2211 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = foldl' go (strictPair (sz + 1) (Set.insert (termIndex t) seen)) (unwrapTermF t)</span></span>
<span class="lineno"> 2212 </span>
<span class="lineno"> 2213 </span>strictPair :: a -&gt; b -&gt; (a, b)
<span class="lineno"> 2214 </span><span class="decl"><span class="istickedoff">strictPair x y = x `seq` y `seq` (x, y)</span></span>
<span class="lineno"> 2215 </span>
<span class="lineno"> 2216 </span>-- | Return the number of nodes that would be used by the given
<span class="lineno"> 2217 </span>-- @Term@ if it were represented as a tree instead of a DAG.
<span class="lineno"> 2218 </span>scTreeSize :: Term -&gt; Integer
<span class="lineno"> 2219 </span><span class="decl"><span class="nottickedoff">scTreeSize = fst . scTreeSizeAux (0, Map.empty)</span></span>
<span class="lineno"> 2220 </span>
<span class="lineno"> 2221 </span>scTreeSizeMany :: [Term] -&gt; Integer
<span class="lineno"> 2222 </span><span class="decl"><span class="nottickedoff">scTreeSizeMany = fst . foldl scTreeSizeAux (0, Map.empty)</span></span>
<span class="lineno"> 2223 </span>
<span class="lineno"> 2224 </span>scTreeSizeAux :: (Integer, Map TermIndex Integer) -&gt; Term -&gt; (Integer, Map TermIndex Integer)
<span class="lineno"> 2225 </span><span class="decl"><span class="nottickedoff">scTreeSizeAux = go</span>
<span class="lineno"> 2226 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2227 </span><span class="spaces">    </span><span class="nottickedoff">go (sz, seen) t =</span>
<span class="lineno"> 2228 </span><span class="spaces">      </span><span class="nottickedoff">case Map.lookup (termIndex t) seen of</span>
<span class="lineno"> 2229 </span><span class="spaces">        </span><span class="nottickedoff">Just sz' -&gt; (sz + sz', seen)</span>
<span class="lineno"> 2230 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; (sz + sz', Map.insert (termIndex t) sz' seen')</span>
<span class="lineno"> 2231 </span><span class="spaces">          </span><span class="nottickedoff">where (sz', seen') = foldl' go (1, seen) (unwrapTermF t)</span></span>

</pre>
</body>
</html>
