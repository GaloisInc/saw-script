<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    2 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    3 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    4 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>{- |
<span class="lineno">    7 </span>Module      : SAWCore.SharedTerm
<span class="lineno">    8 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    9 </span>License     : BSD3
<span class="lineno">   10 </span>Maintainer  : jhendrix@galois.com
<span class="lineno">   11 </span>Stability   : experimental
<span class="lineno">   12 </span>Portability : non-portable (language extensions)
<span class="lineno">   13 </span>-}
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>module SAWCore.SharedTerm
<span class="lineno">   16 </span>  ( TermF(..)
<span class="lineno">   17 </span>  , Ident, mkIdent
<span class="lineno">   18 </span>  , VarIndex
<span class="lineno">   19 </span>  , NameInfo(..)
<span class="lineno">   20 </span>    -- * Shared terms
<span class="lineno">   21 </span>  , Term -- exported as abstract
<span class="lineno">   22 </span>  , unwrapTermF
<span class="lineno">   23 </span>  , termIndex
<span class="lineno">   24 </span>  , varTypes
<span class="lineno">   25 </span>  , freeVars
<span class="lineno">   26 </span>  , closedTerm
<span class="lineno">   27 </span>  , termSortOrType
<span class="lineno">   28 </span>  , TermIndex
<span class="lineno">   29 </span>  , scImport
<span class="lineno">   30 </span>  , alphaEquiv
<span class="lineno">   31 </span>  , alistAllFields
<span class="lineno">   32 </span>  , scRegisterName
<span class="lineno">   33 </span>  , scResolveName
<span class="lineno">   34 </span>  , scResolveNameByURI
<span class="lineno">   35 </span>  , ppTerm
<span class="lineno">   36 </span>  , prettyTerm
<span class="lineno">   37 </span>  , DuplicateNameException(..)
<span class="lineno">   38 </span>    -- * SharedContext interface for building shared terms
<span class="lineno">   39 </span>  , SharedContext -- abstract type
<span class="lineno">   40 </span>  , mkSharedContext
<span class="lineno">   41 </span>  , scGetModuleMap
<span class="lineno">   42 </span>  , SharedContextCheckpoint -- abstract type
<span class="lineno">   43 </span>  , checkpointSharedContext
<span class="lineno">   44 </span>  , restoreSharedContext
<span class="lineno">   45 </span>  , scGetNamingEnv
<span class="lineno">   46 </span>    -- ** Low-level generic term constructors
<span class="lineno">   47 </span>  , scTermF
<span class="lineno">   48 </span>  , scFlatTermF
<span class="lineno">   49 </span>    -- ** Implicit versions of functions.
<span class="lineno">   50 </span>  , scFreshVariable
<span class="lineno">   51 </span>  , scFreshName
<span class="lineno">   52 </span>  , scFreshVarName
<span class="lineno">   53 </span>  , scVariable
<span class="lineno">   54 </span>  , scVariables
<span class="lineno">   55 </span>  , scGlobalDef
<span class="lineno">   56 </span>  , scFreshenGlobalIdent
<span class="lineno">   57 </span>    -- ** Recursors and datatypes
<span class="lineno">   58 </span>  , scRecursor
<span class="lineno">   59 </span>  , scReduceRecursor
<span class="lineno">   60 </span>  , allowedElimSort
<span class="lineno">   61 </span>  , scBuildCtor
<span class="lineno">   62 </span>    -- ** Modules
<span class="lineno">   63 </span>  , scLoadModule
<span class="lineno">   64 </span>  , scImportModule
<span class="lineno">   65 </span>  , scModuleIsLoaded
<span class="lineno">   66 </span>  , scFindModule
<span class="lineno">   67 </span>  , scFindDef
<span class="lineno">   68 </span>  , scFindDataType
<span class="lineno">   69 </span>  , scFindCtor
<span class="lineno">   70 </span>  , scRequireDef
<span class="lineno">   71 </span>  , scRequireDataType
<span class="lineno">   72 </span>  , scRequireCtor
<span class="lineno">   73 </span>  , scInjectCode
<span class="lineno">   74 </span>    -- ** Declaring global constants
<span class="lineno">   75 </span>  , scDeclarePrim
<span class="lineno">   76 </span>  , scFreshConstant
<span class="lineno">   77 </span>  , scDefineConstant
<span class="lineno">   78 </span>  , scOpaqueConstant
<span class="lineno">   79 </span>  , scBeginDataType
<span class="lineno">   80 </span>  , scCompleteDataType
<span class="lineno">   81 </span>    -- ** Term construction
<span class="lineno">   82 </span>    -- *** Sorts
<span class="lineno">   83 </span>  , scSort
<span class="lineno">   84 </span>  , scISort
<span class="lineno">   85 </span>  , scSortWithFlags
<span class="lineno">   86 </span>    -- *** Variables and constants
<span class="lineno">   87 </span>  , scConst
<span class="lineno">   88 </span>  , scConstApply
<span class="lineno">   89 </span>    -- *** Functions and function application
<span class="lineno">   90 </span>  , scApply
<span class="lineno">   91 </span>  , scApplyAll
<span class="lineno">   92 </span>  , scApplyBeta
<span class="lineno">   93 </span>  , scApplyAllBeta
<span class="lineno">   94 </span>  , scGlobalApply
<span class="lineno">   95 </span>  , scFun
<span class="lineno">   96 </span>  , scFunAll
<span class="lineno">   97 </span>  , scLambda
<span class="lineno">   98 </span>  , scLambdaList
<span class="lineno">   99 </span>  , scPi
<span class="lineno">  100 </span>  , scPiList
<span class="lineno">  101 </span>    -- *** Strings
<span class="lineno">  102 </span>  , scString
<span class="lineno">  103 </span>  , scStringType
<span class="lineno">  104 </span>    -- *** Booleans
<span class="lineno">  105 </span>  , scEqTrue
<span class="lineno">  106 </span>  , scBool
<span class="lineno">  107 </span>  , scBoolType
<span class="lineno">  108 </span>    -- *** Unit, pairs, and tuples
<span class="lineno">  109 </span>  , scUnitValue
<span class="lineno">  110 </span>  , scUnitType
<span class="lineno">  111 </span>  , scPairValue
<span class="lineno">  112 </span>  , scPairType
<span class="lineno">  113 </span>  , scPairLeft
<span class="lineno">  114 </span>  , scPairRight
<span class="lineno">  115 </span>  , scPairValueReduced
<span class="lineno">  116 </span>  , scTuple
<span class="lineno">  117 </span>  , scTupleType
<span class="lineno">  118 </span>  , scTupleSelector
<span class="lineno">  119 </span>  , scTupleReduced
<span class="lineno">  120 </span>    -- *** Records
<span class="lineno">  121 </span>  , scRecord
<span class="lineno">  122 </span>  , scRecordSelect
<span class="lineno">  123 </span>  , scRecordType
<span class="lineno">  124 </span>    -- *** Vectors
<span class="lineno">  125 </span>  , scVector
<span class="lineno">  126 </span>  , scVecType
<span class="lineno">  127 </span>  , scVectorReduced
<span class="lineno">  128 </span>    -- ** Normalization
<span class="lineno">  129 </span>  , scWhnf
<span class="lineno">  130 </span>  , scConvertibleEval
<span class="lineno">  131 </span>  , scConvertible
<span class="lineno">  132 </span>  , scSubtype
<span class="lineno">  133 </span>    -- ** Type checking
<span class="lineno">  134 </span>  , scTypeOf
<span class="lineno">  135 </span>  , asSort
<span class="lineno">  136 </span>  , reducePi
<span class="lineno">  137 </span>  , scTypeOfIdent
<span class="lineno">  138 </span>  , scTypeOfName
<span class="lineno">  139 </span>    -- ** Prelude operations
<span class="lineno">  140 </span>    -- *** Booleans
<span class="lineno">  141 </span>  , scNot
<span class="lineno">  142 </span>  , scAnd
<span class="lineno">  143 </span>  , scOr
<span class="lineno">  144 </span>  , scImplies
<span class="lineno">  145 </span>  , scXor
<span class="lineno">  146 </span>  , scBoolEq
<span class="lineno">  147 </span>  , scIte
<span class="lineno">  148 </span>  , scAndList
<span class="lineno">  149 </span>  , scOrList
<span class="lineno">  150 </span>  -- *** Natural numbers
<span class="lineno">  151 </span>  , scNat
<span class="lineno">  152 </span>  , scNatType
<span class="lineno">  153 </span>  , scAddNat
<span class="lineno">  154 </span>  , scSubNat
<span class="lineno">  155 </span>  , scMulNat
<span class="lineno">  156 </span>  , scDivNat
<span class="lineno">  157 </span>  , scModNat
<span class="lineno">  158 </span>  , scDivModNat
<span class="lineno">  159 </span>  , scEqualNat
<span class="lineno">  160 </span>  , scLtNat
<span class="lineno">  161 </span>  , scMinNat
<span class="lineno">  162 </span>  , scMaxNat
<span class="lineno">  163 </span>  , scUpdNatFun
<span class="lineno">  164 </span>    -- *** Integers
<span class="lineno">  165 </span>  , scIntegerType
<span class="lineno">  166 </span>  , scIntegerConst
<span class="lineno">  167 </span>  , scIntAdd, scIntSub, scIntMul
<span class="lineno">  168 </span>  , scIntDiv, scIntMod, scIntNeg
<span class="lineno">  169 </span>  , scIntAbs, scIntMin, scIntMax
<span class="lineno">  170 </span>  , scIntEq, scIntLe, scIntLt
<span class="lineno">  171 </span>  , scIntToNat, scNatToInt
<span class="lineno">  172 </span>  , scIntToBv, scBvToInt, scSbvToInt
<span class="lineno">  173 </span>    -- *** IntMod
<span class="lineno">  174 </span>  , scIntModType
<span class="lineno">  175 </span>  , scToIntMod
<span class="lineno">  176 </span>  , scFromIntMod
<span class="lineno">  177 </span>  , scIntModEq
<span class="lineno">  178 </span>  , scIntModAdd
<span class="lineno">  179 </span>  , scIntModSub
<span class="lineno">  180 </span>  , scIntModMul
<span class="lineno">  181 </span>  , scIntModNeg
<span class="lineno">  182 </span>    -- *** Vectors
<span class="lineno">  183 </span>  , scAppend
<span class="lineno">  184 </span>  , scJoin
<span class="lineno">  185 </span>  , scSplit
<span class="lineno">  186 </span>  , scGet
<span class="lineno">  187 </span>  , scAtWithDefault
<span class="lineno">  188 </span>  , scAt
<span class="lineno">  189 </span>  , scSingle
<span class="lineno">  190 </span>  , scSlice
<span class="lineno">  191 </span>    -- *** Bitvectors
<span class="lineno">  192 </span>  , scBitvector
<span class="lineno">  193 </span>  , scBvNat
<span class="lineno">  194 </span>  , scBvToNat
<span class="lineno">  195 </span>  , scBvAt
<span class="lineno">  196 </span>  , scBvConst
<span class="lineno">  197 </span>  , scBvLit
<span class="lineno">  198 </span>  , scBvForall
<span class="lineno">  199 </span>  , scUpdBvFun
<span class="lineno">  200 </span>  , scBvNonzero, scBvBool
<span class="lineno">  201 </span>  , scBvAdd, scBvSub, scBvMul, scBvNeg
<span class="lineno">  202 </span>  , scBvURem, scBvUDiv, scBvSRem, scBvSDiv
<span class="lineno">  203 </span>  , scBvOr, scBvAnd, scBvXor
<span class="lineno">  204 </span>  , scBvNot
<span class="lineno">  205 </span>  , scBvEq, scBvUGe, scBvUGt, scBvULe, scBvULt
<span class="lineno">  206 </span>  , scBvSGt, scBvSGe, scBvSLt, scBvSLe
<span class="lineno">  207 </span>  , scBvShl, scBvShr, scBvSShr
<span class="lineno">  208 </span>  , scBvUExt, scBvSExt
<span class="lineno">  209 </span>  , scBvTrunc
<span class="lineno">  210 </span>  , scBvLg2
<span class="lineno">  211 </span>  , scBvPopcount
<span class="lineno">  212 </span>  , scBvCountLeadingZeros
<span class="lineno">  213 </span>  , scBvCountTrailingZeros
<span class="lineno">  214 </span>  , scLsb, scMsb
<span class="lineno">  215 </span>    -- *** Arrays
<span class="lineno">  216 </span>  , scArrayType
<span class="lineno">  217 </span>  , scArrayConstant
<span class="lineno">  218 </span>  , scArrayLookup
<span class="lineno">  219 </span>  , scArrayUpdate
<span class="lineno">  220 </span>  , scArrayEq
<span class="lineno">  221 </span>  , scArrayCopy
<span class="lineno">  222 </span>  , scArraySet
<span class="lineno">  223 </span>  , scArrayRangeEq
<span class="lineno">  224 </span>    -- ** Variable substitution
<span class="lineno">  225 </span>  , betaNormalize
<span class="lineno">  226 </span>  , isConstFoldTerm
<span class="lineno">  227 </span>  , getAllVars
<span class="lineno">  228 </span>  , getAllVarsMap
<span class="lineno">  229 </span>  , getConstantSet
<span class="lineno">  230 </span>  , scInstantiate
<span class="lineno">  231 </span>  , scInstantiateBeta
<span class="lineno">  232 </span>  , scAbstractTerms
<span class="lineno">  233 </span>  , scLambdaListEtaCollapse
<span class="lineno">  234 </span>  , scGeneralizeTerms
<span class="lineno">  235 </span>  , scUnfoldConstants
<span class="lineno">  236 </span>  , scUnfoldConstantsBeta
<span class="lineno">  237 </span>  , scUnfoldOnceFixConstantSet
<span class="lineno">  238 </span>  , scSharedSize
<span class="lineno">  239 </span>  , scSharedSizeAux
<span class="lineno">  240 </span>  , scSharedSizeMany
<span class="lineno">  241 </span>  , scTreeSize
<span class="lineno">  242 </span>  , scTreeSizeAux
<span class="lineno">  243 </span>  , scTreeSizeMany
<span class="lineno">  244 </span>  ) where
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>import Control.Applicative
<span class="lineno">  247 </span>-- ((&lt;$&gt;), pure, (&lt;*&gt;))
<span class="lineno">  248 </span>import Control.Exception
<span class="lineno">  249 </span>import Control.Lens
<span class="lineno">  250 </span>import Control.Monad (foldM)
<span class="lineno">  251 </span>import qualified Control.Monad.State.Strict as State
<span class="lineno">  252 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">  253 </span>import Data.Bits
<span class="lineno">  254 </span>import Data.Maybe
<span class="lineno">  255 </span>import qualified Data.Foldable as Fold
<span class="lineno">  256 </span>import Data.Foldable (foldl', foldlM)
<span class="lineno">  257 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">  258 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">  259 </span>import qualified Data.IntSet as IntSet
<span class="lineno">  260 </span>import Data.Map (Map)
<span class="lineno">  261 </span>import qualified Data.Map as Map
<span class="lineno">  262 </span>import Data.Ref ( C )
<span class="lineno">  263 </span>import Data.Set (Set)
<span class="lineno">  264 </span>import Data.Text (Text)
<span class="lineno">  265 </span>import qualified Data.Set as Set
<span class="lineno">  266 </span>import qualified Data.Text as Text
<span class="lineno">  267 </span>import Numeric.Natural (Natural)
<span class="lineno">  268 </span>import Prelude hiding (maximum)
<span class="lineno">  269 </span>import Text.URI
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts)
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>import SAWCore.Panic (panic)
<span class="lineno">  274 </span>import SAWCore.Cache
<span class="lineno">  275 </span>import SAWCore.Change
<span class="lineno">  276 </span>import SAWCore.Module
<span class="lineno">  277 </span>  ( ctorName
<span class="lineno">  278 </span>  , moduleIsLoaded
<span class="lineno">  279 </span>  , lookupVarIndexInMap
<span class="lineno">  280 </span>  , findCtorInMap
<span class="lineno">  281 </span>  , findDataTypeInMap
<span class="lineno">  282 </span>  , findDefInMap
<span class="lineno">  283 </span>  , findModule
<span class="lineno">  284 </span>  , resolvedNameType
<span class="lineno">  285 </span>  , resolveNameInMap
<span class="lineno">  286 </span>  , CtorArg(..)
<span class="lineno">  287 </span>  , CtorArgStruct(..)
<span class="lineno">  288 </span>  , Ctor(..)
<span class="lineno">  289 </span>  , DataType(..)
<span class="lineno">  290 </span>  , Def(..)
<span class="lineno">  291 </span>  , Module
<span class="lineno">  292 </span>  , ResolvedName(..)
<span class="lineno">  293 </span>  )
<span class="lineno">  294 </span>import SAWCore.Name
<span class="lineno">  295 </span>import SAWCore.Prelude.Constants
<span class="lineno">  296 </span>import SAWCore.Recognizer
<span class="lineno">  297 </span>import SAWCore.Term.Certified
<span class="lineno">  298 </span>import SAWCore.Term.Functor
<span class="lineno">  299 </span>
<span class="lineno">  300 </span>--------------------------------------------------------------------------------
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>data DuplicateNameException = DuplicateNameException URI
<span class="lineno">  303 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Exception DuplicateNameException</span></span></span></span></span></span>
<span class="lineno">  304 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show DuplicateNameException</span></span></span></span> where
<span class="lineno">  305 </span>  <span class="decl"><span class="nottickedoff">show (DuplicateNameException uri) =</span>
<span class="lineno">  306 </span><span class="spaces">      </span><span class="nottickedoff">&quot;Attempted to register the following name twice: &quot; ++ Text.unpack (render uri)</span></span>
<span class="lineno">  307 </span>
<span class="lineno">  308 </span>scResolveName :: SharedContext -&gt; Text -&gt; IO [VarIndex]
<span class="lineno">  309 </span><span class="decl"><span class="istickedoff">scResolveName sc nm =</span>
<span class="lineno">  310 </span><span class="spaces">  </span><span class="istickedoff">do env &lt;- scGetNamingEnv sc</span>
<span class="lineno">  311 </span><span class="spaces">     </span><span class="istickedoff">pure (resolveDisplayName env nm)</span></span>
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>-- | Create a fresh variable with the given identifier (which may be &quot;_&quot;) and type.
<span class="lineno">  314 </span>scFreshVariable :: SharedContext -&gt; Text -&gt; Term -&gt; IO Term
<span class="lineno">  315 </span><span class="decl"><span class="istickedoff">scFreshVariable sc x tp =</span>
<span class="lineno">  316 </span><span class="spaces">  </span><span class="istickedoff">do nm &lt;- scFreshVarName sc x</span>
<span class="lineno">  317 </span><span class="spaces">     </span><span class="istickedoff">scVariable sc nm tp</span></span>
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>-- | Test if a module is loaded in the current shared context
<span class="lineno">  320 </span>scModuleIsLoaded :: SharedContext -&gt; ModuleName -&gt; IO Bool
<span class="lineno">  321 </span><span class="decl"><span class="istickedoff">scModuleIsLoaded sc name =</span>
<span class="lineno">  322 </span><span class="spaces">  </span><span class="istickedoff">moduleIsLoaded name &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>-- | Look up a module by name, raising an error if it is not loaded
<span class="lineno">  325 </span>scFindModule :: SharedContext -&gt; ModuleName -&gt; IO Module
<span class="lineno">  326 </span><span class="decl"><span class="istickedoff">scFindModule sc name =</span>
<span class="lineno">  327 </span><span class="spaces">  </span><span class="istickedoff">do maybe_mod &lt;- findModule name &lt;$&gt; scGetModuleMap sc</span>
<span class="lineno">  328 </span><span class="spaces">     </span><span class="istickedoff">case maybe_mod of</span>
<span class="lineno">  329 </span><span class="spaces">       </span><span class="istickedoff">Just m -&gt; return m</span>
<span class="lineno">  330 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  331 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">error (&quot;scFindModule: module &quot; ++ show name ++ &quot; not found!&quot;)</span></span></span>
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>-- | Look up a definition by its identifier
<span class="lineno">  334 </span>scFindDef :: SharedContext -&gt; Ident -&gt; IO (Maybe Def)
<span class="lineno">  335 </span><span class="decl"><span class="istickedoff">scFindDef sc i = findDefInMap i &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>-- | Look up a 'Def' by its identifier, throwing an error if it is not found
<span class="lineno">  338 </span>scRequireDef :: SharedContext -&gt; Ident -&gt; IO Def
<span class="lineno">  339 </span><span class="decl"><span class="nottickedoff">scRequireDef sc i =</span>
<span class="lineno">  340 </span><span class="spaces">  </span><span class="nottickedoff">scFindDef sc i &gt;&gt;= \maybe_d -&gt;</span>
<span class="lineno">  341 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_d of</span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="nottickedoff">Just d -&gt; return d</span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail (&quot;Could not find definition: &quot; ++ show i)</span></span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>-- | Look up a datatype by its identifier
<span class="lineno">  346 </span>scFindDataType :: SharedContext -&gt; Ident -&gt; IO (Maybe DataType)
<span class="lineno">  347 </span><span class="decl"><span class="nottickedoff">scFindDataType sc i = findDataTypeInMap i &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>-- | Look up a datatype by its identifier, throwing an error if it is not found
<span class="lineno">  350 </span>scRequireDataType :: SharedContext -&gt; Ident -&gt; IO DataType
<span class="lineno">  351 </span><span class="decl"><span class="nottickedoff">scRequireDataType sc i =</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="nottickedoff">scFindDataType sc i &gt;&gt;= \maybe_d -&gt;</span>
<span class="lineno">  353 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_d of</span>
<span class="lineno">  354 </span><span class="spaces">    </span><span class="nottickedoff">Just d -&gt; return d</span>
<span class="lineno">  355 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail (&quot;Could not find datatype: &quot; ++ show i)</span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>-- | Look up a constructor by its identifier
<span class="lineno">  358 </span>scFindCtor :: SharedContext -&gt; Ident -&gt; IO (Maybe Ctor)
<span class="lineno">  359 </span><span class="decl"><span class="nottickedoff">scFindCtor sc i = findCtorInMap i &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>-- | Look up a constructor by its identifier, throwing an error if not found
<span class="lineno">  362 </span>scRequireCtor :: SharedContext -&gt; Ident -&gt; IO Ctor
<span class="lineno">  363 </span><span class="decl"><span class="nottickedoff">scRequireCtor sc i =</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="nottickedoff">scFindCtor sc i &gt;&gt;= \maybe_ctor -&gt;</span>
<span class="lineno">  365 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_ctor of</span>
<span class="lineno">  366 </span><span class="spaces">    </span><span class="nottickedoff">Just ctor -&gt; return ctor</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail (&quot;Could not find constructor: &quot; ++ show i)</span></span>
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>--------------------------------------------------------------------------------
<span class="lineno">  370 </span>-- Recursors
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>-- | Test whether a 'DataType' can be eliminated to the given sort. The rules
<span class="lineno">  373 </span>-- are that you can only eliminate propositional datatypes to the proposition
<span class="lineno">  374 </span>-- sort, unless your propositional data type is the empty type. This differs
<span class="lineno">  375 </span>-- slightly from the Coq rules, which allow elimination of propositional
<span class="lineno">  376 </span>-- datatypes with a single constructor that has only propositional arguments,
<span class="lineno">  377 </span>-- but this Coq behavior can be simulated with the behavior we are using here.
<span class="lineno">  378 </span>allowedElimSort :: DataType -&gt; Sort -&gt; Bool
<span class="lineno">  379 </span><span class="decl"><span class="istickedoff">allowedElimSort dt s =</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="istickedoff">if dtSort dt == propSort &amp;&amp; s /= propSort then</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">length (dtCtors dt) == 1</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="istickedoff">else True</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>-- | Internal: Compute the type of a constructor from the name of its
<span class="lineno">  385 </span>-- datatype and its 'CtorArgStruct'.
<span class="lineno">  386 </span>ctxCtorType :: SharedContext -&gt; Name -&gt; CtorArgStruct -&gt; IO Term
<span class="lineno">  387 </span><span class="decl"><span class="istickedoff">ctxCtorType sc d (CtorArgStruct{..}) =</span>
<span class="lineno">  388 </span><span class="spaces">  </span><span class="istickedoff">do params &lt;- scVariables sc ctorParams</span>
<span class="lineno">  389 </span><span class="spaces">     </span><span class="istickedoff">d_params &lt;- scConstApply sc d params</span>
<span class="lineno">  390 </span><span class="spaces">     </span><span class="istickedoff">d_params_ixs &lt;- scApplyAll sc d_params ctorIndices</span>
<span class="lineno">  391 </span><span class="spaces">     </span><span class="istickedoff">let ctorArgType :: CtorArg -&gt; IO Term</span>
<span class="lineno">  392 </span><span class="spaces">         </span><span class="istickedoff">ctorArgType (ConstArg tp) = pure tp</span>
<span class="lineno">  393 </span><span class="spaces">         </span><span class="istickedoff">ctorArgType (RecursiveArg zs_ctx ixs) =</span>
<span class="lineno">  394 </span><span class="spaces">           </span><span class="istickedoff">scPiList <span class="nottickedoff">sc</span> zs_ctx =&lt;&lt; scApplyAll sc d_params ixs</span>
<span class="lineno">  395 </span><span class="spaces">     </span><span class="istickedoff">bs &lt;- traverse (traverse ctorArgType) ctorArgs</span>
<span class="lineno">  396 </span><span class="spaces">     </span><span class="istickedoff">body &lt;- scPiList sc bs d_params_ixs</span>
<span class="lineno">  397 </span><span class="spaces">     </span><span class="istickedoff">scPiList sc ctorParams body</span></span>
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>-- | Build a 'Ctor' from a 'CtorArgStruct' and a list of the other constructor
<span class="lineno">  400 </span>-- names of the 'DataType'. Note that we cannot look up the latter information,
<span class="lineno">  401 </span>-- as 'scBuildCtor' is called during construction of the 'DataType'.
<span class="lineno">  402 </span>scBuildCtor ::
<span class="lineno">  403 </span>  SharedContext -&gt;
<span class="lineno">  404 </span>  Name {- ^ data type -} -&gt;
<span class="lineno">  405 </span>  Ident {- ^ constructor name -} -&gt;
<span class="lineno">  406 </span>  CtorArgStruct {- ^ constructor formal arguments -} -&gt;
<span class="lineno">  407 </span>  IO Ctor
<span class="lineno">  408 </span><span class="decl"><span class="istickedoff">scBuildCtor sc d c arg_struct =</span>
<span class="lineno">  409 </span><span class="spaces">  </span><span class="istickedoff">do</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="istickedoff">-- Step 0: allocate a fresh unique variable index for this constructor</span>
<span class="lineno">  411 </span><span class="spaces">    </span><span class="istickedoff">-- and register its name in the naming environment</span>
<span class="lineno">  412 </span><span class="spaces">    </span><span class="istickedoff">cname &lt;- scRegisterName sc (ModuleIdentifier c)</span>
<span class="lineno">  413 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">-- Step 1: build the types for the constructor and the type required</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="istickedoff">-- of its eliminator functions</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">tp &lt;- ctxCtorType sc d arg_struct</span>
<span class="lineno">  417 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">-- Finally, return the required Ctor record</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="istickedoff">return $ Ctor</span>
<span class="lineno">  420 </span><span class="spaces">      </span><span class="istickedoff">{ ctorName = cname</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="istickedoff">, ctorArgStruct = arg_struct</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="istickedoff">, ctorDataType = d</span>
<span class="lineno">  423 </span><span class="spaces">      </span><span class="istickedoff">, ctorType = tp</span>
<span class="lineno">  424 </span><span class="spaces">      </span><span class="istickedoff">}</span></span>
<span class="lineno">  425 </span>
<span class="lineno">  426 </span>-- | Reduce an application of a recursor to a particular constructor.
<span class="lineno">  427 </span>-- This is known in the Coq literature as an iota reduction. More specifically,
<span class="lineno">  428 </span>-- the call
<span class="lineno">  429 </span>--
<span class="lineno">  430 </span>-- &gt; ctxReduceRecursor rec f_c [x1, .., xk]
<span class="lineno">  431 </span>--
<span class="lineno">  432 </span>-- reduces the term @(RecursorApp rec ixs (CtorApp c ps xs))@ to
<span class="lineno">  433 </span>--
<span class="lineno">  434 </span>-- &gt; f_c x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  435 </span>--
<span class="lineno">  436 </span>-- where @f_c@ is the eliminator function associated to the constructor @c@ by the
<span class="lineno">  437 </span>-- recursor value @rec@.  Here @maybe rec_tm_i@ indicates an optional recursive call
<span class="lineno">  438 </span>-- of the recursor on one of the @xi@. These recursive calls only exist for those
<span class="lineno">  439 </span>-- arguments @xi@ that are recursive arguments, i.e., that are specified with
<span class="lineno">  440 </span>-- 'RecursiveArg', and are omitted for non-recursive arguments specified by 'ConstArg'.
<span class="lineno">  441 </span>--
<span class="lineno">  442 </span>-- Specifically, for a @'RecursiveArg' zs ixs@ argument @xi@, which has type
<span class="lineno">  443 </span>-- @\(z1::Z1) -&gt; .. -&gt; d p1 .. pn ix1 .. ixp@, we build the recursive call
<span class="lineno">  444 </span>--
<span class="lineno">  445 </span>-- &gt; \(z1::[xs/args]Z1) -&gt; .. -&gt;
<span class="lineno">  446 </span>-- &gt;   RecursorApp rec [xs/args]ixs (xi z1 ... zn)
<span class="lineno">  447 </span>--
<span class="lineno">  448 </span>-- where @[xs/args]@ substitutes the concrete values for the earlier
<span class="lineno">  449 </span>-- constructor arguments @xs@ for the remaining free variables.
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>ctxReduceRecursor ::
<span class="lineno">  452 </span>  SharedContext -&gt;
<span class="lineno">  453 </span>  Term {- ^ recursor applied to params, motive, and eliminator functions -} -&gt;
<span class="lineno">  454 </span>  Term {- ^ constructor eliminator function -} -&gt;
<span class="lineno">  455 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  456 </span>  CtorArgStruct {- ^ constructor formal argument descriptor -} -&gt;
<span class="lineno">  457 </span>  IO Term
<span class="lineno">  458 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor sc r elimf c_args CtorArgStruct{..}</span>
<span class="lineno">  459 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">length c_args /= length ctorArgs</span> = <span class="nottickedoff">panic &quot;ctxReduceRecursor&quot; [&quot;Wrong number of constructor arguments&quot;]</span></span>
<span class="lineno">  460 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">do args &lt;- mk_args <span class="nottickedoff">IntMap.empty</span> (zip c_args ctorArgs)</span>
<span class="lineno">  462 </span><span class="spaces">       </span><span class="istickedoff">scWhnf sc =&lt;&lt; scApplyAll sc elimf args</span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">mk_args :: IntMap Term -&gt;  -- already processed parameters/arguments</span>
<span class="lineno">  465 </span><span class="spaces">               </span><span class="istickedoff">[(Term, (VarName, CtorArg))] -&gt;</span>
<span class="lineno">  466 </span><span class="spaces">                 </span><span class="istickedoff">-- remaining actual arguments to process, with</span>
<span class="lineno">  467 </span><span class="spaces">                 </span><span class="istickedoff">-- telescope for typing the actual arguments</span>
<span class="lineno">  468 </span><span class="spaces">               </span><span class="istickedoff">IO [Term]</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">-- no more arguments to process</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ [] = return []</span>
<span class="lineno">  471 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is not a recursive call</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (nm, ConstArg _)) : xs_args) =</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">do tl &lt;- mk_args <span class="nottickedoff">(IntMap.insert (vnIndex nm) x pre_xs)</span> xs_args</span>
<span class="lineno">  475 </span><span class="spaces">         </span><span class="istickedoff">pure (x : tl)</span>
<span class="lineno">  476 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  477 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is a recursive call</span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (nm, RecursiveArg zs ixs)) : xs_args) =</span>
<span class="lineno">  479 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do zs'  &lt;- traverse (traverse (scInstantiate sc pre_xs)) zs</span></span>
<span class="lineno">  480 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">ixs' &lt;- traverse (scInstantiate sc pre_xs) ixs</span></span>
<span class="lineno">  481 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">recx &lt;- mk_rec_arg zs' ixs' x</span></span>
<span class="lineno">  482 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">tl   &lt;- mk_args (IntMap.insert (vnIndex nm) x pre_xs) xs_args</span></span>
<span class="lineno">  483 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">pure (x : recx : tl)</span></span>
<span class="lineno">  484 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  485 </span><span class="spaces">    </span><span class="istickedoff">-- Build an individual recursive call, given the parameters, the bindings</span>
<span class="lineno">  486 </span><span class="spaces">    </span><span class="istickedoff">-- for the RecursiveArg, and the argument we are going to recurse on</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">-- The resulting term has the form</span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff">-- &gt; \(z1:Z1) .. (zk:Zk) -&gt; r ixs (x z1 .. zk)</span>
<span class="lineno">  489 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg ::</span>
<span class="lineno">  490 </span><span class="spaces">      </span><span class="istickedoff">[(VarName, Term)] -&gt;             -- telescope describing the zs</span>
<span class="lineno">  491 </span><span class="spaces">      </span><span class="istickedoff">[Term] -&gt;                        -- actual values for the indices, shifted under zs</span>
<span class="lineno">  492 </span><span class="spaces">      </span><span class="istickedoff">Term -&gt;                         -- actual value in recursive position</span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="istickedoff">IO Term</span>
<span class="lineno">  494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">mk_rec_arg zs_ctx ixs x =</span></span>
<span class="lineno">  495 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">-- eta expand over the zs and apply the Recursor form</span></span>
<span class="lineno">  496 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do zs &lt;- scVariables sc zs_ctx</span></span>
<span class="lineno">  497 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">x_zs &lt;- scApplyAll sc x zs</span></span>
<span class="lineno">  498 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">r_ixs &lt;- scApplyAll sc r ixs</span></span>
<span class="lineno">  499 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">body &lt;- scApply sc r_ixs x_zs</span></span>
<span class="lineno">  500 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">scLambdaList sc zs_ctx body</span></span></span>
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>-- | Reduce an application of a recursor. This is known in the Coq literature as
<span class="lineno">  503 </span>-- an iota reduction. More specifically, the call
<span class="lineno">  504 </span>--
<span class="lineno">  505 </span>-- &gt; scReduceRecursor sc rec crec ci [x1, .., xk]
<span class="lineno">  506 </span>--
<span class="lineno">  507 </span>-- reduces the term @(Recursor r elims ixs (CtorApp ci ps xs))@ to
<span class="lineno">  508 </span>--
<span class="lineno">  509 </span>-- &gt; fi x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  510 </span>--
<span class="lineno">  511 </span>-- where @maybe rec_tm_i@ indicates an optional recursive call of the recursor
<span class="lineno">  512 </span>-- on one of the @xi@. These recursive calls only exist for those arguments
<span class="lineno">  513 </span>-- @xi@. See the documentation for 'ctxReduceRecursor' and the
<span class="lineno">  514 </span>-- 'ctorIotaReduction' field for more details.
<span class="lineno">  515 </span>scReduceRecursor ::
<span class="lineno">  516 </span>  SharedContext -&gt;
<span class="lineno">  517 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno">  518 </span>  CompiledRecursor {- ^ concrete data included in the recursor term -} -&gt;
<span class="lineno">  519 </span>  [Term] {- ^ datatype parameters -} -&gt;
<span class="lineno">  520 </span>  Term {- ^ motive function -} -&gt;
<span class="lineno">  521 </span>  [Term] {- ^ eliminator functions -} -&gt;
<span class="lineno">  522 </span>  Name {- ^ constructor name -} -&gt;
<span class="lineno">  523 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  524 </span>  IO Term
<span class="lineno">  525 </span><span class="decl"><span class="istickedoff">scReduceRecursor sc r crec params motive elims c args =</span>
<span class="lineno">  526 </span><span class="spaces">  </span><span class="istickedoff">do mres &lt;- lookupVarIndexInMap (nameIndex c) &lt;$&gt; scGetModuleMap sc</span>
<span class="lineno">  527 </span><span class="spaces">     </span><span class="istickedoff">let cs_fs = Map.fromList (zip (map nameIndex (recursorCtorOrder crec)) elims)</span>
<span class="lineno">  528 </span><span class="spaces">     </span><span class="istickedoff">r_applied &lt;- scApplyAll sc r (params ++ motive : elims)</span>
<span class="lineno">  529 </span><span class="spaces">     </span><span class="istickedoff">case mres of</span>
<span class="lineno">  530 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedCtor ctor) -&gt;</span>
<span class="lineno">  531 </span><span class="spaces">         </span><span class="istickedoff">-- The ctorIotaReduction field caches the result of iota reduction, which</span>
<span class="lineno">  532 </span><span class="spaces">         </span><span class="istickedoff">-- we just substitute into to perform the reduction</span>
<span class="lineno">  533 </span><span class="spaces">         </span><span class="istickedoff">ctorIotaReduction sc ctor <span class="nottickedoff">r_applied</span> cs_fs args</span>
<span class="lineno">  534 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  535 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">panic &quot;scReduceRecursor&quot; [&quot;Could not find constructor: &quot; &lt;&gt; toAbsoluteName (nameInfo c)]</span></span></span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>-- | Function for computing the result of one step of iota reduction
<span class="lineno">  538 </span>-- of the term
<span class="lineno">  539 </span>--
<span class="lineno">  540 </span>-- &gt; dt#rec params elims ixs (c params args)
<span class="lineno">  541 </span>--
<span class="lineno">  542 </span>-- The arguments to this function are the recursor value (applied to
<span class="lineno">  543 </span>-- params, motive and elims), a mapping from constructor name indices
<span class="lineno">  544 </span>-- to eliminator functions, and the arguments to the constructor.
<span class="lineno">  545 </span>ctorIotaReduction ::
<span class="lineno">  546 </span>  SharedContext -&gt;
<span class="lineno">  547 </span>  Ctor -&gt;
<span class="lineno">  548 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno">  549 </span>  Map VarIndex Term {- ^ constructor eliminators -} -&gt;
<span class="lineno">  550 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  551 </span>  IO Term
<span class="lineno">  552 </span><span class="decl"><span class="istickedoff">ctorIotaReduction sc ctor r cs_fs args =</span>
<span class="lineno">  553 </span><span class="spaces">  </span><span class="istickedoff">ctxReduceRecursor sc <span class="nottickedoff">r</span> elim args (ctorArgStruct ctor)</span>
<span class="lineno">  554 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="istickedoff">elim =</span>
<span class="lineno">  556 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup (nameIndex (ctorName ctor)) cs_fs of</span>
<span class="lineno">  557 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; e</span>
<span class="lineno">  558 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  559 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;ctorIotaReduction&quot;</span></span>
<span class="lineno">  560 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;no eliminator for constructor &quot; &lt;&gt; toAbsoluteName (nameInfo (ctorName ctor))]</span></span></span>
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>--------------------------------------------------------------------------------
<span class="lineno">  563 </span>-- Type checking
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>-- | @reducePi sc (Pi x tp body) t@ returns @[t/x]body@, and otherwise fails
<span class="lineno">  566 </span>reducePi :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  567 </span><span class="decl"><span class="nottickedoff">reducePi sc t arg = do</span>
<span class="lineno">  568 </span><span class="spaces">  </span><span class="nottickedoff">t' &lt;- scWhnf sc t</span>
<span class="lineno">  569 </span><span class="spaces">  </span><span class="nottickedoff">case asPi t' of</span>
<span class="lineno">  570 </span><span class="spaces">    </span><span class="nottickedoff">Just (vn, _, body) -&gt;</span>
<span class="lineno">  571 </span><span class="spaces">      </span><span class="nottickedoff">scInstantiateBeta sc (IntMap.singleton (vnIndex vn) arg) body</span>
<span class="lineno">  572 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; do</span>
<span class="lineno">  573 </span><span class="spaces">      </span><span class="nottickedoff">t'' &lt;- ppTerm sc PPS.defaultOpts t'</span>
<span class="lineno">  574 </span><span class="spaces">      </span><span class="nottickedoff">fail $ unlines [&quot;reducePi: not a Pi term&quot;, t'']</span></span>
<span class="lineno">  575 </span>
<span class="lineno">  576 </span>
<span class="lineno">  577 </span>-- | Look up the type of a global constant, primitive, data type, or
<span class="lineno">  578 </span>-- data constructor, given its name as an 'Ident'.
<span class="lineno">  579 </span>scTypeOfIdent :: SharedContext -&gt; Ident -&gt; IO Term
<span class="lineno">  580 </span><span class="decl"><span class="istickedoff">scTypeOfIdent sc ident =</span>
<span class="lineno">  581 </span><span class="spaces">  </span><span class="istickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  582 </span><span class="spaces">     </span><span class="istickedoff">case resolveNameInMap mm ident of</span>
<span class="lineno">  583 </span><span class="spaces">       </span><span class="istickedoff">Just r -&gt; pure (resolvedNameType r)</span>
<span class="lineno">  584 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail (&quot;scTypeOfIdent: Identifier not found: &quot; ++ show ident)</span></span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>-- | Look up the type of a global constant, given its 'Name'.
<span class="lineno">  587 </span>scTypeOfName :: SharedContext -&gt; Name -&gt; IO Term
<span class="lineno">  588 </span><span class="decl"><span class="nottickedoff">scTypeOfName sc nm =</span>
<span class="lineno">  589 </span><span class="spaces">  </span><span class="nottickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  590 </span><span class="spaces">     </span><span class="nottickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  591 </span><span class="spaces">       </span><span class="nottickedoff">Just r -&gt; pure (resolvedNameType r)</span>
<span class="lineno">  592 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt; fail (&quot;scTypeOfName: Name not found: &quot; ++ show nm)</span></span>
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>--------------------------------------------------------------------------------
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>-- | Imports a term built in a different shared context into the given
<span class="lineno">  597 </span>-- shared context. The caller must ensure that all the global constants
<span class="lineno">  598 </span>-- appearing in the term are valid in the new context.
<span class="lineno">  599 </span>scImport :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  600 </span><span class="decl"><span class="nottickedoff">scImport sc t0 =</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="nottickedoff">do cache &lt;- newCache</span>
<span class="lineno">  602 </span><span class="spaces">       </span><span class="nottickedoff">go cache t0</span>
<span class="lineno">  603 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="nottickedoff">go :: Cache IO TermIndex Term -&gt; Term -&gt; IO Term</span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="nottickedoff">go cache t =</span>
<span class="lineno">  606 </span><span class="spaces">      </span><span class="nottickedoff">useCache cache (termIndex t) (scTermF sc =&lt;&lt; traverse (go cache) (unwrapTermF t))</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>--------------------------------------------------------------------------------
<span class="lineno">  609 </span>-- Beta Normalization
<span class="lineno">  610 </span>
<span class="lineno">  611 </span>-- | Apply a function to an argument, beta-reducing if the function is
<span class="lineno">  612 </span>-- a lambda.
<span class="lineno">  613 </span>-- If both input terms are in beta-normal form, then the result will
<span class="lineno">  614 </span>-- also be beta-normal.
<span class="lineno">  615 </span>scApplyBeta :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  616 </span><span class="decl"><span class="nottickedoff">scApplyBeta sc f arg = scApplyAllBeta sc f [arg]</span></span>
<span class="lineno">  617 </span>
<span class="lineno">  618 </span>-- | Internal function: Instantiate free variables within a term,
<span class="lineno">  619 </span>-- apply it to a list of arguments, and beta-normalize the result.
<span class="lineno">  620 </span>-- Precondition: All terms in the substitution map and the list of
<span class="lineno">  621 </span>-- arguments are already in beta-normal form.
<span class="lineno">  622 </span>scBetaNormalizeAux ::
<span class="lineno">  623 </span>  SharedContext -&gt; IntMap Term -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno">  624 </span><span class="decl"><span class="istickedoff">scBetaNormalizeAux sc sub t0 args0 =</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="istickedoff">do let rangeVars = foldMap freeVars sub</span>
<span class="lineno">  626 </span><span class="spaces">     </span><span class="istickedoff">-- The cache memoizes the result of normalizing a given</span>
<span class="lineno">  627 </span><span class="spaces">     </span><span class="istickedoff">-- expression under the current substitution; recursive calls</span>
<span class="lineno">  628 </span><span class="spaces">     </span><span class="istickedoff">-- that change the substitution must start a new memo table.</span>
<span class="lineno">  629 </span><span class="spaces">     </span><span class="istickedoff">cache &lt;- newCacheIntMap</span>
<span class="lineno">  630 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; IO Term</span>
<span class="lineno">  631 </span><span class="spaces">         </span><span class="istickedoff">memo t = useCache cache (termIndex t) (go t [])</span>
<span class="lineno">  632 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; [Term] -&gt; IO Term</span>
<span class="lineno">  633 </span><span class="spaces">         </span><span class="istickedoff">go t args =</span>
<span class="lineno">  634 </span><span class="spaces">           </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  635 </span><span class="spaces">             </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno">  636 </span><span class="spaces">               </span><span class="istickedoff">do ftf' &lt;- traverse <span class="nottickedoff">memo</span> ftf</span>
<span class="lineno">  637 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scFlatTermF sc ftf'</span>
<span class="lineno">  638 </span><span class="spaces">                  </span><span class="istickedoff">scApplyAll <span class="nottickedoff">sc</span> t' args</span>
<span class="lineno">  639 </span><span class="spaces">             </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno">  640 </span><span class="spaces">               </span><span class="istickedoff">do t2' &lt;- memo t2</span>
<span class="lineno">  641 </span><span class="spaces">                  </span><span class="istickedoff">go t1 (t2' : args)</span>
<span class="lineno">  642 </span><span class="spaces">             </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno">  643 </span><span class="spaces">               </span><span class="istickedoff">case args of</span>
<span class="lineno">  644 </span><span class="spaces">                 </span><span class="istickedoff">arg : args' -&gt;</span>
<span class="lineno">  645 </span><span class="spaces">                   </span><span class="istickedoff">-- No possibility of capture here, as the binder is</span>
<span class="lineno">  646 </span><span class="spaces">                   </span><span class="istickedoff">-- going away. If x is already in the map,</span>
<span class="lineno">  647 </span><span class="spaces">                   </span><span class="istickedoff">-- overwriting that entry is what we want.</span>
<span class="lineno">  648 </span><span class="spaces">                   </span><span class="istickedoff">do let sub' = IntMap.insert (vnIndex x) arg sub</span>
<span class="lineno">  649 </span><span class="spaces">                      </span><span class="istickedoff">scBetaNormalizeAux sc sub' t2 args'</span>
<span class="lineno">  650 </span><span class="spaces">                 </span><span class="istickedoff">[] -&gt;</span>
<span class="lineno">  651 </span><span class="spaces">                   </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno">  652 </span><span class="spaces">                      </span><span class="istickedoff">-- Freshen bound variable if it can capture.</span>
<span class="lineno">  653 </span><span class="spaces">                      </span><span class="istickedoff">x' &lt;-</span>
<span class="lineno">  654 </span><span class="spaces">                        </span><span class="istickedoff">if <span class="tickonlyfalse">IntSet.member (vnIndex x) rangeVars</span></span>
<span class="lineno">  655 </span><span class="spaces">                        </span><span class="istickedoff">then <span class="nottickedoff">scFreshVarName sc (vnName x)</span></span>
<span class="lineno">  656 </span><span class="spaces">                        </span><span class="istickedoff">else pure x</span>
<span class="lineno">  657 </span><span class="spaces">                      </span><span class="istickedoff">var &lt;- scVariable sc x' t1'</span>
<span class="lineno">  658 </span><span class="spaces">                      </span><span class="istickedoff">let sub' = IntMap.insert (vnIndex x) var sub</span>
<span class="lineno">  659 </span><span class="spaces">                      </span><span class="istickedoff">t2' &lt;- scBetaNormalizeAux sc sub' t2 []</span>
<span class="lineno">  660 </span><span class="spaces">                      </span><span class="istickedoff">scLambda sc x' t1' t2'</span>
<span class="lineno">  661 </span><span class="spaces">             </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno">  662 </span><span class="spaces">               </span><span class="istickedoff">-- Pi expressions may never be applied to arguments</span>
<span class="lineno">  663 </span><span class="spaces">               </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno">  664 </span><span class="spaces">                  </span><span class="istickedoff">-- Freshen bound variable if it can capture.</span>
<span class="lineno">  665 </span><span class="spaces">                  </span><span class="istickedoff">x' &lt;-</span>
<span class="lineno">  666 </span><span class="spaces">                    </span><span class="istickedoff">if IntSet.member (vnIndex x) rangeVars</span>
<span class="lineno">  667 </span><span class="spaces">                    </span><span class="istickedoff">then scFreshVarName sc (vnName x)</span>
<span class="lineno">  668 </span><span class="spaces">                    </span><span class="istickedoff">else pure x</span>
<span class="lineno">  669 </span><span class="spaces">                  </span><span class="istickedoff">var &lt;- scVariable sc x' t1'</span>
<span class="lineno">  670 </span><span class="spaces">                  </span><span class="istickedoff">let sub' = IntMap.insert (vnIndex x) var sub</span>
<span class="lineno">  671 </span><span class="spaces">                  </span><span class="istickedoff">t2' &lt;- scBetaNormalizeAux sc sub' t2 []</span>
<span class="lineno">  672 </span><span class="spaces">                  </span><span class="istickedoff">scPi sc x' t1' t2'</span>
<span class="lineno">  673 </span><span class="spaces">             </span><span class="istickedoff">Constant{} -&gt;</span>
<span class="lineno">  674 </span><span class="spaces">               </span><span class="istickedoff">scApplyAll sc t args</span>
<span class="lineno">  675 </span><span class="spaces">             </span><span class="istickedoff">Variable x _ -&gt;</span>
<span class="lineno">  676 </span><span class="spaces">               </span><span class="istickedoff">-- All bound variables will be present in the map.</span>
<span class="lineno">  677 </span><span class="spaces">               </span><span class="istickedoff">-- To preserve term invariants, free variables must</span>
<span class="lineno">  678 </span><span class="spaces">               </span><span class="istickedoff">-- have their type annotations left unmodified.</span>
<span class="lineno">  679 </span><span class="spaces">               </span><span class="istickedoff">case IntMap.lookup (vnIndex x) sub of</span>
<span class="lineno">  680 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  681 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">scApplyAll sc t args</span></span>
<span class="lineno">  682 </span><span class="spaces">                 </span><span class="istickedoff">Just t' -&gt;</span>
<span class="lineno">  683 </span><span class="spaces">                   </span><span class="istickedoff">scApplyAllBeta sc t' args</span>
<span class="lineno">  684 </span><span class="spaces">     </span><span class="istickedoff">go t0 args0</span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>-- | Beta-reduce a term to normal form.
<span class="lineno">  687 </span>betaNormalize :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  688 </span><span class="decl"><span class="istickedoff">betaNormalize sc t = scBetaNormalizeAux sc IntMap.empty t []</span></span>
<span class="lineno">  689 </span>
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>--------------------------------------------------------------------------------
<span class="lineno">  692 </span>-- Building shared terms
<span class="lineno">  693 </span>
<span class="lineno">  694 </span>-- | Apply a function 'Term' to zero or more argument 'Term's.
<span class="lineno">  695 </span>scApplyAll :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno">  696 </span><span class="decl"><span class="istickedoff">scApplyAll sc = foldlM (scApply sc)</span></span>
<span class="lineno">  697 </span>
<span class="lineno">  698 </span>-- | Create a term from a 'Sort', and set the advisory &quot;inhabited&quot; flag
<span class="lineno">  699 </span>scISort :: SharedContext -&gt; Sort -&gt; IO Term
<span class="lineno">  700 </span><span class="decl"><span class="istickedoff">scISort sc s = scSortWithFlags sc s $ noFlags { flagInhabited = True }</span></span>
<span class="lineno">  701 </span>
<span class="lineno">  702 </span>-- | Create an n-place tuple from a list (of length n) of 'Term's.
<span class="lineno">  703 </span>-- Note that tuples are nested pairs, associating to the right e.g.
<span class="lineno">  704 </span>-- @(a, (b, (c, d)))@.
<span class="lineno">  705 </span>scTuple :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno">  706 </span><span class="decl"><span class="istickedoff">scTuple sc [] = scUnitValue sc</span>
<span class="lineno">  707 </span><span class="spaces"></span><span class="istickedoff">scTuple _ [t] = return t</span>
<span class="lineno">  708 </span><span class="spaces"></span><span class="istickedoff">scTuple sc (t : ts) = scPairValue sc t =&lt;&lt; scTuple sc ts</span></span>
<span class="lineno">  709 </span>
<span class="lineno">  710 </span>-- | Create a term representing the type of an n-place tuple, from a list
<span class="lineno">  711 </span>-- (of length n) of 'Term's, each representing a type.
<span class="lineno">  712 </span>scTupleType :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno">  713 </span><span class="decl"><span class="istickedoff">scTupleType sc [] = scUnitType sc</span>
<span class="lineno">  714 </span><span class="spaces"></span><span class="istickedoff">scTupleType _ [t] = return t</span>
<span class="lineno">  715 </span><span class="spaces"></span><span class="istickedoff">scTupleType sc (t : ts) = scPairType sc t =&lt;&lt; scTupleType sc ts</span></span>
<span class="lineno">  716 </span>
<span class="lineno">  717 </span>-- | @scTupleSelector sc t i n@ returns a term selecting the @i@th component of
<span class="lineno">  718 </span>-- an @n@-place tuple 'Term', @t@.
<span class="lineno">  719 </span>scTupleSelector ::
<span class="lineno">  720 </span>  SharedContext -&gt; Term -&gt;
<span class="lineno">  721 </span>  Int {- ^ 1-based index -} -&gt;
<span class="lineno">  722 </span>  Int {- ^ tuple size -} -&gt;
<span class="lineno">  723 </span>  IO Term
<span class="lineno">  724 </span><span class="decl"><span class="istickedoff">scTupleSelector sc t i n</span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="istickedoff">| n == 1    = return t</span>
<span class="lineno">  726 </span><span class="spaces">  </span><span class="istickedoff">| i == 1    = scPairLeft sc t</span>
<span class="lineno">  727 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">i &gt; 1</span>     = do t' &lt;- scPairRight sc t</span>
<span class="lineno">  728 </span><span class="spaces">                   </span><span class="istickedoff">scTupleSelector sc t' (i - 1) (n - 1)</span>
<span class="lineno">  729 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">fail &quot;scTupleSelector: non-positive index&quot;</span></span></span>
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>-- | An optimized variant of 'scPairValue' that will reduce pairs of
<span class="lineno">  732 </span>-- the form @(x.L, x.R)@ to @x@.
<span class="lineno">  733 </span>scPairValueReduced :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  734 </span><span class="decl"><span class="istickedoff">scPairValueReduced sc x y =</span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="istickedoff">case (unwrapTermF x, unwrapTermF y) of</span>
<span class="lineno">  736 </span><span class="spaces">    </span><span class="istickedoff">(FTermF (PairLeft a), FTermF (PairRight b)) | <span class="tickonlytrue">a == b</span> -&gt; return a</span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; scPairValue sc x y</span></span>
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>-- | An optimized variant of 'scPairTuple' that will reduce tuples of
<span class="lineno">  740 </span>-- the form @(x.1, x.2, x.3)@ to @x@.
<span class="lineno">  741 </span>scTupleReduced :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno">  742 </span><span class="decl"><span class="istickedoff">scTupleReduced sc [] = <span class="nottickedoff">scUnitValue sc</span></span>
<span class="lineno">  743 </span><span class="spaces"></span><span class="istickedoff">scTupleReduced _ [t] = return t</span>
<span class="lineno">  744 </span><span class="spaces"></span><span class="istickedoff">scTupleReduced sc (t : ts) = scPairValueReduced sc t =&lt;&lt; scTupleReduced sc ts</span></span>
<span class="lineno">  745 </span>
<span class="lineno">  746 </span>-- | An optimized variant of 'scVector' that will reduce vectors of
<span class="lineno">  747 </span>-- the form @[at x 0, at x 1, at x 2, at x 3]@ to just @x@.
<span class="lineno">  748 </span>scVectorReduced :: SharedContext -&gt; Term {- ^ element type -} -&gt; [Term] {- ^ elements -} -&gt; IO Term
<span class="lineno">  749 </span><span class="decl"><span class="istickedoff">scVectorReduced sc ety xs</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff">| (hd : _) &lt;- xs</span>
<span class="lineno">  751 </span><span class="spaces">  </span><span class="istickedoff">, Just ((arr_sz :*: arr_tm) :*: 0) &lt;- asAtOrBvAt hd</span>
<span class="lineno">  752 </span><span class="spaces">  </span><span class="istickedoff">, fromIntegral (length xs) == arr_sz</span>
<span class="lineno">  753 </span><span class="spaces">  </span><span class="istickedoff">, iall (\i x -&gt; asAtOrBvAt x == Just ((arr_sz :*: arr_tm) :*: fromIntegral i)) xs =</span>
<span class="lineno">  754 </span><span class="spaces">    </span><span class="istickedoff">return arr_tm</span>
<span class="lineno">  755 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = scVector sc ety xs</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff">asAny :: Term -&gt; Maybe ()</span>
<span class="lineno">  758 </span><span class="spaces">    </span><span class="istickedoff">asAny _ = Just <span class="nottickedoff">()</span></span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  760 </span><span class="spaces">    </span><span class="istickedoff">asAt :: Term -&gt; Maybe ((Natural :*: Term) :*: Natural)</span>
<span class="lineno">  761 </span><span class="spaces">    </span><span class="istickedoff">asAt = (((isGlobalDef &quot;Prelude.at&quot; @&gt; asNat) &lt;@ asAny) &lt;@&gt; return) &lt;@&gt; asNat</span>
<span class="lineno">  762 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  763 </span><span class="spaces">    </span><span class="istickedoff">asBvAt :: Term -&gt; Maybe ((Natural :*: Term) :*: Natural)</span>
<span class="lineno">  764 </span><span class="spaces">    </span><span class="istickedoff">asBvAt = ((((isGlobalDef &quot;Prelude.bvAt&quot; @&gt; <span class="nottickedoff">asNat</span>) &lt;@ <span class="nottickedoff">asAny</span>) &lt;@ <span class="nottickedoff">asAny</span>) &lt;@&gt; <span class="nottickedoff">return</span>) &lt;@&gt; <span class="nottickedoff">asUnsignedConcreteBv</span></span>
<span class="lineno">  765 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  766 </span><span class="spaces">    </span><span class="istickedoff">asAtOrBvAt :: Term -&gt; Maybe ((Natural :*: Term) :*: Natural)</span>
<span class="lineno">  767 </span><span class="spaces">    </span><span class="istickedoff">asAtOrBvAt term</span>
<span class="lineno">  768 </span><span class="spaces">      </span><span class="istickedoff">| res@Just{} &lt;- asAt term = res</span>
<span class="lineno">  769 </span><span class="spaces">      </span><span class="istickedoff">| res@Just{} &lt;- asBvAt term = <span class="nottickedoff">res</span></span>
<span class="lineno">  770 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Nothing</span></span>
<span class="lineno">  771 </span>
<span class="lineno">  772 </span>------------------------------------------------------------
<span class="lineno">  773 </span>-- Building terms using prelude functions
<span class="lineno">  774 </span>
<span class="lineno">  775 </span>-- | Create a term applying @Prelude.EqTrue@ to the given term.
<span class="lineno">  776 </span>--
<span class="lineno">  777 </span>-- &gt; EqTrue : Bool -&gt; sort 1;
<span class="lineno">  778 </span>scEqTrue :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  779 </span><span class="decl"><span class="istickedoff">scEqTrue sc t = scGlobalApply sc &quot;Prelude.EqTrue&quot; [t]</span></span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>-- | Create a @Prelude.Bool@-typed term from the given Boolean: @Prelude.True@
<span class="lineno">  782 </span>-- for @True@, @Prelude.False@ for @False@.
<span class="lineno">  783 </span>scBool :: SharedContext -&gt; Bool -&gt; IO Term
<span class="lineno">  784 </span><span class="decl"><span class="istickedoff">scBool sc True  = scGlobalDef sc &quot;Prelude.True&quot;</span>
<span class="lineno">  785 </span><span class="spaces"></span><span class="istickedoff">scBool sc False = scGlobalDef sc &quot;Prelude.False&quot;</span></span>
<span class="lineno">  786 </span>
<span class="lineno">  787 </span>-- | Create a term representing the prelude Boolean type, @Prelude.Bool@.
<span class="lineno">  788 </span>scBoolType :: SharedContext -&gt; IO Term
<span class="lineno">  789 </span><span class="decl"><span class="istickedoff">scBoolType sc = scGlobalDef sc &quot;Prelude.Bool&quot;</span></span>
<span class="lineno">  790 </span>
<span class="lineno">  791 </span>-- | Create a term representing the prelude Natural type.
<span class="lineno">  792 </span>scNatType :: SharedContext -&gt; IO Term
<span class="lineno">  793 </span><span class="decl"><span class="nottickedoff">scNatType sc = scGlobalDef sc preludeNatIdent</span></span>
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>-- | Create a term representing a vector type, from a term giving the length
<span class="lineno">  796 </span>-- and a term giving the element type.
<span class="lineno">  797 </span>scVecType :: SharedContext
<span class="lineno">  798 </span>          -&gt; Term -- ^ The length of the vector
<span class="lineno">  799 </span>          -&gt; Term -- ^ The element type
<span class="lineno">  800 </span>          -&gt; IO Term
<span class="lineno">  801 </span><span class="decl"><span class="istickedoff">scVecType sc n e = scGlobalApply sc preludeVecIdent [n, e]</span></span>
<span class="lineno">  802 </span>
<span class="lineno">  803 </span>-- | Create a term applying @Prelude.not@ to the given term.
<span class="lineno">  804 </span>--
<span class="lineno">  805 </span>-- &gt; not : Bool -&gt; Bool;
<span class="lineno">  806 </span>scNot :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno">  807 </span><span class="decl"><span class="istickedoff">scNot sc t = scGlobalApply sc &quot;Prelude.not&quot; [t]</span></span>
<span class="lineno">  808 </span>
<span class="lineno">  809 </span>-- | Create a term applying @Prelude.and@ to the two given terms.
<span class="lineno">  810 </span>--
<span class="lineno">  811 </span>-- &gt; and : Bool -&gt; Bool -&gt; Bool;
<span class="lineno">  812 </span>scAnd :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  813 </span><span class="decl"><span class="istickedoff">scAnd sc x y = scGlobalApply sc &quot;Prelude.and&quot; [x,y]</span></span>
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>-- | Create a term applying @Prelude.or@ to the two given terms.
<span class="lineno">  816 </span>--
<span class="lineno">  817 </span>-- &gt; or : Bool -&gt; Bool -&gt; Bool;
<span class="lineno">  818 </span>scOr :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  819 </span><span class="decl"><span class="istickedoff">scOr sc x y = scGlobalApply sc &quot;Prelude.or&quot; [x,y]</span></span>
<span class="lineno">  820 </span>
<span class="lineno">  821 </span>-- | Create a term applying @Prelude.implies@ to the two given terms.
<span class="lineno">  822 </span>--
<span class="lineno">  823 </span>-- &gt; implies : Bool -&gt; Bool -&gt; Bool;
<span class="lineno">  824 </span>scImplies :: SharedContext -&gt; Term -&gt; Term
<span class="lineno">  825 </span>          -&gt; IO Term
<span class="lineno">  826 </span><span class="decl"><span class="istickedoff">scImplies sc x y = scGlobalApply sc &quot;Prelude.implies&quot; [x,y]</span></span>
<span class="lineno">  827 </span>
<span class="lineno">  828 </span>-- | Create a term applying @Prelude.xor@ to the two given terms.
<span class="lineno">  829 </span>--
<span class="lineno">  830 </span>-- &gt; xor : Bool -&gt; Bool -&gt; Bool;
<span class="lineno">  831 </span>scXor :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  832 </span><span class="decl"><span class="nottickedoff">scXor sc x y = scGlobalApply sc &quot;Prelude.xor&quot; [x,y]</span></span>
<span class="lineno">  833 </span>
<span class="lineno">  834 </span>-- | Create a term applying @Prelude.boolEq@ to the two given terms.
<span class="lineno">  835 </span>--
<span class="lineno">  836 </span>-- &gt; boolEq : Bool -&gt; Bool -&gt; Bool;
<span class="lineno">  837 </span>scBoolEq :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  838 </span><span class="decl"><span class="istickedoff">scBoolEq sc x y = scGlobalApply sc &quot;Prelude.boolEq&quot; [x,y]</span></span>
<span class="lineno">  839 </span>
<span class="lineno">  840 </span>-- | Create a universally quantified bitvector term.
<span class="lineno">  841 </span>--
<span class="lineno">  842 </span>-- &gt; bvForall : (n : Nat) -&gt; (Vec n Bool -&gt; Bool) -&gt; Bool;
<span class="lineno">  843 </span>scBvForall :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  844 </span><span class="decl"><span class="nottickedoff">scBvForall sc w f = scGlobalApply sc &quot;Prelude.bvForall&quot; [w, f]</span></span>
<span class="lineno">  845 </span>
<span class="lineno">  846 </span>-- | Create a non-dependent if-then-else term.
<span class="lineno">  847 </span>--
<span class="lineno">  848 </span>-- &gt; ite : (a : sort 1) -&gt; Bool -&gt; a -&gt; a -&gt; a;
<span class="lineno">  849 </span>scIte :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno">  850 </span>         Term -&gt; Term -&gt; IO Term
<span class="lineno">  851 </span><span class="decl"><span class="istickedoff">scIte sc t b x y = scGlobalApply sc &quot;Prelude.ite&quot; [t, b, x, y]</span></span>
<span class="lineno">  852 </span>
<span class="lineno">  853 </span>-- | Build a conjunction from a list of boolean terms.
<span class="lineno">  854 </span>scAndList :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno">  855 </span><span class="decl"><span class="istickedoff">scAndList sc = conj . filter nontrivial</span>
<span class="lineno">  856 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  857 </span><span class="spaces">    </span><span class="istickedoff">nontrivial x = asBool x /= Just <span class="nottickedoff">True</span></span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="istickedoff">conj [] = scBool sc True</span>
<span class="lineno">  859 </span><span class="spaces">    </span><span class="istickedoff">conj [x] = return x</span>
<span class="lineno">  860 </span><span class="spaces">    </span><span class="istickedoff">conj (x : xs) = foldM (scAnd sc) x xs</span></span>
<span class="lineno">  861 </span>
<span class="lineno">  862 </span>-- | Build a conjunction from a list of boolean terms.
<span class="lineno">  863 </span>scOrList :: SharedContext -&gt; [Term] -&gt; IO Term
<span class="lineno">  864 </span><span class="decl"><span class="nottickedoff">scOrList sc = disj . filter nontrivial</span>
<span class="lineno">  865 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="nottickedoff">nontrivial x = asBool x /= Just False</span>
<span class="lineno">  867 </span><span class="spaces">    </span><span class="nottickedoff">disj [] = scBool sc False</span>
<span class="lineno">  868 </span><span class="spaces">    </span><span class="nottickedoff">disj [x] = return x</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="nottickedoff">disj (x : xs) = foldM (scOr sc) x xs</span></span>
<span class="lineno">  870 </span>
<span class="lineno">  871 </span>
<span class="lineno">  872 </span>-- | Create a term applying @Prelude.append@ to two vectors.
<span class="lineno">  873 </span>--
<span class="lineno">  874 </span>-- &gt; append : (m n : Nat) -&gt; (e : sort 0) -&gt; Vec m e -&gt; Vec n e -&gt; Vec (addNat m n) e;
<span class="lineno">  875 </span>scAppend :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt;
<span class="lineno">  876 </span>            Term -&gt; Term -&gt; IO Term
<span class="lineno">  877 </span><span class="decl"><span class="istickedoff">scAppend sc m n t x y = scGlobalApply sc &quot;Prelude.append&quot; [m, n, t, x, y]</span></span>
<span class="lineno">  878 </span>
<span class="lineno">  879 </span>-- | Create a term applying @Prelude.join@ to a vector of vectors.
<span class="lineno">  880 </span>--
<span class="lineno">  881 </span>-- &gt; join  : (m n : Nat) -&gt; (a : sort 0) -&gt; Vec m (Vec n a) -&gt; Vec (mulNat m n) a;
<span class="lineno">  882 </span>scJoin :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  883 </span><span class="decl"><span class="istickedoff">scJoin sc m n a v = scGlobalApply sc &quot;Prelude.join&quot; [m, n, a, v]</span></span>
<span class="lineno">  884 </span>
<span class="lineno">  885 </span>-- | Create a term splitting a vector with @Prelude.split@.
<span class="lineno">  886 </span>--
<span class="lineno">  887 </span>-- &gt; split : (m n : Nat) -&gt; (a : sort 0) -&gt; Vec (mulNat m n) a -&gt; Vec m (Vec n a);
<span class="lineno">  888 </span>scSplit :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  889 </span><span class="decl"><span class="istickedoff">scSplit sc m n a v = scGlobalApply sc &quot;Prelude.split&quot; [m, n, a, v]</span></span>
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>-- | Create a term selecting a range of values from a vector with @Prelude.slice@.
<span class="lineno">  892 </span>--
<span class="lineno">  893 </span>-- &gt; slice : (e : sort 1) -&gt; (i n o : Nat) -&gt; Vec (addNat (addNat i n) o) e -&gt; Vec n e;
<span class="lineno">  894 </span>scSlice :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno">  895 </span>           Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  896 </span><span class="decl"><span class="istickedoff">scSlice sc e i n o a = scGlobalApply sc &quot;Prelude.slice&quot; [e, i, n, o, a]</span></span>
<span class="lineno">  897 </span>
<span class="lineno">  898 </span>-- | Create a term accessing a particular element of a vector with @get@.
<span class="lineno">  899 </span>--
<span class="lineno">  900 </span>-- &gt; get : (n : Nat) -&gt; (e : sort 0) -&gt; Vec n e -&gt; Fin n -&gt; e;
<span class="lineno">  901 </span>scGet :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno">  902 </span>         Term -&gt; Term -&gt; IO Term
<span class="lineno">  903 </span><span class="decl"><span class="nottickedoff">scGet sc n e v i = scGlobalApply sc (mkIdent preludeName &quot;get&quot;) [n, e, v, i]</span></span>
<span class="lineno">  904 </span>
<span class="lineno">  905 </span>-- | Create a term accessing a particular element of a vector with @bvAt@,
<span class="lineno">  906 </span>-- which uses a bitvector for indexing.
<span class="lineno">  907 </span>--
<span class="lineno">  908 </span>-- &gt; bvAt : (n : Nat) -&gt; (a : sort 0) -&gt; (w : Nat) -&gt; Vec n a -&gt; Vec w Bool -&gt; a;
<span class="lineno">  909 </span>scBvAt :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno">  910 </span>         Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  911 </span><span class="decl"><span class="istickedoff">scBvAt sc n a i xs idx = scGlobalApply sc (mkIdent preludeName &quot;bvAt&quot;) [n, a, i, xs, idx]</span></span>
<span class="lineno">  912 </span>
<span class="lineno">  913 </span>-- | Create a term accessing a particular element of a vector, with a default
<span class="lineno">  914 </span>-- to return if the index is out of bounds.
<span class="lineno">  915 </span>--
<span class="lineno">  916 </span>-- &gt; atWithDefault : (n : Nat) -&gt; (a : sort 0) -&gt; a -&gt; Vec n a -&gt; Nat -&gt; a;
<span class="lineno">  917 </span>scAtWithDefault :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  918 </span><span class="decl"><span class="nottickedoff">scAtWithDefault sc n a v xs idx = scGlobalApply sc (mkIdent preludeName &quot;atWithDefault&quot;) [n, a, v, xs, idx]</span></span>
<span class="lineno">  919 </span>
<span class="lineno">  920 </span>-- | Create a term accessing a particular element of a vector, failing if the
<span class="lineno">  921 </span>-- index is out of bounds.
<span class="lineno">  922 </span>--
<span class="lineno">  923 </span>-- &gt; at : (n : Nat) -&gt; (a : sort 0) -&gt; Vec n a -&gt; Nat -&gt; a;
<span class="lineno">  924 </span>scAt :: SharedContext -&gt; Term -&gt; Term -&gt;
<span class="lineno">  925 </span>        Term -&gt; Term -&gt; IO Term
<span class="lineno">  926 </span><span class="decl"><span class="istickedoff">scAt sc n a xs idx = scGlobalApply sc (mkIdent preludeName &quot;at&quot;) [n, a, xs, idx]</span></span>
<span class="lineno">  927 </span>
<span class="lineno">  928 </span>-- | Create a term evaluating to a vector containing a single element.
<span class="lineno">  929 </span>--
<span class="lineno">  930 </span>-- &gt; single : (e : sort 1) -&gt; e -&gt; Vec 1 e;
<span class="lineno">  931 </span>scSingle :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  932 </span><span class="decl"><span class="istickedoff">scSingle sc e x = scGlobalApply sc (mkIdent preludeName &quot;single&quot;) [e, x]</span></span>
<span class="lineno">  933 </span>
<span class="lineno">  934 </span>-- | Create a term computing the least significant bit of a bitvector, given a
<span class="lineno">  935 </span>-- length and bitvector.
<span class="lineno">  936 </span>--
<span class="lineno">  937 </span>-- &gt; lsb : (n : Nat) -&gt; Vec (Succ n) Bool -&gt; Bool;
<span class="lineno">  938 </span>scLsb :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  939 </span><span class="decl"><span class="nottickedoff">scLsb sc n x = scGlobalApply sc (mkIdent preludeName &quot;lsb&quot;) [n, x]</span></span>
<span class="lineno">  940 </span>
<span class="lineno">  941 </span>-- | Create a term computing the most significant bit of a bitvector, given a
<span class="lineno">  942 </span>-- length and bitvector.
<span class="lineno">  943 </span>--
<span class="lineno">  944 </span>-- &gt; msb : (n : Nat) -&gt; Vec (Succ n) Bool -&gt; Bool;
<span class="lineno">  945 </span>scMsb :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  946 </span><span class="decl"><span class="nottickedoff">scMsb sc n x = scGlobalApply sc (mkIdent preludeName &quot;lsb&quot;) [n, x]</span></span>
<span class="lineno">  947 </span>
<span class="lineno">  948 </span>-- Primitive operations on nats
<span class="lineno">  949 </span>
<span class="lineno">  950 </span>-- | Create a term computing the sum of the two given (natural number) terms.
<span class="lineno">  951 </span>--
<span class="lineno">  952 </span>-- &gt; addNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno">  953 </span>scAddNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  954 </span><span class="decl"><span class="nottickedoff">scAddNat sc x y = scGlobalApply sc &quot;Prelude.addNat&quot; [x,y]</span></span>
<span class="lineno">  955 </span>
<span class="lineno">  956 </span>-- | Create a term computing the difference between the two given
<span class="lineno">  957 </span>-- (natural number) terms.
<span class="lineno">  958 </span>--
<span class="lineno">  959 </span>-- &gt; subNat : Nat -&gt; Nat -&gt; Nat
<span class="lineno">  960 </span>scSubNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  961 </span><span class="decl"><span class="nottickedoff">scSubNat sc x y = scGlobalApply sc &quot;Prelude.subNat&quot; [x,y]</span></span>
<span class="lineno">  962 </span>
<span class="lineno">  963 </span>-- | Create a term computing the product of the two given (natural number)
<span class="lineno">  964 </span>-- terms.
<span class="lineno">  965 </span>--
<span class="lineno">  966 </span>-- &gt; mulNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno">  967 </span>scMulNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  968 </span><span class="decl"><span class="nottickedoff">scMulNat sc x y = scGlobalApply sc &quot;Prelude.mulNat&quot; [x,y]</span></span>
<span class="lineno">  969 </span>
<span class="lineno">  970 </span>-- | Create a term computing the quotient of the two given (natural number)
<span class="lineno">  971 </span>-- terms.
<span class="lineno">  972 </span>--
<span class="lineno">  973 </span>-- &gt; divNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno">  974 </span>scDivNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  975 </span><span class="decl"><span class="nottickedoff">scDivNat sc x y = scGlobalApply sc &quot;Prelude.divNat&quot; [x,y]</span></span>
<span class="lineno">  976 </span>
<span class="lineno">  977 </span>-- | Create a term computing the remainder upon division of the two given
<span class="lineno">  978 </span>-- (natural number) terms.
<span class="lineno">  979 </span>--
<span class="lineno">  980 </span>-- &gt; modNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno">  981 </span>scModNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  982 </span><span class="decl"><span class="nottickedoff">scModNat sc x y = scGlobalApply sc &quot;Prelude.modNat&quot; [x,y]</span></span>
<span class="lineno">  983 </span>
<span class="lineno">  984 </span>-- | Create a term computing the quotient and remainder upon division of the
<span class="lineno">  985 </span>-- two given (natural number) terms, giving the result as a pair.
<span class="lineno">  986 </span>--
<span class="lineno">  987 </span>-- &gt; divModNat : Nat -&gt; Nat -&gt; Nat * Nat;
<span class="lineno">  988 </span>scDivModNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  989 </span><span class="decl"><span class="nottickedoff">scDivModNat sc x y = scGlobalApply sc &quot;Prelude.divModNat&quot; [x,y]</span></span>
<span class="lineno">  990 </span>
<span class="lineno">  991 </span>-- | Create a term computing whether the two given (natural number) terms are
<span class="lineno">  992 </span>-- equal.
<span class="lineno">  993 </span>--
<span class="lineno">  994 </span>-- &gt; equalNat : Nat -&gt; Nat -&gt; Bool;
<span class="lineno">  995 </span>scEqualNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  996 </span><span class="decl"><span class="nottickedoff">scEqualNat sc x y = scGlobalApply sc &quot;Prelude.equalNat&quot; [x,y]</span></span>
<span class="lineno">  997 </span>
<span class="lineno">  998 </span>-- | Create a term computing whether the first term (a natural number) is less
<span class="lineno">  999 </span>-- than the second term (also a natural number).
<span class="lineno"> 1000 </span>--
<span class="lineno"> 1001 </span>-- &gt; ltNat : Nat -&gt; Nat -&gt; Bool;
<span class="lineno"> 1002 </span>scLtNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1003 </span><span class="decl"><span class="nottickedoff">scLtNat sc x y = scGlobalApply sc &quot;Prelude.ltNat&quot; [x,y]</span></span>
<span class="lineno"> 1004 </span>
<span class="lineno"> 1005 </span>-- | Create a term computing the minimum of the two given (natural number)
<span class="lineno"> 1006 </span>-- terms.
<span class="lineno"> 1007 </span>--
<span class="lineno"> 1008 </span>-- &gt; minNat : Nat -&gt; Nat -&gt; Nat
<span class="lineno"> 1009 </span>scMinNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1010 </span><span class="decl"><span class="nottickedoff">scMinNat sc x y = scGlobalApply sc &quot;Prelude.minNat&quot; [x,y]</span></span>
<span class="lineno"> 1011 </span>
<span class="lineno"> 1012 </span>-- | Create a term computing the maximum of the two given (natural number)
<span class="lineno"> 1013 </span>-- terms.
<span class="lineno"> 1014 </span>--
<span class="lineno"> 1015 </span>-- &gt; maxNat : Nat -&gt; Nat -&gt; Nat;
<span class="lineno"> 1016 </span>scMaxNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1017 </span><span class="decl"><span class="nottickedoff">scMaxNat sc x y = scGlobalApply sc &quot;Prelude.maxNat&quot; [x,y]</span></span>
<span class="lineno"> 1018 </span>
<span class="lineno"> 1019 </span>-- Primitive operations on Integer
<span class="lineno"> 1020 </span>
<span class="lineno"> 1021 </span>-- | Create a term representing the prelude Integer type.
<span class="lineno"> 1022 </span>scIntegerType :: SharedContext -&gt; IO Term
<span class="lineno"> 1023 </span><span class="decl"><span class="istickedoff">scIntegerType sc = scGlobalDef sc preludeIntegerIdent</span></span>
<span class="lineno"> 1024 </span>
<span class="lineno"> 1025 </span>-- | Create an integer constant term from an 'Integer'.
<span class="lineno"> 1026 </span>scIntegerConst :: SharedContext -&gt; Integer -&gt; IO Term
<span class="lineno"> 1027 </span><span class="decl"><span class="nottickedoff">scIntegerConst sc i</span>
<span class="lineno"> 1028 </span><span class="spaces">  </span><span class="nottickedoff">| i &gt;= 0    = scNatToInt sc =&lt;&lt; scNat sc (fromInteger i)</span>
<span class="lineno"> 1029 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = scIntNeg sc =&lt;&lt; scNatToInt sc =&lt;&lt; scNat sc (fromInteger (- i))</span></span>
<span class="lineno"> 1030 </span>
<span class="lineno"> 1031 </span>-- | Create a term applying the integer addition primitive.
<span class="lineno"> 1032 </span>--
<span class="lineno"> 1033 </span>-- &gt; intAdd : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1034 </span>scIntAdd :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1035 </span><span class="decl"><span class="nottickedoff">scIntAdd sc x y = scGlobalApply sc &quot;Prelude.intAdd&quot; [x, y]</span></span>
<span class="lineno"> 1036 </span>
<span class="lineno"> 1037 </span>-- | Create a term applying the integer subtraction primitive.
<span class="lineno"> 1038 </span>--
<span class="lineno"> 1039 </span>-- &gt; intSub : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1040 </span>scIntSub :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1041 </span><span class="decl"><span class="nottickedoff">scIntSub sc x y = scGlobalApply sc &quot;Prelude.intSub&quot; [x, y]</span></span>
<span class="lineno"> 1042 </span>
<span class="lineno"> 1043 </span>-- | Create a term applying the integer multiplication primitive.
<span class="lineno"> 1044 </span>--
<span class="lineno"> 1045 </span>-- &gt; intMul : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1046 </span>scIntMul :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1047 </span><span class="decl"><span class="nottickedoff">scIntMul sc x y = scGlobalApply sc &quot;Prelude.intMul&quot; [x, y]</span></span>
<span class="lineno"> 1048 </span>
<span class="lineno"> 1049 </span>-- | Create a term applying the integer division primitive.
<span class="lineno"> 1050 </span>--
<span class="lineno"> 1051 </span>-- &gt; intDiv : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1052 </span>scIntDiv :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1053 </span><span class="decl"><span class="nottickedoff">scIntDiv sc x y = scGlobalApply sc &quot;Prelude.intDiv&quot; [x, y]</span></span>
<span class="lineno"> 1054 </span>
<span class="lineno"> 1055 </span>-- | Create a term applying the integer modulus primitive.
<span class="lineno"> 1056 </span>--
<span class="lineno"> 1057 </span>-- &gt; intMod : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1058 </span>scIntMod :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1059 </span><span class="decl"><span class="nottickedoff">scIntMod sc x y = scGlobalApply sc &quot;Prelude.intMod&quot; [x, y]</span></span>
<span class="lineno"> 1060 </span>
<span class="lineno"> 1061 </span>-- | Create a term applying the integer min primitive.
<span class="lineno"> 1062 </span>--
<span class="lineno"> 1063 </span>-- &gt; intMin : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1064 </span>scIntMin :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1065 </span><span class="decl"><span class="nottickedoff">scIntMin sc x y = scGlobalApply sc &quot;Prelude.intMin&quot; [x, y]</span></span>
<span class="lineno"> 1066 </span>
<span class="lineno"> 1067 </span>-- | Create a term applying the integer max primitive.
<span class="lineno"> 1068 </span>--
<span class="lineno"> 1069 </span>-- &gt; intMax : Integer -&gt; Integer -&gt; Integer
<span class="lineno"> 1070 </span>scIntMax :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1071 </span><span class="decl"><span class="nottickedoff">scIntMax sc x y = scGlobalApply sc &quot;Prelude.intMax&quot; [x, y]</span></span>
<span class="lineno"> 1072 </span>
<span class="lineno"> 1073 </span>-- | Create a term applying the negation integer primitive.
<span class="lineno"> 1074 </span>--
<span class="lineno"> 1075 </span>-- &gt; intNeg : Integer -&gt; Integer;
<span class="lineno"> 1076 </span>scIntNeg :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1077 </span><span class="decl"><span class="istickedoff">scIntNeg sc x = scGlobalApply sc &quot;Prelude.intNeg&quot; [x]</span></span>
<span class="lineno"> 1078 </span>
<span class="lineno"> 1079 </span>-- | Create a term applying the absolute value integer primitive.
<span class="lineno"> 1080 </span>--
<span class="lineno"> 1081 </span>-- &gt; intAbs : Integer -&gt; Integer;
<span class="lineno"> 1082 </span>scIntAbs :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1083 </span><span class="decl"><span class="nottickedoff">scIntAbs sc x = scGlobalApply sc &quot;Prelude.intAbs&quot; [x]</span></span>
<span class="lineno"> 1084 </span>
<span class="lineno"> 1085 </span>-- | Create a term applying the integer equality testing primitive.
<span class="lineno"> 1086 </span>--
<span class="lineno"> 1087 </span>-- &gt; intEq : Integer -&gt; Integer -&gt; Bool;
<span class="lineno"> 1088 </span>scIntEq :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1089 </span><span class="decl"><span class="istickedoff">scIntEq sc x y = scGlobalApply sc &quot;Prelude.intEq&quot; [x, y]</span></span>
<span class="lineno"> 1090 </span>
<span class="lineno"> 1091 </span>-- | Create a term applying the integer less-than-or-equal primitive.
<span class="lineno"> 1092 </span>--
<span class="lineno"> 1093 </span>-- &gt; intLe : Integer -&gt; Integer -&gt; Bool;
<span class="lineno"> 1094 </span>scIntLe :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1095 </span><span class="decl"><span class="nottickedoff">scIntLe sc x y = scGlobalApply sc &quot;Prelude.intLe&quot; [x, y]</span></span>
<span class="lineno"> 1096 </span>
<span class="lineno"> 1097 </span>-- | Create a term applying the integer less-than primitive.
<span class="lineno"> 1098 </span>--
<span class="lineno"> 1099 </span>-- &gt; intLt : Integer -&gt; Integer -&gt; Bool;
<span class="lineno"> 1100 </span>scIntLt :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1101 </span><span class="decl"><span class="nottickedoff">scIntLt sc x y = scGlobalApply sc &quot;Prelude.intLt&quot; [x, y]</span></span>
<span class="lineno"> 1102 </span>
<span class="lineno"> 1103 </span>-- | Create a term computing a @Nat@ from an @Integer@, if possible.
<span class="lineno"> 1104 </span>--
<span class="lineno"> 1105 </span>-- &gt; intToNat : Integer -&gt; Nat;
<span class="lineno"> 1106 </span>scIntToNat
<span class="lineno"> 1107 </span>   :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1108 </span><span class="decl"><span class="nottickedoff">scIntToNat sc x = scGlobalApply sc &quot;Prelude.intToNat&quot; [x]</span></span>
<span class="lineno"> 1109 </span>
<span class="lineno"> 1110 </span>-- | Create a term computing an @Integer@ from a @Nat@.
<span class="lineno"> 1111 </span>--
<span class="lineno"> 1112 </span>-- &gt; natToInt : Nat -&gt; Integer;
<span class="lineno"> 1113 </span>scNatToInt
<span class="lineno"> 1114 </span>   :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1115 </span><span class="decl"><span class="istickedoff">scNatToInt sc x = scGlobalApply sc &quot;Prelude.natToInt&quot; [x]</span></span>
<span class="lineno"> 1116 </span>
<span class="lineno"> 1117 </span>-- | Create a term computing a bitvector of length n from an @Integer@, if
<span class="lineno"> 1118 </span>-- possible.
<span class="lineno"> 1119 </span>--
<span class="lineno"> 1120 </span>-- &gt; intToBv : (n::Nat) -&gt; Integer -&gt; Vec n Bool;
<span class="lineno"> 1121 </span>scIntToBv
<span class="lineno"> 1122 </span>   :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1123 </span><span class="decl"><span class="nottickedoff">scIntToBv sc n x = scGlobalApply sc &quot;Prelude.intToBv&quot; [n,x]</span></span>
<span class="lineno"> 1124 </span>
<span class="lineno"> 1125 </span>-- | Create a term computing an @Integer@ from a bitvector of length n.
<span class="lineno"> 1126 </span>-- This produces the unsigned value of the bitvector.
<span class="lineno"> 1127 </span>--
<span class="lineno"> 1128 </span>-- &gt; bvToInt : (n : Nat) -&gt; Vec n Bool -&gt; Integer;
<span class="lineno"> 1129 </span>scBvToInt
<span class="lineno"> 1130 </span>   :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1131 </span><span class="decl"><span class="nottickedoff">scBvToInt sc n x = scGlobalApply sc &quot;Prelude.bvToInt&quot; [n,x]</span></span>
<span class="lineno"> 1132 </span>
<span class="lineno"> 1133 </span>-- | Create a term computing an @Integer@ from a bitvector of length n.
<span class="lineno"> 1134 </span>-- This produces the 2's complement signed value of the bitvector.
<span class="lineno"> 1135 </span>--
<span class="lineno"> 1136 </span>-- &gt; sbvToInt : (n : Nat) -&gt; Vec n Bool -&gt; Integer;
<span class="lineno"> 1137 </span>scSbvToInt
<span class="lineno"> 1138 </span>   :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1139 </span><span class="decl"><span class="nottickedoff">scSbvToInt sc n x = scGlobalApply sc &quot;Prelude.sbvToInt&quot; [n,x]</span></span>
<span class="lineno"> 1140 </span>
<span class="lineno"> 1141 </span>
<span class="lineno"> 1142 </span>-- Primitive operations on IntMod
<span class="lineno"> 1143 </span>
<span class="lineno"> 1144 </span>-- | Create a term representing the prelude @IntMod@ type.
<span class="lineno"> 1145 </span>--
<span class="lineno"> 1146 </span>-- &gt; IntMod : Nat -&gt; sort 0;
<span class="lineno"> 1147 </span>scIntModType :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1148 </span><span class="decl"><span class="nottickedoff">scIntModType sc n = scGlobalApply sc &quot;Prelude.IntMod&quot; [n]</span></span>
<span class="lineno"> 1149 </span>
<span class="lineno"> 1150 </span>-- | Convert an integer to an integer mod n.
<span class="lineno"> 1151 </span>--
<span class="lineno"> 1152 </span>-- &gt; toIntMod : (n : Nat) -&gt; Integer -&gt; IntMod n;
<span class="lineno"> 1153 </span>scToIntMod :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1154 </span><span class="decl"><span class="nottickedoff">scToIntMod sc n x = scGlobalApply sc &quot;Prelude.toIntMod&quot; [n, x]</span></span>
<span class="lineno"> 1155 </span>
<span class="lineno"> 1156 </span>-- | Convert an integer mod n to an integer.
<span class="lineno"> 1157 </span>--
<span class="lineno"> 1158 </span>-- &gt; fromIntMod : (n : Nat) -&gt; IntMod n -&gt; Integer;
<span class="lineno"> 1159 </span>scFromIntMod :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1160 </span><span class="decl"><span class="nottickedoff">scFromIntMod sc n x = scGlobalApply sc &quot;Prelude.fromIntMod&quot; [n, x]</span></span>
<span class="lineno"> 1161 </span>
<span class="lineno"> 1162 </span>-- | Equality test on the @IntMod@ type
<span class="lineno"> 1163 </span>--
<span class="lineno"> 1164 </span>-- &gt; intModEq  : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; Bool;
<span class="lineno"> 1165 </span>scIntModEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1166 </span><span class="decl"><span class="nottickedoff">scIntModEq sc n x y = scGlobalApply sc &quot;Prelude.intModEq&quot; [n,x,y]</span></span>
<span class="lineno"> 1167 </span>
<span class="lineno"> 1168 </span>-- | Addition of @IntMod@ values
<span class="lineno"> 1169 </span>--
<span class="lineno"> 1170 </span>-- &gt; intModAdd : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1171 </span>scIntModAdd :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1172 </span><span class="decl"><span class="nottickedoff">scIntModAdd sc n x y = scGlobalApply sc &quot;Prelude.intModAdd&quot; [n,x,y]</span></span>
<span class="lineno"> 1173 </span>
<span class="lineno"> 1174 </span>-- | Subtraction of @IntMod@ values
<span class="lineno"> 1175 </span>--
<span class="lineno"> 1176 </span>-- &gt; intModSub : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1177 </span>scIntModSub :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1178 </span><span class="decl"><span class="nottickedoff">scIntModSub sc n x y = scGlobalApply sc &quot;Prelude.intModSub&quot; [n,x,y]</span></span>
<span class="lineno"> 1179 </span>
<span class="lineno"> 1180 </span>-- | Multiplication of @IntMod@ values
<span class="lineno"> 1181 </span>--
<span class="lineno"> 1182 </span>-- &gt; intModMul : (n : Nat) -&gt; IntMod n -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1183 </span>scIntModMul :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1184 </span><span class="decl"><span class="nottickedoff">scIntModMul sc n x y = scGlobalApply sc &quot;Prelude.intModMul&quot; [n,x,y]</span></span>
<span class="lineno"> 1185 </span>
<span class="lineno"> 1186 </span>-- | Negation (additive inverse) of @IntMod@ values
<span class="lineno"> 1187 </span>--
<span class="lineno"> 1188 </span>-- &gt; intModNeg : (n : Nat) -&gt; IntMod n -&gt; IntMod n;
<span class="lineno"> 1189 </span>scIntModNeg :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1190 </span><span class="decl"><span class="nottickedoff">scIntModNeg sc n x = scGlobalApply sc &quot;Prelude.intModNeg&quot; [n,x]</span></span>
<span class="lineno"> 1191 </span>
<span class="lineno"> 1192 </span>
<span class="lineno"> 1193 </span>-- Primitive operations on bitvectors
<span class="lineno"> 1194 </span>
<span class="lineno"> 1195 </span>-- | Create a term computing the type of a length-n bitvector.
<span class="lineno"> 1196 </span>--
<span class="lineno"> 1197 </span>-- &gt; bitvector : (n : Nat) -&gt; sort 1
<span class="lineno"> 1198 </span>scBitvector :: SharedContext -&gt; Natural -&gt; IO Term
<span class="lineno"> 1199 </span><span class="decl"><span class="istickedoff">scBitvector sc size =</span>
<span class="lineno"> 1200 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- scNat sc size</span>
<span class="lineno"> 1201 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- scBoolType sc</span>
<span class="lineno"> 1202 </span><span class="spaces">     </span><span class="istickedoff">scVecType sc s t</span></span>
<span class="lineno"> 1203 </span>
<span class="lineno"> 1204 </span>-- | Create a term computing a bitvector of length x from a @Nat@, if possible.
<span class="lineno"> 1205 </span>--
<span class="lineno"> 1206 </span>-- &gt; bvNat : (n : Nat) -&gt; Nat -&gt; Vec n Bool;
<span class="lineno"> 1207 </span>scBvNat :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1208 </span><span class="decl"><span class="istickedoff">scBvNat sc x y = scGlobalApply sc &quot;Prelude.bvNat&quot; [x, y]</span></span>
<span class="lineno"> 1209 </span>
<span class="lineno"> 1210 </span>-- | Create a term computing a @Nat@ from a bitvector of length n.
<span class="lineno"> 1211 </span>--
<span class="lineno"> 1212 </span>-- &gt; bvToNat : (n : Nat) -&gt; Vec n Bool -&gt; Nat;
<span class="lineno"> 1213 </span>scBvToNat :: SharedContext -&gt; Natural -&gt; Term -&gt; IO Term
<span class="lineno"> 1214 </span><span class="decl"><span class="istickedoff">scBvToNat sc n x = do</span>
<span class="lineno"> 1215 </span><span class="spaces">    </span><span class="istickedoff">n' &lt;- scNat sc n</span>
<span class="lineno"> 1216 </span><span class="spaces">    </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.bvToNat&quot; [n',x]</span></span>
<span class="lineno"> 1217 </span>
<span class="lineno"> 1218 </span>-- | Create a @bvNat@ term computing a bitvector of the given length
<span class="lineno"> 1219 </span>-- representing the given 'Integer' value (if possible).
<span class="lineno"> 1220 </span>scBvConst :: SharedContext -&gt; Natural -&gt; Integer -&gt; IO Term
<span class="lineno"> 1221 </span><span class="decl"><span class="istickedoff">scBvConst sc w v = assert (w &lt;= fromIntegral (maxBound :: Int)) $ do</span>
<span class="lineno"> 1222 </span><span class="spaces">  </span><span class="istickedoff">x &lt;- scNat sc w</span>
<span class="lineno"> 1223 </span><span class="spaces">  </span><span class="istickedoff">y &lt;- scNat sc $ fromInteger $ v .&amp;. (1 `shiftL` fromIntegral w - 1)</span>
<span class="lineno"> 1224 </span><span class="spaces">  </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.bvNat&quot; [x, y]</span></span>
<span class="lineno"> 1225 </span>
<span class="lineno"> 1226 </span>-- | Create a vector literal term computing a bitvector of the given length
<span class="lineno"> 1227 </span>-- representing the given 'Integer' value (if possible).
<span class="lineno"> 1228 </span>scBvLit :: SharedContext -&gt; Natural -&gt; Integer -&gt; IO Term
<span class="lineno"> 1229 </span><span class="decl"><span class="nottickedoff">scBvLit sc w v = assert (w &lt;= fromIntegral (maxBound :: Int)) $ do</span>
<span class="lineno"> 1230 </span><span class="spaces">  </span><span class="nottickedoff">do bool_tp &lt;- scBoolType sc</span>
<span class="lineno"> 1231 </span><span class="spaces">     </span><span class="nottickedoff">bits &lt;- mapM (scBool sc . testBit v)</span>
<span class="lineno"> 1232 </span><span class="spaces">                  </span><span class="nottickedoff">[(fromIntegral w - 1), (fromIntegral w - 2) .. 0]</span>
<span class="lineno"> 1233 </span><span class="spaces">     </span><span class="nottickedoff">scVector sc bool_tp bits</span></span>
<span class="lineno"> 1234 </span>
<span class="lineno"> 1235 </span>-- | Create a term computing the bitvector of given length representing 0 if
<span class="lineno"> 1236 </span>-- the other given term evaluates to @False@ and representing 1 if the other
<span class="lineno"> 1237 </span>-- given term evaluates to @True@.
<span class="lineno"> 1238 </span>--
<span class="lineno"> 1239 </span>-- &gt; bvBool : (n : Nat) -&gt; Bool -&gt; Vec n Bool;
<span class="lineno"> 1240 </span>scBvBool :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1241 </span><span class="decl"><span class="nottickedoff">scBvBool sc n x = scGlobalApply sc &quot;Prelude.bvBool&quot; [n, x]</span></span>
<span class="lineno"> 1242 </span>
<span class="lineno"> 1243 </span>-- | Create a term returning true if and only if the given bitvector represents
<span class="lineno"> 1244 </span>-- a nonzero value.
<span class="lineno"> 1245 </span>--
<span class="lineno"> 1246 </span>-- &gt; bvNonzero : (n : Nat) -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1247 </span>scBvNonzero :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1248 </span><span class="decl"><span class="istickedoff">scBvNonzero sc n x = scGlobalApply sc &quot;Prelude.bvNonzero&quot; [n, x]</span></span>
<span class="lineno"> 1249 </span>
<span class="lineno"> 1250 </span>-- | Create a term computing the 2's complement negation of the given
<span class="lineno"> 1251 </span>-- bitvector.
<span class="lineno"> 1252 </span>-- &gt; bvNeg : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1253 </span>scBvNeg :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1254 </span><span class="decl"><span class="nottickedoff">scBvNeg sc n x = scGlobalApply sc &quot;Prelude.bvNeg&quot; [n, x]</span></span>
<span class="lineno"> 1255 </span>
<span class="lineno"> 1256 </span>-- | Create a term applying the bitvector addition primitive.
<span class="lineno"> 1257 </span>--
<span class="lineno"> 1258 </span>-- &gt; bvAdd : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1259 </span>scBvAdd :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1260 </span><span class="decl"><span class="istickedoff">scBvAdd sc n x y = scGlobalApply sc &quot;Prelude.bvAdd&quot; [n, x, y]</span></span>
<span class="lineno"> 1261 </span>
<span class="lineno"> 1262 </span>-- | Create a term applying the bitvector subtraction primitive.
<span class="lineno"> 1263 </span>--
<span class="lineno"> 1264 </span>-- &gt; bvSub : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1265 </span>scBvSub :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1266 </span><span class="decl"><span class="istickedoff">scBvSub sc n x y = scGlobalApply sc &quot;Prelude.bvSub&quot; [n, x, y]</span></span>
<span class="lineno"> 1267 </span>
<span class="lineno"> 1268 </span>-- | Create a term applying the bitvector multiplication primitive.
<span class="lineno"> 1269 </span>--
<span class="lineno"> 1270 </span>-- &gt; bvMul : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1271 </span>scBvMul :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1272 </span><span class="decl"><span class="istickedoff">scBvMul sc n x y = scGlobalApply sc &quot;Prelude.bvMul&quot; [n, x, y]</span></span>
<span class="lineno"> 1273 </span>
<span class="lineno"> 1274 </span>-- | Create a term applying the bitvector (unsigned) modulus primitive.
<span class="lineno"> 1275 </span>--
<span class="lineno"> 1276 </span>-- &gt; bvURem : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1277 </span>scBvURem :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1278 </span><span class="decl"><span class="istickedoff">scBvURem sc n x y = scGlobalApply sc &quot;Prelude.bvURem&quot; [n, x, y]</span></span>
<span class="lineno"> 1279 </span>
<span class="lineno"> 1280 </span>-- | Create a term applying the bitvector (unsigned) division primitive.
<span class="lineno"> 1281 </span>--
<span class="lineno"> 1282 </span>-- &gt; bvUDiv : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1283 </span>scBvUDiv :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1284 </span><span class="decl"><span class="istickedoff">scBvUDiv sc n x y = scGlobalApply sc &quot;Prelude.bvUDiv&quot; [n, x, y]</span></span>
<span class="lineno"> 1285 </span>
<span class="lineno"> 1286 </span>-- | Create a term applying the bitvector (signed) modulus primitive.
<span class="lineno"> 1287 </span>--
<span class="lineno"> 1288 </span>-- &gt; bvSRem : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1289 </span>scBvSRem :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1290 </span><span class="decl"><span class="istickedoff">scBvSRem sc n x y = scGlobalApply sc &quot;Prelude.bvSRem&quot; [n, x, y]</span></span>
<span class="lineno"> 1291 </span>
<span class="lineno"> 1292 </span>-- | Create a term applying the bitvector (signed) division primitive.
<span class="lineno"> 1293 </span>--
<span class="lineno"> 1294 </span>-- &gt; bvSDiv : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1295 </span>scBvSDiv :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1296 </span><span class="decl"><span class="nottickedoff">scBvSDiv sc n x y = scGlobalApply sc &quot;Prelude.bvSDiv&quot; [n, x, y]</span></span>
<span class="lineno"> 1297 </span>
<span class="lineno"> 1298 </span>-- | Create a term applying the lg2 bitvector primitive.
<span class="lineno"> 1299 </span>--
<span class="lineno"> 1300 </span>-- &gt; bvLg2 : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1301 </span>scBvLg2 :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1302 </span><span class="decl"><span class="nottickedoff">scBvLg2 sc n x = scGlobalApply sc &quot;Prelude.bvLg2&quot; [n, x]</span></span>
<span class="lineno"> 1303 </span>
<span class="lineno"> 1304 </span>-- | Create a term applying the population count bitvector primitive.
<span class="lineno"> 1305 </span>--
<span class="lineno"> 1306 </span>-- &gt; bvPopcount : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1307 </span>scBvPopcount :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1308 </span><span class="decl"><span class="istickedoff">scBvPopcount sc n x = scGlobalApply sc &quot;Prelude.bvPopcount&quot; [n, x]</span></span>
<span class="lineno"> 1309 </span>
<span class="lineno"> 1310 </span>-- | Create a term applying the leading zero counting bitvector primitive.
<span class="lineno"> 1311 </span>--
<span class="lineno"> 1312 </span>-- &gt; bvCountLeadingZeros : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1313 </span>scBvCountLeadingZeros :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1314 </span><span class="decl"><span class="istickedoff">scBvCountLeadingZeros sc n x = scGlobalApply sc &quot;Prelude.bvCountLeadingZeros&quot; [n, x]</span></span>
<span class="lineno"> 1315 </span>
<span class="lineno"> 1316 </span>-- | Create a term applying the trailing zero counting bitvector primitive.
<span class="lineno"> 1317 </span>--
<span class="lineno"> 1318 </span>-- &gt; bvCountTrailingZeros : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1319 </span>scBvCountTrailingZeros :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1320 </span><span class="decl"><span class="istickedoff">scBvCountTrailingZeros sc n x = scGlobalApply sc &quot;Prelude.bvCountTrailingZeros&quot; [n, x]</span></span>
<span class="lineno"> 1321 </span>
<span class="lineno"> 1322 </span>-- | Create a term applying the bit-wise and primitive.
<span class="lineno"> 1323 </span>--
<span class="lineno"> 1324 </span>-- &gt; bvAnd : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1325 </span>scBvAnd :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1326 </span><span class="decl"><span class="istickedoff">scBvAnd sc n x y = scGlobalApply sc &quot;Prelude.bvAnd&quot; [n, x, y]</span></span>
<span class="lineno"> 1327 </span>
<span class="lineno"> 1328 </span>-- | Create a term applying the bit-wise xor primitive.
<span class="lineno"> 1329 </span>--
<span class="lineno"> 1330 </span>-- &gt; bvXor : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1331 </span>scBvXor :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1332 </span><span class="decl"><span class="istickedoff">scBvXor sc n x y = scGlobalApply sc &quot;Prelude.bvXor&quot; [n, x, y]</span></span>
<span class="lineno"> 1333 </span>
<span class="lineno"> 1334 </span>-- | Create a term applying the bit-wise or primitive.
<span class="lineno"> 1335 </span>--
<span class="lineno"> 1336 </span>-- &gt; bvOr : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1337 </span>scBvOr :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1338 </span><span class="decl"><span class="istickedoff">scBvOr  sc n x y = scGlobalApply sc &quot;Prelude.bvOr&quot;  [n, x, y]</span></span>
<span class="lineno"> 1339 </span>
<span class="lineno"> 1340 </span>-- | Create a term applying the bit-wise negation primitive.
<span class="lineno"> 1341 </span>--
<span class="lineno"> 1342 </span>-- &gt; bvNot : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool;
<span class="lineno"> 1343 </span>scBvNot :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1344 </span><span class="decl"><span class="istickedoff">scBvNot sc n x = scGlobalApply sc &quot;Prelude.bvNot&quot; [n, x]</span></span>
<span class="lineno"> 1345 </span>
<span class="lineno"> 1346 </span>-- | Create a term computing whether the two given bitvectors (of equal length)
<span class="lineno"> 1347 </span>-- are equal.
<span class="lineno"> 1348 </span>--
<span class="lineno"> 1349 </span>-- &gt; bvEq : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1350 </span>scBvEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1351 </span><span class="decl"><span class="istickedoff">scBvEq  sc n x y = scGlobalApply sc &quot;Prelude.bvEq&quot;  [n, x, y]</span></span>
<span class="lineno"> 1352 </span>
<span class="lineno"> 1353 </span>-- | Create a term applying the bitvector (unsigned) greater-than-or-equal
<span class="lineno"> 1354 </span>-- primitive.
<span class="lineno"> 1355 </span>--
<span class="lineno"> 1356 </span>-- &gt; bvuge : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1357 </span>scBvUGe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1358 </span><span class="decl"><span class="nottickedoff">scBvUGe sc n x y = scGlobalApply sc &quot;Prelude.bvuge&quot; [n, x, y]</span></span>
<span class="lineno"> 1359 </span>
<span class="lineno"> 1360 </span>-- | Create a term applying the bitvector (unsigned) less-than-or-equal
<span class="lineno"> 1361 </span>-- primitive.
<span class="lineno"> 1362 </span>--
<span class="lineno"> 1363 </span>-- &gt; bvule : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1364 </span>scBvULe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1365 </span><span class="decl"><span class="istickedoff">scBvULe sc n x y = scGlobalApply sc &quot;Prelude.bvule&quot; [n, x, y]</span></span>
<span class="lineno"> 1366 </span>
<span class="lineno"> 1367 </span>-- | Create a term applying the bitvector (unsigned) greater-than primitive.
<span class="lineno"> 1368 </span>--
<span class="lineno"> 1369 </span>-- &gt; bvugt : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1370 </span>scBvUGt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1371 </span><span class="decl"><span class="nottickedoff">scBvUGt sc n x y = scGlobalApply sc &quot;Prelude.bvugt&quot; [n, x, y]</span></span>
<span class="lineno"> 1372 </span>
<span class="lineno"> 1373 </span>-- | Create a term applying the bitvector (unsigned) less-than primitive.
<span class="lineno"> 1374 </span>--
<span class="lineno"> 1375 </span>-- &gt; bvult : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1376 </span>scBvULt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1377 </span><span class="decl"><span class="istickedoff">scBvULt sc n x y = scGlobalApply sc &quot;Prelude.bvult&quot; [n, x, y]</span></span>
<span class="lineno"> 1378 </span>
<span class="lineno"> 1379 </span>-- | Create a term applying the bitvector (signed) greater-than-or-equal
<span class="lineno"> 1380 </span>-- primitive.
<span class="lineno"> 1381 </span>--
<span class="lineno"> 1382 </span>-- &gt; bvsge : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1383 </span>scBvSGe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1384 </span><span class="decl"><span class="nottickedoff">scBvSGe sc n x y = scGlobalApply sc &quot;Prelude.bvsge&quot; [n, x, y]</span></span>
<span class="lineno"> 1385 </span>
<span class="lineno"> 1386 </span>-- | Create a term applying the bitvector (signed) less-than-or-equal
<span class="lineno"> 1387 </span>-- primitive.
<span class="lineno"> 1388 </span>--
<span class="lineno"> 1389 </span>-- &gt; bvsle : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1390 </span>scBvSLe :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1391 </span><span class="decl"><span class="nottickedoff">scBvSLe sc n x y = scGlobalApply sc &quot;Prelude.bvsle&quot; [n, x, y]</span></span>
<span class="lineno"> 1392 </span>
<span class="lineno"> 1393 </span>-- | Create a term applying the bitvector (signed) greater-than primitive.
<span class="lineno"> 1394 </span>--
<span class="lineno"> 1395 </span>-- &gt; bvsgt : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1396 </span>scBvSGt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1397 </span><span class="decl"><span class="nottickedoff">scBvSGt sc n x y = scGlobalApply sc &quot;Prelude.bvsgt&quot; [n, x, y]</span></span>
<span class="lineno"> 1398 </span>
<span class="lineno"> 1399 </span>-- | Create a term applying the bitvector (signed) less-than primitive.
<span class="lineno"> 1400 </span>--
<span class="lineno"> 1401 </span>-- &gt; bvslt : (n : Nat) -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1402 </span>scBvSLt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1403 </span><span class="decl"><span class="istickedoff">scBvSLt sc n x y = scGlobalApply sc &quot;Prelude.bvslt&quot; [n, x, y]</span></span>
<span class="lineno"> 1404 </span>
<span class="lineno"> 1405 </span>-- | Create a term applying the left-shift primitive.
<span class="lineno"> 1406 </span>--
<span class="lineno"> 1407 </span>-- &gt; bvShl : (n : Nat) -&gt; Vec n Bool -&gt; Nat -&gt; Vec n Bool;
<span class="lineno"> 1408 </span>scBvShl :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1409 </span><span class="decl"><span class="istickedoff">scBvShl sc n x y = scGlobalApply sc &quot;Prelude.bvShl&quot; [n, x, y]</span></span>
<span class="lineno"> 1410 </span>
<span class="lineno"> 1411 </span>-- | Create a term applying the logical right-shift primitive.
<span class="lineno"> 1412 </span>--
<span class="lineno"> 1413 </span>-- &gt; bvShr : (n : Nat) -&gt; Vec n Bool -&gt; Nat -&gt; Vec n Bool;
<span class="lineno"> 1414 </span>scBvShr :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1415 </span><span class="decl"><span class="istickedoff">scBvShr sc n x y = scGlobalApply sc &quot;Prelude.bvShr&quot; [n, x, y]</span></span>
<span class="lineno"> 1416 </span>
<span class="lineno"> 1417 </span>-- | Create a term applying the arithmetic/signed right-shift primitive.
<span class="lineno"> 1418 </span>--
<span class="lineno"> 1419 </span>-- &gt; bvSShr : (w : Nat) -&gt; Vec (Succ w) Bool -&gt; Nat -&gt; Vec (Succ w) Bool;
<span class="lineno"> 1420 </span>scBvSShr :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1421 </span><span class="decl"><span class="istickedoff">scBvSShr sc n x y = scGlobalApply sc &quot;Prelude.bvSShr&quot; [n, x, y]</span></span>
<span class="lineno"> 1422 </span>
<span class="lineno"> 1423 </span>-- | Create a term applying the unsigned bitvector extension primitive.
<span class="lineno"> 1424 </span>--
<span class="lineno"> 1425 </span>-- &gt; bvUExt : (m n : Nat) -&gt; Vec n Bool -&gt; Vec (addNat m n) Bool;
<span class="lineno"> 1426 </span>scBvUExt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1427 </span><span class="decl"><span class="istickedoff">scBvUExt sc n m x = scGlobalApply sc &quot;Prelude.bvUExt&quot; [n,m,x]</span></span>
<span class="lineno"> 1428 </span>
<span class="lineno"> 1429 </span>-- | Create a term applying the signed bitvector extension primitive.
<span class="lineno"> 1430 </span>--
<span class="lineno"> 1431 </span>-- &gt; bvSExt : (m n : Nat) -&gt; Vec (Succ n) Bool -&gt; Vec (addNat m (Succ n)) Bool;
<span class="lineno"> 1432 </span>scBvSExt :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1433 </span><span class="decl"><span class="istickedoff">scBvSExt sc n m x = scGlobalApply sc &quot;Prelude.bvSExt&quot; [n,m,x]</span></span>
<span class="lineno"> 1434 </span>
<span class="lineno"> 1435 </span>-- | Create a term applying the bitvector truncation primitive. Note that this
<span class="lineno"> 1436 </span>-- truncates starting from the most significant bit.
<span class="lineno"> 1437 </span>--
<span class="lineno"> 1438 </span>-- &gt; bvTrunc : (m n : Nat) -&gt; Vec (addNat m n) Bool -&gt; Vec n Bool;
<span class="lineno"> 1439 </span>scBvTrunc :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1440 </span><span class="decl"><span class="nottickedoff">scBvTrunc sc n m x = scGlobalApply sc &quot;Prelude.bvTrunc&quot; [n,m,x]</span></span>
<span class="lineno"> 1441 </span>
<span class="lineno"> 1442 </span>-- | Create a term applying the @updNatFun@ primitive, which satisfies the
<span class="lineno"> 1443 </span>-- following laws:
<span class="lineno"> 1444 </span>--
<span class="lineno"> 1445 </span>-- &gt; updNatFun : (a : sort 0) -&gt; (Nat -&gt; a) -&gt; Nat -&gt; a -&gt; (Nat -&gt; a);
<span class="lineno"> 1446 </span>-- &gt; updNatFun a _ i v i == v
<span class="lineno"> 1447 </span>-- &gt; updNatFun a f i v x == f x, when i != x
<span class="lineno"> 1448 </span>scUpdNatFun :: SharedContext -&gt; Term -&gt; Term
<span class="lineno"> 1449 </span>            -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1450 </span><span class="decl"><span class="nottickedoff">scUpdNatFun sc a f i v = scGlobalApply sc &quot;Prelude.updNatFun&quot; [a, f, i, v]</span></span>
<span class="lineno"> 1451 </span>
<span class="lineno"> 1452 </span>-- | Create a term applying the @updBvFun@ primitive, which has the same
<span class="lineno"> 1453 </span>-- behavior as @updNatFun@ but acts on bitvectors.
<span class="lineno"> 1454 </span>--
<span class="lineno"> 1455 </span>-- &gt; updBvFun : (n : Nat) -&gt; (a : sort 0) -&gt; (Vec n Bool -&gt; a) -&gt; Vec n Bool -&gt; a -&gt; (Vec n Bool -&gt; a);
<span class="lineno"> 1456 </span>scUpdBvFun :: SharedContext -&gt; Term -&gt; Term
<span class="lineno"> 1457 </span>           -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1458 </span><span class="decl"><span class="nottickedoff">scUpdBvFun sc n a f i v = scGlobalApply sc &quot;Prelude.updBvFun&quot; [n, a, f, i, v]</span></span>
<span class="lineno"> 1459 </span>
<span class="lineno"> 1460 </span>-- | Create a term representing the type of arrays, given an index type and
<span class="lineno"> 1461 </span>-- element type (as 'Term's).
<span class="lineno"> 1462 </span>--
<span class="lineno"> 1463 </span>-- &gt; Array : sort 0 -&gt; sort 0 -&gt; sort 0
<span class="lineno"> 1464 </span>scArrayType :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1465 </span><span class="decl"><span class="istickedoff">scArrayType sc a b = scGlobalApply sc &quot;Prelude.Array&quot; [a, b]</span></span>
<span class="lineno"> 1466 </span>
<span class="lineno"> 1467 </span>-- | Create a term computing a constant array, given an index type, element type,
<span class="lineno"> 1468 </span>-- and element (all as 'Term's).
<span class="lineno"> 1469 </span>--
<span class="lineno"> 1470 </span>-- &gt; arrayConstant : (a b : sort 0) -&gt; b -&gt; (Array a b);
<span class="lineno"> 1471 </span>scArrayConstant :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1472 </span><span class="decl"><span class="istickedoff">scArrayConstant sc a b e = scGlobalApply sc &quot;Prelude.arrayConstant&quot; [a, b, e]</span></span>
<span class="lineno"> 1473 </span>
<span class="lineno"> 1474 </span>-- | Create a term computing the value at a particular index of an array.
<span class="lineno"> 1475 </span>--
<span class="lineno"> 1476 </span>-- &gt; arrayLookup : (a b : sort 0) -&gt; (Array a b) -&gt; a -&gt; b;
<span class="lineno"> 1477 </span>scArrayLookup :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1478 </span><span class="decl"><span class="istickedoff">scArrayLookup sc a b f i = scGlobalApply sc &quot;Prelude.arrayLookup&quot; [a, b, f, i]</span></span>
<span class="lineno"> 1479 </span>
<span class="lineno"> 1480 </span>-- | Create a term computing an array updated at a particular index.
<span class="lineno"> 1481 </span>--
<span class="lineno"> 1482 </span>-- &gt; arrayUpdate : (a b : sort 0) -&gt; (Array a b) -&gt; a -&gt; b -&gt; (Array a b);
<span class="lineno"> 1483 </span>scArrayUpdate :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1484 </span><span class="decl"><span class="istickedoff">scArrayUpdate sc a b f i e = scGlobalApply sc &quot;Prelude.arrayUpdate&quot; [a, b, f, i, e]</span></span>
<span class="lineno"> 1485 </span>
<span class="lineno"> 1486 </span>-- | Create a term computing the equality of two arrays.
<span class="lineno"> 1487 </span>--
<span class="lineno"> 1488 </span>-- &gt; arrayEq : (a b : sort 0) -&gt; (Array a b) -&gt; (Array a b) -&gt; Bool;
<span class="lineno"> 1489 </span>scArrayEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1490 </span><span class="decl"><span class="nottickedoff">scArrayEq sc a b x y = scGlobalApply sc &quot;Prelude.arrayEq&quot; [a, b, x, y]</span></span>
<span class="lineno"> 1491 </span>
<span class="lineno"> 1492 </span>-- &gt; arrayCopy : (n : Nat) -&gt; (a : sort 0) -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Array (Vec n Bool) a;
<span class="lineno"> 1493 </span>-- &gt; arrayCopy n a dest_arr dest_idx src_arr src_idx len
<span class="lineno"> 1494 </span>scArrayCopy :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1495 </span><span class="decl"><span class="nottickedoff">scArrayCopy sc n a f i g j l = scGlobalApply sc &quot;Prelude.arrayCopy&quot; [n, a, f, i, g, j, l]</span></span>
<span class="lineno"> 1496 </span>
<span class="lineno"> 1497 </span>-- &gt; arraySet : (n : Nat) -&gt; (a : sort 0) -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; a -&gt; Vec n Bool -&gt; Array (Vec n Bool) a;
<span class="lineno"> 1498 </span>-- &gt; arraySet n a arr idx val len
<span class="lineno"> 1499 </span>scArraySet :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1500 </span><span class="decl"><span class="nottickedoff">scArraySet sc n a f i e l = scGlobalApply sc &quot;Prelude.arraySet&quot; [n, a, f, i, e, l]</span></span>
<span class="lineno"> 1501 </span>
<span class="lineno"> 1502 </span>-- &gt; arrayRangeEq : (n : Nat) -&gt; (a : sort 0) -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Array (Vec n Bool) a -&gt; Vec n Bool -&gt; Vec n Bool -&gt; Bool;
<span class="lineno"> 1503 </span>-- &gt; arrayRangeEq n a lhs_arr lhs_idx rhs_arr rhs_idx len
<span class="lineno"> 1504 </span>scArrayRangeEq :: SharedContext -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1505 </span><span class="decl"><span class="nottickedoff">scArrayRangeEq sc n a f i g j l = scGlobalApply sc &quot;Prelude.arrayRangeEq&quot; [n, a, f, i, g, j, l]</span></span>
<span class="lineno"> 1506 </span>
<span class="lineno"> 1507 </span>------------------------------------------------------------
<span class="lineno"> 1508 </span>
<span class="lineno"> 1509 </span>useChangeCache :: C m =&gt; Cache m k (Change v) -&gt; k -&gt; ChangeT m v -&gt; ChangeT m v
<span class="lineno"> 1510 </span><span class="decl"><span class="istickedoff">useChangeCache c k a = ChangeT $ useCache c k (runChangeT a)</span></span>
<span class="lineno"> 1511 </span>
<span class="lineno"> 1512 </span>-- | Performs an action when a value has been modified, and otherwise
<span class="lineno"> 1513 </span>-- returns a pure value.
<span class="lineno"> 1514 </span>whenModified :: (Functor m, Monad m) =&gt; b -&gt; (a -&gt; m b) -&gt; ChangeT m a -&gt; ChangeT m b
<span class="lineno"> 1515 </span><span class="decl"><span class="istickedoff">whenModified b f m = ChangeT $ do</span>
<span class="lineno"> 1516 </span><span class="spaces">  </span><span class="istickedoff">ca &lt;- runChangeT m</span>
<span class="lineno"> 1517 </span><span class="spaces">  </span><span class="istickedoff">case ca of</span>
<span class="lineno"> 1518 </span><span class="spaces">    </span><span class="istickedoff">Original{} -&gt; return (Original b)</span>
<span class="lineno"> 1519 </span><span class="spaces">    </span><span class="istickedoff">Modified a -&gt; Modified &lt;$&gt; f a</span></span>
<span class="lineno"> 1520 </span>
<span class="lineno"> 1521 </span>-- | Can this term be evaluated to a constant?
<span class="lineno"> 1522 </span>-- The parameter is a set of names which should be considered opaque---if
<span class="lineno"> 1523 </span>-- we encounter any of these then the term is not considered to evaluate to
<span class="lineno"> 1524 </span>-- a constant.
<span class="lineno"> 1525 </span>isConstFoldTerm :: SharedContext -&gt; Set VarIndex -&gt; Term -&gt; IO Bool
<span class="lineno"> 1526 </span><span class="decl"><span class="istickedoff">isConstFoldTerm sc unint t</span>
<span class="lineno"> 1527 </span><span class="spaces">  </span><span class="istickedoff">| closedTerm t =</span>
<span class="lineno"> 1528 </span><span class="spaces">    </span><span class="istickedoff">do</span>
<span class="lineno"> 1529 </span><span class="spaces">      </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1530 </span><span class="spaces">      </span><span class="istickedoff">let ?mmap = mm</span>
<span class="lineno"> 1531 </span><span class="spaces">      </span><span class="istickedoff">pure (isJust (go mempty t))</span>
<span class="lineno"> 1532 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = pure False</span>
<span class="lineno"> 1533 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno"> 1534 </span><span class="spaces">    </span><span class="istickedoff">go !vis term</span>
<span class="lineno"> 1535 </span><span class="spaces">      </span><span class="istickedoff">| IntSet.member (termIndex term) vis = Just vis</span>
<span class="lineno"> 1536 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goF (IntSet.insert (termIndex term) vis) (unwrapTermF term)</span>
<span class="lineno"> 1537 </span><span class="spaces">    </span><span class="istickedoff">goF vis tf =</span>
<span class="lineno"> 1538 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno"> 1539 </span><span class="spaces">        </span><span class="istickedoff">Constant c</span>
<span class="lineno"> 1540 </span><span class="spaces">          </span><span class="istickedoff">| nameIndex c `Set.member` unint -&gt; Nothing</span>
<span class="lineno"> 1541 </span><span class="spaces">          </span><span class="istickedoff">| Just (ResolvedDef d) &lt;- lookupVarIndexInMap (nameIndex c) ?mmap</span>
<span class="lineno"> 1542 </span><span class="spaces">          </span><span class="istickedoff">, Just t1 &lt;- defBody d -&gt; go vis t1</span>
<span class="lineno"> 1543 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; Just vis</span>
<span class="lineno"> 1544 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; foldM go vis tf</span></span>
<span class="lineno"> 1545 </span>
<span class="lineno"> 1546 </span>-- | Return a list of all free variables in the given term along with
<span class="lineno"> 1547 </span>-- their types, sorted by index.
<span class="lineno"> 1548 </span>getAllVars :: Term -&gt; [(VarName, Term)]
<span class="lineno"> 1549 </span><span class="decl"><span class="istickedoff">getAllVars t = Map.toList (getAllVarsMap t)</span></span>
<span class="lineno"> 1550 </span>
<span class="lineno"> 1551 </span>-- | Return a map of all free variables in the given term with their
<span class="lineno"> 1552 </span>-- types.
<span class="lineno"> 1553 </span>getAllVarsMap :: Term -&gt; Map VarName Term
<span class="lineno"> 1554 </span><span class="decl"><span class="istickedoff">getAllVarsMap t0 = State.evalState (go t0) IntMap.empty</span>
<span class="lineno"> 1555 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1556 </span><span class="spaces">    </span><span class="istickedoff">go :: Term -&gt; State.State (IntMap (Map VarName Term)) (Map VarName Term)</span>
<span class="lineno"> 1557 </span><span class="spaces">    </span><span class="istickedoff">go t</span>
<span class="lineno"> 1558 </span><span class="spaces">      </span><span class="istickedoff">| closedTerm t = pure Map.empty</span>
<span class="lineno"> 1559 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1560 </span><span class="spaces">        </span><span class="istickedoff">do memo &lt;- State.get</span>
<span class="lineno"> 1561 </span><span class="spaces">           </span><span class="istickedoff">let i = termIndex t</span>
<span class="lineno"> 1562 </span><span class="spaces">           </span><span class="istickedoff">case IntMap.lookup i memo of</span>
<span class="lineno"> 1563 </span><span class="spaces">             </span><span class="istickedoff">Just vars -&gt; pure vars</span>
<span class="lineno"> 1564 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1565 </span><span class="spaces">               </span><span class="istickedoff">do vars &lt;- termf (unwrapTermF t)</span>
<span class="lineno"> 1566 </span><span class="spaces">                  </span><span class="istickedoff">State.modify' (IntMap.insert i vars)</span>
<span class="lineno"> 1567 </span><span class="spaces">                  </span><span class="istickedoff">pure vars</span>
<span class="lineno"> 1568 </span><span class="spaces">    </span><span class="istickedoff">termf :: TermF Term -&gt; State.State (IntMap (Map VarName Term)) (Map VarName Term)</span>
<span class="lineno"> 1569 </span><span class="spaces">    </span><span class="istickedoff">termf tf =</span>
<span class="lineno"> 1570 </span><span class="spaces">      </span><span class="istickedoff">case tf of</span>
<span class="lineno"> 1571 </span><span class="spaces">        </span><span class="istickedoff">Variable x tp -&gt; pure (Map.singleton x tp)</span>
<span class="lineno"> 1572 </span><span class="spaces">        </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 1573 </span><span class="spaces">          </span><span class="istickedoff">do vars1 &lt;- go t1</span>
<span class="lineno"> 1574 </span><span class="spaces">             </span><span class="istickedoff">vars2 &lt;- go t2</span>
<span class="lineno"> 1575 </span><span class="spaces">             </span><span class="istickedoff">pure (vars1 &lt;&gt; Map.delete x vars2)</span>
<span class="lineno"> 1576 </span><span class="spaces">        </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 1577 </span><span class="spaces">          </span><span class="istickedoff">do vars1 &lt;- go t1</span>
<span class="lineno"> 1578 </span><span class="spaces">             </span><span class="istickedoff">vars2 &lt;- go t2</span>
<span class="lineno"> 1579 </span><span class="spaces">             </span><span class="istickedoff">pure (vars1 &lt;&gt; Map.delete x vars2)</span>
<span class="lineno"> 1580 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; Fold.fold &lt;$&gt; traverse go tf</span></span>
<span class="lineno"> 1581 </span>
<span class="lineno"> 1582 </span>getConstantSet :: Term -&gt; Map VarIndex NameInfo
<span class="lineno"> 1583 </span><span class="decl"><span class="nottickedoff">getConstantSet t0 = snd $ go (IntSet.empty, Map.empty) t0</span>
<span class="lineno"> 1584 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1585 </span><span class="spaces">    </span><span class="nottickedoff">go acc@(idxs, names) t</span>
<span class="lineno"> 1586 </span><span class="spaces">      </span><span class="nottickedoff">| IntSet.member (termIndex t) idxs = acc</span>
<span class="lineno"> 1587 </span><span class="spaces">      </span><span class="nottickedoff">| otherwise = termf (IntSet.insert (termIndex t) idxs, names) (unwrapTermF t)</span>
<span class="lineno"> 1588 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1589 </span><span class="spaces">    </span><span class="nottickedoff">termf acc@(idxs, names) tf =</span>
<span class="lineno"> 1590 </span><span class="spaces">      </span><span class="nottickedoff">case tf of</span>
<span class="lineno"> 1591 </span><span class="spaces">        </span><span class="nottickedoff">Constant (Name vidx n) -&gt; (idxs, Map.insert vidx n names)</span>
<span class="lineno"> 1592 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; foldl' go acc tf</span></span>
<span class="lineno"> 1593 </span>
<span class="lineno"> 1594 </span>-- | Create a lambda term by abstracting over the list of arguments,
<span class="lineno"> 1595 </span>-- which must all be named variables (e.g. terms generated by
<span class="lineno"> 1596 </span>-- 'scVariable' or 'scFreshVariable').
<span class="lineno"> 1597 </span>scAbstractTerms :: SharedContext -&gt; [Term] -&gt; Term -&gt; IO Term
<span class="lineno"> 1598 </span><span class="decl"><span class="istickedoff">scAbstractTerms sc args body =</span>
<span class="lineno"> 1599 </span><span class="spaces">  </span><span class="istickedoff">do vars &lt;- mapM toVar args</span>
<span class="lineno"> 1600 </span><span class="spaces">     </span><span class="istickedoff">scLambdaList sc vars body</span>
<span class="lineno"> 1601 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1602 </span><span class="spaces">    </span><span class="istickedoff">toVar :: Term -&gt; IO (VarName, Term)</span>
<span class="lineno"> 1603 </span><span class="spaces">    </span><span class="istickedoff">toVar t =</span>
<span class="lineno"> 1604 </span><span class="spaces">      </span><span class="istickedoff">case asVariable t of</span>
<span class="lineno"> 1605 </span><span class="spaces">        </span><span class="istickedoff">Just var -&gt; pure var</span>
<span class="lineno"> 1606 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;scAbstractTerms: expected Variable&quot;</span></span></span>
<span class="lineno"> 1607 </span>
<span class="lineno"> 1608 </span>-- | Abstract over the given list of variables by wrapping the given
<span class="lineno"> 1609 </span>-- term with lambdas.
<span class="lineno"> 1610 </span>-- However, the term will be eta-collapsed as far as possible, so
<span class="lineno"> 1611 </span>-- unnecessary lambdas will simply be omitted.
<span class="lineno"> 1612 </span>scLambdaListEtaCollapse :: SharedContext -&gt; [(VarName, Term)] -&gt; Term -&gt; IO Term
<span class="lineno"> 1613 </span><span class="decl"><span class="nottickedoff">scLambdaListEtaCollapse sc = \vars tm -&gt; loop (reverse vars) tm</span>
<span class="lineno"> 1614 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1615 </span><span class="spaces">    </span><span class="nottickedoff">-- we eta-collapsed all the variables, nothing more to do</span>
<span class="lineno"> 1616 </span><span class="spaces">    </span><span class="nottickedoff">loop [] tm = pure tm</span>
<span class="lineno"> 1617 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1618 </span><span class="spaces">    </span><span class="nottickedoff">-- the final variable to abstract is applied to the</span>
<span class="lineno"> 1619 </span><span class="spaces">    </span><span class="nottickedoff">-- term, and does not appear elsewhere in the term,</span>
<span class="lineno"> 1620 </span><span class="spaces">    </span><span class="nottickedoff">-- so we can eta-collapse.</span>
<span class="lineno"> 1621 </span><span class="spaces">    </span><span class="nottickedoff">loop ((x, _) : vars) (asApp -&gt; Just (f, asVariable -&gt; Just (x', _)))</span>
<span class="lineno"> 1622 </span><span class="spaces">      </span><span class="nottickedoff">| x == x', IntSet.notMember (vnIndex x) (freeVars f)</span>
<span class="lineno"> 1623 </span><span class="spaces">      </span><span class="nottickedoff">= loop vars f</span>
<span class="lineno"> 1624 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="nottickedoff">-- cannot eta-collapse, do abstraction as usual</span>
<span class="lineno"> 1626 </span><span class="spaces">    </span><span class="nottickedoff">loop vars tm = scLambdaList sc (reverse vars) tm</span></span>
<span class="lineno"> 1627 </span>
<span class="lineno"> 1628 </span>
<span class="lineno"> 1629 </span>-- | Create a pi term by abstracting over the list of arguments, which
<span class="lineno"> 1630 </span>-- must all be named variables (e.g. terms generated by 'scVariable' or
<span class="lineno"> 1631 </span>-- 'scFreshVariable').
<span class="lineno"> 1632 </span>scGeneralizeTerms :: SharedContext -&gt; [Term] -&gt; Term -&gt; IO Term
<span class="lineno"> 1633 </span><span class="decl"><span class="istickedoff">scGeneralizeTerms sc args body =</span>
<span class="lineno"> 1634 </span><span class="spaces">  </span><span class="istickedoff">do vars &lt;- mapM toVar args</span>
<span class="lineno"> 1635 </span><span class="spaces">     </span><span class="istickedoff">scPiList sc vars body</span>
<span class="lineno"> 1636 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1637 </span><span class="spaces">    </span><span class="istickedoff">toVar :: Term -&gt; IO (VarName, Term)</span>
<span class="lineno"> 1638 </span><span class="spaces">    </span><span class="istickedoff">toVar t =</span>
<span class="lineno"> 1639 </span><span class="spaces">      </span><span class="istickedoff">case asVariable t of</span>
<span class="lineno"> 1640 </span><span class="spaces">        </span><span class="istickedoff">Just var -&gt; pure var</span>
<span class="lineno"> 1641 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;scGeneralizeTerms: expected Variable&quot;</span></span></span>
<span class="lineno"> 1642 </span>
<span class="lineno"> 1643 </span>-- | Unfold some of the defined constants within a 'Term'.
<span class="lineno"> 1644 </span>-- The supplied predicate specifies whether or not to unfold each
<span class="lineno"> 1645 </span>-- constant, based on its 'Name'.
<span class="lineno"> 1646 </span>scUnfoldConstants ::
<span class="lineno"> 1647 </span>  SharedContext -&gt;
<span class="lineno"> 1648 </span>  (Name -&gt; Bool) {- ^ whether to unfold a constant with this name -} -&gt;
<span class="lineno"> 1649 </span>  Term -&gt; IO Term
<span class="lineno"> 1650 </span><span class="decl"><span class="istickedoff">scUnfoldConstants sc unfold t0 =</span>
<span class="lineno"> 1651 </span><span class="spaces">  </span><span class="istickedoff">do tcache &lt;- newCacheMap' Map.empty</span>
<span class="lineno"> 1652 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1653 </span><span class="spaces">     </span><span class="istickedoff">let getRhs nm =</span>
<span class="lineno"> 1654 </span><span class="spaces">           </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 1655 </span><span class="spaces">             </span><span class="istickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno"> 1656 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 1657 </span><span class="spaces">     </span><span class="istickedoff">let go :: Term -&gt; ChangeT IO Term</span>
<span class="lineno"> 1658 </span><span class="spaces">         </span><span class="istickedoff">go t =</span>
<span class="lineno"> 1659 </span><span class="spaces">           </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1660 </span><span class="spaces">             </span><span class="istickedoff">Constant nm</span>
<span class="lineno"> 1661 </span><span class="spaces">               </span><span class="istickedoff">| unfold nm</span>
<span class="lineno"> 1662 </span><span class="spaces">               </span><span class="istickedoff">, Just rhs &lt;- getRhs nm -&gt; taint (go rhs)</span>
<span class="lineno"> 1663 </span><span class="spaces">               </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>             -&gt; pure t</span>
<span class="lineno"> 1664 </span><span class="spaces">             </span><span class="istickedoff">Variable x _</span>
<span class="lineno"> 1665 </span><span class="spaces">               </span><span class="istickedoff">| IntMap.member (vnIndex x) (varTypes t0) -&gt;</span>
<span class="lineno"> 1666 </span><span class="spaces">                 </span><span class="istickedoff">-- Avoid modifying types of free variables to preserve Term invariant</span>
<span class="lineno"> 1667 </span><span class="spaces">                 </span><span class="istickedoff">pure t</span>
<span class="lineno"> 1668 </span><span class="spaces">             </span><span class="istickedoff">tf -&gt;</span>
<span class="lineno"> 1669 </span><span class="spaces">               </span><span class="istickedoff">useChangeCache tcache (termIndex t) $</span>
<span class="lineno"> 1670 </span><span class="spaces">               </span><span class="istickedoff">whenModified t (scTermF sc) (traverse go tf)</span>
<span class="lineno"> 1671 </span><span class="spaces">     </span><span class="istickedoff">commitChangeT (go t0)</span></span>
<span class="lineno"> 1672 </span>
<span class="lineno"> 1673 </span>-- | Unfold some of the defined constants within a 'Term'.
<span class="lineno"> 1674 </span>-- The supplied predicate specifies whether or not to unfold each
<span class="lineno"> 1675 </span>-- constant, based on its 'Name'.
<span class="lineno"> 1676 </span>-- Reduce any beta redexes created by unfolding a constant definition
<span class="lineno"> 1677 </span>-- that is a lambda term.
<span class="lineno"> 1678 </span>scUnfoldConstantsBeta ::
<span class="lineno"> 1679 </span>  SharedContext -&gt;
<span class="lineno"> 1680 </span>  (Name -&gt; Bool) {- ^ whether to unfold a constant with this name -} -&gt;
<span class="lineno"> 1681 </span>  Term -&gt; IO Term
<span class="lineno"> 1682 </span><span class="decl"><span class="istickedoff">scUnfoldConstantsBeta sc unfold t0 =</span>
<span class="lineno"> 1683 </span><span class="spaces">  </span><span class="istickedoff">do tcache &lt;- newCacheMap' Map.empty</span>
<span class="lineno"> 1684 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1685 </span><span class="spaces">     </span><span class="istickedoff">let getRhs nm =</span>
<span class="lineno"> 1686 </span><span class="spaces">           </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 1687 </span><span class="spaces">             </span><span class="istickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno"> 1688 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 1689 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; ChangeT IO Term</span>
<span class="lineno"> 1690 </span><span class="spaces">         </span><span class="istickedoff">memo t = useChangeCache tcache (termIndex t) (go t)</span>
<span class="lineno"> 1691 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; ChangeT IO Term</span>
<span class="lineno"> 1692 </span><span class="spaces">         </span><span class="istickedoff">go (asApplyAll -&gt; (asConstant -&gt; Just nm, args))</span>
<span class="lineno"> 1693 </span><span class="spaces">           </span><span class="istickedoff">| unfold nm, Just rhs &lt;- getRhs nm =</span>
<span class="lineno"> 1694 </span><span class="spaces">               </span><span class="istickedoff">do args' &lt;- traverse memo args</span>
<span class="lineno"> 1695 </span><span class="spaces">                  </span><span class="istickedoff">taint $ lift $ scApplyAllBeta sc rhs args'</span>
<span class="lineno"> 1696 </span><span class="spaces">         </span><span class="istickedoff">go t@(asVariable -&gt; Just (x, _))</span>
<span class="lineno"> 1697 </span><span class="spaces">           </span><span class="istickedoff">| IntMap.member (vnIndex x) (varTypes t0) =</span>
<span class="lineno"> 1698 </span><span class="spaces">               </span><span class="istickedoff">-- Avoid modifying types of free variables to preserve Term invariant</span>
<span class="lineno"> 1699 </span><span class="spaces">               </span><span class="istickedoff">pure <span class="nottickedoff">t</span></span>
<span class="lineno"> 1700 </span><span class="spaces">         </span><span class="istickedoff">go t = whenModified t (scTermF sc) (traverse memo (unwrapTermF t))</span>
<span class="lineno"> 1701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1702 </span><span class="spaces">     </span><span class="istickedoff">commitChangeT (memo t0)</span></span>
<span class="lineno"> 1703 </span>
<span class="lineno"> 1704 </span>-- | Unfold one time fixpoint constants.
<span class="lineno"> 1705 </span>--
<span class="lineno"> 1706 </span>-- Specifically, if @c = fix a f@, then replace @c@ with @f c@, that is replace
<span class="lineno"> 1707 </span>-- @(fix a f)@ with @f (fix a f)@ while preserving the constant name.  The
<span class="lineno"> 1708 </span>-- signature of @fix@ is @primitive fix : (a : sort 1) -&gt; (a -&gt; a) -&gt; a;@.
<span class="lineno"> 1709 </span>scUnfoldOnceFixConstantSet :: SharedContext
<span class="lineno"> 1710 </span>                           -&gt; Bool  -- ^ True: unfold constants in set. False: unfold constants NOT in set
<span class="lineno"> 1711 </span>                           -&gt; Set VarIndex -- ^ Set of constant names
<span class="lineno"> 1712 </span>                           -&gt; Term
<span class="lineno"> 1713 </span>                           -&gt; IO Term
<span class="lineno"> 1714 </span><span class="decl"><span class="istickedoff">scUnfoldOnceFixConstantSet sc b names t0 = do</span>
<span class="lineno"> 1715 </span><span class="spaces">  </span><span class="istickedoff">cache &lt;- newCache</span>
<span class="lineno"> 1716 </span><span class="spaces">  </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1717 </span><span class="spaces">  </span><span class="istickedoff">let getRhs v =</span>
<span class="lineno"> 1718 </span><span class="spaces">        </span><span class="istickedoff">case lookupVarIndexInMap v mm of</span>
<span class="lineno"> 1719 </span><span class="spaces">          </span><span class="istickedoff">Just (ResolvedDef d) -&gt; defBody d</span>
<span class="lineno"> 1720 </span><span class="spaces">          </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno"> 1721 </span><span class="spaces">  </span><span class="istickedoff">let unfold t idx rhs</span>
<span class="lineno"> 1722 </span><span class="spaces">        </span><span class="istickedoff">| Set.member idx names == b</span>
<span class="lineno"> 1723 </span><span class="spaces">        </span><span class="istickedoff">, (isGlobalDef &quot;Prelude.fix&quot; -&gt; Just (), [_, f]) &lt;- asApplyAll rhs =</span>
<span class="lineno"> 1724 </span><span class="spaces">          </span><span class="istickedoff">betaNormalize sc =&lt;&lt; scApply sc f t</span>
<span class="lineno"> 1725 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1726 </span><span class="spaces">          </span><span class="istickedoff">return t</span>
<span class="lineno"> 1727 </span><span class="spaces">  </span><span class="istickedoff">let go :: Term -&gt; IO Term</span>
<span class="lineno"> 1728 </span><span class="spaces">      </span><span class="istickedoff">go t = useCache cache (termIndex t) $</span>
<span class="lineno"> 1729 </span><span class="spaces">        </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1730 </span><span class="spaces">          </span><span class="istickedoff">Constant (Name nmidx _) | Just rhs &lt;- getRhs nmidx -&gt; unfold t nmidx rhs</span>
<span class="lineno"> 1731 </span><span class="spaces">          </span><span class="istickedoff">tf -&gt; scTermF sc =&lt;&lt; traverse go tf</span>
<span class="lineno"> 1732 </span><span class="spaces">  </span><span class="istickedoff">go t0</span></span>
<span class="lineno"> 1733 </span>
<span class="lineno"> 1734 </span>-- | Return the number of DAG nodes used by the given @Term@.
<span class="lineno"> 1735 </span>scSharedSize :: Term -&gt; Integer
<span class="lineno"> 1736 </span><span class="decl"><span class="istickedoff">scSharedSize = fst . scSharedSizeAux (0, Set.empty)</span></span>
<span class="lineno"> 1737 </span>
<span class="lineno"> 1738 </span>scSharedSizeMany :: [Term] -&gt; Integer
<span class="lineno"> 1739 </span><span class="decl"><span class="istickedoff">scSharedSizeMany = fst . foldl scSharedSizeAux (0, Set.empty)</span></span>
<span class="lineno"> 1740 </span>
<span class="lineno"> 1741 </span>scSharedSizeAux :: (Integer, Set TermIndex) -&gt; Term -&gt; (Integer, Set TermIndex)
<span class="lineno"> 1742 </span><span class="decl"><span class="istickedoff">scSharedSizeAux = go</span>
<span class="lineno"> 1743 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1744 </span><span class="spaces">    </span><span class="istickedoff">go (sz, seen) t</span>
<span class="lineno"> 1745 </span><span class="spaces">      </span><span class="istickedoff">| Set.member (termIndex t) seen = (sz, seen)</span>
<span class="lineno"> 1746 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = foldl' go (strictPair (sz + 1) (Set.insert (termIndex t) seen)) (unwrapTermF t)</span></span>
<span class="lineno"> 1747 </span>
<span class="lineno"> 1748 </span>strictPair :: a -&gt; b -&gt; (a, b)
<span class="lineno"> 1749 </span><span class="decl"><span class="istickedoff">strictPair x y = x `seq` y `seq` (x, y)</span></span>
<span class="lineno"> 1750 </span>
<span class="lineno"> 1751 </span>-- | Return the number of nodes that would be used by the given
<span class="lineno"> 1752 </span>-- @Term@ if it were represented as a tree instead of a DAG.
<span class="lineno"> 1753 </span>scTreeSize :: Term -&gt; Integer
<span class="lineno"> 1754 </span><span class="decl"><span class="nottickedoff">scTreeSize = fst . scTreeSizeAux (0, Map.empty)</span></span>
<span class="lineno"> 1755 </span>
<span class="lineno"> 1756 </span>scTreeSizeMany :: [Term] -&gt; Integer
<span class="lineno"> 1757 </span><span class="decl"><span class="nottickedoff">scTreeSizeMany = fst . foldl scTreeSizeAux (0, Map.empty)</span></span>
<span class="lineno"> 1758 </span>
<span class="lineno"> 1759 </span>scTreeSizeAux :: (Integer, Map TermIndex Integer) -&gt; Term -&gt; (Integer, Map TermIndex Integer)
<span class="lineno"> 1760 </span><span class="decl"><span class="nottickedoff">scTreeSizeAux = go</span>
<span class="lineno"> 1761 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 1762 </span><span class="spaces">    </span><span class="nottickedoff">go (sz, seen) t =</span>
<span class="lineno"> 1763 </span><span class="spaces">      </span><span class="nottickedoff">case Map.lookup (termIndex t) seen of</span>
<span class="lineno"> 1764 </span><span class="spaces">        </span><span class="nottickedoff">Just sz' -&gt; (sz + sz', seen)</span>
<span class="lineno"> 1765 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; (sz + sz', Map.insert (termIndex t) sz' seen')</span>
<span class="lineno"> 1766 </span><span class="spaces">          </span><span class="nottickedoff">where (sz', seen') = foldl' go (1, seen) (unwrapTermF t)</span></span>

</pre>
</body>
</html>
