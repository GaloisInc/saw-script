<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    2 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    3 </span>
<span class="lineno">    4 </span>{- |
<span class="lineno">    5 </span>Module      : SAWCore.Term.Certified
<span class="lineno">    6 </span>Copyright   : Galois, Inc. 2025
<span class="lineno">    7 </span>License     : BSD3
<span class="lineno">    8 </span>Maintainer  : huffman@galois.com
<span class="lineno">    9 </span>Stability   : experimental
<span class="lineno">   10 </span>Portability : non-portable (language extensions)
<span class="lineno">   11 </span>-}
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>module SAWCore.Term.Certified
<span class="lineno">   14 </span>  ( SharedContext -- abstract
<span class="lineno">   15 </span>  , Term -- abstract
<span class="lineno">   16 </span>  , TermIndex
<span class="lineno">   17 </span>  , unwrapTermF
<span class="lineno">   18 </span>  , termIndex
<span class="lineno">   19 </span>  , varTypes
<span class="lineno">   20 </span>  , freeVars
<span class="lineno">   21 </span>  , closedTerm
<span class="lineno">   22 </span>  , termSortOrType
<span class="lineno">   23 </span>  , alphaEquiv
<span class="lineno">   24 </span>    -- * Building certified terms
<span class="lineno">   25 </span>  , scAscribe
<span class="lineno">   26 </span>  , scTermF
<span class="lineno">   27 </span>  , scFlatTermF
<span class="lineno">   28 </span>  , scApply
<span class="lineno">   29 </span>  , scLambda
<span class="lineno">   30 </span>  , scLambdaList
<span class="lineno">   31 </span>  , scPi
<span class="lineno">   32 </span>  , scPiList
<span class="lineno">   33 </span>  , scFun
<span class="lineno">   34 </span>  , scFunAll
<span class="lineno">   35 </span>  , scConstant
<span class="lineno">   36 </span>  , scConst
<span class="lineno">   37 </span>  , scConstApply
<span class="lineno">   38 </span>  , scGlobal
<span class="lineno">   39 </span>  , scGlobalDef
<span class="lineno">   40 </span>  , scGlobalApply
<span class="lineno">   41 </span>  , scVariable
<span class="lineno">   42 </span>  , scVariables
<span class="lineno">   43 </span>  , scUnitValue
<span class="lineno">   44 </span>  , scUnitType
<span class="lineno">   45 </span>  , scPairValue
<span class="lineno">   46 </span>  , scPairType
<span class="lineno">   47 </span>  , scPairLeft
<span class="lineno">   48 </span>  , scPairRight
<span class="lineno">   49 </span>  , scRecursor
<span class="lineno">   50 </span>  , scRecordType
<span class="lineno">   51 </span>  , scRecordValue
<span class="lineno">   52 </span>  , scRecord
<span class="lineno">   53 </span>  , scRecordProj
<span class="lineno">   54 </span>  , scRecordSelect
<span class="lineno">   55 </span>  , scSort
<span class="lineno">   56 </span>  , scSortWithFlags
<span class="lineno">   57 </span>  , scNat
<span class="lineno">   58 </span>  , scVector
<span class="lineno">   59 </span>  , scString, scStringType
<span class="lineno">   60 </span>    -- * Typing and reduction
<span class="lineno">   61 </span>  , scTypeOf
<span class="lineno">   62 </span>  , scWhnf
<span class="lineno">   63 </span>  , scConvertibleEval
<span class="lineno">   64 </span>  , scConvertible
<span class="lineno">   65 </span>  , scSubtype
<span class="lineno">   66 </span>  , scInstantiate
<span class="lineno">   67 </span>  , scInstantiateBeta
<span class="lineno">   68 </span>  , scApplyAllBeta
<span class="lineno">   69 </span>  -- * SharedContext operations
<span class="lineno">   70 </span>  , mkSharedContext
<span class="lineno">   71 </span>  , scGetModuleMap
<span class="lineno">   72 </span>  , scGetNamingEnv
<span class="lineno">   73 </span>  , scRegisterName
<span class="lineno">   74 </span>  , scFreshVarName
<span class="lineno">   75 </span>  , scInjectCode
<span class="lineno">   76 </span>  , scDeclarePrim
<span class="lineno">   77 </span>  , scFreshConstant
<span class="lineno">   78 </span>  , scDefineConstant
<span class="lineno">   79 </span>  , scOpaqueConstant
<span class="lineno">   80 </span>  , scBeginDataType
<span class="lineno">   81 </span>  , scCompleteDataType
<span class="lineno">   82 </span>  , scImportModule
<span class="lineno">   83 </span>  , scLoadModule
<span class="lineno">   84 </span>  , scFreshName
<span class="lineno">   85 </span>  , scFreshenGlobalIdent
<span class="lineno">   86 </span>  , scResolveNameByURI
<span class="lineno">   87 </span>  , SharedContextCheckpoint
<span class="lineno">   88 </span>  , checkpointSharedContext
<span class="lineno">   89 </span>  , restoreSharedContext
<span class="lineno">   90 </span>    -- * Prettyprinting hooks (re-exported from SharedTerm; get them from
<span class="lineno">   91 </span>    -- there unless you need to be here for some reason)
<span class="lineno">   92 </span>  , prettyTerm
<span class="lineno">   93 </span>  , ppTerm
<span class="lineno">   94 </span>  ) where
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>import Control.Applicative
<span class="lineno">   97 </span>-- ((&lt;$&gt;), pure, (&lt;*&gt;))
<span class="lineno">   98 </span>import Control.Exception
<span class="lineno">   99 </span>import Control.Lens
<span class="lineno">  100 </span>import Control.Monad (foldM, forM, forM_, join, unless, when)
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>import Data.Bits
<span class="lineno">  103 </span>import qualified Data.Foldable as Fold
<span class="lineno">  104 </span>import Data.Foldable (foldlM, foldrM)
<span class="lineno">  105 </span>import Data.Hashable (Hashable(hash))
<span class="lineno">  106 </span>import Data.HashMap.Strict (HashMap)
<span class="lineno">  107 </span>import qualified Data.HashMap.Strict as HMap
<span class="lineno">  108 </span>import Data.IntMap.Strict (IntMap)
<span class="lineno">  109 </span>import qualified Data.IntMap.Strict as IntMap
<span class="lineno">  110 </span>import qualified Data.IntSet as IntSet
<span class="lineno">  111 </span>import Data.IORef (IORef,newIORef,readIORef,modifyIORef',atomicModifyIORef',writeIORef)
<span class="lineno">  112 </span>import Data.List (find)
<span class="lineno">  113 </span>import qualified Data.Map as Map
<span class="lineno">  114 </span>import Data.Map (Map)
<span class="lineno">  115 </span>import Data.Maybe
<span class="lineno">  116 </span>import Data.Text (Text)
<span class="lineno">  117 </span>import qualified Data.Text as Text
<span class="lineno">  118 </span>import qualified Data.Vector as V
<span class="lineno">  119 </span>import Numeric.Natural (Natural)
<span class="lineno">  120 </span>import Prelude hiding (maximum)
<span class="lineno">  121 </span>import Text.URI
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>import SAWSupport.IntRangeSet (IntRangeSet)
<span class="lineno">  124 </span>import qualified SAWSupport.IntRangeSet as IntRangeSet
<span class="lineno">  125 </span>import qualified SAWSupport.Pretty as PPS
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>import SAWCore.Cache
<span class="lineno">  128 </span>import SAWCore.Module
<span class="lineno">  129 </span>  ( beginDataType
<span class="lineno">  130 </span>  , completeDataType
<span class="lineno">  131 </span>  , dtName
<span class="lineno">  132 </span>  , ctorNumParams
<span class="lineno">  133 </span>  , ctorName
<span class="lineno">  134 </span>  , emptyModuleMap
<span class="lineno">  135 </span>  , moduleIsLoaded
<span class="lineno">  136 </span>  , moduleName
<span class="lineno">  137 </span>  , loadModule
<span class="lineno">  138 </span>  , lookupVarIndexInMap
<span class="lineno">  139 </span>  , insDefInMap
<span class="lineno">  140 </span>  , insInjectCodeInMap
<span class="lineno">  141 </span>  , insImportInMap
<span class="lineno">  142 </span>  , resolvedNameType
<span class="lineno">  143 </span>  , requireNameInMap
<span class="lineno">  144 </span>  , CtorArg(..)
<span class="lineno">  145 </span>  , CtorArgStruct(..)
<span class="lineno">  146 </span>  , Ctor(..)
<span class="lineno">  147 </span>  , DefQualifier(..)
<span class="lineno">  148 </span>  , DataType(..)
<span class="lineno">  149 </span>  , Def(..)
<span class="lineno">  150 </span>  , Module
<span class="lineno">  151 </span>  , ModuleMap
<span class="lineno">  152 </span>  , ResolvedName(..)
<span class="lineno">  153 </span>  )
<span class="lineno">  154 </span>import SAWCore.Name
<span class="lineno">  155 </span>import SAWCore.Panic (panic)
<span class="lineno">  156 </span>import SAWCore.Prelude.Constants
<span class="lineno">  157 </span>import SAWCore.Recognizer
<span class="lineno">  158 </span>import SAWCore.Term.Functor
<span class="lineno">  159 </span>import SAWCore.Term.Pretty
<span class="lineno">  160 </span>import SAWCore.Term.Raw
<span class="lineno">  161 </span>import SAWCore.Unique
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>scGlobal :: SharedContext -&gt; Ident -&gt; IO Term
<span class="lineno">  164 </span><span class="decl"><span class="istickedoff">scGlobal sc ident = scGlobalDef sc ident</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- possible errors: constant not defined
<span class="lineno">  167 </span>scConstant :: SharedContext -&gt; Name -&gt; IO Term
<span class="lineno">  168 </span><span class="decl"><span class="istickedoff">scConstant = scConst</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>-- possible errors: duplicate field name
<span class="lineno">  171 </span>scRecordValue :: SharedContext -&gt; [(FieldName, Term)] -&gt; IO Term
<span class="lineno">  172 </span><span class="decl"><span class="istickedoff">scRecordValue sc fields = scRecord sc (Map.fromList fields)</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- possible errors: not a record type, field name not found
<span class="lineno">  175 </span>scRecordProj :: SharedContext -&gt; Term -&gt; FieldName -&gt; IO Term
<span class="lineno">  176 </span><span class="decl"><span class="nottickedoff">scRecordProj sc t fname = scRecordSelect sc t fname</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>----------------------------------------------------------------------
<span class="lineno">  180 </span>-- Printing
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>-- Ideally these would be able to live in Pretty.hs, but they can't
<span class="lineno">  183 </span>-- because they need the `SharedContext`. They used to live in
<span class="lineno">  184 </span>-- SharedTerm.hs, but we would like to use them from inside here for
<span class="lineno">  185 </span>-- error reporting.
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>-- | The preferred printing mechanism for `Term`, if you want a `Doc`.
<span class="lineno">  188 </span>--
<span class="lineno">  189 </span>--   Note that there are two naming conventions in conflict here: the
<span class="lineno">  190 </span>--   convention that things using the `SharedContext` and in `IO`
<span class="lineno">  191 </span>--   should be named `sc`, and the convention that the preferred way
<span class="lineno">  192 </span>--   to prettyprint an object of type @Foo@ to a `Doc` should be
<span class="lineno">  193 </span>--   called @prettyFoo@. For the time being at least we've concluded
<span class="lineno">  194 </span>--   that the latter is more important.
<span class="lineno">  195 </span>prettyTerm :: SharedContext -&gt; PPS.Opts -&gt; Term -&gt; IO PPS.Doc
<span class="lineno">  196 </span><span class="decl"><span class="istickedoff">prettyTerm sc opts t =</span>
<span class="lineno">  197 </span><span class="spaces">  </span><span class="istickedoff">do env &lt;- scGetNamingEnv sc</span>
<span class="lineno">  198 </span><span class="spaces">     </span><span class="istickedoff">pure (prettyTermWithEnv opts env t)</span></span>
<span class="lineno">  199 </span>
<span class="lineno">  200 </span>-- | The preferred printing mechanism for `Term`, if you want text.
<span class="lineno">  201 </span>--
<span class="lineno">  202 </span>--   The same naming considerations as `prettyTerm` apply.
<span class="lineno">  203 </span>ppTerm :: SharedContext -&gt; PPS.Opts -&gt; Term -&gt; IO String
<span class="lineno">  204 </span><span class="decl"><span class="istickedoff">ppTerm sc opts t =</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">PPS.render opts &lt;$&gt; prettyTerm sc opts t</span></span>
<span class="lineno">  206 </span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>----------------------------------------------------------------------
<span class="lineno">  209 </span>-- TermFMaps
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>{-
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>Hash-consing story:
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>For scApply, we do a hash-consing lookup in 'appMapTFM' *before*
<span class="lineno">  216 </span>computing the result type (because computing the type may be expensive
<span class="lineno">  217 </span>in some cases). Terms in 'appMapTFM' must have the default type that
<span class="lineno">  218 </span>would normally be computed by scApply.
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>If we don't find the pair of keys in 'appMapTFM', only then do we
<span class="lineno">  221 </span>compute the result type, generate a new TermIndex, create a Term, and
<span class="lineno">  222 </span>then add it to appMapTFM.
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>For anything other than Apply nodes, we compute the type first.
<span class="lineno">  225 </span>(For non-Apply this should usually be fairly cheap to compute.)
<span class="lineno">  226 </span>Then we look up the pair of TermF and type together in hashMapTFM.
<span class="lineno">  227 </span>
<span class="lineno">  228 </span>Terms may have types ascribed to them that are convertible (but not
<span class="lineno">  229 </span>equal) to the type that would have been computed by the typing rules.
<span class="lineno">  230 </span>When constructing an application term with a possibly-modified type,
<span class="lineno">  231 </span>we should do the following:
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>* Look up the TermF and type in hashMapTFM; if an entry is found,
<span class="lineno">  234 </span>  return it.
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>* Look up the two subterms in appMapTFM; if an entry is found *and the
<span class="lineno">  237 </span>  type matches*, then return it.
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>* If an entry with the wrong type was found in appMapTFM, then obtain
<span class="lineno">  240 </span>  a new TermIndex, add a new entry to hashMapTFM, and return the new
<span class="lineno">  241 </span>  term.
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>* If no entry was found in either table, we *could* compute the
<span class="lineno">  244 </span>  expected type for scApply and compare it to the given type to see
<span class="lineno">  245 </span>  which table the new term should go in. This is probably a very
<span class="lineno">  246 </span>  uncommon case.
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>In any case, a type-ascription operation should test for whether the
<span class="lineno">  249 </span>new type is identical to the old type and return the original term if
<span class="lineno">  250 </span>so.
<span class="lineno">  251 </span>
<span class="lineno">  252 </span>-}
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>-- | A TermFMap is a data structure used for hash-consing of terms.
<span class="lineno">  255 </span>data TermFMap a
<span class="lineno">  256 </span>  = TermFMap
<span class="lineno">  257 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">appMapTFM</span></span></span> :: !(IntMap (IntMap a))
<span class="lineno">  258 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">hashMapTFM</span></span></span> :: !(HashMap (TermF Term, Either Sort Term) a)
<span class="lineno">  259 </span>  }
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>emptyTFM :: TermFMap a
<span class="lineno">  262 </span><span class="decl"><span class="istickedoff">emptyTFM = TermFMap mempty mempty</span></span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>lookupAppTFM :: Term -&gt; Term -&gt; TermFMap a -&gt; Maybe a
<span class="lineno">  265 </span><span class="decl"><span class="istickedoff">lookupAppTFM STApp{stAppIndex = i} STApp{stAppIndex = j} tfm =</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="istickedoff">IntMap.lookup i (appMapTFM tfm) &gt;&gt;= IntMap.lookup j</span></span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>insertAppTFM :: Term -&gt; Term -&gt; a -&gt; TermFMap a -&gt; TermFMap a
<span class="lineno">  269 </span><span class="decl"><span class="istickedoff">insertAppTFM STApp{stAppIndex = i} STApp{stAppIndex = j} x tfm =</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="istickedoff">let f Nothing = Just (IntMap.singleton j x)</span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff">f (Just m) = Just (IntMap.insert j x m)</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="istickedoff">in tfm { appMapTFM = IntMap.alter f i (appMapTFM tfm) }</span></span>
<span class="lineno">  273 </span>
<span class="lineno">  274 </span>lookupTFM :: TermF Term -&gt; Either Sort Term -&gt; TermFMap a -&gt; Maybe a
<span class="lineno">  275 </span><span class="decl"><span class="istickedoff">lookupTFM tf mty tfm =</span>
<span class="lineno">  276 </span><span class="spaces">  </span><span class="istickedoff">HMap.lookup (tf, mty) (hashMapTFM tfm)</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>insertTFM :: TermF Term -&gt; Either Sort Term -&gt; a -&gt; TermFMap a -&gt; TermFMap a
<span class="lineno">  279 </span><span class="decl"><span class="istickedoff">insertTFM tf mty x tfm =</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="istickedoff">tfm { hashMapTFM = HMap.insert (tf, mty) x (hashMapTFM tfm) }</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>filterTFM :: (a -&gt; Bool) -&gt; TermFMap a -&gt; TermFMap a
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">filterTFM p tfm =</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="istickedoff">TermFMap</span>
<span class="lineno">  285 </span><span class="spaces">  </span><span class="istickedoff">{ appMapTFM = IntMap.map (IntMap.filter p) (appMapTFM tfm)</span>
<span class="lineno">  286 </span><span class="spaces">  </span><span class="istickedoff">, hashMapTFM = HMap.filter p (hashMapTFM tfm)</span>
<span class="lineno">  287 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>type AppCache = TermFMap Term
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>type AppCacheRef = IORef AppCache
<span class="lineno">  292 </span>
<span class="lineno">  293 </span>emptyAppCache :: AppCache
<span class="lineno">  294 </span><span class="decl"><span class="istickedoff">emptyAppCache = emptyTFM</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>----------------------------------------------------------------------
<span class="lineno">  297 </span>-- SharedContext: a high-level interface for building Terms.
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>-- | 'SharedContext' is an abstract datatype representing all the
<span class="lineno">  300 </span>-- information necessary to resolve names and to construct,
<span class="lineno">  301 </span>-- type-check, normalize, and evaluate SAWCore 'Term's.
<span class="lineno">  302 </span>-- A 'SharedContext' contains mutable references so that it can be
<span class="lineno">  303 </span>-- extended at run-time with new names and declarations.
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>-- Invariant: scGlobalEnv is a cache with one entry for every global
<span class="lineno">  306 </span>-- declaration in 'scModuleMap' whose name is a 'ModuleIdentifier'.
<span class="lineno">  307 </span>-- Each map entry points to a 'Constant' term with the same 'Ident'.
<span class="lineno">  308 </span>-- It exists only to save one map lookup when building terms: Without
<span class="lineno">  309 </span>-- it we would first have to look up the Ident by URI in scURIEnv, and
<span class="lineno">  310 </span>-- then do another lookup for hash-consing the Constant term.
<span class="lineno">  311 </span>-- Invariant: All entries in 'scAppCache' must have 'TermIndex'es that
<span class="lineno">  312 </span>-- are less than 'scNextTermIndex' and marked valid in 'scValidTerms'.
<span class="lineno">  313 </span>data SharedContext = SharedContext
<span class="lineno">  314 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">scModuleMap</span></span></span>      :: IORef ModuleMap
<span class="lineno">  315 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scAppCache</span></span></span>       :: AppCacheRef
<span class="lineno">  316 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scDisplayNameEnv</span></span></span> :: IORef DisplayNameEnv
<span class="lineno">  317 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scURIEnv</span></span></span>         :: IORef (Map URI VarIndex)
<span class="lineno">  318 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scGlobalEnv</span></span></span>      :: IORef (HashMap Ident Term)
<span class="lineno">  319 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scNextVarIndex</span></span></span>   :: IORef VarIndex
<span class="lineno">  320 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scNextTermIndex</span></span></span>  :: IORef TermIndex
<span class="lineno">  321 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">scValidTerms</span></span></span>     :: IORef IntRangeSet
<span class="lineno">  322 </span>  }
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>-- | Internal function to get the next available 'TermIndex'. Not exported.
<span class="lineno">  325 </span>scFreshTermIndex :: SharedContext -&gt; IO VarIndex
<span class="lineno">  326 </span><span class="decl"><span class="istickedoff">scFreshTermIndex sc = atomicModifyIORef' (scNextTermIndex sc) (\i -&gt; (i + 1, i))</span></span>
<span class="lineno">  327 </span>
<span class="lineno">  328 </span>scEnsureValidTerm :: SharedContext -&gt; Term -&gt; IO ()
<span class="lineno">  329 </span><span class="decl"><span class="istickedoff">scEnsureValidTerm sc t =</span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- readIORef (scValidTerms sc)</span>
<span class="lineno">  331 </span><span class="spaces">     </span><span class="istickedoff">unless (IntRangeSet.member (termIndex t) s) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  332 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">-- XXX: we should probably have the prettyprinting options in the SharedContext</span></span>
<span class="lineno">  333 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">t' &lt;- ppTerm sc PPS.defaultOpts t</span></span>
<span class="lineno">  334 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines $ [</span></span>
<span class="lineno">  335 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">&quot;Stale term encountered: index = &quot; ++ show (termIndex t),</span></span>
<span class="lineno">  336 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">&quot;Valid indexes: &quot; ++ show (IntRangeSet.toList s),</span></span>
<span class="lineno">  337 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">t'</span></span>
<span class="lineno">  338 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>-- | Internal function to make a 'Term' from a 'TermF' with a given
<span class="lineno">  341 </span>-- variable typing context and type.
<span class="lineno">  342 </span>-- Precondition: The 'Either' argument should never have 'Right'
<span class="lineno">  343 </span>-- applied to a 'Sort'.
<span class="lineno">  344 </span>-- Precondition: All subterms should have been checked with 'scEnsureValidTerm'.
<span class="lineno">  345 </span>scMakeTerm :: SharedContext -&gt; IntMap Term -&gt; TermF Term -&gt; Either Sort Term -&gt; IO Term
<span class="lineno">  346 </span><span class="decl"><span class="istickedoff">scMakeTerm sc vt tf mty =</span>
<span class="lineno">  347 </span><span class="spaces">  </span><span class="istickedoff">do s &lt;- readIORef (scAppCache sc)</span>
<span class="lineno">  348 </span><span class="spaces">     </span><span class="istickedoff">case lookupTFM tf mty s of</span>
<span class="lineno">  349 </span><span class="spaces">       </span><span class="istickedoff">Just term -&gt; pure term</span>
<span class="lineno">  350 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  351 </span><span class="spaces">         </span><span class="istickedoff">do i &lt;- scFreshTermIndex sc</span>
<span class="lineno">  352 </span><span class="spaces">            </span><span class="istickedoff">let term = STApp { stAppIndex = i</span>
<span class="lineno">  353 </span><span class="spaces">                             </span><span class="istickedoff">, stAppHash = hash tf</span>
<span class="lineno">  354 </span><span class="spaces">                             </span><span class="istickedoff">, stAppVarTypes = vt</span>
<span class="lineno">  355 </span><span class="spaces">                             </span><span class="istickedoff">, stAppTermF = tf</span>
<span class="lineno">  356 </span><span class="spaces">                             </span><span class="istickedoff">, stAppType = mty</span>
<span class="lineno">  357 </span><span class="spaces">                             </span><span class="istickedoff">}</span>
<span class="lineno">  358 </span><span class="spaces">            </span><span class="istickedoff">modifyIORef' (scAppCache sc) (insertTFM tf mty term)</span>
<span class="lineno">  359 </span><span class="spaces">            </span><span class="istickedoff">pure term</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>--------------------------------------------------------------------------------
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>data SharedContextCheckpoint =
<span class="lineno">  364 </span>  SCC
<span class="lineno">  365 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccModuleMap</span></span></span> :: ModuleMap
<span class="lineno">  366 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccNamingEnv</span></span></span> :: DisplayNameEnv
<span class="lineno">  367 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccURIEnv</span></span></span>    :: Map URI VarIndex
<span class="lineno">  368 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sccGlobalEnv</span></span></span> :: HashMap Ident Term
<span class="lineno">  369 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">sccTermIndex</span></span></span> :: TermIndex
<span class="lineno">  370 </span>  }
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>checkpointSharedContext :: SharedContext -&gt; IO SharedContextCheckpoint
<span class="lineno">  373 </span><span class="decl"><span class="istickedoff">checkpointSharedContext sc =</span>
<span class="lineno">  374 </span><span class="spaces">  </span><span class="istickedoff">do mmap &lt;- readIORef (scModuleMap sc)</span>
<span class="lineno">  375 </span><span class="spaces">     </span><span class="istickedoff">nenv &lt;- readIORef (scDisplayNameEnv sc)</span>
<span class="lineno">  376 </span><span class="spaces">     </span><span class="istickedoff">uenv &lt;- readIORef (scURIEnv sc)</span>
<span class="lineno">  377 </span><span class="spaces">     </span><span class="istickedoff">genv &lt;- readIORef (scGlobalEnv sc)</span>
<span class="lineno">  378 </span><span class="spaces">     </span><span class="istickedoff">i &lt;- readIORef (scNextTermIndex sc)</span>
<span class="lineno">  379 </span><span class="spaces">     </span><span class="istickedoff">return SCC</span>
<span class="lineno">  380 </span><span class="spaces">            </span><span class="istickedoff">{ sccModuleMap = <span class="nottickedoff">mmap</span></span>
<span class="lineno">  381 </span><span class="spaces">            </span><span class="istickedoff">, sccNamingEnv = <span class="nottickedoff">nenv</span></span>
<span class="lineno">  382 </span><span class="spaces">            </span><span class="istickedoff">, sccURIEnv = <span class="nottickedoff">uenv</span></span>
<span class="lineno">  383 </span><span class="spaces">            </span><span class="istickedoff">, sccGlobalEnv = <span class="nottickedoff">genv</span></span>
<span class="lineno">  384 </span><span class="spaces">            </span><span class="istickedoff">, sccTermIndex = i</span>
<span class="lineno">  385 </span><span class="spaces">            </span><span class="istickedoff">}</span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>restoreSharedContext :: SharedContextCheckpoint -&gt; SharedContext -&gt; IO SharedContext
<span class="lineno">  388 </span><span class="decl"><span class="istickedoff">restoreSharedContext scc sc =</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="istickedoff">do -- Ensure that the checkpoint itself is not stale</span>
<span class="lineno">  390 </span><span class="spaces">     </span><span class="istickedoff">let i = sccTermIndex scc</span>
<span class="lineno">  391 </span><span class="spaces">     </span><span class="istickedoff">s &lt;- readIORef (scValidTerms sc)</span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="istickedoff">unless (IntRangeSet.member i s) $</span>
<span class="lineno">  393 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines $</span></span>
<span class="lineno">  394 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Stale checkpoint encountered: index = &quot; ++ show i</span></span>
<span class="lineno">  395 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">, &quot;Valid indexes: &quot; ++ show (IntRangeSet.toList s)</span></span>
<span class="lineno">  396 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  397 </span><span class="spaces">     </span><span class="istickedoff">-- Restore saved environments</span>
<span class="lineno">  398 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scModuleMap sc) <span class="nottickedoff">(sccModuleMap scc)</span></span>
<span class="lineno">  399 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scDisplayNameEnv sc) <span class="nottickedoff">(sccNamingEnv scc)</span></span>
<span class="lineno">  400 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scURIEnv sc) <span class="nottickedoff">(sccURIEnv scc)</span></span>
<span class="lineno">  401 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scGlobalEnv sc) <span class="nottickedoff">(sccGlobalEnv scc)</span></span>
<span class="lineno">  402 </span><span class="spaces">     </span><span class="istickedoff">-- Mark 'TermIndex'es created since the checkpoint as invalid</span>
<span class="lineno">  403 </span><span class="spaces">     </span><span class="istickedoff">j &lt;- readIORef (scNextTermIndex sc)</span>
<span class="lineno">  404 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scValidTerms sc) (IntRangeSet.delete (i, j-1))</span>
<span class="lineno">  405 </span><span class="spaces">     </span><span class="istickedoff">-- Filter stale terms from AppCache</span>
<span class="lineno">  406 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scAppCache sc) (filterTFM (\t -&gt; termIndex t &lt; i))</span>
<span class="lineno">  407 </span><span class="spaces">     </span><span class="istickedoff">-- scNextVarIndex and scNextTermIndex are left untouched</span>
<span class="lineno">  408 </span><span class="spaces">     </span><span class="istickedoff">pure sc</span></span>
<span class="lineno">  409 </span>
<span class="lineno">  410 </span>--------------------------------------------------------------------------------
<span class="lineno">  411 </span>-- Fundamental term builders
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>-- | Build a variant of a 'Term' with a specific type.
<span class="lineno">  414 </span>-- The first term's type must be a subtype of the second term.
<span class="lineno">  415 </span>scAscribe :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  416 </span><span class="decl"><span class="istickedoff">scAscribe sc t0 ty =</span>
<span class="lineno">  417 </span><span class="spaces">  </span><span class="istickedoff">do let mty = maybe (Right ty) Left (asSort ty)</span>
<span class="lineno">  418 </span><span class="spaces">     </span><span class="istickedoff">ty0 &lt;- scTypeOf sc t0</span>
<span class="lineno">  419 </span><span class="spaces">     </span><span class="istickedoff">ok &lt;- scSubtype sc ty0 ty</span>
<span class="lineno">  420 </span><span class="spaces">     </span><span class="istickedoff">unless ok $</span>
<span class="lineno">  421 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">do ty0' &lt;- ppTerm sc PPS.defaultOpts ty0</span></span>
<span class="lineno">  422 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">ty' &lt;- ppTerm sc PPS.defaultOpts ty</span></span>
<span class="lineno">  423 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines $</span></span>
<span class="lineno">  424 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Not a subtype&quot;</span></span>
<span class="lineno">  425 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected: &quot; ++ ty'</span></span>
<span class="lineno">  426 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">, &quot;got: &quot; ++ ty0'</span></span>
<span class="lineno">  427 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  428 </span><span class="spaces">     </span><span class="istickedoff">let tf = unwrapTermF t0</span>
<span class="lineno">  429 </span><span class="spaces">     </span><span class="istickedoff">let fallback = scMakeTerm sc (varTypes t0) tf mty</span>
<span class="lineno">  430 </span><span class="spaces">     </span><span class="istickedoff">tfm &lt;- readIORef (scAppCache sc)</span>
<span class="lineno">  431 </span><span class="spaces">     </span><span class="istickedoff">case tf of</span>
<span class="lineno">  432 </span><span class="spaces">       </span><span class="istickedoff">App f arg -&gt;</span>
<span class="lineno">  433 </span><span class="spaces">         </span><span class="istickedoff">case lookupAppTFM f arg tfm of</span>
<span class="lineno">  434 </span><span class="spaces">           </span><span class="istickedoff">Just t' -&gt;</span>
<span class="lineno">  435 </span><span class="spaces">             </span><span class="istickedoff">if fmap termIndex mty == fmap termIndex (termSortOrType t')</span>
<span class="lineno">  436 </span><span class="spaces">             </span><span class="istickedoff">then pure t' else fallback</span>
<span class="lineno">  437 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fallback</span></span>
<span class="lineno">  438 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; fallback</span></span>
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>-- | Build a new 'Term' value from the given 'TermF'.
<span class="lineno">  441 </span>-- Reuse a 'Term' from the cache if an identical one already exists.
<span class="lineno">  442 </span>scTermF :: SharedContext -&gt; TermF Term -&gt; IO Term
<span class="lineno">  443 </span><span class="decl"><span class="istickedoff">scTermF sc tf =</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  445 </span><span class="spaces">    </span><span class="istickedoff">FTermF ftf -&gt; scFlatTermF sc ftf</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">App t1 t2 -&gt; scApply sc t1 t2</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">Lambda x t1 t2 -&gt; scLambda sc x t1 t2</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">Pi x t1 t2 -&gt; scPi sc x t1 t2</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">Constant nm -&gt; scConst sc nm</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff">Variable x t1 -&gt; scVariable sc x t1</span></span>
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>-- | Create a new term from a lower-level 'FlatTermF' term.
<span class="lineno">  453 </span>scFlatTermF :: SharedContext -&gt; FlatTermF Term -&gt; IO Term
<span class="lineno">  454 </span><span class="decl"><span class="istickedoff">scFlatTermF sc ftf =</span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">UnitValue -&gt; scUnitValue sc</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">UnitType -&gt; scUnitType sc</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">PairValue t1 t2 -&gt; scPairValue sc t1 t2</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">PairType t1 t2 -&gt; scPairType sc t1 t2</span>
<span class="lineno">  460 </span><span class="spaces">    </span><span class="istickedoff">PairLeft t -&gt; scPairLeft sc t</span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">PairRight t -&gt; scPairRight sc t</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">Recursor crec -&gt; scRecursor sc (recursorDataType crec) (recursorSort crec)</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">RecordType fs -&gt; scRecordType sc fs</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">RecordValue fs -&gt; scRecord sc (Map.fromList fs)</span>
<span class="lineno">  465 </span><span class="spaces">    </span><span class="istickedoff">RecordProj t fname -&gt; scRecordSelect sc t fname</span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">Sort s flags -&gt; scSortWithFlags sc s flags</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue t ts -&gt; scVector sc t (V.toList ts)</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">StringLit s -&gt; scString sc s</span></span>
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>-- | Create a function application term.
<span class="lineno">  471 </span>scApply ::
<span class="lineno">  472 </span>  SharedContext -&gt;
<span class="lineno">  473 </span>  Term {- ^ The function to apply -} -&gt;
<span class="lineno">  474 </span>  Term {- ^ The argument to apply to -} -&gt;
<span class="lineno">  475 </span>  IO Term
<span class="lineno">  476 </span><span class="decl"><span class="istickedoff">scApply sc t1 t2 =</span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">-- Look up this application in the hash table first; if it is</span>
<span class="lineno">  478 </span><span class="spaces">  </span><span class="istickedoff">-- already there we can avoid recomputing the result type.</span>
<span class="lineno">  479 </span><span class="spaces">  </span><span class="istickedoff">do tfm &lt;- readIORef (scAppCache sc)</span>
<span class="lineno">  480 </span><span class="spaces">     </span><span class="istickedoff">case lookupAppTFM t1 t2 tfm of</span>
<span class="lineno">  481 </span><span class="spaces">       </span><span class="istickedoff">Just term -&gt; pure term</span>
<span class="lineno">  482 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  483 </span><span class="spaces">         </span><span class="istickedoff">do scEnsureValidTerm sc t1</span>
<span class="lineno">  484 </span><span class="spaces">            </span><span class="istickedoff">scEnsureValidTerm sc t2</span>
<span class="lineno">  485 </span><span class="spaces">            </span><span class="istickedoff">vt &lt;- unifyVarTypes <span class="nottickedoff">&quot;scApply&quot;</span> <span class="nottickedoff">sc</span> (varTypes t1) (varTypes t2)</span>
<span class="lineno">  486 </span><span class="spaces">            </span><span class="istickedoff">ty1 &lt;- scTypeOf <span class="nottickedoff">sc</span> t1</span>
<span class="lineno">  487 </span><span class="spaces">            </span><span class="istickedoff">(x, ty1a, ty1b) &lt;- ensurePi sc ty1</span>
<span class="lineno">  488 </span><span class="spaces">            </span><span class="istickedoff">ty2 &lt;- scTypeOf sc t2</span>
<span class="lineno">  489 </span><span class="spaces">            </span><span class="istickedoff">ok &lt;- scSubtype sc ty2 ty1a</span>
<span class="lineno">  490 </span><span class="spaces">            </span><span class="istickedoff">unless ok $ <span class="nottickedoff">do</span></span>
<span class="lineno">  491 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">-- XXX we should probably have the prettyprint options in the SharedContext</span></span>
<span class="lineno">  492 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">ty1a' &lt;- ppTerm sc PPS.defaultOpts ty1a</span></span>
<span class="lineno">  493 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">ty2' &lt;- ppTerm sc PPS.defaultOpts ty2</span></span>
<span class="lineno">  494 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines $ [</span></span>
<span class="lineno">  495 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;Not a subtype&quot;,</span></span>
<span class="lineno">  496 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;expected: &quot; ++ ty1a',</span></span>
<span class="lineno">  497 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">&quot;got: &quot; ++ ty2'</span></span>
<span class="lineno">  498 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  499 </span><span class="spaces">            </span><span class="istickedoff">-- Computing the result type with scInstantiateBeta may</span>
<span class="lineno">  500 </span><span class="spaces">            </span><span class="istickedoff">-- lead to other calls to scApply, but these should be at</span>
<span class="lineno">  501 </span><span class="spaces">            </span><span class="istickedoff">-- simpler types, so it should always terminate.</span>
<span class="lineno">  502 </span><span class="spaces">            </span><span class="istickedoff">ty &lt;- scInstantiateBeta sc (IntMap.singleton (vnIndex x) t2) ty1b</span>
<span class="lineno">  503 </span><span class="spaces">            </span><span class="istickedoff">let mty = maybe (Right ty) Left (asSort ty)</span>
<span class="lineno">  504 </span><span class="spaces">            </span><span class="istickedoff">i &lt;- scFreshTermIndex sc</span>
<span class="lineno">  505 </span><span class="spaces">            </span><span class="istickedoff">let tf = App t1 t2</span>
<span class="lineno">  506 </span><span class="spaces">            </span><span class="istickedoff">let term =</span>
<span class="lineno">  507 </span><span class="spaces">                  </span><span class="istickedoff">STApp</span>
<span class="lineno">  508 </span><span class="spaces">                  </span><span class="istickedoff">{ stAppIndex = i</span>
<span class="lineno">  509 </span><span class="spaces">                  </span><span class="istickedoff">, stAppHash = hash tf</span>
<span class="lineno">  510 </span><span class="spaces">                  </span><span class="istickedoff">, stAppVarTypes = vt</span>
<span class="lineno">  511 </span><span class="spaces">                  </span><span class="istickedoff">, stAppTermF = tf</span>
<span class="lineno">  512 </span><span class="spaces">                  </span><span class="istickedoff">, stAppType = mty</span>
<span class="lineno">  513 </span><span class="spaces">                  </span><span class="istickedoff">}</span>
<span class="lineno">  514 </span><span class="spaces">            </span><span class="istickedoff">modifyIORef' (scAppCache sc) (insertAppTFM t1 t2 term)</span>
<span class="lineno">  515 </span><span class="spaces">            </span><span class="istickedoff">pure term</span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>-- | Create a lambda term from a parameter name (as a 'VarName'),
<span class="lineno">  518 </span>-- parameter type (as a 'Term'), and a body ('Term').
<span class="lineno">  519 </span>-- All free variables with the same 'VarName' in the body become
<span class="lineno">  520 </span>-- bound.
<span class="lineno">  521 </span>scLambda ::
<span class="lineno">  522 </span>  SharedContext -&gt;
<span class="lineno">  523 </span>  VarName {- ^ The parameter name -} -&gt;
<span class="lineno">  524 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  525 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  526 </span>  IO Term
<span class="lineno">  527 </span><span class="decl"><span class="istickedoff">scLambda sc x t body =</span>
<span class="lineno">  528 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t</span>
<span class="lineno">  529 </span><span class="spaces">     </span><span class="istickedoff">scEnsureValidTerm sc body</span>
<span class="lineno">  530 </span><span class="spaces">     </span><span class="istickedoff">ensureNotFreeInContext x body</span>
<span class="lineno">  531 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- unifyVarTypes <span class="nottickedoff">&quot;scLambda&quot;</span> <span class="nottickedoff">sc</span> (IntMap.singleton (vnIndex x) t) (varTypes body)</span>
<span class="lineno">  532 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- unifyVarTypes <span class="nottickedoff">&quot;scLambda&quot;</span> <span class="nottickedoff">sc</span> (varTypes t) (IntMap.delete (vnIndex x) (varTypes body))</span>
<span class="lineno">  533 </span><span class="spaces">     </span><span class="istickedoff">rty &lt;- scTypeOf sc body</span>
<span class="lineno">  534 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scPi sc x t rty</span>
<span class="lineno">  535 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt (Lambda x t body) (Right ty)</span></span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>-- | Create a (possibly dependent) function given a parameter name,
<span class="lineno">  538 </span>-- parameter type (as a 'Term'), and a body ('Term').
<span class="lineno">  539 </span>-- All free variables with the same 'VarName' in the body become
<span class="lineno">  540 </span>-- bound.
<span class="lineno">  541 </span>scPi ::
<span class="lineno">  542 </span>  SharedContext -&gt;
<span class="lineno">  543 </span>  VarName {- ^ The parameter name -} -&gt;
<span class="lineno">  544 </span>  Term {- ^ The parameter type -} -&gt;
<span class="lineno">  545 </span>  Term {- ^ The body -} -&gt;
<span class="lineno">  546 </span>  IO Term
<span class="lineno">  547 </span><span class="decl"><span class="istickedoff">scPi sc x t body =</span>
<span class="lineno">  548 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t</span>
<span class="lineno">  549 </span><span class="spaces">     </span><span class="istickedoff">scEnsureValidTerm sc body</span>
<span class="lineno">  550 </span><span class="spaces">     </span><span class="istickedoff">ensureNotFreeInContext x body</span>
<span class="lineno">  551 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- unifyVarTypes <span class="nottickedoff">&quot;scPi&quot;</span> <span class="nottickedoff">sc</span> (IntMap.singleton (vnIndex x) t) (varTypes body)</span>
<span class="lineno">  552 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- unifyVarTypes <span class="nottickedoff">&quot;scPi&quot;</span> <span class="nottickedoff">sc</span> (varTypes t) (IntMap.delete (vnIndex x) (varTypes body))</span>
<span class="lineno">  553 </span><span class="spaces">     </span><span class="istickedoff">s1 &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType t)</span>
<span class="lineno">  554 </span><span class="spaces">     </span><span class="istickedoff">s2 &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType body)</span>
<span class="lineno">  555 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt (Pi x t body) (Left (piSort s1 s2))</span></span>
<span class="lineno">  556 </span>
<span class="lineno">  557 </span>-- | Create a constant 'Term' from a 'Name'.
<span class="lineno">  558 </span>scConst :: SharedContext -&gt; Name -&gt; IO Term
<span class="lineno">  559 </span><span class="decl"><span class="istickedoff">scConst sc nm =</span>
<span class="lineno">  560 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scTypeOfName sc nm</span>
<span class="lineno">  561 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right ty) Left (asSort ty)</span>
<span class="lineno">  562 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc IntMap.empty (Constant nm) mty</span></span>
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>-- | Create a named variable 'Term' from a 'VarName' and a type.
<span class="lineno">  565 </span>scVariable :: SharedContext -&gt; VarName -&gt; Term -&gt; IO Term
<span class="lineno">  566 </span><span class="decl"><span class="istickedoff">scVariable sc x t =</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t</span>
<span class="lineno">  568 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- unifyVarTypes <span class="nottickedoff">&quot;scVariable&quot;</span> <span class="nottickedoff">sc</span> (IntMap.singleton (vnIndex x) t) (varTypes t)</span>
<span class="lineno">  569 </span><span class="spaces">     </span><span class="istickedoff">_s &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType t)</span>
<span class="lineno">  570 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right t) Left (asSort t)</span>
<span class="lineno">  571 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt (Variable x t) mty</span></span>
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>-- | Check whether the given 'VarName' occurs free in the type of
<span class="lineno">  574 </span>-- another variable in the context of the given 'Term', and fail if it
<span class="lineno">  575 </span>-- does.
<span class="lineno">  576 </span>ensureNotFreeInContext :: VarName -&gt; Term -&gt; IO ()
<span class="lineno">  577 </span><span class="decl"><span class="istickedoff">ensureNotFreeInContext x body =</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="istickedoff">when (any (IntMap.member (vnIndex x) . varTypes) (varTypes body)) $</span>
<span class="lineno">  579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;Variable occurs free in typing context: &quot; ++ show (vnName x)</span></span></span>
<span class="lineno">  580 </span>
<span class="lineno">  581 </span>-- | Two typing contexts are unifiable if they agree perfectly on all
<span class="lineno">  582 </span>-- entries where they overlap.
<span class="lineno">  583 </span>unifyVarTypes :: String -&gt; SharedContext -&gt; IntMap Term -&gt; IntMap Term -&gt; IO (IntMap Term)
<span class="lineno">  584 </span><span class="decl"><span class="istickedoff">unifyVarTypes msg sc ctx1 ctx2 =</span>
<span class="lineno">  585 </span><span class="spaces">  </span><span class="istickedoff">do let check i t1 t2 =</span>
<span class="lineno">  586 </span><span class="spaces">           </span><span class="istickedoff">unless (t1 == t2) $ <span class="nottickedoff">do</span></span>
<span class="lineno">  587 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">t1' &lt;- ppTerm sc PPS.defaultOpts t1</span></span>
<span class="lineno">  588 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">t2' &lt;- ppTerm sc PPS.defaultOpts t2</span></span>
<span class="lineno">  589 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [</span></span>
<span class="lineno">  590 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">msg ++ &quot;: variable typing context mismatch&quot;,</span></span>
<span class="lineno">  591 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">&quot;VarIndex: &quot; ++ show i,</span></span>
<span class="lineno">  592 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">&quot;t1: &quot; ++ t1',</span></span>
<span class="lineno">  593 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">&quot;t2: &quot; ++ t2'</span></span>
<span class="lineno">  594 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  595 </span><span class="spaces">     </span><span class="istickedoff">sequence_ (IntMap.intersectionWithKey check ctx1 ctx2)</span>
<span class="lineno">  596 </span><span class="spaces">     </span><span class="istickedoff">pure (IntMap.union ctx1 ctx2)</span></span>
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>ensureRecognizer :: String -&gt; SharedContext -&gt; (Term -&gt; Maybe a) -&gt; Term -&gt; IO a
<span class="lineno">  599 </span><span class="decl"><span class="istickedoff">ensureRecognizer s sc f trm =</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="istickedoff">case f trm of</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="istickedoff">Just a -&gt; pure a</span>
<span class="lineno">  602 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  603 </span><span class="spaces">      </span><span class="istickedoff">do trm' &lt;- scWhnf sc trm</span>
<span class="lineno">  604 </span><span class="spaces">         </span><span class="istickedoff">case f trm' of</span>
<span class="lineno">  605 </span><span class="spaces">           </span><span class="istickedoff">Just a -&gt; pure a</span>
<span class="lineno">  606 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  607 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">trm'' &lt;- ppTerm sc PPS.defaultOpts trm'</span></span>
<span class="lineno">  608 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">fail $ &quot;ensureRecognizer: Expected &quot; ++ s ++ &quot;, found: &quot; ++ trm''</span></span></span>
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>ensureSort :: SharedContext -&gt; Term -&gt; IO Sort
<span class="lineno">  611 </span><span class="decl"><span class="nottickedoff">ensureSort sc tp = ensureRecognizer &quot;Sort&quot; sc asSort tp</span></span>
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>ensurePi :: SharedContext -&gt; Term -&gt; IO (VarName, Term, Term)
<span class="lineno">  614 </span><span class="decl"><span class="istickedoff">ensurePi sc tp = ensureRecognizer <span class="nottickedoff">&quot;Pi&quot;</span> sc asPi tp</span></span>
<span class="lineno">  615 </span>
<span class="lineno">  616 </span>ensurePairType :: SharedContext -&gt; Term -&gt; IO (Term, Term)
<span class="lineno">  617 </span><span class="decl"><span class="istickedoff">ensurePairType sc tp = ensureRecognizer <span class="nottickedoff">&quot;PairType&quot;</span> <span class="nottickedoff">sc</span> asPairType tp</span></span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>ensureRecordType :: SharedContext -&gt; Term -&gt; IO (Map FieldName Term)
<span class="lineno">  620 </span><span class="decl"><span class="istickedoff">ensureRecordType sc tp = ensureRecognizer <span class="nottickedoff">&quot;RecordType&quot;</span> sc asRecordType tp</span></span>
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>piSort :: Sort -&gt; Sort -&gt; Sort
<span class="lineno">  623 </span><span class="decl"><span class="istickedoff">piSort s1 s2 = if s2 == propSort then propSort else max s1 s2</span></span>
<span class="lineno">  624 </span>
<span class="lineno">  625 </span>--------------------------------------------------------------------------------
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>-- | Create a function application term from the 'Name' of a global
<span class="lineno">  628 </span>-- constant and a list of 'Term' arguments.
<span class="lineno">  629 </span>scConstApply :: SharedContext -&gt; Name -&gt; [Term] -&gt; IO Term
<span class="lineno">  630 </span><span class="decl"><span class="istickedoff">scConstApply sc i ts =</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">do c &lt;- scConst sc i</span>
<span class="lineno">  632 </span><span class="spaces">     </span><span class="istickedoff">scApplyAll sc c ts</span></span>
<span class="lineno">  633 </span>
<span class="lineno">  634 </span>-- | Create a list of named variables from a list of names and types.
<span class="lineno">  635 </span>scVariables :: Traversable t =&gt; SharedContext -&gt; t (VarName, Term) -&gt; IO (t Term)
<span class="lineno">  636 </span><span class="decl"><span class="istickedoff">scVariables sc = traverse (\(v, t) -&gt; scVariable sc v t)</span></span>
<span class="lineno">  637 </span>
<span class="lineno">  638 </span>data DuplicateNameException = DuplicateNameException URI
<span class="lineno">  639 </span>instance <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">Exception DuplicateNameException</span></span></span></span></span></span>
<span class="lineno">  640 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show DuplicateNameException</span></span></span></span> where
<span class="lineno">  641 </span>  <span class="decl"><span class="istickedoff">show (DuplicateNameException uri) =</span>
<span class="lineno">  642 </span><span class="spaces">      </span><span class="istickedoff">&quot;Attempted to register the following name twice: &quot; ++ Text.unpack (render uri)</span></span>
<span class="lineno">  643 </span>
<span class="lineno">  644 </span>-- | Internal function to get the next available 'VarIndex'. Not exported.
<span class="lineno">  645 </span>scFreshVarIndex :: SharedContext -&gt; IO VarIndex
<span class="lineno">  646 </span><span class="decl"><span class="istickedoff">scFreshVarIndex sc = atomicModifyIORef' (scNextVarIndex sc) (\i -&gt; (i + 1, i))</span></span>
<span class="lineno">  647 </span>
<span class="lineno">  648 </span>-- | Internal function to register a name with a caller-provided
<span class="lineno">  649 </span>-- 'VarIndex'. Not exported.
<span class="lineno">  650 </span>scRegisterNameWithIndex :: SharedContext -&gt; VarIndex -&gt; NameInfo -&gt; IO ()
<span class="lineno">  651 </span><span class="decl"><span class="istickedoff">scRegisterNameWithIndex sc i nmi =</span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="istickedoff">do uris &lt;- readIORef (scURIEnv sc)</span>
<span class="lineno">  653 </span><span class="spaces">     </span><span class="istickedoff">let uri = nameURI nmi</span>
<span class="lineno">  654 </span><span class="spaces">     </span><span class="istickedoff">when (Map.member uri uris) $ throwIO (DuplicateNameException uri)</span>
<span class="lineno">  655 </span><span class="spaces">     </span><span class="istickedoff">writeIORef (scURIEnv sc) (Map.insert uri i uris)</span>
<span class="lineno">  656 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scDisplayNameEnv sc) $ extendDisplayNameEnv i (nameAliases nmi)</span></span>
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>
<span class="lineno">  659 </span>-- | Generate a 'Name' with a fresh 'VarIndex' for the given
<span class="lineno">  660 </span>-- 'NameInfo' and register everything together in the naming
<span class="lineno">  661 </span>-- environment of the 'SharedContext'.
<span class="lineno">  662 </span>-- Throws 'DuplicateNameException' if the URI in the 'NameInfo' is
<span class="lineno">  663 </span>-- already registered.
<span class="lineno">  664 </span>scRegisterName :: SharedContext -&gt; NameInfo -&gt; IO Name
<span class="lineno">  665 </span><span class="decl"><span class="istickedoff">scRegisterName sc nmi =</span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="istickedoff">do i &lt;- scFreshVarIndex sc</span>
<span class="lineno">  667 </span><span class="spaces">     </span><span class="istickedoff">scRegisterNameWithIndex sc i nmi</span>
<span class="lineno">  668 </span><span class="spaces">     </span><span class="istickedoff">pure (Name i nmi)</span></span>
<span class="lineno">  669 </span>
<span class="lineno">  670 </span>scResolveNameByURI :: SharedContext -&gt; URI -&gt; IO (Maybe VarIndex)
<span class="lineno">  671 </span><span class="decl"><span class="istickedoff">scResolveNameByURI sc uri =</span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="istickedoff">do env &lt;- readIORef (scURIEnv sc)</span>
<span class="lineno">  673 </span><span class="spaces">     </span><span class="istickedoff">pure $! Map.lookup uri env</span></span>
<span class="lineno">  674 </span>
<span class="lineno">  675 </span>-- | Create a unique global name with the given base name.
<span class="lineno">  676 </span>scFreshName :: SharedContext -&gt; Text -&gt; IO Name
<span class="lineno">  677 </span><span class="decl"><span class="nottickedoff">scFreshName sc x =</span>
<span class="lineno">  678 </span><span class="spaces">  </span><span class="nottickedoff">do i &lt;- scFreshVarIndex sc</span>
<span class="lineno">  679 </span><span class="spaces">     </span><span class="nottickedoff">let uri = scFreshNameURI x i</span>
<span class="lineno">  680 </span><span class="spaces">     </span><span class="nottickedoff">let nmi = ImportedName uri [x, x &lt;&gt; &quot;#&quot; &lt;&gt;  Text.pack (show i)]</span>
<span class="lineno">  681 </span><span class="spaces">     </span><span class="nottickedoff">scRegisterNameWithIndex sc i nmi</span>
<span class="lineno">  682 </span><span class="spaces">     </span><span class="nottickedoff">pure (Name i nmi)</span></span>
<span class="lineno">  683 </span>
<span class="lineno">  684 </span>-- | Create a 'VarName' with the given identifier (which may be &quot;_&quot;).
<span class="lineno">  685 </span>scFreshVarName :: SharedContext -&gt; Text -&gt; IO VarName
<span class="lineno">  686 </span><span class="decl"><span class="istickedoff">scFreshVarName sc x = VarName &lt;$&gt; scFreshVarIndex sc &lt;*&gt; pure x</span></span>
<span class="lineno">  687 </span>
<span class="lineno">  688 </span>-- | Returns shared term associated with ident.
<span class="lineno">  689 </span>-- Does not check module namespace.
<span class="lineno">  690 </span>scGlobalDef :: SharedContext -&gt; Ident -&gt; IO Term
<span class="lineno">  691 </span><span class="decl"><span class="istickedoff">scGlobalDef sc ident =</span>
<span class="lineno">  692 </span><span class="spaces">  </span><span class="istickedoff">do m &lt;- readIORef (scGlobalEnv sc)</span>
<span class="lineno">  693 </span><span class="spaces">     </span><span class="istickedoff">case HMap.lookup ident m of</span>
<span class="lineno">  694 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail (&quot;Could not find global: &quot; ++ show ident)</span></span>
<span class="lineno">  695 </span><span class="spaces">       </span><span class="istickedoff">Just t -&gt; pure t</span></span>
<span class="lineno">  696 </span>
<span class="lineno">  697 </span>-- | Internal function to register an 'Ident' with a 'Term' (which
<span class="lineno">  698 </span>-- must be a 'Constant' term with the same 'Ident') in the
<span class="lineno">  699 </span>-- 'scGlobalEnv' map of the 'SharedContext'. Not exported.
<span class="lineno">  700 </span>scRegisterGlobal :: SharedContext -&gt; Ident -&gt; Term -&gt; IO ()
<span class="lineno">  701 </span><span class="decl"><span class="istickedoff">scRegisterGlobal sc ident t =</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="istickedoff">do dup &lt;- atomicModifyIORef' (scGlobalEnv sc) f</span>
<span class="lineno">  703 </span><span class="spaces">     </span><span class="istickedoff">when dup $ <span class="nottickedoff">fail (&quot;Global identifier already registered: &quot; ++ show ident)</span></span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">f m =</span>
<span class="lineno">  706 </span><span class="spaces">      </span><span class="istickedoff">case HMap.lookup ident m of</span>
<span class="lineno">  707 </span><span class="spaces">        </span><span class="istickedoff">Just _ -&gt; <span class="nottickedoff">(m, True)</span></span>
<span class="lineno">  708 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; (HMap.insert ident t m, False)</span></span>
<span class="lineno">  709 </span>
<span class="lineno">  710 </span>-- | Find a variant of an identifier that is not already being used as a global,
<span class="lineno">  711 </span>-- by possibly adding a numeric suffix
<span class="lineno">  712 </span>scFreshenGlobalIdent :: SharedContext -&gt; Ident -&gt; IO Ident
<span class="lineno">  713 </span><span class="decl"><span class="nottickedoff">scFreshenGlobalIdent sc ident =</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="nottickedoff">readIORef (scGlobalEnv sc) &gt;&gt;= \gmap -&gt;</span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="nottickedoff">return $ fromJust $ find (\i -&gt; not $ HMap.member i gmap) $</span>
<span class="lineno">  716 </span><span class="spaces">  </span><span class="nottickedoff">ident : map (mkIdent (identModule ident) .</span>
<span class="lineno">  717 </span><span class="spaces">               </span><span class="nottickedoff">Text.append (identBaseName ident) .</span>
<span class="lineno">  718 </span><span class="spaces">               </span><span class="nottickedoff">Text.pack . show) [(0::Integer) ..]</span></span>
<span class="lineno">  719 </span>
<span class="lineno">  720 </span>-- | Get the current naming environment
<span class="lineno">  721 </span>scGetNamingEnv :: SharedContext -&gt; IO DisplayNameEnv
<span class="lineno">  722 </span><span class="decl"><span class="istickedoff">scGetNamingEnv sc = readIORef (scDisplayNameEnv sc)</span></span>
<span class="lineno">  723 </span>
<span class="lineno">  724 </span>-- | Get the current 'ModuleMap'
<span class="lineno">  725 </span>scGetModuleMap :: SharedContext -&gt; IO ModuleMap
<span class="lineno">  726 </span><span class="decl"><span class="istickedoff">scGetModuleMap sc = readIORef (scModuleMap sc)</span></span>
<span class="lineno">  727 </span>
<span class="lineno">  728 </span>-- | Test if a module is loaded in the current shared context
<span class="lineno">  729 </span>scModuleIsLoaded :: SharedContext -&gt; ModuleName -&gt; IO Bool
<span class="lineno">  730 </span><span class="decl"><span class="istickedoff">scModuleIsLoaded sc name =</span>
<span class="lineno">  731 </span><span class="spaces">  </span><span class="istickedoff">moduleIsLoaded name &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  732 </span>
<span class="lineno">  733 </span>-- | Load a module into the current shared context, raising an error if a module
<span class="lineno">  734 </span>-- of the same name is already loaded
<span class="lineno">  735 </span>scLoadModule :: SharedContext -&gt; Module -&gt; IO ()
<span class="lineno">  736 </span><span class="decl"><span class="istickedoff">scLoadModule sc m =</span>
<span class="lineno">  737 </span><span class="spaces">  </span><span class="istickedoff">do loaded &lt;- scModuleIsLoaded sc (moduleName m)</span>
<span class="lineno">  738 </span><span class="spaces">     </span><span class="istickedoff">when loaded $ <span class="nottickedoff">fail $ &quot;scLoadModule: module &quot;</span></span>
<span class="lineno">  739 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">++ show (moduleName m) ++ &quot; already loaded!&quot;</span></span>
<span class="lineno">  740 </span><span class="spaces">     </span><span class="istickedoff">modifyIORef' (scModuleMap sc) (loadModule m)</span></span>
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>-- | Bring a subset of names from one module into scope in a second module.
<span class="lineno">  743 </span>scImportModule ::
<span class="lineno">  744 </span>  SharedContext -&gt;
<span class="lineno">  745 </span>  (Text -&gt; Bool) {- ^ which names to import -} -&gt;
<span class="lineno">  746 </span>  ModuleName {- ^ from this module -} -&gt;
<span class="lineno">  747 </span>  ModuleName {- ^ into this module -} -&gt;
<span class="lineno">  748 </span>  IO ()
<span class="lineno">  749 </span><span class="decl"><span class="istickedoff">scImportModule sc p mn1 mn2 =</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff">modifyIORef' (scModuleMap sc) (insImportInMap p mn1 mn2)</span></span>
<span class="lineno">  751 </span>
<span class="lineno">  752 </span>-- | Internal function to insert a definition into the 'ModuleMap' of
<span class="lineno">  753 </span>-- the 'SharedContext'. Throws 'DuplicateNameException' if the name is
<span class="lineno">  754 </span>-- already registered.
<span class="lineno">  755 </span>scInsDefInMap :: SharedContext -&gt; Def -&gt; IO ()
<span class="lineno">  756 </span><span class="decl"><span class="istickedoff">scInsDefInMap sc d =</span>
<span class="lineno">  757 </span><span class="spaces">  </span><span class="istickedoff">do e &lt;- atomicModifyIORef' (scModuleMap sc) $ \mm -&gt;</span>
<span class="lineno">  758 </span><span class="spaces">       </span><span class="istickedoff">case insDefInMap d mm of</span>
<span class="lineno">  759 </span><span class="spaces">         </span><span class="istickedoff">Left i -&gt; <span class="nottickedoff">(mm, Just (DuplicateNameException (moduleIdentToURI i)))</span></span>
<span class="lineno">  760 </span><span class="spaces">         </span><span class="istickedoff">Right mm' -&gt; (mm', Nothing)</span>
<span class="lineno">  761 </span><span class="spaces">     </span><span class="istickedoff">maybe (pure <span class="nottickedoff">()</span>) <span class="nottickedoff">throwIO</span> e</span></span>
<span class="lineno">  762 </span>
<span class="lineno">  763 </span>-- | Internal function to extend the SAWCore global environment with a
<span class="lineno">  764 </span>-- new constant, which may or may not have a definition. Not exported.
<span class="lineno">  765 </span>-- Assumes that the type and body (if present) are closed terms, and
<span class="lineno">  766 </span>-- that the body has the given type.
<span class="lineno">  767 </span>scDeclareDef ::
<span class="lineno">  768 </span>  SharedContext -&gt; Name -&gt; DefQualifier -&gt; Term -&gt; Maybe Term -&gt; IO Term
<span class="lineno">  769 </span><span class="decl"><span class="istickedoff">scDeclareDef sc nm q ty body =</span>
<span class="lineno">  770 </span><span class="spaces">  </span><span class="istickedoff">do scInsDefInMap sc $</span>
<span class="lineno">  771 </span><span class="spaces">       </span><span class="istickedoff">Def</span>
<span class="lineno">  772 </span><span class="spaces">       </span><span class="istickedoff">{ defName = nm</span>
<span class="lineno">  773 </span><span class="spaces">       </span><span class="istickedoff">, defQualifier = <span class="nottickedoff">q</span></span>
<span class="lineno">  774 </span><span class="spaces">       </span><span class="istickedoff">, defType = ty</span>
<span class="lineno">  775 </span><span class="spaces">       </span><span class="istickedoff">, defBody = body</span>
<span class="lineno">  776 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno">  777 </span><span class="spaces">     </span><span class="istickedoff">t &lt;- scConst sc nm</span>
<span class="lineno">  778 </span><span class="spaces">     </span><span class="istickedoff">-- Register constant in scGlobalEnv if it has an Ident name</span>
<span class="lineno">  779 </span><span class="spaces">     </span><span class="istickedoff">case nameInfo nm of</span>
<span class="lineno">  780 </span><span class="spaces">       </span><span class="istickedoff">ModuleIdentifier ident -&gt; scRegisterGlobal sc ident t</span>
<span class="lineno">  781 </span><span class="spaces">       </span><span class="istickedoff">ImportedName{} -&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  782 </span><span class="spaces">     </span><span class="istickedoff">pure t</span></span>
<span class="lineno">  783 </span>
<span class="lineno">  784 </span>-- | Declare a SAW core primitive of the specified type.
<span class="lineno">  785 </span>scDeclarePrim :: SharedContext -&gt; Ident -&gt; DefQualifier -&gt; Term -&gt; IO ()
<span class="lineno">  786 </span><span class="decl"><span class="istickedoff">scDeclarePrim sc ident q def_tp =</span>
<span class="lineno">  787 </span><span class="spaces">  </span><span class="istickedoff">do _ &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType def_tp)</span>
<span class="lineno">  788 </span><span class="spaces">     </span><span class="istickedoff">let nmi = ModuleIdentifier ident</span>
<span class="lineno">  789 </span><span class="spaces">     </span><span class="istickedoff">nm &lt;- scRegisterName sc nmi</span>
<span class="lineno">  790 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- scDeclareDef sc nm <span class="nottickedoff">q</span> def_tp Nothing</span>
<span class="lineno">  791 </span><span class="spaces">     </span><span class="istickedoff">pure <span class="nottickedoff">()</span></span></span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>-- Internal function
<span class="lineno">  794 </span>scFindDefBody :: SharedContext -&gt; VarIndex -&gt; IO (Maybe Term)
<span class="lineno">  795 </span><span class="decl"><span class="istickedoff">scFindDefBody sc vi =</span>
<span class="lineno">  796 </span><span class="spaces">  </span><span class="istickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  797 </span><span class="spaces">     </span><span class="istickedoff">case lookupVarIndexInMap vi mm of</span>
<span class="lineno">  798 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedDef d) -&gt; pure (defBody d)</span>
<span class="lineno">  799 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; pure Nothing</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>-- | Insert an \&quot;incomplete\&quot; datatype, used as part of building up a
<span class="lineno">  802 </span>-- 'DataType' to typecheck its constructors. The constructors must be
<span class="lineno">  803 </span>-- registered separately with 'scCompleteDataType'.
<span class="lineno">  804 </span>scBeginDataType ::
<span class="lineno">  805 </span>  SharedContext -&gt;
<span class="lineno">  806 </span>  Ident {- ^ The name of this datatype -} -&gt;
<span class="lineno">  807 </span>  [(VarName, Term)] {- ^ The context of parameters of this datatype -} -&gt;
<span class="lineno">  808 </span>  [(VarName, Term)] {- ^ The context of indices of this datatype -} -&gt;
<span class="lineno">  809 </span>  Sort {- ^ The universe of this datatype -} -&gt;
<span class="lineno">  810 </span>  IO Name
<span class="lineno">  811 </span><span class="decl"><span class="istickedoff">scBeginDataType sc dtIdent dtParams dtIndices dtSort =</span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff">do dtName &lt;- scRegisterName sc (ModuleIdentifier dtIdent)</span>
<span class="lineno">  813 </span><span class="spaces">     </span><span class="istickedoff">dtType &lt;- scPiList sc (dtParams ++ dtIndices) =&lt;&lt; scSort sc dtSort</span>
<span class="lineno">  814 </span><span class="spaces">     </span><span class="istickedoff">dtMotiveName &lt;- scFreshVarName sc &quot;p&quot;</span>
<span class="lineno">  815 </span><span class="spaces">     </span><span class="istickedoff">dtArgName &lt;- scFreshVarName sc &quot;arg&quot;</span>
<span class="lineno">  816 </span><span class="spaces">     </span><span class="istickedoff">let dt = DataType { dtCtors = <span class="nottickedoff">[]</span>, .. }</span>
<span class="lineno">  817 </span><span class="spaces">     </span><span class="istickedoff">e &lt;- atomicModifyIORef' (scModuleMap sc) $ \mm -&gt;</span>
<span class="lineno">  818 </span><span class="spaces">       </span><span class="istickedoff">case beginDataType dt mm of</span>
<span class="lineno">  819 </span><span class="spaces">         </span><span class="istickedoff">Left i -&gt; <span class="nottickedoff">(mm, Just (DuplicateNameException (moduleIdentToURI i)))</span></span>
<span class="lineno">  820 </span><span class="spaces">         </span><span class="istickedoff">Right mm' -&gt; (mm', Nothing)</span>
<span class="lineno">  821 </span><span class="spaces">     </span><span class="istickedoff">maybe (pure <span class="nottickedoff">()</span>) <span class="nottickedoff">throwIO</span> e</span>
<span class="lineno">  822 </span><span class="spaces">     </span><span class="istickedoff">scRegisterGlobal sc dtIdent =&lt;&lt; scConst sc dtName</span>
<span class="lineno">  823 </span><span class="spaces">     </span><span class="istickedoff">pure dtName</span></span>
<span class="lineno">  824 </span>
<span class="lineno">  825 </span>-- | Complete a datatype, by adding its constructors. See also 'scBeginDataType'.
<span class="lineno">  826 </span>scCompleteDataType :: SharedContext -&gt; Ident -&gt; [Ctor] -&gt; IO ()
<span class="lineno">  827 </span><span class="decl"><span class="istickedoff">scCompleteDataType sc dtIdent ctors =</span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="istickedoff">do e &lt;- atomicModifyIORef' (scModuleMap sc) $ \mm -&gt;</span>
<span class="lineno">  829 </span><span class="spaces">       </span><span class="istickedoff">case completeDataType dtIdent ctors mm of</span>
<span class="lineno">  830 </span><span class="spaces">         </span><span class="istickedoff">Left i -&gt; <span class="nottickedoff">(mm, Just (DuplicateNameException (moduleIdentToURI i)))</span></span>
<span class="lineno">  831 </span><span class="spaces">         </span><span class="istickedoff">Right mm' -&gt; (mm', Nothing)</span>
<span class="lineno">  832 </span><span class="spaces">     </span><span class="istickedoff">maybe (pure <span class="nottickedoff">()</span>) <span class="nottickedoff">throwIO</span> e</span>
<span class="lineno">  833 </span><span class="spaces">     </span><span class="istickedoff">forM_ ctors $ \ctor -&gt;</span>
<span class="lineno">  834 </span><span class="spaces">       </span><span class="istickedoff">case nameInfo (ctorName ctor) of</span>
<span class="lineno">  835 </span><span class="spaces">         </span><span class="istickedoff">ModuleIdentifier ident -&gt;</span>
<span class="lineno">  836 </span><span class="spaces">           </span><span class="istickedoff">-- register constructor in scGlobalEnv if it has an Ident name</span>
<span class="lineno">  837 </span><span class="spaces">           </span><span class="istickedoff">scRegisterGlobal sc ident =&lt;&lt; scConst sc (ctorName ctor)</span>
<span class="lineno">  838 </span><span class="spaces">         </span><span class="istickedoff">ImportedName{} -&gt;</span>
<span class="lineno">  839 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">pure ()</span></span></span>
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>-- | Insert an \&quot;injectCode\&quot; declaration to the given SAWCore module.
<span class="lineno">  842 </span>-- This declaration has no logical effect within SAW; it is used to
<span class="lineno">  843 </span>-- add extra code (like class instance declarations, for example) to
<span class="lineno">  844 </span>-- exported SAWCore modules in certain translation backends.
<span class="lineno">  845 </span>scInjectCode ::
<span class="lineno">  846 </span>  SharedContext -&gt;
<span class="lineno">  847 </span>  ModuleName -&gt;
<span class="lineno">  848 </span>  Text {- ^ Code namespace -} -&gt;
<span class="lineno">  849 </span>  Text {- ^ Code to inject -} -&gt;
<span class="lineno">  850 </span>  IO ()
<span class="lineno">  851 </span><span class="decl"><span class="istickedoff">scInjectCode sc mnm ns txt =</span>
<span class="lineno">  852 </span><span class="spaces">  </span><span class="istickedoff">modifyIORef' (scModuleMap sc) $ insInjectCodeInMap mnm <span class="nottickedoff">ns</span> <span class="nottickedoff">txt</span></span></span>
<span class="lineno">  853 </span>
<span class="lineno">  854 </span>--------------------------------------------------------------------------------
<span class="lineno">  855 </span>-- Recursors
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>scRecursor :: SharedContext -&gt; Name -&gt; Sort -&gt; IO Term
<span class="lineno">  858 </span><span class="decl"><span class="istickedoff">scRecursor sc nm s =</span>
<span class="lineno">  859 </span><span class="spaces">  </span><span class="istickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  860 </span><span class="spaces">     </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  861 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedDataType dt) -&gt;</span>
<span class="lineno">  862 </span><span class="spaces">         </span><span class="istickedoff">do unless (allowedElimSort dt s) $ <span class="nottickedoff">fail &quot;Disallowed propositional elimination&quot;</span></span>
<span class="lineno">  863 </span><span class="spaces">            </span><span class="istickedoff">let d = dtName dt</span>
<span class="lineno">  864 </span><span class="spaces">            </span><span class="istickedoff">let nparams = length (dtParams dt)</span>
<span class="lineno">  865 </span><span class="spaces">            </span><span class="istickedoff">let nixs = length (dtIndices dt)</span>
<span class="lineno">  866 </span><span class="spaces">            </span><span class="istickedoff">let ctorOrder = map ctorName (dtCtors dt)</span>
<span class="lineno">  867 </span><span class="spaces">            </span><span class="istickedoff">let crec = CompiledRecursor d s nparams nixs ctorOrder</span>
<span class="lineno">  868 </span><span class="spaces">            </span><span class="istickedoff">let vt = IntMap.empty</span>
<span class="lineno">  869 </span><span class="spaces">            </span><span class="istickedoff">let tf = FTermF (Recursor crec)</span>
<span class="lineno">  870 </span><span class="spaces">            </span><span class="istickedoff">ty &lt;- scRecursorType sc dt s</span>
<span class="lineno">  871 </span><span class="spaces">            </span><span class="istickedoff">scMakeTerm sc vt tf (Right ty)</span>
<span class="lineno">  872 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  873 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">fail &quot;datatype not found&quot;</span></span></span>
<span class="lineno">  874 </span>
<span class="lineno">  875 </span>-- | Test whether a 'DataType' can be eliminated to the given sort. The rules
<span class="lineno">  876 </span>-- are that you can only eliminate propositional datatypes to the proposition
<span class="lineno">  877 </span>-- sort, unless your propositional data type is the empty type. This differs
<span class="lineno">  878 </span>-- slightly from the Coq rules, which allow elimination of propositional
<span class="lineno">  879 </span>-- datatypes with a single constructor that has only propositional arguments,
<span class="lineno">  880 </span>-- but this Coq behavior can be simulated with the behavior we are using here.
<span class="lineno">  881 </span>allowedElimSort :: DataType -&gt; Sort -&gt; Bool
<span class="lineno">  882 </span><span class="decl"><span class="istickedoff">allowedElimSort dt s =</span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="istickedoff">if dtSort dt == propSort &amp;&amp; s /= propSort then</span>
<span class="lineno">  884 </span><span class="spaces">    </span><span class="istickedoff">length (dtCtors dt) == 1</span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">else True</span></span>
<span class="lineno">  886 </span>
<span class="lineno">  887 </span>-- | Compute the type of an eliminator function for a constructor from the name
<span class="lineno">  888 </span>-- of its datatype, its name, and its 'CtorArgStruct'. This type has, as free
<span class="lineno">  889 </span>-- variables, both the parameters of the datatype and a &quot;motive&quot; function from
<span class="lineno">  890 </span>-- indices of the datatype to a return type. It is of the form
<span class="lineno">  891 </span>--
<span class="lineno">  892 </span>-- &gt; (x1::arg1) -&gt; maybe (rec1::rec_tp1) -&gt; .. -&gt;
<span class="lineno">  893 </span>-- &gt; (xn::argn) -&gt; maybe (recn::rec_tpn) -&gt;
<span class="lineno">  894 </span>-- &gt;   p_ret ix_1 .. ix_k (ctor params x1 .. xn)
<span class="lineno">  895 </span>--
<span class="lineno">  896 </span>-- where the ixs are the type indices of the return type for the constructor,
<span class="lineno">  897 </span>-- the (xi::argi) are the arguments of the constructor, and the @maybe@s
<span class="lineno">  898 </span>-- indicate additional arguments that are present only for arguments of
<span class="lineno">  899 </span>-- recursive type, that is, where @argi@ has the form
<span class="lineno">  900 </span>--
<span class="lineno">  901 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk
<span class="lineno">  902 </span>--
<span class="lineno">  903 </span>-- In this case, @rec_tpi@ has the form
<span class="lineno">  904 </span>--
<span class="lineno">  905 </span>-- &gt; (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (f z1 .. zm)
<span class="lineno">  906 </span>--
<span class="lineno">  907 </span>-- Note that the output type cannot be expressed in the type of this function,
<span class="lineno">  908 </span>-- since it depends on fields of the 'CtorArgStruct', so, instead, the result is
<span class="lineno">  909 </span>-- just casted to whatever type the caller specifies.
<span class="lineno">  910 </span>ctxCtorElimType ::
<span class="lineno">  911 </span>  SharedContext -&gt;
<span class="lineno">  912 </span>  Name {- ^ data type name -} -&gt;
<span class="lineno">  913 </span>  Name {- ^ constructor name -} -&gt;
<span class="lineno">  914 </span>  Term {- ^ motive function -} -&gt;
<span class="lineno">  915 </span>  CtorArgStruct -&gt;
<span class="lineno">  916 </span>  IO Term
<span class="lineno">  917 </span><span class="decl"><span class="istickedoff">ctxCtorElimType sc d c p_ret (CtorArgStruct{..}) =</span>
<span class="lineno">  918 </span><span class="spaces">  </span><span class="istickedoff">do params &lt;- scVariables sc ctorParams</span>
<span class="lineno">  919 </span><span class="spaces">     </span><span class="istickedoff">d_params &lt;- scConstApply sc d params</span>
<span class="lineno">  920 </span><span class="spaces">     </span><span class="istickedoff">let helper :: [Term] -&gt; [(VarName, CtorArg)] -&gt; IO Term</span>
<span class="lineno">  921 </span><span class="spaces">         </span><span class="istickedoff">helper prevs ((nm, ConstArg tp) : args) =</span>
<span class="lineno">  922 </span><span class="spaces">           </span><span class="istickedoff">-- For a constant argument type, just abstract it and continue</span>
<span class="lineno">  923 </span><span class="spaces">           </span><span class="istickedoff">do arg &lt;- scVariable sc nm tp</span>
<span class="lineno">  924 </span><span class="spaces">              </span><span class="istickedoff">rest &lt;- helper (prevs ++ [arg]) args</span>
<span class="lineno">  925 </span><span class="spaces">              </span><span class="istickedoff">scPi sc nm tp rest</span>
<span class="lineno">  926 </span><span class="spaces">         </span><span class="istickedoff">helper prevs ((nm, RecursiveArg zs ts) : args) =</span>
<span class="lineno">  927 </span><span class="spaces">           </span><span class="istickedoff">-- For a recursive argument type of the form</span>
<span class="lineno">  928 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  929 </span><span class="spaces">           </span><span class="istickedoff">-- (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk</span>
<span class="lineno">  930 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  931 </span><span class="spaces">           </span><span class="istickedoff">-- form the type abstraction</span>
<span class="lineno">  932 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  933 </span><span class="spaces">           </span><span class="istickedoff">-- (arg:: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; d params t1 .. tk) -&gt;</span>
<span class="lineno">  934 </span><span class="spaces">           </span><span class="istickedoff">-- (ih :: (z1::Z1) -&gt; .. -&gt; (zm::Zm) -&gt; p_ret t1 .. tk (arg z1 .. zm)) -&gt;</span>
<span class="lineno">  935 </span><span class="spaces">           </span><span class="istickedoff">-- rest</span>
<span class="lineno">  936 </span><span class="spaces">           </span><span class="istickedoff">--</span>
<span class="lineno">  937 </span><span class="spaces">           </span><span class="istickedoff">-- where rest is the result of a recursive call</span>
<span class="lineno">  938 </span><span class="spaces">           </span><span class="istickedoff">do d_params_ts &lt;- scApplyAll sc d_params ts</span>
<span class="lineno">  939 </span><span class="spaces">              </span><span class="istickedoff">-- Build the type of the argument arg</span>
<span class="lineno">  940 </span><span class="spaces">              </span><span class="istickedoff">arg_tp &lt;- scPiList <span class="nottickedoff">sc</span> zs d_params_ts</span>
<span class="lineno">  941 </span><span class="spaces">              </span><span class="istickedoff">arg &lt;- scVariable sc nm arg_tp</span>
<span class="lineno">  942 </span><span class="spaces">              </span><span class="istickedoff">-- Build the type of ih</span>
<span class="lineno">  943 </span><span class="spaces">              </span><span class="istickedoff">pret_ts &lt;- scApplyAll sc p_ret ts</span>
<span class="lineno">  944 </span><span class="spaces">              </span><span class="istickedoff">z_vars &lt;- scVariables <span class="nottickedoff">sc</span> zs</span>
<span class="lineno">  945 </span><span class="spaces">              </span><span class="istickedoff">arg_zs &lt;- scApplyAll <span class="nottickedoff">sc</span> arg z_vars</span>
<span class="lineno">  946 </span><span class="spaces">              </span><span class="istickedoff">ih_ret &lt;- scApply sc pret_ts arg_zs</span>
<span class="lineno">  947 </span><span class="spaces">              </span><span class="istickedoff">ih_tp &lt;- scPiList <span class="nottickedoff">sc</span> zs ih_ret</span>
<span class="lineno">  948 </span><span class="spaces">              </span><span class="istickedoff">-- Finally, build the pi-abstraction for arg and ih around the rest</span>
<span class="lineno">  949 </span><span class="spaces">              </span><span class="istickedoff">rest &lt;- helper (prevs ++ [arg]) args</span>
<span class="lineno">  950 </span><span class="spaces">              </span><span class="istickedoff">scPi sc nm arg_tp =&lt;&lt; scFun sc ih_tp rest</span>
<span class="lineno">  951 </span><span class="spaces">         </span><span class="istickedoff">helper prevs [] =</span>
<span class="lineno">  952 </span><span class="spaces">           </span><span class="istickedoff">-- If we are finished with our arguments, construct the final result type</span>
<span class="lineno">  953 </span><span class="spaces">           </span><span class="istickedoff">-- (p_ret ret_ixs (c params prevs))</span>
<span class="lineno">  954 </span><span class="spaces">           </span><span class="istickedoff">do p_ret_ixs &lt;- scApplyAll sc p_ret ctorIndices</span>
<span class="lineno">  955 </span><span class="spaces">              </span><span class="istickedoff">appliedCtor &lt;- scConstApply sc c (params ++ prevs)</span>
<span class="lineno">  956 </span><span class="spaces">              </span><span class="istickedoff">scApply sc p_ret_ixs appliedCtor</span>
<span class="lineno">  957 </span><span class="spaces">     </span><span class="istickedoff">helper [] ctorArgs</span></span>
<span class="lineno">  958 </span>
<span class="lineno">  959 </span>-- | Reduce an application of a recursor to a particular constructor.
<span class="lineno">  960 </span>-- This is known in the Coq literature as an iota reduction. More specifically,
<span class="lineno">  961 </span>-- the call
<span class="lineno">  962 </span>--
<span class="lineno">  963 </span>-- &gt; ctxReduceRecursor rec f_c [x1, .., xk]
<span class="lineno">  964 </span>--
<span class="lineno">  965 </span>-- reduces the term @(RecursorApp rec ixs (CtorApp c ps xs))@ to
<span class="lineno">  966 </span>--
<span class="lineno">  967 </span>-- &gt; f_c x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno">  968 </span>--
<span class="lineno">  969 </span>-- where @f_c@ is the eliminator function associated to the constructor @c@ by the
<span class="lineno">  970 </span>-- recursor value @rec@.  Here @maybe rec_tm_i@ indicates an optional recursive call
<span class="lineno">  971 </span>-- of the recursor on one of the @xi@. These recursive calls only exist for those
<span class="lineno">  972 </span>-- arguments @xi@ that are recursive arguments, i.e., that are specified with
<span class="lineno">  973 </span>-- 'RecursiveArg', and are omitted for non-recursive arguments specified by 'ConstArg'.
<span class="lineno">  974 </span>--
<span class="lineno">  975 </span>-- Specifically, for a @'RecursiveArg' zs ixs@ argument @xi@, which has type
<span class="lineno">  976 </span>-- @\(z1::Z1) -&gt; .. -&gt; d p1 .. pn ix1 .. ixp@, we build the recursive call
<span class="lineno">  977 </span>--
<span class="lineno">  978 </span>-- &gt; \(z1::[xs/args]Z1) -&gt; .. -&gt;
<span class="lineno">  979 </span>-- &gt;   RecursorApp rec [xs/args]ixs (xi z1 ... zn)
<span class="lineno">  980 </span>--
<span class="lineno">  981 </span>-- where @[xs/args]@ substitutes the concrete values for the earlier
<span class="lineno">  982 </span>-- constructor arguments @xs@ for the remaining free variables.
<span class="lineno">  983 </span>
<span class="lineno">  984 </span>ctxReduceRecursor ::
<span class="lineno">  985 </span>  SharedContext -&gt;
<span class="lineno">  986 </span>  Term {- ^ recursor applied to params, motive, and eliminator functions -} -&gt;
<span class="lineno">  987 </span>  Term {- ^ constructor eliminator function -} -&gt;
<span class="lineno">  988 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno">  989 </span>  CtorArgStruct {- ^ constructor formal argument descriptor -} -&gt;
<span class="lineno">  990 </span>  IO Term
<span class="lineno">  991 </span><span class="decl"><span class="istickedoff">ctxReduceRecursor sc r elimf c_args CtorArgStruct{..}</span>
<span class="lineno">  992 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlyfalse">length c_args /= length ctorArgs</span> = <span class="nottickedoff">panic &quot;ctxReduceRecursor&quot; [&quot;Wrong number of constructor arguments&quot;]</span></span>
<span class="lineno">  993 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  994 </span><span class="spaces">    </span><span class="istickedoff">do args &lt;- mk_args IntMap.empty (zip c_args ctorArgs)</span>
<span class="lineno">  995 </span><span class="spaces">       </span><span class="istickedoff">scWhnf sc =&lt;&lt; scApplyAll sc elimf args</span>
<span class="lineno">  996 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  997 </span><span class="spaces">    </span><span class="istickedoff">mk_args :: IntMap Term -&gt;  -- already processed parameters/arguments</span>
<span class="lineno">  998 </span><span class="spaces">               </span><span class="istickedoff">[(Term, (VarName, CtorArg))] -&gt;</span>
<span class="lineno">  999 </span><span class="spaces">                 </span><span class="istickedoff">-- remaining actual arguments to process, with</span>
<span class="lineno"> 1000 </span><span class="spaces">                 </span><span class="istickedoff">-- telescope for typing the actual arguments</span>
<span class="lineno"> 1001 </span><span class="spaces">               </span><span class="istickedoff">IO [Term]</span>
<span class="lineno"> 1002 </span><span class="spaces">    </span><span class="istickedoff">-- no more arguments to process</span>
<span class="lineno"> 1003 </span><span class="spaces">    </span><span class="istickedoff">mk_args _ [] = return []</span>
<span class="lineno"> 1004 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1005 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is not a recursive call</span>
<span class="lineno"> 1006 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (nm, ConstArg _)) : xs_args) =</span>
<span class="lineno"> 1007 </span><span class="spaces">      </span><span class="istickedoff">do tl &lt;- mk_args (IntMap.insert (vnIndex nm) x pre_xs) xs_args</span>
<span class="lineno"> 1008 </span><span class="spaces">         </span><span class="istickedoff">pure (x : tl)</span>
<span class="lineno"> 1009 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1010 </span><span class="spaces">    </span><span class="istickedoff">-- process an argument that is a recursive call</span>
<span class="lineno"> 1011 </span><span class="spaces">    </span><span class="istickedoff">mk_args pre_xs ((x, (nm, RecursiveArg zs ixs)) : xs_args) =</span>
<span class="lineno"> 1012 </span><span class="spaces">      </span><span class="istickedoff">do zs'  &lt;- traverse <span class="nottickedoff">(traverse (scInstantiate sc pre_xs))</span> zs</span>
<span class="lineno"> 1013 </span><span class="spaces">         </span><span class="istickedoff">ixs' &lt;- traverse (scInstantiate <span class="nottickedoff">sc</span> pre_xs) ixs</span>
<span class="lineno"> 1014 </span><span class="spaces">         </span><span class="istickedoff">recx &lt;- mk_rec_arg zs' ixs' x</span>
<span class="lineno"> 1015 </span><span class="spaces">         </span><span class="istickedoff">tl   &lt;- mk_args <span class="nottickedoff">(IntMap.insert (vnIndex nm) x pre_xs)</span> xs_args</span>
<span class="lineno"> 1016 </span><span class="spaces">         </span><span class="istickedoff">pure (x : recx : tl)</span>
<span class="lineno"> 1017 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1018 </span><span class="spaces">    </span><span class="istickedoff">-- Build an individual recursive call, given the parameters, the bindings</span>
<span class="lineno"> 1019 </span><span class="spaces">    </span><span class="istickedoff">-- for the RecursiveArg, and the argument we are going to recurse on</span>
<span class="lineno"> 1020 </span><span class="spaces">    </span><span class="istickedoff">-- The resulting term has the form</span>
<span class="lineno"> 1021 </span><span class="spaces">    </span><span class="istickedoff">-- &gt; \(z1:Z1) .. (zk:Zk) -&gt; r ixs (x z1 .. zk)</span>
<span class="lineno"> 1022 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg ::</span>
<span class="lineno"> 1023 </span><span class="spaces">      </span><span class="istickedoff">[(VarName, Term)] -&gt;             -- telescope describing the zs</span>
<span class="lineno"> 1024 </span><span class="spaces">      </span><span class="istickedoff">[Term] -&gt;                        -- actual values for the indices, shifted under zs</span>
<span class="lineno"> 1025 </span><span class="spaces">      </span><span class="istickedoff">Term -&gt;                         -- actual value in recursive position</span>
<span class="lineno"> 1026 </span><span class="spaces">      </span><span class="istickedoff">IO Term</span>
<span class="lineno"> 1027 </span><span class="spaces">    </span><span class="istickedoff">mk_rec_arg zs_ctx ixs x =</span>
<span class="lineno"> 1028 </span><span class="spaces">      </span><span class="istickedoff">-- eta expand over the zs and apply the Recursor form</span>
<span class="lineno"> 1029 </span><span class="spaces">      </span><span class="istickedoff">do zs &lt;- scVariables <span class="nottickedoff">sc</span> zs_ctx</span>
<span class="lineno"> 1030 </span><span class="spaces">         </span><span class="istickedoff">x_zs &lt;- scApplyAll <span class="nottickedoff">sc</span> x zs</span>
<span class="lineno"> 1031 </span><span class="spaces">         </span><span class="istickedoff">r_ixs &lt;- scApplyAll sc r ixs</span>
<span class="lineno"> 1032 </span><span class="spaces">         </span><span class="istickedoff">body &lt;- scApply sc r_ixs x_zs</span>
<span class="lineno"> 1033 </span><span class="spaces">         </span><span class="istickedoff">scLambdaList <span class="nottickedoff">sc</span> zs_ctx body</span></span>
<span class="lineno"> 1034 </span>
<span class="lineno"> 1035 </span>-- | Build the type of the @p_ret@ function, also known as the &quot;motive&quot;
<span class="lineno"> 1036 </span>-- function, of a recursor on datatype @d@. This type has the form
<span class="lineno"> 1037 </span>--
<span class="lineno"> 1038 </span>-- &gt; (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s
<span class="lineno"> 1039 </span>--
<span class="lineno"> 1040 </span>-- where the @pi@ are the parameters of @d@, the @ixj@ are the indices
<span class="lineno"> 1041 </span>-- of @d@, and @s@ is any sort supplied as an argument.
<span class="lineno"> 1042 </span>-- Parameter variables @p1 .. pn@ will be free in the resulting term.
<span class="lineno"> 1043 </span>scRecursorMotiveType :: SharedContext -&gt; DataType -&gt; Sort -&gt; IO Term
<span class="lineno"> 1044 </span><span class="decl"><span class="istickedoff">scRecursorMotiveType sc dt s =</span>
<span class="lineno"> 1045 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- scVariables sc (dtParams dt)</span>
<span class="lineno"> 1046 </span><span class="spaces">     </span><span class="istickedoff">ix_vars &lt;- scVariables sc (dtIndices dt)</span>
<span class="lineno"> 1047 </span><span class="spaces">     </span><span class="istickedoff">d &lt;- scConstApply sc (dtName dt) (param_vars ++ ix_vars)</span>
<span class="lineno"> 1048 </span><span class="spaces">     </span><span class="istickedoff">ret &lt;- scFun sc d =&lt;&lt; scSort sc s</span>
<span class="lineno"> 1049 </span><span class="spaces">     </span><span class="istickedoff">scPiList sc (dtIndices dt) ret</span></span>
<span class="lineno"> 1050 </span>
<span class="lineno"> 1051 </span>-- | Build the type of a recursor for datatype @d@ that has been
<span class="lineno"> 1052 </span>-- applied to parameters, a motive function, and a full set of
<span class="lineno"> 1053 </span>-- eliminator functions. This type has the form
<span class="lineno"> 1054 </span>--
<span class="lineno"> 1055 </span>-- &gt; (i1:ix1) -&gt; .. -&gt; (im:ixm) -&gt;
<span class="lineno"> 1056 </span>-- &gt;   (arg : d p1 .. pn i1 .. im) -&gt; motive i1 .. im arg
<span class="lineno"> 1057 </span>--
<span class="lineno"> 1058 </span>-- where the @pi@ are the parameters of @d@, and the @ixj@ are the
<span class="lineno"> 1059 </span>-- indices of @d@.
<span class="lineno"> 1060 </span>-- Parameter variables @p1 .. pn@ will be free in the resulting term.
<span class="lineno"> 1061 </span>scRecursorAppType :: SharedContext -&gt; DataType -&gt; Term -&gt; IO Term
<span class="lineno"> 1062 </span><span class="decl"><span class="istickedoff">scRecursorAppType sc dt motive =</span>
<span class="lineno"> 1063 </span><span class="spaces">  </span><span class="istickedoff">do param_vars &lt;- scVariables sc (dtParams dt)</span>
<span class="lineno"> 1064 </span><span class="spaces">     </span><span class="istickedoff">ix_vars &lt;- scVariables sc (dtIndices dt)</span>
<span class="lineno"> 1065 </span><span class="spaces">     </span><span class="istickedoff">d &lt;- scConstApply sc (dtName dt) (param_vars ++ ix_vars)</span>
<span class="lineno"> 1066 </span><span class="spaces">     </span><span class="istickedoff">let arg_vn = dtArgName dt</span>
<span class="lineno"> 1067 </span><span class="spaces">     </span><span class="istickedoff">arg_var &lt;- scVariable sc arg_vn d</span>
<span class="lineno"> 1068 </span><span class="spaces">     </span><span class="istickedoff">ret &lt;- scApplyAll sc motive (ix_vars ++ [arg_var])</span>
<span class="lineno"> 1069 </span><span class="spaces">     </span><span class="istickedoff">scPiList sc (dtIndices dt ++ [(arg_vn, d)]) ret</span></span>
<span class="lineno"> 1070 </span>
<span class="lineno"> 1071 </span>-- | Build the full type of an unapplied recursor for datatype @d@
<span class="lineno"> 1072 </span>-- with elimination to sort @s@.
<span class="lineno"> 1073 </span>-- This type has the form
<span class="lineno"> 1074 </span>--
<span class="lineno"> 1075 </span>-- &gt; (p1:pt1) -&gt; .. -&gt; (pn::ptn) -&gt;
<span class="lineno"> 1076 </span>-- &gt; (motive : (i1::ix1) -&gt; .. -&gt; (im::ixm) -&gt; d p1 .. pn i1 .. im -&gt; s) -&gt;
<span class="lineno"> 1077 </span>-- &gt; (elim1 : ..) -&gt; .. (elimk : ..) -&gt;
<span class="lineno"> 1078 </span>-- &gt; (i1:ix1) -&gt; .. -&gt; (im:ixm) -&gt;
<span class="lineno"> 1079 </span>-- &gt;   (arg : d p1 .. pn i1 .. im) -&gt; motive i1 .. im arg
<span class="lineno"> 1080 </span>scRecursorType :: SharedContext -&gt; DataType -&gt; Sort -&gt; IO Term
<span class="lineno"> 1081 </span><span class="decl"><span class="istickedoff">scRecursorType sc dt s =</span>
<span class="lineno"> 1082 </span><span class="spaces">  </span><span class="istickedoff">do let d = dtName dt</span>
<span class="lineno"> 1083 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1084 </span><span class="spaces">     </span><span class="istickedoff">-- Compute the type of the motive function, which has the form</span>
<span class="lineno"> 1085 </span><span class="spaces">     </span><span class="istickedoff">-- (i1:ix1) -&gt; .. -&gt; (im:ixm) -&gt; d p1 .. pn i1 .. im -&gt; s</span>
<span class="lineno"> 1086 </span><span class="spaces">     </span><span class="istickedoff">motive_ty &lt;- scRecursorMotiveType sc dt s</span>
<span class="lineno"> 1087 </span><span class="spaces">     </span><span class="istickedoff">let motive_vn = dtMotiveName dt</span>
<span class="lineno"> 1088 </span><span class="spaces">     </span><span class="istickedoff">motive_var &lt;- scVariable sc motive_vn motive_ty</span>
<span class="lineno"> 1089 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1090 </span><span class="spaces">     </span><span class="istickedoff">-- Compute the types of the elimination functions</span>
<span class="lineno"> 1091 </span><span class="spaces">     </span><span class="istickedoff">elims_tps &lt;-</span>
<span class="lineno"> 1092 </span><span class="spaces">       </span><span class="istickedoff">forM (dtCtors dt) $ \ctor -&gt;</span>
<span class="lineno"> 1093 </span><span class="spaces">       </span><span class="istickedoff">ctxCtorElimType sc d (ctorName ctor) motive_var (ctorArgStruct ctor)</span>
<span class="lineno"> 1094 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1095 </span><span class="spaces">     </span><span class="istickedoff">scPiList sc (dtParams dt) =&lt;&lt;</span>
<span class="lineno"> 1096 </span><span class="spaces">       </span><span class="istickedoff">scPi sc motive_vn motive_ty =&lt;&lt;</span>
<span class="lineno"> 1097 </span><span class="spaces">       </span><span class="istickedoff">scFunAll sc elims_tps =&lt;&lt;</span>
<span class="lineno"> 1098 </span><span class="spaces">       </span><span class="istickedoff">scRecursorAppType sc dt motive_var</span></span>
<span class="lineno"> 1099 </span>
<span class="lineno"> 1100 </span>-- | Reduce an application of a recursor. This is known in the Coq literature as
<span class="lineno"> 1101 </span>-- an iota reduction. More specifically, the call
<span class="lineno"> 1102 </span>--
<span class="lineno"> 1103 </span>-- &gt; scReduceRecursor sc rec crec ci [x1, .., xk]
<span class="lineno"> 1104 </span>--
<span class="lineno"> 1105 </span>-- reduces the term @(Recursor r elims ixs (CtorApp ci ps xs))@ to
<span class="lineno"> 1106 </span>--
<span class="lineno"> 1107 </span>-- &gt; fi x1 (maybe rec_tm_1) .. xk (maybe rec_tm_k)
<span class="lineno"> 1108 </span>--
<span class="lineno"> 1109 </span>-- where @maybe rec_tm_i@ indicates an optional recursive call of the recursor
<span class="lineno"> 1110 </span>-- on one of the @xi@. These recursive calls only exist for those arguments
<span class="lineno"> 1111 </span>-- @xi@. See the documentation for 'ctxReduceRecursor' and the
<span class="lineno"> 1112 </span>-- 'ctorIotaReduction' field for more details.
<span class="lineno"> 1113 </span>scReduceRecursor ::
<span class="lineno"> 1114 </span>  SharedContext -&gt;
<span class="lineno"> 1115 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno"> 1116 </span>  CompiledRecursor {- ^ concrete data included in the recursor term -} -&gt;
<span class="lineno"> 1117 </span>  [Term] {- ^ datatype parameters -} -&gt;
<span class="lineno"> 1118 </span>  Term {- ^ motive function -} -&gt;
<span class="lineno"> 1119 </span>  [Term] {- ^ eliminator functions -} -&gt;
<span class="lineno"> 1120 </span>  Name {- ^ constructor name -} -&gt;
<span class="lineno"> 1121 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno"> 1122 </span>  IO Term
<span class="lineno"> 1123 </span><span class="decl"><span class="istickedoff">scReduceRecursor sc r crec params motive elims c args =</span>
<span class="lineno"> 1124 </span><span class="spaces">  </span><span class="istickedoff">do mres &lt;- lookupVarIndexInMap (nameIndex c) &lt;$&gt; scGetModuleMap sc</span>
<span class="lineno"> 1125 </span><span class="spaces">     </span><span class="istickedoff">let cs_fs = Map.fromList (zip (map nameIndex (recursorCtorOrder crec)) elims)</span>
<span class="lineno"> 1126 </span><span class="spaces">     </span><span class="istickedoff">r_applied &lt;- scApplyAll sc r (params ++ motive : elims)</span>
<span class="lineno"> 1127 </span><span class="spaces">     </span><span class="istickedoff">case mres of</span>
<span class="lineno"> 1128 </span><span class="spaces">       </span><span class="istickedoff">Just (ResolvedCtor ctor) -&gt;</span>
<span class="lineno"> 1129 </span><span class="spaces">         </span><span class="istickedoff">-- The ctorIotaReduction field caches the result of iota reduction, which</span>
<span class="lineno"> 1130 </span><span class="spaces">         </span><span class="istickedoff">-- we just substitute into to perform the reduction</span>
<span class="lineno"> 1131 </span><span class="spaces">         </span><span class="istickedoff">ctorIotaReduction sc ctor r_applied cs_fs args</span>
<span class="lineno"> 1132 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1133 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">panic &quot;scReduceRecursor&quot; [&quot;Could not find constructor: &quot; &lt;&gt; toAbsoluteName (nameInfo c)]</span></span></span>
<span class="lineno"> 1134 </span>
<span class="lineno"> 1135 </span>-- | Function for computing the result of one step of iota reduction
<span class="lineno"> 1136 </span>-- of the term
<span class="lineno"> 1137 </span>--
<span class="lineno"> 1138 </span>-- &gt; dt#rec params elims ixs (c params args)
<span class="lineno"> 1139 </span>--
<span class="lineno"> 1140 </span>-- The arguments to this function are the recursor value (applied to
<span class="lineno"> 1141 </span>-- params, motive and elims), a mapping from constructor name indices
<span class="lineno"> 1142 </span>-- to eliminator functions, and the arguments to the constructor.
<span class="lineno"> 1143 </span>ctorIotaReduction ::
<span class="lineno"> 1144 </span>  SharedContext -&gt;
<span class="lineno"> 1145 </span>  Ctor -&gt;
<span class="lineno"> 1146 </span>  Term {- ^ recursor term -} -&gt;
<span class="lineno"> 1147 </span>  Map VarIndex Term {- ^ constructor eliminators -} -&gt;
<span class="lineno"> 1148 </span>  [Term] {- ^ constructor arguments -} -&gt;
<span class="lineno"> 1149 </span>  IO Term
<span class="lineno"> 1150 </span><span class="decl"><span class="istickedoff">ctorIotaReduction sc ctor r cs_fs args =</span>
<span class="lineno"> 1151 </span><span class="spaces">  </span><span class="istickedoff">ctxReduceRecursor sc r elim args (ctorArgStruct ctor)</span>
<span class="lineno"> 1152 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1153 </span><span class="spaces">    </span><span class="istickedoff">elim =</span>
<span class="lineno"> 1154 </span><span class="spaces">      </span><span class="istickedoff">case Map.lookup (nameIndex (ctorName ctor)) cs_fs of</span>
<span class="lineno"> 1155 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; e</span>
<span class="lineno"> 1156 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1157 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">panic &quot;ctorIotaReduction&quot;</span></span>
<span class="lineno"> 1158 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;no eliminator for constructor &quot; &lt;&gt; toAbsoluteName (nameInfo (ctorName ctor))]</span></span></span>
<span class="lineno"> 1159 </span>
<span class="lineno"> 1160 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1161 </span>-- Reduction to head-normal form
<span class="lineno"> 1162 </span>
<span class="lineno"> 1163 </span>-- | An elimination for 'scWhnf'
<span class="lineno"> 1164 </span>data WHNFElim
<span class="lineno"> 1165 </span>  = ElimApp Term
<span class="lineno"> 1166 </span>  | ElimProj FieldName
<span class="lineno"> 1167 </span>  | ElimPair Bool
<span class="lineno"> 1168 </span>  | ElimRecursor Term CompiledRecursor [Term] Term [Term] [Term]
<span class="lineno"> 1169 </span>    -- ^ recursor, compiled recursor, params, motive, eliminators, indices
<span class="lineno"> 1170 </span>
<span class="lineno"> 1171 </span>-- | Reduces beta-redexes, tuple/record selectors, recursor applications, and
<span class="lineno"> 1172 </span>-- definitions at the top level of a term.
<span class="lineno"> 1173 </span>scWhnf :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1174 </span><span class="decl"><span class="istickedoff">scWhnf sc t0 = go [] t0</span>
<span class="lineno"> 1175 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1176 </span><span class="spaces">    </span><span class="istickedoff">go :: [WHNFElim] -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 1177 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asApp            -&gt; Just (t, x)) = go (ElimApp x : xs) t</span>
<span class="lineno"> 1178 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asRecordSelector -&gt; Just (t, n)) = go (ElimProj n : xs) t</span>
<span class="lineno"> 1179 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asPairSelector -&gt; Just (t, i))   = go (ElimPair i : xs) t</span>
<span class="lineno"> 1180 </span><span class="spaces">    </span><span class="istickedoff">go (ElimApp x : xs)       (asLambda -&gt; Just (vn, _, body))  = betaReduce xs [(vn, x)] body</span>
<span class="lineno"> 1181 </span><span class="spaces">    </span><span class="istickedoff">go (ElimPair i : xs)      (asPairValue -&gt; Just (a, b))      = go xs (if i then b else a)</span>
<span class="lineno"> 1182 </span><span class="spaces">    </span><span class="istickedoff">go (ElimProj fld : xs)    (asRecordValue -&gt; Just elems)     = case Map.lookup fld elems of</span>
<span class="lineno"> 1183 </span><span class="spaces">                                                                    </span><span class="istickedoff">Just t -&gt; go xs t</span>
<span class="lineno"> 1184 </span><span class="spaces">                                                                    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1185 </span><span class="spaces">                                                                      </span><span class="istickedoff"><span class="nottickedoff">error &quot;scWhnf: field missing in record&quot;</span></span>
<span class="lineno"> 1186 </span><span class="spaces">    </span><span class="istickedoff">go xs                     (asRecursorApp -&gt; Just (r, crec)) | Just (params, ElimApp motive : xs1) &lt;- splitApps (recursorNumParams crec) xs</span>
<span class="lineno"> 1187 </span><span class="spaces">                                                                </span><span class="istickedoff">, Just (elims, xs2) &lt;- splitApps (length (recursorCtorOrder crec)) xs1</span>
<span class="lineno"> 1188 </span><span class="spaces">                                                                </span><span class="istickedoff">, Just (ixs, ElimApp x : xs') &lt;- splitApps (recursorNumIxs crec) xs2</span>
<span class="lineno"> 1189 </span><span class="spaces">                                                                </span><span class="istickedoff">= go (ElimRecursor r crec params motive elims ixs : xs') x</span>
<span class="lineno"> 1190 </span><span class="spaces">    </span><span class="istickedoff">go xs                     t@(asConstant -&gt; Just nm)         = do r &lt;- resolveConstant nm</span>
<span class="lineno"> 1191 </span><span class="spaces">                                                                     </span><span class="istickedoff">case r of</span>
<span class="lineno"> 1192 </span><span class="spaces">                                                                       </span><span class="istickedoff">ResolvedDef d -&gt;</span>
<span class="lineno"> 1193 </span><span class="spaces">                                                                         </span><span class="istickedoff">case defBody d of</span>
<span class="lineno"> 1194 </span><span class="spaces">                                                                           </span><span class="istickedoff">Just body -&gt; go xs body</span>
<span class="lineno"> 1195 </span><span class="spaces">                                                                           </span><span class="istickedoff">Nothing -&gt; foldM reapply t xs</span>
<span class="lineno"> 1196 </span><span class="spaces">                                                                       </span><span class="istickedoff">ResolvedCtor ctor -&gt;</span>
<span class="lineno"> 1197 </span><span class="spaces">                                                                         </span><span class="istickedoff">case asArgsRec xs of</span>
<span class="lineno"> 1198 </span><span class="spaces">                                                                           </span><span class="istickedoff">Nothing -&gt; foldM reapply t xs</span>
<span class="lineno"> 1199 </span><span class="spaces">                                                                           </span><span class="istickedoff">Just (rt, crec, params, motive, elims, args, xs') -&gt;</span>
<span class="lineno"> 1200 </span><span class="spaces">                                                                             </span><span class="istickedoff">do let args' = drop (ctorNumParams ctor) args</span>
<span class="lineno"> 1201 </span><span class="spaces">                                                                                </span><span class="istickedoff">scReduceRecursor sc rt crec params motive elims nm args' &gt;&gt;= go xs'</span>
<span class="lineno"> 1202 </span><span class="spaces">                                                                       </span><span class="istickedoff">ResolvedDataType _ -&gt;</span>
<span class="lineno"> 1203 </span><span class="spaces">                                                                         </span><span class="istickedoff">foldM reapply t xs</span>
<span class="lineno"> 1204 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1205 </span><span class="spaces">    </span><span class="istickedoff">go xs                     t                                 = foldM reapply t xs</span>
<span class="lineno"> 1206 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1207 </span><span class="spaces">    </span><span class="istickedoff">betaReduce :: [WHNFElim] -&gt; [(VarName, Term)] -&gt; Term -&gt; IO Term</span>
<span class="lineno"> 1208 </span><span class="spaces">    </span><span class="istickedoff">betaReduce (ElimApp x : xs) vs (asLambda -&gt; Just (vn,_,body)) =</span>
<span class="lineno"> 1209 </span><span class="spaces">      </span><span class="istickedoff">betaReduce xs ((vn, x) : vs) body</span>
<span class="lineno"> 1210 </span><span class="spaces">    </span><span class="istickedoff">betaReduce xs vs body =</span>
<span class="lineno"> 1211 </span><span class="spaces">      </span><span class="istickedoff">do let subst = IntMap.fromList [ (vnIndex vn, x) | (vn, x) &lt;- vs ]</span>
<span class="lineno"> 1212 </span><span class="spaces">         </span><span class="istickedoff">body' &lt;- scInstantiate sc subst body</span>
<span class="lineno"> 1213 </span><span class="spaces">         </span><span class="istickedoff">go xs body'</span>
<span class="lineno"> 1214 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1215 </span><span class="spaces">    </span><span class="istickedoff">reapply :: Term -&gt; WHNFElim -&gt; IO Term</span>
<span class="lineno"> 1216 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimApp x) = scApply sc t x</span>
<span class="lineno"> 1217 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimProj i) = <span class="nottickedoff">scRecordSelect sc t i</span></span>
<span class="lineno"> 1218 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimPair i) = scPairSelector sc t i</span>
<span class="lineno"> 1219 </span><span class="spaces">    </span><span class="istickedoff">reapply t (ElimRecursor r _crec params motive elims ixs) =</span>
<span class="lineno"> 1220 </span><span class="spaces">      </span><span class="istickedoff">do f &lt;- scApplyAll sc r (params ++ motive : elims ++ ixs)</span>
<span class="lineno"> 1221 </span><span class="spaces">         </span><span class="istickedoff">scApply sc f t</span>
<span class="lineno"> 1222 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1223 </span><span class="spaces">    </span><span class="istickedoff">resolveConstant :: Name -&gt; IO ResolvedName</span>
<span class="lineno"> 1224 </span><span class="spaces">    </span><span class="istickedoff">resolveConstant nm = requireNameInMap nm &lt;$&gt; scGetModuleMap sc</span>
<span class="lineno"> 1225 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1226 </span><span class="spaces">    </span><span class="istickedoff">-- look for a prefix of ElimApps followed by an ElimRecursor</span>
<span class="lineno"> 1227 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec :: [WHNFElim] -&gt; Maybe (Term, CompiledRecursor, [Term], Term, [Term], [Term], [WHNFElim])</span>
<span class="lineno"> 1228 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec (ElimRecursor r crec params motive elims _ixs : xs) = Just (r, crec, params, motive, elims, [], xs)</span>
<span class="lineno"> 1229 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec (ElimApp x : xs) =</span>
<span class="lineno"> 1230 </span><span class="spaces">      </span><span class="istickedoff">case asArgsRec xs of</span>
<span class="lineno"> 1231 </span><span class="spaces">        </span><span class="istickedoff">Just (r, crec, params, motive, elims, args, xs') -&gt; Just (r, crec, params, motive, elims, x : args, xs')</span>
<span class="lineno"> 1232 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; Nothing</span>
<span class="lineno"> 1233 </span><span class="spaces">    </span><span class="istickedoff">asArgsRec _ = Nothing</span>
<span class="lineno"> 1234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1235 </span><span class="spaces">    </span><span class="istickedoff">-- look for a prefix of n ElimApps</span>
<span class="lineno"> 1236 </span><span class="spaces">    </span><span class="istickedoff">splitApps :: Int -&gt; [WHNFElim] -&gt; Maybe ([Term], [WHNFElim])</span>
<span class="lineno"> 1237 </span><span class="spaces">    </span><span class="istickedoff">splitApps 0 xs = Just ([], xs)</span>
<span class="lineno"> 1238 </span><span class="spaces">    </span><span class="istickedoff">splitApps n (ElimApp t : xs) =</span>
<span class="lineno"> 1239 </span><span class="spaces">       </span><span class="istickedoff">do (ts, xs') &lt;- splitApps (n-1) xs</span>
<span class="lineno"> 1240 </span><span class="spaces">          </span><span class="istickedoff">Just (t : ts, xs')</span>
<span class="lineno"> 1241 </span><span class="spaces">    </span><span class="istickedoff">splitApps _ _ = Nothing</span></span>
<span class="lineno"> 1242 </span>
<span class="lineno"> 1243 </span>
<span class="lineno"> 1244 </span>-- | Test if two terms are convertible up to a given evaluation procedure. In
<span class="lineno"> 1245 </span>-- practice, this procedure is usually 'scWhnf', possibly combined with some
<span class="lineno"> 1246 </span>-- rewriting.
<span class="lineno"> 1247 </span>scConvertibleEval :: SharedContext
<span class="lineno"> 1248 </span>                  -&gt; (SharedContext -&gt; Term -&gt; IO Term)
<span class="lineno"> 1249 </span>                  -&gt; Bool -- ^ Should constants be unfolded during this check?
<span class="lineno"> 1250 </span>                  -&gt; Term
<span class="lineno"> 1251 </span>                  -&gt; Term
<span class="lineno"> 1252 </span>                  -&gt; IO Bool
<span class="lineno"> 1253 </span><span class="decl"><span class="istickedoff">scConvertibleEval sc eval unfoldConst tm1 tm2 = do</span>
<span class="lineno"> 1254 </span><span class="spaces">   </span><span class="istickedoff">c &lt;- newCache</span>
<span class="lineno"> 1255 </span><span class="spaces">   </span><span class="istickedoff">go c IntMap.empty tm1 tm2</span>
<span class="lineno"> 1256 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1257 </span><span class="spaces"> </span><span class="istickedoff">where whnf :: Cache IO TermIndex Term -&gt; Term -&gt; IO (TermF Term)</span>
<span class="lineno"> 1258 </span><span class="spaces">       </span><span class="istickedoff">whnf c t@(STApp{ stAppIndex = idx}) =</span>
<span class="lineno"> 1259 </span><span class="spaces">         </span><span class="istickedoff">unwrapTermF &lt;$&gt; useCache c idx (eval sc t)</span>
<span class="lineno"> 1260 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1261 </span><span class="spaces">       </span><span class="istickedoff">go :: Cache IO TermIndex Term -&gt; IntMap VarIndex -&gt; Term -&gt; Term -&gt; IO Bool</span>
<span class="lineno"> 1262 </span><span class="spaces">       </span><span class="istickedoff">go _c vm (STApp{stAppIndex = idx1, stAppVarTypes = vt1}) (STApp{stAppIndex = idx2})</span>
<span class="lineno"> 1263 </span><span class="spaces">         </span><span class="istickedoff">| IntMap.disjoint vt1 vm &amp;&amp; idx1 == idx2 = pure True   -- succeed early case</span>
<span class="lineno"> 1264 </span><span class="spaces">       </span><span class="istickedoff">go c vm t1 t2 = join (goF c vm &lt;$&gt; whnf c t1 &lt;*&gt; whnf c t2)</span>
<span class="lineno"> 1265 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1266 </span><span class="spaces">       </span><span class="istickedoff">goF :: Cache IO TermIndex Term -&gt; IntMap VarIndex -&gt; TermF Term -&gt; TermF Term -&gt; IO Bool</span>
<span class="lineno"> 1267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1268 </span><span class="spaces">       </span><span class="istickedoff">goF _c _vm (Constant nx) (Constant ny) | nameIndex nx == nameIndex ny = pure True</span>
<span class="lineno"> 1269 </span><span class="spaces">       </span><span class="istickedoff">goF c vm (Constant nx) y</span>
<span class="lineno"> 1270 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">unfoldConst</span> =</span>
<span class="lineno"> 1271 </span><span class="spaces">             </span><span class="istickedoff">do mx &lt;- scFindDefBody sc (nameIndex nx)</span>
<span class="lineno"> 1272 </span><span class="spaces">                </span><span class="istickedoff">case mx of</span>
<span class="lineno"> 1273 </span><span class="spaces">                  </span><span class="istickedoff">Just x -&gt; <span class="nottickedoff">join (goF c vm &lt;$&gt; whnf c x &lt;*&gt; return y)</span></span>
<span class="lineno"> 1274 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; pure False</span>
<span class="lineno"> 1275 </span><span class="spaces">       </span><span class="istickedoff">goF c vm x (Constant ny)</span>
<span class="lineno"> 1276 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">unfoldConst</span> =</span>
<span class="lineno"> 1277 </span><span class="spaces">             </span><span class="istickedoff">do my &lt;- scFindDefBody sc (nameIndex ny)</span>
<span class="lineno"> 1278 </span><span class="spaces">                </span><span class="istickedoff">case my of</span>
<span class="lineno"> 1279 </span><span class="spaces">                  </span><span class="istickedoff">Just y -&gt; <span class="nottickedoff">join (goF c vm &lt;$&gt; return x &lt;*&gt; whnf c y)</span></span>
<span class="lineno"> 1280 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt; pure False</span>
<span class="lineno"> 1281 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1282 </span><span class="spaces">       </span><span class="istickedoff">goF c vm (FTermF ftf1) (FTermF ftf2) =</span>
<span class="lineno"> 1283 </span><span class="spaces">               </span><span class="istickedoff">case zipWithFlatTermF (go c vm) ftf1 ftf2 of</span>
<span class="lineno"> 1284 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">False</span></span>
<span class="lineno"> 1285 </span><span class="spaces">                 </span><span class="istickedoff">Just zipped -&gt; Fold.and &lt;$&gt; traverse id zipped</span>
<span class="lineno"> 1286 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1287 </span><span class="spaces">       </span><span class="istickedoff">goF c vm (App f1 x1) (App f2 x2) =</span>
<span class="lineno"> 1288 </span><span class="spaces">              </span><span class="istickedoff">pure (&amp;&amp;) &lt;*&gt; go c vm f1 f2 &lt;*&gt; go c vm x1 x2</span>
<span class="lineno"> 1289 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1290 </span><span class="spaces">       </span><span class="istickedoff">goF c vm (Lambda (vnIndex -&gt; i1) ty1 body1) (Lambda (vnIndex -&gt; i2) ty2 body2) =</span>
<span class="lineno"> 1291 </span><span class="spaces">         </span><span class="istickedoff">pure (&amp;&amp;) &lt;*&gt; go c <span class="nottickedoff">vm</span> ty1 ty2 &lt;*&gt; go c vm' body1 body2</span>
<span class="lineno"> 1292 </span><span class="spaces">           </span><span class="istickedoff">where vm' = if i1 == i2 then vm else IntMap.insert i1 i2 vm</span>
<span class="lineno"> 1293 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1294 </span><span class="spaces">       </span><span class="istickedoff">goF c vm (Pi (vnIndex -&gt; i1) ty1 body1) (Pi (vnIndex -&gt; i2) ty2 body2) =</span>
<span class="lineno"> 1295 </span><span class="spaces">         </span><span class="istickedoff">pure (&amp;&amp;) &lt;*&gt; go c vm ty1 ty2 &lt;*&gt; go c vm' body1 body2</span>
<span class="lineno"> 1296 </span><span class="spaces">           </span><span class="istickedoff">where vm' = if i1 == i2 then vm else IntMap.insert i1 i2 vm</span>
<span class="lineno"> 1297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1298 </span><span class="spaces">       </span><span class="istickedoff">goF c vm (Variable x1 t1) (Variable x2 t2)</span>
<span class="lineno"> 1299 </span><span class="spaces">         </span><span class="istickedoff">| i' == vnIndex x2 = go <span class="nottickedoff">c</span> vm t1 t2</span>
<span class="lineno"> 1300 </span><span class="spaces">           </span><span class="istickedoff">where i' = case IntMap.lookup (vnIndex x1) vm of</span>
<span class="lineno"> 1301 </span><span class="spaces">                        </span><span class="istickedoff">Nothing -&gt; vnIndex x1</span>
<span class="lineno"> 1302 </span><span class="spaces">                        </span><span class="istickedoff">Just i -&gt; i</span>
<span class="lineno"> 1303 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1304 </span><span class="spaces">       </span><span class="istickedoff">-- final catch-all case</span>
<span class="lineno"> 1305 </span><span class="spaces">       </span><span class="istickedoff">goF _c _vm _x _y = pure False</span></span>
<span class="lineno"> 1306 </span>
<span class="lineno"> 1307 </span>-- | Test if two terms are convertible using 'scWhnf' for evaluation
<span class="lineno"> 1308 </span>scConvertible :: SharedContext
<span class="lineno"> 1309 </span>              -&gt; Bool -- ^ Should constants be unfolded during this check?
<span class="lineno"> 1310 </span>              -&gt; Term
<span class="lineno"> 1311 </span>              -&gt; Term
<span class="lineno"> 1312 </span>              -&gt; IO Bool
<span class="lineno"> 1313 </span><span class="decl"><span class="istickedoff">scConvertible sc = scConvertibleEval sc scWhnf</span></span>
<span class="lineno"> 1314 </span>
<span class="lineno"> 1315 </span>-- | Check whether one type is a subtype of another: Either they are
<span class="lineno"> 1316 </span>-- convertible, or they are both Pi types with convertible argument
<span class="lineno"> 1317 </span>-- types and result sorts @s1@ and @s2@ with @s1 &lt;= s2@.
<span class="lineno"> 1318 </span>scSubtype :: SharedContext -&gt; Term -&gt; Term -&gt; IO Bool
<span class="lineno"> 1319 </span><span class="decl"><span class="istickedoff">scSubtype sc t1 t2</span>
<span class="lineno"> 1320 </span><span class="spaces">  </span><span class="istickedoff">| alphaEquiv t1 t2 = pure True</span>
<span class="lineno"> 1321 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1322 </span><span class="spaces">    </span><span class="istickedoff">do t1' &lt;- scWhnf sc t1</span>
<span class="lineno"> 1323 </span><span class="spaces">       </span><span class="istickedoff">t2' &lt;- scWhnf sc t2</span>
<span class="lineno"> 1324 </span><span class="spaces">       </span><span class="istickedoff">case (t1', t2') of</span>
<span class="lineno"> 1325 </span><span class="spaces">         </span><span class="istickedoff">(asSort -&gt; Just s1, asSort -&gt; Just s2) -&gt;</span>
<span class="lineno"> 1326 </span><span class="spaces">           </span><span class="istickedoff">pure (s1 &lt;= s2)</span>
<span class="lineno"> 1327 </span><span class="spaces">         </span><span class="istickedoff">(unwrapTermF -&gt; Pi x1 a1 b1, unwrapTermF -&gt; Pi x2 a2 b2)</span>
<span class="lineno"> 1328 </span><span class="spaces">           </span><span class="istickedoff">| x1 == x2 -&gt;</span>
<span class="lineno"> 1329 </span><span class="spaces">             </span><span class="istickedoff">(&amp;&amp;) &lt;$&gt; scConvertible sc <span class="nottickedoff">True</span> a1 a2 &lt;*&gt; scSubtype sc b1 b2</span>
<span class="lineno"> 1330 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno"> 1331 </span><span class="spaces">             </span><span class="istickedoff">do conv1 &lt;- scConvertible sc <span class="nottickedoff">True</span> a1 a2</span>
<span class="lineno"> 1332 </span><span class="spaces">                </span><span class="istickedoff">var1 &lt;- scVariable sc x1 a1</span>
<span class="lineno"> 1333 </span><span class="spaces">                </span><span class="istickedoff">b2' &lt;- scInstantiate sc (IntMap.singleton (vnIndex x2) var1) b2</span>
<span class="lineno"> 1334 </span><span class="spaces">                </span><span class="istickedoff">conv2 &lt;- scSubtype sc b1 b2'</span>
<span class="lineno"> 1335 </span><span class="spaces">                </span><span class="istickedoff">pure (conv1 &amp;&amp; conv2)</span>
<span class="lineno"> 1336 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1337 </span><span class="spaces">           </span><span class="istickedoff">scConvertible sc True t1' t2'</span></span>
<span class="lineno"> 1338 </span>
<span class="lineno"> 1339 </span>
<span class="lineno"> 1340 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1341 </span>-- Type checking
<span class="lineno"> 1342 </span>
<span class="lineno"> 1343 </span>-- | Look up the type of a global constant, given its 'Name'.
<span class="lineno"> 1344 </span>scTypeOfName :: SharedContext -&gt; Name -&gt; IO Term
<span class="lineno"> 1345 </span><span class="decl"><span class="istickedoff">scTypeOfName sc nm =</span>
<span class="lineno"> 1346 </span><span class="spaces">  </span><span class="istickedoff">do mm &lt;- scGetModuleMap sc</span>
<span class="lineno"> 1347 </span><span class="spaces">     </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno"> 1348 </span><span class="spaces">       </span><span class="istickedoff">Just r -&gt; pure (resolvedNameType r)</span>
<span class="lineno"> 1349 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail (&quot;scTypeOfName: Name not found: &quot; ++ show nm)</span></span></span>
<span class="lineno"> 1350 </span>
<span class="lineno"> 1351 </span>-- | Return the type of a term.
<span class="lineno"> 1352 </span>scTypeOf :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1353 </span><span class="decl"><span class="istickedoff">scTypeOf sc t =</span>
<span class="lineno"> 1354 </span><span class="spaces">  </span><span class="istickedoff">case stAppType t of</span>
<span class="lineno"> 1355 </span><span class="spaces">    </span><span class="istickedoff">Right ty -&gt; pure ty</span>
<span class="lineno"> 1356 </span><span class="spaces">    </span><span class="istickedoff">Left s -&gt; scSort sc s</span></span>
<span class="lineno"> 1357 </span>
<span class="lineno"> 1358 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1359 </span>-- Beta Normalization
<span class="lineno"> 1360 </span>
<span class="lineno"> 1361 </span>-- | Instantiate some of the named variables in the term, reducing any
<span class="lineno"> 1362 </span>-- new beta redexes created in the process.
<span class="lineno"> 1363 </span>-- The substitution 'IntMap' is keyed by 'VarIndex'.
<span class="lineno"> 1364 </span>-- If the input term and all terms in the substitution are in
<span class="lineno"> 1365 </span>-- beta-normal form, then the result will also be beta-normal.
<span class="lineno"> 1366 </span>-- If a substituted term is a lambda, and it is substituted into the
<span class="lineno"> 1367 </span>-- left side of an application, creating a new beta redex, then it
<span class="lineno"> 1368 </span>-- will trigger further beta reduction.
<span class="lineno"> 1369 </span>-- Existing beta redexes in the input term or substitution are
<span class="lineno"> 1370 </span>-- not reduced.
<span class="lineno"> 1371 </span>scInstantiateBeta :: SharedContext -&gt; IntMap Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1372 </span><span class="decl"><span class="istickedoff">scInstantiateBeta sc sub t0 =</span>
<span class="lineno"> 1373 </span><span class="spaces">  </span><span class="istickedoff">do let domainVars = IntMap.keysSet sub</span>
<span class="lineno"> 1374 </span><span class="spaces">     </span><span class="istickedoff">let rangeVars = foldMap freeVars sub</span>
<span class="lineno"> 1375 </span><span class="spaces">     </span><span class="istickedoff">cache &lt;- newCacheIntMap</span>
<span class="lineno"> 1376 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; IO Term</span>
<span class="lineno"> 1377 </span><span class="spaces">         </span><span class="istickedoff">memo t@STApp{stAppIndex = i} = useCache cache i (go t)</span>
<span class="lineno"> 1378 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; IO Term</span>
<span class="lineno"> 1379 </span><span class="spaces">         </span><span class="istickedoff">go t</span>
<span class="lineno"> 1380 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.disjoint domainVars (freeVars t) = pure t</span>
<span class="lineno"> 1381 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = goArgs t []</span>
<span class="lineno"> 1382 </span><span class="spaces">         </span><span class="istickedoff">goArgs :: Term -&gt; [Term] -&gt; IO Term</span>
<span class="lineno"> 1383 </span><span class="spaces">         </span><span class="istickedoff">goArgs t args =</span>
<span class="lineno"> 1384 </span><span class="spaces">           </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1385 </span><span class="spaces">             </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno"> 1386 </span><span class="spaces">               </span><span class="istickedoff">do ftf' &lt;- traverse memo ftf</span>
<span class="lineno"> 1387 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scFlatTermF sc ftf'</span>
<span class="lineno"> 1388 </span><span class="spaces">                  </span><span class="istickedoff">scApplyAll sc t' args</span>
<span class="lineno"> 1389 </span><span class="spaces">             </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno"> 1390 </span><span class="spaces">               </span><span class="istickedoff">do t2' &lt;- memo t2</span>
<span class="lineno"> 1391 </span><span class="spaces">                  </span><span class="istickedoff">goArgs t1 (t2' : args)</span>
<span class="lineno"> 1392 </span><span class="spaces">             </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 1393 </span><span class="spaces">               </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1394 </span><span class="spaces">                  </span><span class="istickedoff">(x', t2') &lt;- goBinder x t1' t2</span>
<span class="lineno"> 1395 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scLambda sc x' t1' t2'</span>
<span class="lineno"> 1396 </span><span class="spaces">                  </span><span class="istickedoff">scApplyAll sc t' args</span>
<span class="lineno"> 1397 </span><span class="spaces">             </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 1398 </span><span class="spaces">               </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1399 </span><span class="spaces">                  </span><span class="istickedoff">(x', t2') &lt;- goBinder x <span class="nottickedoff">t1'</span> t2</span>
<span class="lineno"> 1400 </span><span class="spaces">                  </span><span class="istickedoff">t' &lt;- scPi sc x' t1' t2'</span>
<span class="lineno"> 1401 </span><span class="spaces">                  </span><span class="istickedoff">scApplyAll <span class="nottickedoff">sc</span> t' args</span>
<span class="lineno"> 1402 </span><span class="spaces">             </span><span class="istickedoff">Constant {} -&gt;</span>
<span class="lineno"> 1403 </span><span class="spaces">               </span><span class="istickedoff">scApplyAll sc t args</span>
<span class="lineno"> 1404 </span><span class="spaces">             </span><span class="istickedoff">Variable x t1 -&gt;</span>
<span class="lineno"> 1405 </span><span class="spaces">               </span><span class="istickedoff">case IntMap.lookup (vnIndex x) sub of</span>
<span class="lineno"> 1406 </span><span class="spaces">                 </span><span class="istickedoff">Just t' -&gt; scApplyAllBeta sc t' args</span>
<span class="lineno"> 1407 </span><span class="spaces">                 </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1408 </span><span class="spaces">                   </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1409 </span><span class="spaces">                      </span><span class="istickedoff">t' &lt;- scVariable sc x t1'</span>
<span class="lineno"> 1410 </span><span class="spaces">                      </span><span class="istickedoff">scApplyAll sc t' args</span>
<span class="lineno"> 1411 </span><span class="spaces">         </span><span class="istickedoff">goBinder :: VarName -&gt; Term -&gt; Term -&gt; IO (VarName, Term)</span>
<span class="lineno"> 1412 </span><span class="spaces">         </span><span class="istickedoff">goBinder x@(vnIndex -&gt; i) t body</span>
<span class="lineno"> 1413 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.member i rangeVars =</span>
<span class="lineno"> 1414 </span><span class="spaces">               </span><span class="istickedoff">-- Possibility of capture; rename bound variable.</span>
<span class="lineno"> 1415 </span><span class="spaces">               </span><span class="istickedoff">do x' &lt;- scFreshVarName sc (vnName x)</span>
<span class="lineno"> 1416 </span><span class="spaces">                  </span><span class="istickedoff">var &lt;- scVariable sc x' t</span>
<span class="lineno"> 1417 </span><span class="spaces">                  </span><span class="istickedoff">let sub' = IntMap.insert i var sub</span>
<span class="lineno"> 1418 </span><span class="spaces">                  </span><span class="istickedoff">body' &lt;- scInstantiateBeta sc sub' body</span>
<span class="lineno"> 1419 </span><span class="spaces">                  </span><span class="istickedoff">pure (x', body')</span>
<span class="lineno"> 1420 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlyfalse">IntMap.member i sub</span> =</span>
<span class="lineno"> 1421 </span><span class="spaces">               </span><span class="istickedoff">-- Shadowing; remove entry from substitution.</span>
<span class="lineno"> 1422 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">do let sub' = IntMap.delete i sub</span></span>
<span class="lineno"> 1423 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">body' &lt;- scInstantiateBeta sc sub' body</span></span>
<span class="lineno"> 1424 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">pure (x, body')</span></span>
<span class="lineno"> 1425 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1426 </span><span class="spaces">               </span><span class="istickedoff">-- No possibility of shadowing or capture.</span>
<span class="lineno"> 1427 </span><span class="spaces">               </span><span class="istickedoff">do body' &lt;- memo body</span>
<span class="lineno"> 1428 </span><span class="spaces">                  </span><span class="istickedoff">pure (x, body')</span>
<span class="lineno"> 1429 </span><span class="spaces">     </span><span class="istickedoff">go t0</span></span>
<span class="lineno"> 1430 </span>
<span class="lineno"> 1431 </span>-- | Apply a function 'Term' to a list of zero or more arguments.
<span class="lineno"> 1432 </span>-- If the function is a lambda term, then beta reduce the arguments
<span class="lineno"> 1433 </span>-- into the function body.
<span class="lineno"> 1434 </span>-- If all input terms are in beta-normal form, then the result will
<span class="lineno"> 1435 </span>-- also be beta-normal.
<span class="lineno"> 1436 </span>scApplyAllBeta :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1437 </span><span class="decl"><span class="istickedoff">scApplyAllBeta _ t0 [] = pure t0</span>
<span class="lineno"> 1438 </span><span class="spaces"></span><span class="istickedoff">scApplyAllBeta sc t0 (arg0 : args0) =</span>
<span class="lineno"> 1439 </span><span class="spaces">  </span><span class="istickedoff">case asLambda t0 of</span>
<span class="lineno"> 1440 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; scApplyAll sc t0 (arg0 : args0)</span>
<span class="lineno"> 1441 </span><span class="spaces">    </span><span class="istickedoff">Just (x, _, body) -&gt; go (IntMap.singleton (vnIndex x) arg0) body args0</span>
<span class="lineno"> 1442 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1443 </span><span class="spaces">    </span><span class="istickedoff">go :: IntMap Term -&gt; Term -&gt; [Term] -&gt; IO Term</span>
<span class="lineno"> 1444 </span><span class="spaces">    </span><span class="istickedoff">go sub (asLambda -&gt; Just (x, _, body)) (arg : args) =</span>
<span class="lineno"> 1445 </span><span class="spaces">      </span><span class="istickedoff">go (IntMap.insert (vnIndex x) arg sub) body args</span>
<span class="lineno"> 1446 </span><span class="spaces">    </span><span class="istickedoff">go sub t args =</span>
<span class="lineno"> 1447 </span><span class="spaces">      </span><span class="istickedoff">do t' &lt;- scInstantiateBeta sc sub t</span>
<span class="lineno"> 1448 </span><span class="spaces">         </span><span class="istickedoff">scApplyAllBeta sc t' args</span></span>
<span class="lineno"> 1449 </span>
<span class="lineno"> 1450 </span>
<span class="lineno"> 1451 </span>--------------------------------------------------------------------------------
<span class="lineno"> 1452 </span>-- Building shared terms
<span class="lineno"> 1453 </span>
<span class="lineno"> 1454 </span>-- | Apply a function 'Term' to zero or more argument 'Term's.
<span class="lineno"> 1455 </span>scApplyAll :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1456 </span><span class="decl"><span class="istickedoff">scApplyAll sc = foldlM (scApply sc)</span></span>
<span class="lineno"> 1457 </span>
<span class="lineno"> 1458 </span>-- | Create a term from a 'Sort'.
<span class="lineno"> 1459 </span>scSort :: SharedContext -&gt; Sort -&gt; IO Term
<span class="lineno"> 1460 </span><span class="decl"><span class="istickedoff">scSort sc s = scSortWithFlags sc s noFlags</span></span>
<span class="lineno"> 1461 </span>
<span class="lineno"> 1462 </span>-- | Create a term from a 'Sort', and set the given advisory flags
<span class="lineno"> 1463 </span>scSortWithFlags :: SharedContext -&gt; Sort -&gt; SortFlags -&gt; IO Term
<span class="lineno"> 1464 </span><span class="decl"><span class="istickedoff">scSortWithFlags sc s flags =</span>
<span class="lineno"> 1465 </span><span class="spaces">  </span><span class="istickedoff">scMakeTerm sc IntMap.empty (FTermF (Sort s flags)) (Left (sortOf s))</span></span>
<span class="lineno"> 1466 </span>
<span class="lineno"> 1467 </span>-- | Create a literal term from a 'Natural'.
<span class="lineno"> 1468 </span>scNat :: SharedContext -&gt; Natural -&gt; IO Term
<span class="lineno"> 1469 </span><span class="decl"><span class="istickedoff">scNat sc 0 = scGlobalDef sc &quot;Prelude.Zero&quot;</span>
<span class="lineno"> 1470 </span><span class="spaces"></span><span class="istickedoff">scNat sc n =</span>
<span class="lineno"> 1471 </span><span class="spaces">  </span><span class="istickedoff">do p &lt;- scPos sc n</span>
<span class="lineno"> 1472 </span><span class="spaces">     </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.NatPos&quot; [p]</span></span>
<span class="lineno"> 1473 </span>
<span class="lineno"> 1474 </span>scPos :: SharedContext -&gt; Natural -&gt; IO Term
<span class="lineno"> 1475 </span><span class="decl"><span class="istickedoff">scPos sc n</span>
<span class="lineno"> 1476 </span><span class="spaces">  </span><span class="istickedoff">| n &lt;= 1    = scGlobalDef sc &quot;Prelude.One&quot;</span>
<span class="lineno"> 1477 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1478 </span><span class="spaces">    </span><span class="istickedoff">do arg &lt;- scPos sc (div n 2)</span>
<span class="lineno"> 1479 </span><span class="spaces">       </span><span class="istickedoff">let ident = if even n then &quot;Prelude.Bit0&quot; else &quot;Prelude.Bit1&quot;</span>
<span class="lineno"> 1480 </span><span class="spaces">       </span><span class="istickedoff">scGlobalApply sc ident [arg]</span></span>
<span class="lineno"> 1481 </span>
<span class="lineno"> 1482 </span>-- | Create a literal term (of saw-core type @String@) from a 'Text'.
<span class="lineno"> 1483 </span>scString :: SharedContext -&gt; Text -&gt; IO Term
<span class="lineno"> 1484 </span><span class="decl"><span class="istickedoff">scString sc s =</span>
<span class="lineno"> 1485 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scStringType sc</span>
<span class="lineno"> 1486 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc IntMap.empty (FTermF (StringLit s)) (Right ty)</span></span>
<span class="lineno"> 1487 </span>
<span class="lineno"> 1488 </span>-- | Create a term representing the primitive saw-core type @String@.
<span class="lineno"> 1489 </span>scStringType :: SharedContext -&gt; IO Term
<span class="lineno"> 1490 </span><span class="decl"><span class="istickedoff">scStringType sc = scGlobalDef sc preludeStringIdent</span></span>
<span class="lineno"> 1491 </span>
<span class="lineno"> 1492 </span>-- | Create a vector term from a type (as a 'Term') and a list of 'Term's of
<span class="lineno"> 1493 </span>-- that type.
<span class="lineno"> 1494 </span>scVector :: SharedContext -&gt; Term -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1495 </span><span class="decl"><span class="istickedoff">scVector sc e xs =</span>
<span class="lineno"> 1496 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc e</span>
<span class="lineno"> 1497 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- foldM (unifyVarTypes <span class="nottickedoff">&quot;scVector&quot;</span> <span class="nottickedoff">sc</span>) (varTypes e) (map varTypes xs)</span>
<span class="lineno"> 1498 </span><span class="spaces">     </span><span class="istickedoff">let check x =</span>
<span class="lineno"> 1499 </span><span class="spaces">           </span><span class="istickedoff">do scEnsureValidTerm sc x</span>
<span class="lineno"> 1500 </span><span class="spaces">              </span><span class="istickedoff">xty &lt;- scTypeOf <span class="nottickedoff">sc</span> x</span>
<span class="lineno"> 1501 </span><span class="spaces">              </span><span class="istickedoff">ok &lt;- scSubtype sc xty e</span>
<span class="lineno"> 1502 </span><span class="spaces">              </span><span class="istickedoff">unless ok $ <span class="nottickedoff">do</span></span>
<span class="lineno"> 1503 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">e' &lt;- ppTerm sc PPS.defaultOpts e</span></span>
<span class="lineno"> 1504 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">xty' &lt;- ppTerm sc PPS.defaultOpts xty</span></span>
<span class="lineno"> 1505 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [</span></span>
<span class="lineno"> 1506 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;Not a subtype&quot;,</span></span>
<span class="lineno"> 1507 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;expected: &quot; ++ e',</span></span>
<span class="lineno"> 1508 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">&quot;got: &quot; ++ xty'</span></span>
<span class="lineno"> 1509 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1510 </span><span class="spaces">     </span><span class="istickedoff">mapM_ check xs</span>
<span class="lineno"> 1511 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- scNat sc (fromIntegral (length xs))</span>
<span class="lineno"> 1512 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (ArrayValue e (V.fromList xs))</span>
<span class="lineno"> 1513 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scVecType sc n e</span>
<span class="lineno"> 1514 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt tf (Right ty)</span></span>
<span class="lineno"> 1515 </span>
<span class="lineno"> 1516 </span>-- | Create a term representing a vector type, from a term giving the length
<span class="lineno"> 1517 </span>-- and a term giving the element type.
<span class="lineno"> 1518 </span>scVecType :: SharedContext -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1519 </span><span class="decl"><span class="istickedoff">scVecType sc n e = scGlobalApply sc preludeVecIdent [n, e]</span></span>
<span class="lineno"> 1520 </span>
<span class="lineno"> 1521 </span>-- | Create a record term from a 'Map' from 'FieldName's to 'Term's.
<span class="lineno"> 1522 </span>scRecord :: SharedContext -&gt; Map FieldName Term -&gt; IO Term
<span class="lineno"> 1523 </span><span class="decl"><span class="istickedoff">scRecord sc (Map.toList -&gt; fields) =</span>
<span class="lineno"> 1524 </span><span class="spaces">  </span><span class="istickedoff">do mapM_ (scEnsureValidTerm sc . snd) fields</span>
<span class="lineno"> 1525 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- foldM (unifyVarTypes <span class="nottickedoff">&quot;scRecord&quot;</span> <span class="nottickedoff">sc</span>) IntMap.empty (map (varTypes . snd) fields)</span>
<span class="lineno"> 1526 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (RecordValue fields)</span>
<span class="lineno"> 1527 </span><span class="spaces">     </span><span class="istickedoff">field_tys &lt;- traverse (traverse (scTypeOf <span class="nottickedoff">sc</span>)) fields</span>
<span class="lineno"> 1528 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scRecordType sc field_tys</span>
<span class="lineno"> 1529 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt tf (Right ty)</span></span>
<span class="lineno"> 1530 </span>
<span class="lineno"> 1531 </span>-- | Create a record field access term from a 'Term' representing a record and
<span class="lineno"> 1532 </span>-- a 'FieldName'.
<span class="lineno"> 1533 </span>scRecordSelect :: SharedContext -&gt; Term -&gt; FieldName -&gt; IO Term
<span class="lineno"> 1534 </span><span class="decl"><span class="istickedoff">scRecordSelect sc t fname =</span>
<span class="lineno"> 1535 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t</span>
<span class="lineno"> 1536 </span><span class="spaces">     </span><span class="istickedoff">let vt = varTypes t</span>
<span class="lineno"> 1537 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (RecordProj t fname)</span>
<span class="lineno"> 1538 </span><span class="spaces">     </span><span class="istickedoff">field_tys &lt;- ensureRecordType sc =&lt;&lt; scTypeOf <span class="nottickedoff">sc</span> t</span>
<span class="lineno"> 1539 </span><span class="spaces">     </span><span class="istickedoff">case Map.lookup fname field_tys of</span>
<span class="lineno"> 1540 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;scRecordSelect: field name not found&quot;</span></span>
<span class="lineno"> 1541 </span><span class="spaces">       </span><span class="istickedoff">Just ty' -&gt; scMakeTerm sc vt tf (Right ty')</span></span>
<span class="lineno"> 1542 </span>
<span class="lineno"> 1543 </span>-- | Create a term representing the type of a record from a list associating
<span class="lineno"> 1544 </span>-- field names (as 'FieldName's) and types (as 'Term's). Note that the order of
<span class="lineno"> 1545 </span>-- the given list is irrelevant, as record fields are not ordered.
<span class="lineno"> 1546 </span>scRecordType :: SharedContext -&gt; [(FieldName, Term)] -&gt; IO Term
<span class="lineno"> 1547 </span><span class="decl"><span class="istickedoff">scRecordType sc field_tys =</span>
<span class="lineno"> 1548 </span><span class="spaces">  </span><span class="istickedoff">do mapM_ (scEnsureValidTerm sc . snd) field_tys</span>
<span class="lineno"> 1549 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- foldM (unifyVarTypes <span class="nottickedoff">&quot;scRecordType&quot;</span> <span class="nottickedoff">sc</span>) IntMap.empty (map (varTypes . snd) field_tys)</span>
<span class="lineno"> 1550 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (RecordType field_tys)</span>
<span class="lineno"> 1551 </span><span class="spaces">     </span><span class="istickedoff">let field_sort (_, t) = either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType t)</span>
<span class="lineno"> 1552 </span><span class="spaces">     </span><span class="istickedoff">sorts &lt;- traverse field_sort field_tys</span>
<span class="lineno"> 1553 </span><span class="spaces">     </span><span class="istickedoff">let s = foldl max (mkSort 0) sorts</span>
<span class="lineno"> 1554 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt tf (Left s)</span></span>
<span class="lineno"> 1555 </span>
<span class="lineno"> 1556 </span>-- | Create a unit-valued term.
<span class="lineno"> 1557 </span>scUnitValue :: SharedContext -&gt; IO Term
<span class="lineno"> 1558 </span><span class="decl"><span class="istickedoff">scUnitValue sc =</span>
<span class="lineno"> 1559 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scUnitType sc</span>
<span class="lineno"> 1560 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc IntMap.empty (FTermF UnitValue) (Right ty)</span></span>
<span class="lineno"> 1561 </span>
<span class="lineno"> 1562 </span>-- | Create a term representing the unit type.
<span class="lineno"> 1563 </span>scUnitType :: SharedContext -&gt; IO Term
<span class="lineno"> 1564 </span><span class="decl"><span class="istickedoff">scUnitType sc =</span>
<span class="lineno"> 1565 </span><span class="spaces">  </span><span class="istickedoff">scMakeTerm sc IntMap.empty (FTermF UnitType) (Left (TypeSort 0))</span></span>
<span class="lineno"> 1566 </span>
<span class="lineno"> 1567 </span>-- | Create a pair term from two terms.
<span class="lineno"> 1568 </span>scPairValue :: SharedContext
<span class="lineno"> 1569 </span>            -&gt; Term -- ^ The left projection
<span class="lineno"> 1570 </span>            -&gt; Term -- ^ The right projection
<span class="lineno"> 1571 </span>            -&gt; IO Term
<span class="lineno"> 1572 </span><span class="decl"><span class="istickedoff">scPairValue sc t1 t2 =</span>
<span class="lineno"> 1573 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t1</span>
<span class="lineno"> 1574 </span><span class="spaces">     </span><span class="istickedoff">scEnsureValidTerm sc t2</span>
<span class="lineno"> 1575 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- unifyVarTypes <span class="nottickedoff">&quot;scPairValue&quot;</span> <span class="nottickedoff">sc</span> (varTypes t1) (varTypes t2)</span>
<span class="lineno"> 1576 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (PairValue t1 t2)</span>
<span class="lineno"> 1577 </span><span class="spaces">     </span><span class="istickedoff">ty1 &lt;- scTypeOf <span class="nottickedoff">sc</span> t1</span>
<span class="lineno"> 1578 </span><span class="spaces">     </span><span class="istickedoff">ty2 &lt;- scTypeOf <span class="nottickedoff">sc</span> t2</span>
<span class="lineno"> 1579 </span><span class="spaces">     </span><span class="istickedoff">ty &lt;- scPairType sc ty1 ty2</span>
<span class="lineno"> 1580 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt tf (Right ty)</span></span>
<span class="lineno"> 1581 </span>
<span class="lineno"> 1582 </span>-- | Create a term representing a pair type from two other terms, each
<span class="lineno"> 1583 </span>-- representing a type.
<span class="lineno"> 1584 </span>scPairType :: SharedContext
<span class="lineno"> 1585 </span>           -&gt; Term -- ^ Left projection type
<span class="lineno"> 1586 </span>           -&gt; Term -- ^ Right projection type
<span class="lineno"> 1587 </span>           -&gt; IO Term
<span class="lineno"> 1588 </span><span class="decl"><span class="istickedoff">scPairType sc t1 t2 =</span>
<span class="lineno"> 1589 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t1</span>
<span class="lineno"> 1590 </span><span class="spaces">     </span><span class="istickedoff">scEnsureValidTerm sc t2</span>
<span class="lineno"> 1591 </span><span class="spaces">     </span><span class="istickedoff">vt &lt;- unifyVarTypes <span class="nottickedoff">&quot;scPairType&quot;</span> <span class="nottickedoff">sc</span> (varTypes t1) (varTypes t2)</span>
<span class="lineno"> 1592 </span><span class="spaces">     </span><span class="istickedoff">let tf = FTermF (PairType t1 t2)</span>
<span class="lineno"> 1593 </span><span class="spaces">     </span><span class="istickedoff">s1 &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType t1)</span>
<span class="lineno"> 1594 </span><span class="spaces">     </span><span class="istickedoff">s2 &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType t2)</span>
<span class="lineno"> 1595 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc vt tf (Left (max s1 s2))</span></span>
<span class="lineno"> 1596 </span>
<span class="lineno"> 1597 </span>-- | Create a term giving the left projection of a 'Term' representing a pair.
<span class="lineno"> 1598 </span>scPairLeft :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1599 </span><span class="decl"><span class="istickedoff">scPairLeft sc t =</span>
<span class="lineno"> 1600 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t</span>
<span class="lineno"> 1601 </span><span class="spaces">     </span><span class="istickedoff">(ty, _) &lt;- ensurePairType <span class="nottickedoff">sc</span> =&lt;&lt; scTypeOf <span class="nottickedoff">sc</span> t</span>
<span class="lineno"> 1602 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right ty) <span class="nottickedoff">Left</span> (asSort ty)</span>
<span class="lineno"> 1603 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc (varTypes t) (FTermF (PairLeft t)) mty</span></span>
<span class="lineno"> 1604 </span>
<span class="lineno"> 1605 </span>-- | Create a term giving the right projection of a 'Term' representing a pair.
<span class="lineno"> 1606 </span>scPairRight :: SharedContext -&gt; Term -&gt; IO Term
<span class="lineno"> 1607 </span><span class="decl"><span class="istickedoff">scPairRight sc t =</span>
<span class="lineno"> 1608 </span><span class="spaces">  </span><span class="istickedoff">do scEnsureValidTerm sc t</span>
<span class="lineno"> 1609 </span><span class="spaces">     </span><span class="istickedoff">(_, ty) &lt;- ensurePairType <span class="nottickedoff">sc</span> =&lt;&lt; scTypeOf <span class="nottickedoff">sc</span> t</span>
<span class="lineno"> 1610 </span><span class="spaces">     </span><span class="istickedoff">let mty = maybe (Right ty) <span class="nottickedoff">Left</span> (asSort ty)</span>
<span class="lineno"> 1611 </span><span class="spaces">     </span><span class="istickedoff">scMakeTerm sc (varTypes t) (FTermF (PairRight t)) mty</span></span>
<span class="lineno"> 1612 </span>
<span class="lineno"> 1613 </span>-- | Create a term representing either the left or right projection of the
<span class="lineno"> 1614 </span>-- given 'Term', depending on the given 'Bool': left if @False@, right if @True@.
<span class="lineno"> 1615 </span>scPairSelector :: SharedContext -&gt; Term -&gt; Bool -&gt; IO Term
<span class="lineno"> 1616 </span><span class="decl"><span class="istickedoff">scPairSelector sc t False = scPairLeft sc t</span>
<span class="lineno"> 1617 </span><span class="spaces"></span><span class="istickedoff">scPairSelector sc t True = <span class="nottickedoff">scPairRight sc t</span></span></span>
<span class="lineno"> 1618 </span>
<span class="lineno"> 1619 </span>-- | Create a term representing the type of a non-dependent function, given a
<span class="lineno"> 1620 </span>-- parameter and result type (as 'Term's).
<span class="lineno"> 1621 </span>scFun :: SharedContext
<span class="lineno"> 1622 </span>      -&gt; Term -- ^ The parameter type
<span class="lineno"> 1623 </span>      -&gt; Term -- ^ The result type
<span class="lineno"> 1624 </span>      -&gt; IO Term
<span class="lineno"> 1625 </span><span class="decl"><span class="istickedoff">scFun sc a b = scPi sc wildcardVarName a b</span></span>
<span class="lineno"> 1626 </span>
<span class="lineno"> 1627 </span>-- | Create a term representing the type of a non-dependent n-ary function,
<span class="lineno"> 1628 </span>-- given a list of parameter types and a result type (as terms).
<span class="lineno"> 1629 </span>scFunAll :: SharedContext
<span class="lineno"> 1630 </span>         -&gt; [Term] -- ^ The parameter types
<span class="lineno"> 1631 </span>         -&gt; Term   -- ^ The result type
<span class="lineno"> 1632 </span>         -&gt; IO Term
<span class="lineno"> 1633 </span><span class="decl"><span class="istickedoff">scFunAll sc argTypes resultType = foldrM (scFun sc) resultType argTypes</span></span>
<span class="lineno"> 1634 </span>
<span class="lineno"> 1635 </span>-- | Create a lambda term of multiple arguments (curried) from a list
<span class="lineno"> 1636 </span>-- associating parameter names to types (as 'Term's) and a body.
<span class="lineno"> 1637 </span>-- The parameters are listed outermost first.
<span class="lineno"> 1638 </span>-- Variable names in the parameter list are in scope for all parameter
<span class="lineno"> 1639 </span>-- types occurring later in the list.
<span class="lineno"> 1640 </span>scLambdaList :: SharedContext
<span class="lineno"> 1641 </span>             -&gt; [(VarName, Term)] -- ^ List of parameter / parameter type pairs
<span class="lineno"> 1642 </span>             -&gt; Term -- ^ The body
<span class="lineno"> 1643 </span>             -&gt; IO Term
<span class="lineno"> 1644 </span><span class="decl"><span class="istickedoff">scLambdaList _ [] rhs = return rhs</span>
<span class="lineno"> 1645 </span><span class="spaces"></span><span class="istickedoff">scLambdaList sc ((nm,tp):r) rhs =</span>
<span class="lineno"> 1646 </span><span class="spaces">  </span><span class="istickedoff">scLambda sc nm tp =&lt;&lt; scLambdaList sc r rhs</span></span>
<span class="lineno"> 1647 </span>
<span class="lineno"> 1648 </span>-- | Create a (possibly dependent) function of multiple arguments (curried)
<span class="lineno"> 1649 </span>-- from a list associating parameter names to types (as 'Term's) and a body.
<span class="lineno"> 1650 </span>-- Variable names in the parameter list are in scope for all parameter
<span class="lineno"> 1651 </span>-- types occurring later in the list.
<span class="lineno"> 1652 </span>scPiList :: SharedContext
<span class="lineno"> 1653 </span>         -&gt; [(VarName, Term)] -- ^ List of parameter / parameter type pairs
<span class="lineno"> 1654 </span>         -&gt; Term -- ^ The body
<span class="lineno"> 1655 </span>         -&gt; IO Term
<span class="lineno"> 1656 </span><span class="decl"><span class="istickedoff">scPiList _ [] rhs = return rhs</span>
<span class="lineno"> 1657 </span><span class="spaces"></span><span class="istickedoff">scPiList sc ((nm,tp):r) rhs = scPi sc nm tp =&lt;&lt; scPiList sc r rhs</span></span>
<span class="lineno"> 1658 </span>
<span class="lineno"> 1659 </span>-- | Define a global constant with the specified base name (as
<span class="lineno"> 1660 </span>-- 'Text') and body.
<span class="lineno"> 1661 </span>-- The term for the body must not have any free variables.
<span class="lineno"> 1662 </span>-- A globally-unique name with the specified base name will be created
<span class="lineno"> 1663 </span>-- using 'scFreshName'.
<span class="lineno"> 1664 </span>-- The type of the body determines the type of the constant; to
<span class="lineno"> 1665 </span>-- specify a different formulation of the type, use 'scAscribe'.
<span class="lineno"> 1666 </span>scFreshConstant ::
<span class="lineno"> 1667 </span>  SharedContext -&gt;
<span class="lineno"> 1668 </span>  Text {- ^ The base name -} -&gt;
<span class="lineno"> 1669 </span>  Term {- ^ The body -} -&gt;
<span class="lineno"> 1670 </span>  IO Term
<span class="lineno"> 1671 </span><span class="decl"><span class="nottickedoff">scFreshConstant sc name rhs =</span>
<span class="lineno"> 1672 </span><span class="spaces">  </span><span class="nottickedoff">do ty &lt;- scTypeOf sc rhs</span>
<span class="lineno"> 1673 </span><span class="spaces">     </span><span class="nottickedoff">unless (closedTerm rhs) $ do</span>
<span class="lineno"> 1674 </span><span class="spaces">       </span><span class="nottickedoff">ty' &lt;- ppTerm sc PPS.defaultOpts ty</span>
<span class="lineno"> 1675 </span><span class="spaces">       </span><span class="nottickedoff">rhs' &lt;- ppTerm sc PPS.defaultOpts rhs</span>
<span class="lineno"> 1676 </span><span class="spaces">       </span><span class="nottickedoff">fail $ unlines [</span>
<span class="lineno"> 1677 </span><span class="spaces">           </span><span class="nottickedoff">&quot;scFreshConstant: term contains free variables&quot;,</span>
<span class="lineno"> 1678 </span><span class="spaces">           </span><span class="nottickedoff">&quot;name: &quot; ++ Text.unpack name,</span>
<span class="lineno"> 1679 </span><span class="spaces">           </span><span class="nottickedoff">&quot;ty: &quot; ++ ty',</span>
<span class="lineno"> 1680 </span><span class="spaces">           </span><span class="nottickedoff">&quot;rhs: &quot; ++ rhs'</span>
<span class="lineno"> 1681 </span><span class="spaces">        </span><span class="nottickedoff">]</span>
<span class="lineno"> 1682 </span><span class="spaces">     </span><span class="nottickedoff">nm &lt;- scFreshName sc name</span>
<span class="lineno"> 1683 </span><span class="spaces">     </span><span class="nottickedoff">scDeclareDef sc nm NoQualifier ty (Just rhs)</span></span>
<span class="lineno"> 1684 </span>
<span class="lineno"> 1685 </span>-- | Define a global constant with the specified name (as 'NameInfo')
<span class="lineno"> 1686 </span>-- and body.
<span class="lineno"> 1687 </span>-- The URI in the given 'NameInfo' must be globally unique.
<span class="lineno"> 1688 </span>-- The term for the body must not have any free variables.
<span class="lineno"> 1689 </span>-- The type of the body determines the type of the constant; to
<span class="lineno"> 1690 </span>-- specify a different formulation of the type, use 'scAscribe'.
<span class="lineno"> 1691 </span>scDefineConstant ::
<span class="lineno"> 1692 </span>  SharedContext -&gt;
<span class="lineno"> 1693 </span>  NameInfo {- ^ The name -} -&gt;
<span class="lineno"> 1694 </span>  Term {- ^ The body -} -&gt;
<span class="lineno"> 1695 </span>  IO Term
<span class="lineno"> 1696 </span><span class="decl"><span class="istickedoff">scDefineConstant sc nmi rhs =</span>
<span class="lineno"> 1697 </span><span class="spaces">  </span><span class="istickedoff">do ty &lt;- scTypeOf sc rhs</span>
<span class="lineno"> 1698 </span><span class="spaces">     </span><span class="istickedoff">unless (closedTerm rhs) $ <span class="nottickedoff">do</span></span>
<span class="lineno"> 1699 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">ty' &lt;- ppTerm sc PPS.defaultOpts ty</span></span>
<span class="lineno"> 1700 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">rhs' &lt;- ppTerm sc PPS.defaultOpts rhs</span></span>
<span class="lineno"> 1701 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [</span></span>
<span class="lineno"> 1702 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">&quot;scDefineConstant: term contains free variables&quot;,</span></span>
<span class="lineno"> 1703 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">&quot;nmi: &quot; ++ Text.unpack (toAbsoluteName nmi),</span></span>
<span class="lineno"> 1704 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">&quot;ty: &quot; ++ ty',</span></span>
<span class="lineno"> 1705 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">&quot;rhs: &quot; ++ rhs'</span></span>
<span class="lineno"> 1706 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1707 </span><span class="spaces">     </span><span class="istickedoff">nm &lt;- scRegisterName sc nmi</span>
<span class="lineno"> 1708 </span><span class="spaces">     </span><span class="istickedoff">scDeclareDef sc nm <span class="nottickedoff">NoQualifier</span> ty (Just rhs)</span></span>
<span class="lineno"> 1709 </span>
<span class="lineno"> 1710 </span>
<span class="lineno"> 1711 </span>-- | Declare a global opaque constant with the specified name (as
<span class="lineno"> 1712 </span>-- 'NameInfo') and type.
<span class="lineno"> 1713 </span>-- Such a constant has no definition, but unlike a variable it may be
<span class="lineno"> 1714 </span>-- used in other constant definitions and is not subject to
<span class="lineno"> 1715 </span>-- lambda-binding or substitution.
<span class="lineno"> 1716 </span>scOpaqueConstant ::
<span class="lineno"> 1717 </span>  SharedContext -&gt;
<span class="lineno"> 1718 </span>  NameInfo -&gt;
<span class="lineno"> 1719 </span>  Term {- ^ type of the constant -} -&gt;
<span class="lineno"> 1720 </span>  IO Term
<span class="lineno"> 1721 </span><span class="decl"><span class="istickedoff">scOpaqueConstant sc nmi ty =</span>
<span class="lineno"> 1722 </span><span class="spaces">  </span><span class="istickedoff">do _ &lt;- either pure <span class="nottickedoff">(ensureSort sc)</span> (stAppType ty)</span>
<span class="lineno"> 1723 </span><span class="spaces">     </span><span class="istickedoff">nm &lt;- scRegisterName sc nmi</span>
<span class="lineno"> 1724 </span><span class="spaces">     </span><span class="istickedoff">scDeclareDef sc nm <span class="nottickedoff">NoQualifier</span> ty Nothing</span></span>
<span class="lineno"> 1725 </span>
<span class="lineno"> 1726 </span>-- | Create a function application term from a global identifier and a list of
<span class="lineno"> 1727 </span>-- arguments (as 'Term's).
<span class="lineno"> 1728 </span>scGlobalApply :: SharedContext -&gt; Ident -&gt; [Term] -&gt; IO Term
<span class="lineno"> 1729 </span><span class="decl"><span class="istickedoff">scGlobalApply sc i ts =</span>
<span class="lineno"> 1730 </span><span class="spaces">    </span><span class="istickedoff">do c &lt;- scGlobalDef sc i</span>
<span class="lineno"> 1731 </span><span class="spaces">       </span><span class="istickedoff">scApplyAll sc c ts</span></span>
<span class="lineno"> 1732 </span>
<span class="lineno"> 1733 </span>
<span class="lineno"> 1734 </span>------------------------------------------------------------
<span class="lineno"> 1735 </span>
<span class="lineno"> 1736 </span>-- | The default instance of the SharedContext operations.
<span class="lineno"> 1737 </span>mkSharedContext :: IO SharedContext
<span class="lineno"> 1738 </span><span class="decl"><span class="istickedoff">mkSharedContext =</span>
<span class="lineno"> 1739 </span><span class="spaces">  </span><span class="istickedoff">do vr &lt;- newIORef (1 :: VarIndex) -- 0 is reserved for wildcardVarName.</span>
<span class="lineno"> 1740 </span><span class="spaces">     </span><span class="istickedoff">cr &lt;- newIORef emptyAppCache</span>
<span class="lineno"> 1741 </span><span class="spaces">     </span><span class="istickedoff">gr &lt;- newIORef HMap.empty</span>
<span class="lineno"> 1742 </span><span class="spaces">     </span><span class="istickedoff">mr &lt;- newIORef emptyModuleMap</span>
<span class="lineno"> 1743 </span><span class="spaces">     </span><span class="istickedoff">dr &lt;- newIORef emptyDisplayNameEnv</span>
<span class="lineno"> 1744 </span><span class="spaces">     </span><span class="istickedoff">ur &lt;- newIORef Map.empty</span>
<span class="lineno"> 1745 </span><span class="spaces">     </span><span class="istickedoff">-- The top 16 bits of the TermIndex form a unique ID for this</span>
<span class="lineno"> 1746 </span><span class="spaces">     </span><span class="istickedoff">-- particular SharedContext.</span>
<span class="lineno"> 1747 </span><span class="spaces">     </span><span class="istickedoff">-- We expect that the low 48 bits will never overflow.</span>
<span class="lineno"> 1748 </span><span class="spaces">     </span><span class="istickedoff">scid &lt;- getUniqueInt</span>
<span class="lineno"> 1749 </span><span class="spaces">     </span><span class="istickedoff">let i0 = scid `shiftL` 48</span>
<span class="lineno"> 1750 </span><span class="spaces">     </span><span class="istickedoff">tr &lt;- newIORef (i0 :: TermIndex)</span>
<span class="lineno"> 1751 </span><span class="spaces">     </span><span class="istickedoff">let j0 = i0 + (1 `shiftL` 48 - 1)</span>
<span class="lineno"> 1752 </span><span class="spaces">     </span><span class="istickedoff">ir &lt;- newIORef (IntRangeSet.singleton (i0, j0))</span>
<span class="lineno"> 1753 </span><span class="spaces">     </span><span class="istickedoff">pure $</span>
<span class="lineno"> 1754 </span><span class="spaces">       </span><span class="istickedoff">SharedContext</span>
<span class="lineno"> 1755 </span><span class="spaces">       </span><span class="istickedoff">{ scModuleMap = mr</span>
<span class="lineno"> 1756 </span><span class="spaces">       </span><span class="istickedoff">, scAppCache = cr</span>
<span class="lineno"> 1757 </span><span class="spaces">       </span><span class="istickedoff">, scNextVarIndex = vr</span>
<span class="lineno"> 1758 </span><span class="spaces">       </span><span class="istickedoff">, scDisplayNameEnv = dr</span>
<span class="lineno"> 1759 </span><span class="spaces">       </span><span class="istickedoff">, scURIEnv = ur</span>
<span class="lineno"> 1760 </span><span class="spaces">       </span><span class="istickedoff">, scGlobalEnv = gr</span>
<span class="lineno"> 1761 </span><span class="spaces">       </span><span class="istickedoff">, scNextTermIndex = tr</span>
<span class="lineno"> 1762 </span><span class="spaces">       </span><span class="istickedoff">, scValidTerms = ir</span>
<span class="lineno"> 1763 </span><span class="spaces">       </span><span class="istickedoff">}</span></span>
<span class="lineno"> 1764 </span>
<span class="lineno"> 1765 </span>-- | Instantiate some of the named variables in the term.
<span class="lineno"> 1766 </span>-- The 'IntMap' is keyed by 'VarIndex'.
<span class="lineno"> 1767 </span>-- Note: The replacement is _not_ applied recursively
<span class="lineno"> 1768 </span>-- to the terms in the substitution map.
<span class="lineno"> 1769 </span>scInstantiate :: SharedContext -&gt; IntMap Term -&gt; Term -&gt; IO Term
<span class="lineno"> 1770 </span><span class="decl"><span class="istickedoff">scInstantiate sc vmap t0 =</span>
<span class="lineno"> 1771 </span><span class="spaces">  </span><span class="istickedoff">do let domainVars = IntMap.keysSet vmap</span>
<span class="lineno"> 1772 </span><span class="spaces">     </span><span class="istickedoff">let rangeVars = foldMap freeVars vmap</span>
<span class="lineno"> 1773 </span><span class="spaces">     </span><span class="istickedoff">tcache &lt;- newCacheIntMap</span>
<span class="lineno"> 1774 </span><span class="spaces">     </span><span class="istickedoff">let memo :: Term -&gt; IO Term</span>
<span class="lineno"> 1775 </span><span class="spaces">         </span><span class="istickedoff">memo t =</span>
<span class="lineno"> 1776 </span><span class="spaces">           </span><span class="istickedoff">case t of</span>
<span class="lineno"> 1777 </span><span class="spaces">             </span><span class="istickedoff">STApp {stAppIndex = i} -&gt; useCache tcache i (go t)</span>
<span class="lineno"> 1778 </span><span class="spaces">         </span><span class="istickedoff">go :: Term -&gt; IO Term</span>
<span class="lineno"> 1779 </span><span class="spaces">         </span><span class="istickedoff">go t</span>
<span class="lineno"> 1780 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.disjoint domainVars (freeVars t) = pure t</span>
<span class="lineno"> 1781 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1782 </span><span class="spaces">             </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno"> 1783 </span><span class="spaces">               </span><span class="istickedoff">FTermF ftf     -&gt; scFlatTermF sc =&lt;&lt; traverse memo ftf</span>
<span class="lineno"> 1784 </span><span class="spaces">               </span><span class="istickedoff">App t1 t2      -&gt; scTermF sc =&lt;&lt; App &lt;$&gt; memo t1 &lt;*&gt; memo t2</span>
<span class="lineno"> 1785 </span><span class="spaces">               </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno"> 1786 </span><span class="spaces">                 </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1787 </span><span class="spaces">                    </span><span class="istickedoff">(x', t2') &lt;- goBinder x t1' t2</span>
<span class="lineno"> 1788 </span><span class="spaces">                    </span><span class="istickedoff">scLambda sc x' t1' t2'</span>
<span class="lineno"> 1789 </span><span class="spaces">               </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno"> 1790 </span><span class="spaces">                 </span><span class="istickedoff">do t1' &lt;- memo t1</span>
<span class="lineno"> 1791 </span><span class="spaces">                    </span><span class="istickedoff">(x', t2') &lt;- goBinder x <span class="nottickedoff">t1'</span> t2</span>
<span class="lineno"> 1792 </span><span class="spaces">                    </span><span class="istickedoff">scPi sc x' t1' t2'</span>
<span class="lineno"> 1793 </span><span class="spaces">               </span><span class="istickedoff">Constant {} -&gt; <span class="nottickedoff">pure t</span></span>
<span class="lineno"> 1794 </span><span class="spaces">               </span><span class="istickedoff">Variable nm tp -&gt;</span>
<span class="lineno"> 1795 </span><span class="spaces">                 </span><span class="istickedoff">case IntMap.lookup (vnIndex nm) vmap of</span>
<span class="lineno"> 1796 </span><span class="spaces">                   </span><span class="istickedoff">Just t' -&gt; pure t'</span>
<span class="lineno"> 1797 </span><span class="spaces">                   </span><span class="istickedoff">Nothing -&gt; scVariable sc nm =&lt;&lt; memo tp</span>
<span class="lineno"> 1798 </span><span class="spaces">         </span><span class="istickedoff">goBinder :: VarName -&gt; Term -&gt; Term -&gt; IO (VarName, Term)</span>
<span class="lineno"> 1799 </span><span class="spaces">         </span><span class="istickedoff">goBinder x@(vnIndex -&gt; i) t body</span>
<span class="lineno"> 1800 </span><span class="spaces">           </span><span class="istickedoff">| IntSet.member i rangeVars =</span>
<span class="lineno"> 1801 </span><span class="spaces">               </span><span class="istickedoff">-- Possibility of capture; rename bound variable.</span>
<span class="lineno"> 1802 </span><span class="spaces">               </span><span class="istickedoff">do x' &lt;- scFreshVarName sc (vnName x)</span>
<span class="lineno"> 1803 </span><span class="spaces">                  </span><span class="istickedoff">var &lt;- scVariable sc x' t</span>
<span class="lineno"> 1804 </span><span class="spaces">                  </span><span class="istickedoff">let vmap' = IntMap.insert i var vmap</span>
<span class="lineno"> 1805 </span><span class="spaces">                  </span><span class="istickedoff">body' &lt;- scInstantiate sc vmap' body</span>
<span class="lineno"> 1806 </span><span class="spaces">                  </span><span class="istickedoff">pure (x', body')</span>
<span class="lineno"> 1807 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlyfalse">IntMap.member i vmap</span> =</span>
<span class="lineno"> 1808 </span><span class="spaces">               </span><span class="istickedoff">-- Shadowing; remove entry from substitution.</span>
<span class="lineno"> 1809 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">do let vmap' = IntMap.delete i vmap</span></span>
<span class="lineno"> 1810 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">body' &lt;- scInstantiate sc vmap' body</span></span>
<span class="lineno"> 1811 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">pure (x, body')</span></span>
<span class="lineno"> 1812 </span><span class="spaces">           </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno"> 1813 </span><span class="spaces">               </span><span class="istickedoff">-- No possibility of shadowing or capture.</span>
<span class="lineno"> 1814 </span><span class="spaces">               </span><span class="istickedoff">do body' &lt;- memo body</span>
<span class="lineno"> 1815 </span><span class="spaces">                  </span><span class="istickedoff">pure (x, body')</span>
<span class="lineno"> 1816 </span><span class="spaces">     </span><span class="istickedoff">go t0</span></span>

</pre>
</body>
</html>
