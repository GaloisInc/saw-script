<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Interpreter
<span class="lineno">    3 </span>Description : Interpreter for SAW-Script files and statements.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    9 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">   10 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">   11 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   12 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   13 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   14 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">   15 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   16 </span>{-# LANGUAGE OverlappingInstances #-}
<span class="lineno">   17 </span>#endif
<span class="lineno">   18 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   19 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   20 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   21 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   22 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   23 </span>{-# LANGUAGE NondecreasingIndentation #-}
<span class="lineno">   24 </span>-- See Note [-Wincomplete-uni-patterns and irrefutable patterns] in SAWScript.Typechecker
<span class="lineno">   25 </span>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>module SAWScript.Interpreter
<span class="lineno">   28 </span>  ( interpretStmt
<span class="lineno">   29 </span>  , interpretFile
<span class="lineno">   30 </span>  , processFile
<span class="lineno">   31 </span>  , buildTopLevelEnv
<span class="lineno">   32 </span>  , primDocEnv
<span class="lineno">   33 </span>  , InteractiveMonad(..)
<span class="lineno">   34 </span>  )
<span class="lineno">   35 </span>  where
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   38 </span>import Control.Applicative
<span class="lineno">   39 </span>import Data.Traversable hiding ( mapM )
<span class="lineno">   40 </span>#endif
<span class="lineno">   41 </span>import qualified Control.Exception as X
<span class="lineno">   42 </span>import Control.Monad (unless, (&gt;=&gt;), when)
<span class="lineno">   43 </span>import Control.Monad.IO.Class (liftIO)
<span class="lineno">   44 </span>import qualified Data.ByteString as BS
<span class="lineno">   45 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   46 </span>import Data.List (genericLength)
<span class="lineno">   47 </span>import qualified Data.Map as Map
<span class="lineno">   48 </span>import Data.Map ( Map )
<span class="lineno">   49 </span>import qualified Data.Set as Set
<span class="lineno">   50 </span>import qualified Data.Text as Text
<span class="lineno">   51 </span>import Data.Text (Text)
<span class="lineno">   52 </span>import System.Directory (getCurrentDirectory, setCurrentDirectory)
<span class="lineno">   53 </span>import System.FilePath (takeDirectory)
<span class="lineno">   54 </span>import System.Environment (lookupEnv)
<span class="lineno">   55 </span>import System.Process (readProcess)
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>import qualified SAWSupport.Pretty as PPS (MemoStyle(..), Opts(..), defaultOpts, pShow, pShowText)
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import qualified SAWCentral.AST as SS
<span class="lineno">   60 </span>import qualified SAWCentral.Position as SS
<span class="lineno">   61 </span>import SAWCentral.AST (Located(..), Import(..), PrimitiveLifecycle(..), defaultAvailable)
<span class="lineno">   62 </span>import SAWCentral.Bisimulation
<span class="lineno">   63 </span>import SAWCentral.Builtins
<span class="lineno">   64 </span>import SAWCentral.Exceptions (failTypecheck)
<span class="lineno">   65 </span>import qualified SAWScript.Import
<span class="lineno">   66 </span>import SAWScript.HeapsterBuiltins
<span class="lineno">   67 </span>import SAWCentral.JavaExpr
<span class="lineno">   68 </span>import SAWCentral.LLVMBuiltins
<span class="lineno">   69 </span>import SAWCentral.Options
<span class="lineno">   70 </span>import SAWScript.Lexer (lexSAW)
<span class="lineno">   71 </span>import SAWScript.Typechecker (checkStmt)
<span class="lineno">   72 </span>import SAWScript.Parser (parseSchema)
<span class="lineno">   73 </span>import SAWScript.Panic (panic)
<span class="lineno">   74 </span>import SAWCentral.TopLevel
<span class="lineno">   75 </span>import SAWCentral.Utils
<span class="lineno">   76 </span>import SAWCentral.Value
<span class="lineno">   77 </span>import SAWCentral.SolverCache
<span class="lineno">   78 </span>import SAWCentral.SolverVersions
<span class="lineno">   79 </span>import SAWCentral.Proof (emptyTheoremDB)
<span class="lineno">   80 </span>import SAWCentral.Prover.Rewrite(basic_ss)
<span class="lineno">   81 </span>import SAWCentral.Prover.Exporter
<span class="lineno">   82 </span>import SAWCentral.Prover.MRSolver (emptyMREnv, emptyRefnset)
<span class="lineno">   83 </span>import SAWCentral.Yosys
<span class="lineno">   84 </span>import SAWCore.Conversion
<span class="lineno">   85 </span>import SAWCore.Module (Def(..), emptyModule, moduleDefs)
<span class="lineno">   86 </span>import SAWCore.Name (mkModuleName)
<span class="lineno">   87 </span>import SAWCore.Prim (rethrowEvalError)
<span class="lineno">   88 </span>import SAWCore.Rewriter (emptySimpset, rewritingSharedContext, scSimpset)
<span class="lineno">   89 </span>import SAWCore.SharedTerm
<span class="lineno">   90 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">   91 </span>import qualified CryptolSAWCore.CryptolEnv as CEnv
<span class="lineno">   92 </span>import qualified CryptolSAWCore.Monadify as Monadify
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>import qualified Lang.JVM.Codebase as JCB
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>import qualified CryptolSAWCore.Prelude as CryptolSAW
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>-- Crucible
<span class="lineno">   99 </span>import qualified Lang.Crucible.JVM as CJ
<span class="lineno">  100 </span>import           Mir.Intrinsics (MIR)
<span class="lineno">  101 </span>import qualified Mir.Mir as Mir
<span class="lineno">  102 </span>import qualified SAWCentral.Crucible.Common as CC
<span class="lineno">  103 </span>import qualified SAWCentral.Crucible.Common.MethodSpec as CMS
<span class="lineno">  104 </span>import qualified SAWCentral.Crucible.JVM.BuiltinsJVM as CJ
<span class="lineno">  105 </span>import           SAWCentral.Crucible.LLVM.Builtins
<span class="lineno">  106 </span>import           SAWCentral.Crucible.JVM.Builtins
<span class="lineno">  107 </span>import           SAWCentral.Crucible.MIR.Builtins
<span class="lineno">  108 </span>import           SAWCentral.Crucible.LLVM.X86
<span class="lineno">  109 </span>import           SAWCentral.Crucible.LLVM.Boilerplate
<span class="lineno">  110 </span>import           SAWCentral.Crucible.LLVM.Skeleton.Builtins
<span class="lineno">  111 </span>import           SAWCentral.Crucible.LLVM.FFI
<span class="lineno">  112 </span>import qualified SAWCentral.Crucible.LLVM.MethodSpecIR as CIR
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- Cryptol
<span class="lineno">  115 </span>import qualified Cryptol.Eval as V (PPOpts(..))
<span class="lineno">  116 </span>import qualified Cryptol.Backend.Monad as V (runEval)
<span class="lineno">  117 </span>import qualified Cryptol.Eval.Value as V (defaultPPOpts, ppValue)
<span class="lineno">  118 </span>import qualified Cryptol.Eval.Concrete as V (Concrete(..))
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>import qualified Prettyprinter.Render.Text as PP (putDoc)
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>import SAWScript.AutoMatch
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>import qualified Lang.Crucible.FunctionHandle as Crucible
<span class="lineno">  125 </span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>-- Support ---------------------------------------------------------------------
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- This is used to reject top-level execution of polymorphic
<span class="lineno">  130 </span>-- expressions. Assumes we aren't inside an uninstantiated forall
<span class="lineno">  131 </span>-- quantifier. Also assumes the typechecker has already approved the
<span class="lineno">  132 </span>-- type. This means we know it doesn't contain unbound named type
<span class="lineno">  133 </span>-- variables. Fail if we encounter a unification var.
<span class="lineno">  134 </span>--
<span class="lineno">  135 </span>-- XXX: this serves little purpose. A polymorphic expression must
<span class="lineno">  136 </span>-- either be a partially applied (or unapplied) polymorphic function,
<span class="lineno">  137 </span>-- in which case we aren't going to actually execute anything anyway,
<span class="lineno">  138 </span>-- or be fully applied but have a polymorphic return type, and the
<span class="lineno">  139 </span>-- only such functions we can have are those that don't return (like
<span class="lineno">  140 </span>-- &quot;fail&quot;) so we don't actually care what they produce. So this code
<span class="lineno">  141 </span>-- and the check that calls it should probably be removed.
<span class="lineno">  142 </span>--
<span class="lineno">  143 </span>-- XXX: also, this is here transiently so that the rejection continues
<span class="lineno">  144 </span>-- to work while the interaction between the interpreter and the
<span class="lineno">  145 </span>-- typechecker is rationalized. In the long run, the rejection should
<span class="lineno">  146 </span>-- really belong only to the repl for repl purposes and the
<span class="lineno">  147 </span>-- polymorphism check should be part of the currently nonexistent
<span class="lineno">  148 </span>-- incremental interface to the typechecker. Alternatively, if there
<span class="lineno">  149 </span>-- are cases that really require rejection of polymorphic expressions
<span class="lineno">  150 </span>-- at the top level, they also require rejection of polymorphic
<span class="lineno">  151 </span>-- expressions in nested do-blocks that aren't inside functions, and
<span class="lineno">  152 </span>-- it can and should all happen inside the typechecker.
<span class="lineno">  153 </span>isPolymorphic :: SS.Type -&gt; Bool
<span class="lineno">  154 </span><span class="decl"><span class="istickedoff">isPolymorphic ty0 = case ty0 of</span>
<span class="lineno">  155 </span><span class="spaces">    </span><span class="istickedoff">SS.TyCon _pos _tycon args -&gt; any isPolymorphic args</span>
<span class="lineno">  156 </span><span class="spaces">    </span><span class="istickedoff">SS.TyRecord _pos fields -&gt; <span class="nottickedoff">any isPolymorphic fields</span></span>
<span class="lineno">  157 </span><span class="spaces">    </span><span class="istickedoff">SS.TyVar _pos _a -&gt; False</span>
<span class="lineno">  158 </span><span class="spaces">    </span><span class="istickedoff">SS.TyUnifyVar _pos _ix -&gt; True</span></span>
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>-- Environment -----------------------------------------------------------------
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>-- The second argument (the schema, aka type) is Nothing in most
<span class="lineno">  164 </span>-- cases, but for Decls is taken from the Decl. This will always be
<span class="lineno">  165 </span>-- Just s for Decls that have been typechecked, which are the only
<span class="lineno">  166 </span>-- ones we should be handling here.
<span class="lineno">  167 </span>--
<span class="lineno">  168 </span>-- Meanwhile the Maybe Type field of PVar is also always Just ty for
<span class="lineno">  169 </span>-- patterns that have been typechecked, and the typechecker will have
<span class="lineno">  170 </span>-- established that the type of the pattern matches the type of the
<span class="lineno">  171 </span>-- Decl if there is one.
<span class="lineno">  172 </span>--
<span class="lineno">  173 </span>-- So we should be able to remove the schema argument (and with it the
<span class="lineno">  174 </span>-- mess for dividing up a passed-in tuple), but for the moment I'm
<span class="lineno">  175 </span>-- unwilling to in case there's something weird going on somewhere.
<span class="lineno">  176 </span>-- For the time being we'll just panic if the pattern type is missing
<span class="lineno">  177 </span>-- and use it to fill in the schema if there isn't a schema passed
<span class="lineno">  178 </span>-- down. We could also assert that the schema type and the pattern
<span class="lineno">  179 </span>-- type actually match, but it's intentionally difficult to do that
<span class="lineno">  180 </span>-- outside the typechecker and not really worthwhile.
<span class="lineno">  181 </span>--
<span class="lineno">  182 </span>-- XXX: at some point clean this up further.
<span class="lineno">  183 </span>--
<span class="lineno">  184 </span>bindPatternLocal :: SS.Pattern -&gt; Maybe SS.Schema -&gt; Value -&gt; LocalEnv -&gt; LocalEnv
<span class="lineno">  185 </span><span class="decl"><span class="istickedoff">bindPatternLocal pat ms v env =</span>
<span class="lineno">  186 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos _ -&gt;</span>
<span class="lineno">  188 </span><span class="spaces">      </span><span class="istickedoff">env</span>
<span class="lineno">  189 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _pos _x Nothing -&gt;</span>
<span class="lineno">  190 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  191 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Found pattern with no type in it&quot;,</span></span>
<span class="lineno">  192 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">&quot;Pattern: &quot; &lt;&gt; Text.pack (show pat)</span></span>
<span class="lineno">  193 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _pos x (Just ty) -&gt;</span>
<span class="lineno">  195 </span><span class="spaces">      </span><span class="istickedoff">let s = fromMaybe <span class="nottickedoff">(SS.tMono ty)</span> ms in</span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="istickedoff">extendLocal x s <span class="nottickedoff">Nothing</span> v env</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple _pos ps -&gt;</span>
<span class="lineno">  198 </span><span class="spaces">      </span><span class="istickedoff">case v of</span>
<span class="lineno">  199 </span><span class="spaces">        </span><span class="istickedoff">VTuple vs -&gt; foldr ($) env (zipWith3 bindPatternLocal ps mss vs)</span>
<span class="lineno">  200 </span><span class="spaces">          </span><span class="istickedoff">where mss = case ms of</span>
<span class="lineno">  201 </span><span class="spaces">                  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  202 </span><span class="spaces">                      </span><span class="istickedoff">repeat <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  203 </span><span class="spaces">                  </span><span class="istickedoff">Just (SS.Forall ks (SS.TyCon _ (SS.TupleCon _) ts)) -&gt;</span>
<span class="lineno">  204 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">[ Just (SS.Forall ks t) | t &lt;- ts ]</span></span>
<span class="lineno">  205 </span><span class="spaces">                  </span><span class="istickedoff">Just t -&gt;</span>
<span class="lineno">  206 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  207 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple type, got &quot; &lt;&gt; Text.pack (show t)</span></span>
<span class="lineno">  208 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  209 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternLocal&quot; [</span></span>
<span class="lineno">  211 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple value; got &quot; &lt;&gt; Text.pack (show v)</span></span>
<span class="lineno">  212 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>-- See notes in bindPatternLocal above regading the schema argument.
<span class="lineno">  215 </span>bindPatternEnv :: SS.Pattern -&gt; Maybe SS.Schema -&gt; Value -&gt; TopLevelRW -&gt; TopLevel TopLevelRW
<span class="lineno">  216 </span><span class="decl"><span class="istickedoff">bindPatternEnv pat ms v env =</span>
<span class="lineno">  217 </span><span class="spaces">  </span><span class="istickedoff">case pat of</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos _   -&gt;</span>
<span class="lineno">  219 </span><span class="spaces">        </span><span class="istickedoff">pure env</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _pos _x Nothing -&gt;</span>
<span class="lineno">  221 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternEnv&quot; [</span></span>
<span class="lineno">  222 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Found pattern with no type in it&quot;,</span></span>
<span class="lineno">  223 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Pattern: &quot; &lt;&gt; Text.pack (show pat)</span></span>
<span class="lineno">  224 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _pos x (Just ty) -&gt; do</span>
<span class="lineno">  226 </span><span class="spaces">        </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  227 </span><span class="spaces">        </span><span class="istickedoff">let s = fromMaybe <span class="nottickedoff">(SS.tMono ty)</span> ms</span>
<span class="lineno">  228 </span><span class="spaces">        </span><span class="istickedoff">liftIO $ extendEnv <span class="nottickedoff">sc</span> x s <span class="nottickedoff">Nothing</span> v env</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple _pos ps -&gt;</span>
<span class="lineno">  230 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case v of</span></span>
<span class="lineno">  231 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">VTuple vs -&gt; foldr (=&lt;&lt;) (pure env) (zipWith3 bindPatternEnv ps mss vs)</span></span>
<span class="lineno">  232 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">where mss = case ms of</span></span>
<span class="lineno">  233 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; repeat Nothing</span></span>
<span class="lineno">  234 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Just (SS.Forall ks (SS.TyCon _ (SS.TupleCon _) ts)) -&gt;</span></span>
<span class="lineno">  235 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">[ Just (SS.Forall ks t) | t &lt;- ts ]</span></span>
<span class="lineno">  236 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">Just t -&gt;</span></span>
<span class="lineno">  237 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternEnv&quot; [</span></span>
<span class="lineno">  238 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple type, got &quot; &lt;&gt; Text.pack (show t)</span></span>
<span class="lineno">  239 </span><span class="spaces">                      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  240 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">_ -&gt;</span></span>
<span class="lineno">  241 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;bindPatternEnv&quot; [</span></span>
<span class="lineno">  242 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Expected tuple value; got &quot; &lt;&gt; Text.pack (show v)</span></span>
<span class="lineno">  243 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>-- Typechecker ----------------------------------------------------------------
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>-- Process a typechecker result.
<span class="lineno">  248 </span>-- Wraps the typechecker in the stuff needed to print its warnings and errors.
<span class="lineno">  249 </span>--
<span class="lineno">  250 </span>-- XXX: this code should probably live inside the typechecker.
<span class="lineno">  251 </span>--
<span class="lineno">  252 </span>-- Usage is processTypeCheck $ checkStmt ...
<span class="lineno">  253 </span>type MsgList = [(SS.Pos, String)]
<span class="lineno">  254 </span>processTypeCheck :: InteractiveMonad m =&gt; (Either MsgList a, MsgList) -&gt; m a
<span class="lineno">  255 </span><span class="decl"><span class="istickedoff">processTypeCheck (errs_or_output, warns) =</span>
<span class="lineno">  256 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">let issueWarning (pos, msg) =</span>
<span class="lineno">  258 </span><span class="spaces">          </span><span class="istickedoff">-- XXX the print functions should be what knows how to show positions...</span>
<span class="lineno">  259 </span><span class="spaces">          </span><span class="istickedoff">printOutLnTop Warn (show pos ++ &quot;: Warning: &quot; ++ msg)</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">mapM_ issueWarning warns</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="istickedoff">either failTypecheck return errs_or_output</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>-- Interpretation of SAWScript -------------------------------------------------
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>interpret :: SS.Expr -&gt; TopLevel Value
<span class="lineno">  266 </span><span class="decl"><span class="istickedoff">interpret expr =</span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span> in</span>
<span class="lineno">  268 </span><span class="spaces">    </span><span class="istickedoff">case expr of</span>
<span class="lineno">  269 </span><span class="spaces">      </span><span class="istickedoff">SS.Bool _ b              -&gt; <span class="nottickedoff">return $ VBool b</span></span>
<span class="lineno">  270 </span><span class="spaces">      </span><span class="istickedoff">SS.String _ s            -&gt; return $ VString s</span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff">SS.Int _ z               -&gt; return $ VInteger z</span>
<span class="lineno">  272 </span><span class="spaces">      </span><span class="istickedoff">SS.Code str              -&gt; do sc &lt;- getSharedContext</span>
<span class="lineno">  273 </span><span class="spaces">                                     </span><span class="istickedoff">cenv &lt;- fmap rwCryptol getMergedEnv</span>
<span class="lineno">  274 </span><span class="spaces">                                     </span><span class="istickedoff">--io $ putStrLn $ &quot;Parsing code: &quot; ++ show str</span>
<span class="lineno">  275 </span><span class="spaces">                                     </span><span class="istickedoff">--showCryptolEnv' cenv</span>
<span class="lineno">  276 </span><span class="spaces">                                     </span><span class="istickedoff">t &lt;- io $ CEnv.parseTypedTerm sc cenv</span>
<span class="lineno">  277 </span><span class="spaces">                                             </span><span class="istickedoff">$ locToInput str</span>
<span class="lineno">  278 </span><span class="spaces">                                     </span><span class="istickedoff">return (toValue t)</span>
<span class="lineno">  279 </span><span class="spaces">      </span><span class="istickedoff">SS.CType str             -&gt; do cenv &lt;- fmap rwCryptol getMergedEnv</span>
<span class="lineno">  280 </span><span class="spaces">                                     </span><span class="istickedoff">s &lt;- io $ CEnv.parseSchema cenv</span>
<span class="lineno">  281 </span><span class="spaces">                                             </span><span class="istickedoff">$ locToInput str</span>
<span class="lineno">  282 </span><span class="spaces">                                     </span><span class="istickedoff">return (toValue s)</span>
<span class="lineno">  283 </span><span class="spaces">      </span><span class="istickedoff">SS.Array _ es            -&gt; VArray &lt;$&gt; traverse interpret es</span>
<span class="lineno">  284 </span><span class="spaces">      </span><span class="istickedoff">SS.Block _ stmts         -&gt; interpretStmts stmts</span>
<span class="lineno">  285 </span><span class="spaces">      </span><span class="istickedoff">SS.Tuple _ es            -&gt; VTuple &lt;$&gt; traverse interpret es</span>
<span class="lineno">  286 </span><span class="spaces">      </span><span class="istickedoff">SS.Record _ bs           -&gt; VRecord &lt;$&gt; traverse interpret bs</span>
<span class="lineno">  287 </span><span class="spaces">      </span><span class="istickedoff">SS.Index _ e1 e2         -&gt; <span class="nottickedoff">do a &lt;- interpret e1</span></span>
<span class="lineno">  288 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">i &lt;- interpret e2</span></span>
<span class="lineno">  289 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">return (indexValue a i)</span></span>
<span class="lineno">  290 </span><span class="spaces">      </span><span class="istickedoff">SS.Lookup _ e n          -&gt; <span class="nottickedoff">do a &lt;- interpret e</span></span>
<span class="lineno">  291 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">return (lookupValue a n)</span></span>
<span class="lineno">  292 </span><span class="spaces">      </span><span class="istickedoff">SS.TLookup _ e i         -&gt; <span class="nottickedoff">do a &lt;- interpret e</span></span>
<span class="lineno">  293 </span><span class="spaces">                                     </span><span class="istickedoff"><span class="nottickedoff">return (tupleLookupValue a i)</span></span>
<span class="lineno">  294 </span><span class="spaces">      </span><span class="istickedoff">SS.Var x                 -&gt; do rw &lt;- getMergedEnv</span>
<span class="lineno">  295 </span><span class="spaces">                                     </span><span class="istickedoff">case Map.lookup x (rwValueInfo rw) of</span>
<span class="lineno">  296 </span><span class="spaces">                                       </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ Text.unpack $ &quot;unknown variable: &quot; &lt;&gt; SS.getVal x</span></span>
<span class="lineno">  297 </span><span class="spaces">                                       </span><span class="istickedoff">Just (lc, _ty, v)</span>
<span class="lineno">  298 </span><span class="spaces">                                         </span><span class="istickedoff">| <span class="tickonlytrue">Set.member lc (rwPrimsAvail rw)</span> -&gt;</span>
<span class="lineno">  299 </span><span class="spaces">                                              </span><span class="istickedoff">return (addTrace (show x) v)</span>
<span class="lineno">  300 </span><span class="spaces">                                         </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt;</span>
<span class="lineno">  301 </span><span class="spaces">                                              </span><span class="istickedoff"><span class="nottickedoff">fail $ Text.unpack $ &quot;inaccessible variable: &quot; &lt;&gt; SS.getVal x</span></span>
<span class="lineno">  302 </span><span class="spaces">      </span><span class="istickedoff">SS.Function _ pat e      -&gt; do env &lt;- getLocalEnv</span>
<span class="lineno">  303 </span><span class="spaces">                                     </span><span class="istickedoff">let f v = withLocalEnv (bindPatternLocal pat <span class="nottickedoff">Nothing</span> v env) (interpret e)</span>
<span class="lineno">  304 </span><span class="spaces">                                     </span><span class="istickedoff">return $ VLambda f</span>
<span class="lineno">  305 </span><span class="spaces">      </span><span class="istickedoff">SS.Application _ e1 e2   -&gt; do v1 &lt;- interpret e1</span>
<span class="lineno">  306 </span><span class="spaces">                                     </span><span class="istickedoff">v2 &lt;- interpret e2</span>
<span class="lineno">  307 </span><span class="spaces">                                     </span><span class="istickedoff">case v1 of</span>
<span class="lineno">  308 </span><span class="spaces">                                       </span><span class="istickedoff">VLambda f -&gt; f v2</span>
<span class="lineno">  309 </span><span class="spaces">                                       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ &quot;interpret Application: &quot; ++ show v1</span></span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">SS.Let _ dg e            -&gt; do env' &lt;- interpretDeclGroup dg</span>
<span class="lineno">  311 </span><span class="spaces">                                     </span><span class="istickedoff">withLocalEnv env' (interpret e)</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">SS.TSig _ e _            -&gt; <span class="nottickedoff">interpret e</span></span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">SS.IfThenElse _ e1 e2 e3 -&gt; do v1 &lt;- interpret e1</span>
<span class="lineno">  314 </span><span class="spaces">                                     </span><span class="istickedoff">case v1 of</span>
<span class="lineno">  315 </span><span class="spaces">                                       </span><span class="istickedoff">VBool b -&gt; interpret (if b then e2 else e3)</span>
<span class="lineno">  316 </span><span class="spaces">                                       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail $ &quot;interpret IfThenElse: &quot; ++ show v1</span></span></span>
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>locToInput :: Located Text -&gt; CEnv.InputText
<span class="lineno">  319 </span><span class="decl"><span class="istickedoff">locToInput l = CEnv.InputText { CEnv.inpText = getVal l</span>
<span class="lineno">  320 </span><span class="spaces">                              </span><span class="istickedoff">, CEnv.inpFile = file</span>
<span class="lineno">  321 </span><span class="spaces">                              </span><span class="istickedoff">, CEnv.inpLine = ln</span>
<span class="lineno">  322 </span><span class="spaces">                              </span><span class="istickedoff">, CEnv.inpCol  = col + 2 -- for dropped }}</span>
<span class="lineno">  323 </span><span class="spaces">                              </span><span class="istickedoff">}</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="istickedoff">(file, ln, col) = extract $ locatedPos l</span>
<span class="lineno">  326 </span><span class="spaces">  </span><span class="istickedoff">extract pos = case pos of</span>
<span class="lineno">  327 </span><span class="spaces">      </span><span class="istickedoff">SS.Range f sl sc _ _ -&gt; (f,sl, sc)</span>
<span class="lineno">  328 </span><span class="spaces">      </span><span class="istickedoff">SS.FileOnlyPos f -&gt; <span class="nottickedoff">(f, 1, 1)</span></span>
<span class="lineno">  329 </span><span class="spaces">      </span><span class="istickedoff">SS.FileAndFunctionPos f _ -&gt; <span class="nottickedoff">(f, 1, 1)</span></span>
<span class="lineno">  330 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInferred _ pos' -&gt; <span class="nottickedoff">extract pos'</span></span>
<span class="lineno">  331 </span><span class="spaces">      </span><span class="istickedoff">SS.PosInternal s -&gt; <span class="nottickedoff">(s,1,1)</span></span>
<span class="lineno">  332 </span><span class="spaces">      </span><span class="istickedoff">SS.PosREPL       -&gt; <span class="nottickedoff">(&quot;&lt;interactive&gt;&quot;, 1, 1)</span></span>
<span class="lineno">  333 </span><span class="spaces">      </span><span class="istickedoff">SS.Unknown       -&gt; <span class="nottickedoff">(&quot;Unknown&quot;, 1, 1)</span></span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>interpretDecl :: LocalEnv -&gt; SS.Decl -&gt; TopLevel LocalEnv
<span class="lineno">  336 </span><span class="decl"><span class="istickedoff">interpretDecl env (SS.Decl _ pat mt expr) = do</span>
<span class="lineno">  337 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- interpret expr</span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="istickedoff">return (bindPatternLocal pat mt v env)</span></span>
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>interpretFunction :: LocalEnv -&gt; SS.Expr -&gt; Value
<span class="lineno">  341 </span><span class="decl"><span class="istickedoff">interpretFunction env expr =</span>
<span class="lineno">  342 </span><span class="spaces">    </span><span class="istickedoff">case expr of</span>
<span class="lineno">  343 </span><span class="spaces">      </span><span class="istickedoff">SS.Function _ pat e -&gt; VLambda <span class="nottickedoff">f</span></span>
<span class="lineno">  344 </span><span class="spaces">        </span><span class="istickedoff">where <span class="nottickedoff">f v = withLocalEnv (bindPatternLocal pat Nothing v env) (interpret e)</span></span>
<span class="lineno">  345 </span><span class="spaces">      </span><span class="istickedoff">SS.TSig _ e _ -&gt; <span class="nottickedoff">interpretFunction env e</span></span>
<span class="lineno">  346 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error &quot;interpretFunction: not a function&quot;</span></span></span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>interpretDeclGroup :: SS.DeclGroup -&gt; TopLevel LocalEnv
<span class="lineno">  349 </span><span class="decl"><span class="istickedoff">interpretDeclGroup (SS.NonRecursive d) =</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">do env &lt;- getLocalEnv</span>
<span class="lineno">  351 </span><span class="spaces">       </span><span class="istickedoff">interpretDecl env d</span>
<span class="lineno">  352 </span><span class="spaces"></span><span class="istickedoff">interpretDeclGroup (SS.Recursive ds) =</span>
<span class="lineno">  353 </span><span class="spaces">    </span><span class="istickedoff">do env &lt;- getLocalEnv</span>
<span class="lineno">  354 </span><span class="spaces">       </span><span class="istickedoff">let addDecl (SS.Decl _ pat mty e) = bindPatternLocal pat <span class="nottickedoff">mty</span> (interpretFunction <span class="nottickedoff">env'</span> e)</span>
<span class="lineno">  355 </span><span class="spaces">           </span><span class="istickedoff">env' = foldr addDecl env ds</span>
<span class="lineno">  356 </span><span class="spaces">       </span><span class="istickedoff">return env'</span></span>
<span class="lineno">  357 </span>
<span class="lineno">  358 </span>interpretStmts :: [SS.Stmt] -&gt; TopLevel Value
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff">interpretStmts stmts =</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span> in</span>
<span class="lineno">  361 </span><span class="spaces">    </span><span class="istickedoff">-- XXX are the uses of withPosition here suitable? not super clear</span>
<span class="lineno">  362 </span><span class="spaces">    </span><span class="istickedoff">case stmts of</span>
<span class="lineno">  363 </span><span class="spaces">      </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">fail &quot;empty block&quot;</span></span>
<span class="lineno">  364 </span><span class="spaces">      </span><span class="istickedoff">[SS.StmtBind pos (SS.PWild _patpos _) e] -&gt; withPosition pos (interpret e)</span>
<span class="lineno">  365 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtBind pos pat e : ss -&gt;</span>
<span class="lineno">  366 </span><span class="spaces">          </span><span class="istickedoff">do env &lt;- getLocalEnv</span>
<span class="lineno">  367 </span><span class="spaces">             </span><span class="istickedoff">v1 &lt;- withPosition <span class="nottickedoff">pos</span> (interpret e)</span>
<span class="lineno">  368 </span><span class="spaces">             </span><span class="istickedoff">let f v = withLocalEnv (bindPatternLocal pat Nothing v env) (interpretStmts ss)</span>
<span class="lineno">  369 </span><span class="spaces">             </span><span class="istickedoff">bindValue pos v1 (VLambda f)</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtLet pos bs : ss -&gt;</span>
<span class="lineno">  371 </span><span class="spaces">          </span><span class="istickedoff">-- Caution: the position pos is not the correct position for</span>
<span class="lineno">  372 </span><span class="spaces">          </span><span class="istickedoff">-- the block ss. However, interpret on Block ignores the</span>
<span class="lineno">  373 </span><span class="spaces">          </span><span class="istickedoff">-- position there, so all we need is a placeholder for it to</span>
<span class="lineno">  374 </span><span class="spaces">          </span><span class="istickedoff">-- ignore. Therefore, don't take the trouble to compute the</span>
<span class="lineno">  375 </span><span class="spaces">          </span><span class="istickedoff">-- correct position (the bounding box on the statements ss).</span>
<span class="lineno">  376 </span><span class="spaces">          </span><span class="istickedoff">interpret (SS.Let <span class="nottickedoff">pos</span> bs (SS.Block <span class="nottickedoff">pos</span> ss))</span>
<span class="lineno">  377 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtCode _ s : ss -&gt;</span>
<span class="lineno">  378 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do sc &lt;- getSharedContext</span></span>
<span class="lineno">  379 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">rw &lt;- getMergedEnv</span></span>
<span class="lineno">  380 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  381 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">ce' &lt;- io $ CEnv.parseDecls sc (rwCryptol rw) $ locToInput s</span></span>
<span class="lineno">  382 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">-- FIXME: Local bindings get saved into the global cryptol environment here.</span></span>
<span class="lineno">  383 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">-- We should change parseDecls to return only the new bindings instead.</span></span>
<span class="lineno">  384 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">putTopLevelRW $ rw{rwCryptol = ce'}</span></span>
<span class="lineno">  385 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">interpretStmts ss</span></span>
<span class="lineno">  386 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtImport _ _ : _ -&gt;</span>
<span class="lineno">  387 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do fail &quot;block import unimplemented&quot;</span></span>
<span class="lineno">  388 </span><span class="spaces">      </span><span class="istickedoff">SS.StmtTypedef _ name ty : ss -&gt;</span>
<span class="lineno">  389 </span><span class="spaces">          </span><span class="istickedoff">do env &lt;- getLocalEnv</span>
<span class="lineno">  390 </span><span class="spaces">             </span><span class="istickedoff">let env' = LocalTypedef <span class="nottickedoff">(getVal name)</span> <span class="nottickedoff">ty</span> : env</span>
<span class="lineno">  391 </span><span class="spaces">             </span><span class="istickedoff">withLocalEnv env' (interpretStmts ss)</span></span>
<span class="lineno">  392 </span>
<span class="lineno">  393 </span>stmtInterpreter :: StmtInterpreter
<span class="lineno">  394 </span><span class="decl"><span class="nottickedoff">stmtInterpreter ro rw stmts =</span>
<span class="lineno">  395 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; runTopLevel (withLocalEnv emptyLocal (interpretStmts stmts)) ro rw</span></span>
<span class="lineno">  396 </span>
<span class="lineno">  397 </span>-- Get the type of an AST element. For now, only patterns because that's
<span class="lineno">  398 </span>-- what we're using.
<span class="lineno">  399 </span>--
<span class="lineno">  400 </span>-- Assumes we have been through the typechecker and the types are filled in.
<span class="lineno">  401 </span>--
<span class="lineno">  402 </span>-- XXX: this should be a typeclass function with instances for all the AST
<span class="lineno">  403 </span>-- types.
<span class="lineno">  404 </span>---
<span class="lineno">  405 </span>-- XXX: also it should be moved to ASTUtil once we have such a place.
<span class="lineno">  406 </span>getType :: SS.Pattern -&gt; SS.Type
<span class="lineno">  407 </span><span class="decl"><span class="istickedoff">getType pat = case pat of</span>
<span class="lineno">  408 </span><span class="spaces">    </span><span class="istickedoff">SS.PWild _pos ~(Just t) -&gt; t</span>
<span class="lineno">  409 </span><span class="spaces">    </span><span class="istickedoff">SS.PVar _pos _x ~(Just t) -&gt; t</span>
<span class="lineno">  410 </span><span class="spaces">    </span><span class="istickedoff">SS.PTuple tuplepos pats -&gt;</span>
<span class="lineno">  411 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">SS.TyCon tuplepos (SS.TupleCon (genericLength pats)) (map getType pats)</span></span></span>
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>processStmtBind ::
<span class="lineno">  414 </span>  InteractiveMonad m =&gt;
<span class="lineno">  415 </span>  Bool -&gt;
<span class="lineno">  416 </span>  SS.Pattern -&gt;
<span class="lineno">  417 </span>  SS.Expr -&gt;
<span class="lineno">  418 </span>  m ()
<span class="lineno">  419 </span><span class="decl"><span class="istickedoff">processStmtBind printBinds pat expr = do -- mx mt</span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- liftTopLevel getMergedEnv</span>
<span class="lineno">  421 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  422 </span><span class="spaces">  </span><span class="istickedoff">val &lt;- liftTopLevel $ interpret expr</span>
<span class="lineno">  423 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  424 </span><span class="spaces">  </span><span class="istickedoff">-- Fetch the type from updated pattern, since the typechecker will</span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="istickedoff">-- have filled it in there.</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="istickedoff">--</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="istickedoff">-- Note that this type won't include the current monad type, because</span>
<span class="lineno">  428 </span><span class="spaces">  </span><span class="istickedoff">-- it's the type of the value that the pattern on the left of &lt;- is</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="istickedoff">-- trying to bind.</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="istickedoff">let ty = getType pat</span>
<span class="lineno">  431 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="istickedoff">-- Reject polymorphic values. XXX: as noted above this should either</span>
<span class="lineno">  433 </span><span class="spaces">  </span><span class="istickedoff">-- be inside the typechecker or restricted to the repl.</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="istickedoff">when (isPolymorphic ty) $ fail $ &quot;Not a monomorphic type: &quot; ++ PPS.pShow ty</span>
<span class="lineno">  435 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  436 </span><span class="spaces">  </span><span class="istickedoff">-- Run the resulting TopLevel (or ProofScript) action.</span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- actionFromValue val</span>
<span class="lineno">  438 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  439 </span><span class="spaces">  </span><span class="istickedoff">--io $ putStrLn $ &quot;Top-level bind: &quot; ++ show mx</span>
<span class="lineno">  440 </span><span class="spaces">  </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  441 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="istickedoff">-- When in the repl, print the result.</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">when printBinds $ do</span>
<span class="lineno">  444 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">opts = rwPPOpts rw</span></span>
<span class="lineno">  445 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="istickedoff">-- Extract the variable, if any, from the pattern. If there isn't</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">-- any single variable use &quot;it&quot;.</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">name = case pat of</span></span>
<span class="lineno">  449 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PWild _patpos _t -&gt; &quot;it&quot;</span></span>
<span class="lineno">  450 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PVar _patpos x _t -&gt; getVal x</span></span>
<span class="lineno">  451 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">SS.PTuple _patpos _pats -&gt; &quot;it&quot;</span></span>
<span class="lineno">  452 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">-- Print non-unit result if it was not bound to a variable</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="istickedoff">case pat of</span>
<span class="lineno">  455 </span><span class="spaces">      </span><span class="istickedoff">SS.PWild _ _ | <span class="tickonlyfalse">not (isVUnit result)</span> -&gt;</span>
<span class="lineno">  456 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $</span></span>
<span class="lineno">  457 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span></span>
<span class="lineno">  458 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">printOutLnTop Info (showsPrecValue opts nenv 0 result &quot;&quot;)</span></span>
<span class="lineno">  459 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return ()</span>
<span class="lineno">  460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  461 </span><span class="spaces">    </span><span class="istickedoff">-- Print function type if result was a function</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">case ty of</span>
<span class="lineno">  463 </span><span class="spaces">      </span><span class="istickedoff">SS.TyCon _ SS.FunCon _ -&gt;</span>
<span class="lineno">  464 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">liftTopLevel $ printOutLnTop Info $ Text.unpack $ name &lt;&gt; &quot; : &quot; &lt;&gt; PPS.pShowText ty</span></span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; return ()</span>
<span class="lineno">  466 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  467 </span><span class="spaces">  </span><span class="istickedoff">liftTopLevel $</span>
<span class="lineno">  468 </span><span class="spaces">   </span><span class="istickedoff">do rw' &lt;- getTopLevelRW</span>
<span class="lineno">  469 </span><span class="spaces">      </span><span class="istickedoff">putTopLevelRW =&lt;&lt; bindPatternEnv pat (Just (SS.tMono ty)) result rw'</span></span>
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>
<span class="lineno">  472 </span>class (Monad m, MonadFail m) =&gt; InteractiveMonad m where
<span class="lineno">  473 </span>  liftTopLevel :: TopLevel a -&gt; m a
<span class="lineno">  474 </span>  withTopLevel :: (forall b. TopLevel b -&gt; TopLevel b) -&gt; m a -&gt; m a
<span class="lineno">  475 </span>  actionFromValue :: FromValue a =&gt; Value -&gt; m a
<span class="lineno">  476 </span>  getMonadContext :: m SS.Context
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>instance InteractiveMonad TopLevel where
<span class="lineno">  479 </span>  <span class="decl"><span class="istickedoff">liftTopLevel m = m</span></span>
<span class="lineno">  480 </span>  <span class="decl"><span class="istickedoff">withTopLevel f m = f m</span></span>
<span class="lineno">  481 </span>  <span class="decl"><span class="istickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  482 </span>  <span class="decl"><span class="istickedoff">getMonadContext = return SS.TopLevel</span></span>
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>instance InteractiveMonad ProofScript where
<span class="lineno">  485 </span>  <span class="decl"><span class="nottickedoff">liftTopLevel m = scriptTopLevel m</span></span>
<span class="lineno">  486 </span>  <span class="decl"><span class="nottickedoff">withTopLevel f (ProofScript m) = ProofScript (underExceptT (underStateT f) m)</span></span>
<span class="lineno">  487 </span>  <span class="decl"><span class="nottickedoff">actionFromValue = fromValue</span></span>
<span class="lineno">  488 </span>  <span class="decl"><span class="nottickedoff">getMonadContext = return SS.ProofScript</span></span>
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>-- | Interpret a block-level statement in an interactive monad (TopLevel or ProofScript)
<span class="lineno">  491 </span>interpretStmt :: InteractiveMonad m =&gt;
<span class="lineno">  492 </span>  Bool {-^ whether to print non-unit result values -} -&gt;
<span class="lineno">  493 </span>  SS.Stmt -&gt;
<span class="lineno">  494 </span>  m ()
<span class="lineno">  495 </span><span class="decl"><span class="istickedoff">interpretStmt printBinds stmt = do</span>
<span class="lineno">  496 </span><span class="spaces">  </span><span class="istickedoff">let ?fileReader = BS.readFile</span>
<span class="lineno">  497 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  498 </span><span class="spaces">  </span><span class="istickedoff">ctx &lt;- getMonadContext</span>
<span class="lineno">  499 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- liftTopLevel getMergedEnv</span>
<span class="lineno">  500 </span><span class="spaces">  </span><span class="istickedoff">let valueInfo = rwValueInfo rw</span>
<span class="lineno">  501 </span><span class="spaces">      </span><span class="istickedoff">valueInfo' = Map.map (\(lc, ty, _v) -&gt; (lc, ty)) valueInfo</span>
<span class="lineno">  502 </span><span class="spaces">  </span><span class="istickedoff">stmt' &lt;- processTypeCheck $ checkStmt (rwPrimsAvail rw) valueInfo' (rwTypeInfo rw) ctx stmt</span>
<span class="lineno">  503 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  504 </span><span class="spaces">  </span><span class="istickedoff">case stmt' of</span>
<span class="lineno">  505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  506 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtBind pos pat expr -&gt;</span>
<span class="lineno">  507 </span><span class="spaces">      </span><span class="istickedoff">withTopLevel (withPosition pos) (processStmtBind printBinds pat expr)</span>
<span class="lineno">  508 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  509 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtLet _pos dg -&gt;</span>
<span class="lineno">  510 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  511 </span><span class="spaces">         </span><span class="istickedoff">env &lt;- interpretDeclGroup dg</span>
<span class="lineno">  512 </span><span class="spaces">         </span><span class="istickedoff">withLocalEnv env getMergedEnv &gt;&gt;= putTopLevelRW</span>
<span class="lineno">  513 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  514 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtCode _ lstr -&gt;</span>
<span class="lineno">  515 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  516 </span><span class="spaces">         </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  517 </span><span class="spaces">         </span><span class="istickedoff">--io $ putStrLn $ &quot;Processing toplevel code: &quot; ++ show lstr</span>
<span class="lineno">  518 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  519 </span><span class="spaces">         </span><span class="istickedoff">cenv' &lt;- io $ CEnv.parseDecls sc (rwCryptol rw) $ locToInput lstr</span>
<span class="lineno">  520 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW $ rw { rwCryptol = cenv' }</span>
<span class="lineno">  521 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  522 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  523 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtImport _ imp -&gt;</span>
<span class="lineno">  524 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  525 </span><span class="spaces">         </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  526 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  527 </span><span class="spaces">         </span><span class="istickedoff">let mLoc = iModule imp</span>
<span class="lineno">  528 </span><span class="spaces">             </span><span class="istickedoff">qual = iAs imp</span>
<span class="lineno">  529 </span><span class="spaces">             </span><span class="istickedoff">spec = iSpec imp</span>
<span class="lineno">  530 </span><span class="spaces">         </span><span class="istickedoff">cenv' &lt;- io $ CEnv.importModule sc (rwCryptol rw) mLoc qual CEnv.PublicAndPrivate spec</span>
<span class="lineno">  531 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW $ rw { rwCryptol = cenv' }</span>
<span class="lineno">  532 </span><span class="spaces">         </span><span class="istickedoff">--showCryptolEnv</span>
<span class="lineno">  533 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  534 </span><span class="spaces">    </span><span class="istickedoff">SS.StmtTypedef _ name ty -&gt;</span>
<span class="lineno">  535 </span><span class="spaces">      </span><span class="istickedoff">liftTopLevel $ do</span>
<span class="lineno">  536 </span><span class="spaces">         </span><span class="istickedoff">putTopLevelRW $ addTypedef (getVal name) ty rw</span></span>
<span class="lineno">  537 </span>
<span class="lineno">  538 </span>interpretFile :: FilePath -&gt; Bool {- ^ run main? -} -&gt; TopLevel ()
<span class="lineno">  539 </span><span class="decl"><span class="istickedoff">interpretFile file runMain =</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="istickedoff">bracketTopLevel (io getCurrentDirectory) (io . setCurrentDirectory) (const interp)</span>
<span class="lineno">  541 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="istickedoff">interp =</span>
<span class="lineno">  543 </span><span class="spaces">      </span><span class="istickedoff">do  opts &lt;- getOptions</span>
<span class="lineno">  544 </span><span class="spaces">          </span><span class="istickedoff">stmts &lt;- io $ SAWScript.Import.loadFile opts file</span>
<span class="lineno">  545 </span><span class="spaces">          </span><span class="istickedoff">io $ setCurrentDirectory (takeDirectory file)</span>
<span class="lineno">  546 </span><span class="spaces">          </span><span class="istickedoff">mapM_ stmtWithPrint stmts</span>
<span class="lineno">  547 </span><span class="spaces">          </span><span class="istickedoff">when runMain interpretMain</span>
<span class="lineno">  548 </span><span class="spaces">          </span><span class="istickedoff">writeVerificationSummary</span>
<span class="lineno">  549 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">stmtWithPrint s = do let <span class="nottickedoff">withPos str = unlines $</span></span>
<span class="lineno">  551 </span><span class="spaces">                                           </span><span class="istickedoff"><span class="nottickedoff">(&quot;[output] at &quot; ++ show (SS.getPos s) ++ &quot;: &quot;) :</span></span>
<span class="lineno">  552 </span><span class="spaces">                                             </span><span class="istickedoff"><span class="nottickedoff">map (\l -&gt; &quot;\t&quot;  ++ l) (lines str)</span></span>
<span class="lineno">  553 </span><span class="spaces">                         </span><span class="istickedoff">showLoc &lt;- printShowPos &lt;$&gt; getOptions</span>
<span class="lineno">  554 </span><span class="spaces">                         </span><span class="istickedoff">if <span class="tickonlyfalse">showLoc</span></span>
<span class="lineno">  555 </span><span class="spaces">                           </span><span class="istickedoff">then <span class="nottickedoff">localOptions (\o -&gt; o { printOutFn = \lvl str -&gt;</span></span>
<span class="lineno">  556 </span><span class="spaces">                                                          </span><span class="istickedoff"><span class="nottickedoff">printOutFn o lvl (withPos str) })</span></span>
<span class="lineno">  557 </span><span class="spaces">                                  </span><span class="istickedoff"><span class="nottickedoff">(interpretStmt False s)</span></span>
<span class="lineno">  558 </span><span class="spaces">                           </span><span class="istickedoff">else interpretStmt False s</span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>-- | Evaluate the value called 'main' from the current environment.
<span class="lineno">  561 </span>interpretMain :: TopLevel ()
<span class="lineno">  562 </span><span class="decl"><span class="istickedoff">interpretMain = do</span>
<span class="lineno">  563 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="istickedoff">let mainName = Located &quot;main&quot; <span class="nottickedoff">&quot;main&quot;</span> <span class="nottickedoff">(SS.PosInternal &quot;entry&quot;)</span></span>
<span class="lineno">  565 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup mainName (rwValueInfo rw) of</span>
<span class="lineno">  566 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; return () -- fail &quot;No 'main' defined&quot;</span>
<span class="lineno">  567 </span><span class="spaces">    </span><span class="istickedoff">Just (Current, _ty, v) -&gt; fromValue v</span>
<span class="lineno">  568 </span><span class="spaces">    </span><span class="istickedoff">Just (lc, _ty, _v) -&gt;</span>
<span class="lineno">  569 </span><span class="spaces">      </span><span class="istickedoff">-- There is no way for things other than primitives to get marked</span>
<span class="lineno">  570 </span><span class="spaces">      </span><span class="istickedoff">-- experimental or deprecated, so this isn't possible. If we allow</span>
<span class="lineno">  571 </span><span class="spaces">      </span><span class="istickedoff">-- users to deprecate their own functions in the future, change</span>
<span class="lineno">  572 </span><span class="spaces">      </span><span class="istickedoff">-- this message to an actual error that says something snarky :-)</span>
<span class="lineno">  573 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">panic &quot;Interpreter&quot; [&quot;Unexpected lifecycle state &quot; &lt;&gt; Text.pack (show lc) &lt;&gt; &quot; for main&quot;]</span></span></span>
<span class="lineno">  574 </span>
<span class="lineno">  575 </span>buildTopLevelEnv :: AIGProxy
<span class="lineno">  576 </span>                 -&gt; Options
<span class="lineno">  577 </span>                 -&gt; IO (BuiltinContext, TopLevelRO, TopLevelRW)
<span class="lineno">  578 </span><span class="decl"><span class="istickedoff">buildTopLevelEnv proxy opts =</span>
<span class="lineno">  579 </span><span class="spaces">    </span><span class="istickedoff">do let mn = mkModuleName [&quot;SAWScript&quot;]</span>
<span class="lineno">  580 </span><span class="spaces">       </span><span class="istickedoff">sc0 &lt;- mkSharedContext</span>
<span class="lineno">  581 </span><span class="spaces">       </span><span class="istickedoff">let ?fileReader = <span class="nottickedoff">BS.readFile</span></span>
<span class="lineno">  582 </span><span class="spaces">       </span><span class="istickedoff">CryptolSAW.scLoadPreludeModule sc0</span>
<span class="lineno">  583 </span><span class="spaces">       </span><span class="istickedoff">CryptolSAW.scLoadCryptolModule sc0</span>
<span class="lineno">  584 </span><span class="spaces">       </span><span class="istickedoff">scLoadModule sc0 (emptyModule mn)</span>
<span class="lineno">  585 </span><span class="spaces">       </span><span class="istickedoff">cryptol_mod &lt;- scFindModule sc0 $ mkModuleName [&quot;Cryptol&quot;]</span>
<span class="lineno">  586 </span><span class="spaces">       </span><span class="istickedoff">let convs = natConversions</span>
<span class="lineno">  587 </span><span class="spaces">                   </span><span class="istickedoff">++ bvConversions</span>
<span class="lineno">  588 </span><span class="spaces">                   </span><span class="istickedoff">++ vecConversions</span>
<span class="lineno">  589 </span><span class="spaces">                   </span><span class="istickedoff">++ [ tupleConversion</span>
<span class="lineno">  590 </span><span class="spaces">                      </span><span class="istickedoff">, recordConversion</span>
<span class="lineno">  591 </span><span class="spaces">                      </span><span class="istickedoff">, remove_ident_coerce</span>
<span class="lineno">  592 </span><span class="spaces">                      </span><span class="istickedoff">, remove_ident_unsafeCoerce</span>
<span class="lineno">  593 </span><span class="spaces">                      </span><span class="istickedoff">]</span>
<span class="lineno">  594 </span><span class="spaces">           </span><span class="istickedoff">cryptolDefs = filter defPred $ moduleDefs cryptol_mod</span>
<span class="lineno">  595 </span><span class="spaces">           </span><span class="istickedoff">defPred d = defIdent d `Set.member` includedDefs</span>
<span class="lineno">  596 </span><span class="spaces">           </span><span class="istickedoff">includedDefs = Set.fromList</span>
<span class="lineno">  597 </span><span class="spaces">                          </span><span class="istickedoff">[ &quot;Cryptol.ecDemote&quot;</span>
<span class="lineno">  598 </span><span class="spaces">                          </span><span class="istickedoff">, &quot;Cryptol.seq&quot;</span>
<span class="lineno">  599 </span><span class="spaces">                          </span><span class="istickedoff">]</span>
<span class="lineno">  600 </span><span class="spaces">       </span><span class="istickedoff">simps &lt;- scSimpset sc0 cryptolDefs [] convs</span>
<span class="lineno">  601 </span><span class="spaces">       </span><span class="istickedoff">let sc = rewritingSharedContext sc0 simps</span>
<span class="lineno">  602 </span><span class="spaces">       </span><span class="istickedoff">ss &lt;- basic_ss sc</span>
<span class="lineno">  603 </span><span class="spaces">       </span><span class="istickedoff">jcb &lt;- JCB.loadCodebase (jarList opts) (classPath opts) (javaBinDirs opts)</span>
<span class="lineno">  604 </span><span class="spaces">       </span><span class="istickedoff">currDir &lt;- getCurrentDirectory</span>
<span class="lineno">  605 </span><span class="spaces">       </span><span class="istickedoff">mb_cache &lt;- lookupEnv &quot;SAW_SOLVER_CACHE_PATH&quot; &gt;&gt;= \case</span>
<span class="lineno">  606 </span><span class="spaces">         </span><span class="istickedoff">Just path | <span class="tickonlytrue">not (null path)</span> -&gt; Just &lt;$&gt; lazyOpenSolverCache path</span>
<span class="lineno">  607 </span><span class="spaces">         </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">return Nothing</span></span>
<span class="lineno">  608 </span><span class="spaces">       </span><span class="istickedoff">Crucible.withHandleAllocator $ \halloc -&gt; do</span>
<span class="lineno">  609 </span><span class="spaces">       </span><span class="istickedoff">let ro0 = TopLevelRO</span>
<span class="lineno">  610 </span><span class="spaces">                   </span><span class="istickedoff">{ roJavaCodebase = jcb</span>
<span class="lineno">  611 </span><span class="spaces">                   </span><span class="istickedoff">, roOptions = opts</span>
<span class="lineno">  612 </span><span class="spaces">                   </span><span class="istickedoff">, roHandleAlloc = halloc</span>
<span class="lineno">  613 </span><span class="spaces">                   </span><span class="istickedoff">, roPosition = SS.Unknown</span>
<span class="lineno">  614 </span><span class="spaces">                   </span><span class="istickedoff">, roProxy = proxy</span>
<span class="lineno">  615 </span><span class="spaces">                   </span><span class="istickedoff">, roInitWorkDir = currDir</span>
<span class="lineno">  616 </span><span class="spaces">                   </span><span class="istickedoff">, roBasicSS = ss</span>
<span class="lineno">  617 </span><span class="spaces">                   </span><span class="istickedoff">, roStackTrace = []</span>
<span class="lineno">  618 </span><span class="spaces">                   </span><span class="istickedoff">, roSubshell = <span class="nottickedoff">fail &quot;Subshells not supported&quot;</span></span>
<span class="lineno">  619 </span><span class="spaces">                   </span><span class="istickedoff">, roProofSubshell = <span class="nottickedoff">fail &quot;Proof subshells not supported&quot;</span></span>
<span class="lineno">  620 </span><span class="spaces">                   </span><span class="istickedoff">, roLocalEnv = []</span>
<span class="lineno">  621 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno">  622 </span><span class="spaces">       </span><span class="istickedoff">let bic = BuiltinContext {</span>
<span class="lineno">  623 </span><span class="spaces">                   </span><span class="istickedoff">biSharedContext = sc</span>
<span class="lineno">  624 </span><span class="spaces">                 </span><span class="istickedoff">, biBasicSS = <span class="nottickedoff">ss</span></span>
<span class="lineno">  625 </span><span class="spaces">                 </span><span class="istickedoff">}</span>
<span class="lineno">  626 </span><span class="spaces">       </span><span class="istickedoff">ce0 &lt;- CEnv.initCryptolEnv sc</span>
<span class="lineno">  627 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  628 </span><span class="spaces">       </span><span class="istickedoff">jvmTrans &lt;- CJ.mkInitialJVMContext <span class="nottickedoff">halloc</span></span>
<span class="lineno">  629 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  630 </span><span class="spaces">       </span><span class="istickedoff">let rw0 = TopLevelRW</span>
<span class="lineno">  631 </span><span class="spaces">                   </span><span class="istickedoff">{ rwValueInfo  = primValueEnv <span class="nottickedoff">opts</span> bic</span>
<span class="lineno">  632 </span><span class="spaces">                   </span><span class="istickedoff">, rwTypeInfo   = primNamedTypeEnv</span>
<span class="lineno">  633 </span><span class="spaces">                   </span><span class="istickedoff">, rwDocs       = <span class="nottickedoff">primDocEnv</span></span>
<span class="lineno">  634 </span><span class="spaces">                   </span><span class="istickedoff">, rwCryptol    = ce0</span>
<span class="lineno">  635 </span><span class="spaces">                   </span><span class="istickedoff">, rwMonadify   = <span class="nottickedoff">Monadify.defaultMonEnv</span></span>
<span class="lineno">  636 </span><span class="spaces">                   </span><span class="istickedoff">, rwMRSolverEnv = <span class="nottickedoff">emptyMREnv</span></span>
<span class="lineno">  637 </span><span class="spaces">                   </span><span class="istickedoff">, rwProofs     = []</span>
<span class="lineno">  638 </span><span class="spaces">                   </span><span class="istickedoff">, rwPPOpts     = PPS.defaultOpts</span>
<span class="lineno">  639 </span><span class="spaces">                   </span><span class="istickedoff">, rwSharedContext = sc</span>
<span class="lineno">  640 </span><span class="spaces">                   </span><span class="istickedoff">, rwSolverCache = mb_cache</span>
<span class="lineno">  641 </span><span class="spaces">                   </span><span class="istickedoff">, rwTheoremDB = emptyTheoremDB</span>
<span class="lineno">  642 </span><span class="spaces">                   </span><span class="istickedoff">, rwJVMTrans   = jvmTrans</span>
<span class="lineno">  643 </span><span class="spaces">                   </span><span class="istickedoff">, rwPrimsAvail = defaultAvailable</span>
<span class="lineno">  644 </span><span class="spaces">                   </span><span class="istickedoff">, rwSMTArrayMemoryModel = False</span>
<span class="lineno">  645 </span><span class="spaces">                   </span><span class="istickedoff">, rwCrucibleAssertThenAssume = False</span>
<span class="lineno">  646 </span><span class="spaces">                   </span><span class="istickedoff">, rwProfilingFile = Nothing</span>
<span class="lineno">  647 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxArith = False</span>
<span class="lineno">  648 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxPointerOrdering = False</span>
<span class="lineno">  649 </span><span class="spaces">                   </span><span class="istickedoff">, rwLaxLoadsAndStores = False</span>
<span class="lineno">  650 </span><span class="spaces">                   </span><span class="istickedoff">, rwDebugIntrinsics = True</span>
<span class="lineno">  651 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4HashConsing = False</span>
<span class="lineno">  652 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4HashConsingX86 = False</span>
<span class="lineno">  653 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4Eval = False</span>
<span class="lineno">  654 </span><span class="spaces">                   </span><span class="istickedoff">, rwPreservedRegs = []</span>
<span class="lineno">  655 </span><span class="spaces">                   </span><span class="istickedoff">, rwStackBaseAlign = defaultStackBaseAlign</span>
<span class="lineno">  656 </span><span class="spaces">                   </span><span class="istickedoff">, rwAllocSymInitCheck = True</span>
<span class="lineno">  657 </span><span class="spaces">                   </span><span class="istickedoff">, rwWhat4PushMuxOps = False</span>
<span class="lineno">  658 </span><span class="spaces">                   </span><span class="istickedoff">, rwNoSatisfyingWriteFreshConstant = True</span>
<span class="lineno">  659 </span><span class="spaces">                   </span><span class="istickedoff">, rwCrucibleTimeout = CC.defaultSAWCoreBackendTimeout</span>
<span class="lineno">  660 </span><span class="spaces">                   </span><span class="istickedoff">, rwPathSatSolver = CC.PathSat_Z3</span>
<span class="lineno">  661 </span><span class="spaces">                   </span><span class="istickedoff">, rwSkipSafetyProofs = False</span>
<span class="lineno">  662 </span><span class="spaces">                   </span><span class="istickedoff">, rwSingleOverrideSpecialCase = False</span>
<span class="lineno">  663 </span><span class="spaces">                   </span><span class="istickedoff">, rwSequentGoals = False</span>
<span class="lineno">  664 </span><span class="spaces">                   </span><span class="istickedoff">}</span>
<span class="lineno">  665 </span><span class="spaces">       </span><span class="istickedoff">return (<span class="nottickedoff">bic</span>, ro0, rw0)</span></span>
<span class="lineno">  666 </span>
<span class="lineno">  667 </span>processFile ::
<span class="lineno">  668 </span>  AIGProxy -&gt;
<span class="lineno">  669 </span>  Options -&gt;
<span class="lineno">  670 </span>  FilePath -&gt;
<span class="lineno">  671 </span>  Maybe (TopLevel ()) -&gt;
<span class="lineno">  672 </span>  Maybe (ProofScript ()) -&gt;
<span class="lineno">  673 </span>  IO ()
<span class="lineno">  674 </span><span class="decl"><span class="istickedoff">processFile proxy opts file mbSubshell mbProofSubshell = do</span>
<span class="lineno">  675 </span><span class="spaces">  </span><span class="istickedoff">(_, ro, rw) &lt;- buildTopLevelEnv proxy opts</span>
<span class="lineno">  676 </span><span class="spaces">  </span><span class="istickedoff">let ro' = case mbSubshell of</span>
<span class="lineno">  677 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">ro</span></span>
<span class="lineno">  678 </span><span class="spaces">              </span><span class="istickedoff">Just m  -&gt; ro{ roSubshell = <span class="nottickedoff">m</span> }</span>
<span class="lineno">  679 </span><span class="spaces">  </span><span class="istickedoff">let ro'' = case mbProofSubshell of</span>
<span class="lineno">  680 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">ro'</span></span>
<span class="lineno">  681 </span><span class="spaces">              </span><span class="istickedoff">Just m  -&gt; ro'{ roProofSubshell = <span class="nottickedoff">m</span> }</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="istickedoff">_ &lt;- runTopLevel (interpretFile file True) ro'' rw</span>
<span class="lineno">  683 </span><span class="spaces">            </span><span class="istickedoff">`X.catch` (handleException opts)</span>
<span class="lineno">  684 </span><span class="spaces">  </span><span class="istickedoff">return <span class="nottickedoff">()</span></span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>-- Primitives ------------------------------------------------------------------
<span class="lineno">  687 </span>
<span class="lineno">  688 </span>add_primitives :: PrimitiveLifecycle -&gt; BuiltinContext -&gt; Options -&gt; TopLevel ()
<span class="lineno">  689 </span><span class="decl"><span class="istickedoff">add_primitives lc _bic _opts = do</span>
<span class="lineno">  690 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw {</span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">rwPrimsAvail = Set.insert lc (rwPrimsAvail rw)</span>
<span class="lineno">  693 </span><span class="spaces">  </span><span class="istickedoff">}</span></span>
<span class="lineno">  694 </span>
<span class="lineno">  695 </span>enable_safety_proofs :: TopLevel ()
<span class="lineno">  696 </span><span class="decl"><span class="nottickedoff">enable_safety_proofs = do</span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSkipSafetyProofs = False }</span></span>
<span class="lineno">  699 </span>
<span class="lineno">  700 </span>disable_safety_proofs :: TopLevel ()
<span class="lineno">  701 </span><span class="decl"><span class="nottickedoff">disable_safety_proofs = do</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno">  703 </span><span class="spaces">  </span><span class="nottickedoff">io $ printOutLn opts Warn &quot;Safety proofs disabled! This is unsound!&quot;</span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  705 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSkipSafetyProofs = True }</span></span>
<span class="lineno">  706 </span>
<span class="lineno">  707 </span>enable_sequent_goals :: TopLevel ()
<span class="lineno">  708 </span><span class="decl"><span class="nottickedoff">enable_sequent_goals = do</span>
<span class="lineno">  709 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSequentGoals = True }</span></span>
<span class="lineno">  711 </span>
<span class="lineno">  712 </span>disable_sequent_goals :: TopLevel ()
<span class="lineno">  713 </span><span class="decl"><span class="nottickedoff">disable_sequent_goals = do</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw{ rwSequentGoals = False }</span></span>
<span class="lineno">  716 </span>
<span class="lineno">  717 </span>enable_smt_array_memory_model :: TopLevel ()
<span class="lineno">  718 </span><span class="decl"><span class="istickedoff">enable_smt_array_memory_model = do</span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwSMTArrayMemoryModel = True }</span></span>
<span class="lineno">  721 </span>
<span class="lineno">  722 </span>disable_smt_array_memory_model :: TopLevel ()
<span class="lineno">  723 </span><span class="decl"><span class="nottickedoff">disable_smt_array_memory_model = do</span>
<span class="lineno">  724 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSMTArrayMemoryModel = False }</span></span>
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>enable_crucible_assert_then_assume :: TopLevel ()
<span class="lineno">  728 </span><span class="decl"><span class="istickedoff">enable_crucible_assert_then_assume = do</span>
<span class="lineno">  729 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  730 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwCrucibleAssertThenAssume = True }</span></span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>disable_crucible_assert_then_assume :: TopLevel ()
<span class="lineno">  733 </span><span class="decl"><span class="istickedoff">disable_crucible_assert_then_assume = do</span>
<span class="lineno">  734 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwCrucibleAssertThenAssume = False }</span></span>
<span class="lineno">  736 </span>
<span class="lineno">  737 </span>enable_single_override_special_case :: TopLevel ()
<span class="lineno">  738 </span><span class="decl"><span class="nottickedoff">enable_single_override_special_case = do</span>
<span class="lineno">  739 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  740 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSingleOverrideSpecialCase = True }</span></span>
<span class="lineno">  741 </span>
<span class="lineno">  742 </span>disable_single_override_special_case :: TopLevel ()
<span class="lineno">  743 </span><span class="decl"><span class="nottickedoff">disable_single_override_special_case = do</span>
<span class="lineno">  744 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  745 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwSingleOverrideSpecialCase = False }</span></span>
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>
<span class="lineno">  748 </span>enable_crucible_profiling :: FilePath -&gt; TopLevel ()
<span class="lineno">  749 </span><span class="decl"><span class="istickedoff">enable_crucible_profiling f = do</span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  751 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwProfilingFile = Just f }</span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>disable_crucible_profiling :: TopLevel ()
<span class="lineno">  754 </span><span class="decl"><span class="istickedoff">disable_crucible_profiling = do</span>
<span class="lineno">  755 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwProfilingFile = <span class="nottickedoff">Nothing</span> }</span></span>
<span class="lineno">  757 </span>
<span class="lineno">  758 </span>enable_lax_arithmetic :: TopLevel ()
<span class="lineno">  759 </span><span class="decl"><span class="nottickedoff">enable_lax_arithmetic = do</span>
<span class="lineno">  760 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  761 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxArith = True }</span></span>
<span class="lineno">  762 </span>
<span class="lineno">  763 </span>disable_lax_arithmetic :: TopLevel ()
<span class="lineno">  764 </span><span class="decl"><span class="nottickedoff">disable_lax_arithmetic = do</span>
<span class="lineno">  765 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  766 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxArith = False }</span></span>
<span class="lineno">  767 </span>
<span class="lineno">  768 </span>enable_lax_pointer_ordering :: TopLevel ()
<span class="lineno">  769 </span><span class="decl"><span class="istickedoff">enable_lax_pointer_ordering = do</span>
<span class="lineno">  770 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  771 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwLaxPointerOrdering = True }</span></span>
<span class="lineno">  772 </span>
<span class="lineno">  773 </span>disable_lax_pointer_ordering :: TopLevel ()
<span class="lineno">  774 </span><span class="decl"><span class="nottickedoff">disable_lax_pointer_ordering = do</span>
<span class="lineno">  775 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  776 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxPointerOrdering = False }</span></span>
<span class="lineno">  777 </span>
<span class="lineno">  778 </span>enable_lax_loads_and_stores :: TopLevel ()
<span class="lineno">  779 </span><span class="decl"><span class="istickedoff">enable_lax_loads_and_stores = do</span>
<span class="lineno">  780 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwLaxLoadsAndStores = True }</span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>disable_lax_loads_and_stores :: TopLevel ()
<span class="lineno">  784 </span><span class="decl"><span class="nottickedoff">disable_lax_loads_and_stores = do</span>
<span class="lineno">  785 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwLaxLoadsAndStores = False }</span></span>
<span class="lineno">  787 </span>
<span class="lineno">  788 </span>set_solver_cache_path :: FilePath -&gt; TopLevel ()
<span class="lineno">  789 </span><span class="decl"><span class="istickedoff">set_solver_cache_path path = do</span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  791 </span><span class="spaces">  </span><span class="istickedoff">case rwSolverCache rw of</span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="istickedoff">Just _ -&gt; onSolverCache (setSolverCachePath path)</span>
<span class="lineno">  793 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do cache &lt;- io $ openSolverCache path</span></span>
<span class="lineno">  794 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">putTopLevelRW rw { rwSolverCache = Just cache }</span></span></span>
<span class="lineno">  795 </span>
<span class="lineno">  796 </span>clean_mismatched_versions_solver_cache :: TopLevel ()
<span class="lineno">  797 </span><span class="decl"><span class="istickedoff">clean_mismatched_versions_solver_cache = do</span>
<span class="lineno">  798 </span><span class="spaces">  </span><span class="istickedoff">vs &lt;- io $ getSolverBackendVersions allBackends</span>
<span class="lineno">  799 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (cleanMismatchedVersionsSolverCache vs)</span></span>
<span class="lineno">  800 </span>
<span class="lineno">  801 </span>test_solver_cache_stats :: Integer -&gt; Integer -&gt; Integer -&gt; Integer -&gt;
<span class="lineno">  802 </span>                           Integer -&gt; TopLevel ()
<span class="lineno">  803 </span><span class="decl"><span class="istickedoff">test_solver_cache_stats sz ls ls_f is is_f =</span>
<span class="lineno">  804 </span><span class="spaces">  </span><span class="istickedoff">onSolverCache (testSolverCacheStats sz ls ls_f is is_f)</span></span>
<span class="lineno">  805 </span>
<span class="lineno">  806 </span>enable_debug_intrinsics :: TopLevel ()
<span class="lineno">  807 </span><span class="decl"><span class="nottickedoff">enable_debug_intrinsics = do</span>
<span class="lineno">  808 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwDebugIntrinsics = True }</span></span>
<span class="lineno">  810 </span>
<span class="lineno">  811 </span>disable_debug_intrinsics :: TopLevel ()
<span class="lineno">  812 </span><span class="decl"><span class="nottickedoff">disable_debug_intrinsics = do</span>
<span class="lineno">  813 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  814 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwDebugIntrinsics = False }</span></span>
<span class="lineno">  815 </span>
<span class="lineno">  816 </span>enable_what4_hash_consing :: TopLevel ()
<span class="lineno">  817 </span><span class="decl"><span class="nottickedoff">enable_what4_hash_consing = do</span>
<span class="lineno">  818 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  819 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsing = True }</span></span>
<span class="lineno">  820 </span>
<span class="lineno">  821 </span>disable_what4_hash_consing :: TopLevel ()
<span class="lineno">  822 </span><span class="decl"><span class="nottickedoff">disable_what4_hash_consing = do</span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  824 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsing = False }</span></span>
<span class="lineno">  825 </span>
<span class="lineno">  826 </span>enable_x86_what4_hash_consing :: TopLevel ()
<span class="lineno">  827 </span><span class="decl"><span class="nottickedoff">enable_x86_what4_hash_consing = do</span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsingX86 = True }</span></span>
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>disable_x86_what4_hash_consing :: TopLevel ()
<span class="lineno">  832 </span><span class="decl"><span class="nottickedoff">disable_x86_what4_hash_consing = do</span>
<span class="lineno">  833 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  834 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4HashConsingX86 = False }</span></span>
<span class="lineno">  835 </span>
<span class="lineno">  836 </span>enable_what4_eval :: TopLevel ()
<span class="lineno">  837 </span><span class="decl"><span class="istickedoff">enable_what4_eval = do</span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  839 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwWhat4Eval = True }</span></span>
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>disable_what4_eval :: TopLevel ()
<span class="lineno">  842 </span><span class="decl"><span class="nottickedoff">disable_what4_eval = do</span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4Eval = False }</span></span>
<span class="lineno">  845 </span>
<span class="lineno">  846 </span>add_x86_preserved_reg :: String -&gt; TopLevel ()
<span class="lineno">  847 </span><span class="decl"><span class="istickedoff">add_x86_preserved_reg r = do</span>
<span class="lineno">  848 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  849 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPreservedRegs = r:rwPreservedRegs rw }</span></span>
<span class="lineno">  850 </span>
<span class="lineno">  851 </span>default_x86_preserved_reg :: TopLevel ()
<span class="lineno">  852 </span><span class="decl"><span class="istickedoff">default_x86_preserved_reg = do</span>
<span class="lineno">  853 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  854 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPreservedRegs = <span class="nottickedoff">[]</span> }</span></span>
<span class="lineno">  855 </span>
<span class="lineno">  856 </span>set_x86_stack_base_align :: Integer -&gt; TopLevel ()
<span class="lineno">  857 </span><span class="decl"><span class="nottickedoff">set_x86_stack_base_align a = do</span>
<span class="lineno">  858 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  859 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwStackBaseAlign = a }</span></span>
<span class="lineno">  860 </span>
<span class="lineno">  861 </span>default_x86_stack_base_align :: TopLevel ()
<span class="lineno">  862 </span><span class="decl"><span class="nottickedoff">default_x86_stack_base_align = do</span>
<span class="lineno">  863 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  864 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwStackBaseAlign = defaultStackBaseAlign }</span></span>
<span class="lineno">  865 </span>
<span class="lineno">  866 </span>enable_alloc_sym_init_check :: TopLevel ()
<span class="lineno">  867 </span><span class="decl"><span class="istickedoff">enable_alloc_sym_init_check = do</span>
<span class="lineno">  868 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  869 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwAllocSymInitCheck = True }</span></span>
<span class="lineno">  870 </span>
<span class="lineno">  871 </span>disable_alloc_sym_init_check :: TopLevel ()
<span class="lineno">  872 </span><span class="decl"><span class="istickedoff">disable_alloc_sym_init_check = do</span>
<span class="lineno">  873 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  874 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwAllocSymInitCheck = False }</span></span>
<span class="lineno">  875 </span>
<span class="lineno">  876 </span>enable_no_satisfying_write_fresh_constant :: TopLevel ()
<span class="lineno">  877 </span><span class="decl"><span class="nottickedoff">enable_no_satisfying_write_fresh_constant = do</span>
<span class="lineno">  878 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  879 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwNoSatisfyingWriteFreshConstant = True }</span></span>
<span class="lineno">  880 </span>
<span class="lineno">  881 </span>disable_no_satisfying_write_fresh_constant :: TopLevel ()
<span class="lineno">  882 </span><span class="decl"><span class="nottickedoff">disable_no_satisfying_write_fresh_constant = do</span>
<span class="lineno">  883 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  884 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwNoSatisfyingWriteFreshConstant = False }</span></span>
<span class="lineno">  885 </span>
<span class="lineno">  886 </span>enable_what4_push_mux_ops :: TopLevel ()
<span class="lineno">  887 </span><span class="decl"><span class="nottickedoff">enable_what4_push_mux_ops = do</span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  889 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4PushMuxOps = True }</span></span>
<span class="lineno">  890 </span>
<span class="lineno">  891 </span>disable_what4_push_mux_ops :: TopLevel ()
<span class="lineno">  892 </span><span class="decl"><span class="nottickedoff">disable_what4_push_mux_ops = do</span>
<span class="lineno">  893 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  894 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwWhat4PushMuxOps = False }</span></span>
<span class="lineno">  895 </span>
<span class="lineno">  896 </span>set_crucible_timeout :: Integer -&gt; TopLevel ()
<span class="lineno">  897 </span><span class="decl"><span class="nottickedoff">set_crucible_timeout t = do</span>
<span class="lineno">  898 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  899 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwCrucibleTimeout = t }</span></span>
<span class="lineno">  900 </span>
<span class="lineno">  901 </span>include_value :: FilePath -&gt; TopLevel ()
<span class="lineno">  902 </span><span class="decl"><span class="istickedoff">include_value file = do</span>
<span class="lineno">  903 </span><span class="spaces">  </span><span class="istickedoff">interpretFile file False</span></span>
<span class="lineno">  904 </span>
<span class="lineno">  905 </span>set_ascii :: Bool -&gt; TopLevel ()
<span class="lineno">  906 </span><span class="decl"><span class="nottickedoff">set_ascii b = do</span>
<span class="lineno">  907 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  908 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppUseAscii = b } }</span></span>
<span class="lineno">  909 </span>
<span class="lineno">  910 </span>set_base :: Int -&gt; TopLevel ()
<span class="lineno">  911 </span><span class="decl"><span class="istickedoff">set_base b = do</span>
<span class="lineno">  912 </span><span class="spaces">  </span><span class="istickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  913 </span><span class="spaces">  </span><span class="istickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppBase = b } }</span></span>
<span class="lineno">  914 </span>
<span class="lineno">  915 </span>set_color :: Bool -&gt; TopLevel ()
<span class="lineno">  916 </span><span class="decl"><span class="nottickedoff">set_color b = do</span>
<span class="lineno">  917 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  918 </span><span class="spaces">  </span><span class="nottickedoff">opts &lt;- getOptions</span>
<span class="lineno">  919 </span><span class="spaces">  </span><span class="nottickedoff">-- Keep color disabled if `--no-color` command-line option is present</span>
<span class="lineno">  920 </span><span class="spaces">  </span><span class="nottickedoff">let b' = b &amp;&amp; useColor opts</span>
<span class="lineno">  921 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppColor = b' } }</span></span>
<span class="lineno">  922 </span>
<span class="lineno">  923 </span>set_min_sharing :: Int -&gt; TopLevel ()
<span class="lineno">  924 </span><span class="decl"><span class="nottickedoff">set_min_sharing b = do</span>
<span class="lineno">  925 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  926 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMinSharing = b } }</span></span>
<span class="lineno">  927 </span>
<span class="lineno">  928 </span>-- | 'set_memoization_hash i' changes the memoization strategy for terms:
<span class="lineno">  929 </span>-- memoization identifiers will include the first 'i' digits of the hash of the
<span class="lineno">  930 </span>-- term they memoize. This is useful to help keep memoization identifiers of the
<span class="lineno">  931 </span>-- same term as constant as possible across different executions of a proof
<span class="lineno">  932 </span>-- script over the course of its development.
<span class="lineno">  933 </span>set_memoization_hash :: Int -&gt; TopLevel ()
<span class="lineno">  934 </span><span class="decl"><span class="nottickedoff">set_memoization_hash i = do</span>
<span class="lineno">  935 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  936 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.Hash i } }</span></span>
<span class="lineno">  937 </span>
<span class="lineno">  938 </span>-- | 'set_memoization_hash_incremental i' changes the memoization strategy for
<span class="lineno">  939 </span>-- terms: memoization identifiers will include the first 'i' digits of the hash
<span class="lineno">  940 </span>-- of the term they memoize, as well as the value of a global counter that
<span class="lineno">  941 </span>-- increments each time a term is memoized. This is useful to help keep
<span class="lineno">  942 </span>-- memoization identifiers of the same term as constant as possible across
<span class="lineno">  943 </span>-- different executions of a proof script over the course of its development, as
<span class="lineno">  944 </span>-- well as to freshen memoization identifiers in the unlikely case of term hash
<span class="lineno">  945 </span>-- collisions.
<span class="lineno">  946 </span>set_memoization_hash_incremental :: Int -&gt; TopLevel ()
<span class="lineno">  947 </span><span class="decl"><span class="nottickedoff">set_memoization_hash_incremental i = do</span>
<span class="lineno">  948 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  949 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.HashIncremental i } }</span></span>
<span class="lineno">  950 </span>
<span class="lineno">  951 </span>-- | `set_memoization_incremental` changes the memoization strategy for terms:
<span class="lineno">  952 </span>-- memoization identifiers will only include the value of a global counter that
<span class="lineno">  953 </span>-- increments each time a term is memoized.
<span class="lineno">  954 </span>set_memoization_incremental :: TopLevel ()
<span class="lineno">  955 </span><span class="decl"><span class="nottickedoff">set_memoization_incremental = do</span>
<span class="lineno">  956 </span><span class="spaces">  </span><span class="nottickedoff">rw &lt;- getTopLevelRW</span>
<span class="lineno">  957 </span><span class="spaces">  </span><span class="nottickedoff">putTopLevelRW rw { rwPPOpts = (rwPPOpts rw) { PPS.ppMemoStyle = PPS.Incremental } }</span></span>
<span class="lineno">  958 </span>
<span class="lineno">  959 </span>print_value :: Value -&gt; TopLevel ()
<span class="lineno">  960 </span><span class="decl"><span class="istickedoff">print_value (VString s) = printOutLnTop Info (Text.unpack s)</span>
<span class="lineno">  961 </span><span class="spaces"></span><span class="istickedoff">print_value (VTerm t) = do</span>
<span class="lineno">  962 </span><span class="spaces">  </span><span class="istickedoff">sc &lt;- getSharedContext</span>
<span class="lineno">  963 </span><span class="spaces">  </span><span class="istickedoff">cenv &lt;- fmap rwCryptol getTopLevelRW</span>
<span class="lineno">  964 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">cfg = CEnv.meSolverConfig (CEnv.eModuleEnv cenv)</span></span>
<span class="lineno">  965 </span><span class="spaces">  </span><span class="istickedoff">unless (null (getAllExts (ttTerm t))) $</span>
<span class="lineno">  966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail &quot;term contains symbolic variables&quot;</span></span>
<span class="lineno">  967 </span><span class="spaces">  </span><span class="istickedoff">sawopts &lt;- getOptions</span>
<span class="lineno">  968 </span><span class="spaces">  </span><span class="istickedoff">t' &lt;- io $ defaultTypedTerm <span class="nottickedoff">sawopts</span> <span class="nottickedoff">sc</span> <span class="nottickedoff">cfg</span> t</span>
<span class="lineno">  969 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno">  970 </span><span class="spaces">  </span><span class="istickedoff">let opts' = V.defaultPPOpts { V.useAscii = PPS.ppUseAscii opts</span>
<span class="lineno">  971 </span><span class="spaces">                              </span><span class="istickedoff">, V.useBase = PPS.ppBase opts</span>
<span class="lineno">  972 </span><span class="spaces">                              </span><span class="istickedoff">}</span>
<span class="lineno">  973 </span><span class="spaces">  </span><span class="istickedoff">evaled_t &lt;- io $ evaluateTypedTerm sc t'</span>
<span class="lineno">  974 </span><span class="spaces">  </span><span class="istickedoff">doc &lt;- io $ V.runEval <span class="nottickedoff">mempty</span> (V.ppValue <span class="nottickedoff">V.Concrete</span> opts' evaled_t)</span>
<span class="lineno">  975 </span><span class="spaces">  </span><span class="istickedoff">sawOpts &lt;- getOptions</span>
<span class="lineno">  976 </span><span class="spaces">  </span><span class="istickedoff">io (rethrowEvalError $ printOutLn sawOpts Info $ show $ doc)</span>
<span class="lineno">  977 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  978 </span><span class="spaces"></span><span class="istickedoff">print_value v = do</span>
<span class="lineno">  979 </span><span class="spaces">  </span><span class="istickedoff">opts &lt;- fmap rwPPOpts getTopLevelRW</span>
<span class="lineno">  980 </span><span class="spaces">  </span><span class="istickedoff">nenv &lt;- io . scGetNamingEnv =&lt;&lt; getSharedContext</span>
<span class="lineno">  981 </span><span class="spaces">  </span><span class="istickedoff">printOutLnTop Info (showsPrecValue opts nenv <span class="nottickedoff">0</span> v &quot;&quot;)</span></span>
<span class="lineno">  982 </span>
<span class="lineno">  983 </span>-- | Read a type schema. This is used to digest the type signatures
<span class="lineno">  984 </span>-- for builtins, and the expansions for builtin typedefs.
<span class="lineno">  985 </span>--
<span class="lineno">  986 </span>-- The first argument (fakeFileName) is a string to pass as the
<span class="lineno">  987 </span>-- filename for the lexer, which (complete with line and column
<span class="lineno">  988 </span>-- numbering of dubious value) will go into the positions of the
<span class="lineno">  989 </span>-- elements of the resulting type.
<span class="lineno">  990 </span>--
<span class="lineno">  991 </span>-- FUTURE: we should figure out how to generate more meaningful
<span class="lineno">  992 </span>-- positions (like &quot;third argument of concat&quot;) but this at least
<span class="lineno">  993 </span>-- allows telling the user which builtin the type came from.
<span class="lineno">  994 </span>--
<span class="lineno">  995 </span>readSchema :: FilePath -&gt; Text -&gt; SS.Schema
<span class="lineno">  996 </span><span class="decl"><span class="istickedoff">readSchema fakeFileName str =</span>
<span class="lineno">  997 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">croak what msg =</span></span>
<span class="lineno">  998 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">error (what ++ &quot; error in builtin &quot; ++ Text.unpack str ++ &quot;: &quot; ++ msg)</span></span>
<span class="lineno">  999 </span><span class="spaces">      </span><span class="istickedoff">tokens =</span>
<span class="lineno"> 1000 </span><span class="spaces">        </span><span class="istickedoff">-- XXX clean this up when we clean out the message printing infrastructure</span>
<span class="lineno"> 1001 </span><span class="spaces">        </span><span class="istickedoff">case lexSAW fakeFileName str of</span>
<span class="lineno"> 1002 </span><span class="spaces">          </span><span class="istickedoff">Left (_, _, msg) -&gt; <span class="nottickedoff">croak &quot;Lexer&quot; $ Text.unpack msg</span></span>
<span class="lineno"> 1003 </span><span class="spaces">          </span><span class="istickedoff">Right (tokens', Nothing) -&gt; tokens'</span>
<span class="lineno"> 1004 </span><span class="spaces">          </span><span class="istickedoff">Right (_      , Just (Error, _pos, msg)) -&gt; <span class="nottickedoff">croak &quot;Lexer&quot; $ Text.unpack msg</span></span>
<span class="lineno"> 1005 </span><span class="spaces">          </span><span class="istickedoff">Right (tokens', Just (_, _pos, _msg)) -&gt; <span class="nottickedoff">tokens'</span></span>
<span class="lineno"> 1006 </span><span class="spaces">  </span><span class="istickedoff">in</span>
<span class="lineno"> 1007 </span><span class="spaces">  </span><span class="istickedoff">case parseSchema tokens of</span>
<span class="lineno"> 1008 </span><span class="spaces">    </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">croak &quot;Parse&quot; $ show err</span></span>
<span class="lineno"> 1009 </span><span class="spaces">    </span><span class="istickedoff">Right schema -&gt; schema</span></span>
<span class="lineno"> 1010 </span>
<span class="lineno"> 1011 </span>data PrimType
<span class="lineno"> 1012 </span>  = PrimType
<span class="lineno"> 1013 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">primTypeType</span></span></span> :: SS.NamedType
<span class="lineno"> 1014 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primTypeLife</span></span></span> :: PrimitiveLifecycle
<span class="lineno"> 1015 </span>    -- FUTURE: add doc strings for these?
<span class="lineno"> 1016 </span>    }
<span class="lineno"> 1017 </span>
<span class="lineno"> 1018 </span>data Primitive
<span class="lineno"> 1019 </span>  = Primitive
<span class="lineno"> 1020 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveType</span></span></span> :: SS.Schema
<span class="lineno"> 1021 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveLife</span></span></span> :: PrimitiveLifecycle
<span class="lineno"> 1022 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">primitiveDoc</span></span></span>  :: [String]
<span class="lineno"> 1023 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">primitiveFn</span></span></span>   :: Options -&gt; BuiltinContext -&gt; Value
<span class="lineno"> 1024 </span>    }
<span class="lineno"> 1025 </span>
<span class="lineno"> 1026 </span>-- | Primitive types, that is, builtin types used by the primitives.
<span class="lineno"> 1027 </span>--
<span class="lineno"> 1028 </span>-- This excludes certain types that are built in more deeply and
<span class="lineno"> 1029 </span>-- appear as entries in @TyCon in AST.hs. Note that those are also
<span class="lineno"> 1030 </span>-- handled as reserved words in the lexer and parser. XXX: and there's
<span class="lineno"> 1031 </span>-- no particular system to which are there and which are here; some of
<span class="lineno"> 1032 </span>-- the ones there have no special syntax or semantics and should
<span class="lineno"> 1033 </span>-- probably be moved here at some point.
<span class="lineno"> 1034 </span>primTypes :: Map SS.Name PrimType
<span class="lineno"> 1035 </span><span class="decl"><span class="istickedoff">primTypes = Map.fromList</span>
<span class="lineno"> 1036 </span><span class="spaces">  </span><span class="istickedoff">[ abstype &quot;BisimTheorem&quot; Experimental</span>
<span class="lineno"> 1037 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;CryptolModule&quot; <span class="nottickedoff">Current</span></span>
<span class="lineno"> 1038 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;FunctionProfile&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1039 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;FunctionSkeleton&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1040 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Ghost&quot; Current</span>
<span class="lineno"> 1041 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;HeapsterEnv&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1042 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JVMSetup&quot; Current</span>
<span class="lineno"> 1043 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JVMValue&quot; Current</span>
<span class="lineno"> 1044 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JavaClass&quot; Current</span>
<span class="lineno"> 1045 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;JavaType&quot; Current</span>
<span class="lineno"> 1046 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMModule&quot; Current</span>
<span class="lineno"> 1047 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;LLVMType&quot; Current</span>
<span class="lineno"> 1048 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRAdt&quot; Experimental</span>
<span class="lineno"> 1049 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRModule&quot; Experimental</span>
<span class="lineno"> 1050 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRType&quot; Experimental</span>
<span class="lineno"> 1051 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;MIRValue&quot; Experimental</span>
<span class="lineno"> 1052 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;ModuleSkeleton&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1053 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;ProofResult&quot; Current</span>
<span class="lineno"> 1054 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Refnset&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1055 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SatResult&quot; Current</span>
<span class="lineno"> 1056 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SetupValue&quot; Current</span>
<span class="lineno"> 1057 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Simpset&quot; Current</span>
<span class="lineno"> 1058 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;SkeletonState&quot; <span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1059 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Theorem&quot; Current</span>
<span class="lineno"> 1060 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;Uninterp&quot; HideDeprecated</span>
<span class="lineno"> 1061 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;YosysSequential&quot; Experimental</span>
<span class="lineno"> 1062 </span><span class="spaces">  </span><span class="istickedoff">, abstype &quot;YosysTheorem&quot; Experimental</span>
<span class="lineno"> 1063 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 1064 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1065 </span><span class="spaces">    </span><span class="istickedoff">-- abstract type</span>
<span class="lineno"> 1066 </span><span class="spaces">    </span><span class="istickedoff">abstype :: Text -&gt; PrimitiveLifecycle -&gt; (SS.Name, PrimType)</span>
<span class="lineno"> 1067 </span><span class="spaces">    </span><span class="istickedoff">abstype name lc = (name, info)</span>
<span class="lineno"> 1068 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno"> 1069 </span><span class="spaces">        </span><span class="istickedoff">info = PrimType</span>
<span class="lineno"> 1070 </span><span class="spaces">          </span><span class="istickedoff">{ primTypeType = SS.AbstractType</span>
<span class="lineno"> 1071 </span><span class="spaces">          </span><span class="istickedoff">, primTypeLife = lc</span>
<span class="lineno"> 1072 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno"> 1073 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1074 </span><span class="spaces">    </span><span class="istickedoff">-- concrete type (not currently used)</span>
<span class="lineno"> 1075 </span><span class="spaces">    </span><span class="istickedoff">_conctype :: Text -&gt; Text -&gt; PrimitiveLifecycle -&gt; (SS.Name, PrimType)</span>
<span class="lineno"> 1076 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">_conctype name tystr lc = (name, info)</span></span>
<span class="lineno"> 1077 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">where</span></span>
<span class="lineno"> 1078 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">info = PrimType</span></span>
<span class="lineno"> 1079 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">{ primTypeType = SS.ConcreteType ty</span></span>
<span class="lineno"> 1080 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">, primTypeLife = lc</span></span>
<span class="lineno"> 1081 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">}</span></span>
<span class="lineno"> 1082 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">fakeFileName = Text.unpack $ &quot;&lt;definition of builtin type &quot; &lt;&gt; name &lt;&gt; &quot;&gt;&quot;</span></span>
<span class="lineno"> 1083 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">ty = case readSchema fakeFileName tystr of</span></span>
<span class="lineno"> 1084 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">SS.Forall [] ty' -&gt; ty'</span></span>
<span class="lineno"> 1085 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; panic &quot;primTypes&quot; [&quot;Builtin typedef name not monomorphic&quot;]</span></span></span>
<span class="lineno"> 1086 </span>
<span class="lineno"> 1087 </span>
<span class="lineno"> 1088 </span>primitives :: Map SS.LName Primitive
<span class="lineno"> 1089 </span><span class="decl"><span class="istickedoff">primitives = Map.fromList</span>
<span class="lineno"> 1090 </span><span class="spaces">  </span><span class="istickedoff">[ prim &quot;return&quot;              &quot;{m, a} a -&gt; m a&quot;</span>
<span class="lineno"> 1091 </span><span class="spaces">    </span><span class="istickedoff">(pureVal VReturn)</span>
<span class="lineno"> 1092 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Yield a value in a command context. The command&quot;</span></span>
<span class="lineno"> 1094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;    x &lt;- return e&quot;</span></span>
<span class="lineno"> 1095 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot;will result in the same value being bound to 'x' as the command&quot;</span></span>
<span class="lineno"> 1096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;    let x = e&quot;</span></span>
<span class="lineno"> 1097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1098 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1099 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;true&quot;                &quot;Bool&quot;</span>
<span class="lineno"> 1100 </span><span class="spaces">    </span><span class="istickedoff">(pureVal True)</span>
<span class="lineno"> 1101 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A boolean value.&quot; ]</span></span>
<span class="lineno"> 1103 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1104 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;false&quot;               &quot;Bool&quot;</span>
<span class="lineno"> 1105 </span><span class="spaces">    </span><span class="istickedoff">(pureVal False)</span>
<span class="lineno"> 1106 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A boolean value.&quot; ]</span></span>
<span class="lineno"> 1108 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1109 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;for&quot;                 &quot;{m, a, b} [a] -&gt; (a -&gt; m b) -&gt; m [b]&quot;</span>
<span class="lineno"> 1110 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (VLambda . forValue))</span>
<span class="lineno"> 1111 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1112 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given command in sequence to the given list. Return&quot;</span></span>
<span class="lineno"> 1113 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the list containing the result returned by the command at each&quot;</span></span>
<span class="lineno"> 1114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;iteration.&quot;</span></span>
<span class="lineno"> 1115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1116 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1117 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;run&quot;                 &quot;{a} TopLevel a -&gt; a&quot;</span>
<span class="lineno"> 1118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (id :: TopLevel Value -&gt; TopLevel Value))</span></span>
<span class="lineno"> 1119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1120 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a monadic TopLevel computation to produce a value.&quot; ]</span></span>
<span class="lineno"> 1121 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1122 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;null&quot;                &quot;{a} [a] -&gt; Bool&quot;</span>
<span class="lineno"> 1123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (null :: [Value] -&gt; Bool))</span></span>
<span class="lineno"> 1124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1125 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Test whether a list value is empty.&quot; ]</span></span>
<span class="lineno"> 1126 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1127 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;nth&quot;                 &quot;{a} [a] -&gt; Int -&gt; a&quot;</span>
<span class="lineno"> 1128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 (nthPrim :: [Value] -&gt; Int -&gt; TopLevel Value))</span></span>
<span class="lineno"> 1129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Look up the value at the given list position.&quot; ]</span></span>
<span class="lineno"> 1131 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1132 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;head&quot;                &quot;{a} [a] -&gt; a&quot;</span>
<span class="lineno"> 1133 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (headPrim :: [Value] -&gt; TopLevel Value))</span></span>
<span class="lineno"> 1134 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the first element from the list.&quot; ]</span></span>
<span class="lineno"> 1136 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1137 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;tail&quot;                &quot;{a} [a] -&gt; [a]&quot;</span>
<span class="lineno"> 1138 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (tailPrim :: [Value] -&gt; TopLevel [Value]))</span></span>
<span class="lineno"> 1139 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Drop the first element from a list.&quot; ]</span></span>
<span class="lineno"> 1141 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1142 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;concat&quot;              &quot;{a} [a] -&gt; [a] -&gt; [a]&quot;</span>
<span class="lineno"> 1143 </span><span class="spaces">    </span><span class="istickedoff">(pureVal <span class="nottickedoff">((++) :: [Value] -&gt; [Value] -&gt; [Value])</span>)</span>
<span class="lineno"> 1144 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate two lists to yield a third.&quot; ]</span></span>
<span class="lineno"> 1146 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1147 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;length&quot;              &quot;{a} [a] -&gt; Int&quot;</span>
<span class="lineno"> 1148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (length :: [Value] -&gt; Int))</span></span>
<span class="lineno"> 1149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Compute the length of a list.&quot; ]</span></span>
<span class="lineno"> 1151 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1152 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;str_concat&quot;          &quot;String -&gt; String -&gt; String&quot;</span>
<span class="lineno"> 1153 </span><span class="spaces">    </span><span class="istickedoff">(pureVal ((++) :: String -&gt; String -&gt; String))</span>
<span class="lineno"> 1154 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate two strings to yield a third.&quot; ]</span></span>
<span class="lineno"> 1156 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1157 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;str_concats&quot;          &quot;[String] -&gt; String&quot;</span>
<span class="lineno"> 1158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (concat :: [String] -&gt; String))</span></span>
<span class="lineno"> 1159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1160 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Concatenate a list of strings together to yield a string.&quot; ]</span></span>
<span class="lineno"> 1161 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1162 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;callcc&quot; &quot;{a} ((a -&gt; TopLevel ()) -&gt; TopLevel a) -&gt; TopLevel a&quot;</span>
<span class="lineno"> 1163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toplevelCallCC)</span></span>
<span class="lineno"> 1164 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1165 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Call-with-current-continuation.&quot;</span></span>
<span class="lineno"> 1166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is a highly experimental control operator that can be used&quot;</span></span>
<span class="lineno"> 1168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to capture the surrounding top-level computation as a continuation.&quot;</span></span>
<span class="lineno"> 1169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The consequences of delaying and reentering the current continuation&quot;</span></span>
<span class="lineno"> 1170 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;may be somewhat unpredictable, so use this operator with great caution.&quot;</span></span>
<span class="lineno"> 1171 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1172 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1173 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;checkpoint&quot;          &quot;TopLevel (() -&gt; TopLevel ())&quot;</span>
<span class="lineno"> 1174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal checkpoint)</span></span>
<span class="lineno"> 1175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Capture the current state of the SAW interpreter, and return&quot;</span></span>
<span class="lineno"> 1177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;A TopLevel monadic action that, if invoked, will reset the&quot;</span></span>
<span class="lineno"> 1178 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;state of the interpreter back to to what it was at the&quot;</span></span>
<span class="lineno"> 1179 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;moment checkpoint was invoked.&quot;</span></span>
<span class="lineno"> 1180 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOTE that this facility is highly experimental and may not&quot;</span></span>
<span class="lineno"> 1182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be entirely reliable.  It is intended only for proof development&quot;</span></span>
<span class="lineno"> 1183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where it can speed up the process of experimenting with&quot;</span></span>
<span class="lineno"> 1184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mid-proof changes. Finalized proofs should not use this facility.&quot;</span></span>
<span class="lineno"> 1185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1186 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1187 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;subshell&quot;            &quot;() -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toplevelSubshell)</span></span>
<span class="lineno"> 1189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Open an interactive subshell instance in the context where&quot;</span></span>
<span class="lineno"> 1191 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'subshell' was called. This works either from within execution&quot;</span></span>
<span class="lineno"> 1192 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of a outer shell instance, or from interpreting a file in batch&quot;</span></span>
<span class="lineno"> 1193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mode. Enter the end-of-file character in your terminal (Ctrl^D, usually)&quot;</span></span>
<span class="lineno"> 1194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to exit the subshell and resume execution.&quot;</span></span>
<span class="lineno"> 1195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command is especially useful in conjunction with the 'checkpoint'&quot;</span></span>
<span class="lineno"> 1197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and 'callcc' commands, which allow state reset capabilities and the capturing&quot;</span></span>
<span class="lineno"> 1198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the calling context.&quot;</span></span>
<span class="lineno"> 1199 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that, due to the way the SAW script interpreter works, changes made&quot;</span></span>
<span class="lineno"> 1201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to a script file in which the 'subshell' command directly appears will&quot;</span></span>
<span class="lineno"> 1202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOT affect subsequent execution following a 'checkpoint' or 'callcc' use.&quot;</span></span>
<span class="lineno"> 1203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;However, changes made in a file that executed via 'include' WILL affect&quot;</span></span>
<span class="lineno"> 1204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;restarted executions, as the 'include' command will read and parse the&quot;</span></span>
<span class="lineno"> 1205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;file from scratch.&quot;</span></span>
<span class="lineno"> 1206 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1207 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1208 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_subshell&quot;      &quot;() -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 1209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\ _ _ -&gt; proofScriptSubshell)</span></span>
<span class="lineno"> 1210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Open an interactive subshell instance in the context of the current proof.&quot;</span></span>
<span class="lineno"> 1212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This allows the user to interactively execute 'ProofScript' tactic commands&quot;</span></span>
<span class="lineno"> 1213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;directly on the command line an examine their effects using, e.g., 'print_goal'.&quot;</span></span>
<span class="lineno"> 1214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In proof mode, the command prompt will change to 'proof (n)', where the 'n'&quot;</span></span>
<span class="lineno"> 1215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;indicates the number of subgoals remaining to proof for the current overall goal.&quot;</span></span>
<span class="lineno"> 1216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In this mode, tactic commands applied will only affect the current subgoal.&quot;</span></span>
<span class="lineno"> 1217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;When a particular subgoal is completed, the next subgoal will automatically become&quot;</span></span>
<span class="lineno"> 1218 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the active subgoal. An overall goal is completed when all subgoals are proved&quot;</span></span>
<span class="lineno"> 1219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the current number of subgoals is 0.&quot;</span></span>
<span class="lineno"> 1220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1221 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Enter the end-of-file character in your terminal (Ctrl^D, usually) to exit the proof&quot;</span></span>
<span class="lineno"> 1222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;subshell and resume execution.&quot;</span></span>
<span class="lineno"> 1223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1225 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;proof_checkpoint&quot;      &quot;ProofScript (() -&gt; ProofScript ())&quot;</span>
<span class="lineno"> 1226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proof_checkpoint)</span></span>
<span class="lineno"> 1227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Capture the current state of the proof and return a&quot;</span></span>
<span class="lineno"> 1229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;ProofScript monadic action that, if invoked, will reset the&quot;</span></span>
<span class="lineno"> 1230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;state of the proof back to to what it was at the&quot;</span></span>
<span class="lineno"> 1231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;moment checkpoint was invoked.&quot;</span></span>
<span class="lineno"> 1232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;NOTE that this facility is highly experimental and may not&quot;</span></span>
<span class="lineno"> 1234 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be entirely reliable.  It is intended only for proof development&quot;</span></span>
<span class="lineno"> 1235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where it can speed up the process of experimenting with&quot;</span></span>
<span class="lineno"> 1236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mid-proof changes. Finalized proofs should not use this facility.&quot;</span></span>
<span class="lineno"> 1237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1238 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1239 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;define&quot;              &quot;String -&gt; Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal definePrim)</span></span>
<span class="lineno"> 1241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Wrap a term with a name that allows its body to be hidden or&quot;</span></span>
<span class="lineno"> 1243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;revealed. This can allow any sub-term to be treated as an&quot;</span></span>
<span class="lineno"> 1244 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;uninterpreted function during proofs.&quot;</span></span>
<span class="lineno"> 1245 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1246 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1247 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;include&quot;             &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1248 </span><span class="spaces">    </span><span class="istickedoff">(pureVal include_value)</span>
<span class="lineno"> 1249 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Execute the given SAWScript file.&quot; ]</span></span>
<span class="lineno"> 1251 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1252 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_deprecated&quot;   &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1253 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal (add_primitives HideDeprecated))</span></span>
<span class="lineno"> 1254 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the use of deprecated commands. When commands are first deprecated they&quot;</span></span>
<span class="lineno"> 1256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;generate warnings. At a later stage they become invisible unless explicitly&quot;</span></span>
<span class="lineno"> 1257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;enabled with this command. The next stage is to remove them entirely. Therefore,&quot;</span></span>
<span class="lineno"> 1258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the use of this command should always be considered a temporary stopgap until&quot;</span></span>
<span class="lineno"> 1259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;your scripts can be updated.&quot;</span></span>
<span class="lineno"> 1260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1262 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_experimental&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1263 </span><span class="spaces">    </span><span class="istickedoff">(bicVal (add_primitives Experimental))</span>
<span class="lineno"> 1264 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the use of experimental commands.&quot; ]</span></span>
<span class="lineno"> 1266 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1267 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_smt_array_memory_model&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1268 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_smt_array_memory_model)</span>
<span class="lineno"> 1269 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the SMT array memory model.&quot; ]</span></span>
<span class="lineno"> 1271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1272 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_smt_array_memory_model&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1273 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_smt_array_memory_model)</span></span>
<span class="lineno"> 1274 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1275 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable the SMT array memory model.&quot; ]</span></span>
<span class="lineno"> 1276 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1277 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_sequent_goals&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_sequent_goals)</span></span>
<span class="lineno"> 1279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When verifying proof obligations arising from `llvm_verify` and similar commands,&quot;</span></span>
<span class="lineno"> 1281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;generate sequents for the proof obligations instead of a single boolean goal.&quot;</span></span>
<span class="lineno"> 1282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1283 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1284 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_sequent_goals&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_sequent_goals)</span></span>
<span class="lineno"> 1286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1287 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Restore the default behavior, which is to generate single boolean goals&quot;</span></span>
<span class="lineno"> 1288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for proof obligations arising from verification commands.&quot;</span></span>
<span class="lineno"> 1289 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1290 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1291 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_safety_proofs&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_safety_proofs)</span></span>
<span class="lineno"> 1293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Restore the default state, where safety obligations&quot;</span></span>
<span class="lineno"> 1295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;encountered during symbolic execution are proofed normally.&quot;</span></span>
<span class="lineno"> 1296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1298 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_safety_proofs&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_safety_proofs)</span></span>
<span class="lineno"> 1300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable checking of safety obligations encountered during symbolic&quot;</span></span>
<span class="lineno"> 1302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;execution. This is unsound! However, it can be useful during&quot;</span></span>
<span class="lineno"> 1303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initial proof construction to focus only on the stated correcness&quot;</span></span>
<span class="lineno"> 1304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications.&quot;</span></span>
<span class="lineno"> 1305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1306 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1307 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_single_override_special_case&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_single_override_special_case)</span></span>
<span class="lineno"> 1309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1310 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable special-case handling when there is exactly one override&quot;</span></span>
<span class="lineno"> 1311 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that appies at a given call site after structural matching.&quot;</span></span>
<span class="lineno"> 1312 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This special case handling asserts the override preconditions as separate&quot;</span></span>
<span class="lineno"> 1313 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof goals, instead of combining them into a single one.  In general,&quot;</span></span>
<span class="lineno"> 1314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this may produce more, but simpler, goals than when disabled.&quot;</span></span>
<span class="lineno"> 1315 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1316 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1317 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_single_override_special_case&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1318 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_single_override_special_case)</span></span>
<span class="lineno"> 1319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable special case handling for single overrides.&quot;</span></span>
<span class="lineno"> 1321 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is the default behavior.&quot;</span></span>
<span class="lineno"> 1322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1323 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1324 </span><span class="spaces"> </span><span class="istickedoff">, prim &quot;enable_crucible_assert_then_assume&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1325 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_crucible_assert_then_assume)</span>
<span class="lineno"> 1326 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume predicate after asserting it during Crucible symbolic simulation.&quot; ]</span></span>
<span class="lineno"> 1328 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1329 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_crucible_assert_then_assume&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1330 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_crucible_assert_then_assume)</span>
<span class="lineno"> 1331 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Do not assume predicate after asserting it during Crucible symbolic simulation.&quot; ]</span></span>
<span class="lineno"> 1333 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1334 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_arithmetic&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_lax_arithmetic)</span></span>
<span class="lineno"> 1336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable lax rules for arithmetic overflow in Crucible.&quot; ]</span></span>
<span class="lineno"> 1338 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1339 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_arithmetic&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1340 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_arithmetic)</span></span>
<span class="lineno"> 1341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable lax rules for arithmetic overflow in Crucible.&quot; ]</span></span>
<span class="lineno"> 1343 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1344 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_pointer_ordering&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1345 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_lax_pointer_ordering)</span>
<span class="lineno"> 1346 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable lax rules for pointer ordering comparisons in Crucible.&quot; ]</span></span>
<span class="lineno"> 1348 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1349 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_pointer_ordering&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_pointer_ordering)</span></span>
<span class="lineno"> 1351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable lax rules for pointer ordering comparisons in Crucible.&quot; ]</span></span>
<span class="lineno"> 1353 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1354 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_lax_loads_and_stores&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1355 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_lax_loads_and_stores)</span>
<span class="lineno"> 1356 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable relaxed validity checking for memory loads and stores in Crucible.&quot; ]</span></span>
<span class="lineno"> 1358 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1359 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_lax_loads_and_stores&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_lax_loads_and_stores)</span></span>
<span class="lineno"> 1361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable relaxed validity checking for memory loads and stores in Crucible.&quot; ]</span></span>
<span class="lineno"> 1363 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1364 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_path_sat_solver&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_path_sat_solver)</span></span>
<span class="lineno"> 1366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1367 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the path satisfiablity solver to use.  Accepted values&quot;</span></span>
<span class="lineno"> 1368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;currently are 'z3' and 'yices'.&quot;</span></span>
<span class="lineno"> 1369 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1370 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1371 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_solver_cache_path&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1372 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_solver_cache_path)</span>
<span class="lineno"> 1373 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a solver result cache at the given path, add to that cache all results&quot;</span></span>
<span class="lineno"> 1375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the currently used solver result cache, if there is one, then use the newly&quot;</span></span>
<span class="lineno"> 1376 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;created cache as the solver result cache going forward. Note that if the&quot;</span></span>
<span class="lineno"> 1377 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW_SOLVER_CACHE_PATH environment variable was set at startup but solver&quot;</span></span>
<span class="lineno"> 1378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;caching has yet to actually be used, then the value of the environment&quot;</span></span>
<span class="lineno"> 1379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable is ignored.&quot;</span></span>
<span class="lineno"> 1380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1381 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1382 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;clean_mismatched_versions_solver_cache&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1383 </span><span class="spaces">    </span><span class="istickedoff">(pureVal clean_mismatched_versions_solver_cache)</span>
<span class="lineno"> 1384 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1385 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all entries in the solver result cache which were created&quot;</span></span>
<span class="lineno"> 1386 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using solver backend versions which do not match the versions&quot;</span></span>
<span class="lineno"> 1387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the current environment.&quot;</span></span>
<span class="lineno"> 1388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1389 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1390 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_solver_cache&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1391 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (onSolverCache . printSolverCacheByHex))</span></span>
<span class="lineno"> 1392 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1393 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print all entries in the solver result cache whose SHA256 hash&quot;</span></span>
<span class="lineno"> 1394 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;keys start with the given hex string. Providing an empty string&quot;</span></span>
<span class="lineno"> 1395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;results in all entries in the cache being printed.&quot;</span></span>
<span class="lineno"> 1396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1397 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1398 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_solver_cache_stats&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (onSolverCache printSolverCacheStats))</span></span>
<span class="lineno"> 1400 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1401 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print out statistics about how the solver cache has been used, namely:&quot;</span></span>
<span class="lineno"> 1402 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. How many entries are in the cache (and where the cache is stored)&quot;</span></span>
<span class="lineno"> 1403 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2. How many insertions into the cache have been made so far this session&quot;</span></span>
<span class="lineno"> 1404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;3. How many failed insertion attempts have been made so far this session&quot;</span></span>
<span class="lineno"> 1405 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;4. How times cached results have been used so far this session&quot;</span></span>
<span class="lineno"> 1406 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;5. How many failed attempted usages have occurred so far this session.&quot; ]</span></span>
<span class="lineno"> 1407 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1408 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;test_solver_cache_stats&quot; &quot;Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1409 </span><span class="spaces">    </span><span class="istickedoff">(pureVal test_solver_cache_stats)</span>
<span class="lineno"> 1410 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Test whether the values of the statistics printed out by&quot;</span></span>
<span class="lineno"> 1412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;print_solver_cache_stats are equal to those given, failing if this does not&quot;</span></span>
<span class="lineno"> 1413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hold. Specifically, the arguments represent:&quot;</span></span>
<span class="lineno"> 1414 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. How many entries are in the cache&quot;</span></span>
<span class="lineno"> 1415 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2. How many insertions into the cache have been made so far this session&quot;</span></span>
<span class="lineno"> 1416 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;3. How many failed insertion attempts have been made so far this session&quot;</span></span>
<span class="lineno"> 1417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;4. How times cached results have been used so far this session&quot;</span></span>
<span class="lineno"> 1418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;5. How many failed attempted usages have occurred so far this session&quot; ]</span></span>
<span class="lineno"> 1419 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1420 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_debug_intrinsics&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1421 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_debug_intrinsics)</span></span>
<span class="lineno"> 1422 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable translating statements using certain llvm.dbg intrinsic functions in Crucible.&quot; ]</span></span>
<span class="lineno"> 1424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1425 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_debug_intrinsics&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1426 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_debug_intrinsics)</span></span>
<span class="lineno"> 1427 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1428 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable translating statements using certain llvm.dbg intrinsic functions in Crucible.&quot; ]</span></span>
<span class="lineno"> 1429 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1430 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_what4_hash_consing)</span></span>
<span class="lineno"> 1432 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1433 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable hash consing for What4 expressions.&quot; ]</span></span>
<span class="lineno"> 1434 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1435 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1436 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_hash_consing)</span></span>
<span class="lineno"> 1437 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1438 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable hash consing for What4 expressions.&quot; ]</span></span>
<span class="lineno"> 1439 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1440 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;env&quot;                 &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal envCmd)</span></span>
<span class="lineno"> 1442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print all sawscript values in scope.&quot; ]</span></span>
<span class="lineno"> 1444 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1445 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_ascii&quot;           &quot;Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1446 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_ascii)</span></span>
<span class="lineno"> 1447 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Select whether to pretty-print arrays of 8-bit numbers as ascii strings.&quot; ]</span></span>
<span class="lineno"> 1449 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1450 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_base&quot;            &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1451 </span><span class="spaces">    </span><span class="istickedoff">(pureVal set_base)</span>
<span class="lineno"> 1452 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1453 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the number base for pretty-printing numeric literals.&quot;</span></span>
<span class="lineno"> 1454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Permissible values include 2, 8, 10, and 16.&quot; ]</span></span>
<span class="lineno"> 1455 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1456 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_color&quot;           &quot;Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1457 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_color)</span></span>
<span class="lineno"> 1458 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Select whether to pretty-print SAWCore terms using color.&quot; ]</span></span>
<span class="lineno"> 1460 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1461 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_min_sharing&quot;     &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1462 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_min_sharing)</span></span>
<span class="lineno"> 1463 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1464 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the number times a subterm must be shared for it to be&quot;</span></span>
<span class="lineno"> 1465 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;let-bound in printer output.&quot; ]</span></span>
<span class="lineno"> 1466 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1467 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_hash&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1468 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_hash)</span></span>
<span class="lineno"> 1469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;`set_memoization_hash i` changes the memoization strategy &quot;</span></span>
<span class="lineno"> 1471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for terms: memoization identifiers will include the first `i` &quot;</span></span>
<span class="lineno"> 1472 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;digits of the hash of the term they memoize. This is useful &quot;</span></span>
<span class="lineno"> 1473 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to help keep memoization identifiers of the same term as &quot;</span></span>
<span class="lineno"> 1474 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;constant as possible across different executions of a proof &quot;</span></span>
<span class="lineno"> 1475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;script over the course of its development.&quot;</span></span>
<span class="lineno"> 1476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1477 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1478 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_hash_incremental&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_hash_incremental)</span></span>
<span class="lineno"> 1480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;`set_memoization_hash_incremental i` changes the memoization &quot;</span></span>
<span class="lineno"> 1482 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;strategy for terms: memoization identifiers will include the &quot;</span></span>
<span class="lineno"> 1483 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first `i` digits of the hash of the term they memoize, as well &quot;</span></span>
<span class="lineno"> 1484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the value of a global counter that increments each time a &quot;</span></span>
<span class="lineno"> 1485 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term is memoized. This is useful to help keep memoization &quot;</span></span>
<span class="lineno"> 1486 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;identifiers of the same term as constant as possible across &quot;</span></span>
<span class="lineno"> 1487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;different executions of a proof script over the course of its &quot;</span></span>
<span class="lineno"> 1488 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;development, as well as to freshen memoization identifiers in &quot;</span></span>
<span class="lineno"> 1489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the unlikely case of term hash collisions.&quot;</span></span>
<span class="lineno"> 1490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1492 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_memoization_incremental&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 1493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_memoization_incremental)</span></span>
<span class="lineno"> 1494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;`set_memoization_incremental` changes the memoization strategy &quot;</span></span>
<span class="lineno"> 1496 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for terms: memoization identifiers will only include the value &quot;</span></span>
<span class="lineno"> 1497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of a global counter that increments each time a term is memoized. &quot;</span></span>
<span class="lineno"> 1498 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is the default.&quot;</span></span>
<span class="lineno"> 1499 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1500 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1501 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_timeout&quot;         &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 1502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_timeout)</span></span>
<span class="lineno"> 1503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the timeout, in milliseconds, for any automated prover at the&quot;</span></span>
<span class="lineno"> 1505 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;end of this proof script. Not that this is simply ignored for provers&quot;</span></span>
<span class="lineno"> 1506 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that don't support timeouts, for now.&quot;</span></span>
<span class="lineno"> 1507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1508 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1509 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show&quot;                &quot;{a} a -&gt; String&quot;</span>
<span class="lineno"> 1510 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 showPrim)</span>
<span class="lineno"> 1511 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert the value of the given expression to a string.&quot; ]</span></span>
<span class="lineno"> 1513 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1514 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print&quot;               &quot;{a} a -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1515 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_value)</span>
<span class="lineno"> 1516 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1517 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the value of the given expression.&quot; ]</span></span>
<span class="lineno"> 1518 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1519 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_term&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1520 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_term)</span>
<span class="lineno"> 1521 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax.&quot; ]</span></span>
<span class="lineno"> 1523 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1524 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_term_depth&quot;    &quot;Int -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_term_depth)</span></span>
<span class="lineno"> 1526 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1527 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax up to a given depth.&quot; ]</span></span>
<span class="lineno"> 1528 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1529 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;dump_file_AST&quot;       &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal $ const $ \opts -&gt; SAWScript.Import.loadFile opts &gt;=&gt; mapM_ print)</span></span>
<span class="lineno"> 1531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Dump a pretty representation of the SAWScript AST for a file.&quot; ]</span></span>
<span class="lineno"> 1533 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1534 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parser_printer_roundtrip&quot;       &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal $ const $</span></span>
<span class="lineno"> 1536 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">\opts -&gt; SAWScript.Import.loadFile opts &gt;=&gt;</span></span>
<span class="lineno"> 1537 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">PP.putDoc . SS.prettyWholeModule)</span></span>
<span class="lineno"> 1538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parses the file as SAWScript and renders the resultant AST back to SAWScript concrete syntax.&quot; ]</span></span>
<span class="lineno"> 1540 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1541 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_type&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1542 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_type)</span>
<span class="lineno"> 1543 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the type of the given term.&quot; ]</span></span>
<span class="lineno"> 1545 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1546 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;type&quot;                &quot;Term -&gt; Type&quot;</span>
<span class="lineno"> 1547 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 term_type)</span></span>
<span class="lineno"> 1548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the type of the given term.&quot; ]</span></span>
<span class="lineno"> 1550 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1551 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show_term&quot;           &quot;Term -&gt; String&quot;</span>
<span class="lineno"> 1552 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 show_term)</span>
<span class="lineno"> 1553 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print the given term in SAWCore syntax, yielding a String.&quot; ]</span></span>
<span class="lineno"> 1555 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1556 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_term&quot;          &quot;Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1557 </span><span class="spaces">    </span><span class="istickedoff">(pureVal check_term)</span>
<span class="lineno"> 1558 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type-check the given term, printing an error message if ill-typed.&quot; ]</span></span>
<span class="lineno"> 1560 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1561 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 1562 </span><span class="spaces">    </span><span class="istickedoff">(pureVal check_goal)</span>
<span class="lineno"> 1563 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type-check the current proof goal, printing an error message if ill-typed.&quot; ]</span></span>
<span class="lineno"> 1565 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1566 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_size&quot;           &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 1567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal scSharedSize)</span></span>
<span class="lineno"> 1568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the size of the given term in the number of DAG nodes.&quot; ]</span></span>
<span class="lineno"> 1570 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1571 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_tree_size&quot;      &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 1572 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal scTreeSize)</span></span>
<span class="lineno"> 1573 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return the size of the given term in the number of nodes it would&quot;</span></span>
<span class="lineno"> 1575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;have if treated as a tree instead of a DAG.&quot;</span></span>
<span class="lineno"> 1576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1577 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1578 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;abstract_symbolic&quot;   &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 1579 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 abstractSymbolicPrim)</span>
<span class="lineno"> 1580 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a term containing symbolic variables of the form returned&quot;</span></span>
<span class="lineno"> 1582 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by 'fresh_symbolic' and return a new lambda term in which those&quot;</span></span>
<span class="lineno"> 1583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables have been replaced by parameter references.&quot;</span></span>
<span class="lineno"> 1584 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1585 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1586 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fresh_symbolic&quot;      &quot;String -&gt; Type -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1587 </span><span class="spaces">    </span><span class="istickedoff">(pureVal freshSymbolicPrim)</span>
<span class="lineno"> 1588 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1589 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given type. The given name&quot;</span></span>
<span class="lineno"> 1590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 1591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1592 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1593 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_apply&quot;          &quot;Term -&gt; [Term] -&gt; Term&quot;</span>
<span class="lineno"> 1594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_apply)</span></span>
<span class="lineno"> 1595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Build a term application node that applies the first term&quot;</span></span>
<span class="lineno"> 1597 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(which much be a term representing a function) to given list of arguments.&quot;</span></span>
<span class="lineno"> 1598 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1599 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1600 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;lambda&quot;              &quot;Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 1601 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 lambda)</span>
<span class="lineno"> 1602 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1603 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a 'fresh_symbolic' variable and another term containing that&quot;</span></span>
<span class="lineno"> 1604 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable, and return a new lambda abstraction over that variable.&quot;</span></span>
<span class="lineno"> 1605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1606 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1607 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;lambdas&quot;             &quot;[Term] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 1608 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 lambdas)</span>
<span class="lineno"> 1609 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a list of 'fresh_symbolic' variable and another term containing&quot;</span></span>
<span class="lineno"> 1611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;those variables, and return a new lambda abstraction over the list of&quot;</span></span>
<span class="lineno"> 1612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables.&quot;</span></span>
<span class="lineno"> 1613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1614 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1615 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;generalize_term&quot;   &quot;[Term] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 1616 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 generalize_term)</span></span>
<span class="lineno"> 1617 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 1618 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Take a list of 'fresh_symbolic' variables and another term containing those&quot;</span></span>
<span class="lineno"> 1619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables, and return a new Pi generalization over the list of variables.&quot;</span></span>
<span class="lineno"> 1620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1621 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1622 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;implies_term&quot;      &quot;Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 1623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 implies_term)</span></span>
<span class="lineno"> 1624 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given two terms, which must be Prop terms, construct the SAWCore implication&quot;</span></span>
<span class="lineno"> 1626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of those terms.&quot;</span></span>
<span class="lineno"> 1627 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1628 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1629 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;size_to_term&quot;      &quot;Type -&gt; Term&quot;</span>
<span class="lineno"> 1630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 size_to_term)</span></span>
<span class="lineno"> 1631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a Cryptol size type into a Term representation.&quot;</span></span>
<span class="lineno"> 1633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1634 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1635 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;int_to_term&quot;      &quot;Int -&gt; Term&quot;</span>
<span class="lineno"> 1636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 int_to_term)</span></span>
<span class="lineno"> 1637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a concrete integer value into an integer term.&quot; ]</span></span>
<span class="lineno"> 1639 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1640 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;nat_to_term&quot;      &quot;Int -&gt; Term&quot;</span>
<span class="lineno"> 1641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 nat_to_term)</span></span>
<span class="lineno"> 1642 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1643 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a non-negative integer value into a natural number term.&quot; ]</span></span>
<span class="lineno"> 1644 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1645 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_theories&quot; &quot;[String] -&gt; Term -&gt; [String]&quot;</span>
<span class="lineno"> 1646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_theories)</span></span>
<span class="lineno"> 1647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term of type \'Bool\', compute the SMT theories required&quot;</span></span>
<span class="lineno"> 1649 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to reason about this term. The functions (if any) given in the&quot;</span></span>
<span class="lineno"> 1650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first argument will be treated as uninterpreted.&quot;</span></span>
<span class="lineno"> 1651 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If the returned list is empty, the given term represents a problem&quot;</span></span>
<span class="lineno"> 1653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that can be solved purely by boolean SAT reasoning.&quot;</span></span>
<span class="lineno"> 1654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: the given term will be simplified using the What4 backend&quot;</span></span>
<span class="lineno"> 1656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;before evaluating what theories are required.  For simple problems,&quot;</span></span>
<span class="lineno"> 1657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this may simplify away some aspects of the problem altogether and may result&quot;</span></span>
<span class="lineno"> 1658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in requiring fewer theories than one might expect.&quot;</span></span>
<span class="lineno"> 1659 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1660 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1661 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_term&quot; &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 1662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 default_typed_term)</span></span>
<span class="lineno"> 1663 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 1664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply Cryptol defaulting rules to the given term.&quot; ]</span></span>
<span class="lineno"> 1665 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1666 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;congruence_for&quot; &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1667 </span><span class="spaces">    </span><span class="istickedoff">(pureVal congruence_for)</span>
<span class="lineno"> 1668 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 1669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term representing a (nondependent) function, attempt&quot;</span></span>
<span class="lineno"> 1670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to automatically construct the statement of a congruence lemma&quot;</span></span>
<span class="lineno"> 1671 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for the function.&quot;</span></span>
<span class="lineno"> 1672 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1674 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;extract_uninterp&quot; &quot;[String] -&gt; [String] -&gt; Term -&gt; TopLevel (Term, [(String,[(Term, Term)])])&quot;</span>
<span class="lineno"> 1675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal extract_uninterp)</span></span>
<span class="lineno"> 1676 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a list of names of functions to treat as uninterpreted and a term, find all occurrences&quot;</span></span>
<span class="lineno"> 1678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the named functions and extract them.&quot;</span></span>
<span class="lineno"> 1679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1680 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the list of \'uninterpreted\' functions to extract.&quot;</span></span>
<span class="lineno"> 1681 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is a list of values to treat as opaque; they will not be unfolded during evaluation.&quot;</span></span>
<span class="lineno"> 1682 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is the term to extract from.&quot;</span></span>
<span class="lineno"> 1683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This operation will return a pair, consisting of a rewritten term and a list of replacements.&quot;</span></span>
<span class="lineno"> 1685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The rewritten term will have each fully-applied occurrence of the named functions replaced&quot;</span></span>
<span class="lineno"> 1686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by a fresh constant of the return type of the function. The list of replacements consists&quot;</span></span>
<span class="lineno"> 1687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of pairs (one for each named function) giving the name of that function and the replacement&quot;</span></span>
<span class="lineno"> 1688 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values for that function. The replacement values are a list of pairs of terms, one for each&quot;</span></span>
<span class="lineno"> 1689 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;occurence that was replaced.  The first term in each  pair gives the fresh constant appearing&quot;</span></span>
<span class="lineno"> 1690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the rewritten term.  The second term will be a tuple containing the arguments to the&quot;</span></span>
<span class="lineno"> 1691 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;replaced function.&quot;</span></span>
<span class="lineno"> 1692 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1693 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1694 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_uninterpreted&quot;   &quot;String -&gt; Term -&gt; TopLevel Uninterp&quot;</span>
<span class="lineno"> 1695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal sbvUninterpreted)</span></span>
<span class="lineno"> 1696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">HideDeprecated</span></span>
<span class="lineno"> 1697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Indicate that the given term should be used as the definition of the&quot;</span></span>
<span class="lineno"> 1698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;named function when loading an SBV file. This command returns an&quot;</span></span>
<span class="lineno"> 1699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;object that can be passed to 'read_sbv'.&quot;</span></span>
<span class="lineno"> 1700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1702 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;is_convertible&quot;  &quot;Term -&gt; Term -&gt; TopLevel Bool&quot;</span>
<span class="lineno"> 1703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal isConvertiblePrim)</span></span>
<span class="lineno"> 1704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true iff the two terms are convertible.&quot; ]</span></span>
<span class="lineno"> 1706 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1707 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;check_convertible&quot;  &quot;Term -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal checkConvertiblePrim)</span></span>
<span class="lineno"> 1709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Check if two terms are convertible and print the result.&quot; ]</span></span>
<span class="lineno"> 1711 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1712 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;replace&quot;             &quot;Term -&gt; Term -&gt; Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1713 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal replacePrim)</span></span>
<span class="lineno"> 1714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;'replace x y z' rewrites occurences of term x into y inside the&quot;</span></span>
<span class="lineno"> 1716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term z.  x and y must be closed terms.&quot;</span></span>
<span class="lineno"> 1717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1718 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1719 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;hoist_ifs&quot;            &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal hoistIfsPrim)</span></span>
<span class="lineno"> 1721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Hoist all if-then-else expressions as high as possible.&quot; ]</span></span>
<span class="lineno"> 1723 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1724 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_bytes&quot;          &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1725 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readBytes)</span>
<span class="lineno"> 1726 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read binary file as a value of type [n][8].&quot; ]</span></span>
<span class="lineno"> 1728 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1729 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_sbv&quot;            &quot;String -&gt; [Uninterp] -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal readSBV)</span></span>
<span class="lineno"> 1731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">HideDeprecated</span></span>
<span class="lineno"> 1732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an SBV file produced by Cryptol 1, using the given set of&quot;</span></span>
<span class="lineno"> 1733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;overrides for any uninterpreted functions that appear in the file.&quot;</span></span>
<span class="lineno"> 1734 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1735 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1736 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;load_aig&quot;            &quot;String -&gt; TopLevel AIG&quot;</span>
<span class="lineno"> 1737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal loadAIGPrim)</span></span>
<span class="lineno"> 1738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an AIG file in binary AIGER format, yielding an AIG value.&quot; ]</span></span>
<span class="lineno"> 1740 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;save_aig&quot;            &quot;String -&gt; AIG -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal saveAIGPrim)</span></span>
<span class="lineno"> 1742 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write an AIG to a file in binary AIGER format.&quot; ]</span></span>
<span class="lineno"> 1744 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;save_aig_as_cnf&quot;     &quot;String -&gt; AIG -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal saveAIGasCNFPrim)</span></span>
<span class="lineno"> 1746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write an AIG representing a boolean function to a file in DIMACS&quot;</span></span>
<span class="lineno"> 1748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CNF format.&quot;</span></span>
<span class="lineno"> 1749 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1750 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1751 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;dsec_print&quot;                &quot;Term -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal dsecPrint)</span></span>
<span class="lineno"> 1753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use ABC's 'dsec' command to compare two terms as SAIGs.&quot;</span></span>
<span class="lineno"> 1755 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The terms must have a type as described in ':help write_saig',&quot;</span></span>
<span class="lineno"> 1756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;i.e. of the form '(i, s) -&gt; (o, s)'. Note that nothing is returned:&quot;</span></span>
<span class="lineno"> 1757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;you must read the output to see what happened.&quot;</span></span>
<span class="lineno"> 1758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;You must have an 'abc' executable on your PATH to use this command.&quot;</span></span>
<span class="lineno"> 1760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1761 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1762 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;bitblast&quot;            &quot;Term -&gt; TopLevel AIG&quot;</span>
<span class="lineno"> 1763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal bbPrim)</span></span>
<span class="lineno"> 1764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a term into an AIG.  The term must be representable as a&quot;</span></span>
<span class="lineno"> 1766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function from a finite number of bits to a finite number of bits.&quot;</span></span>
<span class="lineno"> 1767 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1768 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1769 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_aig&quot;            &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1770 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readAIGPrim)</span>
<span class="lineno"> 1771 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read an AIG file in AIGER format and translate to a term.&quot; ]</span></span>
<span class="lineno"> 1773 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1774 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;read_core&quot;           &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 1775 </span><span class="spaces">    </span><span class="istickedoff">(pureVal readCore)</span>
<span class="lineno"> 1776 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Read a term from a file in the SAWCore external format.&quot; ]</span></span>
<span class="lineno"> 1778 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1779 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_aig&quot;           &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1780 </span><span class="spaces">    </span><span class="istickedoff">(pureVal writeAIGPrim)</span>
<span class="lineno"> 1781 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 1783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 1784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits.&quot;</span></span>
<span class="lineno"> 1785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1786 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1787 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_aig_external&quot;  &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeAIGviaVerilog)</span></span>
<span class="lineno"> 1789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 1791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 1792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits. Uses ABC to convert an intermediate&quot;</span></span>
<span class="lineno"> 1793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Verilog file.&quot;</span></span>
<span class="lineno"> 1794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1795 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1796 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_saig&quot;          &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeSAIGPrim)</span></span>
<span class="lineno"> 1798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1799 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 1800 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 1801 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits. The type must be of the form&quot;</span></span>
<span class="lineno"> 1802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'(i, s) -&gt; (o, s)' and is interpreted as an '[|i| + |s|] -&gt; [|o| + |s|]'&quot;</span></span>
<span class="lineno"> 1803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;AIG with '|s|' latches.&quot;</span></span>
<span class="lineno"> 1804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Arguments:&quot;</span></span>
<span class="lineno"> 1806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  file to translation to : String&quot;</span></span>
<span class="lineno"> 1807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  function to translate to sequential AIG : Term&quot;</span></span>
<span class="lineno"> 1808 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1809 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1810 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_saig'&quot;         &quot;String -&gt; Term -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1811 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeSAIGComputedPrim)</span></span>
<span class="lineno"> 1812 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in binary AIGER format. The&quot;</span></span>
<span class="lineno"> 1814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;term must be representable as a function from a finite number of&quot;</span></span>
<span class="lineno"> 1815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bits to a finite number of bits, '[m] -&gt; [n]'. The int argument,&quot;</span></span>
<span class="lineno"> 1816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'k', must be at most 'min {m, n}', and specifies that the *last* 'k'&quot;</span></span>
<span class="lineno"> 1817 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;input and output bits are joined as latches.&quot;</span></span>
<span class="lineno"> 1818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1819 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Arguments:&quot;</span></span>
<span class="lineno"> 1820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  file to translation to : String&quot;</span></span>
<span class="lineno"> 1821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  function to translate to sequential AIG : Term&quot;</span></span>
<span class="lineno"> 1822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  number of latches : Int&quot;</span></span>
<span class="lineno"> 1823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1824 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1825 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_cnf&quot;           &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1826 </span><span class="spaces">    </span><span class="istickedoff">(pureVal write_cnf)</span>
<span class="lineno"> 1827 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in CNF format.&quot; ]</span></span>
<span class="lineno"> 1829 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1830 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_cnf_external&quot;  &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal write_cnf_external)</span></span>
<span class="lineno"> 1832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1833 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in CNF format.&quot; ]</span></span>
<span class="lineno"> 1834 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1835 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_smtlib2&quot;       &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1836 </span><span class="spaces">    </span><span class="istickedoff">(pureVal write_smtlib2)</span>
<span class="lineno"> 1837 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in SMT-Lib version 2 format.&quot; ]</span></span>
<span class="lineno"> 1839 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1840 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_smtlib2_w4&quot;    &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1841 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal write_smtlib2_w4)</span></span>
<span class="lineno"> 1842 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the given term to the named file in SMT-Lib version 2 format,&quot;</span></span>
<span class="lineno"> 1844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend instead of the SBV backend.&quot;</span></span>
<span class="lineno"> 1845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1846 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1847 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_core&quot;          &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1848 </span><span class="spaces">    </span><span class="istickedoff">(pureVal writeCore)</span>
<span class="lineno"> 1849 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in SAWCore external format.&quot; ]</span></span>
<span class="lineno"> 1851 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1852 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_verilog&quot;       &quot;String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal writeVerilog)</span></span>
<span class="lineno"> 1854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in Verilog format.&quot; ]</span></span>
<span class="lineno"> 1856 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1857 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_term&quot; &quot;String -&gt; [(String, String)] -&gt; [String] -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1858 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeCoqTerm)</span></span>
<span class="lineno"> 1859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a term in Gallina syntax for Coq.&quot;</span></span>
<span class="lineno"> 1861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the name to use in a Definition.&quot;</span></span>
<span class="lineno"> 1862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 1863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 1864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 1865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 1866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 1867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 1868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fifth argument is the term to export.&quot;</span></span>
<span class="lineno"> 1869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1870 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1871 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_module&quot; &quot;String -&gt; String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1872 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (writeCoqCryptolModule False))</span></span>
<span class="lineno"> 1873 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a Cryptol module in Gallina syntax for&quot;</span></span>
<span class="lineno"> 1875 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Coq.&quot;</span></span>
<span class="lineno"> 1876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the file containing the module to export.&quot;</span></span>
<span class="lineno"> 1877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 1878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 1879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 1880 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 1881 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 1882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 1883 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1884 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1885 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_module_monadic&quot; &quot;String -&gt; String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (writeCoqCryptolModule True))</span></span>
<span class="lineno"> 1887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1888 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of a Cryptol module in Gallina syntax for&quot;</span></span>
<span class="lineno"> 1889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Coq, using the monadified version of the given module.&quot;</span></span>
<span class="lineno"> 1890 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the file containing the module to export.&quot;</span></span>
<span class="lineno"> 1891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 1892 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 1893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 1894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 1895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 1896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 1897 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1898 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1899 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_sawcore_prelude&quot; &quot;String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1900 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeCoqSAWCorePrelude)</span></span>
<span class="lineno"> 1901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1902 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of the SAW Core prelude in Gallina syntax for&quot;</span></span>
<span class="lineno"> 1903 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Coq.&quot;</span></span>
<span class="lineno"> 1904 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the name of the file to output into,&quot;</span></span>
<span class="lineno"> 1905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 1906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 1907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 1908 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 1909 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 1910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1911 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1912 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_coq_cryptol_primitives_for_sawcore&quot;</span>
<span class="lineno"> 1913 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; String -&gt; String -&gt; [(String, String)] -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal writeCoqCryptolPrimitivesForSAWCore)</span></span>
<span class="lineno"> 1915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of cryptol-saw-core's Cryptol.sawcore and &quot;</span></span>
<span class="lineno"> 1917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CryptolM.sawcore in Gallina syntax for Coq.&quot;</span></span>
<span class="lineno"> 1918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first three arguments are the names of the output files for translating &quot;</span></span>
<span class="lineno"> 1919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol.sawcore, SpecM.sawcore, and CryptolM.sawcore, respectively.&quot;</span></span>
<span class="lineno"> 1920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use an empty string to output to standard output.&quot;</span></span>
<span class="lineno"> 1921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth argument is a list of pairs of notation substitutions:&quot;</span></span>
<span class="lineno"> 1922 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the operator on the left will be replaced with the identifier on&quot;</span></span>
<span class="lineno"> 1923 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the right, as we do not support notations on the Coq side.&quot;</span></span>
<span class="lineno"> 1924 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fifth argument is a list of identifiers to skip translating.&quot;</span></span>
<span class="lineno"> 1925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1926 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1927 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_coq&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 1928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_coq)</span></span>
<span class="lineno"> 1929 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write out a representation of the current goal in Gallina syntax&quot;</span></span>
<span class="lineno"> 1931 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(for Coq). The argument is a prefix to use for file names.&quot;</span></span>
<span class="lineno"> 1932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1933 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1934 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;auto_match&quot; &quot;String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 1935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (autoMatch stmtInterpreter :: FilePath -&gt; FilePath -&gt; TopLevel ()))</span></span>
<span class="lineno"> 1936 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 1937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Interactively decides how to align two modules of potentially heterogeneous&quot;</span></span>
<span class="lineno"> 1938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;language and prints the result.&quot;</span></span>
<span class="lineno"> 1939 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1940 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1941 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove&quot;               &quot;ProofScript () -&gt; Term -&gt; TopLevel ProofResult&quot;</span>
<span class="lineno"> 1942 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePrim)</span>
<span class="lineno"> 1943 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1944 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is valid&quot;</span></span>
<span class="lineno"> 1945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(true for all inputs). Returns a proof result that can be analyzed&quot;</span></span>
<span class="lineno"> 1946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with 'caseProofResult' to determine whether it represents a successful&quot;</span></span>
<span class="lineno"> 1947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;proof or a counter-example.&quot;</span></span>
<span class="lineno"> 1948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1950 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_print&quot;         &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 1951 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePrintPrim)</span>
<span class="lineno"> 1952 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is valid&quot;</span></span>
<span class="lineno"> 1954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(true for all inputs). Returns a Theorem if successful, and aborts&quot;</span></span>
<span class="lineno"> 1955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if unsuccessful.&quot;</span></span>
<span class="lineno"> 1956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1957 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1958 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_by_bv_induction&quot;  &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 1959 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveByBVInduction)</span></span>
<span class="lineno"> 1960 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 1961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Attempt to prove a fact by induction on the less-than order on bitvectors.&quot;</span></span>
<span class="lineno"> 1962 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The given term is expected to be a function of one or more arguments&quot;</span></span>
<span class="lineno"> 1963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;which returns a tuple containing two values: first, a bitvector expression&quot;</span></span>
<span class="lineno"> 1964 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(which will be the expression we perform induction on), and second, a boolean value&quot;</span></span>
<span class="lineno"> 1965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;defining the theorem to prove.&quot;</span></span>
<span class="lineno"> 1966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 1967 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will attempt to prove the theorem expressed in the second&quot;</span></span>
<span class="lineno"> 1968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;element of the tuple by induction. The goal presented to the user-provided&quot;</span></span>
<span class="lineno"> 1969 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;tactic will ask to prove the stated goal and will be provided with an induction&quot;</span></span>
<span class="lineno"> 1970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hypothesis which states that the goal holds for all values of the varibles&quot;</span></span>
<span class="lineno"> 1971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;where the expression given in the first element of the tuple has decreased.&quot;</span></span>
<span class="lineno"> 1972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1973 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1974 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_extcore&quot;         &quot;ProofScript () -&gt; Term -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 1975 </span><span class="spaces">    </span><span class="istickedoff">(pureVal provePropPrim)</span>
<span class="lineno"> 1976 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 1977 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term representing&quot;</span></span>
<span class="lineno"> 1978 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a proposition is valid. For example, this is useful for proving a goal&quot;</span></span>
<span class="lineno"> 1979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;obtained with 'offline_extcore' or 'parse_core'. Returns a Theorem if&quot;</span></span>
<span class="lineno"> 1980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;successful, and aborts if unsuccessful.&quot;</span></span>
<span class="lineno"> 1981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 1982 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1983 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_bisim&quot;         &quot;ProofScript () -&gt; [BisimTheorem] -&gt; Term -&gt; Term -&gt; Term -&gt; Term -&gt; TopLevel BisimTheorem&quot;</span>
<span class="lineno"> 1984 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBisimulation)</span>
<span class="lineno"> 1985 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 1986 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use bisimulation to prove that two terms simulate each other.  The &quot;</span></span>
<span class="lineno"> 1987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;command takes the following arguments: &quot;</span></span>
<span class="lineno"> 1988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;1. The proof strategy to use&quot;</span></span>
<span class="lineno"> 1989 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;2. A list of already proven bisimulation theorems&quot;</span></span>
<span class="lineno"> 1990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;3. A state relation `srel : lhsState -&gt; rhsState -&gt; Bit`&quot;</span></span>
<span class="lineno"> 1991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;4. An output relation `orel : (lhsState, output) -&gt; (rhsState, output) -&gt; Bit`&quot;</span></span>
<span class="lineno"> 1992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;5. A term `lhs : (lhsState, input) -&gt; (lhsState, output)`&quot;</span></span>
<span class="lineno"> 1993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;6. A term `rhs : (rhsState, input) -&gt; (rhsState, output)`&quot;</span></span>
<span class="lineno"> 1994 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and considers `lhs` and `rhs` bisimilar when the following two theorems hold:&quot;</span></span>
<span class="lineno"> 1995 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* OUTPUT RELATION THEOREM:&quot;</span></span>
<span class="lineno"> 1996 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   forall s1 s2 in.&quot;</span></span>
<span class="lineno"> 1997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     srel s1 s2 -&gt; orel (lhs (s1, in)) (rhs (s2, in))&quot;</span></span>
<span class="lineno"> 1998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* STATE RELATION THEOREM:&quot;</span></span>
<span class="lineno"> 1999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;   forall s1 s2 out1 out2.&quot;</span></span>
<span class="lineno"> 2000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     orel (s1, out1) (s2, out2) -&gt; srel s1 s2&quot;</span></span>
<span class="lineno"> 2001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2002 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LIMITATIONS: For now, the prove_bisim command has a couple limitations:&quot;</span></span>
<span class="lineno"> 2003 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* `lhs` and `rhs` (arguments 5 and 6) must be named functions.&quot;</span></span>
<span class="lineno"> 2004 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;* Each subterm present in the list of bisimulation theorems already&quot;</span></span>
<span class="lineno"> 2005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  proven (argument 2) may be invoked at most once in `lhs` or `rhs`.&quot;</span></span>
<span class="lineno"> 2006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2007 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2008 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sat&quot;                 &quot;ProofScript () -&gt; Term -&gt; TopLevel SatResult&quot;</span>
<span class="lineno"> 2009 </span><span class="spaces">    </span><span class="istickedoff">(pureVal satPrim)</span>
<span class="lineno"> 2010 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2011 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 2012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiable (is true for some input). Returns a proof result that can&quot;</span></span>
<span class="lineno"> 2013 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be analyzed with 'caseSatResult' to determine whether it represents&quot;</span></span>
<span class="lineno"> 2014 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a satisfying assignment or an indication of unsatisfiability.&quot;</span></span>
<span class="lineno"> 2015 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2016 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2017 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sat_print&quot;           &quot;ProofScript () -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2018 </span><span class="spaces">    </span><span class="istickedoff">(pureVal satPrintPrim)</span>
<span class="lineno"> 2019 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2020 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is&quot;</span></span>
<span class="lineno"> 2021 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;satisfiable (true for any input). Returns nothing if successful, and&quot;</span></span>
<span class="lineno"> 2022 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;aborts if unsuccessful.&quot;</span></span>
<span class="lineno"> 2023 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2024 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2025 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;qc_print&quot;            &quot;Int -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\a -&gt; scVal (quickCheckPrintPrim a) a)</span></span>
<span class="lineno"> 2027 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2028 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quick Check a term by applying it to a sequence of random inputs&quot;</span></span>
<span class="lineno"> 2029 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and print the results. The 'Int' arg specifies how many tests to run.&quot;</span></span>
<span class="lineno"> 2030 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2031 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2032 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;codegen&quot;             &quot;String -&gt; [String] -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal codegenSBV)</span></span>
<span class="lineno"> 2034 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate straight-line C code for the given term using SBV.&quot;</span></span>
<span class="lineno"> 2036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;First argument is directory path (\&quot;\&quot; for stdout) for generating files.&quot;</span></span>
<span class="lineno"> 2038 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Second argument is the list of function names to leave uninterpreted.&quot;</span></span>
<span class="lineno"> 2039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Third argument is C function name.&quot;</span></span>
<span class="lineno"> 2040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fourth argument is the term to generate code for. It must be a&quot;</span></span>
<span class="lineno"> 2041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;first-order function whose arguments and result are all of type&quot;</span></span>
<span class="lineno"> 2042 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Bit, [8], [16], [32], or [64].&quot;</span></span>
<span class="lineno"> 2043 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2044 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2045 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfolding&quot;           &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2046 </span><span class="spaces">    </span><span class="istickedoff">(pureVal unfoldGoal)</span>
<span class="lineno"> 2047 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the named subterm(s) within the current goal.&quot; ]</span></span>
<span class="lineno"> 2049 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2050 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfolding_fix_once&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2051 </span><span class="spaces">    </span><span class="istickedoff">(pureVal unfoldFixOnceGoal)</span>
<span class="lineno"> 2052 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2053 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the named recursive constants once within the current goal.&quot;</span></span>
<span class="lineno"> 2054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Like `unfolding`, except that the recursive constants are unfolded&quot;</span></span>
<span class="lineno"> 2055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;only once, avoiding possible infinite evaluation.&quot;</span></span>
<span class="lineno"> 2056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2057 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2058 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;simplify&quot;            &quot;Simpset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2059 </span><span class="spaces">    </span><span class="istickedoff">(pureVal simplifyGoal)</span>
<span class="lineno"> 2060 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given simplifier rule set to the current goal.&quot; ]</span></span>
<span class="lineno"> 2062 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2063 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;simplify_local&quot;       &quot;[Int] -&gt; Simpset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal simplifyGoalWithLocals)</span></span>
<span class="lineno"> 2065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the given simplifier rule set to the current goal.&quot;</span></span>
<span class="lineno"> 2067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Also, use the given numbered hypotheses as rewrites.&quot;</span></span>
<span class="lineno"> 2068 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2069 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2070 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfocus&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal unfocus)</span></span>
<span class="lineno"> 2072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove any sequent focus point.&quot; ]</span></span>
<span class="lineno"> 2074 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2075 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;focus_concl&quot;      &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2076 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal focus_concl)</span></span>
<span class="lineno"> 2077 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Focus on the numbered conclusion within a sequent. This will fail if there are&quot;</span></span>
<span class="lineno"> 2079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not enough conclusions.&quot;</span></span>
<span class="lineno"> 2080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2081 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2082 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;focus_hyp&quot;       &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2083 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal focus_hyp)</span></span>
<span class="lineno"> 2084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Focus on the numbered conclusion with a sequent.  This will fail if there are&quot;</span></span>
<span class="lineno"> 2086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;enough hypotheses.&quot;</span></span>
<span class="lineno"> 2087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2088 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2089 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_sequent&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal normalize_sequent)</span></span>
<span class="lineno"> 2091 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2092 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the current goal sequent by applying reversable sequent calculus rules.&quot;</span></span>
<span class="lineno"> 2093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting sequent will be unfocused.&quot;</span></span>
<span class="lineno"> 2094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2095 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2096 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_cut&quot; &quot;Term -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_cut)</span></span>
<span class="lineno"> 2098 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2099 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a term provided by the user (which must be a boolean expression&quot;</span></span>
<span class="lineno"> 2100 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or a Prop) the current goal is split into two subgoals. In the first subgoal,&quot;</span></span>
<span class="lineno"> 2101 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given proposition is assumed as a new hypothesis. In the second subgoal,&quot;</span></span>
<span class="lineno"> 2102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given proposition is a new focused, conclusion. This implements the&quot;</span></span>
<span class="lineno"> 2103 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;usual cut rule of sequent calculus.&quot;</span></span>
<span class="lineno"> 2104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2105 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2106 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;retain_hyps&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal retain_hyps)</span></span>
<span class="lineno"> 2108 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all hypotheses from the current sequent other than the ones listed.&quot; ]</span></span>
<span class="lineno"> 2110 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2111 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;delete_hyps&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2112 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal delete_hyps)</span></span>
<span class="lineno"> 2113 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove the numbered hypotheses from the current sequent.&quot; ]</span></span>
<span class="lineno"> 2115 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2116 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;retain_concl&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal retain_concl)</span></span>
<span class="lineno"> 2118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove all conclusions from the current sequent other than the ones listed.&quot; ]</span></span>
<span class="lineno"> 2120 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2121 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;delete_concl&quot; &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal delete_concl)</span></span>
<span class="lineno"> 2123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Remove the numbered conclusions from the current sequent.&quot; ]</span></span>
<span class="lineno"> 2125 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2126 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;hoist_ifs_in_goal&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2127 </span><span class="spaces">    </span><span class="istickedoff">(pureVal hoistIfsInGoalPrim)</span>
<span class="lineno"> 2128 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Hoist ifs in the current proof goal.&quot; ]</span></span>
<span class="lineno"> 2130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2131 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_term&quot;      &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 2132 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 normalize_term)</span>
<span class="lineno"> 2133 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2134 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the given term by performing evaluation in SAWCore.&quot; ]</span></span>
<span class="lineno"> 2135 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2136 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;normalize_term_opaque&quot; &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 normalize_term_opaque)</span></span>
<span class="lineno"> 2138 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Normalize the given term by performing evaluation in SAWCore.&quot;</span></span>
<span class="lineno"> 2140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The named values will be treated opaquely and not unfolded during evaluation.&quot;</span></span>
<span class="lineno"> 2141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2142 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2143 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_normalize&quot;  &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2144 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_normalize)</span>
<span class="lineno"> 2145 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the current proof goal by performing evaluation in SAWCore.&quot;</span></span>
<span class="lineno"> 2147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The currently-focused term will be evaluated.  If the sequent is unfocused&quot;</span></span>
<span class="lineno"> 2148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;all terms will be evaluated. The given names will be treated as uninterpreted.&quot;</span></span>
<span class="lineno"> 2149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2150 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2151 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_eval&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2152 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (goal_eval []))</span>
<span class="lineno"> 2153 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the proof goal to a first-order combination of primitives.&quot; ]</span></span>
<span class="lineno"> 2155 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2156 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_eval_unint&quot;     &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_eval)</span></span>
<span class="lineno"> 2158 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the proof goal to a first-order combination of primitives.&quot;</span></span>
<span class="lineno"> 2160 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Leave the given names as uninterpreted.&quot; ]</span></span>
<span class="lineno"> 2161 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2162 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;beta_reduce_goal&quot;    &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal beta_reduce_goal)</span></span>
<span class="lineno"> 2164 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2165 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Reduce the current goal to beta-normal form.&quot; ]</span></span>
<span class="lineno"> 2166 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2167 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_apply&quot;          &quot;Theorem -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2168 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_apply)</span>
<span class="lineno"> 2169 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2170 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply an introduction rule to the current goal. Depending on the&quot;</span></span>
<span class="lineno"> 2171 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;rule, this will result in zero or more new subgoals.&quot;</span></span>
<span class="lineno"> 2172 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2173 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2174 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_exact&quot;          &quot;Term -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_exact)</span></span>
<span class="lineno"> 2176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal by giving an explicit proof term.&quot;</span></span>
<span class="lineno"> 2178 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This will succeed if the type of the given term matches the current goal.&quot;</span></span>
<span class="lineno"> 2179 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2180 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2181 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro_hyp&quot;      &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_intro_hyp)</span></span>
<span class="lineno"> 2183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion that represents an implication,&quot;</span></span>
<span class="lineno"> 2185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplify the conclusion by removing the implication and introducing&quot;</span></span>
<span class="lineno"> 2186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a new sequent hypothesis instead.&quot;</span></span>
<span class="lineno"> 2187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2188 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2189 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro_hyps&quot;     &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_intro_hyps)</span></span>
<span class="lineno"> 2191 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2192 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion that represents an implication,&quot;</span></span>
<span class="lineno"> 2193 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplify the conclusion by removing the implication and introducing&quot;</span></span>
<span class="lineno"> 2194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a new sequent hypothesis instead. The given number indicates how many&quot;</span></span>
<span class="lineno"> 2195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;hypotheses to introduce.&quot;</span></span>
<span class="lineno"> 2196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2197 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2198 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_revert_hyp&quot;     &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2199 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_revert_hyp)</span></span>
<span class="lineno"> 2200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When focused on a conclusion, weaken the focused conclusion&quot;</span></span>
<span class="lineno"> 2202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;by introducing an implication using the numbered sequent hypothesis.&quot;</span></span>
<span class="lineno"> 2203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This is essentially the reverse of 'gooal_intro_hyps'.&quot;</span></span>
<span class="lineno"> 2204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2205 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2206 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_insert&quot;         &quot;Theorem -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2207 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_insert)</span>
<span class="lineno"> 2208 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2209 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Insert a Theorem as a new hypothesis in the current proof goal.&quot;</span></span>
<span class="lineno"> 2210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2211 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2212 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_insert_and_specialize&quot;  &quot;Theorem -&gt; [Term] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_insert_and_specialize)</span></span>
<span class="lineno"> 2214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Insert a Theorem as a new hypothesis in the current proof goal, after&quot;</span></span>
<span class="lineno"> 2216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specializing some of its universal quantifiers using the given terms.&quot;</span></span>
<span class="lineno"> 2217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2218 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2219 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_apply_hyp&quot;      &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_apply_hyp)</span></span>
<span class="lineno"> 2221 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Apply the numbered local hypothesis to the focused conclusion.&quot; ]</span></span>
<span class="lineno"> 2223 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2224 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_specialize_hyp&quot; &quot;[Term] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2225 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_specialize_hyp)</span></span>
<span class="lineno"> 2226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specialize the focused local hypothesis by supplying the values&quot;</span></span>
<span class="lineno"> 2228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for universal quantifiers. A new specialized hypothesis will be&quot;</span></span>
<span class="lineno"> 2229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;added to the sequent.&quot;</span></span>
<span class="lineno"> 2230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2231 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2232 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_intro&quot;          &quot;String -&gt; ProofScript Term&quot;</span>
<span class="lineno"> 2233 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_intro)</span>
<span class="lineno"> 2234 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Introduce a quantified variable in the current proof goal, returning&quot;</span></span>
<span class="lineno"> 2236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the variable as a Term.&quot;</span></span>
<span class="lineno"> 2237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2238 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_when&quot;           &quot;String -&gt; ProofScript () -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_when)</span></span>
<span class="lineno"> 2240 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given proof script only when the goal name contains&quot;</span></span>
<span class="lineno"> 2242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given string.&quot;</span></span>
<span class="lineno"> 2243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2244 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_has_tags&quot;      &quot;[String] -&gt; ProofScript Bool&quot;</span>
<span class="lineno"> 2245 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_has_tags)</span>
<span class="lineno"> 2246 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true if the current goal is tagged with all the tags&quot;</span></span>
<span class="lineno"> 2248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the given list. This function returns true for all goals&quot;</span></span>
<span class="lineno"> 2249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when given an empty list. Tags may be added to goals using&quot;</span></span>
<span class="lineno"> 2250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_setup_with_tag' and similar operations in the specification&quot;</span></span>
<span class="lineno"> 2251 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;setup phase.&quot;</span></span>
<span class="lineno"> 2252 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2253 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_has_some_tag&quot;  &quot;[String] -&gt; ProofScript Bool&quot;</span>
<span class="lineno"> 2254 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_has_some_tag)</span></span>
<span class="lineno"> 2255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns true if the current goal is tagged with any the tags&quot;</span></span>
<span class="lineno"> 2257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the given list. This function returns false for all goals&quot;</span></span>
<span class="lineno"> 2258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;when given an empty list. Tags may be added to goals using&quot;</span></span>
<span class="lineno"> 2259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'llvm_setup_with_tag' and similar operations in the specification&quot;</span></span>
<span class="lineno"> 2260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;setup phase.&quot;</span></span>
<span class="lineno"> 2261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2262 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num_ite&quot;       &quot;{a} Int -&gt; ProofScript a -&gt; ProofScript a -&gt; ProofScript a&quot;</span>
<span class="lineno"> 2263 </span><span class="spaces">    </span><span class="istickedoff">(pureVal goal_num_ite)</span>
<span class="lineno"> 2264 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;If the goal number is the given number, runs the first script.&quot;</span></span>
<span class="lineno"> 2266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Otherwise runs the second script&quot; ]</span></span>
<span class="lineno"> 2267 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num_when&quot;       &quot;Int -&gt; ProofScript () -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2268 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_num_when)</span></span>
<span class="lineno"> 2269 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 2270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given proof script only when the goal number is the&quot;</span></span>
<span class="lineno"> 2271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given number.&quot;</span></span>
<span class="lineno"> 2272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2273 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2274 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_goal)</span>
<span class="lineno"> 2275 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2276 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to prove.&quot; ]</span></span>
<span class="lineno"> 2277 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_inline&quot;   &quot;[Int] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_goal_inline)</span></span>
<span class="lineno"> 2279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to prove,&quot;</span></span>
<span class="lineno"> 2281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;without generating `let` bindings for the provided indices. For&quot;</span></span>
<span class="lineno"> 2282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;example, `print_goal_inline [1,9,3]` will print the goal without&quot;</span></span>
<span class="lineno"> 2283 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;inlining the variables that would otherwise be abstracted as `x@1`,&quot;</span></span>
<span class="lineno"> 2284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; `x@9`, and `x@3`. These indices are assigned deterministically with&quot;</span></span>
<span class="lineno"> 2285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;regard to a particular goal, but are not persistent across goals. As&quot;</span></span>
<span class="lineno"> 2286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;such, this should be used primarily when debugging a proof.&quot;</span></span>
<span class="lineno"> 2287 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 2288 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note: incompatible with non-incremental memoization strategies - see&quot;</span></span>
<span class="lineno"> 2289 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`set_memoization_incremental` and `set_memoization_hash_incremental`.&quot;</span></span>
<span class="lineno"> 2290 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2291 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;write_goal&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal write_goal)</span></span>
<span class="lineno"> 2293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal that a proof script is attempting to prove&quot;</span></span>
<span class="lineno"> 2295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;into the named file.&quot;</span></span>
<span class="lineno"> 2296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2297 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_summary&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2298 </span><span class="spaces">    </span><span class="istickedoff">(pureVal print_goal_summary)</span>
<span class="lineno"> 2299 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the number and description of the goal that a proof script&quot;</span></span>
<span class="lineno"> 2301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;is attempting to prove.&quot;</span></span>
<span class="lineno"> 2302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2303 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_focus&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_focus)</span></span>
<span class="lineno"> 2305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print just the focused part of the current goal.&quot;</span></span>
<span class="lineno"> 2307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Prints a message without failing if there is no current focus.&quot;</span></span>
<span class="lineno"> 2308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2309 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2310 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;goal_num&quot; &quot;ProofScript Int&quot;</span>
<span class="lineno"> 2311 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal goal_num)</span></span>
<span class="lineno"> 2312 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2313 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Returns the number of the current proof goal.&quot;</span></span>
<span class="lineno"> 2314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2315 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_depth&quot;    &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2316 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal print_goal_depth)</span></span>
<span class="lineno"> 2317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2318 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the current goal that a proof script is attempting to prove,&quot;</span></span>
<span class="lineno"> 2319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;limited to a maximum depth.&quot;</span></span>
<span class="lineno"> 2320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2321 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_consts&quot;   &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2322 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal printGoalConsts)</span></span>
<span class="lineno"> 2323 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the list of unfoldable constants in the current proof goal.&quot;</span></span>
<span class="lineno"> 2325 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2326 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;print_goal_size&quot;     &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2327 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal printGoalSize)</span></span>
<span class="lineno"> 2328 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2329 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the size of the goal in terms of both the number of DAG nodes&quot;</span></span>
<span class="lineno"> 2330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and the number of nodes it would have if represented as a tree.&quot;</span></span>
<span class="lineno"> 2331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2332 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2333 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;assume_valid&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2334 </span><span class="spaces">    </span><span class="istickedoff">(pureVal assumeValid)</span>
<span class="lineno"> 2335 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume the current goal is valid, completing the proof.&quot;</span></span>
<span class="lineno"> 2337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Prefer to use 'admit', this command will eventually be removed.&quot;</span></span>
<span class="lineno"> 2338 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2340 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;assume_unsat&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2341 </span><span class="spaces">    </span><span class="istickedoff">(pureVal assumeUnsat)</span>
<span class="lineno"> 2342 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assume the current goal is unsatisfiable, completing the proof.&quot;</span></span>
<span class="lineno"> 2344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Prefer to use 'admit', this command will eventually be removed.&quot;</span></span>
<span class="lineno"> 2345 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2346 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2347 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;admit&quot;               &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2348 </span><span class="spaces">    </span><span class="istickedoff">(pureVal admitProof)</span>
<span class="lineno"> 2349 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Admit the current goal, completing the proof by assumption.&quot;</span></span>
<span class="lineno"> 2351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The string argument provides a description of why the user&quot;</span></span>
<span class="lineno"> 2352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;had decided to admit this goal.&quot;</span></span>
<span class="lineno"> 2353 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2354 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2355 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;quickcheck&quot;          &quot;Int -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2356 </span><span class="spaces">    </span><span class="istickedoff">(scVal quickcheckGoal)</span>
<span class="lineno"> 2357 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Quick Check the current goal by applying it to a sequence of random&quot;</span></span>
<span class="lineno"> 2359 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;inputs. Fail the proof script if the goal returns 'False' for any&quot;</span></span>
<span class="lineno"> 2360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of these inputs.&quot;</span></span>
<span class="lineno"> 2361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2362 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2363 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;abc&quot;                 &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2364 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_abc_aiger)</span>
<span class="lineno"> 2365 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2367 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2368 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_abc&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2369 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveABC_SBV)</span></span>
<span class="lineno"> 2370 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2371 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2372 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2373 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;bitwuzla&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2374 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBitwuzla)</span>
<span class="lineno"> 2375 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2376 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2377 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2378 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;boolector&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveBoolector)</span></span>
<span class="lineno"> 2380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Boolector theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2382 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2383 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cvc4&quot;                &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2384 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveCVC4)</span>
<span class="lineno"> 2385 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2386 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2387 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2388 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cvc5&quot;                &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC5)</span></span>
<span class="lineno"> 2390 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2391 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2392 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2393 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;z3&quot;                  &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2394 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveZ3)</span>
<span class="lineno"> 2395 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2397 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2398 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mathsat&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveMathSAT)</span></span>
<span class="lineno"> 2400 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2401 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the MathSAT theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2402 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2403 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yices&quot;               &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2404 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveYices)</span>
<span class="lineno"> 2405 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2406 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2407 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2408 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2409 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintBitwuzla)</span></span>
<span class="lineno"> 2410 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2414 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2415 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_z3&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2416 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintZ3)</span>
<span class="lineno"> 2417 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2419 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2420 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2421 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2422 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_cvc4&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC4)</span></span>
<span class="lineno"> 2424 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2425 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2426 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2427 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2428 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2429 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_cvc5&quot;            &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC5)</span></span>
<span class="lineno"> 2431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2432 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2433 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2434 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2435 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2436 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unint_yices&quot;           &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2437 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveUnintYices)</span>
<span class="lineno"> 2438 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2440 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2442 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2443 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_bitwuzla&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2444 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveBitwuzla)</span>
<span class="lineno"> 2445 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2446 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2447 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2448 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_boolector&quot;       &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2449 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveBoolector)</span></span>
<span class="lineno"> 2450 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Boolector theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2452 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2453 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_cvc4&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC4)</span></span>
<span class="lineno"> 2455 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2456 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2457 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2458 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_cvc5&quot;            &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2459 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveCVC5)</span></span>
<span class="lineno"> 2460 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2461 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2462 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2463 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_z3&quot;              &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2464 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveZ3)</span></span>
<span class="lineno"> 2465 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2466 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2467 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2468 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_mathsat&quot;         &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveMathSAT)</span></span>
<span class="lineno"> 2470 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2471 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the MathSAT theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2472 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2473 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_yices&quot;           &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2474 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveYices)</span></span>
<span class="lineno"> 2475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal.&quot; ]</span></span>
<span class="lineno"> 2477 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2478 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintBitwuzla)</span></span>
<span class="lineno"> 2480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Bitwuzla theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2482 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2483 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2484 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2485 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_z3&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2486 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintZ3)</span></span>
<span class="lineno"> 2487 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2488 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Z3 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2491 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2492 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_cvc4&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC4)</span></span>
<span class="lineno"> 2494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC4 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2496 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2498 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2499 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_cvc5&quot;        &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2500 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintCVC5)</span></span>
<span class="lineno"> 2501 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the CVC5 theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2504 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2505 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2506 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sbv_unint_yices&quot;       &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal proveUnintYices)</span></span>
<span class="lineno"> 2508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the Yices theorem prover to prove the current goal. Leave the&quot;</span></span>
<span class="lineno"> 2510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2512 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2513 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_aig&quot;         &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_aig)</span></span>
<span class="lineno"> 2515 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2516 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in AIGER format.&quot; ]</span></span>
<span class="lineno"> 2517 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2518 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_aig_external&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_aig_external)</span></span>
<span class="lineno"> 2520 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2521 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in AIGER format.&quot;</span></span>
<span class="lineno"> 2522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Uses ABC and an intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 2523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2524 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2525 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_cnf&quot;         &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2526 </span><span class="spaces">    </span><span class="istickedoff">(pureVal offline_cnf)</span>
<span class="lineno"> 2527 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in CNF format.&quot; ]</span></span>
<span class="lineno"> 2529 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2530 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_cnf_external&quot; &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2531 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_cnf_external)</span></span>
<span class="lineno"> 2532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2533 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in CNF format.&quot;</span></span>
<span class="lineno"> 2534 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Uses ABC and an intermediate Verilog file.&quot;</span></span>
<span class="lineno"> 2535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2536 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2537 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_extcore&quot;     &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_extcore)</span></span>
<span class="lineno"> 2539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2540 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SAWCore format.&quot; ]</span></span>
<span class="lineno"> 2541 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2542 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_smtlib2&quot;     &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2543 </span><span class="spaces">    </span><span class="istickedoff">(pureVal offline_smtlib2)</span>
<span class="lineno"> 2544 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2545 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format.&quot; ]</span></span>
<span class="lineno"> 2546 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2547 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_offline_smtlib2&quot;  &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_offline_smtlib2)</span></span>
<span class="lineno"> 2549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format.&quot; ]</span></span>
<span class="lineno"> 2551 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2552 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_unint_smtlib2&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_unint_smtlib2)</span></span>
<span class="lineno"> 2554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2555 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in SMT-Lib2 format,&quot;</span></span>
<span class="lineno"> 2556 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;leaving the listed functions uninterpreted.&quot;</span></span>
<span class="lineno"> 2557 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2558 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2559 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_verilog&quot;        &quot;String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2560 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_verilog)</span></span>
<span class="lineno"> 2561 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2562 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file in Verilog format.&quot; ]</span></span>
<span class="lineno"> 2563 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2564 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;external_cnf_solver&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (satExternal True))</span></span>
<span class="lineno"> 2566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use an external SAT solver supporting CNF to prove the current goal.&quot;</span></span>
<span class="lineno"> 2568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the executable name of the solver, and the&quot;</span></span>
<span class="lineno"> 2569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second is the list of arguments to pass to the solver. The string '%f'&quot;</span></span>
<span class="lineno"> 2570 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;anywhere in the argument list will be replaced with the name of the&quot;</span></span>
<span class="lineno"> 2571 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;temporary file holding the CNF version of the formula.&quot;]</span></span>
<span class="lineno"> 2572 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2573 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;external_aig_solver&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2574 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (satExternal False))</span></span>
<span class="lineno"> 2575 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2576 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use an external SAT solver supporting AIG to prove the current goal.&quot;</span></span>
<span class="lineno"> 2577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument is the executable name of the solver, and the&quot;</span></span>
<span class="lineno"> 2578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second is the list of arguments to pass to the solver. The string '%f'&quot;</span></span>
<span class="lineno"> 2579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;anywhere in the argument list will be replaced with the name of the&quot;</span></span>
<span class="lineno"> 2580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;temporary file holding the AIG version of the formula.&quot;]</span></span>
<span class="lineno"> 2581 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2582 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;rme&quot;                 &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2583 </span><span class="spaces">    </span><span class="istickedoff">(pureVal proveRME)</span>
<span class="lineno"> 2584 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal by expansion to Reed-Muller Normal Form.&quot; ]</span></span>
<span class="lineno"> 2586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2587 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;trivial&quot;             &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2588 </span><span class="spaces">    </span><span class="istickedoff">(pureVal trivial)</span>
<span class="lineno"> 2589 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Succeeds if the goal is trivial. This tactic recognizes goals&quot;</span></span>
<span class="lineno"> 2591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that are instances of reflexivity, possibly with quantified variables.&quot;</span></span>
<span class="lineno"> 2592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In particular, it will prove goals of the form 'EqTrue x' when 'x' reduces&quot;</span></span>
<span class="lineno"> 2593 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to the constant value 'True'.&quot;</span></span>
<span class="lineno"> 2594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2595 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2596 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4&quot;                  &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2597 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_z3)</span>
<span class="lineno"> 2598 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2599 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend).&quot; ]</span></span>
<span class="lineno"> 2600 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2601 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_bitwuzla&quot; &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2602 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_bitwuzla)</span>
<span class="lineno"> 2603 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2604 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Bitwuzla backend). Leave the&quot;</span></span>
<span class="lineno"> 2605 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2606 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2607 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2608 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_z3&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2609 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_z3)</span>
<span class="lineno"> 2610 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend). Leave the&quot;</span></span>
<span class="lineno"> 2612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2613 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2614 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2615 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_z3_using&quot; &quot;String -&gt; [String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2616 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_z3_using)</span>
<span class="lineno"> 2617 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2618 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Z3 backend) using the given&quot;</span></span>
<span class="lineno"> 2619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Z3 tactic. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2621 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2622 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_yices&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2623 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_yices)</span>
<span class="lineno"> 2624 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2625 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (Yices backend). Leave the&quot;</span></span>
<span class="lineno"> 2626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2627 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2628 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2629 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_cvc4&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_unint_cvc4)</span></span>
<span class="lineno"> 2631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (CVC4 backend). Leave the&quot;</span></span>
<span class="lineno"> 2633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2634 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2635 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2636 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_unint_cvc5&quot;         &quot;[String] -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2637 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_unint_cvc5)</span>
<span class="lineno"> 2638 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2639 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Prove the current goal using What4 (CVC5 backend). Leave the&quot;</span></span>
<span class="lineno"> 2640 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2642 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2643 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_aiger&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_abc_aiger)</span></span>
<span class="lineno"> 2645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 2647 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with AIGER as an interchange format, generated&quot;</span></span>
<span class="lineno"> 2648 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 2649 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2650 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2651 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_smtlib2&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2652 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal w4_abc_smtlib2)</span></span>
<span class="lineno"> 2653 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2654 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 2655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with SMT-Lib2 as an interchange format, generated&quot;</span></span>
<span class="lineno"> 2656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 2657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2658 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2659 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;w4_abc_verilog&quot;        &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2660 </span><span class="spaces">    </span><span class="istickedoff">(pureVal w4_abc_verilog)</span>
<span class="lineno"> 2661 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2662 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the ABC theorem prover as an external process to prove the&quot;</span></span>
<span class="lineno"> 2663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current goal, with Verilog as an interchange format, generated&quot;</span></span>
<span class="lineno"> 2664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;using the What4 backend.&quot;</span></span>
<span class="lineno"> 2665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2666 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2667 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_bitwuzla&quot; &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_w4_unint_bitwuzla)</span></span>
<span class="lineno"> 2669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Bitwuzla backend)&quot;</span></span>
<span class="lineno"> 2671 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; in SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2672 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2674 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_z3&quot;    &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2675 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_w4_unint_z3)</span></span>
<span class="lineno"> 2676 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2677 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Z3 backend) in&quot;</span></span>
<span class="lineno"> 2678 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2681 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_yices&quot; &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2682 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_w4_unint_yices)</span></span>
<span class="lineno"> 2683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (Yices backend) in&quot;</span></span>
<span class="lineno"> 2685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2687 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2688 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_cvc4&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2689 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_w4_unint_cvc4)</span></span>
<span class="lineno"> 2690 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2691 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (CVC4 backend) in&quot;</span></span>
<span class="lineno"> 2692 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2694 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2695 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;offline_w4_unint_cvc5&quot;  &quot;[String] -&gt; String -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 2696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal offline_w4_unint_cvc5)</span></span>
<span class="lineno"> 2697 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2698 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Write the current goal to the given file using What4 (CVC5 backend) in&quot;</span></span>
<span class="lineno"> 2699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot; SMT-Lib2 format. Leave the given list of names as uninterpreted.&quot;</span></span>
<span class="lineno"> 2700 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2702 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;split_goal&quot;          &quot;ProofScript ()&quot;</span>
<span class="lineno"> 2703 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal split_goal)</span></span>
<span class="lineno"> 2704 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Split a goal of the form 'Prelude.and prop1 prop2' into two separate&quot;</span></span>
<span class="lineno"> 2706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;goals 'prop1' and 'prop2'.&quot; ]</span></span>
<span class="lineno"> 2707 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2708 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;empty_ss&quot;            &quot;Simpset&quot;</span>
<span class="lineno"> 2709 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (emptySimpset :: SAWSimpset))</span>
<span class="lineno"> 2710 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The empty simplification rule set, containing no rules.&quot; ]</span></span>
<span class="lineno"> 2712 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2713 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_ss&quot;          &quot;() -&gt; Simpset&quot;</span>
<span class="lineno"> 2714 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 (\() -&gt; cryptolSimpset))</span>
<span class="lineno"> 2715 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A set of simplification rules that will expand definitions from the&quot;</span></span>
<span class="lineno"> 2717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol module.&quot;</span></span>
<span class="lineno"> 2718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2719 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2720 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_prelude_eqs&quot;     &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2721 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addPreludeEqs)</span>
<span class="lineno"> 2722 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2723 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named equality rules from the Prelude module to the given&quot;</span></span>
<span class="lineno"> 2724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 2725 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2726 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2727 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_cryptol_eqs&quot;     &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addCryptolEqs)</span></span>
<span class="lineno"> 2729 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named equality rules from the Cryptol module to the given&quot;</span></span>
<span class="lineno"> 2731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 2732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2733 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2734 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_prelude_defs&quot;    &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 add_prelude_defs)</span></span>
<span class="lineno"> 2736 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named definitions from the Prelude module to the given&quot;</span></span>
<span class="lineno"> 2738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 2739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2740 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2741 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_cryptol_defs&quot;    &quot;[String] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2742 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 add_cryptol_defs)</span>
<span class="lineno"> 2743 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add the named definitions from the Cryptol module to the given&quot;</span></span>
<span class="lineno"> 2745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;simplification rule set.&quot;</span></span>
<span class="lineno"> 2746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2747 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2748 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;basic_ss&quot;            &quot;Simpset&quot;</span>
<span class="lineno"> 2749 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal $ \bic _ -&gt; toValue $ biBasicSS bic)</span></span>
<span class="lineno"> 2750 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2751 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A basic rewriting simplification set containing some boolean identities&quot;</span></span>
<span class="lineno"> 2752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and conversions relating to bitvectors, natural numbers, and vectors.&quot;</span></span>
<span class="lineno"> 2753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2754 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2755 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp&quot;             &quot;Theorem -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2756 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addsimp)</span>
<span class="lineno"> 2757 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved equality theorem to a given simplification rule set.&quot; ]</span></span>
<span class="lineno"> 2759 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2760 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp_shallow&quot;    &quot;Theorem -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2761 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimp_shallow)</span></span>
<span class="lineno"> 2762 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved equality theorem to a given simplification rule set.&quot;</span></span>
<span class="lineno"> 2764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The rule is treated as a 'shallow' rewrite, which means that further&quot;</span></span>
<span class="lineno"> 2765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;rewrite rules will not be applied to the result if this rule fires.&quot;</span></span>
<span class="lineno"> 2766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2767 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2768 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimps&quot;            &quot;[Theorem] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2769 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 addsimps)</span>
<span class="lineno"> 2770 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add proved equality theorems to a given simplification rule set.&quot; ]</span></span>
<span class="lineno"> 2772 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2773 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimp'&quot;            &quot;Term -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimp')</span></span>
<span class="lineno"> 2775 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 2776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add an arbitrary equality term to a given simplification rule set.&quot;</span></span>
<span class="lineno"> 2777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use `admit` or `core_axiom` and `addsimp` instead.&quot;</span></span>
<span class="lineno"> 2778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2779 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2780 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addsimps'&quot;           &quot;[Term] -&gt; Simpset -&gt; Simpset&quot;</span>
<span class="lineno"> 2781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addsimps')</span></span>
<span class="lineno"> 2782 </span><span class="spaces">    </span><span class="istickedoff">HideDeprecated</span>
<span class="lineno"> 2783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add arbitrary equality terms to a given simplification rule set.&quot;</span></span>
<span class="lineno"> 2784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Use `admit` or `core_axiom` and `addsimps` instead.&quot;</span></span>
<span class="lineno"> 2785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2786 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2787 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;rewrite&quot;             &quot;Simpset -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2788 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 rewritePrim)</span>
<span class="lineno"> 2789 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Rewrite a term using a specific simplification rule set, returning&quot;</span></span>
<span class="lineno"> 2791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the rewritten term.&quot;</span></span>
<span class="lineno"> 2792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2793 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2794 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;unfold_term&quot;         &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2795 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 unfold_term)</span>
<span class="lineno"> 2796 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Unfold the definitions of the specified constants in the given term.&quot; ]</span></span>
<span class="lineno"> 2798 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2799 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;beta_reduce_term&quot;    &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 2800 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 beta_reduce_term)</span></span>
<span class="lineno"> 2801 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Reduce the given term to beta-normal form.&quot; ]</span></span>
<span class="lineno"> 2803 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2804 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_eval&quot;           &quot;Term -&gt; Term&quot;</span>
<span class="lineno"> 2805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (term_eval []))</span></span>
<span class="lineno"> 2806 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the term to a first-order combination of primitives.&quot; ]</span></span>
<span class="lineno"> 2808 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2809 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;term_eval_unint&quot;     &quot;[String] -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 2810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 term_eval)</span></span>
<span class="lineno"> 2811 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2812 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate the term to a first-order combination of primitives.&quot;</span></span>
<span class="lineno"> 2813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Leave the given names, as defined with 'define', as uninterpreted.&quot; ]</span></span>
<span class="lineno"> 2814 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2815 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_load&quot;        &quot;String -&gt; TopLevel CryptolModule&quot;</span>
<span class="lineno"> 2816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (cryptol_load BS.readFile))</span></span>
<span class="lineno"> 2817 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2818 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load the given file as a Cryptol module.&quot; ]</span></span>
<span class="lineno"> 2819 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2820 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_extract&quot;     &quot;CryptolModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 2821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CEnv.lookupCryptolModule)</span></span>
<span class="lineno"> 2822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a single definition from a Cryptol module and translate it into&quot;</span></span>
<span class="lineno"> 2824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a 'Term'.&quot;</span></span>
<span class="lineno"> 2825 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2826 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2827 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_prims&quot;       &quot;() -&gt; CryptolModule&quot;</span>
<span class="lineno"> 2828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 (\() -&gt; cryptol_prims))</span></span>
<span class="lineno"> 2829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a Cryptol module containing extra primitive operations,&quot;</span></span>
<span class="lineno"> 2831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;including array updates, truncate/extend, and signed comparisons.&quot;</span></span>
<span class="lineno"> 2832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2833 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2834 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_path&quot;    &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2835 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_path)</span></span>
<span class="lineno"> 2836 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2837 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a directory to the Cryptol search path. The Cryptol file loader&quot;</span></span>
<span class="lineno"> 2838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will look in this directory when following `import` statements in&quot;</span></span>
<span class="lineno"> 2839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Cryptol source files.&quot;</span></span>
<span class="lineno"> 2840 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2841 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2842 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_prim&quot;    &quot;String -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2843 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_prim)</span></span>
<span class="lineno"> 2844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;cryptol_add_prim mod nm trm sets the translation of Cryptol primitive&quot;</span></span>
<span class="lineno"> 2846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nm in module mod to trm&quot;</span></span>
<span class="lineno"> 2847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2848 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2849 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;cryptol_add_prim_type&quot;    &quot;String -&gt; String -&gt; Term -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 2850 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal cryptol_add_prim_type)</span></span>
<span class="lineno"> 2851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;cryptol_add_prim_type mod nm tp sets the translation of Cryptol&quot;</span></span>
<span class="lineno"> 2853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;primitive type nm in module mod to tp&quot;</span></span>
<span class="lineno"> 2854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2855 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2856 </span><span class="spaces">  </span><span class="istickedoff">-- Java stuff</span>
<span class="lineno"> 2857 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2858 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_bool&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 2859 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaBoolean)</span>
<span class="lineno"> 2860 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of booleans.&quot; ]</span></span>
<span class="lineno"> 2862 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2863 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_byte&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 2864 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaByte)</span>
<span class="lineno"> 2865 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of bytes.&quot; ]</span></span>
<span class="lineno"> 2867 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2868 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_char&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 2869 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaChar)</span>
<span class="lineno"> 2870 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of characters.&quot; ]</span></span>
<span class="lineno"> 2872 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2873 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_short&quot;          &quot;JavaType&quot;</span>
<span class="lineno"> 2874 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaShort)</span>
<span class="lineno"> 2875 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of short integers.&quot; ]</span></span>
<span class="lineno"> 2877 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2878 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_int&quot;            &quot;JavaType&quot;</span>
<span class="lineno"> 2879 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaInt)</span>
<span class="lineno"> 2880 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2881 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The standard Java integer type.&quot; ]</span></span>
<span class="lineno"> 2882 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2883 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_long&quot;           &quot;JavaType&quot;</span>
<span class="lineno"> 2884 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaLong)</span>
<span class="lineno"> 2885 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of long integers.&quot; ]</span></span>
<span class="lineno"> 2887 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2888 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_float&quot;          &quot;JavaType&quot;</span>
<span class="lineno"> 2889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaFloat)</span></span>
<span class="lineno"> 2890 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2891 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of single-precision floating point values.&quot; ]</span></span>
<span class="lineno"> 2892 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2893 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_double&quot;         &quot;JavaType&quot;</span>
<span class="lineno"> 2894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaDouble)</span></span>
<span class="lineno"> 2895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of double-precision floating point values.&quot; ]</span></span>
<span class="lineno"> 2897 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2898 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_array&quot;          &quot;Int -&gt; JavaType -&gt; JavaType&quot;</span>
<span class="lineno"> 2899 </span><span class="spaces">    </span><span class="istickedoff">(pureVal JavaArray)</span>
<span class="lineno"> 2900 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type of arrays of a fixed number of elements of the given&quot;</span></span>
<span class="lineno"> 2902 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type.&quot;</span></span>
<span class="lineno"> 2903 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2904 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2905 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_class&quot;          &quot;String -&gt; JavaType&quot;</span>
<span class="lineno"> 2906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal JavaClass)</span></span>
<span class="lineno"> 2907 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2908 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The Java type corresponding to the named class.&quot; ]</span></span>
<span class="lineno"> 2909 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2910 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;java_load_class&quot;     &quot;String -&gt; TopLevel JavaClass&quot;</span>
<span class="lineno"> 2911 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CJ.loadJavaClass)</span>
<span class="lineno"> 2912 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load the named Java class and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 2914 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2915 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_extract&quot;  &quot;JavaClass -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 2916 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CJ.jvm_extract)</span>
<span class="lineno"> 2917 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2918 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a Java method directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 2919 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term will be the parameters of the Java method, and the return&quot;</span></span>
<span class="lineno"> 2920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value will be the return value of the method. Only methods with&quot;</span></span>
<span class="lineno"> 2921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;scalar argument and return types are currently supported.&quot;</span></span>
<span class="lineno"> 2922 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2923 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_java_extract&quot;  &quot;JavaClass -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 2924 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CJ.jvm_extract)</span></span>
<span class="lineno"> 2925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `jvm_extract`.&quot;</span></span>
<span class="lineno"> 2927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2928 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2929 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_sizeof&quot;         &quot;LLVMModule -&gt; LLVMType -&gt; Int&quot;</span>
<span class="lineno"> 2930 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 llvm_sizeof)</span>
<span class="lineno"> 2931 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2932 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;In the context of the given LLVM module, compute the size of the&quot;</span></span>
<span class="lineno"> 2933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given LLVM type in bytes. The module determines details of struct&quot;</span></span>
<span class="lineno"> 2934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;layout and the meaning of type aliases.&quot; ]</span></span>
<span class="lineno"> 2935 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2936 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_type&quot;           &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 2937 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 llvm_type)</span>
<span class="lineno"> 2938 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2939 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse the given string as LLVM type syntax.&quot; ]</span></span>
<span class="lineno"> 2940 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2941 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_int&quot;            &quot;Int -&gt; LLVMType&quot;</span>
<span class="lineno"> 2942 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_int)</span>
<span class="lineno"> 2943 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2944 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of LLVM integers, of the given bit width.&quot; ]</span></span>
<span class="lineno"> 2945 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2946 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_float&quot;          &quot;LLVMType&quot;</span>
<span class="lineno"> 2947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_float)</span></span>
<span class="lineno"> 2948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2949 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of single-precision floating point numbers in LLVM.&quot; ]</span></span>
<span class="lineno"> 2950 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2951 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_double&quot;         &quot;LLVMType&quot;</span>
<span class="lineno"> 2952 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_double)</span></span>
<span class="lineno"> 2953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 2954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of double-precision floating point numbers in LLVM.&quot; ]</span></span>
<span class="lineno"> 2955 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2956 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array&quot;          &quot;Int -&gt; LLVMType -&gt; LLVMType&quot;</span>
<span class="lineno"> 2957 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_array)</span>
<span class="lineno"> 2958 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2959 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of LLVM arrays with the given number of elements of the&quot;</span></span>
<span class="lineno"> 2960 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type.&quot;</span></span>
<span class="lineno"> 2961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2962 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2963 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alias&quot;          &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 2964 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alias)</span>
<span class="lineno"> 2965 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM alias for the given name. Often times, this is used&quot;</span></span>
<span class="lineno"> 2967 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to alias a struct type.&quot;</span></span>
<span class="lineno"> 2968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2969 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct&quot;         &quot;String -&gt; LLVMType&quot;</span>
<span class="lineno"> 2970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alias)</span></span>
<span class="lineno"> 2971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">WarnDeprecated</span></span>
<span class="lineno"> 2972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alias`.&quot;</span></span>
<span class="lineno"> 2973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If you are trying to create a struct type from its contents, you want llvm_struct_type.&quot;</span></span>
<span class="lineno"> 2974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2975 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2976 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_pointer&quot;        &quot;LLVMType -&gt; LLVMType&quot;</span>
<span class="lineno"> 2977 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_pointer)</span>
<span class="lineno"> 2978 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM pointer that points to the given type.&quot;</span></span>
<span class="lineno"> 2980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2981 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2982 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_load_module&quot;    &quot;String -&gt; TopLevel LLVMModule&quot;</span>
<span class="lineno"> 2983 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_load_module)</span>
<span class="lineno"> 2984 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 2985 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load an LLVM bitcode file and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 2986 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2987 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;module_skeleton&quot; &quot;LLVMModule -&gt; TopLevel ModuleSkeleton&quot;</span>
<span class="lineno"> 2988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal module_skeleton)</span></span>
<span class="lineno"> 2989 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a handle to an LLVM module, return a skeleton for that module.&quot;</span></span>
<span class="lineno"> 2991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2992 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 2993 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;function_skeleton&quot; &quot;ModuleSkeleton -&gt; String -&gt; TopLevel FunctionSkeleton&quot;</span>
<span class="lineno"> 2994 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal function_skeleton)</span></span>
<span class="lineno"> 2995 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 2996 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a module skeleton and a function name, return the corresponding&quot;</span></span>
<span class="lineno"> 2997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function skeleton.&quot;</span></span>
<span class="lineno"> 2998 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 2999 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3000 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_resize_arg_index&quot; &quot;FunctionSkeleton -&gt; Int -&gt; Int -&gt; Bool -&gt; TopLevel FunctionSkeleton&quot;</span>
<span class="lineno"> 3001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_resize_arg_index)</span></span>
<span class="lineno"> 3002 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3003 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a function skeleton, argument index, array length, and whether or&quot;</span></span>
<span class="lineno"> 3004 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not that argument is initialized, return a new function skeleton where&quot;</span></span>
<span class="lineno"> 3005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the assumed length/initialization of the given argument is updated.&quot;</span></span>
<span class="lineno"> 3006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3007 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3008 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_resize_arg&quot; &quot;FunctionSkeleton -&gt; String -&gt; Int -&gt; Bool -&gt; TopLevel FunctionSkeleton&quot;</span>
<span class="lineno"> 3009 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_resize_arg)</span></span>
<span class="lineno"> 3010 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3011 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a function skeleton, argument name, array length, and whether or&quot;</span></span>
<span class="lineno"> 3012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;not that argument is initialized, return a new function skeleton where&quot;</span></span>
<span class="lineno"> 3013 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the assumed length/initialization of the given argument is updated.&quot;</span></span>
<span class="lineno"> 3014 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3015 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3016 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_guess_arg_sizes&quot; &quot;ModuleSkeleton -&gt; LLVMModule -&gt; [(String, [FunctionProfile])] -&gt; TopLevel ModuleSkeleton&quot;</span>
<span class="lineno"> 3017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_guess_arg_sizes)</span></span>
<span class="lineno"> 3018 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Update the sizes of all arguments of the given module skeleton using&quot;</span></span>
<span class="lineno"> 3020 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;information obtained from 'crucible_llvm_array_size_profile'.&quot;</span></span>
<span class="lineno"> 3021 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3022 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3023 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_globals_pre&quot; &quot;ModuleSkeleton -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_globals_pre)</span></span>
<span class="lineno"> 3025 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocate and initialize mutable globals from the given module skeleton.&quot;</span></span>
<span class="lineno"> 3027 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3028 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3029 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_globals_post&quot; &quot;ModuleSkeleton -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3030 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_globals_post)</span></span>
<span class="lineno"> 3031 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assert that all mutable globals from the given module skeleton are unchanged.&quot;</span></span>
<span class="lineno"> 3033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3034 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3035 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_prestate&quot; &quot;FunctionSkeleton -&gt; LLVMSetup SkeletonState&quot;</span>
<span class="lineno"> 3036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_prestate)</span></span>
<span class="lineno"> 3037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3038 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocate and initialize the arguments of the given function skeleton.&quot;</span></span>
<span class="lineno"> 3039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Return a 'SkeletonState' from which those arguments can be retrieved,&quot;</span></span>
<span class="lineno"> 3040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so that preconditions can be imposed.&quot;</span></span>
<span class="lineno"> 3041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3042 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3043 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_poststate&quot; &quot;FunctionSkeleton -&gt; SkeletonState -&gt; LLVMSetup SkeletonState&quot;</span>
<span class="lineno"> 3044 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_poststate)</span></span>
<span class="lineno"> 3045 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3046 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Assert that pointer arguments of the given function skeleton remain&quot;</span></span>
<span class="lineno"> 3047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialized. Return a 'SkeletonState' from which those arguments can&quot;</span></span>
<span class="lineno"> 3048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be retrieved, so that postconditions can be imposed.&quot;</span></span>
<span class="lineno"> 3049 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3050 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3051 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_index&quot; &quot;SkeletonState -&gt; Int -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 3052 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_index)</span></span>
<span class="lineno"> 3053 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument value at the given index from the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 3055 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3056 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3057 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg&quot; &quot;SkeletonState -&gt; String -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 3058 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg)</span></span>
<span class="lineno"> 3059 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument value of the given name from the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 3061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3062 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3063 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_index_pointer&quot; &quot;SkeletonState -&gt; Int -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3064 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_index_pointer)</span></span>
<span class="lineno"> 3065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument pointer at the given indexfrom the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 3067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fails if the specified argument is not a pointer.&quot;</span></span>
<span class="lineno"> 3068 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3069 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3070 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_arg_pointer&quot; &quot;SkeletonState -&gt; String -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_arg_pointer)</span></span>
<span class="lineno"> 3072 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Retrieve the argument pointer of the given name from the given 'SkeletonState'.&quot;</span></span>
<span class="lineno"> 3074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Fails if the specified argument is not a pointer.&quot;</span></span>
<span class="lineno"> 3075 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3076 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3077 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;skeleton_exec&quot; &quot;SkeletonState -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal skeleton_exec)</span></span>
<span class="lineno"> 3079 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3080 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Wrapper around 'crucible_execute_func' that passes the arguments initialized&quot;</span></span>
<span class="lineno"> 3081 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in 'skeleton_prestate'.&quot;</span></span>
<span class="lineno"> 3082 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3083 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3084 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_boilerplate&quot; &quot;String -&gt; ModuleSkeleton -&gt; Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_boilerplate)</span></span>
<span class="lineno"> 3086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate boilerplate for the definitions in the given LLVM module skeleton.&quot;</span></span>
<span class="lineno"> 3088 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Output is written to the path passed as the first argument.&quot;</span></span>
<span class="lineno"> 3089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third argument controls whether skeleton builtins are emitted.&quot;</span></span>
<span class="lineno"> 3090 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3091 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3092 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;caseSatResult&quot;       &quot;{b} SatResult -&gt; b -&gt; (Term -&gt; b) -&gt; b&quot;</span>
<span class="lineno"> 3093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValueCase caseSatResultPrim)</span></span>
<span class="lineno"> 3094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3095 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Branch on the result of SAT solving.&quot;</span></span>
<span class="lineno"> 3096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Usage: caseSatResult &lt;code to run if unsat&gt; &lt;code to run if sat&gt;.&quot;</span></span>
<span class="lineno"> 3098 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3099 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For example,&quot;</span></span>
<span class="lineno"> 3100 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3101 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  r &lt;- sat abc &lt;prop&gt;&quot;</span></span>
<span class="lineno"> 3102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  caseSatResult r &lt;unsat&gt; &lt;sat&gt;&quot;</span></span>
<span class="lineno"> 3103 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will run '&lt;unsat&gt;' if '&lt;prop&gt;' is unSAT and will run '&lt;sat&gt; &lt;example&gt;'&quot;</span></span>
<span class="lineno"> 3105 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if '&lt;prop&gt;' is SAT, where '&lt;example&gt;' is a satisfying assignment.&quot;</span></span>
<span class="lineno"> 3106 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If '&lt;prop&gt;' is a curried function, then '&lt;example&gt;' will be a tuple.&quot;</span></span>
<span class="lineno"> 3107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If we could not determine the satisfiability of '&lt;prop&gt;', then&quot;</span></span>
<span class="lineno"> 3108 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this will run '&lt;sat&gt; {{ () }}'.&quot;</span></span>
<span class="lineno"> 3109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3110 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3111 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;caseProofResult&quot;     &quot;{b} ProofResult -&gt; (Theorem -&gt; b) -&gt; (Term -&gt; b) -&gt; b&quot;</span>
<span class="lineno"> 3112 </span><span class="spaces">    </span><span class="istickedoff">(\_ _ -&gt; toValueCase caseProofResultPrim)</span>
<span class="lineno"> 3113 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Branch on the result of proving.&quot;</span></span>
<span class="lineno"> 3115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3116 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Usage: caseProofResult &lt;result&gt; &lt;code to run if true&gt; &lt;code to run if false&gt;.&quot;</span></span>
<span class="lineno"> 3117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For example,&quot;</span></span>
<span class="lineno"> 3119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3120 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  r &lt;- prove abc &lt;prop&gt;&quot;</span></span>
<span class="lineno"> 3121 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  caseProofResult r &lt;true&gt; &lt;false&gt;&quot;</span></span>
<span class="lineno"> 3122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will run '&lt;true&gt; &lt;thm&gt;' if '&lt;prop&gt;' is proved (where '&lt;thm&gt;' represents&quot;</span></span>
<span class="lineno"> 3124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the proved theorem) and will run '&lt;false&gt; &lt;example&gt;'&quot;</span></span>
<span class="lineno"> 3125 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if '&lt;prop&gt;' is false, where '&lt;example&gt;' is a counter example.&quot;</span></span>
<span class="lineno"> 3126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If '&lt;prop&gt;' is a curried function, then '&lt;example&gt;' will be a tuple.&quot;</span></span>
<span class="lineno"> 3127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;If the proof of &lt;prop&gt; was not finished, but we did not find a counterexample,&quot;</span></span>
<span class="lineno"> 3128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the example will run '&lt;false&gt; {{ () }}'&quot;</span></span>
<span class="lineno"> 3129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3130 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3131 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;undefined&quot;           &quot;{a} a&quot;</span>
<span class="lineno"> 3132 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; error &quot;interpret: undefined&quot;)</span></span>
<span class="lineno"> 3133 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3134 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An undefined value of any type. Evaluating 'undefined' makes the&quot;</span></span>
<span class="lineno"> 3135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;program crash.&quot;</span></span>
<span class="lineno"> 3136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3137 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3138 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;exit&quot;                &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3139 </span><span class="spaces">    </span><span class="istickedoff">(pureVal exitPrim)</span>
<span class="lineno"> 3140 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Exit SAWScript, returning the supplied exit code to the parent&quot;</span></span>
<span class="lineno"> 3142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;process.&quot;</span></span>
<span class="lineno"> 3143 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3144 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3145 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fail&quot; &quot;{a} String -&gt; TopLevel a&quot;</span>
<span class="lineno"> 3146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue failPrim)</span></span>
<span class="lineno"> 3147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Throw an exception in the top level monad.&quot; ]</span></span>
<span class="lineno"> 3149 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3150 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;fails&quot;               &quot;{a} TopLevel a -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3151 </span><span class="spaces">    </span><span class="istickedoff">(\_ _ -&gt; toValue failsPrim)</span>
<span class="lineno"> 3152 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3153 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given inner action and convert failure into success.  Fail&quot;</span></span>
<span class="lineno"> 3154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;if the inner action does NOT raise an exception. This is primarily used&quot;</span></span>
<span class="lineno"> 3155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for unit testing purposes, to ensure that we can elicit expected&quot;</span></span>
<span class="lineno"> 3156 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;failing behaviors.&quot;</span></span>
<span class="lineno"> 3157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3158 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3159 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;time&quot;                &quot;{a} TopLevel a -&gt; TopLevel a&quot;</span>
<span class="lineno"> 3160 </span><span class="spaces">    </span><span class="istickedoff">(\_ _ -&gt; toValue timePrim)</span>
<span class="lineno"> 3161 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3162 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the CPU time used by the given TopLevel command.&quot; ]</span></span>
<span class="lineno"> 3163 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3164 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;with_time&quot;           &quot;{a} TopLevel a -&gt; TopLevel (Int, a)&quot;</span>
<span class="lineno"> 3165 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue withTimePrim)</span></span>
<span class="lineno"> 3166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Run the given toplevel command.  Return the number of milliseconds&quot;</span></span>
<span class="lineno"> 3168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;elapsed during the execution of the command and its result.&quot;</span></span>
<span class="lineno"> 3169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3170 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3171 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;exec&quot;               &quot;String -&gt; [String] -&gt; String -&gt; TopLevel String&quot;</span>
<span class="lineno"> 3172 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue readProcess)</span></span>
<span class="lineno"> 3173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Execute an external process with the given executable&quot;</span></span>
<span class="lineno"> 3175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name, arguments, and standard input. Returns standard&quot;</span></span>
<span class="lineno"> 3176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;output.&quot;</span></span>
<span class="lineno"> 3177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3178 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3179 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_bool&quot;           &quot;Term -&gt; Bool&quot;</span>
<span class="lineno"> 3180 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_bool)</span>
<span class="lineno"> 3181 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type Bit to either 'true' or 'false'.&quot;</span></span>
<span class="lineno"> 3183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3184 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3185 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_int&quot;           &quot;Term -&gt; Int&quot;</span>
<span class="lineno"> 3186 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_int)</span>
<span class="lineno"> 3187 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type [n] and convert to a SAWScript Int.&quot;</span></span>
<span class="lineno"> 3189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3190 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3191 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_size&quot;          &quot;Type -&gt; Int&quot;</span>
<span class="lineno"> 3192 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_size)</span>
<span class="lineno"> 3193 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3194 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert a Cryptol size type to a SAWScript Int.&quot;</span></span>
<span class="lineno"> 3195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3196 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3197 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;eval_list&quot;           &quot;Term -&gt; [Term]&quot;</span>
<span class="lineno"> 3198 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 eval_list)</span>
<span class="lineno"> 3199 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Evaluate a Cryptol term of type [n]a to a list of terms.&quot;</span></span>
<span class="lineno"> 3201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3202 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3203 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;list_term&quot;           &quot;[Term] -&gt; Term&quot;</span>
<span class="lineno"> 3204 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 list_term)</span>
<span class="lineno"> 3205 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3206 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Make a Cryptol term of type [n]a from a list of terms of type a.&quot;</span></span>
<span class="lineno"> 3207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Function list_term is the inverse of function eval_list.&quot;</span></span>
<span class="lineno"> 3208 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3209 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3210 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parse_core&quot;         &quot;String -&gt; Term&quot;</span>
<span class="lineno"> 3211 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 parse_core)</span>
<span class="lineno"> 3212 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Term from a String in SAWCore syntax.&quot;</span></span>
<span class="lineno"> 3214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3215 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3216 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;parse_core_mod&quot;      &quot;String -&gt; String -&gt; Term&quot;</span>
<span class="lineno"> 3217 </span><span class="spaces">    </span><span class="istickedoff">(funVal2 parse_core_mod)</span>
<span class="lineno"> 3218 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Term from the second supplied String in SAWCore syntax,&quot;</span></span>
<span class="lineno"> 3220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;relative to the module specified by the first String&quot;</span></span>
<span class="lineno"> 3221 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3222 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3223 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;prove_core&quot;         &quot;ProofScript () -&gt; String -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3224 </span><span class="spaces">    </span><span class="istickedoff">(pureVal prove_core)</span>
<span class="lineno"> 3225 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the given proof script to attempt to prove that a term is valid&quot;</span></span>
<span class="lineno"> 3227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(true for all inputs). The term is specified as a String containing&quot;</span></span>
<span class="lineno"> 3228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;saw-core syntax. Returns a Theorem if successful, and aborts if&quot;</span></span>
<span class="lineno"> 3229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;unsuccessful.&quot;</span></span>
<span class="lineno"> 3230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3231 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3232 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;core_axiom&quot;         &quot;String -&gt; Theorem&quot;</span>
<span class="lineno"> 3233 </span><span class="spaces">    </span><span class="istickedoff">(funVal1 core_axiom)</span>
<span class="lineno"> 3234 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare the given core expression as an axiomatic rewrite rule.&quot;</span></span>
<span class="lineno"> 3236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The input string contains a proof goal in saw-core syntax. The&quot;</span></span>
<span class="lineno"> 3237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;return value is a Theorem that may be added to a Simpset.&quot;</span></span>
<span class="lineno"> 3238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3239 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3240 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;core_thm&quot;           &quot;String -&gt; Theorem&quot;</span>
<span class="lineno"> 3241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 core_thm)</span></span>
<span class="lineno"> 3242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a theorem from the type of the given core expression.&quot; ]</span></span>
<span class="lineno"> 3244 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3245 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;specialize_theorem&quot; &quot;Theorem -&gt; [Term] -&gt; TopLevel Theorem&quot;</span>
<span class="lineno"> 3246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal specialize_theorem)</span></span>
<span class="lineno"> 3247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3248 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specialize a theorem by instantiating universal quantifiers&quot;</span></span>
<span class="lineno"> 3249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the given list of terms.&quot;</span></span>
<span class="lineno"> 3250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3251 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3252 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;get_opt&quot;            &quot;Int -&gt; String&quot;</span>
<span class="lineno"> 3253 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal1 get_opt)</span></span>
<span class="lineno"> 3254 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3255 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Get the nth command-line argument as a String. Index 0 returns&quot;</span></span>
<span class="lineno"> 3256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the program name; other parameters are numbered starting at 1.&quot;</span></span>
<span class="lineno"> 3257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3258 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3259 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;show_cfg&quot;          &quot;CFG -&gt; String&quot;</span>
<span class="lineno"> 3260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal show_cfg)</span></span>
<span class="lineno"> 3261 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3262 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Pretty-print a control-flow graph.&quot;</span></span>
<span class="lineno"> 3263 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3264 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3265 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 3266 </span><span class="spaces">    </span><span class="istickedoff">-- Crucible/LLVM interface</span>
<span class="lineno"> 3267 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3268 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_cfg&quot;     &quot;LLVMModule -&gt; String -&gt; TopLevel CFG&quot;</span>
<span class="lineno"> 3269 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_cfg)</span></span>
<span class="lineno"> 3270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a function from the given LLVM module into a Crucible CFG.&quot;</span></span>
<span class="lineno"> 3272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3273 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3274 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_extract&quot;  &quot;LLVMModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3275 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_extract)</span>
<span class="lineno"> 3276 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 3278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term will be the parameters of the LLVM function, and the return&quot;</span></span>
<span class="lineno"> 3279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value will be the return value of the functions. Only functions with&quot;</span></span>
<span class="lineno"> 3280 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;scalar argument and return types are currently supported. For more&quot;</span></span>
<span class="lineno"> 3281 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;flexibility, see 'llvm_verify'.&quot;</span></span>
<span class="lineno"> 3282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3283 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_extract&quot;  &quot;LLVMModule -&gt; String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 3284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_extract)</span></span>
<span class="lineno"> 3285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_extract`.&quot; ]</span></span>
<span class="lineno"> 3287 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3288 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_compositional_extract&quot;</span>
<span class="lineno"> 3289 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3290 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_compositional_extract)</span>
<span class="lineno"> 3291 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3292 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function directly to a Term. The parameters of the&quot;</span></span>
<span class="lineno"> 3293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Term are the input parameters of the LLVM function: the parameters&quot;</span></span>
<span class="lineno"> 3294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed by value (in the order given by `llvm_exec_func`), then&quot;</span></span>
<span class="lineno"> 3295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the parameters passed by reference (in the order given by&quot;</span></span>
<span class="lineno"> 3296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`llvm_points_to`). The Term is the tuple consisting of the&quot;</span></span>
<span class="lineno"> 3297 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;output parameters of the LLVM function: the return parameter, then&quot;</span></span>
<span class="lineno"> 3298 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the parameters passed by reference (in the order given by&quot;</span></span>
<span class="lineno"> 3299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`llvm_points_to`).&quot;</span></span>
<span class="lineno"> 3300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3301 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;When invoking `llvm_compositional_extract mod fn_name term_name ovs&quot;</span></span>
<span class="lineno"> 3302 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;check_path_sat spec strat`, the arguments represent the following:&quot;</span></span>
<span class="lineno"> 3303 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  1. `mod`: The LLVM module containing the function to extract.&quot;</span></span>
<span class="lineno"> 3304 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  2. `fn_name`: The name of the function to extract.&quot;</span></span>
<span class="lineno"> 3305 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  3. `term_name`: The name of the `Term` to generate.&quot;</span></span>
<span class="lineno"> 3306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  4. `ovs`: A list of overrides to use in the proof that the extracted&quot;</span></span>
<span class="lineno"> 3307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     function satisifies `spec`.&quot;</span></span>
<span class="lineno"> 3308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  5. `check_path_sat`: Whether to perform path satisfiability checks.&quot;</span></span>
<span class="lineno"> 3309 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  6. `spec`: SAW specification for the extracted function.&quot;</span></span>
<span class="lineno"> 3310 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;  7. `strat`: Proof strategy to use when verifying that the extracted&quot;</span></span>
<span class="lineno"> 3311 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;     function satisfies `spec`.&quot;</span></span>
<span class="lineno"> 3312 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3313 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For more flexibility, see `llvm_verify`.&quot;</span></span>
<span class="lineno"> 3314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3315 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_compositional_extract&quot;</span>
<span class="lineno"> 3316 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3317 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_compositional_extract)</span></span>
<span class="lineno"> 3318 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3319 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_compositional_extract`.&quot; ]</span></span>
<span class="lineno"> 3320 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3321 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_var&quot; &quot;String -&gt; LLVMType -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 3322 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_var)</span>
<span class="lineno"> 3323 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3324 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable for use within an LLVM&quot;</span></span>
<span class="lineno"> 3325 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification. The name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 3326 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3327 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_var&quot; &quot;String -&gt; LLVMType -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 3328 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_var)</span>
<span class="lineno"> 3329 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_var`.&quot; ]</span></span>
<span class="lineno"> 3331 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3332 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 3333 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_cryptol_var)</span>
<span class="lineno"> 3334 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given Cryptol type for use&quot;</span></span>
<span class="lineno"> 3336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;within a Crucible specification. The given name is used only for&quot;</span></span>
<span class="lineno"> 3337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pretty-printing. Unlike 'llvm_fresh_var', this can be used when&quot;</span></span>
<span class="lineno"> 3338 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;there isn't an appropriate LLVM type, such as the Cryptol Array type.&quot;</span></span>
<span class="lineno"> 3339 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3340 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; LLVMSetup Term&quot;</span>
<span class="lineno"> 3341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_cryptol_var)</span></span>
<span class="lineno"> 3342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_cryptol_var`.&quot; ]</span></span>
<span class="lineno"> 3344 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3345 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3346 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc)</span>
<span class="lineno"> 3347 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an object of the given type should be allocated in an&quot;</span></span>
<span class="lineno"> 3349 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM specification. Before `llvm_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 3350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 3351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `llvm_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 3352 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 3353 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3354 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3355 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc)</span></span>
<span class="lineno"> 3356 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc`.&quot; ]</span></span>
<span class="lineno"> 3358 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3359 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3360 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_aligned)</span></span>
<span class="lineno"> 3361 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3362 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a memory region of the given type should be allocated in&quot;</span></span>
<span class="lineno"> 3363 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an LLVM specification, and also specify that the start of the region&quot;</span></span>
<span class="lineno"> 3364 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should be aligned to a multiple of the specified number of bytes (which&quot;</span></span>
<span class="lineno"> 3365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must be a power of 2).&quot;</span></span>
<span class="lineno"> 3366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3367 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3368 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_aligned)</span></span>
<span class="lineno"> 3369 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3370 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_aligned`.&quot; ]</span></span>
<span class="lineno"> 3371 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3372 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_readonly&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3373 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_readonly)</span>
<span class="lineno"> 3374 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a read-only memory region of the given type should be&quot;</span></span>
<span class="lineno"> 3376 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in an LLVM specification. The function must not attempt&quot;</span></span>
<span class="lineno"> 3377 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to write to this memory region. Unlike `llvm_alloc`, regions&quot;</span></span>
<span class="lineno"> 3378 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated with `llvm_alloc_readonly` are allowed to alias other&quot;</span></span>
<span class="lineno"> 3379 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;read-only regions.&quot;</span></span>
<span class="lineno"> 3380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3381 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_readonly&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3382 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly)</span></span>
<span class="lineno"> 3383 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3384 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_readonly`.&quot; ]</span></span>
<span class="lineno"> 3385 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3386 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_readonly_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3387 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly_aligned)</span></span>
<span class="lineno"> 3388 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a read-only memory region of the given type should be&quot;</span></span>
<span class="lineno"> 3390 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in an LLVM specification, and also specify that the start of&quot;</span></span>
<span class="lineno"> 3391 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the region should be aligned to a multiple of the specified number of&quot;</span></span>
<span class="lineno"> 3392 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;bytes (which must be a power of 2). The function must not attempt to&quot;</span></span>
<span class="lineno"> 3393 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;write to this memory region. Unlike `llvm_alloc`/`llvm_alloc_aligned`,&quot;</span></span>
<span class="lineno"> 3394 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;regions allocated with `llvm_alloc_readonly_aligned` are allowed to&quot;</span></span>
<span class="lineno"> 3395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;alias other read-only regions.&quot;</span></span>
<span class="lineno"> 3396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3397 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_readonly_aligned&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_readonly_aligned)</span></span>
<span class="lineno"> 3399 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3400 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_readonly_aligned`.&quot; ]</span></span>
<span class="lineno"> 3401 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3402 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_with_size&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3403 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_with_size)</span>
<span class="lineno"> 3404 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3405 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like `llvm_alloc`, but with a user-specified size (given in bytes).&quot;</span></span>
<span class="lineno"> 3406 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The specified size must be greater than the size of the LLVM type.&quot;</span></span>
<span class="lineno"> 3407 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3408 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_with_size&quot; &quot;Int -&gt; LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3409 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_with_size)</span></span>
<span class="lineno"> 3410 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_with_size`.&quot; ]</span></span>
<span class="lineno"> 3412 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3413 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_sym_init&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3414 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_sym_init)</span>
<span class="lineno"> 3415 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3416 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like `llvm_alloc`, but assume that the allocation is initialized with&quot;</span></span>
<span class="lineno"> 3417 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;symbolic bytes.&quot;</span></span>
<span class="lineno"> 3418 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3419 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3420 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_symbolic_alloc&quot; &quot;Bool -&gt; Int -&gt; Term -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3421 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_symbolic_alloc)</span>
<span class="lineno"> 3422 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like `llvm_alloc`, but with a (symbolic) size instead of an LLVM type.&quot;</span></span>
<span class="lineno"> 3424 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument specifies whether the allocation is read-only. The&quot;</span></span>
<span class="lineno"> 3425 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;second argument specifies the alignment in bytes (which must be a power&quot;</span></span>
<span class="lineno"> 3426 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of 2). The third argument specifies the size in bytes.&quot;</span></span>
<span class="lineno"> 3427 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3428 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_symbolic_alloc&quot; &quot;Bool -&gt; Int -&gt; Term -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3429 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_symbolic_alloc)</span></span>
<span class="lineno"> 3430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3431 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_symbolic_alloc`.&quot; ]</span></span>
<span class="lineno"> 3432 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3433 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_alloc_global&quot; &quot;String -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3434 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_alloc_global)</span>
<span class="lineno"> 3435 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3436 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that memory for the named global should be allocated in an&quot;</span></span>
<span class="lineno"> 3437 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM specification. This is done implicitly for immutable globals.&quot;</span></span>
<span class="lineno"> 3438 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;A pointer to the allocated memory may be obtained using `llvm_global`.&quot;</span></span>
<span class="lineno"> 3439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3440 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_alloc_global&quot; &quot;String -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_alloc_global)</span></span>
<span class="lineno"> 3442 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_alloc_global`.&quot; ]</span></span>
<span class="lineno"> 3444 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3445 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_pointer&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3446 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_pointer)</span>
<span class="lineno"> 3447 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh pointer value for use in an LLVM specification.&quot;</span></span>
<span class="lineno"> 3449 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This works like `llvm_alloc` except that the pointer is not&quot;</span></span>
<span class="lineno"> 3450 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;required to point to allocated memory.&quot;</span></span>
<span class="lineno"> 3451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3452 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_pointer&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3453 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_pointer)</span></span>
<span class="lineno"> 3454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3455 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_pointer`.&quot; ]</span></span>
<span class="lineno"> 3456 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3457 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_fresh_expanded_val&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3458 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_fresh_expanded_val)</span>
<span class="lineno"> 3459 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3460 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a compound type entirely populated with fresh symbolic variables.&quot;</span></span>
<span class="lineno"> 3461 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Equivalent to allocating a new struct or array of the given type and&quot;</span></span>
<span class="lineno"> 3462 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;explicitly setting each field or element to contain a fresh symbolic&quot;</span></span>
<span class="lineno"> 3463 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variable.&quot;</span></span>
<span class="lineno"> 3464 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3465 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_fresh_expanded_val&quot; &quot;LLVMType -&gt; LLVMSetup SetupValue&quot;</span>
<span class="lineno"> 3466 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_fresh_expanded_val)</span></span>
<span class="lineno"> 3467 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3468 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_fresh_expanded_val`.&quot; ]</span></span>
<span class="lineno"> 3469 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3470 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3471 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to True))</span>
<span class="lineno"> 3472 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3473 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer (first&quot;</span></span>
<span class="lineno"> 3474 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the given value (second argument).&quot;</span></span>
<span class="lineno"> 3475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `llvm_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 3477 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 3478 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 3479 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 3480 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3481 </span><span class="spaces">    </span><span class="istickedoff">, prim &quot;crucible_points_to&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3482 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_points_to True))</span></span>
<span class="lineno"> 3483 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_points_to`.&quot; ]</span></span>
<span class="lineno"> 3485 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3486 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3487 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_conditional_points_to True))</span>
<span class="lineno"> 3488 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer (second&quot;</span></span>
<span class="lineno"> 3490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the given value (third argument) if the given&quot;</span></span>
<span class="lineno"> 3491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;condition (first argument) holds.&quot;</span></span>
<span class="lineno"> 3492 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `llvm_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 3494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 3495 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 3496 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 3497 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3498 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_conditional_points_to&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3499 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to True))</span></span>
<span class="lineno"> 3500 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3501 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_conditional_points_to`.&quot; ]</span></span>
<span class="lineno"> 3502 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3503 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_at_type&quot; &quot;SetupValue -&gt; LLVMType -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3504 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_points_to_at_type)</span>
<span class="lineno"> 3505 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3506 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_points_to` that casts the pointer to another type.&quot;</span></span>
<span class="lineno"> 3507 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This may be useful when reading or writing a prefix of larger array,&quot;</span></span>
<span class="lineno"> 3508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for example.&quot;</span></span>
<span class="lineno"> 3509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3510 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3511 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to_at_type&quot; &quot;Term -&gt; SetupValue -&gt; LLVMType -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_conditional_points_to_at_type)</span></span>
<span class="lineno"> 3513 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_conditional_points_to` that casts the pointer to&quot;</span></span>
<span class="lineno"> 3515 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;another type. This may be useful when reading or writing a prefix&quot;</span></span>
<span class="lineno"> 3516 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of larger array, for example.&quot;</span></span>
<span class="lineno"> 3517 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3518 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3519 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_untyped&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3520 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to False))</span>
<span class="lineno"> 3521 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_points_to` that does not check for compatibility&quot;</span></span>
<span class="lineno"> 3523 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;between the pointer type and the value type. This may be useful when&quot;</span></span>
<span class="lineno"> 3524 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;reading or writing a prefix of larger array, for example.&quot;</span></span>
<span class="lineno"> 3525 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3526 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_points_to_untyped&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3527 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_points_to False))</span></span>
<span class="lineno"> 3528 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3529 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_points_to`.&quot; ]</span></span>
<span class="lineno"> 3530 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3531 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_conditional_points_to_untyped&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3532 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to False))</span></span>
<span class="lineno"> 3533 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3534 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_conditional_points_to` that does not check for&quot;</span></span>
<span class="lineno"> 3535 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;compatibility between the pointer type and the value type. This may&quot;</span></span>
<span class="lineno"> 3536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be useful when reading or writing a prefix of larger array, for example.&quot;</span></span>
<span class="lineno"> 3537 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3538 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_conditional_points_to_untyped&quot; &quot;Term -&gt; SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3539 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (llvm_conditional_points_to False))</span></span>
<span class="lineno"> 3540 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3541 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_conditional_points_to`.&quot; ]</span></span>
<span class="lineno"> 3542 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3543 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_array_prefix&quot; &quot;SetupValue -&gt; Term -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3544 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_points_to_array_prefix)</span>
<span class="lineno"> 3545 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3546 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given pointer (first&quot;</span></span>
<span class="lineno"> 3547 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the prefix of the given array (second argument) of&quot;</span></span>
<span class="lineno"> 3548 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given size (third argument).&quot;</span></span>
<span class="lineno"> 3549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `llvm_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 3551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 3552 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 3553 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 3554 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3555 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_points_to_array_prefix&quot; &quot;SetupValue -&gt; Term -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3556 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_points_to_array_prefix)</span></span>
<span class="lineno"> 3557 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_points_to_array_prefix`.&quot; ]</span></span>
<span class="lineno"> 3559 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3560 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_points_to_bitfield&quot; &quot;SetupValue -&gt; String -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3561 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (llvm_points_to_bitfield))</span>
<span class="lineno"> 3562 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3563 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A variant of `llvm_points_to` that is meant to be used on struct fields&quot;</span></span>
<span class="lineno"> 3564 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that reside within bitfields. `llvm_points_to_bitfield ptr fieldName rhs`&quot;</span></span>
<span class="lineno"> 3565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;should be used instead of `llvm_points_to (llvm_field ptr fieldName) rhs`,&quot;</span></span>
<span class="lineno"> 3566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the latter will not behave as one would expect for technical reasons.&quot;</span></span>
<span class="lineno"> 3567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command should only be used in combination with&quot;</span></span>
<span class="lineno"> 3569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`enable_lax_loads_and_stores`, as this option relaxes some assumptions&quot;</span></span>
<span class="lineno"> 3570 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the memory model that are crucial to how `llvm_points_to_bitfield`&quot;</span></span>
<span class="lineno"> 3571 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;operates.&quot;</span></span>
<span class="lineno"> 3572 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3573 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3574 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_equal&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3575 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_equal)</span>
<span class="lineno"> 3576 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two LLVM values should be equal. Can be used as either a&quot;</span></span>
<span class="lineno"> 3578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-condition or a post-condition. It is semantically equivalent to&quot;</span></span>
<span class="lineno"> 3579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an `llvm_precond` or `llvm_postcond` statement which is an equality&quot;</span></span>
<span class="lineno"> 3580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 3581 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3582 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_equal&quot; &quot;SetupValue -&gt; SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3583 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_equal)</span></span>
<span class="lineno"> 3584 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_equal`.&quot; ]</span></span>
<span class="lineno"> 3586 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3587 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_precond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3588 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_precond)</span>
<span class="lineno"> 3589 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3590 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on execution of the&quot;</span></span>
<span class="lineno"> 3591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified.&quot;</span></span>
<span class="lineno"> 3592 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3593 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_precond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3594 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_precond)</span>
<span class="lineno"> 3595 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_precond`.&quot; ]</span></span>
<span class="lineno"> 3597 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3598 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_assert&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3599 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_assert)</span>
<span class="lineno"> 3600 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as `llvm_precond`&quot;</span></span>
<span class="lineno"> 3602 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or `llvm_postcond` depending on the phase of specification in which&quot;</span></span>
<span class="lineno"> 3603 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it appears (i.e., before or after `llvm_execute_func`).&quot;</span></span>
<span class="lineno"> 3604 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3605 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3606 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_setup_with_tag&quot; &quot;String -&gt; LLVMSetup () -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3607 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_setup_with_tag)</span>
<span class="lineno"> 3608 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3609 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All conditions (e.g., from points-to or assert statements) executed&quot;</span></span>
<span class="lineno"> 3610 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the scope of the given setup block will have the provieded string&quot;</span></span>
<span class="lineno"> 3611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;attached as a tag that can later be filtered by proof tactics.&quot;</span></span>
<span class="lineno"> 3612 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3613 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3614 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_postcond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3615 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_postcond)</span>
<span class="lineno"> 3616 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3617 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of execution of the&quot;</span></span>
<span class="lineno"> 3618 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function being verified.&quot;</span></span>
<span class="lineno"> 3619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3620 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_postcond&quot; &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3621 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_postcond)</span>
<span class="lineno"> 3622 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3623 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_postcond`.&quot; ]</span></span>
<span class="lineno"> 3624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3625 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_execute_func&quot; &quot;[SetupValue] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3626 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_execute_func)</span>
<span class="lineno"> 3627 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3628 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the function.&quot;</span></span>
<span class="lineno"> 3629 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 3630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The `llvm_execute_func` statement also serves to separate the pre-state&quot;</span></span>
<span class="lineno"> 3631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section of the spec (before `llvm_execute_func`) from the post-state&quot;</span></span>
<span class="lineno"> 3632 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `llvm_execute_func`). The effects of some LLVMSetup&quot;</span></span>
<span class="lineno"> 3633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 3634 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 3635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3636 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_execute_func&quot; &quot;[SetupValue] -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3637 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_execute_func)</span></span>
<span class="lineno"> 3638 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3639 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_execute_func`.&quot; ]</span></span>
<span class="lineno"> 3640 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3641 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_return&quot; &quot;SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3642 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_return)</span>
<span class="lineno"> 3643 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3644 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the function. A&quot;</span></span>
<span class="lineno"> 3645 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;crucible_return statement is required if and only if the function&quot;</span></span>
<span class="lineno"> 3646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-void return type.&quot; ]</span></span>
<span class="lineno"> 3647 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_return&quot; &quot;SetupValue -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 3648 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_return)</span>
<span class="lineno"> 3649 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3650 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_return`.&quot; ]</span></span>
<span class="lineno"> 3651 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3652 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_cast_pointer&quot; &quot;SetupValue -&gt; LLVMType -&gt; SetupValue&quot;</span>
<span class="lineno"> 3653 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_cast_pointer)</span>
<span class="lineno"> 3654 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3655 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Cast the type of the given setup value (which must be a pointer value).&quot;</span></span>
<span class="lineno"> 3656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting setup value will be a pointer to the same location, treated&quot;</span></span>
<span class="lineno"> 3657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as a pointer to the provided type.&quot;</span></span>
<span class="lineno"> 3658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3659 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3660 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify&quot;</span>
<span class="lineno"> 3661 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3662 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_verify)</span>
<span class="lineno"> 3663 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the LLVM function named by the second parameter in the module&quot;</span></span>
<span class="lineno"> 3665 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the LLVMSpec&quot;</span></span>
<span class="lineno"> 3666 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values returned by previous calls to use as overrides. The fourth (Bool)&quot;</span></span>
<span class="lineno"> 3667 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameter enables or disables path satisfiability checking. The fifth&quot;</span></span>
<span class="lineno"> 3668 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;describes how to set up the symbolic execution engine before verification.&quot;</span></span>
<span class="lineno"> 3669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;And the last gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 3670 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 3671 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3672 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_verify&quot;</span>
<span class="lineno"> 3673 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3674 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify)</span></span>
<span class="lineno"> 3675 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3676 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_verify`.&quot; ]</span></span>
<span class="lineno"> 3677 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3678 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_refine_spec&quot;</span>
<span class="lineno"> 3679 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3680 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_refine_spec)</span>
<span class="lineno"> 3681 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3682 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify that a given specification for a function is a refinement of one or more&quot;</span></span>
<span class="lineno"> 3683 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications already proved for a function. This can be useful for situations where&quot;</span></span>
<span class="lineno"> 3684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it is advantageous to logically restate the specification in some why, or where a more&quot;</span></span>
<span class="lineno"> 3685 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;general specification can be constructed from a collection of individual, more specific,&quot;</span></span>
<span class="lineno"> 3686 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifications.&quot;</span></span>
<span class="lineno"> 3687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3688 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3689 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 3690 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; LLVMSetup () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3691 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_unsafe_assume_spec)</span>
<span class="lineno"> 3692 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return an LLVMSpec corresponding to an LLVMSetup block,&quot;</span></span>
<span class="lineno"> 3694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as would be returned by crucible_llvm_verify but without performing&quot;</span></span>
<span class="lineno"> 3695 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;any verification.&quot;</span></span>
<span class="lineno"> 3696 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3697 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 3698 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; LLVMSetup () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_unsafe_assume_spec)</span></span>
<span class="lineno"> 3700 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3701 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_unsafe_assume_spec`.&quot; ]</span></span>
<span class="lineno"> 3702 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3703 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array_size_profile&quot;</span>
<span class="lineno"> 3704 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; LLVMSetup () -&gt; TopLevel [(String, [FunctionProfile])]&quot;</span>
<span class="lineno"> 3705 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal $ llvm_array_size_profile assumeUnsat)</span></span>
<span class="lineno"> 3706 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Symbolically execute the function named by the second parameter in&quot;</span></span>
<span class="lineno"> 3708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the module specified by the first. The fourth parameter may be used&quot;</span></span>
<span class="lineno"> 3709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to specify arguments. Returns profiles specifying the sizes of buffers&quot;</span></span>
<span class="lineno"> 3710 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;referred to by pointer arguments for the function and all other functions&quot;</span></span>
<span class="lineno"> 3711 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it calls (recursively), to be passed to llvm_boilerplate.&quot;</span></span>
<span class="lineno"> 3712 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3713 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_array_size_profile&quot;</span>
<span class="lineno"> 3714 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; [LLVMSpec] -&gt; LLVMSetup () -&gt; TopLevel [(String, [FunctionProfile])]&quot;</span>
<span class="lineno"> 3715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal $ llvm_array_size_profile assumeUnsat)</span></span>
<span class="lineno"> 3716 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_array_size_profile`.&quot; ]</span></span>
<span class="lineno"> 3718 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3719 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_x86&quot;</span>
<span class="lineno"> 3720 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3721 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_verify_x86)</span>
<span class="lineno"> 3722 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3723 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify an x86 function from an ELF file for use as an override in an&quot;</span></span>
<span class="lineno"> 3724 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;LLVM verification. The first argument specifies the LLVM module&quot;</span></span>
<span class="lineno"> 3725 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;containing the _caller_. The second and third specify the ELF file&quot;</span></span>
<span class="lineno"> 3726 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name and symbol name of the function to be verifier. The fourth&quot;</span></span>
<span class="lineno"> 3727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specifies the names and sizes (in bytes) of global variables to&quot;</span></span>
<span class="lineno"> 3728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;initialize, and the fifth whether to perform path satisfiability&quot;</span></span>
<span class="lineno"> 3729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;checking. The last argument is the LLVM specification of the calling&quot;</span></span>
<span class="lineno"> 3730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;context against which to verify the function. Returns a method spec&quot;</span></span>
<span class="lineno"> 3731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that can be used as an override when verifying other LLVM functions.&quot;</span></span>
<span class="lineno"> 3732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3733 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_llvm_verify_x86&quot;</span>
<span class="lineno"> 3734 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3735 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify_x86)</span></span>
<span class="lineno"> 3736 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3737 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_verify_x86`.&quot; ]</span></span>
<span class="lineno"> 3738 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3739 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_fixpoint_x86&quot;</span>
<span class="lineno"> 3740 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; Term -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify_fixpoint_x86)</span></span>
<span class="lineno"> 3742 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3743 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can prove some properties&quot;</span></span>
<span class="lineno"> 3744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;involving simple loops with the help of a user-provided term that describes how&quot;</span></span>
<span class="lineno"> 3745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the live variables in the loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 3746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3747 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3748 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_fixpoint_chc_x86&quot;</span>
<span class="lineno"> 3749 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; Term -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3750 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify_fixpoint_chc_x86)</span></span>
<span class="lineno"> 3751 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental variant of 'llvm_verify_x86'. This variant can prove some properties&quot;</span></span>
<span class="lineno"> 3753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;involving simple loops with the help of a user-provided term that describes how&quot;</span></span>
<span class="lineno"> 3754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the live variables in the loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 3755 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This differs from 'llvm_verify_fixpoint_x86' in that it leverages Z3's&quot;</span></span>
<span class="lineno"> 3757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;constrained horn-clause (CHC) functionality to synthesize some of the&quot;</span></span>
<span class="lineno"> 3758 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;loop's properties.&quot;</span></span>
<span class="lineno"> 3759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3760 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3761 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_verify_x86_with_invariant&quot;</span>
<span class="lineno"> 3762 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; [(String, Int)] -&gt; Bool -&gt; (String, Int, Term) -&gt; LLVMSetup () -&gt; ProofScript () -&gt; TopLevel LLVMSpec&quot;</span>
<span class="lineno"> 3763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_verify_x86_with_invariant)</span></span>
<span class="lineno"> 3764 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3765 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;An experimental extension of 'llvm_verify_x86'. This extension can prove some properties&quot;</span></span>
<span class="lineno"> 3766 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;involving simple loops with the help of a user-provided loop invariant that describes&quot;</span></span>
<span class="lineno"> 3767 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;how the live variables in the loop evolve as the loop computes.&quot;</span></span>
<span class="lineno"> 3768 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The loop invariant is provided by the tuple argument, which indicates what symbol the loop&quot;</span></span>
<span class="lineno"> 3770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;appears in (which might differ from the function the specification is for), which loop within&quot;</span></span>
<span class="lineno"> 3771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;that function to reason about (starts counting from 0), and a term that desribes the loop invariant&quot;</span></span>
<span class="lineno"> 3772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;itself. For this verification command to succeed, the loop in question must have a single entry-point,&quot;</span></span>
<span class="lineno"> 3773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;must have a single back-edge, and must have a constant memory footprint.&quot;</span></span>
<span class="lineno"> 3774 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3775 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The SAWCore type expected of the loop invariant will depend on the results of an analysis done&quot;</span></span>
<span class="lineno"> 3776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;on the indicated loop, which will attempt to discover what are all the loop-carried dependencies.&quot;</span></span>
<span class="lineno"> 3777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The result of this analysis will be packaged into a tuple, and any relevant top-level specification&quot;</span></span>
<span class="lineno"> 3778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;variables will be found. The expected type of the loop invariant will then be a function over all&quot;</span></span>
<span class="lineno"> 3779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the implicit variables found, and two tuples consisting of the initial values of the loop-carried&quot;</span></span>
<span class="lineno"> 3780 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;dependencies, and the current value of the loop-carried dependencies. The function should return Bool.&quot;</span></span>
<span class="lineno"> 3781 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Some trial-and-error will generally be required to match the results of the analysis with a sutiable&quot;</span></span>
<span class="lineno"> 3782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;function.&quot;</span></span>
<span class="lineno"> 3783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;As part of the verification process, the loop invariant will be used in several ways. First, a proof&quot;</span></span>
<span class="lineno"> 3785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;obligation will be issued upon first entry to the loop, establishing the loop invariant holds at the&quot;</span></span>
<span class="lineno"> 3786 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;beginning of the loop. Second, the loop invariant is used when starting execution from the loop head&quot;</span></span>
<span class="lineno"> 3787 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;to make a generic assumption that the invariant holds. Finally, the invariant is used when execution&quot;</span></span>
<span class="lineno"> 3788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;once again reaches the loop head to assert that the invariant holds inductively across the execution&quot;</span></span>
<span class="lineno"> 3789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of the loop body. The produced proof obligations will be tagged with either the tag&quot;</span></span>
<span class="lineno"> 3790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'initial loop invariant' or 'inductive loop invariant'.&quot;</span></span>
<span class="lineno"> 3791 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 3792 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Provided all the generated verification conditions are discharged, this results in a partial&quot;</span></span>
<span class="lineno"> 3793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;correctness proof for the indicated function. Note that termination is not proved via this procedure.&quot;</span></span>
<span class="lineno"> 3794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3795 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3796 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_x86_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3797 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_x86_what4_hash_consing)</span></span>
<span class="lineno"> 3798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3799 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable hash consing for What4 expressions during x86 verification.&quot; ]</span></span>
<span class="lineno"> 3800 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3801 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_x86_what4_hash_consing&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3802 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_x86_what4_hash_consing)</span></span>
<span class="lineno"> 3803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable hash consing for What4 expressions during x86 verification.&quot; ]</span></span>
<span class="lineno"> 3805 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3806 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;add_x86_preserved_reg&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3807 </span><span class="spaces">    </span><span class="istickedoff">(pureVal add_x86_preserved_reg)</span>
<span class="lineno"> 3808 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3809 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Treat the given register as callee-saved during x86 verification.&quot; ]</span></span>
<span class="lineno"> 3810 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3811 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_x86_preserved_reg&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3812 </span><span class="spaces">    </span><span class="istickedoff">(pureVal default_x86_preserved_reg)</span>
<span class="lineno"> 3813 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the default set of callee-saved registers during x86 verification.&quot; ]</span></span>
<span class="lineno"> 3815 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3816 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_eval&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3817 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_what4_eval)</span>
<span class="lineno"> 3818 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3819 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable What4 translation for SAWCore expressions during Crucible symbolic execution.&quot; ]</span></span>
<span class="lineno"> 3820 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3821 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_eval&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_eval)</span></span>
<span class="lineno"> 3823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable What4 translation for SAWCore expressions during Crucible symbolic execution.&quot; ]</span></span>
<span class="lineno"> 3825 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3826 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_x86_stack_base_align&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3827 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_x86_stack_base_align)</span></span>
<span class="lineno"> 3828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the alignment of the stack allocation base to 2^n during x86 verification.&quot; ]</span></span>
<span class="lineno"> 3830 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3831 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;default_x86_stack_base_align&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal default_x86_stack_base_align)</span></span>
<span class="lineno"> 3833 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3834 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the default stack allocation base alignment during x86 verification.&quot; ]</span></span>
<span class="lineno"> 3835 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3836 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_alloc_sym_init_check&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3837 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_alloc_sym_init_check)</span>
<span class="lineno"> 3838 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 3839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Enable the allocation initialization check associated with alloc_sym_init during override application.&quot; ]</span></span>
<span class="lineno"> 3840 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3841 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_alloc_sym_init_check&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3842 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_alloc_sym_init_check)</span>
<span class="lineno"> 3843 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Disable the allocation initialization check associated with alloc_sym_init during override application.&quot;</span></span>
<span class="lineno"> 3845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Disabling this check allows an override to apply when the memory region specified by the alloc_sym_init command&quot;</span></span>
<span class="lineno"> 3846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the override specification is not written to in the calling context.&quot;</span></span>
<span class="lineno"> 3847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This makes the implicit assumption that there is some unspecified byte at any valid memory address.&quot;</span></span>
<span class="lineno"> 3848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3849 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3850 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_no_satisfying_write_fresh_constant&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3851 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_no_satisfying_write_fresh_constant)</span></span>
<span class="lineno"> 3852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When simulating LLVM code that performs an invalid write, make a fresh&quot;</span></span>
<span class="lineno"> 3854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;constant as a proof obligation. This constant will always fail, but it&quot;</span></span>
<span class="lineno"> 3855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;will also not be constant-folded away.&quot;</span></span>
<span class="lineno"> 3856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3857 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3858 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_no_satisfying_write_fresh_constant&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3859 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_no_satisfying_write_fresh_constant)</span></span>
<span class="lineno"> 3860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;When simulating LLVM code that performs an invalid write, return 'false'&quot;</span></span>
<span class="lineno"> 3862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as a proof obligation.&quot;</span></span>
<span class="lineno"> 3863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3864 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3865 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_what4_push_mux_ops&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal enable_what4_push_mux_ops)</span></span>
<span class="lineno"> 3867 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3868 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Push certain What4 operations (e.g., 'zext') down to the branches of&quot;</span></span>
<span class="lineno"> 3869 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;'ite' expressions as much as possible. In some (but not all) circumstances,&quot;</span></span>
<span class="lineno"> 3870 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;this can result in operations that are easier for SMT solvers to reason&quot;</span></span>
<span class="lineno"> 3871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about.&quot;</span></span>
<span class="lineno"> 3872 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3873 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3874 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_what4_push_mux_ops&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 3875 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal disable_what4_push_mux_ops)</span></span>
<span class="lineno"> 3876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Do not push certain What4 operations (e.g., 'zext') down to the branches&quot;</span></span>
<span class="lineno"> 3878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of 'ite' expressions as much as possible.&quot;</span></span>
<span class="lineno"> 3879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3880 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3881 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_crucible_timeout&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 3882 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal set_crucible_timeout)</span></span>
<span class="lineno"> 3883 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 3884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the timeout for the SMT solver during the LLVM and X86 Crucible symbolic execution,&quot;</span></span>
<span class="lineno"> 3885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot;in milliseconds (0 is no timeout). The default is 10000ms (10s).&quot;</span></span>
<span class="lineno"> 3886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,&quot;This is used for path-sat checks, and sat checks when applying overrides.&quot;</span></span>
<span class="lineno"> 3887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3888 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3889 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_array_value&quot;</span>
<span class="lineno"> 3890 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 3891 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupArray)</span>
<span class="lineno"> 3892 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing an array, with the given list of&quot;</span></span>
<span class="lineno"> 3894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements. The list must be non-empty.&quot; ]</span></span>
<span class="lineno"> 3895 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_array&quot;</span>
<span class="lineno"> 3896 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 3897 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupArray)</span></span>
<span class="lineno"> 3898 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3899 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_array_value`.&quot; ]</span></span>
<span class="lineno"> 3900 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3901 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct_type&quot;</span>
<span class="lineno"> 3902 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMType] -&gt; LLVMType&quot;</span>
<span class="lineno"> 3903 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_struct_type)</span>
<span class="lineno"> 3904 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of an LLVM struct with elements of the given types.&quot; ]</span></span>
<span class="lineno"> 3906 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3907 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_struct_value&quot;</span>
<span class="lineno"> 3908 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 3909 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CIR.anySetupStruct False))</span>
<span class="lineno"> 3910 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a struct, with the given list of&quot;</span></span>
<span class="lineno"> 3912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements.&quot; ]</span></span>
<span class="lineno"> 3913 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_struct&quot;</span>
<span class="lineno"> 3914 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 3915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (CIR.anySetupStruct False))</span></span>
<span class="lineno"> 3916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3917 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_struct_value`.&quot; ]</span></span>
<span class="lineno"> 3918 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3919 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_packed_struct_type&quot;</span>
<span class="lineno"> 3920 </span><span class="spaces">    </span><span class="istickedoff">&quot;[LLVMType] -&gt; LLVMType&quot;</span>
<span class="lineno"> 3921 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_packed_struct_type)</span>
<span class="lineno"> 3922 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3923 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of a packed LLVM struct with elements of the given types.&quot; ]</span></span>
<span class="lineno"> 3924 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3925 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_packed_struct_value&quot;</span>
<span class="lineno"> 3926 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 3927 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CIR.anySetupStruct True))</span>
<span class="lineno"> 3928 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3929 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a packed struct, with the given&quot;</span></span>
<span class="lineno"> 3930 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;list of values as elements.&quot; ]</span></span>
<span class="lineno"> 3931 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_packed_struct&quot;</span>
<span class="lineno"> 3932 </span><span class="spaces">    </span><span class="istickedoff">&quot;[SetupValue] -&gt; SetupValue&quot;</span>
<span class="lineno"> 3933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (CIR.anySetupStruct True))</span></span>
<span class="lineno"> 3934 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_packed_struct_value`.&quot; ]</span></span>
<span class="lineno"> 3936 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3937 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_elem&quot;</span>
<span class="lineno"> 3938 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; Int -&gt; SetupValue&quot;</span>
<span class="lineno"> 3939 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupElem)</span>
<span class="lineno"> 3940 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3941 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn a SetupValue representing a struct or array pointer into&quot;</span></span>
<span class="lineno"> 3942 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to an element of the struct or array by field index.&quot; ]</span></span>
<span class="lineno"> 3943 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_elem&quot;</span>
<span class="lineno"> 3944 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; Int -&gt; SetupValue&quot;</span>
<span class="lineno"> 3945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupElem)</span></span>
<span class="lineno"> 3946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_elem`.&quot; ]</span></span>
<span class="lineno"> 3948 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3949 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_union&quot;</span>
<span class="lineno"> 3950 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; String -&gt; SetupValue&quot;</span>
<span class="lineno"> 3951 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupUnion)</span>
<span class="lineno"> 3952 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3953 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn a SetupValue representing a union pointer into&quot;</span></span>
<span class="lineno"> 3954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to one of the branches of the union by field name.&quot;</span></span>
<span class="lineno"> 3955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Requires debug symbols to resolve union field names.&quot;</span></span>
<span class="lineno"> 3956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3957 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3958 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_field&quot;</span>
<span class="lineno"> 3959 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; String -&gt; SetupValue&quot;</span>
<span class="lineno"> 3960 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupField)</span>
<span class="lineno"> 3961 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3962 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Turn a SetupValue representing a struct pointer into&quot;</span></span>
<span class="lineno"> 3963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a pointer to an element of the struct by field name.&quot;</span></span>
<span class="lineno"> 3964 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Requires debug symbols to resolve struct field names.&quot;</span></span>
<span class="lineno"> 3965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 3966 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_field&quot;</span>
<span class="lineno"> 3967 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue -&gt; String -&gt; SetupValue&quot;</span>
<span class="lineno"> 3968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupField)</span></span>
<span class="lineno"> 3969 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_field`.&quot; ]</span></span>
<span class="lineno"> 3971 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3972 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_null&quot;</span>
<span class="lineno"> 3973 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue&quot;</span>
<span class="lineno"> 3974 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupNull)</span>
<span class="lineno"> 3975 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3976 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A SetupValue representing a null pointer value.&quot; ]</span></span>
<span class="lineno"> 3977 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_null&quot;</span>
<span class="lineno"> 3978 </span><span class="spaces">    </span><span class="istickedoff">&quot;SetupValue&quot;</span>
<span class="lineno"> 3979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupNull)</span></span>
<span class="lineno"> 3980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_null`.&quot; ]</span></span>
<span class="lineno"> 3982 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3983 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_global&quot;</span>
<span class="lineno"> 3984 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 3985 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupGlobal)</span>
<span class="lineno"> 3986 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a SetupValue representing a pointer to the named global.&quot;</span></span>
<span class="lineno"> 3988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The String may be either the name of a global value or a function name.&quot; ]</span></span>
<span class="lineno"> 3989 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_global&quot;</span>
<span class="lineno"> 3990 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 3991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupGlobal)</span></span>
<span class="lineno"> 3992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 3993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_global`.&quot; ]</span></span>
<span class="lineno"> 3994 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 3995 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_global_initializer&quot;</span>
<span class="lineno"> 3996 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 3997 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupGlobalInitializer)</span>
<span class="lineno"> 3998 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 3999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a SetupValue representing the value of the initializer of a named&quot;</span></span>
<span class="lineno"> 4000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;global. The String should be the name of a global value.&quot;</span></span>
<span class="lineno"> 4001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4002 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_global_initializer&quot;</span>
<span class="lineno"> 4003 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; SetupValue&quot;</span>
<span class="lineno"> 4004 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal CIR.anySetupGlobalInitializer)</span></span>
<span class="lineno"> 4005 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4006 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_global_initializer`.&quot; ]</span></span>
<span class="lineno"> 4007 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4008 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_term&quot;</span>
<span class="lineno"> 4009 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; SetupValue&quot;</span>
<span class="lineno"> 4010 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupTerm)</span>
<span class="lineno"> 4011 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a `SetupValue` from a `Term`.&quot; ]</span></span>
<span class="lineno"> 4013 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_term&quot;</span>
<span class="lineno"> 4014 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; SetupValue&quot;</span>
<span class="lineno"> 4015 </span><span class="spaces">    </span><span class="istickedoff">(pureVal CIR.anySetupTerm)</span>
<span class="lineno"> 4016 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4017 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_term`.&quot; ]</span></span>
<span class="lineno"> 4018 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4019 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_setup_val_to_term&quot;</span>
<span class="lineno"> 4020 </span><span class="spaces">    </span><span class="istickedoff">&quot; SetupValue -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4021 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal crucible_setup_val_to_typed_term)</span></span>
<span class="lineno"> 4022 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">HideDeprecated</span></span>
<span class="lineno"> 4023 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Convert from a setup value to a typed term. This can only be done for a&quot;</span></span>
<span class="lineno"> 4024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;subset of setup values. Fails if a setup value is a global, variable or null.&quot;</span></span>
<span class="lineno"> 4025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4026 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4027 </span><span class="spaces">  </span><span class="istickedoff">-- Ghost state support</span>
<span class="lineno"> 4028 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;declare_ghost_state&quot;</span>
<span class="lineno"> 4029 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 4030 </span><span class="spaces">    </span><span class="istickedoff">(pureVal declare_ghost_state)</span>
<span class="lineno"> 4031 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Allocates a unique ghost variable.&quot; ]</span></span>
<span class="lineno"> 4033 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_declare_ghost_state&quot;</span>
<span class="lineno"> 4034 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 4035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal declare_ghost_state)</span></span>
<span class="lineno"> 4036 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4037 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `declare_ghost_state`.&quot; ]</span></span>
<span class="lineno"> 4038 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_declare_ghost_state&quot;</span>
<span class="lineno"> 4039 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel Ghost&quot;</span>
<span class="lineno"> 4040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal declare_ghost_state)</span></span>
<span class="lineno"> 4041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 4042 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `declare_ghost_state`.&quot; ]</span></span>
<span class="lineno"> 4043 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4044 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_ghost_value&quot;</span>
<span class="lineno"> 4045 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4046 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_ghost_value)</span>
<span class="lineno"> 4047 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 4049 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;]</span></span>
<span class="lineno"> 4050 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_ghost_value&quot;</span>
<span class="lineno"> 4051 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4052 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal llvm_ghost_value)</span></span>
<span class="lineno"> 4053 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4054 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_ghost_value`.&quot;]</span></span>
<span class="lineno"> 4055 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4056 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_ghost_value&quot;</span>
<span class="lineno"> 4057 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4058 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_ghost_value)</span></span>
<span class="lineno"> 4059 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 4061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;]</span></span>
<span class="lineno"> 4062 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4063 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ghost_value&quot;</span>
<span class="lineno"> 4064 </span><span class="spaces">    </span><span class="istickedoff">&quot;Ghost -&gt; Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4065 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ghost_value)</span>
<span class="lineno"> 4066 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specifies the value of a ghost variable. This can be used&quot;</span></span>
<span class="lineno"> 4068 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the pre- and post- conditions of a setup block.&quot;]</span></span>
<span class="lineno"> 4069 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4070 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_spec_solvers&quot;  &quot;LLVMSpec -&gt; [String]&quot;</span>
<span class="lineno"> 4071 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue llvm_spec_solvers)</span></span>
<span class="lineno"> 4072 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extract a list of all the solvers used when verifying the given method spec.&quot;</span></span>
<span class="lineno"> 4074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4075 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_spec_solvers&quot;  &quot;LLVMSpec -&gt; [String]&quot;</span>
<span class="lineno"> 4076 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue llvm_spec_solvers)</span></span>
<span class="lineno"> 4077 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_spec_solvers`.&quot; ]</span></span>
<span class="lineno"> 4079 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4080 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_spec_size&quot;  &quot;LLVMSpec -&gt; Int&quot;</span>
<span class="lineno"> 4081 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue llvm_spec_size)</span></span>
<span class="lineno"> 4082 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4083 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a count of the combined size of all verification goals proved as part of&quot;</span></span>
<span class="lineno"> 4084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given method spec.&quot;</span></span>
<span class="lineno"> 4085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4086 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;crucible_spec_size&quot;  &quot;LLVMSpec -&gt; Int&quot;</span>
<span class="lineno"> 4087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(\_ _ -&gt; toValue llvm_spec_size)</span></span>
<span class="lineno"> 4088 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4089 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Legacy alternative name for `llvm_spec_size`.&quot; ]</span></span>
<span class="lineno"> 4090 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4091 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;llvm_ffi_setup&quot;  &quot;Term -&gt; LLVMSetup ()&quot;</span>
<span class="lineno"> 4092 </span><span class="spaces">    </span><span class="istickedoff">(pureVal llvm_ffi_setup)</span>
<span class="lineno"> 4093 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Generate a @LLVMSetup@ spec that can be used to verify that the given&quot;</span></span>
<span class="lineno"> 4095 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;monomorphic Cryptol term, consisting of a Cryptol foreign function&quot;</span></span>
<span class="lineno"> 4096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;fully applied to any type arguments, has a correct foreign (LLVM)&quot;</span></span>
<span class="lineno"> 4097 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;implementation with respect to its Cryptol implementation.&quot;</span></span>
<span class="lineno"> 4098 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4099 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4100 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 4101 </span><span class="spaces">    </span><span class="istickedoff">-- Crucible/JVM commands</span>
<span class="lineno"> 4102 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4103 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_fresh_var&quot; &quot;String -&gt; JavaType -&gt; JVMSetup Term&quot;</span>
<span class="lineno"> 4104 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_fresh_var)</span>
<span class="lineno"> 4105 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4106 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh variable for use within a JVM specification. The&quot;</span></span>
<span class="lineno"> 4107 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 4108 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4109 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4110 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_alloc_object&quot; &quot;String -&gt; JVMSetup JVMValue&quot;</span>
<span class="lineno"> 4111 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_alloc_object)</span>
<span class="lineno"> 4112 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4113 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an instance of the given class should be allocated in a&quot;</span></span>
<span class="lineno"> 4114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;JVM specification. Before `jvm_execute_func`, this states that the&quot;</span></span>
<span class="lineno"> 4115 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method expects the object to be allocated before it runs. After&quot;</span></span>
<span class="lineno"> 4116 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`jvm_execute_func`, it states that the method being verified is&quot;</span></span>
<span class="lineno"> 4117 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 4118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4119 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4120 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_alloc_array&quot; &quot;Int -&gt; JavaType -&gt; JVMSetup JVMValue&quot;</span>
<span class="lineno"> 4121 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_alloc_array)</span>
<span class="lineno"> 4122 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4123 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an array of the given size and element type should be&quot;</span></span>
<span class="lineno"> 4124 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;allocated in a JVM specification. Before `jvm_execute_func`, this&quot;</span></span>
<span class="lineno"> 4125 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method expects the array to be allocated before it&quot;</span></span>
<span class="lineno"> 4126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;runs. After `jvm_execute_func`, it states that the method being&quot;</span></span>
<span class="lineno"> 4127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 4128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4129 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4130 </span><span class="spaces">    </span><span class="istickedoff">-- TODO: jvm_alloc_multiarray</span>
<span class="lineno"> 4131 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4132 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_field&quot; &quot;JVMValue -&gt; String -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4133 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_field)</span>
<span class="lineno"> 4134 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated object (first argument) has a field&quot;</span></span>
<span class="lineno"> 4136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing an unspecified value.&quot;</span></span>
<span class="lineno"> 4137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4138 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 4139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), this&quot;</span></span>
<span class="lineno"> 4140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the field, but says&quot;</span></span>
<span class="lineno"> 4141 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 4142 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4143 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4144 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_static_field&quot; &quot;String -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4145 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_static_field)</span>
<span class="lineno"> 4146 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the named static field contains an unspecified&quot;</span></span>
<span class="lineno"> 4148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;value.&quot;</span></span>
<span class="lineno"> 4149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 4151 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), it&quot;</span></span>
<span class="lineno"> 4152 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the static field, but says&quot;</span></span>
<span class="lineno"> 4153 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 4154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4155 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4156 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_elem&quot; &quot;JVMValue -&gt; Int -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4157 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_elem)</span>
<span class="lineno"> 4158 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4159 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array (first argument) has an element&quot;</span></span>
<span class="lineno"> 4160 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing an unspecified value.&quot;</span></span>
<span class="lineno"> 4161 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4162 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 4163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), it&quot;</span></span>
<span class="lineno"> 4164 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the array element, but says&quot;</span></span>
<span class="lineno"> 4165 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new value.&quot;</span></span>
<span class="lineno"> 4166 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4167 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4168 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_modifies_array&quot; &quot;JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4169 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_modifies_array)</span>
<span class="lineno"> 4170 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4171 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array's elements contain unspecified&quot;</span></span>
<span class="lineno"> 4172 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values.&quot;</span></span>
<span class="lineno"> 4173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This lets users write partial specifications of JVM methods.&quot;</span></span>
<span class="lineno"> 4175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the post-state section (after `jvm_execute_func`), it&quot;</span></span>
<span class="lineno"> 4176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;states that the method may modify the array elements, but says&quot;</span></span>
<span class="lineno"> 4177 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;nothing about the new values.&quot;</span></span>
<span class="lineno"> 4178 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4179 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4180 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_field_is&quot; &quot;JVMValue -&gt; String -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4181 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_field_is)</span>
<span class="lineno"> 4182 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated object (first argument) has a field&quot;</span></span>
<span class="lineno"> 4184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing the given value (third argument).&quot;</span></span>
<span class="lineno"> 4185 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4186 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 4187 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4191 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4192 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_static_field_is&quot; &quot;String -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4193 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_static_field_is)</span>
<span class="lineno"> 4194 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the named static field contains the given value.&quot;</span></span>
<span class="lineno"> 4196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;By default the field name is assumed to belong to the same class&quot;</span></span>
<span class="lineno"> 4197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;as the method being specified. Static fields belonging to other&quot;</span></span>
<span class="lineno"> 4198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;classes can be selected using the \&quot;&lt;classname&gt;.&lt;fieldname&gt;\&quot;&quot;</span></span>
<span class="lineno"> 4199 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;syntax in the string argument.&quot;</span></span>
<span class="lineno"> 4200 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4201 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 4202 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4206 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4207 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_elem_is&quot; &quot;JVMValue -&gt; Int -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4208 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_elem_is)</span>
<span class="lineno"> 4209 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array (first argument) has an element&quot;</span></span>
<span class="lineno"> 4211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;(second argument) containing the given value (third argument).&quot;</span></span>
<span class="lineno"> 4212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 4214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4215 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4216 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4217 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4218 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4219 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_array_is&quot; &quot;JVMValue -&gt; Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4220 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_array_is)</span>
<span class="lineno"> 4221 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4222 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the indicated array reference (first argument) contains&quot;</span></span>
<span class="lineno"> 4223 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the given sequence of values (second argument).&quot;</span></span>
<span class="lineno"> 4224 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4225 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before jvm_execute_func) this specifies&quot;</span></span>
<span class="lineno"> 4226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4228 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4231 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_precond&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4232 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_precond)</span>
<span class="lineno"> 4233 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4234 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on execution of the&quot;</span></span>
<span class="lineno"> 4235 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 4236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4237 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4238 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_assert&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4239 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_assert)</span>
<span class="lineno"> 4240 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4241 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as `jvm_precond`&quot;</span></span>
<span class="lineno"> 4242 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or `jvm_postcond` depending on the phase of specification in which&quot;</span></span>
<span class="lineno"> 4243 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it appears (i.e., before or after `jvm_execute_func`).&quot;</span></span>
<span class="lineno"> 4244 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4245 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4246 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_postcond&quot; &quot;Term -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4247 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_postcond)</span></span>
<span class="lineno"> 4248 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4249 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of execution of the&quot;</span></span>
<span class="lineno"> 4250 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 4251 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4252 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4253 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_equal&quot; &quot;JVMValue -&gt; JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4254 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_equal)</span>
<span class="lineno"> 4255 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4256 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two JVM values should be equal. Can be used as either a&quot;</span></span>
<span class="lineno"> 4257 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-condition or a post-condition. It is semantically equivalent to&quot;</span></span>
<span class="lineno"> 4258 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an `jvm_precond` or `jvm_postcond` statement which is an equality&quot;</span></span>
<span class="lineno"> 4259 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 4260 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4262 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_execute_func&quot; &quot;[JVMValue] -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4263 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_execute_func)</span>
<span class="lineno"> 4264 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4265 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the method.&quot;</span></span>
<span class="lineno"> 4266 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 4267 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The jvm_execute_func statement also serves to separate the pre-state&quot;</span></span>
<span class="lineno"> 4268 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section of the spec (before jvm_execute_func) from the post-state&quot;</span></span>
<span class="lineno"> 4269 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after jvm_execute_func). The effects of some JVMSetup&quot;</span></span>
<span class="lineno"> 4270 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 4271 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 4272 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4273 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4274 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_return&quot; &quot;JVMValue -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4275 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_return)</span>
<span class="lineno"> 4276 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4277 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the method. A&quot;</span></span>
<span class="lineno"> 4278 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;jvm_return statement is required if and only if the method&quot;</span></span>
<span class="lineno"> 4279 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-void return type.&quot; ]</span></span>
<span class="lineno"> 4280 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4281 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_setup_with_tag&quot; &quot;String -&gt; JVMSetup () -&gt; JVMSetup ()&quot;</span>
<span class="lineno"> 4282 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal jvm_setup_with_tag)</span></span>
<span class="lineno"> 4283 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4284 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;All conditions (e.g., from points-to or assert statements) executed&quot;</span></span>
<span class="lineno"> 4285 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in the scope of the given setup block will have the provieded string&quot;</span></span>
<span class="lineno"> 4286 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;attached as a tag that can later be filtered by proof tactics.&quot;</span></span>
<span class="lineno"> 4287 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4288 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4289 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_verify&quot;</span>
<span class="lineno"> 4290 </span><span class="spaces">    </span><span class="istickedoff">&quot;JavaClass -&gt; String -&gt; [JVMSpec] -&gt; Bool -&gt; JVMSetup () -&gt; ProofScript () -&gt; TopLevel JVMSpec&quot;</span>
<span class="lineno"> 4291 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_verify)</span>
<span class="lineno"> 4292 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4293 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the JVM method named by the second parameter in the class&quot;</span></span>
<span class="lineno"> 4294 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the JVMSpec values&quot;</span></span>
<span class="lineno"> 4295 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by previous calls to use as overrides. The fourth (Bool)&quot;</span></span>
<span class="lineno"> 4296 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameter enables or disables path satisfiability checking. The fifth&quot;</span></span>
<span class="lineno"> 4297 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;describes how to set up the symbolic execution engine before verification.&quot;</span></span>
<span class="lineno"> 4298 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;And the last gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 4299 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 4300 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4301 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4302 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_unsafe_assume_spec&quot;</span>
<span class="lineno"> 4303 </span><span class="spaces">    </span><span class="istickedoff">&quot;JavaClass -&gt; String -&gt; JVMSetup () -&gt; TopLevel JVMSpec&quot;</span>
<span class="lineno"> 4304 </span><span class="spaces">    </span><span class="istickedoff">(pureVal jvm_unsafe_assume_spec)</span>
<span class="lineno"> 4305 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4306 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a JVMSpec corresponding to a JVMSetup block, as would be&quot;</span></span>
<span class="lineno"> 4307 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by jvm_verify but without performing any verification.&quot;</span></span>
<span class="lineno"> 4308 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4309 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4310 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_null&quot;</span>
<span class="lineno"> 4311 </span><span class="spaces">    </span><span class="istickedoff">&quot;JVMValue&quot;</span>
<span class="lineno"> 4312 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupNull <span class="nottickedoff">()</span> :: CMS.SetupValue CJ.JVM))</span>
<span class="lineno"> 4313 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4314 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;A JVMValue representing a null pointer value.&quot; ]</span></span>
<span class="lineno"> 4315 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4316 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;jvm_term&quot;</span>
<span class="lineno"> 4317 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; JVMValue&quot;</span>
<span class="lineno"> 4318 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTerm :: TypedTerm -&gt; CMS.SetupValue CJ.JVM))</span>
<span class="lineno"> 4319 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 4320 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a `JVMValue` from a `Term`.&quot; ]</span></span>
<span class="lineno"> 4321 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4322 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 4323 </span><span class="spaces">    </span><span class="istickedoff">-- Crucible/MIR commands</span>
<span class="lineno"> 4324 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4325 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 4326 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc)</span>
<span class="lineno"> 4327 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4328 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that an immutable reference to the given type should be allocated&quot;</span></span>
<span class="lineno"> 4329 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a MIR specification. Before `mir_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 4330 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 4331 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `mir_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 4332 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 4333 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4334 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will raise an error if a `mir_slice` or `mir_str` type is&quot;</span></span>
<span class="lineno"> 4335 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed as an argument. To create slice reference, use the&quot;</span></span>
<span class="lineno"> 4336 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_slice_value` or `mir_slice_range_value` functions instead.&quot;</span></span>
<span class="lineno"> 4337 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4338 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4339 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_alloc_mut&quot; &quot;MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 4340 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_alloc_mut)</span>
<span class="lineno"> 4341 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4342 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that a mutable reference to the given type should be allocated&quot;</span></span>
<span class="lineno"> 4343 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;in a MIR specification. Before `mir_execute_func`, this states that&quot;</span></span>
<span class="lineno"> 4344 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the function expects the object to be allocated before it runs.&quot;</span></span>
<span class="lineno"> 4345 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;After `mir_execute_func`, it states that the function being&quot;</span></span>
<span class="lineno"> 4346 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verified is expected to perform the allocation.&quot;</span></span>
<span class="lineno"> 4347 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4348 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This command will raise an error if a `mir_slice` or `mir_str` type is&quot;</span></span>
<span class="lineno"> 4349 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;passed as an argument. To create slice reference, use the&quot;</span></span>
<span class="lineno"> 4350 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;`mir_slice_value` or `mir_slice_range_value` functions instead.&quot;</span></span>
<span class="lineno"> 4351 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4352 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4353 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_array_value&quot; &quot;MIRType -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 4354 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupArray :: Mir.Ty -&gt; [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 4355 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4356 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing an array of the given type, with the&quot;</span></span>
<span class="lineno"> 4357 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given list of values as elements.&quot;</span></span>
<span class="lineno"> 4358 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4359 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4360 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_assert&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4361 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_assert)</span>
<span class="lineno"> 4362 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4363 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate must hold.  Acts as `mir_precond`&quot;</span></span>
<span class="lineno"> 4364 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;or `mir_postcond` depending on the phase of specification in which&quot;</span></span>
<span class="lineno"> 4365 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;it appears (i.e., before or after `mir_execute_func`).&quot;</span></span>
<span class="lineno"> 4366 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4367 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4368 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_enum_value&quot; &quot;MIRAdt -&gt; String -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 4369 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_enum_value)</span>
<span class="lineno"> 4370 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4371 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a variant of a MIR enum with the given&quot;</span></span>
<span class="lineno"> 4372 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;list of values as elements. The MIRAdt argument determines what enum&quot;</span></span>
<span class="lineno"> 4373 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type to create; use `mir_find_adt` to retrieve a MIRAdt value. The&quot;</span></span>
<span class="lineno"> 4374 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;String argument represents the variant name.&quot;</span></span>
<span class="lineno"> 4375 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4376 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4377 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_equal&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4378 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_equal)</span>
<span class="lineno"> 4379 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4380 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that two MIR values should be equal. Can be used as either a&quot;</span></span>
<span class="lineno"> 4381 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pre-condition or a post-condition. It is semantically equivalent to&quot;</span></span>
<span class="lineno"> 4382 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;an `mir_precond` or `mir_postcond` statement which is an equality&quot;</span></span>
<span class="lineno"> 4383 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;predicate, but potentially more efficient.&quot;</span></span>
<span class="lineno"> 4384 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4385 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4386 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_execute_func&quot; &quot;[MIRValue] -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4387 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_execute_func)</span>
<span class="lineno"> 4388 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4389 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given list of values as the arguments of the method.&quot;</span></span>
<span class="lineno"> 4390 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">,  &quot;&quot;</span></span>
<span class="lineno"> 4391 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The mir_execute_func statement also serves to separate the pre-state&quot;</span></span>
<span class="lineno"> 4392 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section of the spec (before mir_execute_func) from the post-state&quot;</span></span>
<span class="lineno"> 4393 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after mir_execute_func). The effects of some MIRSetup&quot;</span></span>
<span class="lineno"> 4394 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;statements depend on whether they occur in the pre-state or post-state&quot;</span></span>
<span class="lineno"> 4395 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section.&quot;</span></span>
<span class="lineno"> 4396 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4397 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4398 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_find_adt&quot; &quot;MIRModule -&gt; String -&gt; [MIRType] -&gt; MIRAdt&quot;</span>
<span class="lineno"> 4399 </span><span class="spaces">    </span><span class="istickedoff">(funVal3 mir_find_adt)</span>
<span class="lineno"> 4400 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4401 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Consult the given MIRModule to find an algebraic data type (MIRAdt)&quot;</span></span>
<span class="lineno"> 4402 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;with the given String as an identifier and the given MIRTypes as the&quot;</span></span>
<span class="lineno"> 4403 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;types used to instantiate the type parameters. If such a MIRAdt cannot&quot;</span></span>
<span class="lineno"> 4404 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be found in the MIRModule, this will raise an error.&quot;</span></span>
<span class="lineno"> 4405 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4406 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4407 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_cryptol_var&quot; &quot;String -&gt; Type -&gt; MIRSetup Term&quot;</span>
<span class="lineno"> 4408 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_cryptol_var)</span>
<span class="lineno"> 4409 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4410 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable of the given Cryptol type for use&quot;</span></span>
<span class="lineno"> 4411 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;within a MIR specification. The given name is used only for&quot;</span></span>
<span class="lineno"> 4412 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;pretty-printing. Unlike 'mir_fresh_var', this can be used when&quot;</span></span>
<span class="lineno"> 4413 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;there isn't an appropriate MIR type, such as the Cryptol Array type.&quot;</span></span>
<span class="lineno"> 4414 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4415 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4416 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_expanded_value&quot; &quot;String -&gt; MIRType -&gt; MIRSetup MIRValue&quot;</span>
<span class="lineno"> 4417 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_expanded_value)</span>
<span class="lineno"> 4418 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4419 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIR value entirely populated with fresh symbolic variables.&quot;</span></span>
<span class="lineno"> 4420 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;For compound types such as structs and arrays, this will explicitly set&quot;</span></span>
<span class="lineno"> 4421 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;each field or element to contain a fresh symbolic variable. The String&quot;</span></span>
<span class="lineno"> 4422 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument is used as a prefix in each of the symbolic variables.&quot;</span></span>
<span class="lineno"> 4423 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4424 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4425 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_fresh_var&quot; &quot;String -&gt; MIRType -&gt; MIRSetup Term&quot;</span>
<span class="lineno"> 4426 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_fresh_var)</span>
<span class="lineno"> 4427 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4428 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a fresh symbolic variable for use within a MIR&quot;</span></span>
<span class="lineno"> 4429 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specification. The name is used only for pretty-printing.&quot;</span></span>
<span class="lineno"> 4430 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4431 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4432 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_load_module&quot; &quot;String -&gt; TopLevel MIRModule&quot;</span>
<span class="lineno"> 4433 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_load_module)</span>
<span class="lineno"> 4434 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4435 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a MIR JSON file and return a handle to it.&quot; ]</span></span>
<span class="lineno"> 4436 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4437 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_mux_values&quot; &quot;Term -&gt; MIRValue -&gt; MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 4438 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_mux_values)</span>
<span class="lineno"> 4439 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4440 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Mux two MIRValues based on whether a (possibly symbolic) Term predicate&quot;</span></span>
<span class="lineno"> 4441 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;holds or not. The Term argument must have the Cryptol type Bit, and the&quot;</span></span>
<span class="lineno"> 4442 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;two MIRValue arguments must have the same type.&quot;</span></span>
<span class="lineno"> 4443 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4444 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4445 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_points_to&quot; &quot;MIRValue -&gt; MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4446 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_points_to)</span>
<span class="lineno"> 4447 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4448 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Declare that the memory location indicated by the given reference (first&quot;</span></span>
<span class="lineno"> 4449 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;argument) contains the given value (second argument).&quot;</span></span>
<span class="lineno"> 4450 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4451 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;In the pre-state section (before `mir_execute_func`) this specifies&quot;</span></span>
<span class="lineno"> 4452 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;the initial memory layout before function execution. In the post-state&quot;</span></span>
<span class="lineno"> 4453 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;section (after `mir_execute_func`), this specifies an assertion&quot;</span></span>
<span class="lineno"> 4454 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;about the final memory state after running the function.&quot;</span></span>
<span class="lineno"> 4455 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4456 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4457 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_postcond&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4458 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_postcond)</span>
<span class="lineno"> 4459 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4460 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a post-condition of execution of the&quot;</span></span>
<span class="lineno"> 4461 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 4462 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4463 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4464 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_precond&quot; &quot;Term -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4465 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_precond)</span>
<span class="lineno"> 4466 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4467 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;State that the given predicate is a pre-condition on execution of the&quot;</span></span>
<span class="lineno"> 4468 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;method being verified.&quot;</span></span>
<span class="lineno"> 4469 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4470 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4471 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_return&quot; &quot;MIRValue -&gt; MIRSetup ()&quot;</span>
<span class="lineno"> 4472 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_return)</span>
<span class="lineno"> 4473 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4474 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Specify the given value as the return value of the method. A&quot;</span></span>
<span class="lineno"> 4475 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;mir_return statement is required if and only if the method&quot;</span></span>
<span class="lineno"> 4476 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;has a non-() return type.&quot; ]</span></span>
<span class="lineno"> 4477 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4478 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice_value&quot; &quot;MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 4479 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice_value)</span>
<span class="lineno"> 4480 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4481 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;[T]. The argument must&quot;</span></span>
<span class="lineno"> 4482 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be a reference to an array value, whose overall type must be &amp;[T; N]&quot;</span></span>
<span class="lineno"> 4483 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for some length N.&quot;</span></span>
<span class="lineno"> 4484 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4485 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4486 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice_range_value&quot; &quot;MIRValue -&gt; Int -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 4487 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice_range_value)</span>
<span class="lineno"> 4488 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4489 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;[T] over a given range.&quot;</span></span>
<span class="lineno"> 4490 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument must be a reference to an array value, whose overall&quot;</span></span>
<span class="lineno"> 4491 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type must be &amp;[T; N] for some length N. The second and third arguments&quot;</span></span>
<span class="lineno"> 4492 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;represent the start and end of the range. The start must not&quot;</span></span>
<span class="lineno"> 4493 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exceed the end, and the end must not exceed N.&quot;</span></span>
<span class="lineno"> 4494 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4495 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4496 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str_slice_value&quot; &quot;MIRValue -&gt; MIRValue&quot;</span>
<span class="lineno"> 4497 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str_slice_value)</span>
<span class="lineno"> 4498 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4499 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;str. The argument must&quot;</span></span>
<span class="lineno"> 4500 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;be a reference to an array value, whose overall type must be &amp;[u8; N]&quot;</span></span>
<span class="lineno"> 4501 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;for some length N. This array is expected to be a UTF-8-encoded sequence&quot;</span></span>
<span class="lineno"> 4502 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;of bytes.&quot;</span></span>
<span class="lineno"> 4503 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4504 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4505 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str_slice_range_value&quot; &quot;MIRValue -&gt; Int -&gt; Int -&gt; MIRValue&quot;</span>
<span class="lineno"> 4506 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str_slice_range_value)</span>
<span class="lineno"> 4507 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4508 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a MIRValue representing a slice of type &amp;str over a given range.&quot;</span></span>
<span class="lineno"> 4509 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first argument must be a reference to an array value, whose overall&quot;</span></span>
<span class="lineno"> 4510 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;type must be &amp;[u8; N] for some length N. This array is expected to be a&quot;</span></span>
<span class="lineno"> 4511 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;UTF-8-encoded sequence of bytes. The second and third arguments&quot;</span></span>
<span class="lineno"> 4512 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;represent the start and end of the range. The start must not&quot;</span></span>
<span class="lineno"> 4513 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;exceed the end, and the end must not exceed N.&quot;</span></span>
<span class="lineno"> 4514 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4515 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4516 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_struct_value&quot; &quot;MIRAdt -&gt; [MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 4517 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupStruct :: Mir.Adt -&gt; [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 4518 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4519 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a MIR struct with the given list of&quot;</span></span>
<span class="lineno"> 4520 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements. The MIRAdt argument determines what struct type to&quot;</span></span>
<span class="lineno"> 4521 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;create; use `mir_find_adt` to retrieve a MIRAdt value.&quot;</span></span>
<span class="lineno"> 4522 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4523 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4524 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_static&quot;</span>
<span class="lineno"> 4525 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRValue&quot;</span>
<span class="lineno"> 4526 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupGlobal () :: String -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 4527 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4528 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRValue representing a reference to the named static.&quot;</span></span>
<span class="lineno"> 4529 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The String should be the name of a static value.&quot;</span></span>
<span class="lineno"> 4530 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4531 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4532 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_static_initializer&quot;</span>
<span class="lineno"> 4533 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; MIRValue&quot;</span>
<span class="lineno"> 4534 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupGlobalInitializer () :: String -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 4535 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4536 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRValue representing the value of the initializer of a named&quot;</span></span>
<span class="lineno"> 4537 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;static. The String should be the name of a static value.&quot;</span></span>
<span class="lineno"> 4538 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4539 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4540 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_term&quot;</span>
<span class="lineno"> 4541 </span><span class="spaces">    </span><span class="istickedoff">&quot;Term -&gt; MIRValue&quot;</span>
<span class="lineno"> 4542 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTerm :: TypedTerm -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 4543 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4544 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Construct a `MIRValue` from a `Term`.&quot; ]</span></span>
<span class="lineno"> 4545 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4546 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_tuple_value&quot; &quot;[MIRValue] -&gt; MIRValue&quot;</span>
<span class="lineno"> 4547 </span><span class="spaces">    </span><span class="istickedoff">(pureVal (CMS.SetupTuple () :: [CMS.SetupValue MIR] -&gt; CMS.SetupValue MIR))</span>
<span class="lineno"> 4548 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4549 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a SetupValue representing a MIR tuple with the given list of&quot;</span></span>
<span class="lineno"> 4550 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values as elements.&quot;</span></span>
<span class="lineno"> 4551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4552 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4553 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_unsafe_assume_spec&quot;</span>
<span class="lineno"> 4554 </span><span class="spaces">    </span><span class="istickedoff">&quot;MIRModule -&gt; String -&gt; MIRSetup () -&gt; TopLevel MIRSpec&quot;</span>
<span class="lineno"> 4555 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_unsafe_assume_spec)</span>
<span class="lineno"> 4556 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4557 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Return a MIRSpec corresponding to a MIRSetup block, as would be&quot;</span></span>
<span class="lineno"> 4558 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;returned by mir_verify but without performing any verification.&quot;</span></span>
<span class="lineno"> 4559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4560 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4561 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_verify&quot;</span>
<span class="lineno"> 4562 </span><span class="spaces">    </span><span class="istickedoff">&quot;MIRModule -&gt; String -&gt; [MIRSpec] -&gt; Bool -&gt; MIRSetup () -&gt; ProofScript () -&gt; TopLevel MIRSpec&quot;</span>
<span class="lineno"> 4563 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_verify)</span>
<span class="lineno"> 4564 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4565 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Verify the MIR function named by the second parameter in the module&quot;</span></span>
<span class="lineno"> 4566 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;specified by the first. The third parameter lists the MIRSpec&quot;</span></span>
<span class="lineno"> 4567 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;values returned by previous calls to use as overrides. The fourth (Bool)&quot;</span></span>
<span class="lineno"> 4568 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;parameter enables or disables path satisfiability checking. The fifth&quot;</span></span>
<span class="lineno"> 4569 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;describes how to set up the symbolic execution engine before verification.&quot;</span></span>
<span class="lineno"> 4570 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;And the last gives the script to use to prove the validity of the resulting&quot;</span></span>
<span class="lineno"> 4571 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;verification conditions.&quot;</span></span>
<span class="lineno"> 4572 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4573 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4574 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_adt&quot; &quot;MIRAdt -&gt; MIRType&quot;</span>
<span class="lineno"> 4575 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_adt)</span>
<span class="lineno"> 4576 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4577 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of a MIR algebraic data type (ADT), i.e., a struct or enum,&quot;</span></span>
<span class="lineno"> 4578 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;corresponding to the given MIRAdt. Use the `mir_find_adt` command to&quot;</span></span>
<span class="lineno"> 4579 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;retrieve a MIRAdt value.&quot;</span></span>
<span class="lineno"> 4580 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4581 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4582 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_array&quot; &quot;Int -&gt; MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 4583 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_array)</span>
<span class="lineno"> 4584 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4585 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR arrays with the given number of elements of the&quot;</span></span>
<span class="lineno"> 4586 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;given type.&quot; ]</span></span>
<span class="lineno"> 4587 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4588 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_bool&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4589 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_bool)</span>
<span class="lineno"> 4590 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4591 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR booleans.&quot; ]</span></span>
<span class="lineno"> 4592 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4593 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_char&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4594 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_char)</span></span>
<span class="lineno"> 4595 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4596 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR characters.&quot; ]</span></span>
<span class="lineno"> 4597 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4598 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i8&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4599 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i8)</span>
<span class="lineno"> 4600 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4601 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 8-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 4602 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4603 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i16&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4604 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i16)</span>
<span class="lineno"> 4605 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4606 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 16-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 4607 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4608 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4609 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i32)</span>
<span class="lineno"> 4610 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4611 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 32-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 4612 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4613 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4614 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_i64)</span>
<span class="lineno"> 4615 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4616 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 64-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 4617 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4618 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_i128&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4619 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_i128)</span></span>
<span class="lineno"> 4620 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4621 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 128-bit signed integers.&quot; ]</span></span>
<span class="lineno"> 4622 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4623 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_isize&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4624 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_isize)</span>
<span class="lineno"> 4625 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4626 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR pointer-sized signed integers.&quot; ]</span></span>
<span class="lineno"> 4627 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4628 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_f32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4629 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_f32)</span></span>
<span class="lineno"> 4630 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4631 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR single-precision floating-point values.&quot; ]</span></span>
<span class="lineno"> 4632 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4633 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_f64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4634 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_f64)</span></span>
<span class="lineno"> 4635 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4636 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR double-precision floating-point values.&quot; ]</span></span>
<span class="lineno"> 4637 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4638 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_lifetime&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4639 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_lifetime)</span>
<span class="lineno"> 4640 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4641 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR lifetimes.&quot; ]</span></span>
<span class="lineno"> 4642 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4643 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 4644 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref)</span>
<span class="lineno"> 4645 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4646 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR immutable references.&quot; ]</span></span>
<span class="lineno"> 4647 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4648 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_ref_mut&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 4649 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_ref_mut)</span>
<span class="lineno"> 4650 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4651 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR mutable references.&quot; ]</span></span>
<span class="lineno"> 4652 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4653 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_slice&quot; &quot;MIRType -&gt; MIRType&quot;</span>
<span class="lineno"> 4654 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_slice)</span>
<span class="lineno"> 4655 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4656 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR slices, i.e., dynamically sized views into a&quot;</span></span>
<span class="lineno"> 4657 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;contiguous sequence of the given type. Currently, SAW can only&quot;</span></span>
<span class="lineno"> 4658 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;handle references to slices (&amp;[T]).&quot; ]</span></span>
<span class="lineno"> 4659 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4660 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_str&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4661 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_str)</span>
<span class="lineno"> 4662 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4663 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR strings, which are a particular kind of slice.&quot;</span></span>
<span class="lineno"> 4664 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Currently, SAW can only handle references to strings (&amp;str).&quot; ]</span></span>
<span class="lineno"> 4665 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4666 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_tuple&quot; &quot;[MIRType] -&gt; MIRType&quot;</span>
<span class="lineno"> 4667 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_tuple)</span>
<span class="lineno"> 4668 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4669 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR tuples of the given types.&quot; ]</span></span>
<span class="lineno"> 4670 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4671 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u8&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4672 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u8)</span>
<span class="lineno"> 4673 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4674 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 8-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 4675 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4676 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u16&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4677 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u16)</span>
<span class="lineno"> 4678 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4679 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 16-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 4680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4681 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u32&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4682 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u32)</span>
<span class="lineno"> 4683 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4684 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 32-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 4685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4686 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u64&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4687 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_u64)</span>
<span class="lineno"> 4688 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4689 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 64-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 4690 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4691 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_u128&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4692 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mir_u128)</span></span>
<span class="lineno"> 4693 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4694 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR 128-bit unsigned integers.&quot; ]</span></span>
<span class="lineno"> 4695 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4696 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mir_usize&quot; &quot;MIRType&quot;</span>
<span class="lineno"> 4697 </span><span class="spaces">    </span><span class="istickedoff">(pureVal mir_usize)</span>
<span class="lineno"> 4698 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4699 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The type of MIR pointer-sized unsigned integers.&quot; ]</span></span>
<span class="lineno"> 4700 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4701 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 4702 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4703 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_import&quot;  &quot;String -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4704 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_import)</span>
<span class="lineno"> 4705 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4706 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Produces a `Term` given the path to a JSON file produced by the Yosys `write_json` command.&quot;</span></span>
<span class="lineno"> 4707 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting term is a Cryptol record, where each field corresponds to one HDL module exported by Yosys.&quot;</span></span>
<span class="lineno"> 4708 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Each HDL module is in turn represented by a function from a record of input port values to a record of output port values.&quot;</span></span>
<span class="lineno"> 4709 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4710 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4711 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_verify&quot;  &quot;Term -&gt; [Term] -&gt; Term -&gt; [YosysTheorem] -&gt; ProofScript () -&gt; TopLevel YosysTheorem&quot;</span>
<span class="lineno"> 4712 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_verify)</span>
<span class="lineno"> 4713 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4714 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Proves equality between a combinational HDL module and a specification.&quot;</span></span>
<span class="lineno"> 4715 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the HDL module - given a record m from yosys_import, this will typically look something like `{{ m.foo }}`.&quot;</span></span>
<span class="lineno"> 4716 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second parameter is a list of preconditions for the equality.&quot;</span></span>
<span class="lineno"> 4717 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third parameter is the specification, a term of the same type as the HDL module, which will typically be some Cryptol function or another HDL module.&quot;</span></span>
<span class="lineno"> 4718 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth parameter is a list of overrides, which witness the results of previous yosys_verify proofs.&quot;</span></span>
<span class="lineno"> 4719 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;These overrides can be used to simplify terms by replacing use sites of submodules with their specifications.&quot;</span></span>
<span class="lineno"> 4720 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Note that terms derived from HDL modules are first class, and are not restricted to yosys_verify: they may also be used with SAW's typical Term infrastructure like sat, prove_print, term rewriting, etc.&quot;</span></span>
<span class="lineno"> 4721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;yosys_verify simply provides a convenient and familiar interface, similar to llvm_verify or jvm_verify.&quot;</span></span>
<span class="lineno"> 4722 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4723 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4724 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_import_sequential&quot;  &quot;String -&gt; String -&gt; TopLevel YosysSequential&quot;</span>
<span class="lineno"> 4725 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_import_sequential)</span>
<span class="lineno"> 4726 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4727 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Imports a particular sequential HDL module.&quot;</span></span>
<span class="lineno"> 4728 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the module name, the second is the path to the Yosys JSON file.&quot;</span></span>
<span class="lineno"> 4729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting value is an opaque representation of the sequential circuit that can be extracted to a Term or sent to solvers in various ways.&quot;</span></span>
<span class="lineno"> 4730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW expects the sequential module to exist entirely within a single Yosys module - the Yosys \&quot;flatten\&quot; command will collapse the module hierarchy into a single module.&quot;</span></span>
<span class="lineno"> 4731 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The only supported sequential element is the basic $dff cell.&quot;</span></span>
<span class="lineno"> 4732 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Memory cells and more complex flip-flops can be translated into $dff using the \&quot;memory\&quot; and \&quot;dffunmap\&quot; Yosys commands.&quot;</span></span>
<span class="lineno"> 4733 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4734 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4735 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential&quot;  &quot;YosysSequential -&gt; Int -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4736 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_extract_sequential)</span>
<span class="lineno"> 4737 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extracts a term from the given sequential module with the state eliminated by iterating the term over the given concrete number of cycles.&quot;</span></span>
<span class="lineno"> 4739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The resulting term has no state field in the inputs or outputs, and each input and output field is replaced with an array of that field's type (array length being the number of cycles).&quot;</span></span>
<span class="lineno"> 4740 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This term can be used like a normal SAW term - it may be embedded in Cryptol expressions, used in prove and sat, etc.&quot;</span></span>
<span class="lineno"> 4741 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4742 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4743 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential_with_state&quot;  &quot;YosysSequential -&gt; Int -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4744 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal yosys_extract_sequential_with_state)</span></span>
<span class="lineno"> 4745 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4746 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Like yosys_extract_sequential, but the resulting term has an additional parameter to specify the initial state.&quot;</span></span>
<span class="lineno"> 4747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4748 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4749 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_extract_sequential_raw&quot;  &quot;YosysSequential -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4750 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_extract_sequential_raw)</span>
<span class="lineno"> 4751 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4752 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extracts a term from the given sequential module.&quot;</span></span>
<span class="lineno"> 4753 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;This term has explicit fields for the state of the circuit in the input and output record types.&quot;</span></span>
<span class="lineno"> 4754 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4755 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4756 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;yosys_verify_sequential_offline_sally&quot;  &quot;YosysSequential -&gt; String -&gt; Term -&gt; [String] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4757 </span><span class="spaces">    </span><span class="istickedoff">(pureVal yosys_verify_sequential_sally)</span>
<span class="lineno"> 4758 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4759 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Export a query over the given sequential module to an input file for the Sally model checker.&quot;</span></span>
<span class="lineno"> 4760 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The first parameter is the sequential module.&quot;</span></span>
<span class="lineno"> 4761 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The second parameter is the path to write the resulting Sally input.&quot;</span></span>
<span class="lineno"> 4762 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The third parameter is the query, which should be a boolean function of three parameters: an 8-bit cycle counter, a record of \&quot;fixed\&quot; inputs, and a record of circuit outputs.&quot;</span></span>
<span class="lineno"> 4763 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;The fourth parameter is a list of strings specifying certain circuit inputs as fixed - these inputs are assumed to remain unchanged across cycles, and are therefore accesible from the query function.&quot;</span></span>
<span class="lineno"> 4764 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4765 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4766 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 4767 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4768 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mrsolver_set_debug_level&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4769 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mrSolverSetDebug)</span></span>
<span class="lineno"> 4770 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4771 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the debug level for Mr. Solver; 0 = no debug output,&quot;</span></span>
<span class="lineno"> 4772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; 1 = basic debug output, 2 = verbose debug output,&quot;</span></span>
<span class="lineno"> 4773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; 3 = all debug output&quot; ]</span></span>
<span class="lineno"> 4774 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4775 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mrsolver_set_debug_printing_depth&quot; &quot;Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4776 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mrSolverSetDebugDepth)</span></span>
<span class="lineno"> 4777 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4778 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Limit the printing of terms in all subsequent Mr. Solver error messages&quot;</span></span>
<span class="lineno"> 4779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;and debug output to a maximum depth&quot; ]</span></span>
<span class="lineno"> 4780 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4781 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mrsolver&quot; &quot;ProofScript ()&quot;</span>
<span class="lineno"> 4782 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (mrSolver emptyRefnset))</span></span>
<span class="lineno"> 4783 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4784 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use MRSolver to prove a current refinement goal, i.e. a goal of&quot;</span></span>
<span class="lineno"> 4785 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; the form `(a1:A1) -&gt; ... -&gt; (an:An) -&gt; refinesS_eq ...`&quot; ]</span></span>
<span class="lineno"> 4786 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4787 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;empty_rs&quot;            &quot;Refnset&quot;</span>
<span class="lineno"> 4788 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal (emptyRefnset :: SAWRefnset))</span></span>
<span class="lineno"> 4789 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4790 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;The empty refinement set, containing no refinements.&quot; ]</span></span>
<span class="lineno"> 4791 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4792 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addrefn&quot;             &quot;Theorem -&gt; Refnset -&gt; Refnset&quot;</span>
<span class="lineno"> 4793 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addrefn)</span></span>
<span class="lineno"> 4794 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add a proved refinement theorem to a given refinement set.&quot; ]</span></span>
<span class="lineno"> 4796 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4797 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;addrefns&quot;            &quot;[Theorem] -&gt; Refnset -&gt; Refnset&quot;</span>
<span class="lineno"> 4798 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal2 addrefns)</span></span>
<span class="lineno"> 4799 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4800 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Add proved refinement theorems to a given refinement set.&quot; ]</span></span>
<span class="lineno"> 4801 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4802 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;mrsolver_with&quot; &quot;Refnset -&gt; ProofScript ()&quot;</span>
<span class="lineno"> 4803 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal mrSolver)</span></span>
<span class="lineno"> 4804 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4805 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use MRSolver to prove a current refinement goal, i.e. a goal of&quot;</span></span>
<span class="lineno"> 4806 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; the form `(a1:A1) -&gt; ... -&gt; (an:An) -&gt; refinesS_eq ...`, with&quot;</span></span>
<span class="lineno"> 4807 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; the given set of refinements taken as assumptions&quot; ]</span></span>
<span class="lineno"> 4808 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4809 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;refines&quot; &quot;[Term] -&gt; Term -&gt; Term -&gt; Term&quot;</span>
<span class="lineno"> 4810 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(funVal3 refinesTerm)</span></span>
<span class="lineno"> 4811 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4812 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Given a list of 'fresh_symbolic' variables over which to quantify&quot;</span></span>
<span class="lineno"> 4813 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; as as well as two terms containing those variables, which may be&quot;</span></span>
<span class="lineno"> 4814 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; either terms or functions in the SpecM monad, construct the&quot;</span></span>
<span class="lineno"> 4815 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; SAWCore term which is the refinement (`SpecM.refinesS`) of the&quot;</span></span>
<span class="lineno"> 4816 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; given terms, with the given variables generalized with a Pi type.&quot; ]</span></span>
<span class="lineno"> 4817 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4818 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 4819 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4820 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;monadify_term&quot; &quot;Term -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal monadifyTypedTerm)</span></span>
<span class="lineno"> 4822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4823 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Monadify a Cryptol term, converting it to a form where all recursion&quot;</span></span>
<span class="lineno"> 4824 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; and errors are represented as monadic operators&quot;]</span></span>
<span class="lineno"> 4825 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4826 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;set_monadification&quot; &quot;String -&gt; String -&gt; Bool -&gt; TopLevel Term&quot;</span>
<span class="lineno"> 4827 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(scVal setMonadification)</span></span>
<span class="lineno"> 4828 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4829 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the monadification of a specific Cryptol identifer to a SAW core &quot;</span></span>
<span class="lineno"> 4830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;identifier of monadic type. The supplied Boolean flag indicates if the &quot;</span></span>
<span class="lineno"> 4831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SAW core term is polymorphic in the event type and function stack of the&quot;</span></span>
<span class="lineno"> 4832 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;SpecM monad.&quot;]</span></span>
<span class="lineno"> 4833 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4834 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_init_env&quot;</span>
<span class="lineno"> 4835 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4836 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_init_env)</span></span>
<span class="lineno"> 4837 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4838 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a new Heapster environment with the given SAW module name&quot;</span></span>
<span class="lineno"> 4839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; from the named LLVM bitcode file.&quot;</span></span>
<span class="lineno"> 4840 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4841 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4842 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_init_env_debug&quot;</span>
<span class="lineno"> 4843 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4844 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_init_env)</span></span>
<span class="lineno"> 4845 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4846 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a new Heapster environment with the given SAW module name&quot;</span></span>
<span class="lineno"> 4847 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; from the named LLVM bitcode file with debug tracing turned on&quot;</span></span>
<span class="lineno"> 4848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4849 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4850 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_init_env_from_file&quot;</span>
<span class="lineno"> 4851 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4852 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_init_env_from_file)</span></span>
<span class="lineno"> 4853 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4854 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a new Heapster environment from the named LLVM bitcode file,&quot;</span></span>
<span class="lineno"> 4855 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; initialized with the module in the given SAW core file.&quot;</span></span>
<span class="lineno"> 4856 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4857 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4858 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_init_env_from_file_debug&quot;</span>
<span class="lineno"> 4859 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4860 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_init_env_from_file_debug)</span></span>
<span class="lineno"> 4861 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4862 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a new Heapster environment from the named LLVM bitcode file,&quot;</span></span>
<span class="lineno"> 4863 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; initialized with the module in the given SAW core file, with debug&quot;</span></span>
<span class="lineno"> 4864 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; tracing turned on&quot;</span></span>
<span class="lineno"> 4865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4866 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4867 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;load_sawcore_from_file&quot;</span>
<span class="lineno"> 4868 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4869 </span><span class="spaces">    </span><span class="istickedoff">(bicVal load_sawcore_from_file)</span>
<span class="lineno"> 4870 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4871 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Load a SAW core module from a file&quot;</span></span>
<span class="lineno"> 4872 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4873 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4874 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_init_env_for_files&quot;</span>
<span class="lineno"> 4875 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; [String] -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4876 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_init_env_for_files)</span></span>
<span class="lineno"> 4877 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4878 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a new Heapster environment from the named LLVM bitcode files,&quot;</span></span>
<span class="lineno"> 4879 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; initialized with the module in the given SAW core file.&quot;</span></span>
<span class="lineno"> 4880 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4881 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4882 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_init_env_for_files_debug&quot;</span>
<span class="lineno"> 4883 </span><span class="spaces">    </span><span class="istickedoff">&quot;String -&gt; [String] -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_init_env_for_files_debug)</span></span>
<span class="lineno"> 4885 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4886 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Create a new Heapster environment from the named LLVM bitcode files,&quot;</span></span>
<span class="lineno"> 4887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; initialized with the module in the given SAW core file, with debug&quot;</span></span>
<span class="lineno"> 4888 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; tracing turned on&quot;</span></span>
<span class="lineno"> 4889 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4890 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4891 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_get_cfg&quot;</span>
<span class="lineno"> 4892 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel CFG&quot;</span>
<span class="lineno"> 4893 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_get_cfg)</span></span>
<span class="lineno"> 4894 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4895 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Extract out the Crucible CFG associated with a symbol in a&quot;</span></span>
<span class="lineno"> 4896 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; Heapster environemnt&quot;</span></span>
<span class="lineno"> 4897 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4898 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4899 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_opaque_perm&quot;</span>
<span class="lineno"> 4900 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4901 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_opaque_perm)</span></span>
<span class="lineno"> 4902 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4903 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_opaque_perm nm args tp trans d defines an opaque named&quot;</span></span>
<span class="lineno"> 4904 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; Heapster permission named nm with arguments parsed from args and type&quot;</span></span>
<span class="lineno"> 4905 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; tp that translates to the SAW core type trans with type description d&quot;</span></span>
<span class="lineno"> 4906 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4907 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4908 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_recursive_perm&quot;</span>
<span class="lineno"> 4909 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4910 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_recursive_perm)</span></span>
<span class="lineno"> 4911 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4912 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_recursive_perm env nm arg_ctx tp p defines a recursive&quot;</span></span>
<span class="lineno"> 4913 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; Heapster permission named nm with arguments parsed from args_ctx and&quot;</span></span>
<span class="lineno"> 4914 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; type parsed from tp that translates to permissions p, which can&quot;</span></span>
<span class="lineno"> 4915 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; resurively use nm (with no arguments) in those permissions&quot;</span></span>
<span class="lineno"> 4916 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4917 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4918 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_reachability_perm&quot;</span>
<span class="lineno"> 4919 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4920 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_reachability_perm)</span></span>
<span class="lineno"> 4921 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4922 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_recursive_perm env nm arg_ctx value_type p trans_fun&quot;</span></span>
<span class="lineno"> 4923 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; defines a recursive named Heapster permission named nm with arguments&quot;</span></span>
<span class="lineno"> 4924 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; parsed from args_ctx and type parsed from value_type that unfolds to p,&quot;</span></span>
<span class="lineno"> 4925 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; which should form a reachability permission, meaning that it should&quot;</span></span>
<span class="lineno"> 4926 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; have the form eq(x) or q for some permission q, where x is the last&quot;</span></span>
<span class="lineno"> 4927 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; argument argument in arg_ctx and q can contain nm with no arguments to&quot;</span></span>
<span class="lineno"> 4928 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; refer to the entire permission recursively.&quot;</span></span>
<span class="lineno"> 4929 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4930 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4931 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_recursive_shape&quot;</span>
<span class="lineno"> 4932 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; Int -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4933 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_recursive_shape)</span></span>
<span class="lineno"> 4934 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4935 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_irt_recursive_shape env name w arg_ctx body_sh&quot;</span></span>
<span class="lineno"> 4936 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; defines a recursive named Heapser shape named nm with arguments&quot;</span></span>
<span class="lineno"> 4937 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; parsed from args_ctx and width w that unfolds to the shape body_sh,&quot;</span></span>
<span class="lineno"> 4938 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; whichx can contain name for recursive occurrences of the shape&quot;</span></span>
<span class="lineno"> 4939 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4940 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4941 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_perm&quot;</span>
<span class="lineno"> 4942 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4943 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_perm)</span></span>
<span class="lineno"> 4944 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4945 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_perm nm args tp p defines a Heapster permission named&quot;</span></span>
<span class="lineno"> 4946 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; nm with arguments x1,...,xn parsed from args and type parsed from tp&quot;</span></span>
<span class="lineno"> 4947 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; such that nm&lt;x1,...,xn&gt; is equivalent to the permission p.&quot;</span></span>
<span class="lineno"> 4948 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4949 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4950 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_llvmshape&quot;</span>
<span class="lineno"> 4951 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; Int -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4952 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_llvmshape)</span></span>
<span class="lineno"> 4953 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4954 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_llvmshape nm w args sh defines a Heapster LLVM shape&quot;</span></span>
<span class="lineno"> 4955 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; nm with type llvmshape w and arguments x1,...,xn parsed from args&quot;</span></span>
<span class="lineno"> 4956 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; such that nm&lt;x1,...,xn&gt; is equivalent to the permission p.&quot;</span></span>
<span class="lineno"> 4957 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4958 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4959 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_opaque_llvmshape&quot;</span>
<span class="lineno"> 4960 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; Int -&gt; String -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4961 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_opaque_llvmshape)</span></span>
<span class="lineno"> 4962 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4963 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_opaque_llvmshape henv nm w args len tp d defines a Heapster&quot;</span></span>
<span class="lineno"> 4964 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; LLVM shape that is opaque, meaning it acts as a sort of shape axiom, where&quot;</span></span>
<span class="lineno"> 4965 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; Heapster does not know or care about the contents of memory of this shape&quot;</span></span>
<span class="lineno"> 4966 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; but instead treats that memory as an opaque object, defined only by its&quot;</span></span>
<span class="lineno"> 4967 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; length and its translation to a SAW core type.&quot;</span></span>
<span class="lineno"> 4968 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;&quot;</span></span>
<span class="lineno"> 4969 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; The henv argument is the Heapster environment this new shape is added to,&quot;</span></span>
<span class="lineno"> 4970 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; nm is its name, args is a context of argument variables for this shape,&quot;</span></span>
<span class="lineno"> 4971 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; len is an expression for the length of the shape in terms of the arguments,&quot;</span></span>
<span class="lineno"> 4972 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; tp gives the translation of the shape as a SAW core type over the&quot;</span></span>
<span class="lineno"> 4973 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; translation of the arguments to SAW core variables, and d is a SAW core&quot;</span></span>
<span class="lineno"> 4974 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; term of type TpDesc that describes the SAW core type.&quot;</span></span>
<span class="lineno"> 4975 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4976 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4977 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_rust_type&quot;</span>
<span class="lineno"> 4978 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4979 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_rust_type)</span></span>
<span class="lineno"> 4980 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4981 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_rust_type env tp defines a Heapster LLVM shape from tp,&quot;</span></span>
<span class="lineno"> 4982 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;a string representing a top-level struct or enum definition.&quot;</span></span>
<span class="lineno"> 4983 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4984 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4985 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_define_rust_type_qual&quot;</span>
<span class="lineno"> 4986 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 4987 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_define_rust_type_qual)</span></span>
<span class="lineno"> 4988 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 4989 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_define_rust_type_qual env crate tp defines a Heapster LLVM&quot;</span></span>
<span class="lineno"> 4990 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; shape from tp, a string representing a top-level Rust struct or enum&quot;</span></span>
<span class="lineno"> 4991 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; definition. The type is qualified by crate, meaning that \&quot;crate::\&quot;&quot;</span></span>
<span class="lineno"> 4992 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; is prepended to its name.&quot;</span></span>
<span class="lineno"> 4993 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 4994 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 4995 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_block_entry_hint&quot;</span>
<span class="lineno"> 4996 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; Int -&gt; String -&gt; String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 4997 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_block_entry_hint)</span></span>
<span class="lineno"> 4998 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 4999 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_block_entry_hint env nm block top_args ghosts perms adds a hint&quot;</span></span>
<span class="lineno"> 5000 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; to the Heapster type-checker that Crucible block number block in nm&quot;</span></span>
<span class="lineno"> 5001 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; should have permissions perms on its inputs, assuming that top_args&quot;</span></span>
<span class="lineno"> 5002 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; lists the top-level ghost and normal arguments to function nm and&quot;</span></span>
<span class="lineno"> 5003 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; ghosts gives the ghost arguments to block&quot;</span></span>
<span class="lineno"> 5004 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5005 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5006 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_gen_block_perms_hint&quot;</span>
<span class="lineno"> 5007 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; [Int] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5008 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_gen_block_perms_hint)</span></span>
<span class="lineno"> 5009 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5010 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_gen_block_perms_hint env nm blocks adds a hint to the Heapster&quot;</span></span>
<span class="lineno"> 5011 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; type-checker to *generalize* (recursively replace all instances of&quot;</span></span>
<span class="lineno"> 5012 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; eq(const) with (exists x. eq(x))) all permissions on the inputs of the&quot;</span></span>
<span class="lineno"> 5013 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; given Crucible blocks numbers. If the given list is empty, do so for&quot;</span></span>
<span class="lineno"> 5014 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; every block in the CFG.&quot;</span></span>
<span class="lineno"> 5015 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5016 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5017 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_join_point_hint&quot;</span>
<span class="lineno"> 5018 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; [Int] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5019 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_join_point_hint)</span></span>
<span class="lineno"> 5020 </span><span class="spaces">    </span><span class="istickedoff">Experimental</span>
<span class="lineno"> 5021 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_join_point_hint env nm blocks adds a hint to the Heapster&quot;</span></span>
<span class="lineno"> 5022 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; type-checker to make a join point at each of the given block numbers,&quot;</span></span>
<span class="lineno"> 5023 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; meaning that all entries to the given blocks are merged into a single&quot;</span></span>
<span class="lineno"> 5024 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; entrypoint, whose permissions are given by the first call to the block.&quot;</span></span>
<span class="lineno"> 5025 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; If the given list is empty, do so for every block in the CFG.&quot;</span></span>
<span class="lineno"> 5026 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5027 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5028 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_find_symbol&quot;</span>
<span class="lineno"> 5029 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel String&quot;</span>
<span class="lineno"> 5030 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_find_symbol)</span></span>
<span class="lineno"> 5031 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5032 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Search for a symbol in any module contained in a HeapsterEnv that&quot;</span></span>
<span class="lineno"> 5033 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; contains the supplied string as a substring. Raise an error if there&quot;</span></span>
<span class="lineno"> 5034 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; is not exactly one such symbol&quot;</span></span>
<span class="lineno"> 5035 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5036 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5037 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_find_symbols&quot;</span>
<span class="lineno"> 5038 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel [String]&quot;</span>
<span class="lineno"> 5039 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_find_symbols)</span></span>
<span class="lineno"> 5040 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5041 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Search for all symbols in any module contained in a HeapsterEnv that&quot;</span></span>
<span class="lineno"> 5042 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; contain the supplied string as a substring&quot;</span></span>
<span class="lineno"> 5043 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5044 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5045 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_find_symbol_with_type&quot;</span>
<span class="lineno"> 5046 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; TopLevel String&quot;</span>
<span class="lineno"> 5047 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_find_symbol_with_type)</span></span>
<span class="lineno"> 5048 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5049 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Search for a symbol in any module contained in a HeapsterEnv that&quot;</span></span>
<span class="lineno"> 5050 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; contains the supplied string as a substring and that has the specified&quot;</span></span>
<span class="lineno"> 5051 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; LLVM type. Raise an error if there is not exactly one such symbol.&quot;</span></span>
<span class="lineno"> 5052 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5053 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5054 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_find_symbols_with_type&quot;</span>
<span class="lineno"> 5055 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; TopLevel [String]&quot;</span>
<span class="lineno"> 5056 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_find_symbols_with_type)</span></span>
<span class="lineno"> 5057 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5058 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Search for all symbols in any module contained in a HeapsterEnv that&quot;</span></span>
<span class="lineno"> 5059 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; contain the supplied string as a substring and that have the specified&quot;</span></span>
<span class="lineno"> 5060 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; LLVM type&quot;</span></span>
<span class="lineno"> 5061 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5062 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5063 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_find_symbol_commands&quot;</span>
<span class="lineno"> 5064 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel [String]&quot;</span>
<span class="lineno"> 5065 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_find_symbol_commands)</span></span>
<span class="lineno"> 5066 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5067 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Map a search string str to a newline-separated sequence of SAW-script &quot;</span></span>
<span class="lineno"> 5068 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; commands \&quot;heapster_find_symbol_with_type str tp\&quot;, one for each LLVM &quot;</span></span>
<span class="lineno"> 5069 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; type tp associated with a symbol whose name contains str&quot; ]</span></span>
<span class="lineno"> 5070 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5071 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_find_trait_method_symbol&quot;</span>
<span class="lineno"> 5072 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel String&quot;</span>
<span class="lineno"> 5073 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_find_trait_method_symbol)</span></span>
<span class="lineno"> 5074 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5075 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Search for a symbol in any module contained in a HeapsterEnv that&quot;</span></span>
<span class="lineno"> 5076 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;corresponds to the given trait method implementation. The search&quot;</span></span>
<span class="lineno"> 5077 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;string should be of the form: trait::method&lt;type&gt;, e.g.&quot;</span></span>
<span class="lineno"> 5078 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;core::fmt::Debug::fmt&lt;Foo&gt;&quot;</span></span>
<span class="lineno"> 5079 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5080 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5081 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_assume_fun&quot;</span>
<span class="lineno"> 5082 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 5083 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_assume_fun)</span></span>
<span class="lineno"> 5084 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5085 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_assume_fun env nm perms trans assumes that function nm has&quot;</span></span>
<span class="lineno"> 5086 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; permissions perms and translates to the SAW core term trans&quot;</span></span>
<span class="lineno"> 5087 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5088 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5089 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_assume_fun_rename&quot;</span>
<span class="lineno"> 5090 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 5091 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_assume_fun_rename)</span></span>
<span class="lineno"> 5092 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5093 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_assume_fun_rename env nm nm_to perms trans assumes that function nm&quot;</span></span>
<span class="lineno"> 5094 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; has permissions perms and translates to the SAW core term trans. If&quot;</span></span>
<span class="lineno"> 5095 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; trans is not an identifier then it is bound to the defined name nm_to.&quot;</span></span>
<span class="lineno"> 5096 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5097 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5098 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_assume_fun_rename_prim&quot;</span>
<span class="lineno"> 5099 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 5100 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_assume_fun_rename_prim)</span></span>
<span class="lineno"> 5101 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5102 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[</span></span>
<span class="lineno"> 5103 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">&quot;heapster_assume_fun_rename_prim env nm nm_to perms assumes that function nm&quot;</span></span>
<span class="lineno"> 5104 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; has permissions perms as a primitive.&quot;</span></span>
<span class="lineno"> 5105 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5106 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5107 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_assume_fun_multi&quot;</span>
<span class="lineno"> 5108 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; [(String, String)] -&gt; TopLevel HeapsterEnv&quot;</span>
<span class="lineno"> 5109 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_assume_fun_multi)</span></span>
<span class="lineno"> 5110 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5111 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;heapster_assume_fun_multi env nm [(perm1, trans1), ...] assumes that function&quot;</span></span>
<span class="lineno"> 5112 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; nm can be typed with 0 or more permissions, each with the corresponding&quot;</span></span>
<span class="lineno"> 5113 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; translation to SAW core&quot;</span></span>
<span class="lineno"> 5114 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5115 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5116 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_typecheck_fun&quot;</span>
<span class="lineno"> 5117 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5118 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_typecheck_fun)</span></span>
<span class="lineno"> 5119 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5120 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate an LLVM function to a SAW core term using Heapster&quot;</span></span>
<span class="lineno"> 5121 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; type-checking, and store the result in the current Heapster SAW module.&quot;</span></span>
<span class="lineno"> 5122 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5123 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5124 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_typecheck_fun_rename&quot;</span>
<span class="lineno"> 5125 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5126 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_typecheck_fun_rename)</span></span>
<span class="lineno"> 5127 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5128 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate the LLVM function named by the first String to a SAW core term&quot;</span></span>
<span class="lineno"> 5129 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; using Heapster type-checking, and store the result in the current&quot;</span></span>
<span class="lineno"> 5130 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot; Heapster SAW module as a definition named with the second string.&quot;</span></span>
<span class="lineno"> 5131 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5132 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5133 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_typecheck_mut_funs&quot;</span>
<span class="lineno"> 5134 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; [(String, String)] -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5135 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_typecheck_mut_funs)</span></span>
<span class="lineno"> 5136 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5137 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Translate a set of mutually recursive LLVM function to a set of SAW &quot;</span></span>
<span class="lineno"> 5138 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;core terms using Heapster type-checking. Store the results in the &quot;</span></span>
<span class="lineno"> 5139 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;current Heapster SAW module.&quot;</span></span>
<span class="lineno"> 5140 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5141 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5142 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_set_event_type&quot;</span>
<span class="lineno"> 5143 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5144 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_set_event_type)</span></span>
<span class="lineno"> 5145 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the event type for the remaining Heapster translations to a SAW &quot;</span></span>
<span class="lineno"> 5147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;core term of type EvType. It is recommended that this is done at most &quot;</span></span>
<span class="lineno"> 5148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;once in a SAW script, at the beginning, because changing the event type &quot;</span></span>
<span class="lineno"> 5149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;yields incompatible specifications.&quot;</span></span>
<span class="lineno"> 5150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5151 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5152 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_print_fun_trans&quot;</span>
<span class="lineno"> 5153 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5154 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_print_fun_trans)</span></span>
<span class="lineno"> 5155 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5156 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print the translation to SAW of a function that has been type-checked.&quot;</span></span>
<span class="lineno"> 5157 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5158 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5159 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_export_coq&quot;</span>
<span class="lineno"> 5160 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5161 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_export_coq)</span></span>
<span class="lineno"> 5162 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5163 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Export a Heapster environment to a Coq file&quot; ]</span></span>
<span class="lineno"> 5164 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5165 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_set_debug_level&quot;</span>
<span class="lineno"> 5166 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; Int -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5167 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_set_debug_level)</span></span>
<span class="lineno"> 5168 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5169 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Set the debug level for Heapster; 0 = no debug output, 1 = debug output&quot; ]</span></span>
<span class="lineno"> 5170 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5171 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_set_translation_checks&quot;</span>
<span class="lineno"> 5172 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; Bool -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5173 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_set_translation_checks)</span></span>
<span class="lineno"> 5174 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5175 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Tell Heapster whether to perform its translation-time checks of the &quot;</span></span>
<span class="lineno"> 5176 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;well-formedness of type-checking proofs&quot; ]</span></span>
<span class="lineno"> 5177 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5178 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_trans_rust_type&quot;</span>
<span class="lineno"> 5179 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5180 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_translate_rust_type)</span></span>
<span class="lineno"> 5181 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5182 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse a Rust function type and print the equivalent Heapser type. &quot;</span></span>
<span class="lineno"> 5183 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;Ideal for learning how Rust types are translated into Heapster. &quot;</span></span>
<span class="lineno"> 5184 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5185 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5186 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_parse_test&quot;</span>
<span class="lineno"> 5187 </span><span class="spaces">    </span><span class="istickedoff">&quot;LLVMModule -&gt; String -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5188 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_parse_test)</span></span>
<span class="lineno"> 5189 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5190 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Parse and print back a set of Heapster permissions for a function&quot;</span></span>
<span class="lineno"> 5191 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5192 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5193 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;heapster_dump_ide_info&quot;</span>
<span class="lineno"> 5194 </span><span class="spaces">    </span><span class="istickedoff">&quot;HeapsterEnv -&gt; String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5195 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(bicVal heapster_dump_ide_info)</span></span>
<span class="lineno"> 5196 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5197 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Dump environment info to a JSON file for IDE integration.&quot;</span></span>
<span class="lineno"> 5198 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5199 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5200 </span><span class="spaces">    </span><span class="istickedoff">---------------------------------------------------------------------</span>
<span class="lineno"> 5201 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5202 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;sharpSAT&quot;  &quot;Term -&gt; TopLevel Integer&quot;</span>
<span class="lineno"> 5203 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal sharpSAT)</span></span>
<span class="lineno"> 5204 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5205 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the sharpSAT solver to count the number of solutions to the CNF&quot;</span></span>
<span class="lineno"> 5206 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;representation of the given Term.&quot;</span></span>
<span class="lineno"> 5207 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5208 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5209 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;approxmc&quot;  &quot;Term -&gt; TopLevel String&quot;</span>
<span class="lineno"> 5210 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal approxmc)</span></span>
<span class="lineno"> 5211 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Current</span></span>
<span class="lineno"> 5212 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Use the approxmc solver to approximate the number of solutions to the&quot;</span></span>
<span class="lineno"> 5213 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;CNF representation of the given Term.&quot;</span></span>
<span class="lineno"> 5214 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5215 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5216 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;enable_crucible_profiling&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5217 </span><span class="spaces">    </span><span class="istickedoff">(pureVal enable_crucible_profiling)</span>
<span class="lineno"> 5218 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5219 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record profiling information from symbolic execution and solver&quot;</span></span>
<span class="lineno"> 5220 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;invocation to the given directory.&quot;</span></span>
<span class="lineno"> 5221 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5222 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5223 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;disable_crucible_profiling&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5224 </span><span class="spaces">    </span><span class="istickedoff">(pureVal disable_crucible_profiling)</span>
<span class="lineno"> 5225 </span><span class="spaces">    </span><span class="istickedoff">Current</span>
<span class="lineno"> 5226 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[&quot;Stop recording profiling information.&quot;]</span></span>
<span class="lineno"> 5227 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5228 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;summarize_verification&quot; &quot;TopLevel ()&quot;</span>
<span class="lineno"> 5229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal summarize_verification)</span></span>
<span class="lineno"> 5230 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5231 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print a human-readable summary of all verifications performed&quot;</span></span>
<span class="lineno"> 5232 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so far.&quot;</span></span>
<span class="lineno"> 5233 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5234 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5235 </span><span class="spaces">  </span><span class="istickedoff">, prim &quot;summarize_verification_json&quot; &quot;String -&gt; TopLevel ()&quot;</span>
<span class="lineno"> 5236 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(pureVal summarize_verification_json)</span></span>
<span class="lineno"> 5237 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Experimental</span></span>
<span class="lineno"> 5238 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Print a JSON summary of all verifications performed&quot;</span></span>
<span class="lineno"> 5239 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">, &quot;so far into the named file.&quot;</span></span>
<span class="lineno"> 5240 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno"> 5241 </span><span class="spaces">  </span><span class="istickedoff">]</span>
<span class="lineno"> 5242 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5243 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 5244 </span><span class="spaces">    </span><span class="istickedoff">prim :: Text -&gt; Text -&gt; (Options -&gt; BuiltinContext -&gt; Value) -&gt; PrimitiveLifecycle -&gt; [String]</span>
<span class="lineno"> 5245 </span><span class="spaces">         </span><span class="istickedoff">-&gt; (SS.LName, Primitive)</span>
<span class="lineno"> 5246 </span><span class="spaces">    </span><span class="istickedoff">prim name ty fn lc doc = (qname, Primitive</span>
<span class="lineno"> 5247 </span><span class="spaces">                                     </span><span class="istickedoff">{ primitiveType = readSchema fakeFileName ty</span>
<span class="lineno"> 5248 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveDoc  = <span class="nottickedoff">doc</span></span>
<span class="lineno"> 5249 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveFn   = fn</span>
<span class="lineno"> 5250 </span><span class="spaces">                                     </span><span class="istickedoff">, primitiveLife = lc</span>
<span class="lineno"> 5251 </span><span class="spaces">                                     </span><span class="istickedoff">})</span>
<span class="lineno"> 5252 </span><span class="spaces">      </span><span class="istickedoff">where qname = qualify name</span>
<span class="lineno"> 5253 </span><span class="spaces">            </span><span class="istickedoff">fakeFileName = Text.unpack $ &quot;&lt;type of &quot; &lt;&gt; name &lt;&gt; &quot;&gt;&quot;</span>
<span class="lineno"> 5254 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5255 </span><span class="spaces">    </span><span class="istickedoff">pureVal :: forall t. IsValue t =&gt; t -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 5256 </span><span class="spaces">    </span><span class="istickedoff">pureVal x _ _ = toValue x</span>
<span class="lineno"> 5257 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5258 </span><span class="spaces">    </span><span class="istickedoff">funVal1 :: forall a t. (FromValue a, IsValue t) =&gt; (a -&gt; TopLevel t)</span>
<span class="lineno"> 5259 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 5260 </span><span class="spaces">    </span><span class="istickedoff">funVal1 f _ _ = VLambda $ \a -&gt; fmap toValue (f (fromValue a))</span>
<span class="lineno"> 5261 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5262 </span><span class="spaces">    </span><span class="istickedoff">funVal2 :: forall a b t. (FromValue a, FromValue b, IsValue t) =&gt; (a -&gt; b -&gt; TopLevel t)</span>
<span class="lineno"> 5263 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 5264 </span><span class="spaces">    </span><span class="istickedoff">funVal2 f _ _ = VLambda $ \a -&gt; return $ VLambda $ \b -&gt;</span>
<span class="lineno"> 5265 </span><span class="spaces">      </span><span class="istickedoff">fmap toValue (f (fromValue a) (fromValue b))</span>
<span class="lineno"> 5266 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5267 </span><span class="spaces">    </span><span class="istickedoff">funVal3 :: forall a b c t. (FromValue a, FromValue b, FromValue c, IsValue t) =&gt; (a -&gt; b -&gt; c -&gt; TopLevel t)</span>
<span class="lineno"> 5268 </span><span class="spaces">               </span><span class="istickedoff">-&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 5269 </span><span class="spaces">    </span><span class="istickedoff">funVal3 f _ _ = VLambda $ \a -&gt; return $ VLambda $ \b -&gt; return $ VLambda $ \c -&gt;</span>
<span class="lineno"> 5270 </span><span class="spaces">      </span><span class="istickedoff">fmap toValue (f (fromValue a) (fromValue b) (fromValue c))</span>
<span class="lineno"> 5271 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5272 </span><span class="spaces">    </span><span class="istickedoff">scVal :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 5273 </span><span class="spaces">             </span><span class="istickedoff">(SharedContext -&gt; t) -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 5274 </span><span class="spaces">    </span><span class="istickedoff">scVal f _ bic = toValue (f (biSharedContext bic))</span>
<span class="lineno"> 5275 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 5276 </span><span class="spaces">    </span><span class="istickedoff">bicVal :: forall t. IsValue t =&gt;</span>
<span class="lineno"> 5277 </span><span class="spaces">              </span><span class="istickedoff">(BuiltinContext -&gt; Options -&gt; t) -&gt; Options -&gt; BuiltinContext -&gt; Value</span>
<span class="lineno"> 5278 </span><span class="spaces">    </span><span class="istickedoff">bicVal f opts bic = toValue (f <span class="nottickedoff">bic</span> <span class="nottickedoff">opts</span>)</span></span>
<span class="lineno"> 5279 </span>
<span class="lineno"> 5280 </span>
<span class="lineno"> 5281 </span>-- FUTURE: extract here is now functionally a nop, so if things don't
<span class="lineno"> 5282 </span>-- change going forward we should consider simplifying so primTypes
<span class="lineno"> 5283 </span>-- uses the same type as the interprer environment this function
<span class="lineno"> 5284 </span>-- seeds, instead of its own.
<span class="lineno"> 5285 </span>primNamedTypeEnv :: Map SS.Name (PrimitiveLifecycle, SS.NamedType)
<span class="lineno"> 5286 </span><span class="decl"><span class="istickedoff">primNamedTypeEnv = fmap extract primTypes</span>
<span class="lineno"> 5287 </span><span class="spaces">   </span><span class="istickedoff">where extract pt = (primTypeLife pt, primTypeType pt)</span></span>
<span class="lineno"> 5288 </span>
<span class="lineno"> 5289 </span>primValueEnv :: Options -&gt; BuiltinContext -&gt; Map SS.LName (PrimitiveLifecycle, SS.Schema, Value)
<span class="lineno"> 5290 </span><span class="decl"><span class="istickedoff">primValueEnv opts bic = fmap extract primitives</span>
<span class="lineno"> 5291 </span><span class="spaces">  </span><span class="istickedoff">where extract p = (primitiveLife p, primitiveType p, (primitiveFn p) <span class="nottickedoff">opts</span> bic)</span></span>
<span class="lineno"> 5292 </span>
<span class="lineno"> 5293 </span>-- | Map containing the formatted documentation string for each
<span class="lineno"> 5294 </span>-- saw-script primitive.
<span class="lineno"> 5295 </span>primDocEnv :: Map SS.Name String
<span class="lineno"> 5296 </span><span class="decl"><span class="nottickedoff">primDocEnv =</span>
<span class="lineno"> 5297 </span><span class="spaces">  </span><span class="nottickedoff">Map.fromList [ (getVal n, doc n p) | (n, p) &lt;- Map.toList primitives ]</span>
<span class="lineno"> 5298 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno"> 5299 </span><span class="spaces">      </span><span class="nottickedoff">tag p = case primitiveLife p of</span>
<span class="lineno"> 5300 </span><span class="spaces">                </span><span class="nottickedoff">Current -&gt; []</span>
<span class="lineno"> 5301 </span><span class="spaces">                </span><span class="nottickedoff">WarnDeprecated -&gt; [&quot;DEPRECATED AND WILL WARN&quot;, &quot;&quot;]</span>
<span class="lineno"> 5302 </span><span class="spaces">                </span><span class="nottickedoff">HideDeprecated -&gt; [&quot;DEPRECATED AND UNAVAILABLE BY DEFAULT&quot;, &quot;&quot;]</span>
<span class="lineno"> 5303 </span><span class="spaces">                </span><span class="nottickedoff">Experimental -&gt; [&quot;EXPERIMENTAL&quot;, &quot;&quot;]</span>
<span class="lineno"> 5304 </span><span class="spaces">      </span><span class="nottickedoff">doc n p = unlines $</span>
<span class="lineno"> 5305 </span><span class="spaces">                </span><span class="nottickedoff">[ &quot;Description&quot;</span>
<span class="lineno"> 5306 </span><span class="spaces">                </span><span class="nottickedoff">, &quot;-----------&quot;</span>
<span class="lineno"> 5307 </span><span class="spaces">                </span><span class="nottickedoff">, &quot;&quot;</span>
<span class="lineno"> 5308 </span><span class="spaces">                </span><span class="nottickedoff">] ++ tag p ++</span>
<span class="lineno"> 5309 </span><span class="spaces">                </span><span class="nottickedoff">[ &quot;    &quot; ++ Text.unpack (getVal n) ++ &quot; : &quot; ++ PPS.pShow (primitiveType p)</span>
<span class="lineno"> 5310 </span><span class="spaces">                </span><span class="nottickedoff">, &quot;&quot;</span>
<span class="lineno"> 5311 </span><span class="spaces">                </span><span class="nottickedoff">] ++ primitiveDoc p</span></span>
<span class="lineno"> 5312 </span>
<span class="lineno"> 5313 </span>qualify :: Text -&gt; Located SS.Name
<span class="lineno"> 5314 </span><span class="decl"><span class="istickedoff">qualify s = Located s <span class="nottickedoff">s</span> <span class="nottickedoff">(SS.PosInternal &quot;coreEnv&quot;)</span></span></span>

</pre>
</body>
</html>
