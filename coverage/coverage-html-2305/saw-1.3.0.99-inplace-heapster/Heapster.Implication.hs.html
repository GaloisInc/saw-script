<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    2 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    5 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">    6 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">    7 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    8 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">   10 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   11 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   12 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   14 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   15 </span>{-# LANGUAGE FunctionalDependencies #-}
<span class="lineno">   16 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   17 </span>{-# LANGUAGE PartialTypeSignatures #-}
<span class="lineno">   18 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   19 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   20 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   21 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   22 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   23 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   24 </span>{-# LANGUAGE TupleSections #-}
<span class="lineno">   25 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   26 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">   27 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>module Heapster.Implication where
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>import Data.Maybe
<span class="lineno">   32 </span>import Data.List
<span class="lineno">   33 </span>import Data.Functor.Compose
<span class="lineno">   34 </span>import Data.Reflection
<span class="lineno">   35 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   36 </span>import GHC.TypeLits (KnownNat)
<span class="lineno">   37 </span>import Control.Lens hiding ((:&gt;), ix)
<span class="lineno">   38 </span>import qualified Control.Applicative as App
<span class="lineno">   39 </span>import Control.Monad (forM_)
<span class="lineno">   40 </span>import Control.Monad.Extra (concatMapM)
<span class="lineno">   41 </span>import Control.Monad.State.Strict (MonadState(..), State, StateT, evalState, execStateT)
<span class="lineno">   42 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>import qualified Data.Type.RList as RL
<span class="lineno">   45 </span>import Data.Binding.Hobbits.MonadBind
<span class="lineno">   46 </span>import Data.Binding.Hobbits.NameMap (NameMap, NameAndElem(..))
<span class="lineno">   47 </span>import qualified Data.Binding.Hobbits.NameMap as NameMap
<span class="lineno">   48 </span>import Data.Binding.Hobbits.NameSet (NameSet)
<span class="lineno">   49 </span>import qualified Data.Binding.Hobbits.NameSet as NameSet
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>import Prettyprinter as PP
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>import Data.Parameterized.BoolRepr
<span class="lineno">   54 </span>import Data.Parameterized.TraversableF
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import Lang.Crucible.Types
<span class="lineno">   57 </span>import Lang.Crucible.LLVM.DataLayout
<span class="lineno">   58 </span>import Lang.Crucible.LLVM.MemModel
<span class="lineno">   59 </span>import Lang.Crucible.CFG.Core
<span class="lineno">   60 </span>import Lang.Crucible.FunctionHandle
<span class="lineno">   61 </span>import SAWCore.Term.Functor (Ident)
<span class="lineno">   62 </span>import Lang.Crucible.LLVM.Bytes
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>import Data.Binding.Hobbits
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>import Heapster.Panic
<span class="lineno">   67 </span>import Heapster.CruUtil
<span class="lineno">   68 </span>import Heapster.PatternMatchUtil
<span class="lineno">   69 </span>import Heapster.Permissions
<span class="lineno">   70 </span>import Heapster.GenMonad
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>import GHC.Stack
<span class="lineno">   73 </span>import Unsafe.Coerce
<span class="lineno">   74 </span>import Data.Functor.Constant (Constant(..))
<span class="lineno">   75 </span>import Data.Functor.Product (Product(..))
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>----------------------------------------------------------------------
<span class="lineno">   80 </span>-- * Equality Proofs
<span class="lineno">   81 </span>----------------------------------------------------------------------
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>-- | An equality permission @x:eq(e)@ read as an an equality @x=e@ or @e=x@,
<span class="lineno">   84 </span>-- where the 'Bool' flag is 'True' for the former and 'False' for the latter
<span class="lineno">   85 </span>data EqPerm a = EqPerm (ExprVar a) (PermExpr a) Bool
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>-- | Get the LHS of the equation represented by an 'EqPerm'
<span class="lineno">   88 </span>eqPermLHS :: EqPerm a -&gt; PermExpr a
<span class="lineno">   89 </span><span class="decl"><span class="nottickedoff">eqPermLHS (EqPerm x _ True) = PExpr_Var x</span>
<span class="lineno">   90 </span><span class="spaces"></span><span class="nottickedoff">eqPermLHS (EqPerm _ e False) = e</span></span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>-- | Get the RHS of the equation represented by an 'EqPerm'
<span class="lineno">   93 </span>eqPermRHS :: EqPerm a -&gt; PermExpr a
<span class="lineno">   94 </span><span class="decl"><span class="nottickedoff">eqPermRHS (EqPerm _ e True) = e</span>
<span class="lineno">   95 </span><span class="spaces"></span><span class="nottickedoff">eqPermRHS (EqPerm x _ False) = PExpr_Var x</span></span>
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- | Get the variable out of an 'EqPerm'
<span class="lineno">   98 </span>eqPermVar :: EqPerm a -&gt; ExprVar a
<span class="lineno">   99 </span><span class="decl"><span class="nottickedoff">eqPermVar (EqPerm x _ _) = x</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- | Get the permission @eq(e)@ out of an 'EqPerm'
<span class="lineno">  102 </span>eqPermPerm :: EqPerm a -&gt; ValuePerm a
<span class="lineno">  103 </span><span class="decl"><span class="nottickedoff">eqPermPerm (EqPerm _ e _) = ValPerm_Eq e</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- | Get the variable and permission out of an 'EqPerm'
<span class="lineno">  106 </span>eqPermVarAndPerm :: EqPerm a -&gt; VarAndPerm a
<span class="lineno">  107 </span><span class="decl"><span class="nottickedoff">eqPermVarAndPerm (EqPerm x e _) = VarAndPerm x (ValPerm_Eq e)</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>-- | Apply symmetry to an 'EqPerm', changing an @e1=e2@ proof to @e2=e1@
<span class="lineno">  110 </span>eqPermSym :: EqPerm a -&gt; EqPerm a
<span class="lineno">  111 </span><span class="decl"><span class="nottickedoff">eqPermSym (EqPerm x e flag) = EqPerm x e (not flag)</span></span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>-- | A single step of an equality proof on some type @a@ is a sequence of @N@
<span class="lineno">  114 </span>-- 'EqPerms', each of which specifies a LHS and a RHS expression (one of which
<span class="lineno">  115 </span>-- is a variable), along with a function @f@ from these @N@ expressions to an
<span class="lineno">  116 </span>-- @a@. This represents a proof that @f es_lhs = f es_rhs@, where @es_lhs@ and
<span class="lineno">  117 </span>-- @es_rhs@ are the LHS and RHS expressions, respectively, of the 'EqPerm's.
<span class="lineno">  118 </span>data EqProofStep ps a = EqProofStep (RAssign EqPerm ps) (PermExprs ps -&gt; a)
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>-- | Get the left-hand side of an 'EqProofStep'
<span class="lineno">  121 </span>eqProofStepLHS :: EqProofStep ps a -&gt; a
<span class="lineno">  122 </span><span class="decl"><span class="nottickedoff">eqProofStepLHS (EqProofStep eq_perms f) = f (RL.map eqPermLHS eq_perms)</span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- | Get the right-hand side of an 'EqProofStep'
<span class="lineno">  125 </span>eqProofStepRHS :: EqProofStep ps a -&gt; a
<span class="lineno">  126 </span><span class="decl"><span class="nottickedoff">eqProofStepRHS (EqProofStep eq_perms f) = f (RL.map eqPermRHS eq_perms)</span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- | Get the equality permissions required by an 'EqProofStep'
<span class="lineno">  129 </span>eqProofStepPerms :: EqProofStep ps a -&gt; DistPerms ps
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">eqProofStepPerms (EqProofStep eq_perms _) = RL.map eqPermVarAndPerm eq_perms</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- | Get the equalities required by an 'EqProofStep'
<span class="lineno">  133 </span>eqProofStepEqs :: EqProofStep ps a -&gt; RAssign EqPerm ps
<span class="lineno">  134 </span><span class="decl"><span class="nottickedoff">eqProofStepEqs (EqProofStep eq_perms _) = eq_perms</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>instance <span class="decl"><span class="nottickedoff">Functor (EqProofStep ps)</span></span> where
<span class="lineno">  137 </span>  <span class="decl"><span class="nottickedoff">fmap f (EqProofStep eq_perms g) = EqProofStep eq_perms (f . g)</span></span>
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>-- | Build a reflexive 'EqProofStep' that any object equals itself. The
<span class="lineno">  140 </span>-- resulting proof uses no 'EqPerm's. This function along with
<span class="lineno">  141 </span>-- 'eqProofStepLiftA2' forms a parameterized 'Applicative', where the @ps@
<span class="lineno">  142 </span>-- argument changes when we combine proofs but otherwise satisfies the
<span class="lineno">  143 </span>-- 'Applicative' laws.
<span class="lineno">  144 </span>eqProofStepRefl :: a -&gt; EqProofStep RNil a
<span class="lineno">  145 </span><span class="decl"><span class="nottickedoff">eqProofStepRefl a = EqProofStep MNil (const a)</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>-- | Apply symmetry to a 'EqProofStep', changing an @e1=e2@ proof to @e2=e1@
<span class="lineno">  148 </span>eqProofStepSym :: EqProofStep ps a -&gt; EqProofStep ps a
<span class="lineno">  149 </span><span class="decl"><span class="nottickedoff">eqProofStepSym (EqProofStep eq_perms f) =</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="nottickedoff">EqProofStep (RL.map eqPermSym eq_perms) f</span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- | Combine two 'EqProofStep's using a function, similar to the 'liftA2' method
<span class="lineno">  153 </span>-- of 'Applicative'. The result uses the 'EqPerm's of both proofs. This function
<span class="lineno">  154 </span>-- along with 'eqProofStepRefl' forms a parameterized 'Applicative', where the
<span class="lineno">  155 </span>-- @ps@ argument changes when we combine proofs but otherwise satisfies the
<span class="lineno">  156 </span>-- 'Applicative' laws.
<span class="lineno">  157 </span>eqProofStepLiftA2 :: (a -&gt; b -&gt; c) -&gt; EqProofStep ps1 a -&gt; EqProofStep ps2 b -&gt;
<span class="lineno">  158 </span>                     EqProofStep (ps1 :++: ps2) c
<span class="lineno">  159 </span><span class="decl"><span class="nottickedoff">eqProofStepLiftA2 f (EqProofStep eq_perms1 g1) (EqProofStep eq_perms2 g2) =</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">EqProofStep (RL.append eq_perms1 eq_perms2) $ \es -&gt;</span>
<span class="lineno">  161 </span><span class="spaces">  </span><span class="nottickedoff">let (es1, es2) = RL.split eq_perms1 eq_perms2 es in</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="nottickedoff">f (g1 es1) (g2 es2)</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>-- | Build an 'EqProofStep' for @(e1,...,en)=(x1,...,xn)@ from permissions
<span class="lineno">  165 </span>-- @x1:eq(e1),...,xn:eq(en)@
<span class="lineno">  166 </span>eqProofStepFromPermsRev :: RAssign ExprVar as -&gt; PermExprs as -&gt;
<span class="lineno">  167 </span>                           EqProofStep as (PermExprs as)
<span class="lineno">  168 </span><span class="decl"><span class="nottickedoff">eqProofStepFromPermsRev xs es =</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="nottickedoff">EqProofStep (RL.map2 (\x e -&gt; EqPerm x e False) xs es) id</span></span>
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>-- | A proof that two objects are equal, using 0 or more 'EqProofStep' steps
<span class="lineno">  172 </span>data EqProof ps a where
<span class="lineno">  173 </span>  EqProofRefl :: a -&gt; EqProof RNil a
<span class="lineno">  174 </span>  EqProofCons :: EqProof ps1 a -&gt; EqProofStep ps2 a -&gt;
<span class="lineno">  175 </span>                 EqProof (ps1 :++: ps2) a
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>-- NOTE: this can be done but requires a lot of type-level equality proofs
<span class="lineno">  178 </span>{-
<span class="lineno">  179 </span>-- | Construct an 'EqProof' by transitivity, checking that the RHS of the first
<span class="lineno">  180 </span>-- proof equals the LHS of the second
<span class="lineno">  181 </span>eqProofTrans :: Eq a =&gt; EqProof ps1 a -&gt; EqProof ps2 a -&gt;
<span class="lineno">  182 </span>                EqProof (ps1 :++: ps2) a
<span class="lineno">  183 </span>eqProofTrans eqp (EqProofRefl a) | eqProofRHS eqp == a = eqp
<span class="lineno">  184 </span>-- FIXME: need to prove RNil :++: ps2 :~: ps2
<span class="lineno">  185 </span>--eqProofTrans EqProofRefl eqp = eqp
<span class="lineno">  186 </span>eqProofTrans eqp1 eqp2
<span class="lineno">  187 </span>  | eqProofRHS eqp1 == eqProofLHS eqp2
<span class="lineno">  188 </span>  = EqProofTrans eqp1 eqp2
<span class="lineno">  189 </span>eqProofTrans _ _ = error &quot;eqProofTrans&quot;
<span class="lineno">  190 </span>-}
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>-- | Get the LHS of an 'EqProof'
<span class="lineno">  193 </span>eqProofLHS :: EqProof ps a -&gt; a
<span class="lineno">  194 </span><span class="decl"><span class="nottickedoff">eqProofLHS (EqProofRefl a) = a</span>
<span class="lineno">  195 </span><span class="spaces"></span><span class="nottickedoff">eqProofLHS (EqProofCons eqp1 _) = eqProofLHS eqp1</span></span>
<span class="lineno">  196 </span>
<span class="lineno">  197 </span>-- | Get the RHS of an 'EqProof'
<span class="lineno">  198 </span>eqProofRHS :: EqProof ps a -&gt; a
<span class="lineno">  199 </span><span class="decl"><span class="nottickedoff">eqProofRHS (EqProofRefl a) = a</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="nottickedoff">eqProofRHS (EqProofCons _ eq_step) = eqProofStepRHS eq_step</span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>-- | Get the permissions needed by an 'EqProof'
<span class="lineno">  203 </span>eqProofPerms :: EqProof ps a -&gt; DistPerms ps
<span class="lineno">  204 </span><span class="decl"><span class="nottickedoff">eqProofPerms (EqProofRefl _) = DistPermsNil</span>
<span class="lineno">  205 </span><span class="spaces"></span><span class="nottickedoff">eqProofPerms (EqProofCons eqp eq_step) =</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (eqProofPerms eqp) (eqProofStepPerms eq_step)</span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | Build an 'EqProof' from a single 'EqProofStep'
<span class="lineno">  209 </span>eqProofFromStep :: EqProofStep ps a -&gt; EqProof ps a
<span class="lineno">  210 </span><span class="decl"><span class="nottickedoff">eqProofFromStep eq_step</span>
<span class="lineno">  211 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- RL.prependRNilEq (eqProofStepPerms eq_step)</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="nottickedoff">= EqProofCons (EqProofRefl $ eqProofStepLHS eq_step) eq_step</span></span>
<span class="lineno">  213 </span>
<span class="lineno">  214 </span>-- | Build an 'EqProof' that @(e1,...,en)=(x1,...,xn)@ from permissions
<span class="lineno">  215 </span>-- @x1:eq(e1),...,xn:eq(en)@
<span class="lineno">  216 </span>eqProofFromPermsRev :: RAssign ExprVar as -&gt; PermExprs as -&gt;
<span class="lineno">  217 </span>                       EqProof as (PermExprs as)
<span class="lineno">  218 </span><span class="decl"><span class="nottickedoff">eqProofFromPermsRev xs es = eqProofFromStep $ eqProofStepFromPermsRev xs es</span></span>
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>instance <span class="decl"><span class="nottickedoff">Functor (EqProof ps)</span></span> where
<span class="lineno">  221 </span>  <span class="decl"><span class="nottickedoff">fmap f (EqProofRefl a) = EqProofRefl $ f a</span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="nottickedoff">fmap f (EqProofCons eqp eq_step) =</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="nottickedoff">EqProofCons (fmap f eqp) (fmap f eq_step)</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>-- | An equality proof using some unknown set of permissions
<span class="lineno">  226 </span>data SomeEqProof a where
<span class="lineno">  227 </span>  SomeEqProofRefl :: a -&gt; SomeEqProof a
<span class="lineno">  228 </span>  SomeEqProofCons :: SomeEqProof a -&gt; EqProofStep ps a -&gt; SomeEqProof a
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>-- | Get the LHS of a 'SomeEqProof'
<span class="lineno">  231 </span>someEqProofLHS :: SomeEqProof a -&gt; a
<span class="lineno">  232 </span><span class="decl"><span class="nottickedoff">someEqProofLHS (SomeEqProofRefl a) = a</span>
<span class="lineno">  233 </span><span class="spaces"></span><span class="nottickedoff">someEqProofLHS (SomeEqProofCons some_eqp _) = someEqProofLHS some_eqp</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>-- | Get the RHS of a 'SomeEqProof'
<span class="lineno">  236 </span>someEqProofRHS :: SomeEqProof a -&gt; a
<span class="lineno">  237 </span><span class="decl"><span class="nottickedoff">someEqProofRHS (SomeEqProofRefl a) = a</span>
<span class="lineno">  238 </span><span class="spaces"></span><span class="nottickedoff">someEqProofRHS (SomeEqProofCons _ eq_step) = eqProofStepRHS eq_step</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>-- | Get all the equality permissions used by a 'SomeEqProof'
<span class="lineno">  241 </span>someEqProofEqs :: SomeEqProof a -&gt; Some (RAssign EqPerm)
<span class="lineno">  242 </span><span class="decl"><span class="nottickedoff">someEqProofEqs (SomeEqProofRefl _) = Some MNil</span>
<span class="lineno">  243 </span><span class="spaces"></span><span class="nottickedoff">someEqProofEqs (SomeEqProofCons some_eqp eq_step) =</span>
<span class="lineno">  244 </span><span class="spaces">  </span><span class="nottickedoff">apSomeRAssign (Some $ eqProofStepEqs eq_step) (someEqProofEqs some_eqp)</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>-- | Get all the equality permissions used by a 'SomeEqProof'
<span class="lineno">  247 </span>someEqProofPerms :: SomeEqProof a -&gt; Some DistPerms
<span class="lineno">  248 </span><span class="decl"><span class="nottickedoff">someEqProofPerms (SomeEqProofRefl _) = Some MNil</span>
<span class="lineno">  249 </span><span class="spaces"></span><span class="nottickedoff">someEqProofPerms (SomeEqProofCons some_eqp eq_step)</span>
<span class="lineno">  250 </span><span class="spaces">  </span><span class="nottickedoff">| Some ps &lt;- someEqProofPerms some_eqp =</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="nottickedoff">Some (RL.append ps $ eqProofStepPerms eq_step)</span></span>
<span class="lineno">  252 </span>
<span class="lineno">  253 </span>someEqProofPP :: PermPretty a =&gt; PPInfo -&gt; SomeEqProof a -&gt; Doc ann
<span class="lineno">  254 </span><span class="decl"><span class="nottickedoff">someEqProofPP i pf =</span>
<span class="lineno">  255 </span><span class="spaces">                </span><span class="nottickedoff">pretty &quot;SomeEqProof:&quot;</span>
<span class="lineno">  256 </span><span class="spaces">                </span><span class="nottickedoff">&lt;+&gt; permPretty i (someEqProofLHS pf)</span>
<span class="lineno">  257 </span><span class="spaces">                </span><span class="nottickedoff">&lt;+&gt; pretty &quot;=&quot;</span>
<span class="lineno">  258 </span><span class="spaces">                </span><span class="nottickedoff">&lt;+&gt; permPretty i (someEqProofRHS pf)</span>
<span class="lineno">  259 </span><span class="spaces">                </span><span class="nottickedoff">&lt;+&gt; line</span>
<span class="lineno">  260 </span><span class="spaces">                </span><span class="nottickedoff">&lt;+&gt; permPretty i (someEqProofPerms pf)</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>-- | Construct a 'SomeEqProof' for @x=e@ or @e=x@ using an @x:eq(e)@ permission,
<span class="lineno">  263 </span>-- where the 'Bool' flag is 'True' for @x=e@ and 'False' for @e=x@ like 'EqPerm'
<span class="lineno">  264 </span>someEqProof1 :: ExprVar a -&gt; PermExpr a -&gt; Bool -&gt; SomeEqProof (PermExpr a)
<span class="lineno">  265 </span><span class="decl"><span class="nottickedoff">someEqProof1 x e flag =</span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="nottickedoff">let eq_step = EqProofStep (MNil :&gt;: EqPerm x e flag) (\(_ :&gt;: e') -&gt; e') in</span>
<span class="lineno">  267 </span><span class="spaces">  </span><span class="nottickedoff">SomeEqProofCons (SomeEqProofRefl $ eqProofStepLHS eq_step) eq_step</span></span>
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>-- | A 'SomeEqProof' for the identity @x = x &amp;+ 0@
<span class="lineno">  270 </span>someEqProofZeroOffset :: (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  271 </span>                         SomeEqProof (PermExpr (LLVMPointerType w))
<span class="lineno">  272 </span><span class="decl"><span class="nottickedoff">someEqProofZeroOffset x =</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="nottickedoff">someEqProof1 x (PExpr_LLVMOffset x (zeroOfType (BVRepr knownNat))) True</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | Apply symmetry to a 'SomeEqProof', changing an @e1=e2@ proof to @e2=e1@
<span class="lineno">  276 </span>someEqProofSym :: SomeEqProof a -&gt; SomeEqProof a
<span class="lineno">  277 </span><span class="decl"><span class="nottickedoff">someEqProofSym eqp_top =</span>
<span class="lineno">  278 </span><span class="spaces">  </span><span class="nottickedoff">helper eqp_top (SomeEqProofRefl $ someEqProofRHS eqp_top) where</span>
<span class="lineno">  279 </span><span class="spaces">  </span><span class="nottickedoff">-- helper implements someEqProofSym using an accumulator</span>
<span class="lineno">  280 </span><span class="spaces">  </span><span class="nottickedoff">helper :: SomeEqProof a -&gt; SomeEqProof a -&gt; SomeEqProof a</span>
<span class="lineno">  281 </span><span class="spaces">  </span><span class="nottickedoff">helper (SomeEqProofRefl _) accum = accum</span>
<span class="lineno">  282 </span><span class="spaces">  </span><span class="nottickedoff">helper (SomeEqProofCons eqp step) accum =</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="nottickedoff">helper eqp (SomeEqProofCons accum (eqProofStepSym step))</span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- | Construct a 'SomeEqProof' by transitivity
<span class="lineno">  286 </span>someEqProofTrans :: Eq a =&gt; SomeEqProof a -&gt; SomeEqProof a -&gt; SomeEqProof a
<span class="lineno">  287 </span><span class="decl"><span class="nottickedoff">someEqProofTrans some_eqp1 some_eqp2</span>
<span class="lineno">  288 </span><span class="spaces">  </span><span class="nottickedoff">| someEqProofRHS some_eqp1 == someEqProofLHS some_eqp2 =</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="nottickedoff">someEqProofTrans' some_eqp1 some_eqp2</span>
<span class="lineno">  290 </span><span class="spaces"></span><span class="nottickedoff">someEqProofTrans _ _ = error &quot;someEqProofTrans&quot;</span></span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>-- | Unchecked version of 'someEqProofTrans'
<span class="lineno">  293 </span>someEqProofTrans' :: SomeEqProof a -&gt; SomeEqProof a -&gt; SomeEqProof a
<span class="lineno">  294 </span><span class="decl"><span class="nottickedoff">someEqProofTrans' some_eqp (SomeEqProofRefl _) = some_eqp</span>
<span class="lineno">  295 </span><span class="spaces"></span><span class="nottickedoff">someEqProofTrans' some_eqp1 (SomeEqProofCons some_eqp2 eq_step) =</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="nottickedoff">SomeEqProofCons (someEqProofTrans' some_eqp1 some_eqp2) eq_step</span></span>
<span class="lineno">  297 </span>
<span class="lineno">  298 </span>instance <span class="decl"><span class="nottickedoff">Functor SomeEqProof</span></span> where
<span class="lineno">  299 </span>  <span class="decl"><span class="nottickedoff">fmap f (SomeEqProofRefl a) = SomeEqProofRefl $ f a</span>
<span class="lineno">  300 </span><span class="spaces">  </span><span class="nottickedoff">fmap f (SomeEqProofCons some_eqp eq_step) =</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="nottickedoff">SomeEqProofCons (fmap f some_eqp) (fmap f eq_step)</span></span>
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>-- NOTE: this is possible, but it requires a lot of type-level equality proofs
<span class="lineno">  304 </span>{-
<span class="lineno">  305 </span>-- | A version of 'liftA2' for 'EqProof', which, like 'eqProofStepLiftA2', forms
<span class="lineno">  306 </span>-- a parameterized 'Applicative'
<span class="lineno">  307 </span>eqProofLiftA2 :: (a -&gt; b -&gt; c) -&gt; EqProof ps1 a -&gt; EqProof ps2 b -&gt;
<span class="lineno">  308 </span>                 EqProof (ps1 :++: ps2) c
<span class="lineno">  309 </span>eqProofLiftA2 f (EqProofRefl a) eqp
<span class="lineno">  310 </span>  -- NOTE: this is to prove RNil :++: ps2 ~ ps2
<span class="lineno">  311 </span>  | Refl &lt;- prependRNilEq (eqProofPerms eqp) = fmap (f a) eqp
<span class="lineno">  312 </span>eqProofLiftA2 f eqp (EqProofRefl b) = fmap (flip f b) eqp
<span class="lineno">  313 </span>eqProofLiftA2 f (EqProof1 eq_step1) (EqProof1 eq_step2) =
<span class="lineno">  314 </span>  EqProof1 (eqProofStepLiftA2 f eq_step1 eq_step2)
<span class="lineno">  315 </span>-}
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative SomeEqProof</span></span></span></span></span></span> where
<span class="lineno">  318 </span>  <span class="decl"><span class="nottickedoff">pure = SomeEqProofRefl</span></span>
<span class="lineno">  319 </span>  <span class="decl"><span class="nottickedoff">liftA2 f (SomeEqProofRefl a) some_eqp = fmap (f a) some_eqp</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="nottickedoff">liftA2 f some_eqp (SomeEqProofRefl b) = fmap (flip f b) some_eqp</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="nottickedoff">liftA2 f (SomeEqProofCons eqp1 step1) (SomeEqProofCons eqp2 step2) =</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="nottickedoff">SomeEqProofCons (App.liftA2 f eqp1 eqp2) (eqProofStepLiftA2 f step1 step2)</span></span>
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>-- | An 'EqProofStep' with an existentially quantified list of permissions
<span class="lineno">  325 </span>data SomeEqProofStep a = forall ps. SomeEqProofStep (EqProofStep ps a)
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | Build an 'EqProofStep' by finding each free variable @x@ in an object that
<span class="lineno">  328 </span>-- has some equality permission @x:eq(e)@ in the supplied variable permission
<span class="lineno">  329 </span>-- map and substituting @e@ for @x@
<span class="lineno">  330 </span>eqProofStepFromSubst :: (AbstractVars a, FreeVars a,
<span class="lineno">  331 </span>                         Substable PermSubst a Identity) =&gt; NameMap ValuePerm -&gt;
<span class="lineno">  332 </span>                        a -&gt; SomeEqProofStep a
<span class="lineno">  333 </span><span class="decl"><span class="nottickedoff">eqProofStepFromSubst var_ps a</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="nottickedoff">| AbsObj vars cl_mb_a &lt;- abstractFreeVars a</span>
<span class="lineno">  335 </span><span class="spaces">  </span><span class="nottickedoff">, eq_perms &lt;- RL.map (\var -&gt; case NameMap.lookup var var_ps of</span>
<span class="lineno">  336 </span><span class="spaces">                           </span><span class="nottickedoff">Just (ValPerm_Eq e) -&gt; EqPerm var e True</span>
<span class="lineno">  337 </span><span class="spaces">                           </span><span class="nottickedoff">_ -&gt; EqPerm var (PExpr_Var var) True) vars =</span>
<span class="lineno">  338 </span><span class="spaces">    </span><span class="nottickedoff">SomeEqProofStep $</span>
<span class="lineno">  339 </span><span class="spaces">    </span><span class="nottickedoff">EqProofStep eq_perms (\es -&gt; subst (substOfExprs es) (unClosed cl_mb_a))</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>-- | Build a 'SomeEqProof' by finding each free variable @x@ in an object that
<span class="lineno">  342 </span>-- has some equality permission @x:eq(e)@ in the supplied variable permission
<span class="lineno">  343 </span>-- map and substituting @e@ for @x@
<span class="lineno">  344 </span>someEqProofFromSubst :: (AbstractVars a, FreeVars a,
<span class="lineno">  345 </span>                         Substable PermSubst a Identity) =&gt; NameMap ValuePerm -&gt;
<span class="lineno">  346 </span>                        a -&gt; SomeEqProof a
<span class="lineno">  347 </span><span class="decl"><span class="nottickedoff">someEqProofFromSubst var_ps a</span>
<span class="lineno">  348 </span><span class="spaces">  </span><span class="nottickedoff">| SomeEqProofStep eq_step &lt;- eqProofStepFromSubst var_ps a =</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="nottickedoff">SomeEqProofCons (SomeEqProofRefl a) eq_step</span></span>
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>-- | A 'SomeEqProof' that has been converted to an 'EqProof' with explicit perms
<span class="lineno">  352 </span>data UnSomeEqProof a = forall ps. UnSomeEqProof (EqProof ps a)
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>-- | Convert a 'SomeEqProof' to an 'EqProof'
<span class="lineno">  355 </span>unSomeEqProof :: SomeEqProof a -&gt; UnSomeEqProof a
<span class="lineno">  356 </span><span class="decl"><span class="nottickedoff">unSomeEqProof (SomeEqProofRefl a) = UnSomeEqProof $ EqProofRefl a</span>
<span class="lineno">  357 </span><span class="spaces"></span><span class="nottickedoff">unSomeEqProof (SomeEqProofCons some_eqp eq_step)</span>
<span class="lineno">  358 </span><span class="spaces">  </span><span class="nottickedoff">| UnSomeEqProof eqp &lt;- unSomeEqProof some_eqp =</span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="nottickedoff">UnSomeEqProof $ EqProofCons eqp eq_step</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>----------------------------------------------------------------------
<span class="lineno">  363 </span>-- * Implication Errors
<span class="lineno">  364 </span>----------------------------------------------------------------------
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>data ImplError where
<span class="lineno">  367 </span>  GeneralError :: Doc ann -&gt; ImplError
<span class="lineno">  368 </span>  NoFrameInScopeError :: ImplError
<span class="lineno">  369 </span>  ArrayStepError :: ImplError
<span class="lineno">  370 </span>  MuUnfoldError :: ImplError
<span class="lineno">  371 </span>  FunctionPermissionError :: ImplError
<span class="lineno">  372 </span>  PartialSubstitutionError :: String -&gt; Doc ann -&gt; ImplError
<span class="lineno">  373 </span>  LifetimeError :: LifetimeErrorType -&gt; ImplError
<span class="lineno">  374 </span>  MemBlockError :: Doc ann -&gt; ImplError
<span class="lineno">  375 </span>  EqualityProofError :: Doc ann -&gt; Doc ann -&gt; ImplError
<span class="lineno">  376 </span>  InsufficientVariablesError :: Doc ann -&gt; ImplError
<span class="lineno">  377 </span>  ExistentialError :: Doc ann -&gt; Doc ann -&gt; ImplError
<span class="lineno">  378 </span>  ImplVariableError
<span class="lineno">  379 </span>    :: Doc ann -&gt; String
<span class="lineno">  380 </span>    -&gt; (Doc ann, ExprVar tp) -&gt; (Doc ann, ValuePerm tp) -&gt; CruCtx vars
<span class="lineno">  381 </span>    -&gt; DistPerms ps
<span class="lineno">  382 </span>    -&gt; ImplError
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>data LifetimeErrorType where
<span class="lineno">  385 </span>  EndLifetimeError :: LifetimeErrorType
<span class="lineno">  386 </span>  ImplicationLifetimeError :: LifetimeErrorType
<span class="lineno">  387 </span>  LifetimeCurrentError :: PP.Doc ann -&gt; LifetimeErrorType
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(concatMapM mkNuMatching</span>
<span class="lineno">  390 </span><span class="spaces">  </span><span class="nottickedoff">[ [t| ImplError |]</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="nottickedoff">, [t| LifetimeErrorType |]</span>
<span class="lineno">  392 </span><span class="spaces">  </span><span class="nottickedoff">])</span></span></span></span></span>
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>instance Liftable LifetimeErrorType where
<span class="lineno">  395 </span>  <span class="decl"><span class="nottickedoff">mbLift e = case mbMatch e of</span>
<span class="lineno">  396 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| EndLifetimeError |] -&gt; EndLifetimeError</span>
<span class="lineno">  397 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ImplicationLifetimeError |] -&gt; ImplicationLifetimeError</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LifetimeCurrentError doc |] -&gt; LifetimeCurrentError $ mbLift doc</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  401 </span>    Substable PermVarSubst ImplError m where
<span class="lineno">  402 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_impl = case mbMatch mb_impl of</span>
<span class="lineno">  403 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| GeneralError doc |] -&gt;</span>
<span class="lineno">  404 </span><span class="spaces">      </span><span class="nottickedoff">return $ GeneralError $ mbLift doc</span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NoFrameInScopeError |] -&gt;</span>
<span class="lineno">  406 </span><span class="spaces">      </span><span class="nottickedoff">return NoFrameInScopeError</span>
<span class="lineno">  407 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ArrayStepError |] -&gt;</span>
<span class="lineno">  408 </span><span class="spaces">      </span><span class="nottickedoff">return ArrayStepError</span>
<span class="lineno">  409 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MuUnfoldError |] -&gt;</span>
<span class="lineno">  410 </span><span class="spaces">      </span><span class="nottickedoff">return MuUnfoldError</span>
<span class="lineno">  411 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| FunctionPermissionError |] -&gt;</span>
<span class="lineno">  412 </span><span class="spaces">      </span><span class="nottickedoff">return FunctionPermissionError</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PartialSubstitutionError str doc |] -&gt;</span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="nottickedoff">return $ PartialSubstitutionError (mbLift str) (mbLift doc)</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| LifetimeError le |] -&gt;</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="nottickedoff">return $ LifetimeError $ mbLift le</span>
<span class="lineno">  417 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MemBlockError doc |] -&gt;</span>
<span class="lineno">  418 </span><span class="spaces">      </span><span class="nottickedoff">return $ MemBlockError (mbLift doc)</span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| EqualityProofError docl docr |] -&gt;</span>
<span class="lineno">  420 </span><span class="spaces">      </span><span class="nottickedoff">return $ EqualityProofError (mbLift docl) (mbLift docr)</span>
<span class="lineno">  421 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| InsufficientVariablesError doc |] -&gt;</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="nottickedoff">return $ InsufficientVariablesError $ mbLift doc</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ExistentialError doc1 doc2 |] -&gt;</span>
<span class="lineno">  424 </span><span class="spaces">      </span><span class="nottickedoff">return $ ExistentialError (mbLift doc1) (mbLift doc2)</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ImplVariableError doc f (xdoc, x) (pdoc, p) ctx mb_dp |] -&gt; do</span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="nottickedoff">x' &lt;- genSubst s x</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="nottickedoff">p' &lt;- genSubst s p</span>
<span class="lineno">  428 </span><span class="spaces">      </span><span class="nottickedoff">dp &lt;- genSubst s mb_dp</span>
<span class="lineno">  429 </span><span class="spaces">      </span><span class="nottickedoff">return $ ImplVariableError (mbLift doc) (mbLift f) (mbLift xdoc, x') (mbLift pdoc, p') (mbLift ctx) dp</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- The reason this isn't just Show is to sort of future-proof things. For
<span class="lineno">  432 </span>-- instance, we may want to dump a limited amount of information to stdout, but
<span class="lineno">  433 </span>-- something more comprehensive to a log for an IDE.
<span class="lineno">  434 </span>class ErrorPretty a where
<span class="lineno">  435 </span>  ppError :: a -&gt; String
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>----------------------------------------------------------------------
<span class="lineno">  438 </span>-- * Permission Implications
<span class="lineno">  439 </span>----------------------------------------------------------------------
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>-- | A simple implication is an implication that does not introduce any
<span class="lineno">  442 </span>-- variables or act on the 'varPermMap' part of a permission set. (Compare to
<span class="lineno">  443 </span>-- the more general 'PermImpl'.) It has the form
<span class="lineno">  444 </span>--
<span class="lineno">  445 </span>-- &gt; P1 * ... * Pn -o P1' * ... * Pm'
<span class="lineno">  446 </span>--
<span class="lineno">  447 </span>-- where the types of @P1@ through @Pn@ are given by the first type argument
<span class="lineno">  448 </span>-- @ps_in@ and those of @P1'@ through @Pm'@ are given by the second, @ps_out@.
<span class="lineno">  449 </span>--
<span class="lineno">  450 </span>-- To add a new @SimplImpl@ proof rule:
<span class="lineno">  451 </span>-- 1. Add a constructor @SImpl_NewConstructor@ and documentation to this
<span class="lineno">  452 </span>--    data structure
<span class="lineno">  453 </span>-- 2. Implement cases for the helper functions @simplImplIn@,
<span class="lineno">  454 </span>--    @simplImplOut@, and @genSubst@ for @SImpl_NewConstructor@
<span class="lineno">  455 </span>-- 3. Implement a wrapper @newConstructorM@ using @implSimplM@ to build up a
<span class="lineno">  456 </span>--    proof using that constructor in the @ImplM@ monad
<span class="lineno">  457 </span>-- 4. Implement the translation of the constructor by adding a case to
<span class="lineno">  458 </span>--    `translateSimplImpl` in `SAWTranslation.hs`.
<span class="lineno">  459 </span>data SimplImpl ps_in ps_out where
<span class="lineno">  460 </span>  -- | Drop a permission, i.e., forget about it:
<span class="lineno">  461 </span>  --
<span class="lineno">  462 </span>  -- &gt; x:p -o .
<span class="lineno">  463 </span>  SImpl_Drop :: ExprVar a -&gt; ValuePerm a -&gt; SimplImpl (RNil :&gt; a) RNil
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>  -- | Copy any copyable permission:
<span class="lineno">  466 </span>  --
<span class="lineno">  467 </span>  -- &gt; x:p -o x:p * x:p
<span class="lineno">  468 </span>  SImpl_Copy :: ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno">  469 </span>                SimplImpl (RNil :&gt; a) (RNil :&gt; a :&gt; a)
<span class="lineno">  470 </span>
<span class="lineno">  471 </span>  -- | Swap the top two permissions on the stack:
<span class="lineno">  472 </span>  --
<span class="lineno">  473 </span>  -- &gt; x:p1 * y:p2 -o y:p2 * x:p1
<span class="lineno">  474 </span>  SImpl_Swap :: ExprVar a -&gt; ValuePerm a -&gt; ExprVar b -&gt; ValuePerm b -&gt;
<span class="lineno">  475 </span>                SimplImpl (RNil :&gt; a :&gt; b) (RNil :&gt; b :&gt; a)
<span class="lineno">  476 </span>
<span class="lineno">  477 </span>  -- | Move permission @p@ that is on the stack below two lists @ps1@ and @ps2@
<span class="lineno">  478 </span>  -- towards the top of the stack by moving it between @ps1@ and @ps2@. That is,
<span class="lineno">  479 </span>  -- change the stack
<span class="lineno">  480 </span>  --
<span class="lineno">  481 </span>  -- &gt; x:p, ps1, ps2 -o ps1, x:p, ps2
<span class="lineno">  482 </span>  SImpl_MoveUp :: DistPerms ps1 -&gt; ExprVar a -&gt; ValuePerm a -&gt; DistPerms ps2 -&gt;
<span class="lineno">  483 </span>                  SimplImpl (RNil :&gt; a :++: ps1 :++: ps2) (ps1 :&gt; a :++: ps2)
<span class="lineno">  484 </span>
<span class="lineno">  485 </span>  -- | Move permission @p@ that is on the stack between two lists @ps1@ and
<span class="lineno">  486 </span>  -- @ps2@ towards the bottom of the stack by moving it below both @ps1@ and
<span class="lineno">  487 </span>  -- @ps2@. This inverts 'SImpl_MoveUp'. That is, change the stack
<span class="lineno">  488 </span>  --
<span class="lineno">  489 </span>  -- &gt; ps1, x:p, ps2 -o x:p, ps1, ps2
<span class="lineno">  490 </span>  SImpl_MoveDown :: DistPerms ps1 -&gt; ExprVar a -&gt; ValuePerm a -&gt; DistPerms ps2 -&gt;
<span class="lineno">  491 </span>                    SimplImpl (ps1 :&gt; a :++: ps2) (RNil :&gt; a :++: ps1 :++: ps2)
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>  -- | @SImpl_IntroOrL x p1 p2@ applies left disjunction introduction:
<span class="lineno">  494 </span>  --
<span class="lineno">  495 </span>  -- &gt; x:p1 -o x:(p1 \/ p2)
<span class="lineno">  496 </span>  SImpl_IntroOrL :: ExprVar a -&gt; ValuePerm a -&gt; ValuePerm a -&gt;
<span class="lineno">  497 </span>                    SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>  -- | @SImpl_IntroOrR x p1 p2 pf@ applies right disjunction introduction:
<span class="lineno">  500 </span>  --
<span class="lineno">  501 </span>  -- &gt; x:p2 -o x:(p1 \/ p2)
<span class="lineno">  502 </span>  SImpl_IntroOrR :: ExprVar a -&gt; ValuePerm a -&gt; ValuePerm a -&gt;
<span class="lineno">  503 </span>                    SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>  -- | @SImpl_IntroExists x e p@ applies existential introduction:
<span class="lineno">  506 </span>  --
<span class="lineno">  507 </span>  -- &gt; x:[e/z]p -o x:(exists z.p)
<span class="lineno">  508 </span>  SImpl_IntroExists :: KnownRepr TypeRepr tp =&gt; ExprVar a -&gt; PermExpr tp -&gt;
<span class="lineno">  509 </span>                       Binding tp (ValuePerm a) -&gt;
<span class="lineno">  510 </span>                       SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>  -- | Cast a proof of @y:p@ to one of @x:p@ using @x:eq(y)@:
<span class="lineno">  513 </span>  --
<span class="lineno">  514 </span>  -- &gt; x:eq(y) * y:p -o x:p
<span class="lineno">  515 </span>  SImpl_Cast :: ExprVar a -&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno">  516 </span>                SimplImpl (RNil :&gt; a :&gt; a) (RNil :&gt; a)
<span class="lineno">  517 </span>
<span class="lineno">  518 </span>  -- | Cast a proof of @x:p@ to one of @x:p'@ using a proof that @p=p'@ along
<span class="lineno">  519 </span>  -- with the equality permissions needed by that proof:
<span class="lineno">  520 </span>  --
<span class="lineno">  521 </span>  -- &gt; x:p, x1:eq(e1), ..., xn:eq(en) -o x:p', x1:eq(e1), ..., xn:eq(en)
<span class="lineno">  522 </span>  SImpl_CastPerm :: ExprVar a -&gt; EqProof ps (ValuePerm a) -&gt;
<span class="lineno">  523 </span>                    SimplImpl (RNil :&gt; a :++: ps) (RNil :&gt; a :++: ps)
<span class="lineno">  524 </span>
<span class="lineno">  525 </span>  -- | Introduce a proof that @x:eq(x)@:
<span class="lineno">  526 </span>  --
<span class="lineno">  527 </span>  -- &gt; . -o x:eq(x)
<span class="lineno">  528 </span>  SImpl_IntroEqRefl :: ExprVar a -&gt; SimplImpl RNil (RNil :&gt; a)
<span class="lineno">  529 </span>
<span class="lineno">  530 </span>  -- | Invert an @x:eq(y)@ permission into a @y:eq(x)@ permission:
<span class="lineno">  531 </span>  --
<span class="lineno">  532 </span>  -- &gt; x:eq(y) -o y:eq(x)
<span class="lineno">  533 </span>  SImpl_InvertEq :: ExprVar a -&gt; ExprVar a -&gt; SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno">  534 </span>
<span class="lineno">  535 </span>  -- | Prove @x:eq(y)@ by proving equality permissions for both @x@ and @y@ to
<span class="lineno">  536 </span>  -- the same expression, thereby implementing a form of transitivity of
<span class="lineno">  537 </span>  -- equality where the second equality is inversted:
<span class="lineno">  538 </span>  --
<span class="lineno">  539 </span>  -- &gt; x:eq(e) * y:eq(e) -o x:eq(y)
<span class="lineno">  540 </span>  SImpl_InvTransEq :: ExprVar a -&gt; ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno">  541 </span>                      SimplImpl (RNil :&gt; a :&gt; a) (RNil :&gt; a)
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>  -- | For any unit-typed variable @x@ and unit-type expression @e@, prove
<span class="lineno">  544 </span>  -- @x:eq(e)@
<span class="lineno">  545 </span>  --
<span class="lineno">  546 </span>  -- &gt; (x:unit,e:unit) . -o x:eq(e)
<span class="lineno">  547 </span>  SImpl_UnitEq :: ExprVar UnitType -&gt; PermExpr UnitType -&gt;
<span class="lineno">  548 </span>                  SimplImpl RNil (RNil :&gt; UnitType)
<span class="lineno">  549 </span>
<span class="lineno">  550 </span>  -- FIXME HERE: remove this in favor of SImpl_Copy
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>  -- | Copy an equality proof on the top of the stack:
<span class="lineno">  553 </span>  --
<span class="lineno">  554 </span>  -- &gt; x:eq(e) -o x:eq(e) * x:eq(e)
<span class="lineno">  555 </span>  SImpl_CopyEq :: ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno">  556 </span>                  SimplImpl (RNil :&gt; a) (RNil :&gt; a :&gt; a)
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>  -- | Cast an @eq(llvmword(y))@ proof to an @eq(llvmword(e))@ proof using a
<span class="lineno">  559 </span>  -- proof of @y:eq(e)@:
<span class="lineno">  560 </span>  --
<span class="lineno">  561 </span>  -- &gt; x:eq(llvmword(y)) * y:eq(e) -o x:eq(llvmword(e))
<span class="lineno">  562 </span>  SImpl_LLVMWordEq :: (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  563 </span>                      ExprVar (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  564 </span>                      SimplImpl (RNil :&gt; LLVMPointerType w :&gt; BVType w)
<span class="lineno">  565 </span>                      (RNil :&gt; LLVMPointerType w)
<span class="lineno">  566 </span>
<span class="lineno">  567 </span>  -- | The implication that @x@ is the same as @x &amp;+ 0@
<span class="lineno">  568 </span>  --
<span class="lineno">  569 </span>  -- &gt; . -o x:eq(x &amp;+ 0)
<span class="lineno">  570 </span>  SImpl_LLVMOffsetZeroEq :: (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  571 </span>                            SimplImpl RNil (RNil :&gt; LLVMPointerType w)
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>  -- | Introduce an empty conjunction on @x@, i.e.:
<span class="lineno">  574 </span>  --
<span class="lineno">  575 </span>  -- &gt; . -o x:true
<span class="lineno">  576 </span>  SImpl_IntroConj :: ExprVar a -&gt; SimplImpl RNil (RNil :&gt; a)
<span class="lineno">  577 </span>
<span class="lineno">  578 </span>  -- | Extract the @i@th atomic permission out of a conjunct, putting it below
<span class="lineno">  579 </span>  -- that conjunct on the stack:
<span class="lineno">  580 </span>  --
<span class="lineno">  581 </span>  -- &gt; x:(p0 * ... * p(n-1)) -o x:pi * x:(p0 * ... p(i-1) * p(i+1) ... * p(n-1))
<span class="lineno">  582 </span>  SImpl_ExtractConj :: ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno">  583 </span>                       SimplImpl (RNil :&gt; a) (RNil :&gt; a :&gt; a)
<span class="lineno">  584 </span>
<span class="lineno">  585 </span>  -- | Copy the @i@th atomic permission out of a conjunct, assuming it is
<span class="lineno">  586 </span>  -- copyable, putting it below that conjunct on the stack:
<span class="lineno">  587 </span>  --
<span class="lineno">  588 </span>  -- &gt; x:(p0 * ... * p (n-1)) -o x:pi * x:(p0 * ... * p(n-1))
<span class="lineno">  589 </span>  SImpl_CopyConj :: ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno">  590 </span>                    SimplImpl (RNil :&gt; a) (RNil :&gt; a :&gt; a)
<span class="lineno">  591 </span>
<span class="lineno">  592 </span>  -- | Insert an atomic permission below the top of the stack at the @i@th
<span class="lineno">  593 </span>  -- position in the conjunct on the top of the stack, where @i@ must be between
<span class="lineno">  594 </span>  -- @0@ and @n@ (the number of conjuncts), inclusive:
<span class="lineno">  595 </span>  --
<span class="lineno">  596 </span>  -- &gt; x:p * x:(p0 * ... * p(n-1))
<span class="lineno">  597 </span>  -- &gt;   -o x:(p0 * ... * p(i-1) * p * pi * ... * p(n-1))
<span class="lineno">  598 </span>  SImpl_InsertConj :: ExprVar a -&gt; AtomicPerm a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno">  599 </span>                      SimplImpl (RNil :&gt; a :&gt; a) (RNil :&gt; a)
<span class="lineno">  600 </span>
<span class="lineno">  601 </span>  -- | Combine the top two conjunctive permissions on the stack:
<span class="lineno">  602 </span>  --
<span class="lineno">  603 </span>  -- &gt; x:(p1 * ... * pi) * x:(pi+1 * ... * pn) -o x:(p1 * ... * pn)
<span class="lineno">  604 </span>  SImpl_AppendConjs :: ExprVar a -&gt; [AtomicPerm a] -&gt; [AtomicPerm a] -&gt;
<span class="lineno">  605 </span>                       SimplImpl (RNil :&gt; a :&gt; a) (RNil :&gt; a)
<span class="lineno">  606 </span>
<span class="lineno">  607 </span>  -- | Split the conjunctive permissions on the top of the stack in two:
<span class="lineno">  608 </span>  --
<span class="lineno">  609 </span>  -- &gt; x:(p1 * ... * pn) -o x:(p1 * ... * pi) * x:(pi+1 * ... * pn)
<span class="lineno">  610 </span>  SImpl_SplitConjs :: ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno">  611 </span>                      SimplImpl (RNil :&gt; a) (RNil :&gt; a :&gt; a)
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>  -- | Prove a struct permission of @true@ permissions on any struct:
<span class="lineno">  614 </span>  --
<span class="lineno">  615 </span>  -- &gt; -o x:struct(true, ..., true)
<span class="lineno">  616 </span>  SImpl_IntroStructTrue ::
<span class="lineno">  617 </span>    ExprVar (StructType ctx) -&gt; RAssign Proxy (CtxToRList ctx) -&gt;
<span class="lineno">  618 </span>    SimplImpl RNil (RNil :&gt; StructType ctx)
<span class="lineno">  619 </span>
<span class="lineno">  620 </span>  -- | Prove a struct permission of equality permissions from an equality
<span class="lineno">  621 </span>  -- permission to a struct:
<span class="lineno">  622 </span>  --
<span class="lineno">  623 </span>  -- &gt; x:eq(struct(e1, ..., en)) -o x:struct(eq(e1), ..., eq(en))
<span class="lineno">  624 </span>  SImpl_StructEqToPerm ::
<span class="lineno">  625 </span>    ExprVar (StructType ctx) -&gt; PermExprs (CtxToRList ctx) -&gt;
<span class="lineno">  626 </span>    SimplImpl (RNil :&gt; StructType ctx) (RNil :&gt; StructType ctx)
<span class="lineno">  627 </span>
<span class="lineno">  628 </span>  -- | Prove an equality permission to a struct from a struct permission of
<span class="lineno">  629 </span>  -- equality permissions:
<span class="lineno">  630 </span>  --
<span class="lineno">  631 </span>  -- &gt; x:struct(eq(e1), ..., eq(en)) -o x:eq(struct(e1, ..., en))
<span class="lineno">  632 </span>  SImpl_StructPermToEq ::
<span class="lineno">  633 </span>    ExprVar (StructType ctx) -&gt; PermExprs (CtxToRList ctx) -&gt;
<span class="lineno">  634 </span>    SimplImpl (RNil :&gt; StructType ctx) (RNil :&gt; StructType ctx)
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>  -- | Prove a permission @p@ on a struct field that is known to equal some
<span class="lineno">  637 </span>  -- variable @y@ using a proof of @y:p@:
<span class="lineno">  638 </span>  --
<span class="lineno">  639 </span>  -- &gt; x:struct(ps, eq(y), ps'), y:p -o x:struct(ps,p,ps')
<span class="lineno">  640 </span>  SImpl_IntroStructField ::
<span class="lineno">  641 </span>    ExprVar (StructType ctx) -&gt; RAssign ValuePerm (CtxToRList ctx) -&gt;
<span class="lineno">  642 </span>    Member (CtxToRList ctx) a -&gt; ValuePerm a -&gt;
<span class="lineno">  643 </span>    SimplImpl (RNil :&gt; StructType ctx :&gt; a) (RNil :&gt; StructType ctx)
<span class="lineno">  644 </span>
<span class="lineno">  645 </span>  -- | Prove a function permission for a statically-known function (assuming
<span class="lineno">  646 </span>  -- that the given entry is in the current function environment):
<span class="lineno">  647 </span>  --
<span class="lineno">  648 </span>  -- &gt; x:eq(handle) -o x:fun_perm
<span class="lineno">  649 </span>  SImpl_ConstFunPerm ::
<span class="lineno">  650 </span>    args ~ CtxToRList cargs =&gt;
<span class="lineno">  651 </span>    ExprVar (FunctionHandleType cargs ret) -&gt; FnHandle cargs ret -&gt;
<span class="lineno">  652 </span>    FunPerm ghosts (CtxToRList cargs) gouts ret -&gt; Ident -&gt;
<span class="lineno">  653 </span>    SimplImpl (RNil :&gt; FunctionHandleType cargs ret)
<span class="lineno">  654 </span>    (RNil :&gt; FunctionHandleType cargs ret)
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>  -- | Cast a proof of @x:eq(word(e1))@ to one of @x:eq(word(e2))@ using an
<span class="lineno">  657 </span>  -- equality permission @e1=e2@ on top of the stack:
<span class="lineno">  658 </span>  --
<span class="lineno">  659 </span>  -- &gt; x:eq(word(e1)) * x:prop(e1=e2) -o x:eq(word(e2))
<span class="lineno">  660 </span>  SImpl_CastLLVMWord ::
<span class="lineno">  661 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  662 </span>    PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  663 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  664 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  665 </span>
<span class="lineno">  666 </span>  -- | Invert an @x:eq(y+off)@ proof into a @y:eq(x-off)@ proof:
<span class="lineno">  667 </span>  --
<span class="lineno">  668 </span>  -- &gt; x:eq(y+off) -o y:eq(x-off)
<span class="lineno">  669 </span>  SImpl_InvertLLVMOffsetEq ::
<span class="lineno">  670 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  671 </span>    ExprVar (LLVMPointerType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  672 </span>    ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  673 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  674 </span>
<span class="lineno">  675 </span>  -- | Cast a proof of @y:eq(word(e))@ to one of @x:eq(word(e+off))@ using an
<span class="lineno">  676 </span>  -- equality permission @x:eq(y+off)@ on top of the stack:
<span class="lineno">  677 </span>  --
<span class="lineno">  678 </span>  -- &gt; x:eq(y+off) * y:eq(word(e)) -o x:eq(word(e+off))
<span class="lineno">  679 </span>  SImpl_OffsetLLVMWord ::
<span class="lineno">  680 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  681 </span>    ExprVar (LLVMPointerType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  682 </span>    PermExpr (BVType w) -&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  683 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  684 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>  -- | Cast a permission @y:p@ of LLVM type on the top of the stack to @x:(p -
<span class="lineno">  687 </span>  -- off)@ using a proof of @x:eq(y+off)@ just below it on the stack:
<span class="lineno">  688 </span>  --
<span class="lineno">  689 </span>  -- &gt; x:eq(y+off) * y:p -o x:(p - off)
<span class="lineno">  690 </span>  --
<span class="lineno">  691 </span>  -- FIXME: change this to work for arbitrary types with 'offsetPerm'
<span class="lineno">  692 </span>  SImpl_CastLLVMPtr ::
<span class="lineno">  693 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  694 </span>    ExprVar (LLVMPointerType w) -&gt; ValuePerm (LLVMPointerType w) -&gt;
<span class="lineno">  695 </span>    PermExpr (BVType w) -&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  696 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  697 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  698 </span>
<span class="lineno">  699 </span>  -- | Cast a proof of @x:free(e1)@ to one of @x:free(e2)@ using an equality
<span class="lineno">  700 </span>  -- permission @e1=e2@ on top of the stack:
<span class="lineno">  701 </span>  --
<span class="lineno">  702 </span>  -- &gt; x:free(e1) * x:prop(e1=e2) -o x:free(e2)
<span class="lineno">  703 </span>  SImpl_CastLLVMFree ::
<span class="lineno">  704 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  705 </span>    PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  706 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  707 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>  -- | Cast the offset of a field permission from @off@ to @off'@ using an
<span class="lineno">  710 </span>  -- equality permission @off=off'@ on the top of the stack:
<span class="lineno">  711 </span>  --
<span class="lineno">  712 </span>  -- &gt; x:ptr((rw,off) |-&gt; p) * x:prop(off=off') -o x:ptr((rw,off') |-&gt; p)
<span class="lineno">  713 </span>  SImpl_CastLLVMFieldOffset ::
<span class="lineno">  714 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  715 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  716 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  717 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  718 </span>
<span class="lineno">  719 </span>  -- | Combine proofs of @x:ptr((rw,off) |-&gt; eq(y))@ and @y:p@ on the top of the
<span class="lineno">  720 </span>  -- permission stack into a proof of @x:ptr((rw,off) |-&gt; p)@, where the
<span class="lineno">  721 </span>  -- supplied 'LLVMFieldPerm' gives the required output permission:
<span class="lineno">  722 </span>  --
<span class="lineno">  723 </span>  -- &gt; x:ptr((rw,off) |-&gt; eq(y)) * y:p -o x:ptr((rw,off) |-&gt; p)
<span class="lineno">  724 </span>  SImpl_IntroLLVMFieldContents ::
<span class="lineno">  725 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  726 </span>    ExprVar (LLVMPointerType w) -&gt; ExprVar (LLVMPointerType sz) -&gt;
<span class="lineno">  727 </span>    LLVMFieldPerm w sz -&gt;
<span class="lineno">  728 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType sz)
<span class="lineno">  729 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>  -- | Demote an LLVM field permission to read:
<span class="lineno">  732 </span>  --
<span class="lineno">  733 </span>  -- &gt; x:[ls]ptr((W,off) |-&gt; p) -o [ls]x:ptr((R,off) |-&gt; p)
<span class="lineno">  734 </span>  SImpl_DemoteLLVMFieldRW ::
<span class="lineno">  735 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  736 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno">  737 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  738 </span>
<span class="lineno">  739 </span>  -- | Split an LLVM field permission with @true@ contents:
<span class="lineno">  740 </span>  --
<span class="lineno">  741 </span>  -- &gt; x:[l]ptr((rw,off,sz2) |-&gt; true)
<span class="lineno">  742 </span>  -- &gt;   -o [l]x:ptr((rw,off,sz1) |-&gt; true)
<span class="lineno">  743 </span>  -- &gt;      * [l]x:ptr((rw,off+sz1,sz2-sz1) |-&gt; true)
<span class="lineno">  744 </span>  SImpl_SplitLLVMTrueField ::
<span class="lineno">  745 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2,
<span class="lineno">  746 </span>     1 &lt;= (sz2 - sz1), KnownNat (sz2 - sz1)) =&gt;
<span class="lineno">  747 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz2 -&gt; NatRepr sz1 -&gt;
<span class="lineno">  748 </span>    NatRepr (sz2 - sz1) -&gt;
<span class="lineno">  749 </span>    SimplImpl (RNil :&gt; LLVMPointerType w)
<span class="lineno">  750 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  751 </span>
<span class="lineno">  752 </span>  -- | Truncate an LLVM field permission with @true@ contents:
<span class="lineno">  753 </span>  --
<span class="lineno">  754 </span>  -- &gt; x:[l]ptr((rw,off,sz2) |-&gt; true)
<span class="lineno">  755 </span>  -- &gt;   -o [l]x:ptr((rw,off,sz1) |-&gt; true)
<span class="lineno">  756 </span>  --
<span class="lineno">  757 </span>  SImpl_TruncateLLVMTrueField ::
<span class="lineno">  758 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2) =&gt;
<span class="lineno">  759 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz2 -&gt; NatRepr sz1 -&gt;
<span class="lineno">  760 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>  -- | Concatenate two LLVM field permissions with @true@ contents:
<span class="lineno">  763 </span>  --
<span class="lineno">  764 </span>  -- &gt; [l]x:ptr((rw,off,sz1) |-&gt; true) * [l]x:ptr((rw,off+sz1,sz2) |-&gt; true)
<span class="lineno">  765 </span>  -- &gt; -o x:[l]ptr((rw,off,sz1+sz2) |-&gt; true)
<span class="lineno">  766 </span>  SImpl_ConcatLLVMTrueFields ::
<span class="lineno">  767 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2,
<span class="lineno">  768 </span>     1 &lt;= (sz1 + sz2), KnownNat (sz1 + sz2)) =&gt;
<span class="lineno">  769 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz1 -&gt; NatRepr sz2 -&gt;
<span class="lineno">  770 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  771 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  772 </span>
<span class="lineno">  773 </span>  -- | Demote an LLVM array permission to read modality:
<span class="lineno">  774 </span>  --
<span class="lineno">  775 </span>  -- &gt; x:[l]array(rw,off,&lt;len,*stride,sh,bs)
<span class="lineno">  776 </span>  -- &gt;   -o x:[l]array(R,off,&lt;len,*stride,sh,bs)
<span class="lineno">  777 </span>  SImpl_DemoteLLVMArrayRW ::
<span class="lineno">  778 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  779 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  780 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  781 </span>
<span class="lineno">  782 </span>  -- | Copy a portion of an array permission with a given offset and length, as
<span class="lineno">  783 </span>  -- computed by 'llvmMakeSubArray', assuming that the array is copyable. This
<span class="lineno">  784 </span>  -- requires a proof that the copied sub-array permission is contained in the
<span class="lineno">  785 </span>  -- larger one as per 'llvmArrayContainsArray', i.e., that the range of the
<span class="lineno">  786 </span>  -- smaller array is contained in the larger one and that all borrows in the
<span class="lineno">  787 </span>  -- larger one are either preserved in the smaller or are disjoint from it:
<span class="lineno">  788 </span>  --
<span class="lineno">  789 </span>  -- &gt; x:ar1=array(off1,&lt;len1,*stride,sh,bs1)
<span class="lineno">  790 </span>  -- &gt; * x:prop('llvmArrayContainsArray' ar1 ar2)
<span class="lineno">  791 </span>  -- &gt;   -o x:ar2=[l]array(rw,off2,&lt;len2,*stride,sh,bs2)
<span class="lineno">  792 </span>  -- &gt;      * x:ar1=[l]array(rw,off1,&lt;len1,*stride,sh,bs1)
<span class="lineno">  793 </span>  SImpl_LLVMArrayCopy ::
<span class="lineno">  794 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  795 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  796 </span>    PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  797 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  798 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  799 </span>
<span class="lineno">  800 </span>  -- | Borrow a portion of an arra permission with a given offset and length, as
<span class="lineno">  801 </span>  -- computed by 'llvmMakeSubArray'. This requires a proof that the borrowed
<span class="lineno">  802 </span>  -- array permission is contained in the larger one as per
<span class="lineno">  803 </span>  -- 'llvmArrayContainsArray', i.e., that the range of the smaller array is
<span class="lineno">  804 </span>  -- contained in the larger one and that all borrows in the larger one are
<span class="lineno">  805 </span>  -- either preserved in the smaller or are disjoint from it:
<span class="lineno">  806 </span>  --
<span class="lineno">  807 </span>  -- &gt; x:ar1=[l]array(rw,off1,&lt;len1,*stride,sh,bs1++bs2)
<span class="lineno">  808 </span>  -- &gt; * x:prop('llvmArrayContainsArray' ar1 ar2)
<span class="lineno">  809 </span>  -- &gt;   -o x:ar2=[l]array(rw,off2,&lt;len2,*stride,sh, bs2+(off1-off2))
<span class="lineno">  810 </span>  -- &gt;      * x:[l]array(rw,off1,&lt;len1,*stride,sh,[off2,len2):bs1)
<span class="lineno">  811 </span>  SImpl_LLVMArrayBorrow ::
<span class="lineno">  812 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  813 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  814 </span>    PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  815 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  816 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>  -- | Return a borrowed range of an array permission, undoing a borrow:
<span class="lineno">  819 </span>  --
<span class="lineno">  820 </span>  -- &gt; x:[l]array(rw,off2,&lt;len2,*stride,sh,bs2)
<span class="lineno">  821 </span>  -- &gt; * x:[l]array(rw,off1,&lt;len1,*stride,sh,[off2,len2):bs1)
<span class="lineno">  822 </span>  -- &gt;   -o x:[l]array(rw,off,&lt;len,*stride,sh,bs1++(bs2+(off2-off1)))
<span class="lineno">  823 </span>  SImpl_LLVMArrayReturn ::
<span class="lineno">  824 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  825 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  826 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  827 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  828 </span>
<span class="lineno">  829 </span>  -- | Append two array permissions, assuming one ends where the other begins
<span class="lineno">  830 </span>  -- and that they have the same stride and fields:
<span class="lineno">  831 </span>  --
<span class="lineno">  832 </span>  -- &gt; x:[l]array(rw, off1, &lt;len1, *stride, sh, bs1)
<span class="lineno">  833 </span>  -- &gt; * x:[l]array(rw,off2=off1+len*stride*word_size, &lt;len2, *stride, sh, bs2)
<span class="lineno">  834 </span>  -- &gt;   -o x:[l]array(rw,off1,&lt;len1+len2,*stride,sh,bs1++bs2)
<span class="lineno">  835 </span>  SImpl_LLVMArrayAppend ::
<span class="lineno">  836 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  837 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  838 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  839 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  840 </span>
<span class="lineno">  841 </span>  -- | Rearrange the order of the borrows in an array permission:
<span class="lineno">  842 </span>  --
<span class="lineno">  843 </span>  -- &gt; x:[l]array(rw,off,&lt;len,*stride,sh,bs)
<span class="lineno">  844 </span>  -- &gt; -o x:[l]array(rw,off,&lt;len,*stride,sh,permute(bs))
<span class="lineno">  845 </span>  SImpl_LLVMArrayRearrange ::
<span class="lineno">  846 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  847 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; [LLVMArrayBorrow w] -&gt;
<span class="lineno">  848 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>  -- | Prove an empty array with length 0:
<span class="lineno">  851 </span>  --
<span class="lineno">  852 </span>  -- &gt; -o x:[l]array(rw,off,&lt;0,*stride,sh,bs)
<span class="lineno">  853 </span>  SImpl_LLVMArrayEmpty ::
<span class="lineno">  854 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  855 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  856 </span>    SimplImpl RNil (RNil :&gt; LLVMPointerType w)
<span class="lineno">  857 </span>
<span class="lineno">  858 </span>  -- | Prove an array whose borrows @bs@ cover the entire array using a
<span class="lineno">  859 </span>  -- permission that instantiates at least one of its cells. This latter
<span class="lineno">  860 </span>  -- permission ensures that the @x@ is a pointer, and is also used in the
<span class="lineno">  861 </span>  -- translation to give a default value to the cells of the output array
<span class="lineno">  862 </span>  -- permission:
<span class="lineno">  863 </span>  --
<span class="lineno">  864 </span>  -- &gt; x:[l2]memblock(rw,off1,stride,sh)
<span class="lineno">  865 </span>  -- &gt; -o x:[l2]memblock(rw,off1,stride,sh)
<span class="lineno">  866 </span>  -- &gt;    * x:[l]array(rw,off,&lt;len,*stride,sh,bs)
<span class="lineno">  867 </span>  SImpl_LLVMArrayBorrowed ::
<span class="lineno">  868 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno">  869 </span>    LLVMBlockPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  870 </span>    SimplImpl (RNil :&gt; LLVMPointerType w)
<span class="lineno">  871 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  872 </span>
<span class="lineno">  873 </span>  -- | Convert an array of byte-sized cells to a field of the same size with
<span class="lineno">  874 </span>  -- @true@ contents:
<span class="lineno">  875 </span>  --
<span class="lineno">  876 </span>  -- &gt; x:array[l](rw,off,&lt;(sz/8),*stride,sh) -o x:[l]ptr((sz,rw,off) |-&gt; true)
<span class="lineno">  877 </span>  SImpl_LLVMArrayToField ::
<span class="lineno">  878 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  879 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; NatRepr sz -&gt;
<span class="lineno">  880 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>  -- | Prove an array of length 1 from a block of its same shape:
<span class="lineno">  883 </span>  --
<span class="lineno">  884 </span>  -- &gt; x:[l]memblock(rw,off,stride,sh) -o x:[l]array(rw,off,&lt;1,*stride,sh,[])
<span class="lineno">  885 </span>  SImpl_LLVMArrayFromBlock ::
<span class="lineno">  886 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  887 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno">  888 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  889 </span>
<span class="lineno">  890 </span>  -- | Copy out the @i@th cell of an array permission, assuming it is
<span class="lineno">  891 </span>  -- copyable. Requires a proposition permission on the top of the stack stating
<span class="lineno">  892 </span>  -- that @i@ is in the range of the array and that it does not overlap with any
<span class="lineno">  893 </span>  -- of the existing borrows:
<span class="lineno">  894 </span>  --
<span class="lineno">  895 </span>  -- &gt; x:[l]array(R,off,&lt;len,*stride,sh,bs)
<span class="lineno">  896 </span>  -- &gt; * x:(prop(i \in [off,len)) * disjoint(bs,i*stride))
<span class="lineno">  897 </span>  -- &gt;   -o x:[l]memblock(R,off + i*stride,stride,sh)
<span class="lineno">  898 </span>  -- &gt;      * x:array(off,&lt;len,*stride,fps,bs)
<span class="lineno">  899 </span>  SImpl_LLVMArrayCellCopy ::
<span class="lineno">  900 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  901 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  902 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  903 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  904 </span>
<span class="lineno">  905 </span>  -- | Borrow the @i@th cell an array permission. Requires a proposition
<span class="lineno">  906 </span>  -- permission on the top of the stack stating that @i@ is in the range of the
<span class="lineno">  907 </span>  -- array and that it does not overlap with any of the existing borrows, and
<span class="lineno">  908 </span>  -- adds a borrow of the given field:
<span class="lineno">  909 </span>  --
<span class="lineno">  910 </span>  -- &gt; x:[l]array(rw,off,&lt;len,*stride,sh,bs)
<span class="lineno">  911 </span>  -- &gt; * x:(prop(i \in [off,len)) * disjoint(bs,i*stride))
<span class="lineno">  912 </span>  -- &gt;   -o x:[l]memblock(rw,off + i*stride,stride,sh)
<span class="lineno">  913 </span>  -- &gt;      * x:[l]array(rw,off,&lt;len,*stride,sh,(i*stride):bs)
<span class="lineno">  914 </span>  SImpl_LLVMArrayCellBorrow ::
<span class="lineno">  915 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  916 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  917 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  918 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  919 </span>
<span class="lineno">  920 </span>  -- | Return the @i@th cell of an array permission, undoing a borrow:
<span class="lineno">  921 </span>  --
<span class="lineno">  922 </span>  -- &gt; x:[l]memblock(rw,off + i*stride,stride,sh)
<span class="lineno">  923 </span>  -- &gt; * x:[l]array(rw,off,&lt;len,*stride,sh,(i*stride):bs)
<span class="lineno">  924 </span>  -- &gt;   -o x:[l]array(rw,off,&lt;len,*stride,sh,bs)
<span class="lineno">  925 </span>  SImpl_LLVMArrayCellReturn ::
<span class="lineno">  926 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  927 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno">  928 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  929 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno">  930 </span>
<span class="lineno">  931 </span>  -- | Apply an implication to the cell shape of an array permission:
<span class="lineno">  932 </span>  --
<span class="lineno">  933 </span>  -- &gt; y:[l]memblock(rw,0,stride,sh1) -o y:[l]memblock(rw,0,stride,sh2)
<span class="lineno">  934 </span>  -- &gt; ----------------------------------------------------------------
<span class="lineno">  935 </span>  -- &gt; x:array(off,&lt;len,*stride,sh1,bs) -o
<span class="lineno">  936 </span>  -- &gt;   x:array(off,&lt;len,*stride,sh2,bs)
<span class="lineno">  937 </span>  SImpl_LLVMArrayContents ::
<span class="lineno">  938 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  939 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  940 </span>    PermExpr (LLVMShapeType w) -&gt;
<span class="lineno">  941 </span>    Binding (LLVMPointerType w) (LocalPermImpl
<span class="lineno">  942 </span>                                 (RNil :&gt; LLVMPointerType w)
<span class="lineno">  943 </span>                                 (RNil :&gt; LLVMPointerType w)) -&gt;
<span class="lineno">  944 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno">  945 </span>
<span class="lineno">  946 </span>  -- | Prove that @x@ is a pointer from a field permission:
<span class="lineno">  947 </span>  --
<span class="lineno">  948 </span>  -- &gt; x:ptr((rw,off) |-&gt; p) -o x:is_llvmptr * x:ptr((rw,off) |-&gt; p)
<span class="lineno">  949 </span>  SImpl_LLVMFieldIsPtr ::
<span class="lineno">  950 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  951 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno">  952 </span>    SimplImpl (RNil :&gt; LLVMPointerType w)
<span class="lineno">  953 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  954 </span>
<span class="lineno">  955 </span>  -- | Prove that @x@ is a pointer from a field permission:
<span class="lineno">  956 </span>  --
<span class="lineno">  957 </span>  -- &gt; x:array(...) -o x:is_llvmptr * x:array(...)
<span class="lineno">  958 </span>  SImpl_LLVMArrayIsPtr ::
<span class="lineno">  959 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  960 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno">  961 </span>    SimplImpl (RNil :&gt; LLVMPointerType w)
<span class="lineno">  962 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  963 </span>
<span class="lineno">  964 </span>  -- | Prove that @x@ is a pointer from a memblock permission:
<span class="lineno">  965 </span>  --
<span class="lineno">  966 </span>  -- &gt; x:[l]memblock(...) -o x:is_llvmptr * x:[l]memblock(...)
<span class="lineno">  967 </span>  SImpl_LLVMBlockIsPtr ::
<span class="lineno">  968 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno">  969 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno">  970 </span>    SimplImpl (RNil :&gt; LLVMPointerType w)
<span class="lineno">  971 </span>    (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno">  972 </span>
<span class="lineno">  973 </span>  -- | Save a permission for later by splitting it into part that is in the
<span class="lineno">  974 </span>  -- current lifetime and part that is saved in the lifetime for later:
<span class="lineno">  975 </span>  --
<span class="lineno">  976 </span>  -- &gt; x:F&lt;l,rws&gt; * l:[l2]lcurrent * l2:lowned[ls] (ps_in -o ps_out)
<span class="lineno">  977 </span>  -- &gt;   -o x:F&lt;l2,rws&gt; * l2:lowned[ls](ps_in, x:F&lt;l2,Rs&gt; -o ps_out, x:F&lt;l,rws&gt;)
<span class="lineno">  978 </span>  --
<span class="lineno">  979 </span>  -- Note that this rule also supports @l=always@, in which case the
<span class="lineno">  980 </span>  -- @l:[l2]lcurrent@ permission is replaced by @l2:true@ (as a hack, because it
<span class="lineno">  981 </span>  -- has the same type)
<span class="lineno">  982 </span>  SImpl_SplitLifetime ::
<span class="lineno">  983 </span>    KnownRepr TypeRepr a =&gt; ExprVar a -&gt; LifetimeFunctor args a -&gt;
<span class="lineno">  984 </span>    PermExprs args -&gt; PermExpr LifetimeType -&gt; ExprVar LifetimeType -&gt;
<span class="lineno">  985 </span>    [PermExpr LifetimeType] -&gt; CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno">  986 </span>    ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno">  987 </span>    SimplImpl (RNil :&gt; a :&gt; LifetimeType :&gt; LifetimeType)
<span class="lineno">  988 </span>    (RNil :&gt; a :&gt; LifetimeType)
<span class="lineno">  989 </span>
<span class="lineno">  990 </span>  -- | Subsume a smaller lifetime @l2@ inside a bigger lifetime @l1@, by adding
<span class="lineno">  991 </span>  -- @l2@ to the lifetimes contained in the @lowned@ permission for @l@:
<span class="lineno">  992 </span>  --
<span class="lineno">  993 </span>  -- &gt; l1:lowned[ls] (ps_in -o ps_out) -o l1:lowned[l2,ls] (ps_in -o ps_out)
<span class="lineno">  994 </span>  SImpl_SubsumeLifetime :: ExprVar LifetimeType -&gt; [PermExpr LifetimeType] -&gt;
<span class="lineno">  995 </span>                           CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno">  996 </span>                           ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno">  997 </span>                           PermExpr LifetimeType -&gt;
<span class="lineno">  998 </span>                           SimplImpl (RNil :&gt; LifetimeType)
<span class="lineno">  999 </span>                           (RNil :&gt; LifetimeType)
<span class="lineno"> 1000 </span>
<span class="lineno"> 1001 </span>  -- | Prove a lifetime @l@ is current during a lifetime @l2@ it contains:
<span class="lineno"> 1002 </span>  --
<span class="lineno"> 1003 </span>  -- &gt; l1:lowned[ls1,l2,ls2] (ps_in -o ps_out)
<span class="lineno"> 1004 </span>  -- &gt;   -o l1:[l2]lcurrent * l1:lowned[ls1,l2,ls2] (ps_in -o ps_out)
<span class="lineno"> 1005 </span>  SImpl_ContainedLifetimeCurrent :: ExprVar LifetimeType -&gt;
<span class="lineno"> 1006 </span>                                    [PermExpr LifetimeType] -&gt;
<span class="lineno"> 1007 </span>                                    CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 1008 </span>                                    ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 1009 </span>                                    PermExpr LifetimeType -&gt;
<span class="lineno"> 1010 </span>                                    SimplImpl (RNil :&gt; LifetimeType)
<span class="lineno"> 1011 </span>                                    (RNil :&gt; LifetimeType :&gt; LifetimeType)
<span class="lineno"> 1012 </span>
<span class="lineno"> 1013 </span>  -- | Remove a finshed contained lifetime from an @lowned@ permission:
<span class="lineno"> 1014 </span>  --
<span class="lineno"> 1015 </span>  -- &gt; l1:lowned[ls1,l2,ls2] (ps_in -o ps_out) * l2:lfinished
<span class="lineno"> 1016 </span>  -- &gt;   -o l1:lowned[ls1,ls2] (ps_in -o ps_out)
<span class="lineno"> 1017 </span>  SImpl_RemoveContainedLifetime :: ExprVar LifetimeType -&gt;
<span class="lineno"> 1018 </span>                                   [PermExpr LifetimeType] -&gt;
<span class="lineno"> 1019 </span>                                   CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 1020 </span>                                   ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 1021 </span>                                   ExprVar LifetimeType -&gt;
<span class="lineno"> 1022 </span>                                   SimplImpl
<span class="lineno"> 1023 </span>                                   (RNil :&gt; LifetimeType :&gt; LifetimeType)
<span class="lineno"> 1024 </span>                                   (RNil :&gt; LifetimeType)
<span class="lineno"> 1025 </span>
<span class="lineno"> 1026 </span>  -- | Weaken a lifetime in a permission from some @l@ to some @l2@ that is
<span class="lineno"> 1027 </span>  -- contained in @l@, i.e., such that @l@ is current during @l2@, assuming that
<span class="lineno"> 1028 </span>  -- @F@ isa valid lifetime functor:
<span class="lineno"> 1029 </span>  --
<span class="lineno"> 1030 </span>  -- &gt; F&lt;l&gt; * 'lcurrentPerm' l l2 -o F&lt;l2&gt;
<span class="lineno"> 1031 </span>  SImpl_WeakenLifetime :: KnownRepr TypeRepr a =&gt; ExprVar a -&gt;
<span class="lineno"> 1032 </span>                          LifetimeFunctor args a -&gt; PermExprs args -&gt;
<span class="lineno"> 1033 </span>                          PermExpr LifetimeType -&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 1034 </span>                          SimplImpl (RNil :&gt; a :&gt; LifetimeType) (RNil :&gt; a)
<span class="lineno"> 1035 </span>
<span class="lineno"> 1036 </span>  -- | Map the input and output permissions of a lifetime ownership permission
<span class="lineno"> 1037 </span>  -- using local implications:
<span class="lineno"> 1038 </span>  --
<span class="lineno"> 1039 </span>  -- &gt; Ps1 * Ps_in' -o Ps_in                          Ps2 * Ps_out -o Ps_out'
<span class="lineno"> 1040 </span>  -- &gt; ----------------------------------------------------------------------
<span class="lineno"> 1041 </span>  -- &gt; Ps1 * Ps2 * l:lowned [ls](Ps_in -o Ps_out) -o l:lowned[ls] (Ps_in' -o Ps_out')
<span class="lineno"> 1042 </span>  SImpl_MapLifetime ::
<span class="lineno"> 1043 </span>    ExprVar LifetimeType -&gt; [PermExpr LifetimeType] -&gt;
<span class="lineno"> 1044 </span>    CruCtx ps_in -&gt; CruCtx ps_out -&gt; ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 1045 </span>    CruCtx ps_in' -&gt; CruCtx ps_out' -&gt; ExprPerms ps_in' -&gt; ExprPerms ps_out' -&gt;
<span class="lineno"> 1046 </span>    DistPerms ps1 -&gt; DistPerms ps2 -&gt;
<span class="lineno"> 1047 </span>    LocalPermImpl (ps1 :++: ps_in') ps_in -&gt;
<span class="lineno"> 1048 </span>    LocalPermImpl (ps2 :++: ps_out) ps_out' -&gt;
<span class="lineno"> 1049 </span>    SimplImpl (ps1 :++: ps2 :&gt; LifetimeType) (RNil :&gt; LifetimeType)
<span class="lineno"> 1050 </span>
<span class="lineno"> 1051 </span>  -- | End a lifetime, taking in its @lowned@ permission and all the permissions
<span class="lineno"> 1052 </span>  -- required by the @lowned@ permission to end it, and returning all
<span class="lineno"> 1053 </span>  -- permissions given back by the @lowned@ lifetime along with an @lfinished@
<span class="lineno"> 1054 </span>  -- permission asserting that @l@ has finished:
<span class="lineno"> 1055 </span>  --
<span class="lineno"> 1056 </span>  -- &gt; ps_in * l:lowned (ps_in -o ps_out) -o ps_out * l:lfinished
<span class="lineno"> 1057 </span>  SImpl_EndLifetime :: ExprVar LifetimeType -&gt;
<span class="lineno"> 1058 </span>                       CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 1059 </span>                       ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 1060 </span>                       SimplImpl (ps_in :&gt; LifetimeType)
<span class="lineno"> 1061 </span>                       (ps_out  :&gt; LifetimeType)
<span class="lineno"> 1062 </span>
<span class="lineno"> 1063 </span>  -- | Prove a simple @lowned(ps)@ permission from permissions @ps@ and an empty
<span class="lineno"> 1064 </span>  -- @lowned@ permission by having @l@ borrow @ps@:
<span class="lineno"> 1065 </span>  --
<span class="lineno"> 1066 </span>  -- &gt; ps * l:lowned(empty -o empty) -o [l]ps * l:lowned(ps)
<span class="lineno"> 1067 </span>  SImpl_IntroLOwnedSimple ::
<span class="lineno"> 1068 </span>    ExprVar LifetimeType -&gt; CruCtx ps -&gt; ExprPerms ps -&gt;
<span class="lineno"> 1069 </span>    SimplImpl (ps :&gt; LifetimeType) (ps :&gt; LifetimeType)
<span class="lineno"> 1070 </span>
<span class="lineno"> 1071 </span>  -- | Eliminate a simple @lowned(ps)@ permission into standard @lowned@
<span class="lineno"> 1072 </span>  -- permission @lowned([l](R)ps -o ps)@ it represents:
<span class="lineno"> 1073 </span>  --
<span class="lineno"> 1074 </span>  -- &gt; l:lowned(ps) -o l:lowned([l](R)ps -o ps)
<span class="lineno"> 1075 </span>  SImpl_ElimLOwnedSimple ::
<span class="lineno"> 1076 </span>    ExprVar LifetimeType -&gt; CruCtx ps -&gt; ExprPerms ps -&gt;
<span class="lineno"> 1077 </span>    SimplImpl (RNil :&gt; LifetimeType) (RNil :&gt; LifetimeType)
<span class="lineno"> 1078 </span>
<span class="lineno"> 1079 </span>  -- | Reflexivity for @lcurrent@ proofs:
<span class="lineno"> 1080 </span>  --
<span class="lineno"> 1081 </span>  -- &gt; . -o l:lcurrent(l)
<span class="lineno"> 1082 </span>  SImpl_LCurrentRefl :: ExprVar LifetimeType -&gt;
<span class="lineno"> 1083 </span>                        SimplImpl RNil (RNil :&gt; LifetimeType)
<span class="lineno"> 1084 </span>
<span class="lineno"> 1085 </span>  -- | Transitively combine @lcurrent@ proofs:
<span class="lineno"> 1086 </span>  --
<span class="lineno"> 1087 </span>  -- &gt; l1:lcurrent(l2) * l2:lcurrent(l3) -o l1:lcurrent(l3)
<span class="lineno"> 1088 </span>  SImpl_LCurrentTrans :: ExprVar LifetimeType -&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 1089 </span>                         PermExpr LifetimeType -&gt;
<span class="lineno"> 1090 </span>                         SimplImpl (RNil :&gt; LifetimeType :&gt; LifetimeType)
<span class="lineno"> 1091 </span>                         (RNil :&gt; LifetimeType)
<span class="lineno"> 1092 </span>
<span class="lineno"> 1093 </span>  -- | Demote the modality of an LLVM block permission to read:
<span class="lineno"> 1094 </span>  --
<span class="lineno"> 1095 </span>  -- &gt; x:[l]memblock(rw,off,len,sh) -o x:[l]memblock(R,off,len,sh)
<span class="lineno"> 1096 </span>  SImpl_DemoteLLVMBlockRW ::
<span class="lineno"> 1097 </span>    (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 1098 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1099 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>  -- | Prove an empty memblock permission of length 0:
<span class="lineno"> 1102 </span>  --
<span class="lineno"> 1103 </span>  -- &gt; -o x:memblock(rw,l,off,0,emptysh)
<span class="lineno"> 1104 </span>  SImpl_IntroLLVMBlockEmpty ::
<span class="lineno"> 1105 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1106 </span>    SimplImpl RNil (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1107 </span>
<span class="lineno"> 1108 </span>  -- | Coerce an memblock permission to an empty memblock permission:
<span class="lineno"> 1109 </span>  --
<span class="lineno"> 1110 </span>  -- &gt; x:memblock(rw,l,off,len,sh) -o x:memblock(rw,l,off,len,emptysh)
<span class="lineno"> 1111 </span>  SImpl_CoerceLLVMBlockEmpty ::
<span class="lineno"> 1112 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1113 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1114 </span>
<span class="lineno"> 1115 </span>  -- | Eliminate any @memblock@ permission to an array of bytes:
<span class="lineno"> 1116 </span>  --
<span class="lineno"> 1117 </span>  -- &gt; x:memblock(rw,l,off,len,emptysh)
<span class="lineno"> 1118 </span>  -- &gt;   -o x:[l]array(rw,off,&lt;len,*1,fieldsh(true),[])
<span class="lineno"> 1119 </span>  SImpl_ElimLLVMBlockToBytes ::
<span class="lineno"> 1120 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1121 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1122 </span>
<span class="lineno"> 1123 </span>  -- | Add a tuple shape around the shape of a @memblock@ permission
<span class="lineno"> 1124 </span>  --
<span class="lineno"> 1125 </span>  -- &gt; x:memblock(rw,l,off,len,sh) -o x:memblock(rw,l,off,len,tuplesh(sh))
<span class="lineno"> 1126 </span>  SImpl_IntroLLVMBlockTuple ::
<span class="lineno"> 1127 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1128 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1129 </span>
<span class="lineno"> 1130 </span>  -- | Eliminate a tuple shape in a @memblock@ permission
<span class="lineno"> 1131 </span>  --
<span class="lineno"> 1132 </span>  -- &gt; x:memblock(rw,l,off,len,tuplesh(sh)) -o x:memblock(rw,l,off,len,sh)
<span class="lineno"> 1133 </span>  SImpl_ElimLLVMBlockTuple ::
<span class="lineno"> 1134 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1135 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1136 </span>
<span class="lineno"> 1137 </span>  -- | Convert a memblock permission of shape @sh@ to one of shape @sh;emptysh@:
<span class="lineno"> 1138 </span>  --
<span class="lineno"> 1139 </span>  -- &gt; x:memblock(rw,l,off,len,sh) -o x:memblock(rw,l,off,len,sh;emptysh)
<span class="lineno"> 1140 </span>  SImpl_IntroLLVMBlockSeqEmpty ::
<span class="lineno"> 1141 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1142 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1143 </span>
<span class="lineno"> 1144 </span>  -- | Convert a memblock permission of shape @sh;emptysh@ to one of shape @sh@:
<span class="lineno"> 1145 </span>  --
<span class="lineno"> 1146 </span>  -- &gt; x:memblock(rw,l,off,len,sh;emptysh) -o x:memblock(rw,l,off,len,sh)
<span class="lineno"> 1147 </span>  SImpl_ElimLLVMBlockSeqEmpty ::
<span class="lineno"> 1148 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1149 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1150 </span>
<span class="lineno"> 1151 </span>  -- | Split a memblock permission of empty shape into one of a given length
<span class="lineno"> 1152 </span>  -- @len1@ and another of the remaining length:
<span class="lineno"> 1153 </span>  --
<span class="lineno"> 1154 </span>  -- &gt; x:memblock(rw,l,off,len,emptysh)
<span class="lineno"> 1155 </span>  -- &gt;   -o x:memblock(rw,l,off,len1,emptysh)
<span class="lineno"> 1156 </span>  -- &gt;      * x:memblock(rw,l,off+len1,len - len1,emptysh)
<span class="lineno"> 1157 </span>  SImpl_SplitLLVMBlockEmpty ::
<span class="lineno"> 1158 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1159 </span>    PermExpr (BVType w) -&gt;
<span class="lineno"> 1160 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1161 </span>
<span class="lineno"> 1162 </span>  -- | Fold the body of a named shape in a @memblock@ permission:
<span class="lineno"> 1163 </span>  --
<span class="lineno"> 1164 </span>  -- &gt; x:memblock(rw,l,off,len,'unfoldNamedShape' nmsh args)
<span class="lineno"> 1165 </span>  -- &gt;   -o x:memblock(rw,l,off,len,nmsh&lt;args&gt;)
<span class="lineno"> 1166 </span>  SImpl_IntroLLVMBlockNamed ::
<span class="lineno"> 1167 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1168 </span>    NamedShape 'True args w -&gt;
<span class="lineno"> 1169 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1170 </span>
<span class="lineno"> 1171 </span>  -- | Unfold the body of a named shape in a @memblock@ permission:
<span class="lineno"> 1172 </span>  --
<span class="lineno"> 1173 </span>  -- &gt; x:memblock(rw,l,off,len,nmsh&lt;args&gt;)
<span class="lineno"> 1174 </span>  -- &gt;   -o x:memblock(rw,l,off,len,'unfoldNamedShape' nmsh args)
<span class="lineno"> 1175 </span>  SImpl_ElimLLVMBlockNamed ::
<span class="lineno"> 1176 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1177 </span>    NamedShape 'True args w -&gt;
<span class="lineno"> 1178 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1179 </span>
<span class="lineno"> 1180 </span>  -- | Add modalities to a named shape in a @memblock@ permission:
<span class="lineno"> 1181 </span>  --
<span class="lineno"> 1182 </span>  -- &gt; x:memblock(rw,l,off,len,nmsh&lt;args&gt;)
<span class="lineno"> 1183 </span>  -- &gt;   -o memblock(rw',l',off,len,[l](rw)nmsh&lt;args&gt;)
<span class="lineno"> 1184 </span>  SImpl_IntroLLVMBlockNamedMods ::
<span class="lineno"> 1185 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1186 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1187 </span>
<span class="lineno"> 1188 </span>  -- | Eliminate modalities on a named shape in a @memblock@ permission:
<span class="lineno"> 1189 </span>  --
<span class="lineno"> 1190 </span>  -- &gt; x:memblock(rw,l,off,len,[l'](rw')nmsh&lt;args&gt;)
<span class="lineno"> 1191 </span>  -- &gt;   -o memblock(rw',l',off,len,nmsh&lt;args&gt;)
<span class="lineno"> 1192 </span>  SImpl_ElimLLVMBlockNamedMods ::
<span class="lineno"> 1193 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1194 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1195 </span>
<span class="lineno"> 1196 </span>  -- | Prove an llvmblock permission of shape @sh@ from one of equality shape
<span class="lineno"> 1197 </span>  -- @eqsh(len,y)@ and a shape permission on @y@:
<span class="lineno"> 1198 </span>  --
<span class="lineno"> 1199 </span>  -- &gt; x:memblock(rw,l,off,len,eqsh(len,y)), y:shape(sh)
<span class="lineno"> 1200 </span>  -- &gt;   -o x:memblock(rw,l,off,len,sh)
<span class="lineno"> 1201 </span>  SImpl_IntroLLVMBlockFromEq ::
<span class="lineno"> 1202 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 1203 </span>    LLVMBlockPerm w -&gt; ExprVar (LLVMBlockType w) -&gt;
<span class="lineno"> 1204 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMBlockType w)
<span class="lineno"> 1205 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1206 </span>
<span class="lineno"> 1207 </span>  -- | Prove an llvmblock permission of pointer shape from one of field shape
<span class="lineno"> 1208 </span>  -- containing a pointer permission:
<span class="lineno"> 1209 </span>  --
<span class="lineno"> 1210 </span>  -- &gt; x:[l]memblock(rw,off,w/8,fieldsh([l2]memblock(rw2,0,sh_len,sh)))
<span class="lineno"> 1211 </span>  -- &gt;   -o x:[l]memblock(rw,off,w/8,[l2]ptrsh(rw2,sh))
<span class="lineno"> 1212 </span>  SImpl_IntroLLVMBlockPtr ::
<span class="lineno"> 1213 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1214 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1215 </span>
<span class="lineno"> 1216 </span>  -- | Eliminate an llvmblock permission of pointer shape:
<span class="lineno"> 1217 </span>  --
<span class="lineno"> 1218 </span>  -- &gt; x:[l]memblock(rw,off,w/8,[l2]ptrsh(rw2,sh))
<span class="lineno"> 1219 </span>  -- &gt;   -o x:[l]memblock(rw,off,w/8,fieldsh([l2]memblock(rw2,0,sh_len,sh)))
<span class="lineno"> 1220 </span>  SImpl_ElimLLVMBlockPtr ::
<span class="lineno"> 1221 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1222 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1223 </span>
<span class="lineno"> 1224 </span>  -- | Prove a block of field shape from the corresponding field permission:
<span class="lineno"> 1225 </span>  --
<span class="lineno"> 1226 </span>  -- &gt; x:[l]ptr((rw,off,sz) |-&gt; p) -o x:memblock(rw,l,off,len+sz,fieldsh(sz,p))
<span class="lineno"> 1227 </span>  SImpl_IntroLLVMBlockField ::
<span class="lineno"> 1228 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1229 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 1230 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1231 </span>
<span class="lineno"> 1232 </span>  -- | Eliminate a block of field shape to the corresponding field permission
<span class="lineno"> 1233 </span>  --
<span class="lineno"> 1234 </span>  -- &gt; x:[l]memblock(rw,off,sz/8,fieldsh(sz,p)) -o x:[l]ptr((rw,off,sz) |-&gt; p)
<span class="lineno"> 1235 </span>  SImpl_ElimLLVMBlockField ::
<span class="lineno"> 1236 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1237 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 1238 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1239 </span>
<span class="lineno"> 1240 </span>  -- | Prove a block of array shape from the corresponding array permission:
<span class="lineno"> 1241 </span>  --
<span class="lineno"> 1242 </span>  -- &gt; x:array(...) -o x:memblock(...)
<span class="lineno"> 1243 </span>  SImpl_IntroLLVMBlockArray ::
<span class="lineno"> 1244 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 1245 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1246 </span>
<span class="lineno"> 1247 </span>  -- | Eliminate a block of array shape to the corresponding array permission,
<span class="lineno"> 1248 </span>  -- assuming that the length of the block equals that of the array:
<span class="lineno"> 1249 </span>  --
<span class="lineno"> 1250 </span>  -- &gt; x:[l]memblock(rw,off,stride*len,arraysh(&lt;len,*stride,sh))
<span class="lineno"> 1251 </span>  -- &gt;   -o x:[l]array(rw,off,&lt;len,*stride,sh,[])
<span class="lineno"> 1252 </span>  SImpl_ElimLLVMBlockArray ::
<span class="lineno"> 1253 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1254 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1255 </span>
<span class="lineno"> 1256 </span>  -- | Prove a block of shape @sh1;sh2@ from blocks of shape @sh1@ and @sh2@,
<span class="lineno"> 1257 </span>  -- where the supplied 'LLVMBlockPerm' gives @sh1@ and the supplied additional
<span class="lineno"> 1258 </span>  -- arguments give @len2@ and @sh2@:
<span class="lineno"> 1259 </span>  --
<span class="lineno"> 1260 </span>  -- &gt; x:memblock(rw,l,off,len1,sh1) * memblock(rw,l,off+len1,len2,sh2)
<span class="lineno"> 1261 </span>  -- &gt;   -o x:memblock(rw,l,off,len1+len2,sh1;sh2)
<span class="lineno"> 1262 </span>  SImpl_IntroLLVMBlockSeq ::
<span class="lineno"> 1263 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 1264 </span>    LLVMBlockPerm w -&gt; PermExpr (BVType w) -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 1265 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 1266 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1267 </span>
<span class="lineno"> 1268 </span>  -- | Eliminate a block of shape @sh1;sh2@ to blocks of shape @sh1@ and @sh2@,
<span class="lineno"> 1269 </span>  -- as long as we can compute the length of @sh1@, where the supplied
<span class="lineno"> 1270 </span>  -- 'LLVMBlockPerm' gives @sh1@ and the additional argument gives @sh2@:
<span class="lineno"> 1271 </span>  --
<span class="lineno"> 1272 </span>  -- &gt; x:memblock(rw,l,off,len,sh1;sh2)
<span class="lineno"> 1273 </span>  -- &gt;   -o x:memblock(rw,l,off,len(sh1),sh1)
<span class="lineno"> 1274 </span>  -- &gt;      * memblock(rw,l,off+len(sh1),len-len(sh1),sh2)
<span class="lineno"> 1275 </span>  SImpl_ElimLLVMBlockSeq ::
<span class="lineno"> 1276 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 1277 </span>    LLVMBlockPerm w -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 1278 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1279 </span>
<span class="lineno"> 1280 </span>  -- | Prove a block of shape @sh1 orsh sh2@ from a disjunction, where the
<span class="lineno"> 1281 </span>  -- supplied 'LLVMBlockPerm' gives @sh1@ and the additional argument is @sh2@:
<span class="lineno"> 1282 </span>  --
<span class="lineno"> 1283 </span>  -- &gt; x:memblock(rw,l,off,len,sh1) or memblock(rw,l,off,len,sh2)
<span class="lineno"> 1284 </span>  -- &gt;   -o x:memblock(rw,l,off,len,sh1 orsh sh2)
<span class="lineno"> 1285 </span>  SImpl_IntroLLVMBlockOr ::
<span class="lineno"> 1286 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 1287 </span>    LLVMBlockPerm w -&gt; PermExpr (LLVMShapeType w) -&gt;
<span class="lineno"> 1288 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1289 </span>
<span class="lineno"> 1290 </span>  -- | Eliminate a block of shape @sh1 orsh (sh2 orsh (... orsh shn))@ to an
<span class="lineno"> 1291 </span>  -- n-way disjunctive permission, where the shape of the supplied
<span class="lineno"> 1292 </span>  -- 'LLVMBlockPerm' is ignored, and is replaced by the list of shapes, which
<span class="lineno"> 1293 </span>  -- must be non-empty:
<span class="lineno"> 1294 </span>  --
<span class="lineno"> 1295 </span>  -- &gt; x:memblock(rw,l,off,len,sh1 orsh (... orsh shn))
<span class="lineno"> 1296 </span>  -- &gt;   -o x:memblock(rw,l,off,len,sh1) or (... or memblock(rw,l,off,len,shn))
<span class="lineno"> 1297 </span>  SImpl_ElimLLVMBlockOr ::
<span class="lineno"> 1298 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 1299 </span>    LLVMBlockPerm w -&gt; [PermExpr (LLVMShapeType w)] -&gt;
<span class="lineno"> 1300 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1301 </span>
<span class="lineno"> 1302 </span>  -- | Prove a block of shape @exsh z:A.sh@ from an existential:
<span class="lineno"> 1303 </span>  --
<span class="lineno"> 1304 </span>  -- &gt; x:exists z:A.memblock(rw,l,off,len,sh)
<span class="lineno"> 1305 </span>  -- &gt;   -o x:memblock(rw,l,off,len,exsh z:A.sh)
<span class="lineno"> 1306 </span>  SImpl_IntroLLVMBlockEx ::
<span class="lineno"> 1307 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1308 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1309 </span>
<span class="lineno"> 1310 </span>  -- | Eliminate a block of shape @exsh z:A.sh@ from to existential:
<span class="lineno"> 1311 </span>  --
<span class="lineno"> 1312 </span>  -- &gt; x:memblock(rw,l,off,len,exsh z:A.sh)
<span class="lineno"> 1313 </span>  -- &gt;   -o x:exists z:A.memblock(rw,l,off,len,sh)
<span class="lineno"> 1314 </span>  SImpl_ElimLLVMBlockEx ::
<span class="lineno"> 1315 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1316 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1317 </span>
<span class="lineno"> 1318 </span>  -- | Eliminate a block of shape @falsesh@ to @false@
<span class="lineno"> 1319 </span>  --
<span class="lineno"> 1320 </span>  -- &gt; x:memblock(..., falsesh) -o x:false
<span class="lineno"> 1321 </span>  SImpl_ElimLLVMBlockFalse ::
<span class="lineno"> 1322 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1323 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1324 </span>
<span class="lineno"> 1325 </span>  -- | Fold a named permission (other than an opaque permission):
<span class="lineno"> 1326 </span>  --
<span class="lineno"> 1327 </span>  -- &gt; x:(unfold P args) -o x:P&lt;args&gt;
<span class="lineno"> 1328 </span>  SImpl_FoldNamed :: NameSortCanFold ns ~ 'True =&gt;
<span class="lineno"> 1329 </span>                     ExprVar a -&gt; NamedPerm ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 1330 </span>                     PermOffset a -&gt; SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1331 </span>
<span class="lineno"> 1332 </span>  -- | Unfold a named permission (other than an opaque permission):
<span class="lineno"> 1333 </span>  --
<span class="lineno"> 1334 </span>  -- &gt; x:P&lt;args&gt; -o x:(unfold P args)
<span class="lineno"> 1335 </span>  SImpl_UnfoldNamed :: NameSortCanFold ns ~ 'True =&gt;
<span class="lineno"> 1336 </span>                       ExprVar a -&gt; NamedPerm ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 1337 </span>                       PermOffset a -&gt; SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1338 </span>
<span class="lineno"> 1339 </span>  -- | Map a named permission that is conjoinable to a conjunction:
<span class="lineno"> 1340 </span>  --
<span class="lineno"> 1341 </span>  -- &gt; x:P&lt;args&gt; -o x:ValPerm_Conj [P&lt;args&gt;]
<span class="lineno"> 1342 </span>  SImpl_NamedToConj :: NameSortIsConj ns ~ 'True =&gt; ExprVar a -&gt;
<span class="lineno"> 1343 </span>                       NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 1344 </span>                       PermOffset a -&gt;
<span class="lineno"> 1345 </span>                       SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1346 </span>
<span class="lineno"> 1347 </span>  -- | Map a conjuctive named permission to a named permission:
<span class="lineno"> 1348 </span>  --
<span class="lineno"> 1349 </span>  -- &gt; x:ValPerm_Conj [P&lt;args&gt;] -o x:P&lt;args&gt;
<span class="lineno"> 1350 </span>  SImpl_NamedFromConj :: NameSortIsConj ns ~ 'True =&gt; ExprVar a -&gt;
<span class="lineno"> 1351 </span>                         NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 1352 </span>                         PermOffset a -&gt; SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1353 </span>
<span class="lineno"> 1354 </span>
<span class="lineno"> 1355 </span>{- FIXME HERE: Write the rule for proving one recursive perm implies another
<span class="lineno"> 1356 </span>
<span class="lineno"> 1357 </span>  -- | Apply an implication to the body of a least fixed-point permission:
<span class="lineno"> 1358 </span>  --
<span class="lineno"> 1359 </span>  -- &gt; y:p1 -o y:p2
<span class="lineno"> 1360 </span>  -- &gt; ----------------------
<span class="lineno"> 1361 </span>  -- &gt; x:mu X.p1 -o x:mu X.p2
<span class="lineno"> 1362 </span>  SImpl_Mu ::
<span class="lineno"> 1363 </span>    ExprVar a -&gt; Binding (ValuePerm a) (ValuePerm a) -&gt;
<span class="lineno"> 1364 </span>    Binding (ValuePerm a) (ValuePerm a) -&gt;
<span class="lineno"> 1365 </span>    Binding (ValuePerm a) (PermImpl ((:~:) (RNil :&gt; a)) (RNil :&gt; a)) -&gt;
<span class="lineno"> 1366 </span>    SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1367 </span>-}
<span class="lineno"> 1368 </span>
<span class="lineno"> 1369 </span>  -- | Weaken an @always@ lifetime argument of a named permission:
<span class="lineno"> 1370 </span>  --
<span class="lineno"> 1371 </span>  -- &gt; x:P&lt;args1,always,args2&gt; -o x:P&lt;args1,l,args2&gt;
<span class="lineno"> 1372 </span>  SImpl_NamedArgAlways :: ExprVar a -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 1373 </span>                          PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 1374 </span>                          Member args LifetimeType -&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 1375 </span>                          SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1376 </span>
<span class="lineno"> 1377 </span>  -- | Weaken a lifetime argument @l1@ of a named permission:
<span class="lineno"> 1378 </span>  --
<span class="lineno"> 1379 </span>  -- &gt; x:P&lt;args1,l1,args2&gt; * l1:[l2]lcurrent -o x:P&lt;args1,l2,args2&gt;
<span class="lineno"> 1380 </span>  SImpl_NamedArgCurrent :: ExprVar a -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 1381 </span>                           PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 1382 </span>                           Member args LifetimeType -&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 1383 </span>                           SimplImpl (RNil :&gt; a :&gt; LifetimeType) (RNil :&gt; a)
<span class="lineno"> 1384 </span>
<span class="lineno"> 1385 </span>  -- | Weaken a 'Write' modality argument to any other modality:
<span class="lineno"> 1386 </span>  --
<span class="lineno"> 1387 </span>  -- &gt; x:P&lt;args1,W,args2&gt; -o x:P&lt;args1,rw,args2&gt;
<span class="lineno"> 1388 </span>  SImpl_NamedArgWrite :: ExprVar a -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 1389 </span>                         PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 1390 </span>                         Member args RWModalityType -&gt;
<span class="lineno"> 1391 </span>                         PermExpr RWModalityType -&gt;
<span class="lineno"> 1392 </span>                         SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1393 </span>
<span class="lineno"> 1394 </span>  -- | Weaken any modality argument to a 'Read' modality:
<span class="lineno"> 1395 </span>  --
<span class="lineno"> 1396 </span>  -- &gt; x:P&lt;args1,rw,args2&gt; -o x:P&lt;args1,R,args2&gt;
<span class="lineno"> 1397 </span>  SImpl_NamedArgRead :: ExprVar a -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 1398 </span>                        PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 1399 </span>                        Member args RWModalityType -&gt;
<span class="lineno"> 1400 </span>                        SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1401 </span>
<span class="lineno"> 1402 </span>  -- | Implements transitivity of reachability permissions:
<span class="lineno"> 1403 </span>  --
<span class="lineno"> 1404 </span>  -- &gt; x:P&lt;args,y&gt;, y:P&lt;args,e&gt; -o x:P&lt;args,e&gt;
<span class="lineno"> 1405 </span>  SImpl_ReachabilityTrans ::
<span class="lineno"> 1406 </span>    ExprVar a -&gt; RecPerm b 'True (args :&gt; a) a -&gt;
<span class="lineno"> 1407 </span>    PermExprs args -&gt; PermOffset a -&gt; ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno"> 1408 </span>    SimplImpl (RNil :&gt; a :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1409 </span>
<span class="lineno"> 1410 </span>  -- | Two inconsistent equality permissions combine to an any:
<span class="lineno"> 1411 </span>  --
<span class="lineno"> 1412 </span>  -- &gt; x:eq(e1), x:eq(e2) -o x:any (when e1 /= e2)
<span class="lineno"> 1413 </span>  SImpl_IntroAnyEqEq :: ExprVar a -&gt; PermExpr a -&gt; PermExpr a -&gt;
<span class="lineno"> 1414 </span>                        SimplImpl (RNil :&gt; a :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1415 </span>
<span class="lineno"> 1416 </span>  -- | Equality to a word along with a pointer permission combine to an any:
<span class="lineno"> 1417 </span>  --
<span class="lineno"> 1418 </span>  -- &gt; x:eq(llvmword(e)), x:p -o x:any (if p is a ptr, array, or block perm)
<span class="lineno"> 1419 </span>  SImpl_IntroAnyWordPtr ::
<span class="lineno"> 1420 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 1421 </span>    PermExpr (BVType w) -&gt; AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 1422 </span>    SimplImpl (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 1423 </span>    (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1424 </span>
<span class="lineno"> 1425 </span>  -- | Eliminate an @any@ permission to an equality:
<span class="lineno"> 1426 </span>  --
<span class="lineno"> 1427 </span>  -- &gt; x:any -o x:eq(e)
<span class="lineno"> 1428 </span>  SImpl_ElimAnyToEq :: ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno"> 1429 </span>                       SimplImpl (RNil :&gt; a) (RNil :&gt; a)
<span class="lineno"> 1430 </span>
<span class="lineno"> 1431 </span>  -- | Eliminate an @any@ permission to a pointer permission containing an @any@
<span class="lineno"> 1432 </span>  -- permission:
<span class="lineno"> 1433 </span>  --
<span class="lineno"> 1434 </span>  -- &gt; x:any -o x:[l]ptr((rw,off) |-&gt; any)
<span class="lineno"> 1435 </span>  SImpl_ElimAnyToPtr ::
<span class="lineno"> 1436 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1437 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 1438 </span>    SimplImpl (RNil :&gt; LLVMPointerType w) (RNil :&gt; LLVMPointerType w)
<span class="lineno"> 1439 </span>
<span class="lineno"> 1440 </span>
<span class="lineno"> 1441 </span>-- | A single step of permission implication. These can have multiple,
<span class="lineno"> 1442 </span>-- disjunctive conclusions, each of which can bind some number of variables, and
<span class="lineno"> 1443 </span>-- can also move permissions between the primary permissions for each variable
<span class="lineno"> 1444 </span>-- and the permission stack. The general form is:
<span class="lineno"> 1445 </span>--
<span class="lineno"> 1446 </span>-- &gt; x1::Px1 * ... * xl::Pl * P1 * ... * Pn
<span class="lineno"> 1447 </span>-- &gt;   -o (zs1 . x1::Px1_1 * ... * xl::Pxl_1 * P1_1 * ... * P1_k1) \/
<span class="lineno"> 1448 </span>-- &gt;      ... \/ (zsm . x1::Px1_m * ... * xl::Pxl_m * Pm_1 * ... * Pm_km)
<span class="lineno"> 1449 </span>--
<span class="lineno"> 1450 </span>-- where @zsi@ is a list of permission variables bound in the permissions @Pi_j@
<span class="lineno"> 1451 </span>-- and @xi::Pxi@ denotes the primary permission for variable @xi@. In the
<span class="lineno"> 1452 </span>-- comments below, we often omit the primary variable permissions when they do
<span class="lineno"> 1453 </span>-- not change. The types of @P1@ through @Pn@ are given by the first type
<span class="lineno"> 1454 </span>-- argument @ps_in@ of this type, while those of the @zsi@ and the @Pi_j@
<span class="lineno"> 1455 </span>-- permissions are given by the @ps_outs@ argument. The latter is an 'RList' of
<span class="lineno"> 1456 </span>-- the form
<span class="lineno"> 1457 </span>--
<span class="lineno"> 1458 </span>-- &gt; RNil :&gt; (bs1, ps1) :&gt; ... :&gt; (bsm, psm)
<span class="lineno"> 1459 </span>--
<span class="lineno"> 1460 </span>-- where each @bsi@ is itself an 'RList' of the types of the bound variables in
<span class="lineno"> 1461 </span>-- @zsi@ and @psi@ is an 'RList' of the types of @Pi_1@ through @Pi_km@.
<span class="lineno"> 1462 </span>--
<span class="lineno"> 1463 </span>-- To add a new @PermImpl1@ proof rule:
<span class="lineno"> 1464 </span>-- 1. Add a constructor @Impl1_NewConstructor@ and documentation to this
<span class="lineno"> 1465 </span>--    data structure
<span class="lineno"> 1466 </span>-- 2. Implement cases for the helper functions @permImplStep@,
<span class="lineno"> 1467 </span>--   @permImplSucceeds@, @applyImpl1@, and @genSubst@ for
<span class="lineno"> 1468 </span>--   @Impl1_NewConstructor@
<span class="lineno"> 1469 </span>-- 3. Implement a wrapper @newConstructorM@ using @implApplyImpl1@ to build
<span class="lineno"> 1470 </span>--    up a proof using that constructor in the @ImplM@ monad
<span class="lineno"> 1471 </span>-- 4. Implement the translation of the constructor by adding a case to
<span class="lineno"> 1472 </span>--    `translatePermImpl1` in `SAWTranslation.hs`.
<span class="lineno"> 1473 </span>data PermImpl1 ps_in ps_outs where
<span class="lineno"> 1474 </span>  -- | Failure of a permission implication, along with a string explanation of
<span class="lineno"> 1475 </span>  -- the failure, which is a proof of 0 disjuncts:
<span class="lineno"> 1476 </span>  --
<span class="lineno"> 1477 </span>  -- &gt; ps -o .
<span class="lineno"> 1478 </span>  Impl1_Fail :: ImplError -&gt; PermImpl1 ps RNil
<span class="lineno"> 1479 </span>
<span class="lineno"> 1480 </span>  -- | Catch any failure in the first branch by calling the second, passing the
<span class="lineno"> 1481 </span>  -- same input permissions to both branches:
<span class="lineno"> 1482 </span>  --
<span class="lineno"> 1483 </span>  -- &gt; ps -o ps \/ ps
<span class="lineno"> 1484 </span>  --
<span class="lineno"> 1485 </span>  -- The 'String' gives debug info about why the algorithm inserted the catch.
<span class="lineno"> 1486 </span>  Impl1_Catch :: String -&gt; PermImpl1 ps (RNil :&gt; '(RNil, ps) :&gt; '(RNil, ps))
<span class="lineno"> 1487 </span>
<span class="lineno"> 1488 </span>  -- | Push the primary permission for variable @x@ onto the stack:
<span class="lineno"> 1489 </span>  --
<span class="lineno"> 1490 </span>  -- &gt; x::P * ps -o x::true * ps * x:P
<span class="lineno"> 1491 </span>  Impl1_Push :: ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 1492 </span>                PermImpl1 ps (RNil :&gt; '(RNil, ps :&gt; a))
<span class="lineno"> 1493 </span>
<span class="lineno"> 1494 </span>  -- | Pop the a permission for variable @x@ back to the primary permission for
<span class="lineno"> 1495 </span>  -- @x@, assuming the latter is the trivial permission @true@:
<span class="lineno"> 1496 </span>  --
<span class="lineno"> 1497 </span>  -- &gt; x::true * ps * x:P -o x::P * ps
<span class="lineno"> 1498 </span>  Impl1_Pop :: ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 1499 </span>               PermImpl1 (ps :&gt; a) (RNil :&gt; '(RNil, ps))
<span class="lineno"> 1500 </span>
<span class="lineno"> 1501 </span>  -- | Eliminate a sequence of right-nested disjunctions:
<span class="lineno"> 1502 </span>  --
<span class="lineno"> 1503 </span>  -- &gt; ps * x:(p1 \/ (p2 \/ (... \/ pn)))
<span class="lineno"> 1504 </span>  -- &gt;   -o (ps * x:p1) \/ ... \/ (ps * x:pn)
<span class="lineno"> 1505 </span>  --
<span class="lineno"> 1506 </span>  -- The 'String' is contains the printed version of the @x:(p1 \/ ...)@
<span class="lineno"> 1507 </span>  -- permission that is being eliminated, for debug info.
<span class="lineno"> 1508 </span>  Impl1_ElimOrs :: String -&gt; ExprVar a -&gt; OrList ps a disjs -&gt;
<span class="lineno"> 1509 </span>                   PermImpl1 (ps :&gt; a) disjs
<span class="lineno"> 1510 </span>
<span class="lineno"> 1511 </span>  -- | Eliminate an existential on the top of the stack:
<span class="lineno"> 1512 </span>  --
<span class="lineno"> 1513 </span>  -- &gt; ps * x:(exists z.p) -o z. ps * x:p
<span class="lineno"> 1514 </span>  Impl1_ElimExists :: KnownRepr TypeRepr tp =&gt; ExprVar a -&gt;
<span class="lineno"> 1515 </span>                      Binding tp (ValuePerm a) -&gt;
<span class="lineno"> 1516 </span>                      PermImpl1 (ps :&gt; a) (RNil :&gt; '(RNil :&gt; tp, ps :&gt; a))
<span class="lineno"> 1517 </span>
<span class="lineno"> 1518 </span>  -- | Eliminate a @false@ permission on the top of the stack, which is a
<span class="lineno"> 1519 </span>  -- contradiction and so has no output disjuncts
<span class="lineno"> 1520 </span>  --
<span class="lineno"> 1521 </span>  -- &gt; ps * x:false -o .
<span class="lineno"> 1522 </span>  Impl1_ElimFalse :: ExprVar a -&gt; PermImpl1 (ps :&gt; a) RNil
<span class="lineno"> 1523 </span>
<span class="lineno"> 1524 </span>  -- | Apply a 'SimplImpl'
<span class="lineno"> 1525 </span>  Impl1_Simpl :: SimplImpl ps_in ps_out -&gt; Proxy ps -&gt;
<span class="lineno"> 1526 </span>                 PermImpl1 (ps :++: ps_in) (RNil :&gt; '(RNil, ps :++: ps_out))
<span class="lineno"> 1527 </span>
<span class="lineno"> 1528 </span>  -- | Let-bind a fresh variable @x@ to expression @e@, leaving an equality
<span class="lineno"> 1529 </span>  -- permission on top of the stack:
<span class="lineno"> 1530 </span>  --
<span class="lineno"> 1531 </span>  -- &gt; ps -o x. ps * x:eq(e)
<span class="lineno"> 1532 </span>  Impl1_LetBind :: TypeRepr tp -&gt; PermExpr tp -&gt;
<span class="lineno"> 1533 </span>                   PermImpl1 ps (RNil :&gt; '(RNil :&gt; tp, ps :&gt; tp))
<span class="lineno"> 1534 </span>
<span class="lineno"> 1535 </span>  -- | Project out a field of a struct @x@ by binding a fresh variable @y@ for
<span class="lineno"> 1536 </span>  -- its contents, and assign the permissions for that field to @y@, replacing
<span class="lineno"> 1537 </span>  -- them with a proof that the field equals @y@:
<span class="lineno"> 1538 </span>  --
<span class="lineno"> 1539 </span>  -- &gt; x:struct(ps,p,ps') -o y. x:struct(ps, eq(y), ps'), y:p
<span class="lineno"> 1540 </span>  Impl1_ElimStructField ::
<span class="lineno"> 1541 </span>    ExprVar (StructType ctx) -&gt; RAssign ValuePerm (CtxToRList ctx) -&gt;
<span class="lineno"> 1542 </span>    TypeRepr a -&gt; Member (CtxToRList ctx) a -&gt;
<span class="lineno"> 1543 </span>    PermImpl1 (ps :&gt; StructType ctx) (RNil :&gt; '(RNil :&gt; a,
<span class="lineno"> 1544 </span>                                                ps :&gt; StructType ctx :&gt; a))
<span class="lineno"> 1545 </span>
<span class="lineno"> 1546 </span>  -- | Eliminate the contents of an LLVM field permission, binding a new
<span class="lineno"> 1547 </span>  -- variable to hold those permissions and changing the contents of the field
<span class="lineno"> 1548 </span>  -- permission to an equals permision for that variable:
<span class="lineno"> 1549 </span>  --
<span class="lineno"> 1550 </span>  -- &gt; x:ptr((rw,off) -&gt; p) -o y. x:ptr((rw,off) -&gt; eq(y)) * y:p
<span class="lineno"> 1551 </span>  Impl1_ElimLLVMFieldContents ::
<span class="lineno"> 1552 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 1553 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 1554 </span>    PermImpl1 (ps :&gt; LLVMPointerType w)
<span class="lineno"> 1555 </span>    (RNil :&gt; '(RNil :&gt; LLVMPointerType sz,
<span class="lineno"> 1556 </span>               ps :&gt; LLVMPointerType w :&gt; LLVMPointerType sz))
<span class="lineno"> 1557 </span>
<span class="lineno"> 1558 </span>  -- | Eliminate an llvmblock permission of shape @sh@ to one of equality shape
<span class="lineno"> 1559 </span>  -- @eqsh(y)@ and a shape permission on @y@ for a fresh variable @y@:
<span class="lineno"> 1560 </span>  --
<span class="lineno"> 1561 </span>  -- &gt; x:memblock(rw,l,off,len,sh)
<span class="lineno"> 1562 </span>  -- &gt;   -o y. x:memblock(rw,l,off,len,eqsh(len,y)),
<span class="lineno"> 1563 </span>  -- &gt;         y:shape('modalize'(rw,l,sh))
<span class="lineno"> 1564 </span>  Impl1_ElimLLVMBlockToEq ::
<span class="lineno"> 1565 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 1566 </span>    PermImpl1 (ps :&gt; LLVMPointerType w)
<span class="lineno"> 1567 </span>    (RNil :&gt; '(RNil :&gt; LLVMBlockType w,
<span class="lineno"> 1568 </span>               ps :&gt; LLVMPointerType w :&gt; LLVMBlockType w))
<span class="lineno"> 1569 </span>
<span class="lineno"> 1570 </span>  -- | Split an LLVM field permission that points to a word value, creating
<span class="lineno"> 1571 </span>  -- fresh variables for the two portions of that word value:
<span class="lineno"> 1572 </span>  --
<span class="lineno"> 1573 </span>  -- &gt; x:[l]ptr((rw,off,sz2) |-&gt; eq(llvmword(e)))
<span class="lineno"> 1574 </span>  -- &gt;   -o y,z.[l]x:ptr((rw,off,sz1) |-&gt; eq(llvmword(y)))
<span class="lineno"> 1575 </span>  -- &gt;        * [l]x:ptr((rw,off+sz1/8,sz2-sz1) |-&gt; eq(llvmword(z)))
<span class="lineno"> 1576 </span>  -- &gt;        * y:p_y * z:p_z
<span class="lineno"> 1577 </span>  --
<span class="lineno"> 1578 </span>  -- If @e@ is a known constant bitvector value @bv1++bv2@, then @p_y@ is
<span class="lineno"> 1579 </span>  -- @eq(bv1)@ and @p_z@ is @eq(bv2)@, and otherwise these permissions are just
<span class="lineno"> 1580 </span>  -- @true@. Note that the definition of @++@ depends on the current endianness.
<span class="lineno"> 1581 </span>  Impl1_SplitLLVMWordField ::
<span class="lineno"> 1582 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2,
<span class="lineno"> 1583 </span>     1 &lt;= (sz2 - sz1), KnownNat (sz2 - sz1)) =&gt;
<span class="lineno"> 1584 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz2 -&gt;
<span class="lineno"> 1585 </span>    NatRepr sz1 -&gt; EndianForm -&gt;
<span class="lineno"> 1586 </span>    PermImpl1 (ps :&gt; LLVMPointerType w)
<span class="lineno"> 1587 </span>    (RNil :&gt; '(RNil :&gt; BVType sz1 :&gt; BVType (sz2 - sz1),
<span class="lineno"> 1588 </span>               ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w :&gt;
<span class="lineno"> 1589 </span>               BVType sz1 :&gt; BVType (sz2 - sz1)))
<span class="lineno"> 1590 </span>
<span class="lineno"> 1591 </span>  -- | Truncate an LLVM field permission that points to a word value, creating a
<span class="lineno"> 1592 </span>  -- fresh variable for the remaining portion of the word value:
<span class="lineno"> 1593 </span>  --
<span class="lineno"> 1594 </span>  -- &gt; x:[l]ptr((rw,off,sz2) |-&gt; eq(llvmword(e)))
<span class="lineno"> 1595 </span>  -- &gt;   -o y. [l]x:ptr((rw,off,sz1) |-&gt; eq(llvmword(y))) * y:p_y
<span class="lineno"> 1596 </span>  --
<span class="lineno"> 1597 </span>  -- If @e@ is a known constant bitvector value @bv1++bv2@, then @p_y@ is
<span class="lineno"> 1598 </span>  -- @eq(bv1)@, and otherwise @p_y@ is just @true@. Note that the definition of
<span class="lineno"> 1599 </span>  -- @++@ depends on the current endianness.
<span class="lineno"> 1600 </span>  Impl1_TruncateLLVMWordField ::
<span class="lineno"> 1601 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2) =&gt;
<span class="lineno"> 1602 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz2 -&gt;
<span class="lineno"> 1603 </span>    NatRepr sz1 -&gt; EndianForm -&gt;
<span class="lineno"> 1604 </span>    PermImpl1 (ps :&gt; LLVMPointerType w)
<span class="lineno"> 1605 </span>    (RNil :&gt; '(RNil :&gt; BVType sz1, ps :&gt; LLVMPointerType w :&gt; BVType sz1))
<span class="lineno"> 1606 </span>
<span class="lineno"> 1607 </span>  -- | Concatenate two LLVM field permissions that point to word values,
<span class="lineno"> 1608 </span>  -- creating a fresh value for the concatenation of these word values:
<span class="lineno"> 1609 </span>  --
<span class="lineno"> 1610 </span>  -- &gt; [l]x:ptr((rw,off,sz1) |-&gt; eq(llvmword(e1)))
<span class="lineno"> 1611 </span>  -- &gt; * [l]x:ptr((rw,off+sz1/2,sz2) |-&gt; eq(llvmword(e2)))
<span class="lineno"> 1612 </span>  -- &gt; -o y. x:[l]ptr((rw,off,sz1+sz2) |-&gt; eq(llvmword(y))) * y:p_y
<span class="lineno"> 1613 </span>  --
<span class="lineno"> 1614 </span>  -- If @e1@ and @e2@ are known constant bitvector values @bv1@ and @bv2@, then
<span class="lineno"> 1615 </span>  -- @p_y@ is @eq(bv1++bv2)@, and otherwise @p_y@ is just @true@. Note that the
<span class="lineno"> 1616 </span>  -- definition of @++@ depends on the current endianness.
<span class="lineno"> 1617 </span>  Impl1_ConcatLLVMWordFields ::
<span class="lineno"> 1618 </span>    (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2,
<span class="lineno"> 1619 </span>     1 &lt;= (sz1 + sz2), KnownNat (sz1 + sz2)) =&gt;
<span class="lineno"> 1620 </span>    ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz1 -&gt;
<span class="lineno"> 1621 </span>    PermExpr (BVType sz2) -&gt; EndianForm -&gt;
<span class="lineno"> 1622 </span>    PermImpl1 (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 1623 </span>    (RNil :&gt; '(RNil :&gt; BVType (sz1 + sz2),
<span class="lineno"> 1624 </span>               ps :&gt; LLVMPointerType w :&gt; BVType (sz1 + sz2)))
<span class="lineno"> 1625 </span>
<span class="lineno"> 1626 </span>  -- | Begin a new lifetime:
<span class="lineno"> 1627 </span>  --
<span class="lineno"> 1628 </span>  -- &gt; . -o ret:lowned(empty -o empty)
<span class="lineno"> 1629 </span>  Impl1_BeginLifetime ::
<span class="lineno"> 1630 </span>    PermImpl1 ps (RNil :&gt; '(RNil :&gt; LifetimeType, ps :&gt; LifetimeType))
<span class="lineno"> 1631 </span>
<span class="lineno"> 1632 </span>  -- | Try to prove a bitvector proposition, or fail (as in the 'Impl1_Fail'
<span class="lineno"> 1633 </span>  -- rule) if this is not possible, where the 'String' is a pretty-printing of
<span class="lineno"> 1634 </span>  -- the proposition (for ease of translation):
<span class="lineno"> 1635 </span>  --
<span class="lineno"> 1636 </span>  -- &gt; . -o prop(p)
<span class="lineno"> 1637 </span>  Impl1_TryProveBVProp ::
<span class="lineno"> 1638 </span>    (1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt; BVProp w -&gt;
<span class="lineno"> 1639 </span>    String -&gt; PermImpl1 ps (RNil :&gt; '(RNil, ps :&gt; LLVMPointerType w))
<span class="lineno"> 1640 </span>
<span class="lineno"> 1641 </span>
<span class="lineno"> 1642 </span>-- | A single disjunct of type @a@ being eliminated, with permissions @ps@ on
<span class="lineno"> 1643 </span>-- the stack below the disjunction
<span class="lineno"> 1644 </span>data OrListDisj (ps :: RList CrucibleType) a
<span class="lineno"> 1645 </span>     (disj :: (RList CrucibleType, RList CrucibleType)) where
<span class="lineno"> 1646 </span>  OrListDisj :: ValuePerm a -&gt; OrListDisj ps a '(RNil, ps :&gt; a)
<span class="lineno"> 1647 </span>
<span class="lineno"> 1648 </span>-- | A sequence of disjuncts being eliminated, with permissions @ps@ on the
<span class="lineno"> 1649 </span>-- stack below the disjunction
<span class="lineno"> 1650 </span>type OrList ps a = RAssign (OrListDisj ps a)
<span class="lineno"> 1651 </span>
<span class="lineno"> 1652 </span>-- | A @'PermImpl' r ps@ is a proof tree of the judgment
<span class="lineno"> 1653 </span>--
<span class="lineno"> 1654 </span>-- &gt; Gamma | Pl * P |- (Gamma1 | Pl1 * P1) \/ ... \/ (Gamman | Pln * Pn)
<span class="lineno"> 1655 </span>--
<span class="lineno"> 1656 </span>-- that contains an element of type @r@ at each leaf of the proof tree. Each
<span class="lineno"> 1657 </span>-- disjunct on the right of the judgment corresponds to a different leaf in the
<span class="lineno"> 1658 </span>-- tree, while each @Gammai@ denotes the variables that are bound on the path
<span class="lineno"> 1659 </span>-- from the root to that leaf. The @ps@ argument captures the form of the
<span class="lineno"> 1660 </span>-- \&quot;distinguished\&quot; left-hand side permissions @Pl@.
<span class="lineno"> 1661 </span>--
<span class="lineno"> 1662 </span>-- FIXME: explain that @Pl@ is like a stack, and that intro rules apply to the
<span class="lineno"> 1663 </span>-- top of the stack
<span class="lineno"> 1664 </span>--
<span class="lineno"> 1665 </span>-- FIXME: it would be nice to have PermImpl r ps_out ps_in, where ps_out is
<span class="lineno"> 1666 </span>-- guaranteed to be the stack shape at any Impl_Done, but this would make our
<span class="lineno"> 1667 </span>-- generalized monad below more complicated...
<span class="lineno"> 1668 </span>data PermImpl r ps where
<span class="lineno"> 1669 </span>  PermImpl_Done :: !(r ps) -&gt; PermImpl r ps
<span class="lineno"> 1670 </span>  PermImpl_Step :: !(PermImpl1 ps_in ps_outs) -&gt;
<span class="lineno"> 1671 </span>                   !(MbPermImpls r ps_outs) -&gt;
<span class="lineno"> 1672 </span>                   PermImpl r ps_in
<span class="lineno"> 1673 </span>
<span class="lineno"> 1674 </span>-- | Helper type for 'PermImpl', that defines a collection of permission
<span class="lineno"> 1675 </span>-- implications, one for each element of the @bs_pss@ type argument. Each of
<span class="lineno"> 1676 </span>-- these elements are of the form @(bs,ps)@, where @ps@ determines the input
<span class="lineno"> 1677 </span>-- permissions for that implication tree and @bs@ specifies an existential
<span class="lineno"> 1678 </span>-- contexts of bound variables for that implication tree.
<span class="lineno"> 1679 </span>data MbPermImpls r bs_pss where
<span class="lineno"> 1680 </span>  MbPermImpls_Nil :: MbPermImpls r RNil
<span class="lineno"> 1681 </span>  MbPermImpls_Cons :: CruCtx bs -&gt;
<span class="lineno"> 1682 </span>                      !(MbPermImpls r bs_pss) -&gt;
<span class="lineno"> 1683 </span>                      !(Mb bs (PermImpl r ps)) -&gt;
<span class="lineno"> 1684 </span>                      MbPermImpls r (bs_pss :&gt; '(bs,ps))
<span class="lineno"> 1685 </span>
<span class="lineno"> 1686 </span>-- | A local implication, from an input to an output permission set
<span class="lineno"> 1687 </span>newtype LocalPermImpl ps_in ps_out =
<span class="lineno"> 1688 </span>  LocalPermImpl (PermImpl (LocalImplRet ps_out) ps_in)
<span class="lineno"> 1689 </span>
<span class="lineno"> 1690 </span>-- | The \&quot;success\&quot; condition of a 'LocalPermImpl', which essentially is just a
<span class="lineno"> 1691 </span>-- type equality stating that the output permissions are as expected
<span class="lineno"> 1692 </span>newtype LocalImplRet ps ps' = LocalImplRet (ps :~: ps')
<span class="lineno"> 1693 </span>
<span class="lineno"> 1694 </span>-- | The identity implication
<span class="lineno"> 1695 </span>idLocalPermImpl :: LocalPermImpl ps ps
<span class="lineno"> 1696 </span><span class="decl"><span class="nottickedoff">idLocalPermImpl = LocalPermImpl $ PermImpl_Done $ LocalImplRet Refl</span></span>
<span class="lineno"> 1697 </span>
<span class="lineno"> 1698 </span>-- type IsLLVMPointerTypeList w ps = RAssign ((:~:) (LLVMPointerType w)) ps
<span class="lineno"> 1699 </span>
<span class="lineno"> 1700 </span>-- Many of these types are mutually recursive. Moreover, Template Haskell
<span class="lineno"> 1701 </span>-- declaration splices strictly separate top-level groups, so if we were to
<span class="lineno"> 1702 </span>-- write each $(mkNuMatching [t| ... |]) splice individually, the splices
<span class="lineno"> 1703 </span>-- involving mutually recursive types would not typecheck. As a result, we
<span class="lineno"> 1704 </span>-- must put everything into a single splice so that it forms a single top-level
<span class="lineno"> 1705 </span>-- group.
<span class="lineno"> 1706 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(concatMapM mkNuMatching</span>
<span class="lineno"> 1707 </span><span class="spaces">  </span><span class="nottickedoff">[ [t| forall a. EqPerm a |]</span>
<span class="lineno"> 1708 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps a. NuMatching a =&gt; EqProofStep ps a |]</span>
<span class="lineno"> 1709 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps a. NuMatching a =&gt; EqProof ps a |]</span>
<span class="lineno"> 1710 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps_in ps_out. SimplImpl ps_in ps_out |]</span>
<span class="lineno"> 1711 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps_in ps_outs. PermImpl1 ps_in ps_outs |]</span>
<span class="lineno"> 1712 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps a disj. OrListDisj ps a disj |]</span>
<span class="lineno"> 1713 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall r bs_pss. NuMatchingAny1 r =&gt; MbPermImpls r bs_pss |]</span>
<span class="lineno"> 1714 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall r ps. NuMatchingAny1 r =&gt; PermImpl r ps |]</span>
<span class="lineno"> 1715 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps_in ps_out. LocalPermImpl ps_in ps_out |]</span>
<span class="lineno"> 1716 </span><span class="spaces">  </span><span class="nottickedoff">, [t| forall ps ps'. LocalImplRet ps ps' |]</span>
<span class="lineno"> 1717 </span><span class="spaces">  </span><span class="nottickedoff">])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1718 </span>
<span class="lineno"> 1719 </span>-- | A splitting of an existential list of permissions into a prefix, a single
<span class="lineno"> 1720 </span>-- variable plus permission, and then a suffix
<span class="lineno"> 1721 </span>data DistPermsSplit ps where
<span class="lineno"> 1722 </span>  DistPermsSplit :: RAssign Proxy ps1 -&gt; RAssign Proxy ps2 -&gt;
<span class="lineno"> 1723 </span>                    DistPerms (ps1 :++: ps2) -&gt;
<span class="lineno"> 1724 </span>                    ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 1725 </span>                    DistPermsSplit (ps1 :&gt; a :++: ps2)
<span class="lineno"> 1726 </span>
<span class="lineno"> 1727 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ps. DistPermsSplit ps |])</span></span></span>
<span class="lineno"> 1728 </span>
<span class="lineno"> 1729 </span>-- FIXME: delete all of this?
<span class="lineno"> 1730 </span>{-
<span class="lineno"> 1731 </span>-- | Compile-time flag for whether to prune failure branches in 'implCatchM'
<span class="lineno"> 1732 </span>pruneFailingBranches :: Bool
<span class="lineno"> 1733 </span>pruneFailingBranches = False
<span class="lineno"> 1734 </span>
<span class="lineno"> 1735 </span>-- | Apply the 'PermImpl_Step' constructor to a 'PermImpl1' rule and its
<span class="lineno"> 1736 </span>-- sub-proofs, performing the following simplifications (some of which are
<span class="lineno"> 1737 </span>-- performed by the helper function 'permImplCatch'), where @unary impl@
<span class="lineno"> 1738 </span>-- represents any unary rule applied to the implication @impl@:
<span class="lineno"> 1739 </span>--
<span class="lineno"> 1740 </span>-- &gt; unary (fail msg) --&gt; fail msg
<span class="lineno"> 1741 </span>-- &gt; unary (catch impl (fail msg)) --&gt; catch (unary impl) (fail msg)
<span class="lineno"> 1742 </span>-- &gt; catch (fail msg1) (fail msg2) --&gt; fail (msg1 ++ msg2)
<span class="lineno"> 1743 </span>-- &gt; catch (catch impl1 impl2) impl3 --&gt; catch impl1 (catch impl2 impl3)
<span class="lineno"> 1744 </span>-- &gt; elim_or (fail msg1) (fail msg2) --&gt; fail (msg1 ++ msg2)
<span class="lineno"> 1745 </span>permImplStep :: NuMatchingAny1 r =&gt; PermImpl1 ps_in ps_outs -&gt;
<span class="lineno"> 1746 </span>                MbPermImpls r ps_outs -&gt; PermImpl r ps_in
<span class="lineno"> 1747 </span>
<span class="lineno"> 1748 </span>-- No need to simplify a fail
<span class="lineno"> 1749 </span>permImplStep impl1@(Impl1_Fail _) mb_impls = PermImpl_Step impl1 mb_impls
<span class="lineno"> 1750 </span>
<span class="lineno"> 1751 </span>-- Catch --&gt; call the permImplCatch function
<span class="lineno"> 1752 </span>permImplStep Impl1_Catch ((MbPermImpls_Cons _
<span class="lineno"> 1753 </span>                           (MbPermImpls_Cons _ _ mb_pimpl1) mb_pimpl2)) =
<span class="lineno"> 1754 </span>  permImplCatch (elimEmptyMb mb_pimpl1) (elimEmptyMb mb_pimpl2)
<span class="lineno"> 1755 </span>
<span class="lineno"> 1756 </span>-- Unary rules applied to failure --&gt; failures
<span class="lineno"> 1757 </span>--
<span class="lineno"> 1758 </span>-- NOTE: we write the cases all out explicitly in case we add a new Impl1 rule
<span class="lineno"> 1759 </span>-- that does not work this way, since not simplifying is better than
<span class="lineno"> 1760 </span>-- oversimplifying
<span class="lineno"> 1761 </span>permImplStep impl1@(Impl1_Push _ _) mb_impls =
<span class="lineno"> 1762 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1763 </span>permImplStep impl1@(Impl1_Pop _ _) mb_impls =
<span class="lineno"> 1764 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1765 </span>permImplStep impl1@(Impl1_ElimExists _ _) mb_impls =
<span class="lineno"> 1766 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1767 </span>permImplStep impl1@(Impl1_Simpl _ _) mb_impls =
<span class="lineno"> 1768 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1769 </span>permImplStep impl1@(Impl1_LetBind _ _) mb_impls =
<span class="lineno"> 1770 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1771 </span>permImplStep impl1@(Impl1_ElimStructField _ _ _ _) mb_impls =
<span class="lineno"> 1772 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1773 </span>permImplStep impl1@(Impl1_ElimLLVMFieldContents _ _) mb_impls =
<span class="lineno"> 1774 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1775 </span>permImplStep impl1@(Impl1_BeginLifetime) mb_impls =
<span class="lineno"> 1776 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1777 </span>permImplStep impl1@(Impl1_TryProveBVProp _ _ _) mb_impls =
<span class="lineno"> 1778 </span>  permImplStepUnary impl1 mb_impls
<span class="lineno"> 1779 </span>
<span class="lineno"> 1780 </span>-- An or elimination fails if both branches fail
<span class="lineno"> 1781 </span>permImplStep (Impl1_ElimOr _ _ _) (MbPermImpls_Cons _
<span class="lineno"> 1782 </span>                                   (MbPermImpls_Cons _ MbPermImpls_Nil
<span class="lineno"> 1783 </span>                                    (matchMbImplFail -&gt; Just msg1))
<span class="lineno"> 1784 </span>                                   (matchMbImplFail -&gt; Just msg2)) =
<span class="lineno"> 1785 </span>  PermImpl_Step (Impl1_Fail $ GeneralError $ pretty
<span class="lineno"> 1786 </span>                  (msg1 ++ &quot;\n\n--------------------\n\n&quot; ++ msg2))
<span class="lineno"> 1787 </span>  MbPermImpls_Nil
<span class="lineno"> 1788 </span>
<span class="lineno"> 1789 </span>-- Default case: just apply PermImpl_Step
<span class="lineno"> 1790 </span>permImplStep impl1 mb_impls = PermImpl_Step impl1 mb_impls
<span class="lineno"> 1791 </span>
<span class="lineno"> 1792 </span>
<span class="lineno"> 1793 </span>-- | Helper for 'permImplStep': apply the 'PermImpl_Step' constructor to a unary
<span class="lineno"> 1794 </span>-- 'PermImpl1' rule and an implication that follows it, performing the necessary
<span class="lineno"> 1795 </span>-- simplifications
<span class="lineno"> 1796 </span>permImplStepUnary :: NuMatchingAny1 r =&gt;
<span class="lineno"> 1797 </span>                     PermImpl1 ps_in (RNil :&gt; '(bs, ps_out)) -&gt;
<span class="lineno"> 1798 </span>                     MbPermImpls r (RNil :&gt; '(bs, ps_out)) -&gt; PermImpl r ps_in
<span class="lineno"> 1799 </span>
<span class="lineno"> 1800 </span>-- If the continuation implication is a failure, percolate it up
<span class="lineno"> 1801 </span>permImplStepUnary _ (MbPermImpls_Cons _ _ (matchMbImplFail -&gt; Just msg)) =
<span class="lineno"> 1802 </span>  PermImpl_Step (Impl1_Fail $ GeneralError $ pretty msg) MbPermImpls_Nil
<span class="lineno"> 1803 </span>
<span class="lineno"> 1804 </span>-- If the continuation implication is a catch with a failure on the right-hand
<span class="lineno"> 1805 </span>-- side, percolate up the catch
<span class="lineno"> 1806 </span>{- FIXME: this exposes some weird performance bug!
<span class="lineno"> 1807 </span>permImplStepUnary impl1 (MbPermImpls_Cons MbPermImpls_Nil
<span class="lineno"> 1808 </span>                         (matchMbImplCatchFail -&gt; Just (mb_impl, msg))) =
<span class="lineno"> 1809 </span>    PermImpl_Step Impl1_Catch
<span class="lineno"> 1810 </span>    (MbPermImpls_Cons
<span class="lineno"> 1811 </span>     (MbPermImpls_Cons MbPermImpls_Nil $
<span class="lineno"> 1812 </span>      emptyMb $ PermImpl_Step impl1 $
<span class="lineno"> 1813 </span>      MbPermImpls_Cons MbPermImpls_Nil mb_impl)
<span class="lineno"> 1814 </span>     (emptyMb $ PermImpl_Step (Impl1_Fail msg) MbPermImpls_Nil))
<span class="lineno"> 1815 </span>-}
<span class="lineno"> 1816 </span>
<span class="lineno"> 1817 </span>-- Default case: just apply PermImpl_Step
<span class="lineno"> 1818 </span>permImplStepUnary impl1 mb_impls = PermImpl_Step impl1 mb_impls
<span class="lineno"> 1819 </span>
<span class="lineno"> 1820 </span>-- | Pattern-match an implication inside a binding to see if it is just a
<span class="lineno"> 1821 </span>-- failure, and if so, return the failure message, all without requiring a
<span class="lineno"> 1822 </span>-- 'NuMatchingAny1' constraint on the @r@ variable
<span class="lineno"> 1823 </span>matchMbImplFail :: NuMatchingAny1 r =&gt; Mb ctx (PermImpl r ps) -&gt; Maybe String
<span class="lineno"> 1824 </span>matchMbImplFail mb_impl = case mbMatch mb_impl of
<span class="lineno"> 1825 </span>  [nuMP| PermImpl_Step (Impl1_Fail err) _ |] -&gt; Just $ mbLift $ fmap ppError err
<span class="lineno"> 1826 </span>  _ -&gt; Nothing
<span class="lineno"> 1827 </span>
<span class="lineno"> 1828 </span>-- | Pattern-matchin an implication inside a binding to see if it is a catch
<span class="lineno"> 1829 </span>-- whose right-hand side is just a failure, all without requiring a
<span class="lineno"> 1830 </span>-- 'NuMatchingAny1' constraint on the @r@ variable
<span class="lineno"> 1831 </span>matchMbImplCatchFail :: NuMatchingAny1 r =&gt;
<span class="lineno"> 1832 </span>                        Mb (ctx :: RList CrucibleType) (PermImpl r ps) -&gt;
<span class="lineno"> 1833 </span>                        Maybe (Mb ctx (PermImpl r ps), String)
<span class="lineno"> 1834 </span>matchMbImplCatchFail mb_impl = case mbMatch mb_impl of
<span class="lineno"> 1835 </span>  [nuMP| PermImpl_Step Impl1_Catch
<span class="lineno"> 1836 </span>                      (MbPermImpls_Cons _ (MbPermImpls_Cons _ _ mb_impl1)
<span class="lineno"> 1837 </span>                      mb_impl2) |]
<span class="lineno"> 1838 </span>    | Just msg &lt;- matchMbImplFail (mbCombine RL.typeCtxProxies mb_impl2) -&gt;
<span class="lineno"> 1839 </span>      Just (mbCombine RL.typeCtxProxies mb_impl1, msg)
<span class="lineno"> 1840 </span>  _ -&gt; Nothing
<span class="lineno"> 1841 </span>
<span class="lineno"> 1842 </span>-- | Produce a branching proof tree that performs the first implication and, if
<span class="lineno"> 1843 </span>-- that one fails, falls back on the second. If 'pruneFailingBranches' is set,
<span class="lineno"> 1844 </span>-- failing branches are pruned; otherwise, catches are reorganized so that they
<span class="lineno"> 1845 </span>-- are right-nested, and any failures are combined.
<span class="lineno"> 1846 </span>permImplCatch :: PermImpl r ps -&gt; PermImpl r ps -&gt; PermImpl r ps
<span class="lineno"> 1847 </span>permImplCatch (PermImpl_Step (Impl1_Fail _) _) pimpl
<span class="lineno"> 1848 </span>  | pruneFailingBranches = pimpl
<span class="lineno"> 1849 </span>permImplCatch pimpl (PermImpl_Step (Impl1_Fail _) _)
<span class="lineno"> 1850 </span>  | pruneFailingBranches = pimpl
<span class="lineno"> 1851 </span>permImplCatch (PermImpl_Step (Impl1_Fail str1) _) (PermImpl_Step
<span class="lineno"> 1852 </span>                                                   (Impl1_Fail str2) mb_impls) =
<span class="lineno"> 1853 </span>  PermImpl_Step (Impl1_Fail $ GeneralError $
<span class="lineno"> 1854 </span>      pretty (ppError str1 ++ &quot;\n\n--------------------\n\n&quot; ++ ppError str2))
<span class="lineno"> 1855 </span>    mb_impls
<span class="lineno"> 1856 </span>permImplCatch pimpl1@(PermImpl_Step (Impl1_Fail _) _) pimpl2 =
<span class="lineno"> 1857 </span>  permImplCatch pimpl2 pimpl1
<span class="lineno"> 1858 </span>permImplCatch (PermImpl_Step Impl1_Catch
<span class="lineno"> 1859 </span>               (MbPermImpls_Cons _
<span class="lineno"> 1860 </span>                (MbPermImpls_Cons _ _ mb_pimpl_1a) mb_pimpl_1b)) pimpl2 =
<span class="lineno"> 1861 </span>  permImplCatch (elimEmptyMb mb_pimpl_1a) $
<span class="lineno"> 1862 </span>  permImplCatch (elimEmptyMb mb_pimpl_1b) pimpl2
<span class="lineno"> 1863 </span>permImplCatch pimpl1 pimpl2 =
<span class="lineno"> 1864 </span>  PermImpl_Step Impl1_Catch $
<span class="lineno"> 1865 </span>  MbPermImpls_Cons knownRepr (MbPermImpls_Cons knownRepr MbPermImpls_Nil $ emptyMb pimpl1) $
<span class="lineno"> 1866 </span>  emptyMb pimpl2
<span class="lineno"> 1867 </span>-}
<span class="lineno"> 1868 </span>
<span class="lineno"> 1869 </span>
<span class="lineno"> 1870 </span>-- | Test if a 'PermImpl' \&quot;succeeds\&quot;, meaning there is at least one non-failing
<span class="lineno"> 1871 </span>-- branch. If it does succeed, return a heuristic number for how \&quot;well\&quot; it
<span class="lineno"> 1872 </span>-- succeeds; e.g., rate a 'PermImpl' higher if all disjunctive branches succeed,
<span class="lineno"> 1873 </span>-- that is, if both children of every 'Impl1_ElimOr' succeed. Return 0 if the
<span class="lineno"> 1874 </span>-- 'PermImpl' does not succeed at all.
<span class="lineno"> 1875 </span>permImplSucceeds :: PermImpl r ps -&gt; Int
<span class="lineno"> 1876 </span><span class="decl"><span class="nottickedoff">permImplSucceeds (PermImpl_Done _) = 2</span>
<span class="lineno"> 1877 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_Fail _) _) = 0</span>
<span class="lineno"> 1878 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_Catch _)</span>
<span class="lineno"> 1879 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ (MbPermImpls_Cons _ _ mb_impl1) mb_impl2)) =</span>
<span class="lineno"> 1880 </span><span class="spaces">  </span><span class="nottickedoff">max (mbLift $ fmap permImplSucceeds mb_impl1)</span>
<span class="lineno"> 1881 </span><span class="spaces">  </span><span class="nottickedoff">(mbLift $ fmap permImplSucceeds mb_impl2)</span>
<span class="lineno"> 1882 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_Push _ _) (MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1883 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1884 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_Pop _ _) (MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1885 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1886 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimOrs _ _ _) mb_impls) =</span>
<span class="lineno"> 1887 </span><span class="spaces">  </span><span class="nottickedoff">mbImplsSucc mb_impls where</span>
<span class="lineno"> 1888 </span><span class="spaces">  </span><span class="nottickedoff">mbImplsSucc :: MbPermImpls r ps_outs -&gt; Int</span>
<span class="lineno"> 1889 </span><span class="spaces">  </span><span class="nottickedoff">mbImplsSucc MbPermImpls_Nil = 0</span>
<span class="lineno"> 1890 </span><span class="spaces">  </span><span class="nottickedoff">mbImplsSucc (MbPermImpls_Cons _ mb_impls' mb_impl) =</span>
<span class="lineno"> 1891 </span><span class="spaces">    </span><span class="nottickedoff">max (mbImplsSucc mb_impls') (mbLift $ fmap permImplSucceeds mb_impl)</span>
<span class="lineno"> 1892 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 1893 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimOr _ _ _)</span>
<span class="lineno"> 1894 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ (MbPermImpls_Cons _ _ mb_impl1) mb_impl2)) =</span>
<span class="lineno"> 1895 </span><span class="spaces">  </span><span class="nottickedoff">max (mbLift (fmap permImplSucceeds mb_impl1))</span>
<span class="lineno"> 1896 </span><span class="spaces">  </span><span class="nottickedoff">(mbLift (fmap permImplSucceeds mb_impl2))</span>
<span class="lineno"> 1897 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 1898 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimExists _ _)</span>
<span class="lineno"> 1899 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1900 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1901 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimFalse _) _) = 2</span>
<span class="lineno"> 1902 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_Simpl _ _)</span>
<span class="lineno"> 1903 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1904 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1905 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_LetBind _ _)</span>
<span class="lineno"> 1906 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1907 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1908 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimStructField _ _ _ _)</span>
<span class="lineno"> 1909 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1910 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1911 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimLLVMFieldContents _ _)</span>
<span class="lineno"> 1912 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1913 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1914 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ElimLLVMBlockToEq _ _)</span>
<span class="lineno"> 1915 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1916 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1917 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_SplitLLVMWordField _ _ _ _)</span>
<span class="lineno"> 1918 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1919 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1920 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_TruncateLLVMWordField _ _ _ _)</span>
<span class="lineno"> 1921 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1922 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1923 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_ConcatLLVMWordFields _ _ _ _)</span>
<span class="lineno"> 1924 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1925 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1926 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step Impl1_BeginLifetime</span>
<span class="lineno"> 1927 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1928 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span>
<span class="lineno"> 1929 </span><span class="spaces"></span><span class="nottickedoff">permImplSucceeds (PermImpl_Step (Impl1_TryProveBVProp _ _ _)</span>
<span class="lineno"> 1930 </span><span class="spaces">                  </span><span class="nottickedoff">(MbPermImpls_Cons _ _ mb_impl)) =</span>
<span class="lineno"> 1931 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap permImplSucceeds mb_impl</span></span>
<span class="lineno"> 1932 </span>
<span class="lineno"> 1933 </span>-- | Test if a 'PermImpl' fails, meaning 'permImplSucceeds' returns 0
<span class="lineno"> 1934 </span>permImplFails :: PermImpl r ps -&gt; Bool
<span class="lineno"> 1935 </span><span class="decl"><span class="nottickedoff">permImplFails = (== 0) . permImplSucceeds</span></span>
<span class="lineno"> 1936 </span>
<span class="lineno"> 1937 </span>
<span class="lineno"> 1938 </span>-- FIXME: no longer needed...?
<span class="lineno"> 1939 </span>-- traversePermImpl :: forall m ps r1 r2.
<span class="lineno"> 1940 </span>--                     MonadStrongBind m =&gt; (forall ps'. r1 ps' -&gt; m (r2 ps')) -&gt;
<span class="lineno"> 1941 </span>--                     PermImpl r1 ps -&gt; m (PermImpl r2 ps)
<span class="lineno"> 1942 </span>-- traversePermImpl f (PermImpl_Done r) = PermImpl_Done &lt;$&gt; f r
<span class="lineno"> 1943 </span>-- traversePermImpl f (PermImpl_Step impl1 mb_perm_impls) =
<span class="lineno"> 1944 </span>--   PermImpl_Step impl1 &lt;$&gt; helper mb_perm_impls
<span class="lineno"> 1945 </span>--   where
<span class="lineno"> 1946 </span>--     helper :: MbPermImpls r1 bs_pss -&gt; m (MbPermImpls r2 bs_pss)
<span class="lineno"> 1947 </span>--     helper MbPermImpls_Nil = return MbPermImpls_Nil
<span class="lineno"> 1948 </span>--     helper (MbPermImpls_Cons _ mb_impls mb_impl) =
<span class="lineno"> 1949 </span>--       do mb_impls' &lt;- helper mb_impls
<span class="lineno"> 1950 </span>--          mb_impl' &lt;- strongMbM (fmap (traversePermImpl f) mb_impl)
<span class="lineno"> 1951 </span>--          return (MbPermImpls_Cons _ mb_impls' mb_impl')
<span class="lineno"> 1952 </span>
<span class="lineno"> 1953 </span>-- | Assert a condition and print an error message if it fails
<span class="lineno"> 1954 </span>--
<span class="lineno"> 1955 </span>-- FIXME: put this somewhere more meaningful...
<span class="lineno"> 1956 </span>permAssert :: Bool -&gt; String -&gt; a -&gt; a
<span class="lineno"> 1957 </span><span class="decl"><span class="nottickedoff">permAssert True _ a = a</span>
<span class="lineno"> 1958 </span><span class="spaces"></span><span class="nottickedoff">permAssert False str _ = error str</span></span>
<span class="lineno"> 1959 </span>
<span class="lineno"> 1960 </span>-- | Compute the input permissions of a 'SimplImpl' implication
<span class="lineno"> 1961 </span>simplImplIn :: SimplImpl ps_in ps_out -&gt; DistPerms ps_in
<span class="lineno"> 1962 </span><span class="decl"><span class="nottickedoff">simplImplIn (SImpl_Drop x p) = distPerms1 x p</span>
<span class="lineno"> 1963 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_Copy x p) =</span>
<span class="lineno"> 1964 </span><span class="spaces">  </span><span class="nottickedoff">permAssert (permIsCopyable p)</span>
<span class="lineno"> 1965 </span><span class="spaces">  </span><span class="nottickedoff">&quot;simplImplIn: SImpl_Copy: permission is not copyable!&quot; $</span>
<span class="lineno"> 1966 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x p</span>
<span class="lineno"> 1967 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_Swap x p1 y p2) = distPerms2 x p1 y p2</span>
<span class="lineno"> 1968 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_MoveUp ps1 x p ps2) =</span>
<span class="lineno"> 1969 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (distPerms1 x p) $ appendDistPerms ps1 ps2</span>
<span class="lineno"> 1970 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_MoveDown ps1 x p ps2) =</span>
<span class="lineno"> 1971 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (DistPermsCons ps1 x p) ps2</span>
<span class="lineno"> 1972 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroOrL x p1 _) = distPerms1 x p1</span>
<span class="lineno"> 1973 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroOrR x _ p2) = distPerms1 x p2</span>
<span class="lineno"> 1974 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroExists x e p) =</span>
<span class="lineno"> 1975 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (subst (singletonSubst e) p)</span>
<span class="lineno"> 1976 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_Cast x y p) = distPerms2 x (ValPerm_Eq $ PExpr_Var y) y p</span>
<span class="lineno"> 1977 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CastPerm x eqp) =</span>
<span class="lineno"> 1978 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (distPerms1 x (eqProofLHS eqp)) (eqProofPerms eqp)</span>
<span class="lineno"> 1979 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroEqRefl _) = DistPermsNil</span>
<span class="lineno"> 1980 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_InvertEq x y) = distPerms1 x (ValPerm_Eq $ PExpr_Var y)</span>
<span class="lineno"> 1981 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_InvTransEq x y e) =</span>
<span class="lineno"> 1982 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq e) y (ValPerm_Eq e)</span>
<span class="lineno"> 1983 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_UnitEq _ _) = DistPermsNil</span>
<span class="lineno"> 1984 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CopyEq x e) = distPerms1 x (ValPerm_Eq e)</span>
<span class="lineno"> 1985 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMWordEq x y e) =</span>
<span class="lineno"> 1986 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq (PExpr_LLVMWord (PExpr_Var y))) y (ValPerm_Eq e)</span>
<span class="lineno"> 1987 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMOffsetZeroEq _) = DistPermsNil</span>
<span class="lineno"> 1988 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroConj _) = DistPermsNil</span>
<span class="lineno"> 1989 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ExtractConj x ps _) = distPerms1 x (ValPerm_Conj ps)</span>
<span class="lineno"> 1990 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CopyConj x ps _) = distPerms1 x (ValPerm_Conj ps)</span>
<span class="lineno"> 1991 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_InsertConj x p ps _) =</span>
<span class="lineno"> 1992 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [p]) x (ValPerm_Conj ps)</span>
<span class="lineno"> 1993 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_AppendConjs x ps1 ps2) =</span>
<span class="lineno"> 1994 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj ps1) x (ValPerm_Conj ps2)</span>
<span class="lineno"> 1995 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_SplitConjs x ps _) =</span>
<span class="lineno"> 1996 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj ps)</span>
<span class="lineno"> 1997 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroStructTrue _ _) = DistPermsNil</span>
<span class="lineno"> 1998 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_StructEqToPerm x exprs) =</span>
<span class="lineno"> 1999 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_Struct exprs)</span>
<span class="lineno"> 2000 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_StructPermToEq x exprs) =</span>
<span class="lineno"> 2001 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_Struct $</span>
<span class="lineno"> 2002 </span><span class="spaces">                </span><span class="nottickedoff">RL.map ValPerm_Eq $ exprsToRAssign exprs)</span>
<span class="lineno"> 2003 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroStructField x ps memb p) =</span>
<span class="lineno"> 2004 </span><span class="spaces">  </span><span class="nottickedoff">case RL.get memb ps of</span>
<span class="lineno"> 2005 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq (PExpr_Var y) -&gt;</span>
<span class="lineno"> 2006 </span><span class="spaces">      </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj1 $ Perm_Struct ps) y p</span>
<span class="lineno"> 2007 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_IntroStructField: field does not have an equality permission to a variable&quot;</span>
<span class="lineno"> 2008 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ConstFunPerm x h _ _) =</span>
<span class="lineno"> 2009 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_Fun h)</span>
<span class="lineno"> 2010 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CastLLVMWord x e1 e2) =</span>
<span class="lineno"> 2011 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq $ PExpr_LLVMWord e1)</span>
<span class="lineno"> 2012 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj [Perm_BVProp $ BVProp_Eq e1 e2])</span>
<span class="lineno"> 2013 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_InvertLLVMOffsetEq x off y) =</span>
<span class="lineno"> 2014 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_Eq $ PExpr_LLVMOffset y off</span>
<span class="lineno"> 2015 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_OffsetLLVMWord y e off x) =</span>
<span class="lineno"> 2016 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq $ PExpr_LLVMOffset y off)</span>
<span class="lineno"> 2017 </span><span class="spaces">  </span><span class="nottickedoff">y (ValPerm_Eq (PExpr_LLVMWord e))</span>
<span class="lineno"> 2018 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CastLLVMPtr y p off x) =</span>
<span class="lineno"> 2019 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq $ PExpr_LLVMOffset y off) y p</span>
<span class="lineno"> 2020 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CastLLVMFree x e1 e2) =</span>
<span class="lineno"> 2021 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMFree e1])</span>
<span class="lineno"> 2022 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj [Perm_BVProp $ BVProp_Eq e1 e2])</span>
<span class="lineno"> 2023 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CastLLVMFieldOffset x fld off') =</span>
<span class="lineno"> 2024 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMField fld])</span>
<span class="lineno"> 2025 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj [Perm_BVProp $ BVProp_Eq (llvmFieldOffset fld) off'])</span>
<span class="lineno"> 2026 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMFieldContents x y fld) =</span>
<span class="lineno"> 2027 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMField $</span>
<span class="lineno"> 2028 </span><span class="spaces">                              </span><span class="nottickedoff">fld { llvmFieldContents =</span>
<span class="lineno"> 2029 </span><span class="spaces">                                    </span><span class="nottickedoff">ValPerm_Eq (PExpr_Var y)}])</span>
<span class="lineno"> 2030 </span><span class="spaces">  </span><span class="nottickedoff">y (llvmFieldContents fld)</span>
<span class="lineno"> 2031 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_DemoteLLVMFieldRW x fld) =</span>
<span class="lineno"> 2032 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMField fld])</span>
<span class="lineno"> 2033 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_SplitLLVMTrueField x fp _ _) =</span>
<span class="lineno"> 2034 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFieldContents fp of</span>
<span class="lineno"> 2035 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True -&gt; distPerms1 x $ ValPerm_LLVMField fp</span>
<span class="lineno"> 2036 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_SplitLLVMTrueField: malformed field permission&quot;</span>
<span class="lineno"> 2037 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_TruncateLLVMTrueField x fp _) =</span>
<span class="lineno"> 2038 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFieldContents fp of</span>
<span class="lineno"> 2039 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True -&gt; distPerms1 x $ ValPerm_LLVMField fp</span>
<span class="lineno"> 2040 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_TruncateLLVMTrueField: malformed field permission&quot;</span>
<span class="lineno"> 2041 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ConcatLLVMTrueFields x fp1 sz2) =</span>
<span class="lineno"> 2042 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFieldContents fp1 of</span>
<span class="lineno"> 2043 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True -&gt;</span>
<span class="lineno"> 2044 </span><span class="spaces">      </span><span class="nottickedoff">distPerms2 x (ValPerm_LLVMField fp1) x (ValPerm_LLVMField $</span>
<span class="lineno"> 2045 </span><span class="spaces">                                              </span><span class="nottickedoff">llvmFieldAddOffsetInt</span>
<span class="lineno"> 2046 </span><span class="spaces">                                              </span><span class="nottickedoff">(llvmFieldSetTrue fp1 sz2)</span>
<span class="lineno"> 2047 </span><span class="spaces">                                              </span><span class="nottickedoff">(intValue (natRepr fp1) `div` 8))</span>
<span class="lineno"> 2048 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_ConcatLLVMTrueFields: malformed field permission&quot;</span>
<span class="lineno"> 2049 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_DemoteLLVMArrayRW x ap) =</span>
<span class="lineno"> 2050 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2051 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayCopy x ap off len) =</span>
<span class="lineno"> 2052 </span><span class="spaces">  </span><span class="nottickedoff">if isJust (matchLLVMArrayCell ap off) &amp;&amp;</span>
<span class="lineno"> 2053 </span><span class="spaces">     </span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMArray ap) then</span>
<span class="lineno"> 2054 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2055 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj $ map Perm_BVProp $ llvmArrayContainsArray ap $</span>
<span class="lineno"> 2056 </span><span class="spaces">       </span><span class="nottickedoff">llvmMakeSubArray ap off len)</span>
<span class="lineno"> 2057 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2058 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayCopy: array permission not copyable or not a sub-array&quot;</span>
<span class="lineno"> 2059 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayBorrow x ap off len) =</span>
<span class="lineno"> 2060 </span><span class="spaces">  </span><span class="nottickedoff">if isJust (matchLLVMArrayCell ap off) then</span>
<span class="lineno"> 2061 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2062 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj $ map Perm_BVProp $ llvmArrayContainsArray ap $</span>
<span class="lineno"> 2063 </span><span class="spaces">       </span><span class="nottickedoff">llvmMakeSubArray ap off len)</span>
<span class="lineno"> 2064 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2065 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayBorrow: array permission not a sub-array&quot;</span>
<span class="lineno"> 2066 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayReturn x ap ret_ap) =</span>
<span class="lineno"> 2067 </span><span class="spaces">  </span><span class="nottickedoff">if isJust (llvmArrayIsOffsetArray ap ret_ap) &amp;&amp;</span>
<span class="lineno"> 2068 </span><span class="spaces">     </span><span class="nottickedoff">elem (llvmSubArrayBorrow ap ret_ap) (llvmArrayBorrows ap) then</span>
<span class="lineno"> 2069 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMArray ret_ap])</span>
<span class="lineno"> 2070 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2071 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2072 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;simplImplIn: SImpl_LLVMArrayReturn: array not being borrowed or not a sub-array:\n&quot; ++</span>
<span class="lineno"> 2073 </span><span class="spaces">            </span><span class="nottickedoff">renderDoc (</span>
<span class="lineno"> 2074 </span><span class="spaces">              </span><span class="nottickedoff">permPretty emptyPPInfo (ap, ret_ap)</span>
<span class="lineno"> 2075 </span><span class="spaces">                      </span><span class="nottickedoff">)</span>
<span class="lineno"> 2076 </span><span class="spaces">          </span><span class="nottickedoff">)</span>
<span class="lineno"> 2077 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2078 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayAppend x ap1 ap2) =</span>
<span class="lineno"> 2079 </span><span class="spaces">  </span><span class="nottickedoff">case llvmArrayIsOffsetArray ap1 ap2 of</span>
<span class="lineno"> 2080 </span><span class="spaces">    </span><span class="nottickedoff">Just len1</span>
<span class="lineno"> 2081 </span><span class="spaces">      </span><span class="nottickedoff">| bvEq len1 (llvmArrayLen ap1)</span>
<span class="lineno"> 2082 </span><span class="spaces">      </span><span class="nottickedoff">, llvmArrayCellShape ap1 == llvmArrayCellShape ap2 -&gt;</span>
<span class="lineno"> 2083 </span><span class="spaces">        </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj1 $ Perm_LLVMArray ap1)</span>
<span class="lineno"> 2084 </span><span class="spaces">        </span><span class="nottickedoff">x (ValPerm_Conj1 $ Perm_LLVMArray ap2)</span>
<span class="lineno"> 2085 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_LLVMArrayAppend: arrays cannot be appended&quot;</span>
<span class="lineno"> 2086 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2087 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayRearrange x ap bs) =</span>
<span class="lineno"> 2088 </span><span class="spaces">  </span><span class="nottickedoff">if llvmArrayBorrowsPermuteTo ap bs then</span>
<span class="lineno"> 2089 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMArray ap)</span>
<span class="lineno"> 2090 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2091 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayRearrange: malformed output borrows list&quot;</span>
<span class="lineno"> 2092 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2093 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayToField x ap _) =</span>
<span class="lineno"> 2094 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMArray ap)</span>
<span class="lineno"> 2095 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2096 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayEmpty _ ap) =</span>
<span class="lineno"> 2097 </span><span class="spaces">  </span><span class="nottickedoff">if bvIsZero (llvmArrayLen ap) then DistPermsNil else</span>
<span class="lineno"> 2098 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayEmpty: malformed empty array permission&quot;</span>
<span class="lineno"> 2099 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayBorrowed x bp ap) =</span>
<span class="lineno"> 2100 </span><span class="spaces">  </span><span class="nottickedoff">if llvmArrayIsBorrowed ap &amp;&amp; llvmBlockShape bp == llvmArrayCellShape ap then</span>
<span class="lineno"> 2101 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2102 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2103 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayBorrowed: array permission not completely borrowed or of the wrong shape&quot;</span>
<span class="lineno"> 2104 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayFromBlock x bp) =</span>
<span class="lineno"> 2105 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2106 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2107 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayCellCopy x ap cell) =</span>
<span class="lineno"> 2108 </span><span class="spaces">  </span><span class="nottickedoff">if atomicPermIsCopyable (Perm_LLVMArray ap) then</span>
<span class="lineno"> 2109 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_LLVMArray ap)</span>
<span class="lineno"> 2110 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj $ map Perm_BVProp $ llvmArrayCellInArray ap cell)</span>
<span class="lineno"> 2111 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2112 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayCellCopy: array is not copyable&quot;</span>
<span class="lineno"> 2113 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2114 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayCellBorrow x ap cell) =</span>
<span class="lineno"> 2115 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2116 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj $ map Perm_BVProp $ llvmArrayCellInArray ap cell)</span>
<span class="lineno"> 2117 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2118 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayCellReturn x ap cell) =</span>
<span class="lineno"> 2119 </span><span class="spaces">  </span><span class="nottickedoff">if elem (FieldBorrow cell) (llvmArrayBorrows ap) then</span>
<span class="lineno"> 2120 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_LLVMBlock $ llvmArrayCellPerm ap cell)</span>
<span class="lineno"> 2121 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2122 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2123 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_LLVMArrayCellReturn: index not being borrowed&quot;</span>
<span class="lineno"> 2124 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2125 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayContents x ap _ _) =</span>
<span class="lineno"> 2126 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2127 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMFieldIsPtr x fp) =</span>
<span class="lineno"> 2128 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMField fp])</span>
<span class="lineno"> 2129 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMArrayIsPtr x ap) =</span>
<span class="lineno"> 2130 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2131 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LLVMBlockIsPtr x bp) =</span>
<span class="lineno"> 2132 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMBlock bp])</span>
<span class="lineno"> 2133 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_SplitLifetime x f args l l2 sub_ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 2134 </span><span class="spaces">  </span><span class="nottickedoff">-- If l=always then the second permission is l2:true</span>
<span class="lineno"> 2135 </span><span class="spaces">  </span><span class="nottickedoff">let (l',l'_p) = lcurrentPerm l l2 in</span>
<span class="lineno"> 2136 </span><span class="spaces">  </span><span class="nottickedoff">distPerms3 x (ltFuncApply f args l) l' l'_p</span>
<span class="lineno"> 2137 </span><span class="spaces">  </span><span class="nottickedoff">l2 (ValPerm_LOwned sub_ls tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 2138 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_SubsumeLifetime l ls tps_in tps_out ps_in ps_out _) =</span>
<span class="lineno"> 2139 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l (ValPerm_LOwned ls tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 2140 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ContainedLifetimeCurrent l ls tps_in tps_out ps_in ps_out l2) =</span>
<span class="lineno"> 2141 </span><span class="spaces">  </span><span class="nottickedoff">if elem l2 ls then</span>
<span class="lineno"> 2142 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 l (ValPerm_LOwned ls tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 2143 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2144 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;simplImplIn: SImpl_ContainedLifetimeCurrent: &quot; ++</span>
<span class="lineno"> 2145 </span><span class="spaces">           </span><span class="nottickedoff">&quot;lifetime not in contained lifetimes&quot;)</span>
<span class="lineno"> 2146 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_RemoveContainedLifetime l ls tps_in tps_out ps_in ps_out l2) =</span>
<span class="lineno"> 2147 </span><span class="spaces">  </span><span class="nottickedoff">if elem (PExpr_Var l2) ls then</span>
<span class="lineno"> 2148 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 l (ValPerm_LOwned ls tps_in tps_out ps_in ps_out) l2 ValPerm_LFinished</span>
<span class="lineno"> 2149 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2150 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;simplImplIn: SImpl_RemoveContainedLifetime: &quot; ++</span>
<span class="lineno"> 2151 </span><span class="spaces">           </span><span class="nottickedoff">&quot;lifetime not in contained lifetimes&quot;)</span>
<span class="lineno"> 2152 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_WeakenLifetime x f args l l2) =</span>
<span class="lineno"> 2153 </span><span class="spaces">  </span><span class="nottickedoff">let (l',l'_p) = lcurrentPerm l l2 in</span>
<span class="lineno"> 2154 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ltFuncApply f args l) l' l'_p</span>
<span class="lineno"> 2155 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_MapLifetime l ls tps_in tps_out ps_in ps_out _ _ _ _ ps1 ps2 _ _) =</span>
<span class="lineno"> 2156 </span><span class="spaces">  </span><span class="nottickedoff">RL.append ps1 $ DistPermsCons ps2 l $</span>
<span class="lineno"> 2157 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LOwned ls tps_in tps_out ps_in ps_out</span>
<span class="lineno"> 2158 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_EndLifetime l tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 2159 </span><span class="spaces">  </span><span class="nottickedoff">case exprPermsToDistPerms ps_in of</span>
<span class="lineno"> 2160 </span><span class="spaces">    </span><span class="nottickedoff">Just perms_in -&gt;</span>
<span class="lineno"> 2161 </span><span class="spaces">      </span><span class="nottickedoff">DistPermsCons perms_in l $ ValPerm_LOwned [] tps_in tps_out ps_in ps_out</span>
<span class="lineno"> 2162 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2163 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_EndLifetime: non-variables in input permissions&quot;</span>
<span class="lineno"> 2164 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLOwnedSimple l _ lops) =</span>
<span class="lineno"> 2165 </span><span class="spaces">  </span><span class="nottickedoff">case exprPermsToDistPerms lops of</span>
<span class="lineno"> 2166 </span><span class="spaces">    </span><span class="nottickedoff">Just dps -&gt; DistPermsCons dps l (ValPerm_LOwned [] CruCtxNil CruCtxNil MNil MNil)</span>
<span class="lineno"> 2167 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2168 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_IntroLOwnedSimple: malformed permissions list&quot;</span>
<span class="lineno"> 2169 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLOwnedSimple l tps lops) =</span>
<span class="lineno"> 2170 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l (ValPerm_LOwnedSimple tps lops)</span>
<span class="lineno"> 2171 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LCurrentRefl _) = DistPermsNil</span>
<span class="lineno"> 2172 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_LCurrentTrans l1 l2 l3) =</span>
<span class="lineno"> 2173 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 l1 (ValPerm_LCurrent $ PExpr_Var l2) l2 (ValPerm_LCurrent l3)</span>
<span class="lineno"> 2174 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockEmpty _ _) = DistPermsNil</span>
<span class="lineno"> 2175 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_DemoteLLVMBlockRW x bp) =</span>
<span class="lineno"> 2176 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2177 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_CoerceLLVMBlockEmpty x bp) =</span>
<span class="lineno"> 2178 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2179 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockToBytes x bp) =</span>
<span class="lineno"> 2180 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2181 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockTuple x bp) =</span>
<span class="lineno"> 2182 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2183 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockTuple x bp) =</span>
<span class="lineno"> 2184 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2185 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_TupShape (llvmBlockShape bp) })</span>
<span class="lineno"> 2186 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockSeqEmpty x bp) =</span>
<span class="lineno"> 2187 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2188 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockSeqEmpty x bp) =</span>
<span class="lineno"> 2189 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2190 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape =</span>
<span class="lineno"> 2191 </span><span class="spaces">                       </span><span class="nottickedoff">PExpr_SeqShape (llvmBlockShape bp) PExpr_EmptyShape })</span>
<span class="lineno"> 2192 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_SplitLLVMBlockEmpty x bp len1) =</span>
<span class="lineno"> 2193 </span><span class="spaces">  </span><span class="nottickedoff">if llvmBlockShape bp == PExpr_EmptyShape &amp;&amp; bvLt len1 (llvmBlockLen bp) then</span>
<span class="lineno"> 2194 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMBlock bp)</span>
<span class="lineno"> 2195 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2196 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_SplitLLVMBlockEmpty: length too long!&quot;</span>
<span class="lineno"> 2197 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockNamed x bp nmsh) =</span>
<span class="lineno"> 2198 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2199 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_NamedShape rw l nmsh' args</span>
<span class="lineno"> 2200 </span><span class="spaces">      </span><span class="nottickedoff">| Just (Refl,Refl) &lt;- namedShapeEq nmsh nmsh'</span>
<span class="lineno"> 2201 </span><span class="spaces">      </span><span class="nottickedoff">, Just sh' &lt;- unfoldModalizeNamedShape rw l nmsh args -&gt;</span>
<span class="lineno"> 2202 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMBlock $ bp { llvmBlockShape = sh' })</span>
<span class="lineno"> 2203 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_IntroLLVMBlockNamed: unexpected block shape&quot;</span>
<span class="lineno"> 2204 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockNamed x bp _) =</span>
<span class="lineno"> 2205 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2206 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockNamedMods x bp) =</span>
<span class="lineno"> 2207 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2208 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_NamedShape maybe_rw maybe_l nmsh args</span>
<span class="lineno"> 2209 </span><span class="spaces">      </span><span class="nottickedoff">| rw &lt;- fromMaybe (llvmBlockRW bp) maybe_rw</span>
<span class="lineno"> 2210 </span><span class="spaces">      </span><span class="nottickedoff">, l &lt;- fromMaybe (llvmBlockLifetime bp) maybe_l -&gt;</span>
<span class="lineno"> 2211 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock $</span>
<span class="lineno"> 2212 </span><span class="spaces">        </span><span class="nottickedoff">bp { llvmBlockRW = rw, llvmBlockLifetime = l,</span>
<span class="lineno"> 2213 </span><span class="spaces">             </span><span class="nottickedoff">llvmBlockShape = PExpr_NamedShape Nothing Nothing nmsh args }</span>
<span class="lineno"> 2214 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImpl_IntroLLVMBlockNamedMods: malformed input permission&quot;</span>
<span class="lineno"> 2215 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockNamedMods x bp) =</span>
<span class="lineno"> 2216 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2217 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockFromEq x bp y) =</span>
<span class="lineno"> 2218 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2219 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape =</span>
<span class="lineno"> 2220 </span><span class="spaces">                       </span><span class="nottickedoff">PExpr_EqShape (llvmBlockLen bp) $ PExpr_Var y })</span>
<span class="lineno"> 2221 </span><span class="spaces">  </span><span class="nottickedoff">y (ValPerm_Conj1 $ Perm_LLVMBlockShape $ llvmBlockShape bp)</span>
<span class="lineno"> 2222 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockPtr x bp) =</span>
<span class="lineno"> 2223 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockPtrShapeUnfold bp of</span>
<span class="lineno"> 2224 </span><span class="spaces">    </span><span class="nottickedoff">Just bp' -&gt; distPerms1 x $ ValPerm_LLVMBlock bp'</span>
<span class="lineno"> 2225 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; error &quot;simplImplIn: SImpl_IntroLLVMBlockPtr: malformed block shape&quot;</span>
<span class="lineno"> 2226 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockPtr x bp) =</span>
<span class="lineno"> 2227 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2228 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockField x fp) =</span>
<span class="lineno"> 2229 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMField fp)</span>
<span class="lineno"> 2230 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockField x fp) =</span>
<span class="lineno"> 2231 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $ llvmFieldPermToBlock fp)</span>
<span class="lineno"> 2232 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockArray x ap) =</span>
<span class="lineno"> 2233 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMArray ap)</span>
<span class="lineno"> 2234 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockArray x bp) =</span>
<span class="lineno"> 2235 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2236 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockSeq x bp1 len2 sh2) =</span>
<span class="lineno"> 2237 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2</span>
<span class="lineno"> 2238 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj1 $ Perm_LLVMBlock bp1)</span>
<span class="lineno"> 2239 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2240 </span><span class="spaces">     </span><span class="nottickedoff">bp1 { llvmBlockOffset = bvAdd (llvmBlockOffset bp1) (llvmBlockLen bp1),</span>
<span class="lineno"> 2241 </span><span class="spaces">           </span><span class="nottickedoff">llvmBlockLen = len2, llvmBlockShape = sh2 })</span>
<span class="lineno"> 2242 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockSeq x bp sh2) =</span>
<span class="lineno"> 2243 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2244 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_SeqShape (llvmBlockShape bp) sh2 })</span>
<span class="lineno"> 2245 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockOr x bp1 sh2) =</span>
<span class="lineno"> 2246 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Or</span>
<span class="lineno"> 2247 </span><span class="spaces">                </span><span class="nottickedoff">(ValPerm_Conj1 $ Perm_LLVMBlock bp1)</span>
<span class="lineno"> 2248 </span><span class="spaces">                </span><span class="nottickedoff">(ValPerm_Conj1 $ Perm_LLVMBlock $ bp1 { llvmBlockShape = sh2 }))</span>
<span class="lineno"> 2249 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockOr x bp shs) =</span>
<span class="lineno"> 2250 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2251 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape = foldr1 PExpr_OrShape shs })</span>
<span class="lineno"> 2252 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroLLVMBlockEx x bp) =</span>
<span class="lineno"> 2253 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2254 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_ExShape mb_sh -&gt;</span>
<span class="lineno"> 2255 </span><span class="spaces">      </span><span class="nottickedoff">distPerms1 x (ValPerm_Exists $</span>
<span class="lineno"> 2256 </span><span class="spaces">                    </span><span class="nottickedoff">flip fmap mb_sh $ \sh -&gt;</span>
<span class="lineno"> 2257 </span><span class="spaces">                     </span><span class="nottickedoff">ValPerm_LLVMBlock (bp { llvmBlockShape = sh }))</span>
<span class="lineno"> 2258 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2259 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_IntroLLVMBlockEx: non-existential shape&quot;</span>
<span class="lineno"> 2260 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockEx x bp) =</span>
<span class="lineno"> 2261 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMBlock bp)</span>
<span class="lineno"> 2262 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimLLVMBlockFalse x bp) =</span>
<span class="lineno"> 2263 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMBlock bp)</span>
<span class="lineno"> 2264 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_FoldNamed x np args off) =</span>
<span class="lineno"> 2265 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (unfoldPerm np args off)</span>
<span class="lineno"> 2266 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_UnfoldNamed x np args off) =</span>
<span class="lineno"> 2267 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named (namedPermName np) args off)</span>
<span class="lineno"> 2268 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_NamedToConj x npn args off) =</span>
<span class="lineno"> 2269 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn args off)</span>
<span class="lineno"> 2270 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_NamedFromConj x npn args off) =</span>
<span class="lineno"> 2271 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_NamedConj npn args off)</span>
<span class="lineno"> 2272 </span><span class="spaces"></span><span class="nottickedoff">-- simplImplIn (SImpl_Mu x p1 _ _) = distPerms1 x (ValPerm_Mu p1)</span>
<span class="lineno"> 2273 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_NamedArgAlways x npn args off memb _) =</span>
<span class="lineno"> 2274 </span><span class="spaces">  </span><span class="nottickedoff">case nthPermExpr args memb of</span>
<span class="lineno"> 2275 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Always -&gt; distPerms1 x (ValPerm_Named npn args off)</span>
<span class="lineno"> 2276 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImplNamedArgAlways: non-always argument!&quot;</span>
<span class="lineno"> 2277 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_NamedArgCurrent x npn args off memb l2) =</span>
<span class="lineno"> 2278 </span><span class="spaces">  </span><span class="nottickedoff">case nthPermExpr args memb of</span>
<span class="lineno"> 2279 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Var l1 -&gt;</span>
<span class="lineno"> 2280 </span><span class="spaces">      </span><span class="nottickedoff">distPerms2 x (ValPerm_Named npn args off) l1 (ValPerm_LCurrent l2)</span>
<span class="lineno"> 2281 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImplNamedArgCurrent: non-variable argument!&quot;</span>
<span class="lineno"> 2282 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_NamedArgWrite x npn args off memb _) =</span>
<span class="lineno"> 2283 </span><span class="spaces">  </span><span class="nottickedoff">case nthPermExpr args memb of</span>
<span class="lineno"> 2284 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_RWModality Write -&gt;</span>
<span class="lineno"> 2285 </span><span class="spaces">      </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn args off)</span>
<span class="lineno"> 2286 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplIn: SImplNamedArgWrite: non-Write argument!&quot;</span>
<span class="lineno"> 2287 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_NamedArgRead x npn args off _) =</span>
<span class="lineno"> 2288 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn args off)</span>
<span class="lineno"> 2289 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ReachabilityTrans x rp args off y e) =</span>
<span class="lineno"> 2290 </span><span class="spaces">  </span><span class="nottickedoff">let npn = recPermName rp in</span>
<span class="lineno"> 2291 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Named npn (PExprs_Cons args (PExpr_Var y)) off)</span>
<span class="lineno"> 2292 </span><span class="spaces">  </span><span class="nottickedoff">y (ValPerm_Named npn (PExprs_Cons args e) off)</span>
<span class="lineno"> 2293 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroAnyEqEq x e1 e2) =</span>
<span class="lineno"> 2294 </span><span class="spaces">  </span><span class="nottickedoff">if exprsUnequal e1 e2 then</span>
<span class="lineno"> 2295 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq e1) x (ValPerm_Eq e2)</span>
<span class="lineno"> 2296 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2297 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_IntroAnyEqEq: expressions not unequal&quot;</span>
<span class="lineno"> 2298 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_IntroAnyWordPtr x e p) =</span>
<span class="lineno"> 2299 </span><span class="spaces">  </span><span class="nottickedoff">if isLLVMPointerPerm p then</span>
<span class="lineno"> 2300 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Eq $ PExpr_LLVMWord e) x (ValPerm_Conj1 p)</span>
<span class="lineno"> 2301 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2302 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_IntroAnyWordPtr: expressions not unequal&quot;</span>
<span class="lineno"> 2303 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimAnyToEq x _) =</span>
<span class="lineno"> 2304 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x ValPerm_Any</span>
<span class="lineno"> 2305 </span><span class="spaces"></span><span class="nottickedoff">simplImplIn (SImpl_ElimAnyToPtr x _) = distPerms1 x ValPerm_Any</span></span>
<span class="lineno"> 2306 </span>
<span class="lineno"> 2307 </span>-- | Compute the output permissions of a 'SimplImpl' implication
<span class="lineno"> 2308 </span>simplImplOut :: SimplImpl ps_in ps_out -&gt; DistPerms ps_out
<span class="lineno"> 2309 </span><span class="decl"><span class="nottickedoff">simplImplOut (SImpl_Drop _ _) = DistPermsNil</span>
<span class="lineno"> 2310 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_Copy x p) =</span>
<span class="lineno"> 2311 </span><span class="spaces">  </span><span class="nottickedoff">if permIsCopyable p then distPerms2 x p x p else</span>
<span class="lineno"> 2312 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_Copy: permission is not copyable!&quot;</span>
<span class="lineno"> 2313 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_Swap x p1 y p2) = distPerms2 y p2 x p1</span>
<span class="lineno"> 2314 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_MoveUp ps1 x p ps2) =</span>
<span class="lineno"> 2315 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (DistPermsCons ps1 x p) ps2</span>
<span class="lineno"> 2316 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_MoveDown ps1 x p ps2) =</span>
<span class="lineno"> 2317 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (distPerms1 x p) $ appendDistPerms ps1 ps2</span>
<span class="lineno"> 2318 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroOrL x p1 p2) = distPerms1 x (ValPerm_Or p1 p2)</span>
<span class="lineno"> 2319 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroOrR x p1 p2) = distPerms1 x (ValPerm_Or p1 p2)</span>
<span class="lineno"> 2320 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroExists x _ p) = distPerms1 x (ValPerm_Exists p)</span>
<span class="lineno"> 2321 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_Cast x _ p) = distPerms1 x p</span>
<span class="lineno"> 2322 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CastPerm x eqp) =</span>
<span class="lineno"> 2323 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms (distPerms1 x (eqProofRHS eqp)) (eqProofPerms eqp)</span>
<span class="lineno"> 2324 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroEqRefl x) = distPerms1 x (ValPerm_Eq $ PExpr_Var x)</span>
<span class="lineno"> 2325 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_InvertEq x y) = distPerms1 y (ValPerm_Eq $ PExpr_Var x)</span>
<span class="lineno"> 2326 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_InvTransEq x y _) = distPerms1 x (ValPerm_Eq $ PExpr_Var y)</span>
<span class="lineno"> 2327 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_UnitEq x e) = distPerms1 x (ValPerm_Eq e)</span>
<span class="lineno"> 2328 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CopyEq x e) = distPerms2 x (ValPerm_Eq e) x (ValPerm_Eq e)</span>
<span class="lineno"> 2329 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMWordEq x _ e) =</span>
<span class="lineno"> 2330 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq (PExpr_LLVMWord e))</span>
<span class="lineno"> 2331 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMOffsetZeroEq x) =</span>
<span class="lineno"> 2332 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq (PExpr_LLVMOffset x (zeroOfType (BVRepr knownNat))))</span>
<span class="lineno"> 2333 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroConj x) = distPerms1 x ValPerm_True</span>
<span class="lineno"> 2334 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ExtractConj x ps i) =</span>
<span class="lineno"> 2335 </span><span class="spaces">  </span><span class="nottickedoff">if i &lt; length ps then</span>
<span class="lineno"> 2336 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [ps !! i])</span>
<span class="lineno"> 2337 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj (take i ps ++ drop (i+1) ps))</span>
<span class="lineno"> 2338 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2339 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_ExtractConj: index out of bounds&quot;</span>
<span class="lineno"> 2340 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CopyConj x ps i) =</span>
<span class="lineno"> 2341 </span><span class="spaces">  </span><span class="nottickedoff">if i &lt; length ps &amp;&amp; atomicPermIsCopyable (ps !! i) then</span>
<span class="lineno"> 2342 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [ps !! i]) x (ValPerm_Conj ps)</span>
<span class="lineno"> 2343 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2344 </span><span class="spaces">    </span><span class="nottickedoff">if i &gt;= length ps then</span>
<span class="lineno"> 2345 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_CopyConj: index out of bounds&quot;</span>
<span class="lineno"> 2346 </span><span class="spaces">    </span><span class="nottickedoff">else</span>
<span class="lineno"> 2347 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_CopyConj: permission not copyable&quot;</span>
<span class="lineno"> 2348 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_InsertConj x p ps i) =</span>
<span class="lineno"> 2349 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj (take i ps ++ p : drop i ps))</span>
<span class="lineno"> 2350 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_AppendConjs x ps1 ps2) =</span>
<span class="lineno"> 2351 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj (ps1 ++ ps2))</span>
<span class="lineno"> 2352 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_SplitConjs x ps i) =</span>
<span class="lineno"> 2353 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj (take i ps)) x (ValPerm_Conj (drop i ps))</span>
<span class="lineno"> 2354 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroStructTrue x fs) =</span>
<span class="lineno"> 2355 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_Struct $ trueValuePerms fs)</span>
<span class="lineno"> 2356 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_StructEqToPerm x exprs) =</span>
<span class="lineno"> 2357 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_Struct $</span>
<span class="lineno"> 2358 </span><span class="spaces">                </span><span class="nottickedoff">RL.map ValPerm_Eq $ exprsToRAssign exprs)</span>
<span class="lineno"> 2359 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_StructPermToEq x exprs) =</span>
<span class="lineno"> 2360 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_Struct exprs)</span>
<span class="lineno"> 2361 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroStructField x ps memb p) =</span>
<span class="lineno"> 2362 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_Struct $ RL.set memb p ps)</span>
<span class="lineno"> 2363 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ConstFunPerm x _ fun_perm _) =</span>
<span class="lineno"> 2364 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_Fun fun_perm)</span>
<span class="lineno"> 2365 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CastLLVMWord x _ e2) =</span>
<span class="lineno"> 2366 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_LLVMWord e2)</span>
<span class="lineno"> 2367 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_InvertLLVMOffsetEq x off y) =</span>
<span class="lineno"> 2368 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 y $ ValPerm_Eq $ PExpr_LLVMOffset x $ bvNegate off</span>
<span class="lineno"> 2369 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_OffsetLLVMWord _ e off x) =</span>
<span class="lineno"> 2370 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_LLVMWord $ bvAdd e off)</span>
<span class="lineno"> 2371 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CastLLVMPtr _ p off x) =</span>
<span class="lineno"> 2372 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (offsetLLVMPerm (bvNegate off) p)</span>
<span class="lineno"> 2373 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CastLLVMFree x _ e2) =</span>
<span class="lineno"> 2374 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMFree e2])</span>
<span class="lineno"> 2375 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CastLLVMFieldOffset x fld off') =</span>
<span class="lineno"> 2376 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMField $ fld { llvmFieldOffset = off' }])</span>
<span class="lineno"> 2377 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMFieldContents x _ fld) =</span>
<span class="lineno"> 2378 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMField fld])</span>
<span class="lineno"> 2379 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_DemoteLLVMFieldRW x fld) =</span>
<span class="lineno"> 2380 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMField $</span>
<span class="lineno"> 2381 </span><span class="spaces">                              </span><span class="nottickedoff">fld { llvmFieldRW = PExpr_Read }])</span>
<span class="lineno"> 2382 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_SplitLLVMTrueField x fp sz1 sz2m1) =</span>
<span class="lineno"> 2383 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFieldContents fp of</span>
<span class="lineno"> 2384 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True -&gt;</span>
<span class="lineno"> 2385 </span><span class="spaces">      </span><span class="nottickedoff">distPerms2 x (ValPerm_LLVMField $ llvmFieldSetTrue fp sz1)</span>
<span class="lineno"> 2386 </span><span class="spaces">      </span><span class="nottickedoff">x (ValPerm_LLVMField $</span>
<span class="lineno"> 2387 </span><span class="spaces">         </span><span class="nottickedoff">llvmFieldAddOffsetInt (llvmFieldSetTrue fp sz2m1)</span>
<span class="lineno"> 2388 </span><span class="spaces">         </span><span class="nottickedoff">(intValue (natRepr sz1) `div` 8))</span>
<span class="lineno"> 2389 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_SplitLLVMTrueField: malformed field permission&quot;</span>
<span class="lineno"> 2390 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_TruncateLLVMTrueField x fp sz1) =</span>
<span class="lineno"> 2391 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFieldContents fp of</span>
<span class="lineno"> 2392 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True</span>
<span class="lineno"> 2393 </span><span class="spaces">      </span><span class="nottickedoff">| intValue sz1 &lt; intValue (llvmFieldSize fp) -&gt;</span>
<span class="lineno"> 2394 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMField $ llvmFieldSetTrue fp sz1)</span>
<span class="lineno"> 2395 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_TruncateLLVMTrueField: malformed field permission&quot;</span>
<span class="lineno"> 2396 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ConcatLLVMTrueFields x fp1 sz2) =</span>
<span class="lineno"> 2397 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFieldContents fp1 of</span>
<span class="lineno"> 2398 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_True -&gt;</span>
<span class="lineno"> 2399 </span><span class="spaces">      </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMField $</span>
<span class="lineno"> 2400 </span><span class="spaces">                    </span><span class="nottickedoff">llvmFieldSetTrue fp1 (addNat (llvmFieldSize fp1) sz2))</span>
<span class="lineno"> 2401 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_ConcatLLVMTrueFields: malformed field permission&quot;</span>
<span class="lineno"> 2402 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_DemoteLLVMArrayRW x ap) =</span>
<span class="lineno"> 2403 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMArray $</span>
<span class="lineno"> 2404 </span><span class="spaces">                              </span><span class="nottickedoff">ap { llvmArrayRW = PExpr_Read }])</span>
<span class="lineno"> 2405 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayCopy x ap off len) =</span>
<span class="lineno"> 2406 </span><span class="spaces">  </span><span class="nottickedoff">if isJust (matchLLVMArrayCell ap off) &amp;&amp;</span>
<span class="lineno"> 2407 </span><span class="spaces">     </span><span class="nottickedoff">atomicPermIsCopyable (Perm_LLVMArray ap) then</span>
<span class="lineno"> 2408 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMArray $ llvmMakeSubArray ap off len])</span>
<span class="lineno"> 2409 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2410 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2411 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayCopy: array permission not copyable or not a sub-array&quot;</span>
<span class="lineno"> 2412 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2413 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayBorrow x ap off len) =</span>
<span class="lineno"> 2414 </span><span class="spaces">  </span><span class="nottickedoff">if isJust (matchLLVMArrayCell ap off) then</span>
<span class="lineno"> 2415 </span><span class="spaces">    </span><span class="nottickedoff">let sub_ap = llvmMakeSubArray ap off len in</span>
<span class="lineno"> 2416 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj [Perm_LLVMArray sub_ap])</span>
<span class="lineno"> 2417 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_Conj</span>
<span class="lineno"> 2418 </span><span class="spaces">       </span><span class="nottickedoff">[Perm_LLVMArray $</span>
<span class="lineno"> 2419 </span><span class="spaces">        </span><span class="nottickedoff">llvmArrayAddBorrow (llvmSubArrayBorrow ap sub_ap) $</span>
<span class="lineno"> 2420 </span><span class="spaces">          </span><span class="nottickedoff">llvmArrayRemArrayBorrows ap sub_ap])</span>
<span class="lineno"> 2421 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2422 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayBorrow: array permission not a sub-array&quot;</span>
<span class="lineno"> 2423 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2424 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayReturn x ap ret_ap) =</span>
<span class="lineno"> 2425 </span><span class="spaces">  </span><span class="nottickedoff">if isJust (llvmArrayIsOffsetArray ap ret_ap) &amp;&amp;</span>
<span class="lineno"> 2426 </span><span class="spaces">     </span><span class="nottickedoff">elem (llvmSubArrayBorrow ap ret_ap) (llvmArrayBorrows ap) then</span>
<span class="lineno"> 2427 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x</span>
<span class="lineno"> 2428 </span><span class="spaces">    </span><span class="nottickedoff">(ValPerm_Conj [Perm_LLVMArray $</span>
<span class="lineno"> 2429 </span><span class="spaces">                   </span><span class="nottickedoff">llvmArrayRemBorrow (llvmSubArrayBorrow ap ret_ap) $</span>
<span class="lineno"> 2430 </span><span class="spaces">                   </span><span class="nottickedoff">llvmArrayAddArrayBorrows ap ret_ap])</span>
<span class="lineno"> 2431 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2432 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayReturn: array not being borrowed or not a sub-array&quot;</span>
<span class="lineno"> 2433 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2434 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayAppend x ap1 ap2) =</span>
<span class="lineno"> 2435 </span><span class="spaces">  </span><span class="nottickedoff">case llvmArrayIsOffsetArray ap1 ap2 of</span>
<span class="lineno"> 2436 </span><span class="spaces">    </span><span class="nottickedoff">Just len1</span>
<span class="lineno"> 2437 </span><span class="spaces">      </span><span class="nottickedoff">| bvEq len1 (llvmArrayLen ap1)</span>
<span class="lineno"> 2438 </span><span class="spaces">      </span><span class="nottickedoff">, llvmArrayCellShape ap1 == llvmArrayCellShape ap2</span>
<span class="lineno"> 2439 </span><span class="spaces">      </span><span class="nottickedoff">, ap1' &lt;- ap1 { llvmArrayLen =</span>
<span class="lineno"> 2440 </span><span class="spaces">                        </span><span class="nottickedoff">bvAdd (llvmArrayLen ap1) (llvmArrayLen ap2) } -&gt;</span>
<span class="lineno"> 2441 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x $ ValPerm_Conj1 $ Perm_LLVMArray $</span>
<span class="lineno"> 2442 </span><span class="spaces">        </span><span class="nottickedoff">llvmArrayAddArrayBorrows ap1' ap2</span>
<span class="lineno"> 2443 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_LLVMArrayAppend: arrays cannot be appended&quot;</span>
<span class="lineno"> 2444 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2445 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayRearrange x ap bs) =</span>
<span class="lineno"> 2446 </span><span class="spaces">  </span><span class="nottickedoff">if llvmArrayBorrowsPermuteTo ap bs then</span>
<span class="lineno"> 2447 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMArray $ ap { llvmArrayBorrows = bs })</span>
<span class="lineno"> 2448 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2449 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayRearrange: malformed output borrows list&quot;</span>
<span class="lineno"> 2450 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2451 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayToField x ap sz) =</span>
<span class="lineno"> 2452 </span><span class="spaces">  </span><span class="nottickedoff">case llvmArrayToField sz ap of</span>
<span class="lineno"> 2453 </span><span class="spaces">    </span><span class="nottickedoff">Just fp -&gt; distPerms1 x (ValPerm_Conj1 $ Perm_LLVMField fp)</span>
<span class="lineno"> 2454 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2455 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayToField: malformed array permission&quot;</span>
<span class="lineno"> 2456 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2457 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayEmpty x ap) =</span>
<span class="lineno"> 2458 </span><span class="spaces">  </span><span class="nottickedoff">if bvIsZero (llvmArrayLen ap) then</span>
<span class="lineno"> 2459 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMArray ap)</span>
<span class="lineno"> 2460 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2461 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayEmpty: malformed empty array permission&quot;</span>
<span class="lineno"> 2462 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2463 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayBorrowed x bp ap) =</span>
<span class="lineno"> 2464 </span><span class="spaces">  </span><span class="nottickedoff">if bvIsZero (llvmArrayLen ap) then</span>
<span class="lineno"> 2465 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayBorrowed: malformed borrowed array permission&quot;</span>
<span class="lineno"> 2466 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2467 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2</span>
<span class="lineno"> 2468 </span><span class="spaces">      </span><span class="nottickedoff">x (ValPerm_Conj1 $ Perm_LLVMArray ap)</span>
<span class="lineno"> 2469 </span><span class="spaces">      </span><span class="nottickedoff">x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2470 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2471 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayFromBlock x bp) =</span>
<span class="lineno"> 2472 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockPermToArray1 bp of</span>
<span class="lineno"> 2473 </span><span class="spaces">    </span><span class="nottickedoff">Just ap -&gt; distPerms1 x $ ValPerm_LLVMArray ap</span>
<span class="lineno"> 2474 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_LLVMArrayFromBlock: block perm with non-static length&quot;</span>
<span class="lineno"> 2475 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2476 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayCellCopy x ap cell) =</span>
<span class="lineno"> 2477 </span><span class="spaces">  </span><span class="nottickedoff">if atomicPermIsCopyable (Perm_LLVMArray ap) then</span>
<span class="lineno"> 2478 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 x (ValPerm_LLVMBlock $ llvmArrayCellPerm ap cell)</span>
<span class="lineno"> 2479 </span><span class="spaces">    </span><span class="nottickedoff">x (ValPerm_LLVMArray ap)</span>
<span class="lineno"> 2480 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2481 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayCellCopy: array is not copyable&quot;</span>
<span class="lineno"> 2482 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2483 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayCellBorrow x ap cell) =</span>
<span class="lineno"> 2484 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_LLVMBlock $ llvmArrayCellPerm ap cell)</span>
<span class="lineno"> 2485 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_LLVMArray $ llvmArrayAddBorrow (FieldBorrow cell) ap)</span>
<span class="lineno"> 2486 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2487 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayCellReturn x ap cell) =</span>
<span class="lineno"> 2488 </span><span class="spaces">  </span><span class="nottickedoff">if elem (FieldBorrow cell) (llvmArrayBorrows ap) then</span>
<span class="lineno"> 2489 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMArray $ llvmArrayRemBorrow (FieldBorrow cell) ap)</span>
<span class="lineno"> 2490 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2491 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_LLVMArrayCellReturn: index not being borrowed&quot;</span>
<span class="lineno"> 2492 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2493 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayContents x ap sh _) =</span>
<span class="lineno"> 2494 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj [Perm_LLVMArray $ ap { llvmArrayCellShape = sh }])</span>
<span class="lineno"> 2495 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2496 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMFieldIsPtr x fp) =</span>
<span class="lineno"> 2497 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj1 Perm_IsLLVMPtr)</span>
<span class="lineno"> 2498 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj [Perm_LLVMField fp])</span>
<span class="lineno"> 2499 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMArrayIsPtr x ap) =</span>
<span class="lineno"> 2500 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj1 Perm_IsLLVMPtr)</span>
<span class="lineno"> 2501 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj [Perm_LLVMArray ap])</span>
<span class="lineno"> 2502 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LLVMBlockIsPtr x bp) =</span>
<span class="lineno"> 2503 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ValPerm_Conj1 Perm_IsLLVMPtr)</span>
<span class="lineno"> 2504 </span><span class="spaces">  </span><span class="nottickedoff">x (ValPerm_Conj [Perm_LLVMBlock bp])</span>
<span class="lineno"> 2505 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_SplitLifetime x f args l l2 sub_ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 2506 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 x (ltFuncApply f args $ PExpr_Var l2)</span>
<span class="lineno"> 2507 </span><span class="spaces">  </span><span class="nottickedoff">l2 (ValPerm_LOwned sub_ls</span>
<span class="lineno"> 2508 </span><span class="spaces">      </span><span class="nottickedoff">(CruCtxCons tps_in $ exprType x)</span>
<span class="lineno"> 2509 </span><span class="spaces">      </span><span class="nottickedoff">(CruCtxCons tps_out $ exprType x)</span>
<span class="lineno"> 2510 </span><span class="spaces">      </span><span class="nottickedoff">(ps_in :&gt;: ExprAndPerm (PExpr_Var x) (ltFuncMinApply f (PExpr_Var l2)))</span>
<span class="lineno"> 2511 </span><span class="spaces">      </span><span class="nottickedoff">(ps_out :&gt;: ExprAndPerm (PExpr_Var x) (ltFuncApply f args l)))</span>
<span class="lineno"> 2512 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_SubsumeLifetime l ls tps_in tps_out ps_in ps_out l2) =</span>
<span class="lineno"> 2513 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l (ValPerm_LOwned (l2:ls) tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 2514 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ContainedLifetimeCurrent l ls tps_in tps_out ps_in ps_out l2) =</span>
<span class="lineno"> 2515 </span><span class="spaces">  </span><span class="nottickedoff">if elem l2 ls then</span>
<span class="lineno"> 2516 </span><span class="spaces">    </span><span class="nottickedoff">distPerms2 l (ValPerm_LCurrent l2)</span>
<span class="lineno"> 2517 </span><span class="spaces">    </span><span class="nottickedoff">l (ValPerm_LOwned ls tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 2518 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2519 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;simplImplOut: SImpl_ContainedLifetimeCurrent: &quot; ++</span>
<span class="lineno"> 2520 </span><span class="spaces">           </span><span class="nottickedoff">&quot;lifetime not in contained lifetimes&quot;)</span>
<span class="lineno"> 2521 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_RemoveContainedLifetime l ls tps_in tps_out ps_in ps_out l2) =</span>
<span class="lineno"> 2522 </span><span class="spaces">  </span><span class="nottickedoff">if elem (PExpr_Var l2) ls then</span>
<span class="lineno"> 2523 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 l (ValPerm_LOwned (delete (PExpr_Var l2) ls)</span>
<span class="lineno"> 2524 </span><span class="spaces">                  </span><span class="nottickedoff">tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 2525 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2526 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;simplImplOut: SImpl_RemoveContainedLifetime: &quot; ++</span>
<span class="lineno"> 2527 </span><span class="spaces">           </span><span class="nottickedoff">&quot;lifetime not in contained lifetimes&quot;)</span>
<span class="lineno"> 2528 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_WeakenLifetime x f args _ l2) =</span>
<span class="lineno"> 2529 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ltFuncApply f args $ PExpr_Var l2)</span>
<span class="lineno"> 2530 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_MapLifetime l ls _ _ _ _ tps_in' tps_out' ps_in' ps_out' _ _ _ _) =</span>
<span class="lineno"> 2531 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l $ ValPerm_LOwned ls tps_in' tps_out' ps_in' ps_out'</span>
<span class="lineno"> 2532 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_EndLifetime l _ _ _ ps_out) =</span>
<span class="lineno"> 2533 </span><span class="spaces">  </span><span class="nottickedoff">case exprPermsToDistPerms ps_out of</span>
<span class="lineno"> 2534 </span><span class="spaces">    </span><span class="nottickedoff">Just perms_out -&gt;</span>
<span class="lineno"> 2535 </span><span class="spaces">      </span><span class="nottickedoff">DistPermsCons perms_out l ValPerm_LFinished</span>
<span class="lineno"> 2536 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_EndLifetime: non-variable in output permissions&quot;</span>
<span class="lineno"> 2537 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLOwnedSimple l tps lops) =</span>
<span class="lineno"> 2538 </span><span class="spaces">  </span><span class="nottickedoff">case modalize Nothing (Just (PExpr_Var l)) lops &gt;&gt;= exprPermsToDistPerms of</span>
<span class="lineno"> 2539 </span><span class="spaces">    </span><span class="nottickedoff">Just dps -&gt; DistPermsCons dps l $ ValPerm_LOwnedSimple tps lops</span>
<span class="lineno"> 2540 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2541 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_IntroLOwnedSimple: non-variables in permission list&quot;</span>
<span class="lineno"> 2542 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLOwnedSimple l tps lops) =</span>
<span class="lineno"> 2543 </span><span class="spaces">  </span><span class="nottickedoff">case lownedPermsSimpleIn l lops of</span>
<span class="lineno"> 2544 </span><span class="spaces">    </span><span class="nottickedoff">Just lops' -&gt; distPerms1 l (ValPerm_LOwned [] tps tps lops' lops)</span>
<span class="lineno"> 2545 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2546 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_ElimLOwnedSimple: could not modalize permission list&quot;</span>
<span class="lineno"> 2547 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LCurrentRefl l) =</span>
<span class="lineno"> 2548 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l (ValPerm_LCurrent $ PExpr_Var l)</span>
<span class="lineno"> 2549 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_LCurrentTrans l1 _ l3) =</span>
<span class="lineno"> 2550 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 l1 (ValPerm_LCurrent l3)</span>
<span class="lineno"> 2551 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_DemoteLLVMBlockRW x bp) =</span>
<span class="lineno"> 2552 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock (bp { llvmBlockRW = PExpr_Read })</span>
<span class="lineno"> 2553 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockEmpty x bp) =</span>
<span class="lineno"> 2554 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2555 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_EmptyShape -&gt; distPerms1 x $ ValPerm_Conj1 $ Perm_LLVMBlock bp</span>
<span class="lineno"> 2556 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_IntroLLVMBlockEmpty: malformed permission&quot;</span>
<span class="lineno"> 2557 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_CoerceLLVMBlockEmpty x bp) =</span>
<span class="lineno"> 2558 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2559 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_EmptyShape })</span>
<span class="lineno"> 2560 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockToBytes x (LLVMBlockPerm {..})) =</span>
<span class="lineno"> 2561 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (llvmByteArrayPerm llvmBlockOffset llvmBlockLen</span>
<span class="lineno"> 2562 </span><span class="spaces">                </span><span class="nottickedoff">llvmBlockRW llvmBlockLifetime)</span>
<span class="lineno"> 2563 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockTuple x bp) =</span>
<span class="lineno"> 2564 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2565 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_TupShape (llvmBlockShape bp) })</span>
<span class="lineno"> 2566 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockTuple x bp) =</span>
<span class="lineno"> 2567 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2568 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockSeqEmpty x bp) =</span>
<span class="lineno"> 2569 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2570 </span><span class="spaces">                </span><span class="nottickedoff">bp { llvmBlockShape =</span>
<span class="lineno"> 2571 </span><span class="spaces">                       </span><span class="nottickedoff">PExpr_SeqShape (llvmBlockShape bp) PExpr_EmptyShape })</span>
<span class="lineno"> 2572 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockSeqEmpty x bp) =</span>
<span class="lineno"> 2573 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2574 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_SplitLLVMBlockEmpty x bp len1) =</span>
<span class="lineno"> 2575 </span><span class="spaces">  </span><span class="nottickedoff">if llvmBlockShape bp == PExpr_EmptyShape &amp;&amp; bvLt len1 (llvmBlockLen bp) then</span>
<span class="lineno"> 2576 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj</span>
<span class="lineno"> 2577 </span><span class="spaces">                  </span><span class="nottickedoff">[Perm_LLVMBlock (bp { llvmBlockLen = len1 }),</span>
<span class="lineno"> 2578 </span><span class="spaces">                   </span><span class="nottickedoff">Perm_LLVMBlock</span>
<span class="lineno"> 2579 </span><span class="spaces">                   </span><span class="nottickedoff">(bp { llvmBlockOffset = bvAdd (llvmBlockOffset bp) len1,</span>
<span class="lineno"> 2580 </span><span class="spaces">                         </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) len1 })])</span>
<span class="lineno"> 2581 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2582 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_SplitLLVMBlockEmpty: length too long!&quot;</span>
<span class="lineno"> 2583 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockNamed x bp _) =</span>
<span class="lineno"> 2584 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2585 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockNamed x bp nmsh) =</span>
<span class="lineno"> 2586 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2587 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_NamedShape rw l nmsh' args</span>
<span class="lineno"> 2588 </span><span class="spaces">      </span><span class="nottickedoff">| Just (Refl,Refl) &lt;- namedShapeEq nmsh nmsh'</span>
<span class="lineno"> 2589 </span><span class="spaces">      </span><span class="nottickedoff">, Just sh' &lt;- unfoldModalizeNamedShape rw l nmsh args -&gt;</span>
<span class="lineno"> 2590 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMBlock $ bp { llvmBlockShape = sh' })</span>
<span class="lineno"> 2591 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_ElimLLVMBlockNamed: unexpected block shape&quot;</span>
<span class="lineno"> 2592 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockNamedMods x bp) =</span>
<span class="lineno"> 2593 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2594 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockNamedMods x bp) =</span>
<span class="lineno"> 2595 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2596 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_NamedShape maybe_rw maybe_l nmsh args</span>
<span class="lineno"> 2597 </span><span class="spaces">      </span><span class="nottickedoff">| rw &lt;- fromMaybe (llvmBlockRW bp) maybe_rw</span>
<span class="lineno"> 2598 </span><span class="spaces">      </span><span class="nottickedoff">, l &lt;- fromMaybe (llvmBlockLifetime bp) maybe_l -&gt;</span>
<span class="lineno"> 2599 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock $</span>
<span class="lineno"> 2600 </span><span class="spaces">        </span><span class="nottickedoff">bp { llvmBlockRW = rw, llvmBlockLifetime = l,</span>
<span class="lineno"> 2601 </span><span class="spaces">             </span><span class="nottickedoff">llvmBlockShape = PExpr_NamedShape Nothing Nothing nmsh args }</span>
<span class="lineno"> 2602 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_ElimLLVMBlockNamedMods: malformed input permission&quot;</span>
<span class="lineno"> 2603 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockFromEq x bp _) =</span>
<span class="lineno"> 2604 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2605 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockPtr x bp) =</span>
<span class="lineno"> 2606 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 2607 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockPtr x bp) =</span>
<span class="lineno"> 2608 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockPtrShapeUnfold bp of</span>
<span class="lineno"> 2609 </span><span class="spaces">    </span><span class="nottickedoff">Just bp' -&gt; distPerms1 x $ ValPerm_LLVMBlock bp'</span>
<span class="lineno"> 2610 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2611 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_ElimLLVMBlockPtr: unexpected block shape&quot;</span>
<span class="lineno"> 2612 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockField x fp) =</span>
<span class="lineno"> 2613 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $ llvmFieldPermToBlock fp)</span>
<span class="lineno"> 2614 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockField x fp) =</span>
<span class="lineno"> 2615 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $ ValPerm_LLVMField fp</span>
<span class="lineno"> 2616 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockArray x ap) =</span>
<span class="lineno"> 2617 </span><span class="spaces">  </span><span class="nottickedoff">case llvmAtomicPermToBlock (Perm_LLVMArray ap) of</span>
<span class="lineno"> 2618 </span><span class="spaces">    </span><span class="nottickedoff">Just bp -&gt; distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock bp)</span>
<span class="lineno"> 2619 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2620 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_IntroLLVMBlockArray: malformed array permission&quot;</span>
<span class="lineno"> 2621 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockArray x bp) =</span>
<span class="lineno"> 2622 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockPermToArray bp of</span>
<span class="lineno"> 2623 </span><span class="spaces">    </span><span class="nottickedoff">Just ap</span>
<span class="lineno"> 2624 </span><span class="spaces">      </span><span class="nottickedoff">| bvEq (llvmArrayLengthBytes ap) (llvmBlockLen bp) -&gt;</span>
<span class="lineno"> 2625 </span><span class="spaces">        </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMArray ap)</span>
<span class="lineno"> 2626 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2627 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplIn: SImpl_ElimLLVMBlockArray: malformed input permission&quot;</span>
<span class="lineno"> 2628 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockSeq x bp1 len2 sh2) =</span>
<span class="lineno"> 2629 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2630 </span><span class="spaces">                </span><span class="nottickedoff">bp1 { llvmBlockLen = bvAdd (llvmBlockLen bp1) len2,</span>
<span class="lineno"> 2631 </span><span class="spaces">                      </span><span class="nottickedoff">llvmBlockShape = PExpr_SeqShape (llvmBlockShape bp1) sh2 })</span>
<span class="lineno"> 2632 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockSeq x bp sh2) =</span>
<span class="lineno"> 2633 </span><span class="spaces">  </span><span class="nottickedoff">case llvmShapeLength (llvmBlockShape bp) of</span>
<span class="lineno"> 2634 </span><span class="spaces">    </span><span class="nottickedoff">Just len1 -&gt;</span>
<span class="lineno"> 2635 </span><span class="spaces">      </span><span class="nottickedoff">distPerms1</span>
<span class="lineno"> 2636 </span><span class="spaces">      </span><span class="nottickedoff">x (ValPerm_Conj</span>
<span class="lineno"> 2637 </span><span class="spaces">         </span><span class="nottickedoff">[Perm_LLVMBlock (bp { llvmBlockLen = len1 }),</span>
<span class="lineno"> 2638 </span><span class="spaces">          </span><span class="nottickedoff">Perm_LLVMBlock $</span>
<span class="lineno"> 2639 </span><span class="spaces">          </span><span class="nottickedoff">bp { llvmBlockOffset = bvAdd (llvmBlockOffset bp) len1,</span>
<span class="lineno"> 2640 </span><span class="spaces">               </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) len1,</span>
<span class="lineno"> 2641 </span><span class="spaces">               </span><span class="nottickedoff">llvmBlockShape = sh2 }])</span>
<span class="lineno"> 2642 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2643 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_ElimLLVMBlockSeq&quot;</span>
<span class="lineno"> 2644 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockOr x bp1 sh2) =</span>
<span class="lineno"> 2645 </span><span class="spaces">  </span><span class="nottickedoff">let sh1 = llvmBlockShape bp1 in</span>
<span class="lineno"> 2646 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2647 </span><span class="spaces">                </span><span class="nottickedoff">bp1 { llvmBlockShape = PExpr_OrShape sh1 sh2 })</span>
<span class="lineno"> 2648 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockOr x bp shs) =</span>
<span class="lineno"> 2649 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x $</span>
<span class="lineno"> 2650 </span><span class="spaces">  </span><span class="nottickedoff">foldr1 ValPerm_Or $</span>
<span class="lineno"> 2651 </span><span class="spaces">  </span><span class="nottickedoff">map (\sh -&gt; ValPerm_Conj1 $ Perm_LLVMBlock $ bp { llvmBlockShape = sh }) shs</span>
<span class="lineno"> 2652 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroLLVMBlockEx x bp) =</span>
<span class="lineno"> 2653 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMBlock bp)</span>
<span class="lineno"> 2654 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockEx x bp) =</span>
<span class="lineno"> 2655 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2656 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_ExShape mb_sh -&gt;</span>
<span class="lineno"> 2657 </span><span class="spaces">      </span><span class="nottickedoff">distPerms1 x (ValPerm_Exists $</span>
<span class="lineno"> 2658 </span><span class="spaces">                    </span><span class="nottickedoff">flip fmap mb_sh $ \sh -&gt;</span>
<span class="lineno"> 2659 </span><span class="spaces">                     </span><span class="nottickedoff">ValPerm_LLVMBlock (bp { llvmBlockShape = sh }))</span>
<span class="lineno"> 2660 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2661 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_ElimLLVMBlockEx: non-existential shape&quot;</span>
<span class="lineno"> 2662 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimLLVMBlockFalse x bp) =</span>
<span class="lineno"> 2663 </span><span class="spaces">  </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 2664 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_FalseShape -&gt;</span>
<span class="lineno"> 2665 </span><span class="spaces">      </span><span class="nottickedoff">distPerms1 x ValPerm_False</span>
<span class="lineno"> 2666 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;simplImplOut: SImpl_ElimLLVMBlockFalse: non-false shape&quot;</span>
<span class="lineno"> 2667 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_FoldNamed x np args off) =</span>
<span class="lineno"> 2668 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named (namedPermName np) args off)</span>
<span class="lineno"> 2669 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_UnfoldNamed x np args off) =</span>
<span class="lineno"> 2670 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (unfoldPerm np args off)</span>
<span class="lineno"> 2671 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_NamedToConj x npn args off) =</span>
<span class="lineno"> 2672 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 $ Perm_NamedConj npn args off)</span>
<span class="lineno"> 2673 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_NamedFromConj x npn args off) =</span>
<span class="lineno"> 2674 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn args off)</span>
<span class="lineno"> 2675 </span><span class="spaces"></span><span class="nottickedoff">-- simplImplOut (SImpl_Mu x _ p2 _) = distPerms1 x (ValPerm_Mu p2)</span>
<span class="lineno"> 2676 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_NamedArgAlways x npn args off memb l) =</span>
<span class="lineno"> 2677 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn (setNthPermExpr args memb l) off)</span>
<span class="lineno"> 2678 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_NamedArgCurrent x npn args off memb l2) =</span>
<span class="lineno"> 2679 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn (setNthPermExpr args memb l2) off)</span>
<span class="lineno"> 2680 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_NamedArgWrite x npn args off memb rw) =</span>
<span class="lineno"> 2681 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn (setNthPermExpr args memb rw) off)</span>
<span class="lineno"> 2682 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_NamedArgRead x npn args off memb) =</span>
<span class="lineno"> 2683 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named npn</span>
<span class="lineno"> 2684 </span><span class="spaces">                </span><span class="nottickedoff">(setNthPermExpr args memb (PExpr_RWModality Read))</span>
<span class="lineno"> 2685 </span><span class="spaces">                </span><span class="nottickedoff">off)</span>
<span class="lineno"> 2686 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ReachabilityTrans x rp args off _ e) =</span>
<span class="lineno"> 2687 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Named (recPermName rp) (PExprs_Cons args e) off)</span>
<span class="lineno"> 2688 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroAnyEqEq x _ _) = distPerms1 x ValPerm_Any</span>
<span class="lineno"> 2689 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_IntroAnyWordPtr x _ _) = distPerms1 x ValPerm_Any</span>
<span class="lineno"> 2690 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimAnyToEq x e) = distPerms1 x (ValPerm_Eq e)</span>
<span class="lineno"> 2691 </span><span class="spaces"></span><span class="nottickedoff">simplImplOut (SImpl_ElimAnyToPtr x fp) =</span>
<span class="lineno"> 2692 </span><span class="spaces">  </span><span class="nottickedoff">if llvmFieldContents fp == ValPerm_Any then</span>
<span class="lineno"> 2693 </span><span class="spaces">    </span><span class="nottickedoff">distPerms1 x (ValPerm_LLVMField fp)</span>
<span class="lineno"> 2694 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2695 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;simplImplOut: SImpl_ElimAnyToPtr: non-any contents&quot;</span></span>
<span class="lineno"> 2696 </span>
<span class="lineno"> 2697 </span>-- | Compute the input permissions of a 'SimplImpl' implication in a binding
<span class="lineno"> 2698 </span>mbSimplImplIn :: Mb ctx (SimplImpl ps_in ps_out) -&gt; Mb ctx (DistPerms ps_in)
<span class="lineno"> 2699 </span><span class="decl"><span class="nottickedoff">mbSimplImplIn = mbMapCl $(mkClosed [| simplImplIn |])</span></span>
<span class="lineno"> 2700 </span>
<span class="lineno"> 2701 </span>-- | Compute the output permissions of a 'SimplImpl' implication in a binding
<span class="lineno"> 2702 </span>mbSimplImplOut :: Mb ctx (SimplImpl ps_in ps_out) -&gt; Mb ctx (DistPerms ps_out)
<span class="lineno"> 2703 </span><span class="decl"><span class="nottickedoff">mbSimplImplOut = mbMapCl $(mkClosed [| simplImplOut |])</span></span>
<span class="lineno"> 2704 </span>
<span class="lineno"> 2705 </span>-- | Apply a 'SimplImpl' implication to the permissions on the top of a
<span class="lineno"> 2706 </span>-- permission set stack, checking that they equal the 'simplImplIn' of the
<span class="lineno"> 2707 </span>-- 'SimplImpl' and then replacing them with its 'simplImplOut'
<span class="lineno"> 2708 </span>applySimplImpl :: HasCallStack =&gt; PPInfo -&gt; Proxy ps -&gt;
<span class="lineno"> 2709 </span>                  SimplImpl ps_in ps_out -&gt; PermSet (ps :++: ps_in) -&gt;
<span class="lineno"> 2710 </span>                  PermSet (ps :++: ps_out)
<span class="lineno"> 2711 </span><span class="decl"><span class="nottickedoff">applySimplImpl pp_info prx simpl =</span>
<span class="lineno"> 2712 </span><span class="spaces">  </span><span class="nottickedoff">modifyDistPerms $ \all_ps -&gt;</span>
<span class="lineno"> 2713 </span><span class="spaces">  </span><span class="nottickedoff">let (ps, ps_in) =</span>
<span class="lineno"> 2714 </span><span class="spaces">        </span><span class="nottickedoff">splitDistPerms prx (distPermsToProxies $ simplImplIn simpl) all_ps in</span>
<span class="lineno"> 2715 </span><span class="spaces">  </span><span class="nottickedoff">if ps_in == simplImplIn simpl then</span>
<span class="lineno"> 2716 </span><span class="spaces">    </span><span class="nottickedoff">appendDistPerms ps (simplImplOut simpl)</span>
<span class="lineno"> 2717 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2718 </span><span class="spaces">    </span><span class="nottickedoff">error $ renderDoc $</span>
<span class="lineno"> 2719 </span><span class="spaces">    </span><span class="nottickedoff">vsep [pretty &quot;applySimplImpl: incorrect input permissions&quot;,</span>
<span class="lineno"> 2720 </span><span class="spaces">          </span><span class="nottickedoff">pretty &quot;expected: &quot; &lt;&gt; permPretty pp_info (simplImplIn simpl),</span>
<span class="lineno"> 2721 </span><span class="spaces">          </span><span class="nottickedoff">pretty &quot;actual: &quot; &lt;&gt; permPretty pp_info ps_in]</span></span>
<span class="lineno"> 2722 </span>
<span class="lineno"> 2723 </span>-- | A sequence of permission sets inside name-bindings
<span class="lineno"> 2724 </span>data MbPermSets bs_pss where
<span class="lineno"> 2725 </span>  MbPermSets_Nil :: MbPermSets RNil
<span class="lineno"> 2726 </span>  MbPermSets_Cons :: MbPermSets bs_pss -&gt; CruCtx bs -&gt; Mb bs (PermSet ps) -&gt;
<span class="lineno"> 2727 </span>                     MbPermSets (bs_pss :&gt; '(bs,ps))
<span class="lineno"> 2728 </span>
<span class="lineno"> 2729 </span>-- | Helper for building a one-element 'MbPermSets' sequence
<span class="lineno"> 2730 </span>mbPermSets1 :: KnownRepr CruCtx bs =&gt;
<span class="lineno"> 2731 </span>               Mb bs (PermSet ps) -&gt; MbPermSets (RNil :&gt; '(bs,ps))
<span class="lineno"> 2732 </span><span class="decl"><span class="nottickedoff">mbPermSets1 = MbPermSets_Cons MbPermSets_Nil knownRepr</span></span>
<span class="lineno"> 2733 </span>
<span class="lineno"> 2734 </span>-- | Helper for building a two-element 'MbPermSets' sequence
<span class="lineno"> 2735 </span>mbPermSets2 :: (KnownRepr CruCtx bs1, KnownRepr CruCtx bs2) =&gt;
<span class="lineno"> 2736 </span>               Mb bs1 (PermSet ps1) -&gt; Mb bs2 (PermSet ps2) -&gt;
<span class="lineno"> 2737 </span>               MbPermSets (RNil :&gt; '(bs1,ps1) :&gt; '(bs2,ps2))
<span class="lineno"> 2738 </span><span class="decl"><span class="nottickedoff">mbPermSets2 ps1 ps2 =</span>
<span class="lineno"> 2739 </span><span class="spaces">  </span><span class="nottickedoff">MbPermSets_Cons (MbPermSets_Cons MbPermSets_Nil knownRepr ps1) knownRepr ps2</span></span>
<span class="lineno"> 2740 </span>
<span class="lineno"> 2741 </span>-- | Extract the permission in an or elimination disjunct
<span class="lineno"> 2742 </span>orListDisjPerm :: OrListDisj ps a disj -&gt; ValuePerm a
<span class="lineno"> 2743 </span><span class="decl"><span class="nottickedoff">orListDisjPerm (OrListDisj p) = p</span></span>
<span class="lineno"> 2744 </span>
<span class="lineno"> 2745 </span>-- | Extract the disjuncts of an or elimination list
<span class="lineno"> 2746 </span>orListDisjs :: OrList ps a disjs -&gt; [ValuePerm a]
<span class="lineno"> 2747 </span><span class="decl"><span class="nottickedoff">orListDisjs = RL.mapToList orListDisjPerm</span></span>
<span class="lineno"> 2748 </span>
<span class="lineno"> 2749 </span>-- | Extract the disjuncts of an or elimination list in a binding
<span class="lineno"> 2750 </span>mbOrListDisjs :: Mb ctx (OrList ps a disjs) -&gt; [Mb ctx (ValuePerm a)]
<span class="lineno"> 2751 </span><span class="decl"><span class="nottickedoff">mbOrListDisjs = mbList . mbMapCl $(mkClosed [| orListDisjs |])</span></span>
<span class="lineno"> 2752 </span>
<span class="lineno"> 2753 </span>-- | Compute the permission eliminated by an 'OrList'
<span class="lineno"> 2754 </span>orListPerm :: OrList ps a disjs -&gt; ValuePerm a
<span class="lineno"> 2755 </span><span class="decl"><span class="nottickedoff">orListPerm MNil = error &quot;orListPerm: empty disjunct list!&quot;</span>
<span class="lineno"> 2756 </span><span class="spaces"></span><span class="nottickedoff">orListPerm or_list = foldr1 ValPerm_Or $ orListDisjs or_list</span></span>
<span class="lineno"> 2757 </span>
<span class="lineno"> 2758 </span>-- | Compute the permission-in-binding eliminated by an 'OrList' in a binding
<span class="lineno"> 2759 </span>mbOrListPerm :: Mb ctx (OrList ps a disj) -&gt; Mb ctx (ValuePerm a)
<span class="lineno"> 2760 </span><span class="decl"><span class="nottickedoff">mbOrListPerm = mbMapCl $(mkClosed [| orListPerm |])</span></span>
<span class="lineno"> 2761 </span>
<span class="lineno"> 2762 </span>-- | Build an 'MbPermSets'
<span class="lineno"> 2763 </span>orListMbPermSets :: PermSet (ps :&gt; a) -&gt; ExprVar a -&gt; OrList ps a disjs -&gt;
<span class="lineno"> 2764 </span>                    MbPermSets disjs
<span class="lineno"> 2765 </span><span class="decl"><span class="nottickedoff">orListMbPermSets _ _ MNil = MbPermSets_Nil</span>
<span class="lineno"> 2766 </span><span class="spaces"></span><span class="nottickedoff">orListMbPermSets ps x (or_list :&gt;: OrListDisj p) =</span>
<span class="lineno"> 2767 </span><span class="spaces">  </span><span class="nottickedoff">MbPermSets_Cons (orListMbPermSets ps x or_list) CruCtxNil $</span>
<span class="lineno"> 2768 </span><span class="spaces">  </span><span class="nottickedoff">emptyMb $ set (topDistPerm x) p ps</span></span>
<span class="lineno"> 2769 </span>
<span class="lineno"> 2770 </span>-- | If we have an 'MbPermImpls' list associated with a multi-way or
<span class="lineno"> 2771 </span>-- elimination, extract out the list of 'PermImpl's it carries
<span class="lineno"> 2772 </span>orListPermImpls :: OrList ps a disjs -&gt; MbPermImpls r disjs -&gt;
<span class="lineno"> 2773 </span>                   [PermImpl r (ps :&gt; a)]
<span class="lineno"> 2774 </span><span class="decl"><span class="nottickedoff">orListPermImpls MNil MbPermImpls_Nil = []</span>
<span class="lineno"> 2775 </span><span class="spaces"></span><span class="nottickedoff">orListPermImpls (or_list :&gt;: OrListDisj _) (MbPermImpls_Cons</span>
<span class="lineno"> 2776 </span><span class="spaces">                                            </span><span class="nottickedoff">_ mb_impls mb_impl) =</span>
<span class="lineno"> 2777 </span><span class="spaces">  </span><span class="nottickedoff">orListPermImpls or_list mb_impls ++ [elimEmptyMb mb_impl]</span></span>
<span class="lineno"> 2778 </span>
<span class="lineno"> 2779 </span>-- | Extract the 'PermImpl's-in-bindings from an 'MbPermImpls'-in-binding
<span class="lineno"> 2780 </span>-- associated with a multi-way or elimination
<span class="lineno"> 2781 </span>mbOrListPermImpls :: NuMatchingAny1 r =&gt; Mb ctx (OrList ps a disjs) -&gt;
<span class="lineno"> 2782 </span>                     Mb ctx (MbPermImpls r disjs) -&gt;
<span class="lineno"> 2783 </span>                     [Mb ctx (PermImpl r (ps :&gt; a))]
<span class="lineno"> 2784 </span><span class="decl"><span class="nottickedoff">mbOrListPermImpls (mbMatch -&gt;</span>
<span class="lineno"> 2785 </span><span class="spaces">                   </span><span class="nottickedoff">[nuMP| MNil |]) (mbMatch -&gt; [nuMP| MbPermImpls_Nil |]) = []</span>
<span class="lineno"> 2786 </span><span class="spaces"></span><span class="nottickedoff">mbOrListPermImpls</span>
<span class="lineno"> 2787 </span><span class="spaces">  </span><span class="nottickedoff">(mbMatch -&gt; [nuMP| mb_or_list :&gt;: OrListDisj _ |])</span>
<span class="lineno"> 2788 </span><span class="spaces">  </span><span class="nottickedoff">(mbMatch -&gt; [nuMP| MbPermImpls_Cons _ mb_impls mb_impl |])</span>
<span class="lineno"> 2789 </span><span class="spaces">  </span><span class="nottickedoff">= mbOrListPermImpls mb_or_list mb_impls ++ [mbMapCl</span>
<span class="lineno"> 2790 </span><span class="spaces">                                              </span><span class="nottickedoff">$(mkClosed [| elimEmptyMb |])</span>
<span class="lineno"> 2791 </span><span class="spaces">                                              </span><span class="nottickedoff">mb_impl]</span></span>
<span class="lineno"> 2792 </span>
<span class="lineno"> 2793 </span>-- | Apply a single permission implication step to a permission set
<span class="lineno"> 2794 </span>applyImpl1 :: HasCallStack =&gt; PPInfo -&gt; PermImpl1 ps_in ps_outs -&gt;
<span class="lineno"> 2795 </span>              PermSet ps_in -&gt; MbPermSets ps_outs
<span class="lineno"> 2796 </span><span class="decl"><span class="nottickedoff">applyImpl1 _ (Impl1_Fail _) _ = MbPermSets_Nil</span>
<span class="lineno"> 2797 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_Catch _) ps = mbPermSets2 (emptyMb ps) (emptyMb ps)</span>
<span class="lineno"> 2798 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 pp_info (Impl1_Push x p) ps =</span>
<span class="lineno"> 2799 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. varPerm x == p then</span>
<span class="lineno"> 2800 </span><span class="spaces">    </span><span class="nottickedoff">mbPermSets1 $ emptyMb $ pushPerm x p $ set (varPerm x) ValPerm_True ps</span>
<span class="lineno"> 2801 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2802 </span><span class="spaces">    </span><span class="nottickedoff">error $ renderDoc (pretty &quot;applyImpl1: Impl1_Push&quot; &lt;+&gt;</span>
<span class="lineno"> 2803 </span><span class="spaces">                       </span><span class="nottickedoff">permPretty pp_info x &lt;+&gt; colon &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 2804 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;expected:&quot; &lt;+&gt; permPretty pp_info p &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 2805 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;found:&quot; &lt;+&gt;</span>
<span class="lineno"> 2806 </span><span class="spaces">                       </span><span class="nottickedoff">permPretty pp_info (ps ^. varPerm x))</span>
<span class="lineno"> 2807 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 pp_info (Impl1_Pop x p) ps =</span>
<span class="lineno"> 2808 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == p &amp;&amp; ps ^. varPerm x == ValPerm_True then</span>
<span class="lineno"> 2809 </span><span class="spaces">    </span><span class="nottickedoff">mbPermSets1 $ emptyMb $ fst $ popPerm x $ set (varPerm x) p ps</span>
<span class="lineno"> 2810 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2811 </span><span class="spaces">    </span><span class="nottickedoff">if ps ^. varPerm x == ValPerm_True then</span>
<span class="lineno"> 2812 </span><span class="spaces">      </span><span class="nottickedoff">error $ renderDoc $</span>
<span class="lineno"> 2813 </span><span class="spaces">      </span><span class="nottickedoff">vsep [pretty &quot;applyImpl1: Impl1_Pop: unexpected permissions on top of the stack&quot;,</span>
<span class="lineno"> 2814 </span><span class="spaces">            </span><span class="nottickedoff">pretty &quot;expected: &quot; &lt;&gt; permPretty pp_info p,</span>
<span class="lineno"> 2815 </span><span class="spaces">            </span><span class="nottickedoff">pretty &quot;actual: &quot; &lt;&gt; permPretty pp_info (ps ^. topDistPerm x)]</span>
<span class="lineno"> 2816 </span><span class="spaces">    </span><span class="nottickedoff">else</span>
<span class="lineno"> 2817 </span><span class="spaces">      </span><span class="nottickedoff">error $ renderDoc $</span>
<span class="lineno"> 2818 </span><span class="spaces">      </span><span class="nottickedoff">vsep [pretty &quot;applyImpl1: Impl1_Pop: non-empty permissions for variable&quot;</span>
<span class="lineno"> 2819 </span><span class="spaces">            </span><span class="nottickedoff">&lt;+&gt; permPretty pp_info x &lt;&gt; pretty &quot;:&quot;,</span>
<span class="lineno"> 2820 </span><span class="spaces">            </span><span class="nottickedoff">permPretty pp_info (ps ^. varPerm x)]</span>
<span class="lineno"> 2821 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ElimOrs _ x or_list) ps =</span>
<span class="lineno"> 2822 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == orListPerm or_list then</span>
<span class="lineno"> 2823 </span><span class="spaces">    </span><span class="nottickedoff">orListMbPermSets ps x or_list</span>
<span class="lineno"> 2824 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2825 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ElimOrs: unexpected permission&quot;</span>
<span class="lineno"> 2826 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ElimExists x p_body) ps =</span>
<span class="lineno"> 2827 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_Exists p_body then</span>
<span class="lineno"> 2828 </span><span class="spaces">    </span><span class="nottickedoff">mbPermSets1 (fmap (\p -&gt; set (topDistPerm x) p ps) p_body)</span>
<span class="lineno"> 2829 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2830 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ElimExists: unexpected permission&quot;</span>
<span class="lineno"> 2831 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ElimFalse x) ps =</span>
<span class="lineno"> 2832 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_False then</span>
<span class="lineno"> 2833 </span><span class="spaces">    </span><span class="nottickedoff">MbPermSets_Nil</span>
<span class="lineno"> 2834 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2835 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ElimFalse: unexpected permission&quot;</span>
<span class="lineno"> 2836 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 pp_info (Impl1_Simpl simpl prx) ps =</span>
<span class="lineno"> 2837 </span><span class="spaces">  </span><span class="nottickedoff">mbPermSets1 $ emptyMb $ applySimplImpl pp_info prx simpl ps</span>
<span class="lineno"> 2838 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_LetBind tp e) ps =</span>
<span class="lineno"> 2839 </span><span class="spaces">  </span><span class="nottickedoff">MbPermSets_Cons MbPermSets_Nil (CruCtxCons CruCtxNil tp) $</span>
<span class="lineno"> 2840 </span><span class="spaces">  </span><span class="nottickedoff">nu $ \x -&gt; pushPerm x (ValPerm_Eq e) ps</span>
<span class="lineno"> 2841 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ElimStructField x ps' tp memb) ps =</span>
<span class="lineno"> 2842 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_Conj [Perm_Struct ps'] then</span>
<span class="lineno"> 2843 </span><span class="spaces">    </span><span class="nottickedoff">(MbPermSets_Cons MbPermSets_Nil (singletonCruCtx tp) $ nu $ \y -&gt;</span>
<span class="lineno"> 2844 </span><span class="spaces">      </span><span class="nottickedoff">pushPerm y (RL.get memb ps') $</span>
<span class="lineno"> 2845 </span><span class="spaces">      </span><span class="nottickedoff">set (topDistPerm x) (ValPerm_Conj1 $ Perm_Struct $</span>
<span class="lineno"> 2846 </span><span class="spaces">                           </span><span class="nottickedoff">RL.set memb (ValPerm_Eq $ PExpr_Var y) ps')</span>
<span class="lineno"> 2847 </span><span class="spaces">      </span><span class="nottickedoff">ps)</span>
<span class="lineno"> 2848 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2849 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ElimStructField: unexpected permission&quot;</span>
<span class="lineno"> 2850 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ElimLLVMFieldContents x fp) ps =</span>
<span class="lineno"> 2851 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_Conj [Perm_LLVMField fp] then</span>
<span class="lineno"> 2852 </span><span class="spaces">    </span><span class="nottickedoff">(mbPermSets1 $ nu $ \y -&gt;</span>
<span class="lineno"> 2853 </span><span class="spaces">      </span><span class="nottickedoff">pushPerm y (llvmFieldContents fp) $</span>
<span class="lineno"> 2854 </span><span class="spaces">      </span><span class="nottickedoff">set (topDistPerm x) (ValPerm_Conj [Perm_LLVMField $</span>
<span class="lineno"> 2855 </span><span class="spaces">                                         </span><span class="nottickedoff">fp { llvmFieldContents =</span>
<span class="lineno"> 2856 </span><span class="spaces">                                              </span><span class="nottickedoff">ValPerm_Eq (PExpr_Var y) }])</span>
<span class="lineno"> 2857 </span><span class="spaces">      </span><span class="nottickedoff">ps)</span>
<span class="lineno"> 2858 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2859 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ElimLLVMFieldContents: unexpected permission&quot;</span>
<span class="lineno"> 2860 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ElimLLVMBlockToEq x bp) ps =</span>
<span class="lineno"> 2861 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_Conj1 (Perm_LLVMBlock bp) then</span>
<span class="lineno"> 2862 </span><span class="spaces">    </span><span class="nottickedoff">(mbPermSets1 $ nu $ \y -&gt;</span>
<span class="lineno"> 2863 </span><span class="spaces">      </span><span class="nottickedoff">pushPerm y (ValPerm_Conj1 $ Perm_LLVMBlockShape $</span>
<span class="lineno"> 2864 </span><span class="spaces">                  </span><span class="nottickedoff">modalizeBlockShape bp) $</span>
<span class="lineno"> 2865 </span><span class="spaces">      </span><span class="nottickedoff">set (topDistPerm x) (ValPerm_Conj1 $ Perm_LLVMBlock $</span>
<span class="lineno"> 2866 </span><span class="spaces">                           </span><span class="nottickedoff">bp { llvmBlockShape =</span>
<span class="lineno"> 2867 </span><span class="spaces">                                  </span><span class="nottickedoff">PExpr_EqShape (llvmBlockLen bp) (PExpr_Var y) })</span>
<span class="lineno"> 2868 </span><span class="spaces">      </span><span class="nottickedoff">ps)</span>
<span class="lineno"> 2869 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2870 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ElimLLVMBlockToEq: unexpected permission&quot;</span>
<span class="lineno"> 2871 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_SplitLLVMWordField x fp sz1 endianness) ps =</span>
<span class="lineno"> 2872 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_LLVMField fp &amp;&amp;</span>
<span class="lineno"> 2873 </span><span class="spaces">     </span><span class="nottickedoff">intValue sz1 `mod` 8 == 0 then</span>
<span class="lineno"> 2874 </span><span class="spaces">    </span><span class="nottickedoff">mbPermSets1 $ nuMultiWithElim1</span>
<span class="lineno"> 2875 </span><span class="spaces">    </span><span class="nottickedoff">(\(_ :&gt;: y :&gt;: z) vps_out -&gt;</span>
<span class="lineno"> 2876 </span><span class="spaces">      </span><span class="nottickedoff">flip modifyDistPerms ps $ \(dps :&gt;: _) -&gt;</span>
<span class="lineno"> 2877 </span><span class="spaces">      </span><span class="nottickedoff">RL.append dps $ RL.map2 VarAndPerm (MNil :&gt;: x :&gt;: x :&gt;: y :&gt;: z) vps_out) $</span>
<span class="lineno"> 2878 </span><span class="spaces">    </span><span class="nottickedoff">impl1SplitLLVMWordFieldOutPerms fp sz1 endianness</span>
<span class="lineno"> 2879 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2880 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_SplitLLVMWordField: unexpected input permissions&quot;</span>
<span class="lineno"> 2881 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_TruncateLLVMWordField x fp sz1 endianness) ps =</span>
<span class="lineno"> 2882 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. topDistPerm x == ValPerm_LLVMField fp then</span>
<span class="lineno"> 2883 </span><span class="spaces">    </span><span class="nottickedoff">mbPermSets1 $ nuWithElim1</span>
<span class="lineno"> 2884 </span><span class="spaces">    </span><span class="nottickedoff">(\y vps_out -&gt;</span>
<span class="lineno"> 2885 </span><span class="spaces">      </span><span class="nottickedoff">flip modifyDistPerms ps $ \(dps :&gt;: _) -&gt;</span>
<span class="lineno"> 2886 </span><span class="spaces">      </span><span class="nottickedoff">RL.append dps $ RL.map2 VarAndPerm (MNil :&gt;: x :&gt;: y) vps_out) $</span>
<span class="lineno"> 2887 </span><span class="spaces">    </span><span class="nottickedoff">impl1TruncateLLVMWordFieldOutPerms fp sz1 endianness</span>
<span class="lineno"> 2888 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2889 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_TruncateLLVMWordField: unexpected input permissions&quot;</span>
<span class="lineno"> 2890 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_ConcatLLVMWordFields x fp1 e2 endianness) ps =</span>
<span class="lineno"> 2891 </span><span class="spaces">  </span><span class="nottickedoff">if ps ^. distPerm (Member_Step Member_Base) x == ValPerm_LLVMField fp1 &amp;&amp;</span>
<span class="lineno"> 2892 </span><span class="spaces">     </span><span class="nottickedoff">ps ^. topDistPerm x == (ValPerm_LLVMField $</span>
<span class="lineno"> 2893 </span><span class="spaces">                             </span><span class="nottickedoff">llvmFieldAddOffsetInt</span>
<span class="lineno"> 2894 </span><span class="spaces">                             </span><span class="nottickedoff">(llvmFieldSetEqWord fp1 e2)</span>
<span class="lineno"> 2895 </span><span class="spaces">                             </span><span class="nottickedoff">(intValue (natRepr fp1) `div` 8)) &amp;&amp;</span>
<span class="lineno"> 2896 </span><span class="spaces">     </span><span class="nottickedoff">intValue (natRepr fp1) `mod` 8 == 0 then</span>
<span class="lineno"> 2897 </span><span class="spaces">    </span><span class="nottickedoff">mbPermSets1 $ nuWithElim1</span>
<span class="lineno"> 2898 </span><span class="spaces">    </span><span class="nottickedoff">(\y vps_out -&gt;</span>
<span class="lineno"> 2899 </span><span class="spaces">      </span><span class="nottickedoff">flip modifyDistPerms ps $ \(dps :&gt;: _ :&gt;: _) -&gt;</span>
<span class="lineno"> 2900 </span><span class="spaces">      </span><span class="nottickedoff">RL.append dps $ RL.map2 VarAndPerm (MNil :&gt;: x :&gt;: y) vps_out) $</span>
<span class="lineno"> 2901 </span><span class="spaces">    </span><span class="nottickedoff">impl1ConcatLLVMWordFieldsOutPerms fp1 e2 endianness</span>
<span class="lineno"> 2902 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 2903 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyImpl1: Impl1_ConcatLLVMWordField: unexpected input permissions&quot;</span>
<span class="lineno"> 2904 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ Impl1_BeginLifetime ps =</span>
<span class="lineno"> 2905 </span><span class="spaces">  </span><span class="nottickedoff">mbPermSets1 $ nu $ \l -&gt;</span>
<span class="lineno"> 2906 </span><span class="spaces">  </span><span class="nottickedoff">pushPerm l (ValPerm_LOwned [] CruCtxNil CruCtxNil MNil MNil) ps</span>
<span class="lineno"> 2907 </span><span class="spaces"></span><span class="nottickedoff">applyImpl1 _ (Impl1_TryProveBVProp x prop _) ps =</span>
<span class="lineno"> 2908 </span><span class="spaces">  </span><span class="nottickedoff">mbPermSets1 $ emptyMb $</span>
<span class="lineno"> 2909 </span><span class="spaces">  </span><span class="nottickedoff">pushPerm x (ValPerm_Conj [Perm_BVProp prop]) ps</span></span>
<span class="lineno"> 2910 </span>
<span class="lineno"> 2911 </span>
<span class="lineno"> 2912 </span>-- | Helper function to compute the output permissions of the
<span class="lineno"> 2913 </span>-- 'Impl1_SplitLLVMWordField' rule
<span class="lineno"> 2914 </span>impl1SplitLLVMWordFieldOutPerms ::
<span class="lineno"> 2915 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2,
<span class="lineno"> 2916 </span>   1 &lt;= (sz2 - sz1), KnownNat (sz2 - sz1)) =&gt;
<span class="lineno"> 2917 </span>  LLVMFieldPerm w sz2 -&gt; NatRepr sz1 -&gt; EndianForm -&gt;
<span class="lineno"> 2918 </span>  Mb (RNil :&gt; BVType sz1 :&gt; BVType (sz2 - sz1))
<span class="lineno"> 2919 </span>  (ValuePerms (RNil :&gt; LLVMPointerType w :&gt; LLVMPointerType w :&gt;
<span class="lineno"> 2920 </span>               BVType sz1 :&gt; BVType (sz2 - sz1)))
<span class="lineno"> 2921 </span><span class="decl"><span class="nottickedoff">impl1SplitLLVMWordFieldOutPerms fp sz1 endianness =</span>
<span class="lineno"> 2922 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti RL.typeCtxProxies $ \(MNil :&gt;: y :&gt;: z) -&gt;</span>
<span class="lineno"> 2923 </span><span class="spaces">  </span><span class="nottickedoff">let (p_y,p_z) =</span>
<span class="lineno"> 2924 </span><span class="spaces">        </span><span class="nottickedoff">case llvmFieldContents fp of</span>
<span class="lineno"> 2925 </span><span class="spaces">          </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMWord (bvMatchConst -&gt; Just bv))</span>
<span class="lineno"> 2926 </span><span class="spaces">            </span><span class="nottickedoff">| Just (bv1,bv2) &lt;- bvSplit endianness sz1 bv -&gt;</span>
<span class="lineno"> 2927 </span><span class="spaces">              </span><span class="nottickedoff">(ValPerm_Eq (bvBV bv1), ValPerm_Eq (bvBV bv2))</span>
<span class="lineno"> 2928 </span><span class="spaces">          </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMWord _) -&gt;</span>
<span class="lineno"> 2929 </span><span class="spaces">            </span><span class="nottickedoff">(ValPerm_True, ValPerm_True)</span>
<span class="lineno"> 2930 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2931 </span><span class="spaces">            </span><span class="nottickedoff">error (&quot;applyImpl1: Impl1_SplitLLVMWordField: &quot;</span>
<span class="lineno"> 2932 </span><span class="spaces">                   </span><span class="nottickedoff">++ &quot;malformed input permission&quot;) in</span>
<span class="lineno"> 2933 </span><span class="spaces">  </span><span class="nottickedoff">MNil :&gt;: ValPerm_LLVMField (llvmFieldSetEqWordVar fp y) :&gt;:</span>
<span class="lineno"> 2934 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LLVMField (llvmFieldAddOffsetInt</span>
<span class="lineno"> 2935 </span><span class="spaces">                     </span><span class="nottickedoff">(llvmFieldSetEqWordVar fp z)</span>
<span class="lineno"> 2936 </span><span class="spaces">                     </span><span class="nottickedoff">(intValue sz1 `div` 8)) :&gt;: p_y :&gt;: p_z</span></span>
<span class="lineno"> 2937 </span>
<span class="lineno"> 2938 </span>-- | Helper function to compute the output permissions of the
<span class="lineno"> 2939 </span>-- 'Impl1_TruncateLLVMWordField' rule
<span class="lineno"> 2940 </span>impl1TruncateLLVMWordFieldOutPerms ::
<span class="lineno"> 2941 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2) =&gt;
<span class="lineno"> 2942 </span>  LLVMFieldPerm w sz2 -&gt; NatRepr sz1 -&gt; EndianForm -&gt;
<span class="lineno"> 2943 </span>  Mb (RNil :&gt; BVType sz1) (ValuePerms (RNil :&gt; LLVMPointerType w :&gt; BVType sz1))
<span class="lineno"> 2944 </span><span class="decl"><span class="nottickedoff">impl1TruncateLLVMWordFieldOutPerms fp sz1 endianness =</span>
<span class="lineno"> 2945 </span><span class="spaces">  </span><span class="nottickedoff">nu $ \y -&gt;</span>
<span class="lineno"> 2946 </span><span class="spaces">  </span><span class="nottickedoff">let p_y =</span>
<span class="lineno"> 2947 </span><span class="spaces">        </span><span class="nottickedoff">case llvmFieldContents fp of</span>
<span class="lineno"> 2948 </span><span class="spaces">          </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMWord (bvMatchConst -&gt; Just bv))</span>
<span class="lineno"> 2949 </span><span class="spaces">            </span><span class="nottickedoff">| Just (bv1,_) &lt;- bvSplit endianness sz1 bv -&gt;</span>
<span class="lineno"> 2950 </span><span class="spaces">              </span><span class="nottickedoff">ValPerm_Eq (bvBV bv1)</span>
<span class="lineno"> 2951 </span><span class="spaces">          </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMWord _) -&gt; ValPerm_True</span>
<span class="lineno"> 2952 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2953 </span><span class="spaces">            </span><span class="nottickedoff">error (&quot;applyImpl1: Impl1_TruncateLLVMWordField: &quot;</span>
<span class="lineno"> 2954 </span><span class="spaces">                   </span><span class="nottickedoff">++ &quot;malformed input permission&quot;) in</span>
<span class="lineno"> 2955 </span><span class="spaces">  </span><span class="nottickedoff">MNil :&gt;: ValPerm_LLVMField (llvmFieldSetEqWordVar fp y) :&gt;: p_y</span></span>
<span class="lineno"> 2956 </span>
<span class="lineno"> 2957 </span>
<span class="lineno"> 2958 </span>-- | Helper function to compute the output permissions of the
<span class="lineno"> 2959 </span>-- 'Impl1_ConcatLLVMWordFields' rule
<span class="lineno"> 2960 </span>impl1ConcatLLVMWordFieldsOutPerms ::
<span class="lineno"> 2961 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1, 1 &lt;= sz2, KnownNat sz2,
<span class="lineno"> 2962 </span>   1 &lt;= (sz1 + sz2), KnownNat (sz1 + sz2)) =&gt;
<span class="lineno"> 2963 </span>  LLVMFieldPerm w sz1 -&gt; PermExpr (BVType sz2) -&gt; EndianForm -&gt;
<span class="lineno"> 2964 </span>  Mb (RNil :&gt; BVType (sz1 + sz2)) (ValuePerms (RNil :&gt; LLVMPointerType w :&gt;
<span class="lineno"> 2965 </span>                                               BVType (sz1 + sz2)))
<span class="lineno"> 2966 </span><span class="decl"><span class="nottickedoff">impl1ConcatLLVMWordFieldsOutPerms fp1 e2 endianness =</span>
<span class="lineno"> 2967 </span><span class="spaces">  </span><span class="nottickedoff">nu $ \y -&gt;</span>
<span class="lineno"> 2968 </span><span class="spaces">  </span><span class="nottickedoff">let p_y =</span>
<span class="lineno"> 2969 </span><span class="spaces">        </span><span class="nottickedoff">case (llvmFieldContents fp1, bvMatchConst e2) of</span>
<span class="lineno"> 2970 </span><span class="spaces">          </span><span class="nottickedoff">(ValPerm_Eq (PExpr_LLVMWord</span>
<span class="lineno"> 2971 </span><span class="spaces">                       </span><span class="nottickedoff">(bvMatchConst -&gt; Just bv1)), Just bv2) -&gt;</span>
<span class="lineno"> 2972 </span><span class="spaces">            </span><span class="nottickedoff">ValPerm_Eq $ bvBV (bvConcat endianness bv1 bv2)</span>
<span class="lineno"> 2973 </span><span class="spaces">          </span><span class="nottickedoff">(ValPerm_Eq (PExpr_LLVMWord _), _) -&gt; ValPerm_True</span>
<span class="lineno"> 2974 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2975 </span><span class="spaces">            </span><span class="nottickedoff">error (&quot;applyImpl1: Impl1_ConcatLLVMWordField: &quot;</span>
<span class="lineno"> 2976 </span><span class="spaces">                   </span><span class="nottickedoff">++ &quot;malformed input permission&quot;) in</span>
<span class="lineno"> 2977 </span><span class="spaces">  </span><span class="nottickedoff">MNil :&gt;: ValPerm_LLVMField (llvmFieldSetEqWordVar fp1 y) :&gt;: p_y</span></span>
<span class="lineno"> 2978 </span>
<span class="lineno"> 2979 </span>
<span class="lineno"> 2980 </span>instance SubstVar PermVarSubst m =&gt; Substable PermVarSubst (EqPerm a) m where
<span class="lineno"> 2981 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| EqPerm x e b |]) =</span>
<span class="lineno"> 2982 </span><span class="spaces">    </span><span class="nottickedoff">EqPerm &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e &lt;*&gt; return (mbLift b)</span></span>
<span class="lineno"> 2983 </span>
<span class="lineno"> 2984 </span>instance SubstVar PermVarSubst m =&gt; Substable1 PermVarSubst EqPerm m where
<span class="lineno"> 2985 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 2986 </span>
<span class="lineno"> 2987 </span>-- NOTE: PermVarSubst is always associated with the Identity monad because of
<span class="lineno"> 2988 </span>-- the functional dependency of SubstVar; this is necessary to substitute inside
<span class="lineno"> 2989 </span>-- the function used in EqProofStep
<span class="lineno"> 2990 </span>instance (NuMatching a, Substable PermVarSubst a Identity) =&gt;
<span class="lineno"> 2991 </span>         Substable PermVarSubst (EqProofStep ps a) Identity where
<span class="lineno"> 2992 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| EqProofStep eq_perms f |]) =</span>
<span class="lineno"> 2993 </span><span class="spaces">    </span><span class="nottickedoff">Identity $ EqProofStep (runIdentity $ genSubst s eq_perms) $ \es -&gt;</span>
<span class="lineno"> 2994 </span><span class="spaces">    </span><span class="nottickedoff">runIdentity $ genSubst s $ fmap ($ es) f</span></span>
<span class="lineno"> 2995 </span>
<span class="lineno"> 2996 </span>instance (NuMatching a, Substable PermVarSubst a Identity) =&gt;
<span class="lineno"> 2997 </span>         Substable PermVarSubst (EqProof ps a) Identity where
<span class="lineno"> 2998 </span>  <span class="decl"><span class="nottickedoff">genSubst s eqp = case mbMatch eqp of</span>
<span class="lineno"> 2999 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| EqProofRefl a |] -&gt;</span>
<span class="lineno"> 3000 </span><span class="spaces">      </span><span class="nottickedoff">EqProofRefl &lt;$&gt; genSubst s a</span>
<span class="lineno"> 3001 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| EqProofCons eqp' eq_step |] -&gt;</span>
<span class="lineno"> 3002 </span><span class="spaces">      </span><span class="nottickedoff">EqProofCons &lt;$&gt; genSubst s eqp' &lt;*&gt; genSubst s eq_step</span></span>
<span class="lineno"> 3003 </span>
<span class="lineno"> 3004 </span>instance m ~ Identity =&gt;
<span class="lineno"> 3005 </span>         Substable PermVarSubst (SimplImpl ps_in ps_out) m where
<span class="lineno"> 3006 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_impl = case mbMatch mb_impl of</span>
<span class="lineno"> 3007 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_Drop x p |] -&gt;</span>
<span class="lineno"> 3008 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_Drop &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3009 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_Copy x p |] -&gt;</span>
<span class="lineno"> 3010 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_Copy &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3011 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_Swap x p1 y p2 |] -&gt;</span>
<span class="lineno"> 3012 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_Swap &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p1 &lt;*&gt; genSubst s y &lt;*&gt; genSubst s p2</span>
<span class="lineno"> 3013 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_MoveUp ps1 x p ps2 |] -&gt;</span>
<span class="lineno"> 3014 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_MoveUp &lt;$&gt; genSubst s ps1 &lt;*&gt; genSubst s x &lt;*&gt;</span>
<span class="lineno"> 3015 </span><span class="spaces">                       </span><span class="nottickedoff">genSubst s p &lt;*&gt; genSubst s ps2</span>
<span class="lineno"> 3016 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_MoveDown ps1 x p ps2 |] -&gt;</span>
<span class="lineno"> 3017 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_MoveDown &lt;$&gt; genSubst s ps1 &lt;*&gt; genSubst s x &lt;*&gt;</span>
<span class="lineno"> 3018 </span><span class="spaces">                         </span><span class="nottickedoff">genSubst s p &lt;*&gt; genSubst s ps2</span>
<span class="lineno"> 3019 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroOrL x p1 p2 |] -&gt;</span>
<span class="lineno"> 3020 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroOrL &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p1 &lt;*&gt; genSubst s p2</span>
<span class="lineno"> 3021 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroOrR x p1 p2 |] -&gt;</span>
<span class="lineno"> 3022 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroOrR &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p1 &lt;*&gt; genSubst s p2</span>
<span class="lineno"> 3023 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroExists x e p |] -&gt;</span>
<span class="lineno"> 3024 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroExists &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3025 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_Cast x y p |] -&gt;</span>
<span class="lineno"> 3026 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_Cast &lt;$&gt; genSubst s x &lt;*&gt; genSubst s y &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3027 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CastPerm x eqp |] -&gt;</span>
<span class="lineno"> 3028 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CastPerm &lt;$&gt; genSubst s x &lt;*&gt; return (runIdentity $ genSubst s eqp)</span>
<span class="lineno"> 3029 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroEqRefl x |] -&gt;</span>
<span class="lineno"> 3030 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroEqRefl &lt;$&gt; genSubst s x</span>
<span class="lineno"> 3031 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_InvertEq x y |] -&gt;</span>
<span class="lineno"> 3032 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_InvertEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s y</span>
<span class="lineno"> 3033 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_InvTransEq x y e |] -&gt;</span>
<span class="lineno"> 3034 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_InvTransEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s y &lt;*&gt; genSubst s e</span>
<span class="lineno"> 3035 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_UnitEq x e |] -&gt;</span>
<span class="lineno"> 3036 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_UnitEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e</span>
<span class="lineno"> 3037 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CopyEq x e |] -&gt;</span>
<span class="lineno"> 3038 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CopyEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e</span>
<span class="lineno"> 3039 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMWordEq x y e |] -&gt;</span>
<span class="lineno"> 3040 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMWordEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s y &lt;*&gt; genSubst s e</span>
<span class="lineno"> 3041 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMOffsetZeroEq x |] -&gt;</span>
<span class="lineno"> 3042 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMOffsetZeroEq &lt;$&gt; genSubst s x</span>
<span class="lineno"> 3043 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroConj x |] -&gt;</span>
<span class="lineno"> 3044 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroConj &lt;$&gt; genSubst s x</span>
<span class="lineno"> 3045 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ExtractConj x ps i |] -&gt;</span>
<span class="lineno"> 3046 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ExtractConj &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ps &lt;*&gt; return (mbLift i)</span>
<span class="lineno"> 3047 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CopyConj x ps i |] -&gt;</span>
<span class="lineno"> 3048 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CopyConj &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ps &lt;*&gt; return (mbLift i)</span>
<span class="lineno"> 3049 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_InsertConj x p ps i |] -&gt;</span>
<span class="lineno"> 3050 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_InsertConj &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p &lt;*&gt;</span>
<span class="lineno"> 3051 </span><span class="spaces">                           </span><span class="nottickedoff">genSubst s ps &lt;*&gt; return (mbLift i)</span>
<span class="lineno"> 3052 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_AppendConjs x ps1 ps2 |] -&gt;</span>
<span class="lineno"> 3053 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_AppendConjs &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ps1 &lt;*&gt; genSubst s ps2</span>
<span class="lineno"> 3054 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_SplitConjs x ps i |] -&gt;</span>
<span class="lineno"> 3055 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_SplitConjs &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ps &lt;*&gt; return (mbLift i)</span>
<span class="lineno"> 3056 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroStructTrue x fs |] -&gt;</span>
<span class="lineno"> 3057 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroStructTrue &lt;$&gt; genSubst s x &lt;*&gt; return (mbLift fs)</span>
<span class="lineno"> 3058 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_StructEqToPerm x exprs |] -&gt;</span>
<span class="lineno"> 3059 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_StructEqToPerm &lt;$&gt; genSubst s x &lt;*&gt; genSubst s exprs</span>
<span class="lineno"> 3060 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_StructPermToEq x exprs |] -&gt;</span>
<span class="lineno"> 3061 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_StructPermToEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s exprs</span>
<span class="lineno"> 3062 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroStructField x ps memb p |] -&gt;</span>
<span class="lineno"> 3063 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroStructField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ps</span>
<span class="lineno"> 3064 </span><span class="spaces">                             </span><span class="nottickedoff">&lt;*&gt; genSubst s memb &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3065 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ConstFunPerm x h fun_perm ident |] -&gt;</span>
<span class="lineno"> 3066 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ConstFunPerm &lt;$&gt; genSubst s x &lt;*&gt; return (mbLift h) &lt;*&gt;</span>
<span class="lineno"> 3067 </span><span class="spaces">                             </span><span class="nottickedoff">genSubst s fun_perm &lt;*&gt; return (mbLift ident)</span>
<span class="lineno"> 3068 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMWord x e1 e2 |] -&gt;</span>
<span class="lineno"> 3069 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CastLLVMWord &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 3070 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_InvertLLVMOffsetEq x off y |] -&gt;</span>
<span class="lineno"> 3071 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_InvertLLVMOffsetEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s off &lt;*&gt; genSubst s y</span>
<span class="lineno"> 3072 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_OffsetLLVMWord y e off x |] -&gt;</span>
<span class="lineno"> 3073 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_OffsetLLVMWord &lt;$&gt; genSubst s y &lt;*&gt; genSubst s e &lt;*&gt;</span>
<span class="lineno"> 3074 </span><span class="spaces">                               </span><span class="nottickedoff">genSubst s off &lt;*&gt; genSubst s x</span>
<span class="lineno"> 3075 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMPtr y p off x |] -&gt;</span>
<span class="lineno"> 3076 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CastLLVMPtr &lt;$&gt; genSubst s y &lt;*&gt; genSubst s p &lt;*&gt;</span>
<span class="lineno"> 3077 </span><span class="spaces">                            </span><span class="nottickedoff">genSubst s off &lt;*&gt; genSubst s x</span>
<span class="lineno"> 3078 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMFree x e1 e2 |] -&gt;</span>
<span class="lineno"> 3079 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CastLLVMFree &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 3080 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CastLLVMFieldOffset x fld off' |] -&gt;</span>
<span class="lineno"> 3081 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CastLLVMFieldOffset &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fld &lt;*&gt;</span>
<span class="lineno"> 3082 </span><span class="spaces">                                    </span><span class="nottickedoff">genSubst s off'</span>
<span class="lineno"> 3083 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMFieldContents x y fld |] -&gt;</span>
<span class="lineno"> 3084 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMFieldContents &lt;$&gt; genSubst s x &lt;*&gt; genSubst s y &lt;*&gt;</span>
<span class="lineno"> 3085 </span><span class="spaces">                                       </span><span class="nottickedoff">genSubst s fld</span>
<span class="lineno"> 3086 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_DemoteLLVMFieldRW x fld |] -&gt;</span>
<span class="lineno"> 3087 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_DemoteLLVMFieldRW &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fld</span>
<span class="lineno"> 3088 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_SplitLLVMTrueField x fp sz1 sz2m1 |] -&gt;</span>
<span class="lineno"> 3089 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_SplitLLVMTrueField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp &lt;*&gt;</span>
<span class="lineno"> 3090 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift sz1) &lt;*&gt; return (mbLift sz2m1)</span>
<span class="lineno"> 3091 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_TruncateLLVMTrueField x fp sz1 |] -&gt;</span>
<span class="lineno"> 3092 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_TruncateLLVMTrueField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp &lt;*&gt;</span>
<span class="lineno"> 3093 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift sz1)</span>
<span class="lineno"> 3094 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ConcatLLVMTrueFields x fp1 sz2 |] -&gt;</span>
<span class="lineno"> 3095 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ConcatLLVMTrueFields &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp1 &lt;*&gt;</span>
<span class="lineno"> 3096 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift sz2)</span>
<span class="lineno"> 3097 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_DemoteLLVMArrayRW x ap |] -&gt;</span>
<span class="lineno"> 3098 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_DemoteLLVMArrayRW &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap</span>
<span class="lineno"> 3099 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCopy x ap off len |] -&gt;</span>
<span class="lineno"> 3100 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayCopy &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt; genSubst s off</span>
<span class="lineno"> 3101 </span><span class="spaces">       </span><span class="nottickedoff">&lt;*&gt; genSubst s len</span>
<span class="lineno"> 3102 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayBorrow x ap off len |] -&gt;</span>
<span class="lineno"> 3103 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayBorrow &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt; genSubst s off</span>
<span class="lineno"> 3104 </span><span class="spaces">       </span><span class="nottickedoff">&lt;*&gt; genSubst s len</span>
<span class="lineno"> 3105 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayReturn x ap rng |] -&gt;</span>
<span class="lineno"> 3106 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayReturn &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt; genSubst s rng</span>
<span class="lineno"> 3107 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayAppend x ap1 ap2 |] -&gt;</span>
<span class="lineno"> 3108 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayAppend &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap1 &lt;*&gt; genSubst s ap2</span>
<span class="lineno"> 3109 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayRearrange x ap bs |] -&gt;</span>
<span class="lineno"> 3110 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayRearrange &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt; genSubst s bs</span>
<span class="lineno"> 3111 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayToField x ap sz |] -&gt;</span>
<span class="lineno"> 3112 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayToField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap</span>
<span class="lineno"> 3113 </span><span class="spaces">                             </span><span class="nottickedoff">&lt;*&gt; return (mbLift sz)</span>
<span class="lineno"> 3114 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayEmpty x ap |] -&gt;</span>
<span class="lineno"> 3115 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayEmpty &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap</span>
<span class="lineno"> 3116 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayFromBlock x bp |] -&gt;</span>
<span class="lineno"> 3117 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayFromBlock &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3118 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayBorrowed x bp ap |] -&gt;</span>
<span class="lineno"> 3119 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayBorrowed &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp &lt;*&gt; genSubst s ap</span>
<span class="lineno"> 3120 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCellCopy x ap cell |] -&gt;</span>
<span class="lineno"> 3121 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayCellCopy &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt; genSubst s cell</span>
<span class="lineno"> 3122 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCellBorrow x ap cell |] -&gt;</span>
<span class="lineno"> 3123 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayCellBorrow &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt;</span>
<span class="lineno"> 3124 </span><span class="spaces">                                     </span><span class="nottickedoff">genSubst s cell</span>
<span class="lineno"> 3125 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayCellReturn x ap cell |] -&gt;</span>
<span class="lineno"> 3126 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayCellReturn &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt;</span>
<span class="lineno"> 3127 </span><span class="spaces">                                     </span><span class="nottickedoff">genSubst s cell</span>
<span class="lineno"> 3128 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayContents x ap sh mb_mb_impl |] -&gt;</span>
<span class="lineno"> 3129 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayContents &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap &lt;*&gt;</span>
<span class="lineno"> 3130 </span><span class="spaces">                                  </span><span class="nottickedoff">genSubst s sh &lt;*&gt; genSubst s mb_mb_impl</span>
<span class="lineno"> 3131 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMFieldIsPtr x fp |] -&gt;</span>
<span class="lineno"> 3132 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMFieldIsPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp</span>
<span class="lineno"> 3133 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMArrayIsPtr x ap |] -&gt;</span>
<span class="lineno"> 3134 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMArrayIsPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ap</span>
<span class="lineno"> 3135 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LLVMBlockIsPtr x bp |] -&gt;</span>
<span class="lineno"> 3136 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LLVMBlockIsPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3137 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_SplitLifetime x f args l l2 sub_ls tps_in tps_out ps_in ps_out |] -&gt;</span>
<span class="lineno"> 3138 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_SplitLifetime &lt;$&gt; genSubst s x &lt;*&gt; genSubst s f &lt;*&gt; genSubst s args</span>
<span class="lineno"> 3139 </span><span class="spaces">                          </span><span class="nottickedoff">&lt;*&gt; genSubst s l &lt;*&gt; genSubst s l2</span>
<span class="lineno"> 3140 </span><span class="spaces">                          </span><span class="nottickedoff">&lt;*&gt; genSubst s sub_ls</span>
<span class="lineno"> 3141 </span><span class="spaces">                          </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in &lt;*&gt; genSubst s tps_out</span>
<span class="lineno"> 3142 </span><span class="spaces">                          </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 3143 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_SubsumeLifetime l ls tps_in tps_out ps_in ps_out l2 |] -&gt;</span>
<span class="lineno"> 3144 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_SubsumeLifetime &lt;$&gt; genSubst s l &lt;*&gt; genSubst s ls</span>
<span class="lineno"> 3145 </span><span class="spaces">                            </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in &lt;*&gt; genSubst s tps_out</span>
<span class="lineno"> 3146 </span><span class="spaces">                            </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 3147 </span><span class="spaces">                            </span><span class="nottickedoff">&lt;*&gt; genSubst s l2</span>
<span class="lineno"> 3148 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ContainedLifetimeCurrent l ls tps_in tps_out ps_in ps_out l2 |] -&gt;</span>
<span class="lineno"> 3149 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ContainedLifetimeCurrent &lt;$&gt; genSubst s l &lt;*&gt; genSubst s ls</span>
<span class="lineno"> 3150 </span><span class="spaces">                                     </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in &lt;*&gt; genSubst s tps_out</span>
<span class="lineno"> 3151 </span><span class="spaces">                                     </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 3152 </span><span class="spaces">                                     </span><span class="nottickedoff">&lt;*&gt; genSubst s l2</span>
<span class="lineno"> 3153 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_RemoveContainedLifetime l ls tps_in tps_out ps_in ps_out l2 |] -&gt;</span>
<span class="lineno"> 3154 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_RemoveContainedLifetime &lt;$&gt; genSubst s l &lt;*&gt; genSubst s ls</span>
<span class="lineno"> 3155 </span><span class="spaces">                                    </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in &lt;*&gt; genSubst s tps_out</span>
<span class="lineno"> 3156 </span><span class="spaces">                                    </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 3157 </span><span class="spaces">                                    </span><span class="nottickedoff">&lt;*&gt; genSubst s l2</span>
<span class="lineno"> 3158 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_WeakenLifetime x f args l l2 |] -&gt;</span>
<span class="lineno"> 3159 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_WeakenLifetime &lt;$&gt; genSubst s x &lt;*&gt; genSubst s f &lt;*&gt; genSubst s args</span>
<span class="lineno"> 3160 </span><span class="spaces">                           </span><span class="nottickedoff">&lt;*&gt; genSubst s l &lt;*&gt; genSubst s l2</span>
<span class="lineno"> 3161 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_MapLifetime l ls tps_in tps_out ps_in ps_out</span>
<span class="lineno"> 3162 </span><span class="spaces">                             </span><span class="nottickedoff">tps_in' tps_out' ps_in' ps_out'</span>
<span class="lineno"> 3163 </span><span class="spaces">                             </span><span class="nottickedoff">ps1 ps2 impl1 impl2 |] -&gt;</span>
<span class="lineno"> 3164 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_MapLifetime &lt;$&gt; genSubst s l &lt;*&gt; genSubst s ls</span>
<span class="lineno"> 3165 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in &lt;*&gt; genSubst s tps_out</span>
<span class="lineno"> 3166 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 3167 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in' &lt;*&gt; genSubst s tps_out'</span>
<span class="lineno"> 3168 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in' &lt;*&gt; genSubst s ps_out'</span>
<span class="lineno"> 3169 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s ps1 &lt;*&gt; genSubst s ps2</span>
<span class="lineno"> 3170 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s impl1 &lt;*&gt; genSubst s impl2</span>
<span class="lineno"> 3171 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_EndLifetime l tps_in tps_out ps_in ps_out |] -&gt;</span>
<span class="lineno"> 3172 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_EndLifetime &lt;$&gt; genSubst s l</span>
<span class="lineno"> 3173 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s tps_in &lt;*&gt; genSubst s tps_out</span>
<span class="lineno"> 3174 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s ps_in &lt;*&gt; genSubst s ps_out</span>
<span class="lineno"> 3175 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLOwnedSimple l tps lops |] -&gt;</span>
<span class="lineno"> 3176 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLOwnedSimple &lt;$&gt; genSubst s l</span>
<span class="lineno"> 3177 </span><span class="spaces">                              </span><span class="nottickedoff">&lt;*&gt; genSubst s tps &lt;*&gt; genSubst s lops</span>
<span class="lineno"> 3178 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLOwnedSimple l tps lops |] -&gt;</span>
<span class="lineno"> 3179 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLOwnedSimple &lt;$&gt; genSubst s l</span>
<span class="lineno"> 3180 </span><span class="spaces">                             </span><span class="nottickedoff">&lt;*&gt; genSubst s tps &lt;*&gt; genSubst s lops</span>
<span class="lineno"> 3181 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LCurrentRefl l |] -&gt;</span>
<span class="lineno"> 3182 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LCurrentRefl &lt;$&gt; genSubst s l</span>
<span class="lineno"> 3183 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_LCurrentTrans l1 l2 l3 |] -&gt;</span>
<span class="lineno"> 3184 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_LCurrentTrans &lt;$&gt; genSubst s l1 &lt;*&gt; genSubst s l2 &lt;*&gt; genSubst s l3</span>
<span class="lineno"> 3185 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_DemoteLLVMBlockRW x bp |] -&gt;</span>
<span class="lineno"> 3186 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_DemoteLLVMBlockRW &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3187 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockEmpty x bp |] -&gt;</span>
<span class="lineno"> 3188 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockEmpty &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3189 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_CoerceLLVMBlockEmpty x bp |] -&gt;</span>
<span class="lineno"> 3190 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_CoerceLLVMBlockEmpty &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3191 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockToBytes x bp |] -&gt;</span>
<span class="lineno"> 3192 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockToBytes &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3193 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockTuple x bp |] -&gt;</span>
<span class="lineno"> 3194 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockTuple &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3195 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockTuple x bp |] -&gt;</span>
<span class="lineno"> 3196 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockTuple &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3197 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockSeqEmpty x bp |] -&gt;</span>
<span class="lineno"> 3198 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockSeqEmpty &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3199 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockSeqEmpty x bp |] -&gt;</span>
<span class="lineno"> 3200 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockSeqEmpty &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3201 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_SplitLLVMBlockEmpty x bp len1 |] -&gt;</span>
<span class="lineno"> 3202 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_SplitLLVMBlockEmpty &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3203 </span><span class="spaces">      </span><span class="nottickedoff">&lt;*&gt; genSubst s len1</span>
<span class="lineno"> 3204 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockNamed x bp nmsh |] -&gt;</span>
<span class="lineno"> 3205 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockNamed &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3206 </span><span class="spaces">                                </span><span class="nottickedoff">&lt;*&gt; genSubst s nmsh</span>
<span class="lineno"> 3207 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockNamed x bp nmsh |] -&gt;</span>
<span class="lineno"> 3208 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockNamed &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3209 </span><span class="spaces">                               </span><span class="nottickedoff">&lt;*&gt; genSubst s nmsh</span>
<span class="lineno"> 3210 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockNamedMods x bp |] -&gt;</span>
<span class="lineno"> 3211 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockNamedMods &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3212 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockNamedMods x bp |] -&gt;</span>
<span class="lineno"> 3213 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockNamedMods &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3214 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockFromEq x bp y |] -&gt;</span>
<span class="lineno"> 3215 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockFromEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3216 </span><span class="spaces">                                 </span><span class="nottickedoff">&lt;*&gt; genSubst s y</span>
<span class="lineno"> 3217 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockPtr x bp |] -&gt;</span>
<span class="lineno"> 3218 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3219 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockPtr x bp |] -&gt;</span>
<span class="lineno"> 3220 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3221 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockField x fp |] -&gt;</span>
<span class="lineno"> 3222 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp</span>
<span class="lineno"> 3223 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockField x fp |] -&gt;</span>
<span class="lineno"> 3224 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp</span>
<span class="lineno"> 3225 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockArray x fp |] -&gt;</span>
<span class="lineno"> 3226 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockArray &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp</span>
<span class="lineno"> 3227 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockArray x bp |] -&gt;</span>
<span class="lineno"> 3228 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockArray &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3229 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockSeq x bp1 len2 sh2 |] -&gt;</span>
<span class="lineno"> 3230 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockSeq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp1</span>
<span class="lineno"> 3231 </span><span class="spaces">                              </span><span class="nottickedoff">&lt;*&gt; genSubst s len2 &lt;*&gt; genSubst s sh2</span>
<span class="lineno"> 3232 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockSeq x bp1 sh2 |] -&gt;</span>
<span class="lineno"> 3233 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockSeq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp1</span>
<span class="lineno"> 3234 </span><span class="spaces">                             </span><span class="nottickedoff">&lt;*&gt; genSubst s sh2</span>
<span class="lineno"> 3235 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockOr x bp1 sh2 |] -&gt;</span>
<span class="lineno"> 3236 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockOr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp1</span>
<span class="lineno"> 3237 </span><span class="spaces">                             </span><span class="nottickedoff">&lt;*&gt; genSubst s sh2</span>
<span class="lineno"> 3238 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockOr x bp shs |] -&gt;</span>
<span class="lineno"> 3239 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockOr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp &lt;*&gt; genSubst s shs</span>
<span class="lineno"> 3240 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroLLVMBlockEx x bp |] -&gt;</span>
<span class="lineno"> 3241 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroLLVMBlockEx &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3242 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockEx x bp |] -&gt;</span>
<span class="lineno"> 3243 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockEx &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3244 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimLLVMBlockFalse x bp |] -&gt;</span>
<span class="lineno"> 3245 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimLLVMBlockFalse &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3246 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_FoldNamed x np args off |] -&gt;</span>
<span class="lineno"> 3247 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_FoldNamed &lt;$&gt; genSubst s x &lt;*&gt; genSubst s np &lt;*&gt; genSubst s args</span>
<span class="lineno"> 3248 </span><span class="spaces">                      </span><span class="nottickedoff">&lt;*&gt; genSubst s off</span>
<span class="lineno"> 3249 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_UnfoldNamed x np args off |] -&gt;</span>
<span class="lineno"> 3250 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_UnfoldNamed &lt;$&gt; genSubst s x &lt;*&gt; genSubst s np &lt;*&gt; genSubst s args</span>
<span class="lineno"> 3251 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s off</span>
<span class="lineno"> 3252 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_NamedToConj x npn args off |] -&gt;</span>
<span class="lineno"> 3253 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_NamedToConj &lt;$&gt; genSubst s x &lt;*&gt; genSubst s npn &lt;*&gt; genSubst s args</span>
<span class="lineno"> 3254 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;*&gt; genSubst s off</span>
<span class="lineno"> 3255 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_NamedFromConj x npn args off |] -&gt;</span>
<span class="lineno"> 3256 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_NamedFromConj &lt;$&gt; genSubst s x &lt;*&gt; genSubst s npn &lt;*&gt; genSubst s args</span>
<span class="lineno"> 3257 </span><span class="spaces">                          </span><span class="nottickedoff">&lt;*&gt; genSubst s off</span>
<span class="lineno"> 3258 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_NamedArgAlways x npn args off memb l |] -&gt;</span>
<span class="lineno"> 3259 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_NamedArgAlways &lt;$&gt; genSubst s x &lt;*&gt; genSubst s npn &lt;*&gt;</span>
<span class="lineno"> 3260 </span><span class="spaces">                               </span><span class="nottickedoff">genSubst s args &lt;*&gt; genSubst s off &lt;*&gt;</span>
<span class="lineno"> 3261 </span><span class="spaces">                               </span><span class="nottickedoff">genSubst s memb &lt;*&gt; genSubst s l</span>
<span class="lineno"> 3262 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_NamedArgCurrent x npn args off memb l2 |] -&gt;</span>
<span class="lineno"> 3263 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_NamedArgCurrent &lt;$&gt; genSubst s x &lt;*&gt; genSubst s npn &lt;*&gt;</span>
<span class="lineno"> 3264 </span><span class="spaces">                                </span><span class="nottickedoff">genSubst s args &lt;*&gt; genSubst s off &lt;*&gt;</span>
<span class="lineno"> 3265 </span><span class="spaces">                                </span><span class="nottickedoff">genSubst s memb &lt;*&gt; genSubst s l2</span>
<span class="lineno"> 3266 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_NamedArgWrite x npn args off memb rw |] -&gt;</span>
<span class="lineno"> 3267 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_NamedArgWrite &lt;$&gt; genSubst s x &lt;*&gt; genSubst s npn &lt;*&gt;</span>
<span class="lineno"> 3268 </span><span class="spaces">                              </span><span class="nottickedoff">genSubst s args &lt;*&gt; genSubst s off &lt;*&gt;</span>
<span class="lineno"> 3269 </span><span class="spaces">                              </span><span class="nottickedoff">genSubst s memb &lt;*&gt; genSubst s rw</span>
<span class="lineno"> 3270 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_NamedArgRead x npn args off memb |] -&gt;</span>
<span class="lineno"> 3271 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_NamedArgRead &lt;$&gt; genSubst s x &lt;*&gt; genSubst s npn &lt;*&gt;</span>
<span class="lineno"> 3272 </span><span class="spaces">                             </span><span class="nottickedoff">genSubst s args &lt;*&gt; genSubst s off &lt;*&gt;</span>
<span class="lineno"> 3273 </span><span class="spaces">                             </span><span class="nottickedoff">genSubst s memb</span>
<span class="lineno"> 3274 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ReachabilityTrans x rp args off y e |] -&gt;</span>
<span class="lineno"> 3275 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ReachabilityTrans &lt;$&gt; genSubst s x &lt;*&gt; genSubst s rp &lt;*&gt;</span>
<span class="lineno"> 3276 </span><span class="spaces">                                  </span><span class="nottickedoff">genSubst s args &lt;*&gt; genSubst s off &lt;*&gt;</span>
<span class="lineno"> 3277 </span><span class="spaces">                                  </span><span class="nottickedoff">genSubst s y &lt;*&gt; genSubst s e</span>
<span class="lineno"> 3278 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroAnyEqEq x e1 e2 |] -&gt;</span>
<span class="lineno"> 3279 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroAnyEqEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e1 &lt;*&gt; genSubst s e2</span>
<span class="lineno"> 3280 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_IntroAnyWordPtr x e p |] -&gt;</span>
<span class="lineno"> 3281 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_IntroAnyWordPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3282 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimAnyToEq x e |] -&gt;</span>
<span class="lineno"> 3283 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimAnyToEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s e</span>
<span class="lineno"> 3284 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SImpl_ElimAnyToPtr x fp |] -&gt;</span>
<span class="lineno"> 3285 </span><span class="spaces">      </span><span class="nottickedoff">SImpl_ElimAnyToPtr &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp</span></span>
<span class="lineno"> 3286 </span>
<span class="lineno"> 3287 </span>instance m ~ Identity =&gt;
<span class="lineno"> 3288 </span>         Substable PermVarSubst (PermImpl1 ps_in ps_out) m where
<span class="lineno"> 3289 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_impl = case mbMatch mb_impl of</span>
<span class="lineno"> 3290 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_Fail err |] -&gt; Impl1_Fail &lt;$&gt; genSubst s err</span>
<span class="lineno"> 3291 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_Catch str |] -&gt; return $ Impl1_Catch $ mbLift str</span>
<span class="lineno"> 3292 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_Push x p |] -&gt;</span>
<span class="lineno"> 3293 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_Push &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3294 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_Pop x p |] -&gt;</span>
<span class="lineno"> 3295 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_Pop &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p</span>
<span class="lineno"> 3296 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ElimOrs str x or_list |] -&gt;</span>
<span class="lineno"> 3297 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ElimOrs (mbLift str) &lt;$&gt; genSubst s x &lt;*&gt; genSubst s or_list</span>
<span class="lineno"> 3298 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ElimExists x p_body |] -&gt;</span>
<span class="lineno"> 3299 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ElimExists &lt;$&gt; genSubst s x &lt;*&gt; genSubst s p_body</span>
<span class="lineno"> 3300 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ElimFalse x |] -&gt;</span>
<span class="lineno"> 3301 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ElimFalse &lt;$&gt; genSubst s x</span>
<span class="lineno"> 3302 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_Simpl simpl prx |] -&gt;</span>
<span class="lineno"> 3303 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_Simpl &lt;$&gt; genSubst s simpl &lt;*&gt; return (mbLift prx)</span>
<span class="lineno"> 3304 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_LetBind tp e |] -&gt;</span>
<span class="lineno"> 3305 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_LetBind (mbLift tp) &lt;$&gt; genSubst s e</span>
<span class="lineno"> 3306 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ElimStructField x ps tp memb |] -&gt;</span>
<span class="lineno"> 3307 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ElimStructField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s ps</span>
<span class="lineno"> 3308 </span><span class="spaces">                            </span><span class="nottickedoff">&lt;*&gt; return (mbLift tp) &lt;*&gt; genSubst s memb</span>
<span class="lineno"> 3309 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ElimLLVMFieldContents x fp |] -&gt;</span>
<span class="lineno"> 3310 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ElimLLVMFieldContents &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp</span>
<span class="lineno"> 3311 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ElimLLVMBlockToEq x bp |] -&gt;</span>
<span class="lineno"> 3312 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ElimLLVMBlockToEq &lt;$&gt; genSubst s x &lt;*&gt; genSubst s bp</span>
<span class="lineno"> 3313 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_SplitLLVMWordField x fp2 sz1 endianness |] -&gt;</span>
<span class="lineno"> 3314 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_SplitLLVMWordField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp2 &lt;*&gt;</span>
<span class="lineno"> 3315 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift sz1) &lt;*&gt; return (mbLift endianness)</span>
<span class="lineno"> 3316 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_TruncateLLVMWordField x fp2 sz1 endianness |] -&gt;</span>
<span class="lineno"> 3317 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_TruncateLLVMWordField &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp2 &lt;*&gt;</span>
<span class="lineno"> 3318 </span><span class="spaces">      </span><span class="nottickedoff">return (mbLift sz1) &lt;*&gt; return (mbLift endianness)</span>
<span class="lineno"> 3319 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_ConcatLLVMWordFields x fp1 e2 endianness |] -&gt;</span>
<span class="lineno"> 3320 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_ConcatLLVMWordFields &lt;$&gt; genSubst s x &lt;*&gt; genSubst s fp1 &lt;*&gt;</span>
<span class="lineno"> 3321 </span><span class="spaces">      </span><span class="nottickedoff">genSubst s e2 &lt;*&gt; return (mbLift endianness)</span>
<span class="lineno"> 3322 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_BeginLifetime |] -&gt; return Impl1_BeginLifetime</span>
<span class="lineno"> 3323 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Impl1_TryProveBVProp x prop prop_str |] -&gt;</span>
<span class="lineno"> 3324 </span><span class="spaces">      </span><span class="nottickedoff">Impl1_TryProveBVProp &lt;$&gt; genSubst s x &lt;*&gt; genSubst s prop &lt;*&gt;</span>
<span class="lineno"> 3325 </span><span class="spaces">                               </span><span class="nottickedoff">return (mbLift prop_str)</span></span>
<span class="lineno"> 3326 </span>
<span class="lineno"> 3327 </span>instance (NuMatchingAny1 r, m ~ Identity,
<span class="lineno"> 3328 </span>          Substable1 PermVarSubst r m) =&gt;
<span class="lineno"> 3329 </span>         Substable PermVarSubst (PermImpl r ps) m where
<span class="lineno"> 3330 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_impl = case mbMatch mb_impl of</span>
<span class="lineno"> 3331 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PermImpl_Done r |] -&gt; PermImpl_Done &lt;$&gt; genSubst1 s r</span>
<span class="lineno"> 3332 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| PermImpl_Step impl1 mb_impls |] -&gt;</span>
<span class="lineno"> 3333 </span><span class="spaces">      </span><span class="nottickedoff">PermImpl_Step &lt;$&gt; genSubst s impl1 &lt;*&gt; genSubst s mb_impls</span></span>
<span class="lineno"> 3334 </span>
<span class="lineno"> 3335 </span>instance (NuMatchingAny1 r, m ~ Identity,
<span class="lineno"> 3336 </span>          Substable1 PermVarSubst r m) =&gt;
<span class="lineno"> 3337 </span>         Substable PermVarSubst (MbPermImpls r bs_pss) m where
<span class="lineno"> 3338 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_impls = case mbMatch mb_impls of</span>
<span class="lineno"> 3339 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MbPermImpls_Nil |] -&gt; return MbPermImpls_Nil</span>
<span class="lineno"> 3340 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MbPermImpls_Cons mpx mb_impl mb_impls' |] -&gt;</span>
<span class="lineno"> 3341 </span><span class="spaces">      </span><span class="nottickedoff">let px = mbLift mpx in</span>
<span class="lineno"> 3342 </span><span class="spaces">      </span><span class="nottickedoff">MbPermImpls_Cons px &lt;$&gt; genSubst s mb_impl &lt;*&gt; genSubstMb (cruCtxProxies px) s mb_impls'</span></span>
<span class="lineno"> 3343 </span>
<span class="lineno"> 3344 </span>instance SubstVar s m =&gt; Substable s (OrListDisj ps a disj) m where
<span class="lineno"> 3345 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| OrListDisj mb_p |]) =</span>
<span class="lineno"> 3346 </span><span class="spaces">    </span><span class="nottickedoff">OrListDisj &lt;$&gt; genSubst s mb_p</span></span>
<span class="lineno"> 3347 </span>
<span class="lineno"> 3348 </span>instance SubstVar s m =&gt; Substable1 s (OrListDisj ps a) m where
<span class="lineno"> 3349 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 3350 </span>
<span class="lineno"> 3351 </span>instance m ~ Identity =&gt;
<span class="lineno"> 3352 </span>         Substable PermVarSubst (LocalPermImpl ps_in ps_out) m where
<span class="lineno"> 3353 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| LocalPermImpl impl |]) =</span>
<span class="lineno"> 3354 </span><span class="spaces">    </span><span class="nottickedoff">LocalPermImpl &lt;$&gt; genSubst s impl</span></span>
<span class="lineno"> 3355 </span>
<span class="lineno"> 3356 </span>instance SubstVar s m =&gt; Substable s (LocalImplRet ps ps') m where
<span class="lineno"> 3357 </span>  <span class="decl"><span class="nottickedoff">genSubst _ (mbMatch -&gt; [nuMP| LocalImplRet Refl |]) = return $ LocalImplRet Refl</span></span>
<span class="lineno"> 3358 </span>
<span class="lineno"> 3359 </span>instance SubstVar s m =&gt; Substable1 s (LocalImplRet ps) m where
<span class="lineno"> 3360 </span>  <span class="decl"><span class="nottickedoff">genSubst1 _ (mbMatch -&gt; [nuMP| LocalImplRet Refl |]) = return $ LocalImplRet Refl</span></span>
<span class="lineno"> 3361 </span>
<span class="lineno"> 3362 </span>
<span class="lineno"> 3363 </span>----------------------------------------------------------------------
<span class="lineno"> 3364 </span>-- * Permission Implication Monad
<span class="lineno"> 3365 </span>----------------------------------------------------------------------
<span class="lineno"> 3366 </span>
<span class="lineno"> 3367 </span>-- FIXME: instead of having a separate PPInfo and name type map, we should maybe
<span class="lineno"> 3368 </span>-- combine all the local context into one type...?
<span class="lineno"> 3369 </span>
<span class="lineno"> 3370 </span>data ImplState vars ps =
<span class="lineno"> 3371 </span>  ImplState { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStatePerms</span></span></span> :: PermSet ps,
<span class="lineno"> 3372 </span>              -- ^ The current primary permissions and permissions stack
<span class="lineno"> 3373 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateVars</span></span></span> :: CruCtx vars,
<span class="lineno"> 3374 </span>              -- ^ The types of all evars in scope
<span class="lineno"> 3375 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStatePSubst</span></span></span> :: PartialSubst vars,
<span class="lineno"> 3376 </span>              -- ^ The partial instantiation of evars in scope
<span class="lineno"> 3377 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStatePVarSubst</span></span></span> :: RAssign (Compose Maybe ExprVar) vars,
<span class="lineno"> 3378 </span>              -- ^ The partial instantiation of evars to fresh variables; used
<span class="lineno"> 3379 </span>              -- by 'proveVarsImplVarEVars' and when evars need have permissions
<span class="lineno"> 3380 </span>              -- proved on them
<span class="lineno"> 3381 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateRecRecurseFlag</span></span></span> :: RecurseFlag,
<span class="lineno"> 3382 </span>              -- ^ Whether we are recursing under a recursive permission, either
<span class="lineno"> 3383 </span>              -- on the left hand or the right hand side
<span class="lineno"> 3384 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStatePermEnv</span></span></span> :: PermEnv,
<span class="lineno"> 3385 </span>              -- ^ The current permission environment
<span class="lineno"> 3386 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStatePPInfo</span></span></span> :: PPInfo,
<span class="lineno"> 3387 </span>              -- ^ Pretty-printing for all variables in scope
<span class="lineno"> 3388 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateNameTypes</span></span></span> :: NameMap TypeRepr,
<span class="lineno"> 3389 </span>              -- ^ Types of all the variables in scope
<span class="lineno"> 3390 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateUnitVar</span></span></span> :: Maybe (ExprVar UnitType),
<span class="lineno"> 3391 </span>              -- ^ A global unit variable that all other unit variables will be
<span class="lineno"> 3392 </span>              -- equal to
<span class="lineno"> 3393 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateEndianness</span></span></span> :: EndianForm,
<span class="lineno"> 3394 </span>              -- ^ The endianness of the current architecture
<span class="lineno"> 3395 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateFailPrefix</span></span></span> :: String,
<span class="lineno"> 3396 </span>              -- ^ A prefix string to prepend to any failure messages
<span class="lineno"> 3397 </span>              <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_implStateDebugLevel</span></span></span> :: DebugLevel
<span class="lineno"> 3398 </span>              -- ^ Whether tracing is turned on or not
<span class="lineno"> 3399 </span>            }
<span class="lineno"> 3400 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''ImplState</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 3401 </span>
<span class="lineno"> 3402 </span>mkImplState :: CruCtx vars -&gt; PermSet ps -&gt; PermEnv -&gt;
<span class="lineno"> 3403 </span>               PPInfo -&gt; String -&gt; DebugLevel -&gt;
<span class="lineno"> 3404 </span>               NameMap TypeRepr -&gt; Maybe (ExprVar UnitType) -&gt;
<span class="lineno"> 3405 </span>               EndianForm -&gt; ImplState vars ps
<span class="lineno"> 3406 </span><span class="decl"><span class="nottickedoff">mkImplState vars perms env info fail_prefix dlevel nameTypes u endianness =</span>
<span class="lineno"> 3407 </span><span class="spaces">  </span><span class="nottickedoff">ImplState {</span>
<span class="lineno"> 3408 </span><span class="spaces">  </span><span class="nottickedoff">_implStateVars = vars,</span>
<span class="lineno"> 3409 </span><span class="spaces">  </span><span class="nottickedoff">_implStatePerms = perms,</span>
<span class="lineno"> 3410 </span><span class="spaces">  </span><span class="nottickedoff">_implStatePSubst = emptyPSubst $ cruCtxProxies vars,</span>
<span class="lineno"> 3411 </span><span class="spaces">  </span><span class="nottickedoff">_implStatePVarSubst = RL.map (const $ Compose Nothing) (cruCtxProxies vars),</span>
<span class="lineno"> 3412 </span><span class="spaces">  </span><span class="nottickedoff">_implStateRecRecurseFlag = RecNone,</span>
<span class="lineno"> 3413 </span><span class="spaces">  </span><span class="nottickedoff">_implStatePermEnv = env,</span>
<span class="lineno"> 3414 </span><span class="spaces">  </span><span class="nottickedoff">_implStatePPInfo = info,</span>
<span class="lineno"> 3415 </span><span class="spaces">  </span><span class="nottickedoff">_implStateNameTypes = nameTypes,</span>
<span class="lineno"> 3416 </span><span class="spaces">  </span><span class="nottickedoff">_implStateUnitVar = u,</span>
<span class="lineno"> 3417 </span><span class="spaces">  </span><span class="nottickedoff">_implStateEndianness = endianness,</span>
<span class="lineno"> 3418 </span><span class="spaces">  </span><span class="nottickedoff">_implStateFailPrefix = fail_prefix,</span>
<span class="lineno"> 3419 </span><span class="spaces">  </span><span class="nottickedoff">_implStateDebugLevel = dlevel</span>
<span class="lineno"> 3420 </span><span class="spaces">  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 3421 </span>
<span class="lineno"> 3422 </span>extImplState :: TypeRepr tp -&gt; ImplState vars ps -&gt;
<span class="lineno"> 3423 </span>                ImplState (vars :&gt; tp) ps
<span class="lineno"> 3424 </span><span class="decl"><span class="nottickedoff">extImplState tp s =</span>
<span class="lineno"> 3425 </span><span class="spaces">  </span><span class="nottickedoff">s { _implStateVars = CruCtxCons (_implStateVars s) tp,</span>
<span class="lineno"> 3426 </span><span class="spaces">      </span><span class="nottickedoff">_implStatePSubst = extPSubst (_implStatePSubst s),</span>
<span class="lineno"> 3427 </span><span class="spaces">      </span><span class="nottickedoff">_implStatePVarSubst = (_implStatePVarSubst s) :&gt;: Compose Nothing }</span></span>
<span class="lineno"> 3428 </span>
<span class="lineno"> 3429 </span>unextImplState :: ImplState (vars :&gt; a) ps -&gt; ImplState vars ps
<span class="lineno"> 3430 </span><span class="decl"><span class="nottickedoff">unextImplState s =</span>
<span class="lineno"> 3431 </span><span class="spaces">  </span><span class="nottickedoff">s { _implStateVars = unextCruCtx (_implStateVars s),</span>
<span class="lineno"> 3432 </span><span class="spaces">      </span><span class="nottickedoff">_implStatePSubst = unextPSubst (_implStatePSubst s),</span>
<span class="lineno"> 3433 </span><span class="spaces">      </span><span class="nottickedoff">_implStatePVarSubst = RL.tail (_implStatePVarSubst s) }</span></span>
<span class="lineno"> 3434 </span>
<span class="lineno"> 3435 </span>
<span class="lineno"> 3436 </span>-- | The implication monad is a state-continuation monad that uses 'ImplState'
<span class="lineno"> 3437 </span>type ImplM vars s r ps_out ps_in =
<span class="lineno"> 3438 </span>  GenStateContT
<span class="lineno"> 3439 </span>    (ImplState vars ps_out) (PermImpl r ps_out)
<span class="lineno"> 3440 </span>    (ImplState vars ps_in ) (PermImpl r ps_in )
<span class="lineno"> 3441 </span>    (State (Closed s))
<span class="lineno"> 3442 </span>
<span class="lineno"> 3443 </span>-- | Run an 'ImplM' computation by passing it a @vars@ context, a starting
<span class="lineno"> 3444 </span>-- permission set, top-level state, and a continuation to consume the output
<span class="lineno"> 3445 </span>runImplM ::
<span class="lineno"> 3446 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 3447 </span>  CruCtx vars               {- ^ existential variables and their types -} -&gt;
<span class="lineno"> 3448 </span>  PermSet ps_in -&gt;
<span class="lineno"> 3449 </span>  PermEnv                   {- ^ permission environment   -} -&gt;
<span class="lineno"> 3450 </span>  PPInfo                    {- ^ pretty-printer settings  -} -&gt;
<span class="lineno"> 3451 </span>  String                    {- ^ fail prefix              -} -&gt;
<span class="lineno"> 3452 </span>  DebugLevel                {- ^ debug level              -} -&gt;
<span class="lineno"> 3453 </span>  NameMap TypeRepr          {- ^ name types               -} -&gt;
<span class="lineno"> 3454 </span>  Maybe (ExprVar UnitType)  {- ^ optional global unit var -} -&gt;
<span class="lineno"> 3455 </span>  EndianForm                {- ^ endianness               -} -&gt;
<span class="lineno"> 3456 </span>  ImplM vars s r ps_out ps_in a -&gt;
<span class="lineno"> 3457 </span>  ((a, ImplState vars ps_out) -&gt; State (Closed s) (r ps_out)) -&gt;
<span class="lineno"> 3458 </span>  State (Closed s) (PermImpl r ps_in)
<span class="lineno"> 3459 </span><span class="decl"><span class="nottickedoff">runImplM vars perms env ppInfo fail_prefix dlevel nameTypes unitVar endianness m k =</span>
<span class="lineno"> 3460 </span><span class="spaces">  </span><span class="nottickedoff">runGenStateContT</span>
<span class="lineno"> 3461 </span><span class="spaces">    </span><span class="nottickedoff">-- instantiate all unit evars to the global unit variable (with</span>
<span class="lineno"> 3462 </span><span class="spaces">    </span><span class="nottickedoff">-- 'handleUnitEVars') before running m</span>
<span class="lineno"> 3463 </span><span class="spaces">    </span><span class="nottickedoff">(handleUnitEVars &gt;&gt;&gt; m)</span>
<span class="lineno"> 3464 </span><span class="spaces">    </span><span class="nottickedoff">(mkImplState vars perms env ppInfo fail_prefix dlevel nameTypes unitVar endianness)</span>
<span class="lineno"> 3465 </span><span class="spaces">    </span><span class="nottickedoff">(\s a -&gt; PermImpl_Done &lt;$&gt; k (a, s))</span></span>
<span class="lineno"> 3466 </span>
<span class="lineno"> 3467 </span>
<span class="lineno"> 3468 </span>
<span class="lineno"> 3469 </span>-- | Run an 'ImplM' computation that returns a 'PermImpl', by inserting that
<span class="lineno"> 3470 </span>-- 'PermImpl' inside of the larger 'PermImpl' that is built up by the 'ImplM'
<span class="lineno"> 3471 </span>-- computation.
<span class="lineno"> 3472 </span>runImplImplM :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3473 </span>                CruCtx vars -&gt; PermSet ps_in -&gt; PermEnv -&gt; PPInfo -&gt;
<span class="lineno"> 3474 </span>                String -&gt; DebugLevel -&gt; NameMap TypeRepr -&gt;
<span class="lineno"> 3475 </span>                Maybe (ExprVar UnitType) -&gt; EndianForm -&gt;
<span class="lineno"> 3476 </span>                ImplM vars s r ps_out ps_in (PermImpl r ps_out) -&gt;
<span class="lineno"> 3477 </span>                State (Closed s) (PermImpl r ps_in)
<span class="lineno"> 3478 </span><span class="decl"><span class="nottickedoff">runImplImplM vars perms env ppInfo fail_prefix dlevel nameTypes u endianness m =</span>
<span class="lineno"> 3479 </span><span class="spaces">  </span><span class="nottickedoff">runGenStateContT</span>
<span class="lineno"> 3480 </span><span class="spaces">    </span><span class="nottickedoff">-- instantiate all unit evars to the global unit variable (with</span>
<span class="lineno"> 3481 </span><span class="spaces">    </span><span class="nottickedoff">-- 'handleUnitEVars') before running m</span>
<span class="lineno"> 3482 </span><span class="spaces">    </span><span class="nottickedoff">(handleUnitEVars &gt;&gt;&gt; m)</span>
<span class="lineno"> 3483 </span><span class="spaces">    </span><span class="nottickedoff">(mkImplState vars perms env ppInfo fail_prefix dlevel nameTypes u endianness)</span>
<span class="lineno"> 3484 </span><span class="spaces">    </span><span class="nottickedoff">(\_ -&gt; pure)</span></span>
<span class="lineno"> 3485 </span>
<span class="lineno"> 3486 </span>-- | Embed a sub-computation in a name-binding inside another 'ImplM'
<span class="lineno"> 3487 </span>-- computation, throwing away any state from that sub-computation and returning
<span class="lineno"> 3488 </span>-- a 'PermImpl' inside a name-binding
<span class="lineno"> 3489 </span>embedImplM :: NuMatchingAny1 r' =&gt;
<span class="lineno"> 3490 </span>              DistPerms ps_in -&gt;
<span class="lineno"> 3491 </span>              ImplM RNil s r' ps_out ps_in (r' ps_out) -&gt;
<span class="lineno"> 3492 </span>              ImplM vars s r ps ps (PermImpl r' ps_in)
<span class="lineno"> 3493 </span><span class="decl"><span class="nottickedoff">embedImplM ps_in m =</span>
<span class="lineno"> 3494 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \s -&gt;</span>
<span class="lineno"> 3495 </span><span class="spaces">  </span><span class="nottickedoff">lift $</span>
<span class="lineno"> 3496 </span><span class="spaces">  </span><span class="nottickedoff">runImplM CruCtxNil (distPermSet ps_in)</span>
<span class="lineno"> 3497 </span><span class="spaces">  </span><span class="nottickedoff">(view implStatePermEnv    s) (view implStatePPInfo     s)</span>
<span class="lineno"> 3498 </span><span class="spaces">  </span><span class="nottickedoff">(view implStateFailPrefix s) (view implStateDebugLevel s)</span>
<span class="lineno"> 3499 </span><span class="spaces">  </span><span class="nottickedoff">(view implStateNameTypes  s) (view implStateUnitVar    s)</span>
<span class="lineno"> 3500 </span><span class="spaces">  </span><span class="nottickedoff">(view implStateEndianness s) m (pure . fst)</span></span>
<span class="lineno"> 3501 </span>
<span class="lineno"> 3502 </span>-- | Embed a sub-computation in a name-binding inside another 'ImplM'
<span class="lineno"> 3503 </span>-- computation, throwing away any state from that sub-computation and returning
<span class="lineno"> 3504 </span>-- a 'PermImpl' inside a name-binding
<span class="lineno"> 3505 </span>embedMbImplM :: KnownRepr CruCtx ctx =&gt; NuMatchingAny1 r' =&gt;
<span class="lineno"> 3506 </span>                Mb ctx (DistPerms ps_in) -&gt;
<span class="lineno"> 3507 </span>                Mb ctx (ImplM RNil s r' ps_out ps_in (r' ps_out)) -&gt;
<span class="lineno"> 3508 </span>                ImplM vars s r ps ps (Mb ctx (PermImpl r' ps_in))
<span class="lineno"> 3509 </span><span class="decl"><span class="nottickedoff">embedMbImplM mb_ps_in mb_m =</span>
<span class="lineno"> 3510 </span><span class="spaces">  </span><span class="nottickedoff">do s &lt;- get</span>
<span class="lineno"> 3511 </span><span class="spaces">     </span><span class="nottickedoff">lift $ strongMbM $ nuMultiWithElim</span>
<span class="lineno"> 3512 </span><span class="spaces">       </span><span class="nottickedoff">(\ns (_ :&gt;: Identity ps_in :&gt;: Identity m) -&gt;</span>
<span class="lineno"> 3513 </span><span class="spaces">        </span><span class="nottickedoff">runImplM</span>
<span class="lineno"> 3514 </span><span class="spaces">         </span><span class="nottickedoff">CruCtxNil (distPermSet ps_in)</span>
<span class="lineno"> 3515 </span><span class="spaces">         </span><span class="nottickedoff">(view implStatePermEnv    s) (view implStatePPInfo  s)</span>
<span class="lineno"> 3516 </span><span class="spaces">         </span><span class="nottickedoff">(view implStateFailPrefix s) (view implStateDebugLevel s)</span>
<span class="lineno"> 3517 </span><span class="spaces">         </span><span class="nottickedoff">(view implStateNameTypes  s) (view implStateUnitVar s)</span>
<span class="lineno"> 3518 </span><span class="spaces">         </span><span class="nottickedoff">(view implStateEndianness s)</span>
<span class="lineno"> 3519 </span><span class="spaces">         </span><span class="nottickedoff">(gmodify (over implStatePPInfo</span>
<span class="lineno"> 3520 </span><span class="spaces">                   </span><span class="nottickedoff">(ppInfoAddTypedExprNames knownRepr ns)) &gt;&gt;&gt;</span>
<span class="lineno"> 3521 </span><span class="spaces">          </span><span class="nottickedoff">implSetNameTypes ns knownRepr &gt;&gt;&gt;</span>
<span class="lineno"> 3522 </span><span class="spaces">          </span><span class="nottickedoff">m)</span>
<span class="lineno"> 3523 </span><span class="spaces">         </span><span class="nottickedoff">(pure . fst))</span>
<span class="lineno"> 3524 </span><span class="spaces">       </span><span class="nottickedoff">(MNil :&gt;: mb_ps_in :&gt;: mb_m)</span></span>
<span class="lineno"> 3525 </span>
<span class="lineno"> 3526 </span>-- | Run an 'ImplM' computation in a locally-scoped way, where all effects
<span class="lineno"> 3527 </span>-- are restricted to the local computation. This is essentially a form of the
<span class="lineno"> 3528 </span>-- @reset@ operation of delimited continuations.
<span class="lineno"> 3529 </span>--
<span class="lineno"> 3530 </span>-- FIXME: figure out a more general @reset@ combinator...
<span class="lineno"> 3531 </span>localImplM ::
<span class="lineno"> 3532 </span>  ImplM vars s r ps_out ps_in (PermImpl r ps_out) -&gt;
<span class="lineno"> 3533 </span>  ImplM vars s r ps_in ps_in (PermImpl r ps_in)
<span class="lineno"> 3534 </span><span class="decl"><span class="nottickedoff">localImplM m =</span>
<span class="lineno"> 3535 </span><span class="spaces">  </span><span class="nottickedoff">do st &lt;- get</span>
<span class="lineno"> 3536 </span><span class="spaces">     </span><span class="nottickedoff">lift (runGenStateContT m st (\_ -&gt; pure))</span></span>
<span class="lineno"> 3537 </span>
<span class="lineno"> 3538 </span>-- | Look up the type of an existential variable
<span class="lineno"> 3539 </span>getExVarType :: Member vars tp -&gt; ImplM vars s r ps ps (TypeRepr tp)
<span class="lineno"> 3540 </span><span class="decl"><span class="nottickedoff">getExVarType memb =</span>
<span class="lineno"> 3541 </span><span class="spaces">  </span><span class="nottickedoff">do varTypes &lt;- use implStateVars</span>
<span class="lineno"> 3542 </span><span class="spaces">     </span><span class="nottickedoff">pure (cruCtxLookup varTypes memb)</span></span>
<span class="lineno"> 3543 </span>
<span class="lineno"> 3544 </span>-- | Look up the current partial substitution
<span class="lineno"> 3545 </span>getPSubst :: ImplM vars s r ps ps (PartialSubst vars)
<span class="lineno"> 3546 </span><span class="decl"><span class="nottickedoff">getPSubst = use implStatePSubst</span></span>
<span class="lineno"> 3547 </span>
<span class="lineno"> 3548 </span>-- | Get phantom arguments for the current existential variables
<span class="lineno"> 3549 </span>getVarProxies :: ImplM vars s r ps ps (RAssign Proxy vars)
<span class="lineno"> 3550 </span><span class="decl"><span class="nottickedoff">getVarProxies = uses implStateVars cruCtxProxies</span></span>
<span class="lineno"> 3551 </span>
<span class="lineno"> 3552 </span>-- | Add a multi-binding for the current existential variables around a value
<span class="lineno"> 3553 </span>-- (that does not use those variables)
<span class="lineno"> 3554 </span>mbVarsM :: a -&gt; ImplM vars s r ps ps (Mb vars a)
<span class="lineno"> 3555 </span><span class="decl"><span class="nottickedoff">mbVarsM a =</span>
<span class="lineno"> 3556 </span><span class="spaces">  </span><span class="nottickedoff">do px &lt;- getVarProxies</span>
<span class="lineno"> 3557 </span><span class="spaces">     </span><span class="nottickedoff">pure (mbPure px a)</span></span>
<span class="lineno"> 3558 </span>
<span class="lineno"> 3559 </span>-- | Build a multi-binding for the current existential variables using a
<span class="lineno"> 3560 </span>-- function that expects a substitution of these new variables for old copies of
<span class="lineno"> 3561 </span>-- those variables
<span class="lineno"> 3562 </span>mbSubstM :: ((forall a. Substable PermVarSubst a Identity =&gt;
<span class="lineno"> 3563 </span>              Mb vars a -&gt; a) -&gt; b) -&gt;
<span class="lineno"> 3564 </span>            ImplM vars s r ps ps (Mb vars b)
<span class="lineno"> 3565 </span><span class="decl"><span class="nottickedoff">mbSubstM f =</span>
<span class="lineno"> 3566 </span><span class="spaces">  </span><span class="nottickedoff">do vars &lt;- getVarProxies</span>
<span class="lineno"> 3567 </span><span class="spaces">     </span><span class="nottickedoff">return (nuMulti vars $ \ns -&gt;</span>
<span class="lineno"> 3568 </span><span class="spaces">              </span><span class="nottickedoff">f (varSubst $ permVarSubstOfNames ns))</span></span>
<span class="lineno"> 3569 </span>
<span class="lineno"> 3570 </span>-- | Apply the current partial substitution to an expression, failing if the
<span class="lineno"> 3571 </span>-- partial substitution is not complete enough. The supplied 'String' is the
<span class="lineno"> 3572 </span>-- calling function, used for error reporting in the failure.
<span class="lineno"> 3573 </span>partialSubstForceM :: (NuMatchingAny1 r, PermPretty a,
<span class="lineno"> 3574 </span>                       Substable PartialSubst a Maybe) =&gt;
<span class="lineno"> 3575 </span>                      Mb vars a -&gt; String -&gt; ImplM vars s r ps ps a
<span class="lineno"> 3576 </span><span class="decl"><span class="nottickedoff">partialSubstForceM mb_e caller =</span>
<span class="lineno"> 3577 </span><span class="spaces">  </span><span class="nottickedoff">do psubst &lt;- getPSubst</span>
<span class="lineno"> 3578 </span><span class="spaces">     </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 3579 </span><span class="spaces">       </span><span class="nottickedoff">case partialSubst psubst mb_e of</span>
<span class="lineno"> 3580 </span><span class="spaces">         </span><span class="nottickedoff">Just e -&gt; pure e</span>
<span class="lineno"> 3581 </span><span class="spaces">         </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 3582 </span><span class="spaces">           </span><span class="nottickedoff">implFailM $ PartialSubstitutionError caller (permPretty ppinfo mb_e)</span></span>
<span class="lineno"> 3583 </span>
<span class="lineno"> 3584 </span>-- | Modify the current partial substitution
<span class="lineno"> 3585 </span>modifyPSubst :: (PartialSubst vars -&gt; PartialSubst vars) -&gt;
<span class="lineno"> 3586 </span>                ImplM vars s r ps ps ()
<span class="lineno"> 3587 </span><span class="decl"><span class="nottickedoff">modifyPSubst f = implStatePSubst %= f</span></span>
<span class="lineno"> 3588 </span>
<span class="lineno"> 3589 </span>-- | Set the value for an existential variable in the current substitution,
<span class="lineno"> 3590 </span>-- raising an error if it is already set
<span class="lineno"> 3591 </span>setVarM :: Member vars a -&gt; PermExpr a -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3592 </span><span class="decl"><span class="nottickedoff">setVarM memb e =</span>
<span class="lineno"> 3593 </span><span class="spaces">  </span><span class="nottickedoff">do vars &lt;- getVarProxies</span>
<span class="lineno"> 3594 </span><span class="spaces">     </span><span class="nottickedoff">_ &lt;- implTraceM (\i -&gt; pretty &quot;Setting&quot; &lt;+&gt;</span>
<span class="lineno"> 3595 </span><span class="spaces">                       </span><span class="nottickedoff">permPretty i (nuMulti vars $ \ns -&gt; RL.get memb ns) &lt;+&gt;</span>
<span class="lineno"> 3596 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;=&quot; &lt;+&gt; permPretty i e)</span>
<span class="lineno"> 3597 </span><span class="spaces">     </span><span class="nottickedoff">modifyPSubst (psubstSet memb e)</span></span>
<span class="lineno"> 3598 </span>
<span class="lineno"> 3599 </span>-- | Set the value for an existential variable to the zero of its type if it has
<span class="lineno"> 3600 </span>-- not yet been set
<span class="lineno"> 3601 </span>zeroUnsetVarM :: Member vars (a :: CrucibleType) -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3602 </span><span class="decl"><span class="nottickedoff">zeroUnsetVarM memb =</span>
<span class="lineno"> 3603 </span><span class="spaces">  </span><span class="nottickedoff">do tp &lt;- RL.get memb &lt;$&gt; cruCtxToTypes &lt;$&gt; use implStateVars</span>
<span class="lineno"> 3604 </span><span class="spaces">     </span><span class="nottickedoff">setVarM memb (zeroOfType tp)</span></span>
<span class="lineno"> 3605 </span>
<span class="lineno"> 3606 </span>-- | Get a free variable that is provably equal to the value of an existential
<span class="lineno"> 3607 </span>-- variable, let-binding a fresh variable if the evar is instantiated with a
<span class="lineno"> 3608 </span>-- non-variable expression. It is an error if the evar has no instantiation in
<span class="lineno"> 3609 </span>-- the current partial substitution.
<span class="lineno"> 3610 </span>getVarVarM :: NuMatchingAny1 r =&gt; Member vars a -&gt;
<span class="lineno"> 3611 </span>              ImplM vars s r ps ps (ExprVar a)
<span class="lineno"> 3612 </span><span class="decl"><span class="nottickedoff">getVarVarM memb =</span>
<span class="lineno"> 3613 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 3614 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePVarSubst &gt;&gt;&gt;= \pvsubst -&gt;</span>
<span class="lineno"> 3615 </span><span class="spaces">  </span><span class="nottickedoff">case (RL.get memb pvsubst, psubstLookup psubst memb) of</span>
<span class="lineno"> 3616 </span><span class="spaces">    </span><span class="nottickedoff">(Compose (Just n), Just _) -&gt; pure n</span>
<span class="lineno"> 3617 </span><span class="spaces">    </span><span class="nottickedoff">(Compose (Just n), Nothing) -&gt;</span>
<span class="lineno"> 3618 </span><span class="spaces">      </span><span class="nottickedoff">setVarM memb (PExpr_Var n) &gt;&gt;&gt; pure n</span>
<span class="lineno"> 3619 </span><span class="spaces">    </span><span class="nottickedoff">(_, Just e) -&gt;</span>
<span class="lineno"> 3620 </span><span class="spaces">      </span><span class="nottickedoff">getExVarType memb &gt;&gt;&gt;= \tp -&gt;</span>
<span class="lineno"> 3621 </span><span class="spaces">      </span><span class="nottickedoff">implLetBindVar tp e &gt;&gt;&gt;= \n -&gt;</span>
<span class="lineno"> 3622 </span><span class="spaces">      </span><span class="nottickedoff">implStatePVarSubst %= RL.set memb (Compose (Just n)) &gt;&gt;&gt;</span>
<span class="lineno"> 3623 </span><span class="spaces">      </span><span class="nottickedoff">pure n</span>
<span class="lineno"> 3624 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;getVarVarM&quot;</span></span>
<span class="lineno"> 3625 </span>
<span class="lineno"> 3626 </span>
<span class="lineno"> 3627 </span>-- | Run an implication computation with one more existential variable,
<span class="lineno"> 3628 </span>-- returning the optional expression it was bound to in the current partial
<span class="lineno"> 3629 </span>-- substitution when it is done
<span class="lineno"> 3630 </span>withExtVarsM' :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3631 </span>                 TypeRepr tp -&gt; ImplM (vars :&gt; tp) s r ps1 ps2 a -&gt;
<span class="lineno"> 3632 </span>                 ImplM vars s r ps1 ps2 (a, PermExpr tp)
<span class="lineno"> 3633 </span><span class="decl"><span class="nottickedoff">withExtVarsM' tp m =</span>
<span class="lineno"> 3634 </span><span class="spaces">  </span><span class="nottickedoff">-- Add a new existential to the 'ImplState'</span>
<span class="lineno"> 3635 </span><span class="spaces">  </span><span class="nottickedoff">gmodify (extImplState tp)  &gt;&gt;&gt;</span>
<span class="lineno"> 3636 </span><span class="spaces">  </span><span class="nottickedoff">-- If the new existential has type unit, instantiate it to the global unit</span>
<span class="lineno"> 3637 </span><span class="spaces">  </span><span class="nottickedoff">handleUnitEVar Member_Base &gt;&gt;&gt;</span>
<span class="lineno"> 3638 </span><span class="spaces">  </span><span class="nottickedoff">-- Run the computation</span>
<span class="lineno"> 3639 </span><span class="spaces">  </span><span class="nottickedoff">m                          &gt;&gt;&gt;= \a -&gt;</span>
<span class="lineno"> 3640 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst                  &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 3641 </span><span class="spaces">  </span><span class="nottickedoff">-- Remove the existential after it has been instantiated</span>
<span class="lineno"> 3642 </span><span class="spaces">  </span><span class="nottickedoff">gmodify unextImplState     &gt;&gt;&gt;</span>
<span class="lineno"> 3643 </span><span class="spaces">  </span><span class="nottickedoff">pure (a, case psubstLookup psubst Member_Base of</span>
<span class="lineno"> 3644 </span><span class="spaces">             </span><span class="nottickedoff">Just e -&gt; e</span>
<span class="lineno"> 3645 </span><span class="spaces">             </span><span class="nottickedoff">Nothing -&gt; zeroOfType tp)</span></span>
<span class="lineno"> 3646 </span>
<span class="lineno"> 3647 </span>-- | Run an implication computation with one more existential variable,
<span class="lineno"> 3648 </span>-- returning the optional expression it was bound to in the current partial
<span class="lineno"> 3649 </span>-- substitution when it is done
<span class="lineno"> 3650 </span>withExtVarsM :: KnownRepr TypeRepr tp =&gt;
<span class="lineno"> 3651 </span>                NuMatchingAny1 r =&gt;
<span class="lineno"> 3652 </span>                ImplM (vars :&gt; tp) s r ps1 ps2 a -&gt;
<span class="lineno"> 3653 </span>                ImplM vars s r ps1 ps2 (a, PermExpr tp)
<span class="lineno"> 3654 </span><span class="decl"><span class="nottickedoff">withExtVarsM = withExtVarsM' knownRepr</span></span>
<span class="lineno"> 3655 </span>
<span class="lineno"> 3656 </span>-- | Run an implication computation with an additional context of existential
<span class="lineno"> 3657 </span>-- variables
<span class="lineno"> 3658 </span>withExtVarsMultiM :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3659 </span>                     CruCtx vars' -&gt;
<span class="lineno"> 3660 </span>                     ImplM (vars :++: vars') s r ps1 ps2 a -&gt;
<span class="lineno"> 3661 </span>                     ImplM vars s r ps1 ps2 a
<span class="lineno"> 3662 </span><span class="decl"><span class="nottickedoff">withExtVarsMultiM CruCtxNil m = m</span>
<span class="lineno"> 3663 </span><span class="spaces"></span><span class="nottickedoff">withExtVarsMultiM (CruCtxCons ctx tp) m =</span>
<span class="lineno"> 3664 </span><span class="spaces">  </span><span class="nottickedoff">withExtVarsMultiM ctx (withExtVarsM' tp m &gt;&gt;&gt;= \(a,_) -&gt; return a)</span></span>
<span class="lineno"> 3665 </span>
<span class="lineno"> 3666 </span>-- | Perform either the first, second, or both computations with an 'implCatchM'
<span class="lineno"> 3667 </span>-- between, depending on the recursion flag. The 'String' names the function
<span class="lineno"> 3668 </span>-- that is calling 'implCatchM', while the @p@ argument states what we are
<span class="lineno"> 3669 </span>-- trying to prove; both of these are used for debug tracing.
<span class="lineno"> 3670 </span>implRecFlagCaseM :: NuMatchingAny1 r =&gt; PermPretty p =&gt; String -&gt; p -&gt;
<span class="lineno"> 3671 </span>                    ImplM vars s r ps_out ps_in a -&gt;
<span class="lineno"> 3672 </span>                    ImplM vars s r ps_out ps_in a -&gt;
<span class="lineno"> 3673 </span>                    ImplM vars s r ps_out ps_in a
<span class="lineno"> 3674 </span><span class="decl"><span class="nottickedoff">implRecFlagCaseM f p m1 m2 =</span>
<span class="lineno"> 3675 </span><span class="spaces">  </span><span class="nottickedoff">use implStateRecRecurseFlag &gt;&gt;&gt;= \case</span>
<span class="lineno"> 3676 </span><span class="spaces">    </span><span class="nottickedoff">RecLeft  -&gt; m1</span>
<span class="lineno"> 3677 </span><span class="spaces">    </span><span class="nottickedoff">RecRight -&gt; m2</span>
<span class="lineno"> 3678 </span><span class="spaces">    </span><span class="nottickedoff">RecNone  -&gt; implCatchM f p m1 m2</span></span>
<span class="lineno"> 3679 </span>
<span class="lineno"> 3680 </span>-- | Set the recursive permission recursion flag to indicate recursion on the
<span class="lineno"> 3681 </span>-- right, or fail if we are already recursing on the left
<span class="lineno"> 3682 </span>implSetRecRecurseRightM :: NuMatchingAny1 r =&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3683 </span><span class="decl"><span class="nottickedoff">implSetRecRecurseRightM =</span>
<span class="lineno"> 3684 </span><span class="spaces">  </span><span class="nottickedoff">use implStateRecRecurseFlag &gt;&gt;= \case</span>
<span class="lineno"> 3685 </span><span class="spaces">    </span><span class="nottickedoff">RecLeft -&gt; implFailM MuUnfoldError</span>
<span class="lineno"> 3686 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; implStateRecRecurseFlag .= RecRight</span></span>
<span class="lineno"> 3687 </span>
<span class="lineno"> 3688 </span>-- | Set the recursive recursion flag to indicate recursion on the left, or fail
<span class="lineno"> 3689 </span>-- if we are already recursing on the right
<span class="lineno"> 3690 </span>implSetRecRecurseLeftM :: NuMatchingAny1 r =&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3691 </span><span class="decl"><span class="nottickedoff">implSetRecRecurseLeftM =</span>
<span class="lineno"> 3692 </span><span class="spaces">  </span><span class="nottickedoff">use implStateRecRecurseFlag &gt;&gt;= \case</span>
<span class="lineno"> 3693 </span><span class="spaces">    </span><span class="nottickedoff">RecRight -&gt;</span>
<span class="lineno"> 3694 </span><span class="spaces">      </span><span class="nottickedoff">implFailM MuUnfoldError</span>
<span class="lineno"> 3695 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; implStateRecRecurseFlag .= RecLeft</span></span>
<span class="lineno"> 3696 </span>
<span class="lineno"> 3697 </span>-- | Look up the 'NamedPerm' structure for a named permssion
<span class="lineno"> 3698 </span>implLookupNamedPerm :: NamedPermName ns args a -&gt;
<span class="lineno"> 3699 </span>                       ImplM vars s r ps ps (NamedPerm ns args a)
<span class="lineno"> 3700 </span><span class="decl"><span class="nottickedoff">implLookupNamedPerm npn =</span>
<span class="lineno"> 3701 </span><span class="spaces">  </span><span class="nottickedoff">(view implStatePermEnv &lt;$&gt; get) &gt;&gt;&gt;= \env -&gt;</span>
<span class="lineno"> 3702 </span><span class="spaces">  </span><span class="nottickedoff">case lookupNamedPerm env npn of</span>
<span class="lineno"> 3703 </span><span class="spaces">    </span><span class="nottickedoff">Just np -&gt; pure np</span>
<span class="lineno"> 3704 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; error (&quot;Named permission &quot; ++ namedPermNameName npn</span>
<span class="lineno"> 3705 </span><span class="spaces">                      </span><span class="nottickedoff">++ &quot; not defined!&quot;)</span></span>
<span class="lineno"> 3706 </span>
<span class="lineno"> 3707 </span>-- | Get the current 'PermSet'
<span class="lineno"> 3708 </span>getPerms :: ImplM vars s r ps ps (PermSet ps)
<span class="lineno"> 3709 </span><span class="decl"><span class="nottickedoff">getPerms = use implStatePerms</span></span>
<span class="lineno"> 3710 </span>
<span class="lineno"> 3711 </span>-- | Look up the current permission for a given variable
<span class="lineno"> 3712 </span>getPerm :: ExprVar a -&gt; ImplM vars s r ps ps (ValuePerm a)
<span class="lineno"> 3713 </span><span class="decl"><span class="nottickedoff">getPerm x = use (implStatePerms . varPerm x)</span></span>
<span class="lineno"> 3714 </span>
<span class="lineno"> 3715 </span>-- | Look up the current permission for a given variable, assuming it has a
<span class="lineno"> 3716 </span>-- conjunctive permissions, and return the conjuncts
<span class="lineno"> 3717 </span>getAtomicPerms :: ExprVar a -&gt; ImplM vars s r ps ps [AtomicPerm a]
<span class="lineno"> 3718 </span><span class="decl"><span class="nottickedoff">getAtomicPerms x = getPerm x &gt;&gt;= \case</span>
<span class="lineno"> 3719 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj ps -&gt; return ps</span>
<span class="lineno"> 3720 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;getAtomicPerms: non-conjunctive permission&quot;</span></span>
<span class="lineno"> 3721 </span>
<span class="lineno"> 3722 </span>-- | Get the distinguished permission stack
<span class="lineno"> 3723 </span>getDistPerms :: ImplM vars s r ps ps (DistPerms ps)
<span class="lineno"> 3724 </span><span class="decl"><span class="nottickedoff">getDistPerms = use (implStatePerms . distPerms)</span></span>
<span class="lineno"> 3725 </span>
<span class="lineno"> 3726 </span>-- | Get ghost arguments to represent the current stack at the type level
<span class="lineno"> 3727 </span>getDistPermsProxies :: ImplM vars s r ps ps (RAssign Proxy ps)
<span class="lineno"> 3728 </span><span class="decl"><span class="nottickedoff">getDistPermsProxies = rlToProxies &lt;$&gt; getDistPerms</span></span>
<span class="lineno"> 3729 </span>
<span class="lineno"> 3730 </span>-- | Get the top permission in the stack
<span class="lineno"> 3731 </span>getTopDistPerm :: ExprVar a -&gt; ImplM vars s r (ps :&gt; a) (ps :&gt; a) (ValuePerm a)
<span class="lineno"> 3732 </span><span class="decl"><span class="nottickedoff">getTopDistPerm x = use (implStatePerms . topDistPerm x)</span></span>
<span class="lineno"> 3733 </span>
<span class="lineno"> 3734 </span>-- | Get the top permission in the stack, which is expected to be a conjuction,
<span class="lineno"> 3735 </span>-- and return its conjuncts. If it is not a conjunction, raise an 'error', using
<span class="lineno"> 3736 </span>-- the supplied 'String' as the caller in the error message.
<span class="lineno"> 3737 </span>getTopDistConj :: HasCallStack =&gt;
<span class="lineno"> 3738 </span>                  String -&gt; ExprVar a -&gt;
<span class="lineno"> 3739 </span>                  ImplM vars s r (ps :&gt; a) (ps :&gt; a) [AtomicPerm a]
<span class="lineno"> 3740 </span><span class="decl"><span class="nottickedoff">getTopDistConj caller x =</span>
<span class="lineno"> 3741 </span><span class="spaces">  </span><span class="nottickedoff">use (implStatePerms . topDistPerm x) &gt;&gt;&gt;= \case</span>
<span class="lineno"> 3742 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Conj ps -&gt; return ps</span>
<span class="lineno"> 3743 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error (caller ++ &quot;: unexpected non-conjunctive permission&quot;)</span></span>
<span class="lineno"> 3744 </span>
<span class="lineno"> 3745 </span>-- | Get a sequence of the top @N@ permissions on the stack
<span class="lineno"> 3746 </span>getTopDistPerms :: prx1 ps1 -&gt; RAssign prx2 ps2 -&gt;
<span class="lineno"> 3747 </span>                   ImplM vars s r (ps1 :++: ps2) (ps1 :++: ps2) (DistPerms ps2)
<span class="lineno"> 3748 </span><span class="decl"><span class="nottickedoff">getTopDistPerms ps1 ps2 = snd &lt;$&gt; RL.split ps1 ps2 &lt;$&gt; getDistPerms</span></span>
<span class="lineno"> 3749 </span>
<span class="lineno"> 3750 </span>-- | Find all @lowned@ permissions held in in the variable permissions
<span class="lineno"> 3751 </span>implFindLOwnedPerms :: ImplM vars s r ps ps [(ExprVar LifetimeType,
<span class="lineno"> 3752 </span>                                              ValuePerm LifetimeType)]
<span class="lineno"> 3753 </span><span class="decl"><span class="nottickedoff">implFindLOwnedPerms =</span>
<span class="lineno"> 3754 </span><span class="spaces">  </span><span class="nottickedoff">mapMaybe (\case NameAndElem l p@(ValPerm_LOwned _ _ _ _ _) -&gt; Just (l,p)</span>
<span class="lineno"> 3755 </span><span class="spaces">                  </span><span class="nottickedoff">NameAndElem l p@(ValPerm_LOwnedSimple _ _) -&gt; Just (l,p)</span>
<span class="lineno"> 3756 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; Nothing) &lt;$&gt;</span>
<span class="lineno"> 3757 </span><span class="spaces">  </span><span class="nottickedoff">NameMap.assocs &lt;$&gt; view varPermMap &lt;$&gt; getPerms</span></span>
<span class="lineno"> 3758 </span>
<span class="lineno"> 3759 </span>-- | Find all lifetimes contained in a lifetime @l@, including itself
<span class="lineno"> 3760 </span>containedLifetimes :: ExprVar LifetimeType -&gt;
<span class="lineno"> 3761 </span>                      ImplM vars s r ps ps [ExprVar LifetimeType]
<span class="lineno"> 3762 </span><span class="decl"><span class="nottickedoff">containedLifetimes orig_l = execStateT (helper $ PExpr_Var orig_l) [] where</span>
<span class="lineno"> 3763 </span><span class="spaces">  </span><span class="nottickedoff">helper :: PermExpr LifetimeType -&gt;</span>
<span class="lineno"> 3764 </span><span class="spaces">            </span><span class="nottickedoff">StateT [ExprVar LifetimeType] (ImplM vars s r ps ps) ()</span>
<span class="lineno"> 3765 </span><span class="spaces">  </span><span class="nottickedoff">helper PExpr_Always = return ()</span>
<span class="lineno"> 3766 </span><span class="spaces">  </span><span class="nottickedoff">helper (PExpr_Var l) =</span>
<span class="lineno"> 3767 </span><span class="spaces">    </span><span class="nottickedoff">do prevs &lt;- get</span>
<span class="lineno"> 3768 </span><span class="spaces">       </span><span class="nottickedoff">if elem l prevs then return () else</span>
<span class="lineno"> 3769 </span><span class="spaces">         </span><span class="nottickedoff">put (l : prevs) &gt;&gt;</span>
<span class="lineno"> 3770 </span><span class="spaces">         </span><span class="nottickedoff">(lift $ getPerm l) &gt;&gt;= \case</span>
<span class="lineno"> 3771 </span><span class="spaces">         </span><span class="nottickedoff">ValPerm_Conj ps -&gt;</span>
<span class="lineno"> 3772 </span><span class="spaces">           </span><span class="nottickedoff">forM_ ps $ \case</span>
<span class="lineno"> 3773 </span><span class="spaces">           </span><span class="nottickedoff">Perm_LCurrent l' -&gt; helper l'</span>
<span class="lineno"> 3774 </span><span class="spaces">           </span><span class="nottickedoff">Perm_LOwned ls _ _ _ _ -&gt; mapM_ helper ls</span>
<span class="lineno"> 3775 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; return ()</span>
<span class="lineno"> 3776 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; return ()</span></span>
<span class="lineno"> 3777 </span>
<span class="lineno"> 3778 </span>-- | Instantiate the current @implStateUnitVar@ with the given @ExprVar@ of type
<span class="lineno"> 3779 </span>-- @UnitType@
<span class="lineno"> 3780 </span>setUnitImplM :: Maybe (ExprVar UnitType) -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3781 </span><span class="decl"><span class="nottickedoff">setUnitImplM e = do st &lt;- get</span>
<span class="lineno"> 3782 </span><span class="spaces">                    </span><span class="nottickedoff">put st{ _implStateUnitVar = e }</span></span>
<span class="lineno"> 3783 </span>
<span class="lineno"> 3784 </span>getUnitImplM :: ImplM vars s r ps ps (Maybe (ExprVar UnitType))
<span class="lineno"> 3785 </span><span class="decl"><span class="nottickedoff">getUnitImplM = do st &lt;- get</span>
<span class="lineno"> 3786 </span><span class="spaces">                  </span><span class="nottickedoff">return $ _implStateUnitVar st</span></span>
<span class="lineno"> 3787 </span>
<span class="lineno"> 3788 </span>-- | If the global unit varaible is not yet set, generate a fresh name and set
<span class="lineno"> 3789 </span>-- it
<span class="lineno"> 3790 </span>ensureUnitImplM :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3791 </span>                   ImplM vars s r ps ps (ExprVar UnitType)
<span class="lineno"> 3792 </span><span class="decl"><span class="nottickedoff">ensureUnitImplM =</span>
<span class="lineno"> 3793 </span><span class="spaces">  </span><span class="nottickedoff">getUnitImplM &gt;&gt;&gt;= \maybe_u -&gt;</span>
<span class="lineno"> 3794 </span><span class="spaces">  </span><span class="nottickedoff">case maybe_u of</span>
<span class="lineno"> 3795 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; implIntroUnitVar &gt;&gt;&gt;= \n -&gt;</span>
<span class="lineno"> 3796 </span><span class="spaces">               </span><span class="nottickedoff">setUnitImplM (Just n) &gt;&gt;&gt;</span>
<span class="lineno"> 3797 </span><span class="spaces">               </span><span class="nottickedoff">pure n</span>
<span class="lineno"> 3798 </span><span class="spaces">    </span><span class="nottickedoff">Just u  -&gt; pure u</span></span>
<span class="lineno"> 3799 </span>
<span class="lineno"> 3800 </span>-- | Look up the type of a free variable
<span class="lineno"> 3801 </span>implGetVarType :: Name a -&gt; ImplM vars s r ps ps (TypeRepr a)
<span class="lineno"> 3802 </span><span class="decl"><span class="nottickedoff">implGetVarType n =</span>
<span class="lineno"> 3803 </span><span class="spaces">  </span><span class="nottickedoff">do varTypes &lt;- use implStateNameTypes</span>
<span class="lineno"> 3804 </span><span class="spaces">     </span><span class="nottickedoff">case NameMap.lookup n varTypes of</span>
<span class="lineno"> 3805 </span><span class="spaces">       </span><span class="nottickedoff">Just tp -&gt; pure tp</span>
<span class="lineno"> 3806 </span><span class="spaces">       </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 3807 </span><span class="spaces">         </span><span class="nottickedoff">implTraceM (\i -&gt; pretty &quot;Could not find type for variable:&quot; &lt;+&gt;</span>
<span class="lineno"> 3808 </span><span class="spaces">                           </span><span class="nottickedoff">permPretty i n) &gt;&gt;&gt;</span>
<span class="lineno"> 3809 </span><span class="spaces">         </span><span class="nottickedoff">error &quot;implGetVarType&quot;</span></span>
<span class="lineno"> 3810 </span>
<span class="lineno"> 3811 </span>-- | Look up the types of a list of free variables
<span class="lineno"> 3812 </span>implGetVarTypes :: RAssign Name a -&gt; ImplM vars s r ps ps (CruCtx a)
<span class="lineno"> 3813 </span><span class="decl"><span class="nottickedoff">implGetVarTypes MNil = pure CruCtxNil</span>
<span class="lineno"> 3814 </span><span class="spaces"></span><span class="nottickedoff">implGetVarTypes (xs :&gt;: x) =</span>
<span class="lineno"> 3815 </span><span class="spaces">  </span><span class="nottickedoff">CruCtxCons &lt;$&gt; implGetVarTypes xs &lt;*&gt; implGetVarType x</span></span>
<span class="lineno"> 3816 </span>
<span class="lineno"> 3817 </span>-- | Find the first variable of a specific type
<span class="lineno"> 3818 </span>implFindVarOfType :: TypeRepr a -&gt; ImplM vars s r ps ps (Maybe (Name a))
<span class="lineno"> 3819 </span><span class="decl"><span class="nottickedoff">implFindVarOfType tp =</span>
<span class="lineno"> 3820 </span><span class="spaces">  </span><span class="nottickedoff">do varTypes &lt;- use implStateNameTypes</span>
<span class="lineno"> 3821 </span><span class="spaces">     </span><span class="nottickedoff">pure (foldr (\(NameAndElem n tp') rest -&gt;</span>
<span class="lineno"> 3822 </span><span class="spaces">                     </span><span class="nottickedoff">case testEquality tp tp' of</span>
<span class="lineno"> 3823 </span><span class="spaces">                       </span><span class="nottickedoff">Just Refl -&gt; return n</span>
<span class="lineno"> 3824 </span><span class="spaces">                       </span><span class="nottickedoff">Nothing -&gt; rest) Nothing</span>
<span class="lineno"> 3825 </span><span class="spaces">             </span><span class="nottickedoff">(NameMap.assocs varTypes))</span></span>
<span class="lineno"> 3826 </span>
<span class="lineno"> 3827 </span>-- | Remember the types associated with a list of 'Name's, and also ensure those
<span class="lineno"> 3828 </span>-- names have permissions
<span class="lineno"> 3829 </span>implSetNameTypes :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3830 </span>                    RAssign Name ctx -&gt; CruCtx ctx -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3831 </span><span class="decl"><span class="nottickedoff">implSetNameTypes MNil _ = pure ()</span>
<span class="lineno"> 3832 </span><span class="spaces"></span><span class="nottickedoff">implSetNameTypes (ns :&gt;: n) (CruCtxCons tps tp) =</span>
<span class="lineno"> 3833 </span><span class="spaces">  </span><span class="nottickedoff">do implStateNameTypes %= NameMap.insert n tp</span>
<span class="lineno"> 3834 </span><span class="spaces">     </span><span class="nottickedoff">implStatePerms     %= initVarPerm n</span>
<span class="lineno"> 3835 </span><span class="spaces">     </span><span class="nottickedoff">handleUnitVar tp n</span>
<span class="lineno"> 3836 </span><span class="spaces">     </span><span class="nottickedoff">implSetNameTypes ns tps</span></span>
<span class="lineno"> 3837 </span>
<span class="lineno"> 3838 </span>-- | TODO: Move this in to Hobbits
<span class="lineno"> 3839 </span>nameMapFind
<span class="lineno"> 3840 </span>  :: (forall tp. f tp -&gt; Bool)
<span class="lineno"> 3841 </span>  -&gt; NameMap f
<span class="lineno"> 3842 </span>  -&gt; Maybe (Some (Product Name f))
<span class="lineno"> 3843 </span><span class="decl"><span class="nottickedoff">nameMapFind predicate nm =</span>
<span class="lineno"> 3844 </span><span class="spaces">  </span><span class="nottickedoff">case find (\(NameAndElem _ f) -&gt; predicate f) $ NameMap.assocs nm of</span>
<span class="lineno"> 3845 </span><span class="spaces">    </span><span class="nottickedoff">Just (NameAndElem name f) -&gt; Just $ Some $ Pair name f</span>
<span class="lineno"> 3846 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 3847 </span>
<span class="lineno"> 3848 </span>-- | Traverse a permissions to determine whether it refers to a particular variable.
<span class="lineno"> 3849 </span>permContainsVar :: ExprVar a -&gt; ValuePerm b -&gt; Bool
<span class="lineno"> 3850 </span><span class="decl"><span class="nottickedoff">permContainsVar x p = NameSet.member x (freeVars p)</span></span>
<span class="lineno"> 3851 </span>
<span class="lineno"> 3852 </span>-- | Build a 'DistPerms' sequence of a permission @y1:p1@ we currently hold such
<span class="lineno"> 3853 </span>-- that @p1@ contains @x@, a permission @y2:p2@ we currently hold such that @p2@
<span class="lineno"> 3854 </span>-- contains @p1@, etc.
<span class="lineno"> 3855 </span>--
<span class="lineno"> 3856 </span>-- FIXME: what is the purpose of this? Don't we want all permissions recursively
<span class="lineno"> 3857 </span>-- containing @x@?
<span class="lineno"> 3858 </span>findPermsContainingVar :: ExprVar tp -&gt; ImplM vars s r ps ps (Some DistPerms)
<span class="lineno"> 3859 </span><span class="decl"><span class="nottickedoff">findPermsContainingVar x =</span>
<span class="lineno"> 3860 </span><span class="spaces">  </span><span class="nottickedoff">getPerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 3861 </span><span class="spaces">    </span><span class="nottickedoff">case nameMapFind (permContainsVar x) (view varPermMap perms) of</span>
<span class="lineno"> 3862 </span><span class="spaces">      </span><span class="nottickedoff">Just (Some (Pair y p)) -&gt; findPermsContainingVar y &gt;&gt;&gt;= \(Some dps) -&gt;</span>
<span class="lineno"> 3863 </span><span class="spaces">        </span><span class="nottickedoff">return $ Some $ DistPermsCons dps y p</span>
<span class="lineno"> 3864 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt; return $ Some DistPermsNil</span></span>
<span class="lineno"> 3865 </span>
<span class="lineno"> 3866 </span>-- | When adding a new existential unit-typed variable, instantiate it with the
<span class="lineno"> 3867 </span>-- underlying global unit if available; if not, update the global unit variable
<span class="lineno"> 3868 </span>-- with a fresh variable
<span class="lineno"> 3869 </span>handleUnitEVar :: forall (a :: CrucibleType) vars s r ps.
<span class="lineno"> 3870 </span>                  NuMatchingAny1 r =&gt;
<span class="lineno"> 3871 </span>                  Member vars a -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3872 </span>-- Note: this only works in ImplM monad, not necessarily in TypedCrucible
<span class="lineno"> 3873 </span><span class="decl"><span class="nottickedoff">handleUnitEVar mem =</span>
<span class="lineno"> 3874 </span><span class="spaces">  </span><span class="nottickedoff">use implStateVars &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 3875 </span><span class="spaces">  </span><span class="nottickedoff">case cruCtxLookup vars mem of</span>
<span class="lineno"> 3876 </span><span class="spaces">    </span><span class="nottickedoff">UnitRepr -&gt; -- get the global unit variable</span>
<span class="lineno"> 3877 </span><span class="spaces">                </span><span class="nottickedoff">ensureUnitImplM &gt;&gt;&gt;= \u -&gt;</span>
<span class="lineno"> 3878 </span><span class="spaces">                </span><span class="nottickedoff">-- add the binding mem |-&gt; u to implStatePSubst</span>
<span class="lineno"> 3879 </span><span class="spaces">                </span><span class="nottickedoff">-- will fail if mem already is instantiated in implStatePSubst</span>
<span class="lineno"> 3880 </span><span class="spaces">                </span><span class="nottickedoff">modifyPSubst (psubstSet mem (PExpr_Var u))</span>
<span class="lineno"> 3881 </span><span class="spaces">    </span><span class="nottickedoff">_        -&gt; -- non-unit variables</span>
<span class="lineno"> 3882 </span><span class="spaces">                </span><span class="nottickedoff">pure ()</span></span>
<span class="lineno"> 3883 </span>
<span class="lineno"> 3884 </span>-- | Call handleUnitEVar on every existential variable in @vars@. Note that this
<span class="lineno"> 3885 </span>-- will fail if called more than once on overlapping sets of @vars@.
<span class="lineno"> 3886 </span>handleUnitEVars :: forall vars s r ps.
<span class="lineno"> 3887 </span>                   NuMatchingAny1 r =&gt;
<span class="lineno"> 3888 </span>                   ImplM vars s r ps ps ()
<span class="lineno"> 3889 </span>-- look up current cructx, then call handleUnitEVar for each member proof
<span class="lineno"> 3890 </span>-- RL.members (CruCtxProxies vars)
<span class="lineno"> 3891 </span><span class="decl"><span class="nottickedoff">handleUnitEVars =</span>
<span class="lineno"> 3892 </span><span class="spaces">    </span><span class="nottickedoff">use implStateVars &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 3893 </span><span class="spaces">    </span><span class="nottickedoff">let mems :: RAssign (Member vars) vars</span>
<span class="lineno"> 3894 </span><span class="spaces">        </span><span class="nottickedoff">-- get the memberships of all variables</span>
<span class="lineno"> 3895 </span><span class="spaces">        </span><span class="nottickedoff">mems = RL.members (cruCtxProxies vars)</span>
<span class="lineno"> 3896 </span><span class="spaces">    </span><span class="nottickedoff">-- call handleUnitEVar on each variable</span>
<span class="lineno"> 3897 </span><span class="spaces">    </span><span class="nottickedoff">in RL.foldr handleUnitEVarM (pure ()) mems</span>
<span class="lineno"> 3898 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 3899 </span><span class="spaces">    </span><span class="nottickedoff">handleUnitEVarM :: forall (a :: CrucibleType).</span>
<span class="lineno"> 3900 </span><span class="spaces">                       </span><span class="nottickedoff">Member vars a -&gt;</span>
<span class="lineno"> 3901 </span><span class="spaces">                       </span><span class="nottickedoff">ImplM vars s r ps ps () -&gt;</span>
<span class="lineno"> 3902 </span><span class="spaces">                       </span><span class="nottickedoff">ImplM vars s r ps ps ()</span>
<span class="lineno"> 3903 </span><span class="spaces">    </span><span class="nottickedoff">handleUnitEVarM mem m = handleUnitEVar mem &gt;&gt;&gt; m</span></span>
<span class="lineno"> 3904 </span>
<span class="lineno"> 3905 </span>-- | When adding a new universal unit-typed variable, unify with the underlying
<span class="lineno"> 3906 </span>-- global unit if available, and if not, update the global unit variable with
<span class="lineno"> 3907 </span>-- the variable provided
<span class="lineno"> 3908 </span>handleUnitVar :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3909 </span>                 TypeRepr a -&gt; ExprVar a -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3910 </span><span class="decl"><span class="nottickedoff">handleUnitVar UnitRepr n =</span>
<span class="lineno"> 3911 </span><span class="spaces">  </span><span class="nottickedoff">-- When introducing a new unit-typed variable, check whether we have a global</span>
<span class="lineno"> 3912 </span><span class="spaces">  </span><span class="nottickedoff">-- unit variable in the current @ImplState@</span>
<span class="lineno"> 3913 </span><span class="spaces">  </span><span class="nottickedoff">getUnitImplM &gt;&gt;= \u -&gt; case u of</span>
<span class="lineno"> 3914 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 3915 </span><span class="spaces">      </span><span class="nottickedoff">-- If not, initialize the state with the current variable</span>
<span class="lineno"> 3916 </span><span class="spaces">      </span><span class="nottickedoff">setUnitImplM (Just n)</span>
<span class="lineno"> 3917 </span><span class="spaces">    </span><span class="nottickedoff">Just x | x == n -&gt;</span>
<span class="lineno"> 3918 </span><span class="spaces">      </span><span class="nottickedoff">-- If n is equal to the global unit, do nothing</span>
<span class="lineno"> 3919 </span><span class="spaces">      </span><span class="nottickedoff">pure ()</span>
<span class="lineno"> 3920 </span><span class="spaces">    </span><span class="nottickedoff">Just x  -&gt;</span>
<span class="lineno"> 3921 </span><span class="spaces">      </span><span class="nottickedoff">-- Otherwise, add a permission @n:eq(x)@, and then pop it off the stack</span>
<span class="lineno"> 3922 </span><span class="spaces">        </span><span class="nottickedoff">unitEqM n (PExpr_Var x) &gt;&gt;&gt;</span>
<span class="lineno"> 3923 </span><span class="spaces">        </span><span class="nottickedoff">implPopM n (ValPerm_Eq (PExpr_Var x)) &gt;&gt;&gt;</span>
<span class="lineno"> 3924 </span><span class="spaces">        </span><span class="nottickedoff">pure ()</span>
<span class="lineno"> 3925 </span><span class="spaces"></span><span class="nottickedoff">handleUnitVar _ _ = pure ()</span></span>
<span class="lineno"> 3926 </span>
<span class="lineno"> 3927 </span>-- | Unify the unit variables already added to the state NameMap
<span class="lineno"> 3928 </span>handleUnitVars :: forall (tps :: RList CrucibleType)
<span class="lineno"> 3929 </span>                          vars r s ps.
<span class="lineno"> 3930 </span>                  NuMatchingAny1 r =&gt;
<span class="lineno"> 3931 </span>                  RAssign Name tps -&gt;
<span class="lineno"> 3932 </span>                  ImplM vars s r ps ps ()
<span class="lineno"> 3933 </span><span class="decl"><span class="nottickedoff">handleUnitVars ns = use implStateNameTypes &gt;&gt;&gt;= \nameMap -&gt;</span>
<span class="lineno"> 3934 </span><span class="spaces">                    </span><span class="nottickedoff">handleUnitVars' nameMap ns</span></span>
<span class="lineno"> 3935 </span>
<span class="lineno"> 3936 </span>handleUnitVars' :: forall (tps :: RList CrucibleType)
<span class="lineno"> 3937 </span>                          vars r s ps.
<span class="lineno"> 3938 </span>                   NuMatchingAny1 r =&gt;
<span class="lineno"> 3939 </span>                   NameMap TypeRepr -&gt;
<span class="lineno"> 3940 </span>                   RAssign Name tps -&gt;
<span class="lineno"> 3941 </span>                   ImplM vars s r ps ps ()
<span class="lineno"> 3942 </span><span class="decl"><span class="nottickedoff">handleUnitVars' _       MNil       = pure ()</span>
<span class="lineno"> 3943 </span><span class="spaces"></span><span class="nottickedoff">handleUnitVars' nameMap (ns :&gt;: n) =</span>
<span class="lineno"> 3944 </span><span class="spaces">  </span><span class="nottickedoff">case NameMap.lookup n nameMap of</span>
<span class="lineno"> 3945 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; error &quot;handleUnitVars: variable not added to nameMap&quot;</span>
<span class="lineno"> 3946 </span><span class="spaces">    </span><span class="nottickedoff">Just tp -&gt; handleUnitVar tp n &gt;&gt;&gt;</span>
<span class="lineno"> 3947 </span><span class="spaces">               </span><span class="nottickedoff">handleUnitVars' nameMap ns</span></span>
<span class="lineno"> 3948 </span>
<span class="lineno"> 3949 </span>
<span class="lineno"> 3950 </span>----------------------------------------------------------------------
<span class="lineno"> 3951 </span>-- * The Permission Implication Rules as Monadic Operations
<span class="lineno"> 3952 </span>----------------------------------------------------------------------
<span class="lineno"> 3953 </span>
<span class="lineno"> 3954 </span>type family Fst (p :: (k1,k2)) :: k1 where Fst '(x,_) = x
<span class="lineno"> 3955 </span>type family Snd (p :: (k1,k2)) :: k2 where Snd '(_,y) = y
<span class="lineno"> 3956 </span>
<span class="lineno"> 3957 </span>-- | An 'ImplM' continuation for a permission implication rule
<span class="lineno"> 3958 </span>newtype Impl1Cont vars s r ps_r a bs_ps =
<span class="lineno"> 3959 </span>  Impl1Cont (RAssign Name (Fst bs_ps) -&gt; ImplM vars s r ps_r (Snd bs_ps) a)
<span class="lineno"> 3960 </span>
<span class="lineno"> 3961 </span>-- | Apply a permission implication rule, with the given continuations in the
<span class="lineno"> 3962 </span>-- possible disjunctive branches of the result
<span class="lineno"> 3963 </span>implApplyImpl1 :: HasCallStack =&gt; NuMatchingAny1 r =&gt; PermImpl1 ps_in ps_outs -&gt;
<span class="lineno"> 3964 </span>                  RAssign (Impl1Cont vars s r ps_r a) ps_outs -&gt;
<span class="lineno"> 3965 </span>                  ImplM vars s r ps_r ps_in a
<span class="lineno"> 3966 </span><span class="decl"><span class="nottickedoff">implApplyImpl1 impl1 mb_ms =</span>
<span class="lineno"> 3967 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 3968 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \pp_info -&gt;</span>
<span class="lineno"> 3969 </span><span class="spaces">  </span><span class="nottickedoff">gmapRet (PermImpl_Step impl1 &lt;$&gt;) &gt;&gt;&gt;</span>
<span class="lineno"> 3970 </span><span class="spaces">  </span><span class="nottickedoff">helper (applyImpl1 pp_info impl1 perms) mb_ms</span>
<span class="lineno"> 3971 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 3972 </span><span class="spaces">    </span><span class="nottickedoff">helper :: NuMatchingAny1 r =&gt;</span>
<span class="lineno"> 3973 </span><span class="spaces">              </span><span class="nottickedoff">MbPermSets ps_outs -&gt;</span>
<span class="lineno"> 3974 </span><span class="spaces">              </span><span class="nottickedoff">RAssign (Impl1Cont vars s r ps_r a) ps_outs -&gt;</span>
<span class="lineno"> 3975 </span><span class="spaces">              </span><span class="nottickedoff">GenStateContT</span>
<span class="lineno"> 3976 </span><span class="spaces">                </span><span class="nottickedoff">(ImplState vars ps_r)  (PermImpl r ps_r)</span>
<span class="lineno"> 3977 </span><span class="spaces">                </span><span class="nottickedoff">(ImplState vars ps_in) (MbPermImpls r ps_outs)</span>
<span class="lineno"> 3978 </span><span class="spaces">                </span><span class="nottickedoff">(State (Closed s)) a</span>
<span class="lineno"> 3979 </span><span class="spaces">    </span><span class="nottickedoff">helper MbPermSets_Nil _ = gabortM (return MbPermImpls_Nil)</span>
<span class="lineno"> 3980 </span><span class="spaces">    </span><span class="nottickedoff">helper (MbPermSets_Cons mbperms ctx mbperm) (args :&gt;: Impl1Cont f) =</span>
<span class="lineno"> 3981 </span><span class="spaces">      </span><span class="nottickedoff">gparallel (\m1 m2 -&gt; MbPermImpls_Cons ctx &lt;$&gt; m1 &lt;*&gt; m2)</span>
<span class="lineno"> 3982 </span><span class="spaces">      </span><span class="nottickedoff">(helper mbperms args)</span>
<span class="lineno"> 3983 </span><span class="spaces">      </span><span class="nottickedoff">(gopenBinding strongMbM mbperm &gt;&gt;&gt;= \(ns, perms') -&gt;</span>
<span class="lineno"> 3984 </span><span class="spaces">        </span><span class="nottickedoff">gmodify (set implStatePerms perms' .</span>
<span class="lineno"> 3985 </span><span class="spaces">                 </span><span class="nottickedoff">over implStatePPInfo (ppInfoAddTypedExprNames ctx ns)) &gt;&gt;&gt;</span>
<span class="lineno"> 3986 </span><span class="spaces">        </span><span class="nottickedoff">implSetNameTypes ns ctx &gt;&gt;&gt;</span>
<span class="lineno"> 3987 </span><span class="spaces">        </span><span class="nottickedoff">f ns)</span></span>
<span class="lineno"> 3988 </span>
<span class="lineno"> 3989 </span>-- | Emit debugging output using the current 'PPInfo' if the 'implStateDebugLevel'
<span class="lineno"> 3990 </span>-- is at least the supplied debug level
<span class="lineno"> 3991 </span>implDebugM :: DebugLevel -&gt; (PPInfo -&gt; PP.Doc ann) -&gt;
<span class="lineno"> 3992 </span>              ImplM vars s r ps ps String
<span class="lineno"> 3993 </span><span class="decl"><span class="nottickedoff">implDebugM reqlvl f =</span>
<span class="lineno"> 3994 </span><span class="spaces">  </span><span class="nottickedoff">do dlevel &lt;- use implStateDebugLevel</span>
<span class="lineno"> 3995 </span><span class="spaces">     </span><span class="nottickedoff">doc &lt;- uses implStatePPInfo f</span>
<span class="lineno"> 3996 </span><span class="spaces">     </span><span class="nottickedoff">let str = renderDoc doc</span>
<span class="lineno"> 3997 </span><span class="spaces">     </span><span class="nottickedoff">debugTrace reqlvl dlevel str (return str)</span></span>
<span class="lineno"> 3998 </span>
<span class="lineno"> 3999 </span>-- | Pretty-print an object using the current pretty-printing info
<span class="lineno"> 4000 </span>implPrettyM :: NuMatchingAny1 r =&gt; PermPretty p =&gt; p -&gt;
<span class="lineno"> 4001 </span>               ImplM vars s r ps ps (PP.Doc ann)
<span class="lineno"> 4002 </span><span class="decl"><span class="nottickedoff">implPrettyM p = uses implStatePPInfo $ \pp_info -&gt; permPretty pp_info p</span></span>
<span class="lineno"> 4003 </span>
<span class="lineno"> 4004 </span>-- | Emit debugging output using the current 'PPInfo' if the 'implStateDebugLevel'
<span class="lineno"> 4005 </span>-- is at least 'traceDebugLevel'
<span class="lineno"> 4006 </span>implTraceM :: (PPInfo -&gt; PP.Doc ann) -&gt; ImplM vars s r ps ps String
<span class="lineno"> 4007 </span><span class="decl"><span class="nottickedoff">implTraceM = implDebugM traceDebugLevel</span></span>
<span class="lineno"> 4008 </span>
<span class="lineno"> 4009 </span>-- | Emit debugging output using the current 'PPInfo' if the 'implStateDebugLevel'
<span class="lineno"> 4010 </span>-- is at least 'verboseDebugLevel'
<span class="lineno"> 4011 </span>implVerbTraceM :: (PPInfo -&gt; PP.Doc ann) -&gt; ImplM vars s r ps ps String
<span class="lineno"> 4012 </span><span class="decl"><span class="nottickedoff">implVerbTraceM = implDebugM verboseDebugLevel</span></span>
<span class="lineno"> 4013 </span>
<span class="lineno"> 4014 </span>-- | Run an 'ImplM' computation with the debug level set to 'noDebugLevel'
<span class="lineno"> 4015 </span>implWithoutTracingM :: ImplM vars s r ps_out ps_in a -&gt;
<span class="lineno"> 4016 </span>                       ImplM vars s r ps_out ps_in a
<span class="lineno"> 4017 </span><span class="decl"><span class="nottickedoff">implWithoutTracingM m =</span>
<span class="lineno"> 4018 </span><span class="spaces">  </span><span class="nottickedoff">use implStateDebugLevel &gt;&gt;&gt;= \saved -&gt;</span>
<span class="lineno"> 4019 </span><span class="spaces">  </span><span class="nottickedoff">(implStateDebugLevel .= noDebugLevel) &gt;&gt;&gt;</span>
<span class="lineno"> 4020 </span><span class="spaces">  </span><span class="nottickedoff">m &gt;&gt;&gt;= \a -&gt;</span>
<span class="lineno"> 4021 </span><span class="spaces">  </span><span class="nottickedoff">(implStateDebugLevel .= saved) &gt;&gt;</span>
<span class="lineno"> 4022 </span><span class="spaces">  </span><span class="nottickedoff">pure a</span></span>
<span class="lineno"> 4023 </span>
<span class="lineno"> 4024 </span>-- | Pretty print an implication @x:p -o (vars).p'@
<span class="lineno"> 4025 </span>ppImpl :: PPInfo -&gt; ExprVar tp -&gt; ValuePerm tp -&gt;
<span class="lineno"> 4026 </span>          Mb (vars :: RList CrucibleType) (ValuePerm tp) -&gt; PP.Doc ann
<span class="lineno"> 4027 </span><span class="decl"><span class="nottickedoff">ppImpl i x p mb_p =</span>
<span class="lineno"> 4028 </span><span class="spaces">  </span><span class="nottickedoff">sep [PP.group (permPretty i x &lt;&gt; PP.colon &lt;&gt; PP.align (permPretty i p)),</span>
<span class="lineno"> 4029 </span><span class="spaces">       </span><span class="nottickedoff">PP.pretty &quot;-o&quot;,</span>
<span class="lineno"> 4030 </span><span class="spaces">       </span><span class="nottickedoff">PP.group (PP.align (permPretty i mb_p))]</span></span>
<span class="lineno"> 4031 </span>
<span class="lineno"> 4032 </span>-- | Produce a branching proof tree that performs the first implication and, if
<span class="lineno"> 4033 </span>-- that one fails, falls back on the second. The supplied 'String' says what
<span class="lineno"> 4034 </span>-- proof-search function is performing the catch, while the @p@ argument says
<span class="lineno"> 4035 </span>-- what we are trying to prove; both of these are for debugging purposes, and
<span class="lineno"> 4036 </span>-- are used in the debug trace.
<span class="lineno"> 4037 </span>implCatchM :: NuMatchingAny1 r =&gt; PermPretty p =&gt; String -&gt; p -&gt;
<span class="lineno"> 4038 </span>              ImplM vars s r ps1 ps2 a -&gt; ImplM vars s r ps1 ps2 a -&gt;
<span class="lineno"> 4039 </span>              ImplM vars s r ps1 ps2 a
<span class="lineno"> 4040 </span><span class="decl"><span class="nottickedoff">implCatchM f p m1 m2 =</span>
<span class="lineno"> 4041 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt; pretty (&quot;Catch in &quot; ++ f ++ &quot; for proving:&quot;)</span>
<span class="lineno"> 4042 </span><span class="spaces">                    </span><span class="nottickedoff">&lt;&gt; line &lt;&gt; permPretty i p) &gt;&gt;&gt;= \catch_str -&gt;</span>
<span class="lineno"> 4043 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1</span>
<span class="lineno"> 4044 </span><span class="spaces">    </span><span class="nottickedoff">(Impl1_Catch catch_str)</span>
<span class="lineno"> 4045 </span><span class="spaces">    </span><span class="nottickedoff">(MNil</span>
<span class="lineno"> 4046 </span><span class="spaces">     </span><span class="nottickedoff">:&gt;: Impl1Cont (const $</span>
<span class="lineno"> 4047 </span><span class="spaces">                    </span><span class="nottickedoff">implTraceM (\i -&gt; pretty (&quot;Case 1 of catch in &quot; ++ f</span>
<span class="lineno"> 4048 </span><span class="spaces">                                              </span><span class="nottickedoff">++ &quot; for proving:&quot;)</span>
<span class="lineno"> 4049 </span><span class="spaces">                                      </span><span class="nottickedoff">&lt;&gt; line &lt;&gt; permPretty i p) &gt;&gt;&gt;</span>
<span class="lineno"> 4050 </span><span class="spaces">                    </span><span class="nottickedoff">m1)</span>
<span class="lineno"> 4051 </span><span class="spaces">     </span><span class="nottickedoff">:&gt;: Impl1Cont (const $</span>
<span class="lineno"> 4052 </span><span class="spaces">                    </span><span class="nottickedoff">implTraceM (\i -&gt; pretty (&quot;Case 2 of catch in &quot; ++ f</span>
<span class="lineno"> 4053 </span><span class="spaces">                                              </span><span class="nottickedoff">++ &quot; for proving:&quot;)</span>
<span class="lineno"> 4054 </span><span class="spaces">                                      </span><span class="nottickedoff">&lt;&gt; line &lt;&gt; permPretty i p) &gt;&gt;&gt;</span>
<span class="lineno"> 4055 </span><span class="spaces">                    </span><span class="nottickedoff">m2))</span></span>
<span class="lineno"> 4056 </span>
<span class="lineno"> 4057 </span>-- | \&quot;Push\&quot; all of the permissions in the permission set for a variable, which
<span class="lineno"> 4058 </span>-- should be equal to the supplied permission, after deleting those permissions
<span class="lineno"> 4059 </span>-- from the input permission set. This is like a simple \&quot;proof\&quot; of @x:p@.
<span class="lineno"> 4060 </span>implPushM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4061 </span>             ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 4062 </span><span class="decl"><span class="nottickedoff">implPushM x p =</span>
<span class="lineno"> 4063 </span><span class="spaces">  </span><span class="nottickedoff">implVerbTraceM (\i -&gt;</span>
<span class="lineno"> 4064 </span><span class="spaces">                   </span><span class="nottickedoff">sep [pretty &quot;implPushM&quot; &lt;+&gt;</span>
<span class="lineno"> 4065 </span><span class="spaces">                        </span><span class="nottickedoff">permPretty i x &lt;&gt; colon &lt;&gt; permPretty i p]) &gt;&gt;&gt;</span>
<span class="lineno"> 4066 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_Push x p) (MNil :&gt;: Impl1Cont (const $ pure ()))</span></span>
<span class="lineno"> 4067 </span>
<span class="lineno"> 4068 </span>-- | Call 'implPushM' for multiple @x:p@ permissions
<span class="lineno"> 4069 </span>implPushMultiM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4070 </span>                  DistPerms ps -&gt; ImplM vars s r ps RNil ()
<span class="lineno"> 4071 </span><span class="decl"><span class="nottickedoff">implPushMultiM DistPermsNil = pure ()</span>
<span class="lineno"> 4072 </span><span class="spaces"></span><span class="nottickedoff">implPushMultiM (DistPermsCons ps x p) =</span>
<span class="lineno"> 4073 </span><span class="spaces">  </span><span class="nottickedoff">implPushMultiM ps &gt;&gt;&gt; implPushM x p</span></span>
<span class="lineno"> 4074 </span>
<span class="lineno"> 4075 </span>-- | For each permission @x:p@ in a list of permissions, either prove @x:eq(x)@
<span class="lineno"> 4076 </span>-- by reflexivity if @p=eq(x)@ or push @x:p@ if @x@ has permissions @p@
<span class="lineno"> 4077 </span>implPushOrReflMultiM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; DistPerms ps -&gt;
<span class="lineno"> 4078 </span>                        ImplM vars s r ps RNil ()
<span class="lineno"> 4079 </span><span class="decl"><span class="nottickedoff">implPushOrReflMultiM DistPermsNil = pure ()</span>
<span class="lineno"> 4080 </span><span class="spaces"></span><span class="nottickedoff">implPushOrReflMultiM (DistPermsCons ps x (ValPerm_Eq (PExpr_Var x')))</span>
<span class="lineno"> 4081 </span><span class="spaces">  </span><span class="nottickedoff">| x == x' = implPushOrReflMultiM ps &gt;&gt;&gt; introEqReflM x</span>
<span class="lineno"> 4082 </span><span class="spaces"></span><span class="nottickedoff">implPushOrReflMultiM (DistPermsCons ps x p) =</span>
<span class="lineno"> 4083 </span><span class="spaces">  </span><span class="nottickedoff">implPushOrReflMultiM ps &gt;&gt;&gt; implPushM x p</span></span>
<span class="lineno"> 4084 </span>
<span class="lineno"> 4085 </span>-- | Pop a permission from the top of the stack back to the primary permission
<span class="lineno"> 4086 </span>-- for a variable, assuming that the primary permission for that variable is
<span class="lineno"> 4087 </span>-- empty, i.e., is the @true@ permission
<span class="lineno"> 4088 </span>implPopM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4089 </span>            ImplM vars s r ps (ps :&gt; a) ()
<span class="lineno"> 4090 </span><span class="decl"><span class="nottickedoff">implPopM x p =</span>
<span class="lineno"> 4091 </span><span class="spaces">  </span><span class="nottickedoff">implVerbTraceM (\i -&gt;</span>
<span class="lineno"> 4092 </span><span class="spaces">                   </span><span class="nottickedoff">sep [pretty &quot;implPopM&quot; &lt;+&gt;</span>
<span class="lineno"> 4093 </span><span class="spaces">                        </span><span class="nottickedoff">permPretty i x &lt;&gt; colon &lt;&gt; permPretty i p]) &gt;&gt;&gt;</span>
<span class="lineno"> 4094 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_Pop x p) (MNil :&gt;: Impl1Cont (const $ pure ()))</span></span>
<span class="lineno"> 4095 </span>
<span class="lineno"> 4096 </span>-- | Pattern-match a permission as a sequence of 1 or more disjuncts
<span class="lineno"> 4097 </span>matchOrList :: ValuePerm a -&gt; Maybe (Some (OrList ps a))
<span class="lineno"> 4098 </span><span class="decl"><span class="nottickedoff">matchOrList p_top@(ValPerm_Or _ _) = Just (helper MNil p_top) where</span>
<span class="lineno"> 4099 </span><span class="spaces">  </span><span class="nottickedoff">helper :: OrList ps a disjs -&gt; ValuePerm a -&gt; Some (OrList ps a)</span>
<span class="lineno"> 4100 </span><span class="spaces">  </span><span class="nottickedoff">helper or_list (ValPerm_Or p1 p2) =</span>
<span class="lineno"> 4101 </span><span class="spaces">    </span><span class="nottickedoff">helper (or_list :&gt;: OrListDisj p1) p2</span>
<span class="lineno"> 4102 </span><span class="spaces">  </span><span class="nottickedoff">helper or_list p = Some (or_list :&gt;: OrListDisj p)</span>
<span class="lineno"> 4103 </span><span class="spaces"></span><span class="nottickedoff">matchOrList _ = Nothing</span></span>
<span class="lineno"> 4104 </span>
<span class="lineno"> 4105 </span>-- | Eliminate a right-nested disjunction @x:(p1 \/ (p2 \/ (... \/ pn)))@,
<span class="lineno"> 4106 </span>-- building proof trees that proceed with all the @pi@
<span class="lineno"> 4107 </span>implElimOrsM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4108 </span>                ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4109 </span><span class="decl"><span class="nottickedoff">implElimOrsM x p@(matchOrList -&gt; Just (Some or_list)) =</span>
<span class="lineno"> 4110 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\pp_info -&gt; pretty &quot;Eliminating or:&quot; &lt;+&gt;</span>
<span class="lineno"> 4111 </span><span class="spaces">                          </span><span class="nottickedoff">permPretty pp_info (ColonPair x p)) &gt;&gt;&gt;= \xp_pp -&gt;</span>
<span class="lineno"> 4112 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_ElimOrs xp_pp x or_list)</span>
<span class="lineno"> 4113 </span><span class="spaces">  </span><span class="nottickedoff">(RL.map (\(OrListDisj _) -&gt; Impl1Cont (const $ pure ())) or_list)</span>
<span class="lineno"> 4114 </span><span class="spaces"></span><span class="nottickedoff">implElimOrsM _ _ = error &quot;implElimOrsM: malformed input permission&quot;</span></span>
<span class="lineno"> 4115 </span>
<span class="lineno"> 4116 </span>-- | Eliminate an existential permission @x:(exists (y:tp).p)@ in the current
<span class="lineno"> 4117 </span>-- permission set
<span class="lineno"> 4118 </span>implElimExistsM :: (NuMatchingAny1 r, KnownRepr TypeRepr tp) =&gt;
<span class="lineno"> 4119 </span>                   ExprVar a -&gt; Binding tp (ValuePerm a) -&gt;
<span class="lineno"> 4120 </span>                   ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4121 </span><span class="decl"><span class="nottickedoff">implElimExistsM x p =</span>
<span class="lineno"> 4122 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_ElimExists x p)</span>
<span class="lineno"> 4123 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (const $ pure ()))</span></span>
<span class="lineno"> 4124 </span>
<span class="lineno"> 4125 </span>-- | Eliminate a false permission in the current permission set
<span class="lineno"> 4126 </span>implElimFalseM :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4127 </span>                  ImplM vars s r ps_any (ps :&gt; a) ()
<span class="lineno"> 4128 </span><span class="decl"><span class="nottickedoff">implElimFalseM x =</span>
<span class="lineno"> 4129 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_ElimFalse x) MNil</span></span>
<span class="lineno"> 4130 </span>
<span class="lineno"> 4131 </span>-- | Apply a simple implication rule to the top permissions on the stack
<span class="lineno"> 4132 </span>implSimplM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; Proxy ps -&gt;
<span class="lineno"> 4133 </span>              SimplImpl ps_in ps_out -&gt;
<span class="lineno"> 4134 </span>              ImplM vars s r (ps :++: ps_out) (ps :++: ps_in) ()
<span class="lineno"> 4135 </span><span class="decl"><span class="nottickedoff">implSimplM prx simpl =</span>
<span class="lineno"> 4136 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_Simpl simpl prx)</span>
<span class="lineno"> 4137 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (const $ pure ()))</span></span>
<span class="lineno"> 4138 </span>
<span class="lineno"> 4139 </span>-- | Bind a new variable @x@ that is set to the supplied expression @e@ and has
<span class="lineno"> 4140 </span>-- permissions @eq(e)@, returning @x@
<span class="lineno"> 4141 </span>implLetBindVar :: NuMatchingAny1 r =&gt; TypeRepr tp -&gt; PermExpr tp -&gt;
<span class="lineno"> 4142 </span>                  ImplM vars s r ps ps (Name tp)
<span class="lineno"> 4143 </span>-- NOTE: we explicitly do *not* want to re-use an existing variable, for the
<span class="lineno"> 4144 </span>-- case where we need distinct bound variables, i.e., for proveVarsImplVarEVars
<span class="lineno"> 4145 </span>--
<span class="lineno"> 4146 </span>-- implLetBindVar _ (PExpr_Var x) = greturn x
<span class="lineno"> 4147 </span><span class="decl"><span class="nottickedoff">implLetBindVar tp e =</span>
<span class="lineno"> 4148 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_LetBind tp e)</span>
<span class="lineno"> 4149 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (\(_ :&gt;: n) -&gt; pure n)) &gt;&gt;&gt;= \n -&gt;</span>
<span class="lineno"> 4150 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm n (ValPerm_Eq e) &gt;&gt;&gt;</span>
<span class="lineno"> 4151 </span><span class="spaces">  </span><span class="nottickedoff">pure n</span></span>
<span class="lineno"> 4152 </span>
<span class="lineno"> 4153 </span>-- | Bind a sequence of variables with 'implLetBindVar'
<span class="lineno"> 4154 </span>implLetBindVars :: NuMatchingAny1 r =&gt; CruCtx tps -&gt; PermExprs tps -&gt;
<span class="lineno"> 4155 </span>                   ImplM vars s r ps ps (RAssign ExprVar tps)
<span class="lineno"> 4156 </span><span class="decl"><span class="nottickedoff">implLetBindVars CruCtxNil MNil = pure MNil</span>
<span class="lineno"> 4157 </span><span class="spaces"></span><span class="nottickedoff">implLetBindVars (CruCtxCons tps tp) (es :&gt;: e) =</span>
<span class="lineno"> 4158 </span><span class="spaces">  </span><span class="nottickedoff">(:&gt;:) &lt;$&gt; implLetBindVars tps es &lt;*&gt; implLetBindVar tp e</span></span>
<span class="lineno"> 4159 </span>
<span class="lineno"> 4160 </span>-- | Introduce a new univerally-quantified variable @x@ of unit type.
<span class="lineno"> 4161 </span>--
<span class="lineno"> 4162 </span>-- ps -o x. ps
<span class="lineno"> 4163 </span>implIntroUnitVar :: NuMatchingAny1 r =&gt;
<span class="lineno"> 4164 </span>                    ImplM vars s r ps ps (Name UnitType)
<span class="lineno"> 4165 </span><span class="decl"><span class="nottickedoff">implIntroUnitVar =</span>
<span class="lineno"> 4166 </span><span class="spaces">  </span><span class="nottickedoff">-- Note that unlike @implLetbindVar@, this function does *not* bind @x@ to a</span>
<span class="lineno"> 4167 </span><span class="spaces">  </span><span class="nottickedoff">-- value @e@. Instead, we have almost the same operations as 'implLetBindVar'</span>
<span class="lineno"> 4168 </span><span class="spaces">  </span><span class="nottickedoff">-- but instead of calling 'recombinePerm', we instead call</span>
<span class="lineno"> 4169 </span><span class="spaces">  </span><span class="nottickedoff">-- 'implLetBindVarDropEq', which drops the residual equality permission</span>
<span class="lineno"> 4170 </span><span class="spaces">  </span><span class="nottickedoff">let e = PExpr_Unit in</span>
<span class="lineno"> 4171 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_LetBind UnitRepr e)</span>
<span class="lineno"> 4172 </span><span class="spaces">    </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (\(_ :&gt;: n) -&gt; pure n)) &gt;&gt;&gt;= \n -&gt;</span>
<span class="lineno"> 4173 </span><span class="spaces">  </span><span class="nottickedoff">-- Drop the n:eq(unit) permission</span>
<span class="lineno"> 4174 </span><span class="spaces">  </span><span class="nottickedoff">implDropM n (ValPerm_Eq e) &gt;&gt;&gt;</span>
<span class="lineno"> 4175 </span><span class="spaces">  </span><span class="nottickedoff">pure n</span></span>
<span class="lineno"> 4176 </span>
<span class="lineno"> 4177 </span>
<span class="lineno"> 4178 </span>-- | Freshen up a sequence of names by replacing any duplicate names in the list
<span class="lineno"> 4179 </span>-- with fresh, let-bound variables
<span class="lineno"> 4180 </span>implFreshenNames :: NuMatchingAny1 r =&gt; RAssign ExprVar tps -&gt;
<span class="lineno"> 4181 </span>                    ImplM vars s r ps ps (RAssign ExprVar tps)
<span class="lineno"> 4182 </span><span class="decl"><span class="nottickedoff">implFreshenNames ns =</span>
<span class="lineno"> 4183 </span><span class="spaces">  </span><span class="nottickedoff">fmap fst $ rlMapMWithAccum</span>
<span class="lineno"> 4184 </span><span class="spaces">  </span><span class="nottickedoff">(\prevs n -&gt;</span>
<span class="lineno"> 4185 </span><span class="spaces">    </span><span class="nottickedoff">if NameSet.member n prevs then</span>
<span class="lineno"> 4186 </span><span class="spaces">      </span><span class="nottickedoff">(implGetVarType n &gt;&gt;&gt;= \tp -&gt; implLetBindVar tp (PExpr_Var n) &gt;&gt;&gt;= \n' -&gt;</span>
<span class="lineno"> 4187 </span><span class="spaces">        </span><span class="nottickedoff">return (n', prevs))</span>
<span class="lineno"> 4188 </span><span class="spaces">    </span><span class="nottickedoff">else return (n, NameSet.insert n prevs))</span>
<span class="lineno"> 4189 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.empty ns</span></span>
<span class="lineno"> 4190 </span>
<span class="lineno"> 4191 </span>-- | Project out a field of a struct @x@ by binding a fresh variable @y@ for its
<span class="lineno"> 4192 </span>-- contents, and assign the permissions for that field to @y@, replacing them
<span class="lineno"> 4193 </span>-- with a proof that the field equals @y@, popping the permissions for @y@ and
<span class="lineno"> 4194 </span>-- returning the variable @y@. If the given struct field already has permissions
<span class="lineno"> 4195 </span>-- @eq(y)@ for some @y@, just return that @y@.
<span class="lineno"> 4196 </span>implElimStructField ::
<span class="lineno"> 4197 </span>  NuMatchingAny1 r =&gt; ExprVar (StructType ctx) -&gt;
<span class="lineno"> 4198 </span>  RAssign ValuePerm (CtxToRList ctx) -&gt; Member (CtxToRList ctx) a -&gt;
<span class="lineno"> 4199 </span>  ImplM vars s r (ps :&gt; StructType ctx) (ps :&gt; StructType ctx) (ExprVar a)
<span class="lineno"> 4200 </span><span class="decl"><span class="nottickedoff">implElimStructField _ ps memb</span>
<span class="lineno"> 4201 </span><span class="spaces">  </span><span class="nottickedoff">| ValPerm_Eq (PExpr_Var y) &lt;- RL.get memb ps = pure y</span>
<span class="lineno"> 4202 </span><span class="spaces"></span><span class="nottickedoff">implElimStructField x ps memb =</span>
<span class="lineno"> 4203 </span><span class="spaces">  </span><span class="nottickedoff">implGetVarType x &gt;&gt;&gt;= \(StructRepr tps) -&gt;</span>
<span class="lineno"> 4204 </span><span class="spaces">  </span><span class="nottickedoff">let tp = RL.get memb (assignToRList tps) in</span>
<span class="lineno"> 4205 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_ElimStructField x ps tp memb)</span>
<span class="lineno"> 4206 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (\(_ :&gt;: n) -&gt; pure n)) &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 4207 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm y (RL.get memb ps) &gt;&gt;&gt;</span>
<span class="lineno"> 4208 </span><span class="spaces">  </span><span class="nottickedoff">pure y</span></span>
<span class="lineno"> 4209 </span>
<span class="lineno"> 4210 </span>-- | Apply 'implElimStructField' to a sequence of fields in a struct permission,
<span class="lineno"> 4211 </span>-- to get out a sequence of variables for the corrsponding fields of that struct
<span class="lineno"> 4212 </span>implElimStructFields ::
<span class="lineno"> 4213 </span>  NuMatchingAny1 r =&gt; ExprVar (StructType ctx) -&gt;
<span class="lineno"> 4214 </span>  RAssign ValuePerm (CtxToRList ctx) -&gt; RAssign (Member (CtxToRList ctx)) fs -&gt;
<span class="lineno"> 4215 </span>  ImplM vars s r (ps :&gt; StructType ctx) (ps :&gt; StructType ctx) (RAssign ExprVar fs)
<span class="lineno"> 4216 </span><span class="decl"><span class="nottickedoff">implElimStructFields _ _ MNil = pure MNil</span>
<span class="lineno"> 4217 </span><span class="spaces"></span><span class="nottickedoff">implElimStructFields x ps (membs :&gt;: memb) =</span>
<span class="lineno"> 4218 </span><span class="spaces">  </span><span class="nottickedoff">implElimStructField x ps memb &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 4219 </span><span class="spaces">  </span><span class="nottickedoff">implElimStructFields x (RL.set memb (ValPerm_Eq $</span>
<span class="lineno"> 4220 </span><span class="spaces">                                       </span><span class="nottickedoff">PExpr_Var y) ps) membs &gt;&gt;&gt;= \ys -&gt;</span>
<span class="lineno"> 4221 </span><span class="spaces">  </span><span class="nottickedoff">pure (ys :&gt;: y)</span></span>
<span class="lineno"> 4222 </span>
<span class="lineno"> 4223 </span>-- | Apply 'implElimStructField' to all fields in a struct permission, to get
<span class="lineno"> 4224 </span>-- out a sequence of variables for the fields of that struct
<span class="lineno"> 4225 </span>implElimStructAllFields ::
<span class="lineno"> 4226 </span>  NuMatchingAny1 r =&gt; ExprVar (StructType ctx) -&gt;
<span class="lineno"> 4227 </span>  RAssign ValuePerm (CtxToRList ctx) -&gt;
<span class="lineno"> 4228 </span>  ImplM vars s r (ps :&gt; StructType ctx) (ps :&gt; StructType ctx)
<span class="lineno"> 4229 </span>  (RAssign Name (CtxToRList ctx))
<span class="lineno"> 4230 </span><span class="decl"><span class="nottickedoff">implElimStructAllFields x ps = implElimStructFields x ps (RL.members ps)</span></span>
<span class="lineno"> 4231 </span>
<span class="lineno"> 4232 </span>-- | Prove a struct permission @struct(p1,...,pn)@ from a struct permission
<span class="lineno"> 4233 </span>-- (described by the second argument) where some subset of the field permissions
<span class="lineno"> 4234 </span>-- are equality permissions to variables along with proofs that the variables
<span class="lineno"> 4235 </span>-- have the required permissions
<span class="lineno"> 4236 </span>implIntroStructFields ::
<span class="lineno"> 4237 </span>  NuMatchingAny1 r =&gt; ExprVar (StructType ctx) -&gt;
<span class="lineno"> 4238 </span>  RAssign ValuePerm (CtxToRList ctx) -&gt; RAssign (Member (CtxToRList ctx)) fs -&gt;
<span class="lineno"> 4239 </span>  ImplM vars s r (ps :&gt; StructType ctx) (ps :++: fs :&gt; StructType ctx) ()
<span class="lineno"> 4240 </span><span class="decl"><span class="nottickedoff">implIntroStructFields _ _ MNil = pure ()</span>
<span class="lineno"> 4241 </span><span class="spaces"></span><span class="nottickedoff">implIntroStructFields x ps (membs :&gt;: memb)</span>
<span class="lineno"> 4242 </span><span class="spaces">  </span><span class="nottickedoff">| ValPerm_Eq (PExpr_Var y) &lt;- RL.get memb ps =</span>
<span class="lineno"> 4243 </span><span class="spaces">    </span><span class="nottickedoff">(distPermsHeadPerm &lt;$&gt; distPermsSnoc &lt;$&gt; getDistPerms) &gt;&gt;&gt;= \y_p -&gt;</span>
<span class="lineno"> 4244 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM y y_p x (ValPerm_Conj1 $ Perm_Struct ps) &gt;&gt;&gt;</span>
<span class="lineno"> 4245 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroStructField x ps memb y_p) &gt;&gt;&gt;</span>
<span class="lineno"> 4246 </span><span class="spaces">    </span><span class="nottickedoff">implIntroStructFields x (RL.set memb y_p ps) membs</span>
<span class="lineno"> 4247 </span><span class="spaces"></span><span class="nottickedoff">implIntroStructFields _ _ _ =</span>
<span class="lineno"> 4248 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;implIntroStructFields: malformed input permission&quot;</span></span>
<span class="lineno"> 4249 </span>
<span class="lineno"> 4250 </span>-- | Prove a struct permission @struct(p1,...,pn)@ from a struct permission
<span class="lineno"> 4251 </span>-- @struct(eq(y1),...,eq(yn))@ on top of the stack of equality permissions to
<span class="lineno"> 4252 </span>-- variables along with proofs below it on the stack that each variable @yi@ has
<span class="lineno"> 4253 </span>-- the corresponding permission @pi@
<span class="lineno"> 4254 </span>implIntroStructAllFields ::
<span class="lineno"> 4255 </span>  NuMatchingAny1 r =&gt; ExprVar (StructType ctx) -&gt;
<span class="lineno"> 4256 </span>  ImplM vars s r (ps :&gt; StructType ctx) (ps :++: CtxToRList ctx
<span class="lineno"> 4257 </span>                                         :&gt; StructType ctx) ()
<span class="lineno"> 4258 </span><span class="decl"><span class="nottickedoff">implIntroStructAllFields x =</span>
<span class="lineno"> 4259 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 4260 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj1 (Perm_Struct ps)) -&gt;</span>
<span class="lineno"> 4261 </span><span class="spaces">    </span><span class="nottickedoff">implIntroStructFields x ps (RL.members ps)</span>
<span class="lineno"> 4262 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;implIntroStructAllFields: malformed input permission&quot;</span></span>
<span class="lineno"> 4263 </span>
<span class="lineno"> 4264 </span>-- | Eliminate a permission @x:ptr((rw,off) |-&gt; p)@ into permissions
<span class="lineno"> 4265 </span>-- @x:ptr((rw,off) |-&gt; eq(y))@ and @y:p@ for a fresh variable @y@, returning the
<span class="lineno"> 4266 </span>-- fresh variable @y@ and popping the @y@ permissions off the stack. If @p@
<span class="lineno"> 4267 </span>-- already has the form @eq(y)@, then just return @y@.
<span class="lineno"> 4268 </span>implElimLLVMFieldContentsM ::
<span class="lineno"> 4269 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 4270 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 4271 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 4272 </span>  (ExprVar (LLVMPointerType sz))
<span class="lineno"> 4273 </span><span class="decl"><span class="nottickedoff">implElimLLVMFieldContentsM _ fp</span>
<span class="lineno"> 4274 </span><span class="spaces">  </span><span class="nottickedoff">| ValPerm_Eq (PExpr_Var y) &lt;- llvmFieldContents fp</span>
<span class="lineno"> 4275 </span><span class="spaces">  </span><span class="nottickedoff">= pure y</span>
<span class="lineno"> 4276 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMFieldContentsM x fp =</span>
<span class="lineno"> 4277 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_ElimLLVMFieldContents x fp)</span>
<span class="lineno"> 4278 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (\(_ :&gt;: n) -&gt; pure n)) &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 4279 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm y (llvmFieldContents fp) &gt;&gt;&gt;</span>
<span class="lineno"> 4280 </span><span class="spaces">  </span><span class="nottickedoff">pure y</span></span>
<span class="lineno"> 4281 </span>
<span class="lineno"> 4282 </span>-- | Prove a reachability permission @x:P&lt;args,e&gt;@ from a proof of @x:eq(e)@ on
<span class="lineno"> 4283 </span>-- the top of the stack
<span class="lineno"> 4284 </span>implReachabilityReflM ::
<span class="lineno"> 4285 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 4286 </span>  ExprVar a -&gt; NamedPermName (RecursiveSort b 'True) args a -&gt;
<span class="lineno"> 4287 </span>  PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 4288 </span>  ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4289 </span><span class="decl"><span class="nottickedoff">implReachabilityReflM x npn all_args off</span>
<span class="lineno"> 4290 </span><span class="spaces">  </span><span class="nottickedoff">| NameReachConstr &lt;- namedPermNameReachConstr npn</span>
<span class="lineno"> 4291 </span><span class="spaces">  </span><span class="nottickedoff">, PExprs_Cons args e &lt;- all_args =</span>
<span class="lineno"> 4292 </span><span class="spaces">    </span><span class="nottickedoff">implLookupNamedPerm npn &gt;&gt;&gt;= \np -&gt;</span>
<span class="lineno"> 4293 </span><span class="spaces">    </span><span class="nottickedoff">case unfoldPerm np (PExprs_Cons args e) off of</span>
<span class="lineno"> 4294 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Or p1 p2</span>
<span class="lineno"> 4295 </span><span class="spaces">        </span><span class="nottickedoff">| p1 == ValPerm_Eq e -&gt;</span>
<span class="lineno"> 4296 </span><span class="spaces">          </span><span class="nottickedoff">introOrLM x p1 p2 &gt;&gt;&gt;</span>
<span class="lineno"> 4297 </span><span class="spaces">          </span><span class="nottickedoff">implFoldNamedM x npn (PExprs_Cons args e) off</span>
<span class="lineno"> 4298 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;implReachabilityReflM: unexpected form of unfolded permission&quot;</span></span>
<span class="lineno"> 4299 </span>
<span class="lineno"> 4300 </span>-- | Prove a reachability permission @x:P&lt;args,e&gt;@ from proofs of
<span class="lineno"> 4301 </span>-- @x:P&lt;args,y&gt;@ and @y:P&lt;args,e&gt;@ on the top of the stack
<span class="lineno"> 4302 </span>implReachabilityTransM ::
<span class="lineno"> 4303 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 4304 </span>  ExprVar a -&gt; NamedPermName (RecursiveSort b 'True) args a -&gt;
<span class="lineno"> 4305 </span>  PermExprs args -&gt; PermOffset a -&gt; ExprVar a -&gt;
<span class="lineno"> 4306 </span>  ImplM vars s r (ps :&gt; a) (ps :&gt; a :&gt; a) ()
<span class="lineno"> 4307 </span><span class="decl"><span class="nottickedoff">implReachabilityTransM x npn all_args off y</span>
<span class="lineno"> 4308 </span><span class="spaces">  </span><span class="nottickedoff">| NameReachConstr &lt;- namedPermNameReachConstr npn</span>
<span class="lineno"> 4309 </span><span class="spaces">  </span><span class="nottickedoff">, PExprs_Cons args e &lt;- all_args =</span>
<span class="lineno"> 4310 </span><span class="spaces">    </span><span class="nottickedoff">implLookupNamedPerm npn &gt;&gt;&gt;= \(NamedPerm_Rec rp) -&gt;</span>
<span class="lineno"> 4311 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ReachabilityTrans x rp args off y e)</span></span>
<span class="lineno"> 4312 </span>
<span class="lineno"> 4313 </span>-- | Eliminate a @memblock@ permission with arbitrary shape @sh@, which cannot
<span class="lineno"> 4314 </span>-- have any free variables outside of pointer shapes, to have equality shape
<span class="lineno"> 4315 </span>-- @eqsh(y)@ for a variable @y@, assuming that permission is on the top of the
<span class="lineno"> 4316 </span>-- stack, and return the variable @y@. If @sh@ is already of this form, just
<span class="lineno"> 4317 </span>-- return the variable without doing any elimination.
<span class="lineno"> 4318 </span>implElimLLVMBlockToEq ::
<span class="lineno"> 4319 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4320 </span>  LLVMBlockPerm w -&gt;
<span class="lineno"> 4321 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 4322 </span>  (ExprVar (LLVMBlockType w))
<span class="lineno"> 4323 </span><span class="decl"><span class="nottickedoff">implElimLLVMBlockToEq _ (LLVMBlockPerm</span>
<span class="lineno"> 4324 </span><span class="spaces">                         </span><span class="nottickedoff">{ llvmBlockShape = PExpr_EqShape _ (PExpr_Var y)}) =</span>
<span class="lineno"> 4325 </span><span class="spaces">  </span><span class="nottickedoff">pure y</span>
<span class="lineno"> 4326 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlockToEq x bp =</span>
<span class="lineno"> 4327 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_ElimLLVMBlockToEq x bp)</span>
<span class="lineno"> 4328 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (\(_ :&gt;: n) -&gt; pure n)) &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 4329 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm y (ValPerm_Conj1 $ Perm_LLVMBlockShape $ modalizeBlockShape bp) &gt;&gt;&gt;</span>
<span class="lineno"> 4330 </span><span class="spaces">  </span><span class="nottickedoff">pure y</span></span>
<span class="lineno"> 4331 </span>
<span class="lineno"> 4332 </span>-- | Try to prove a proposition about bitvectors dynamically, failing as in
<span class="lineno"> 4333 </span>-- 'implFailM if the proposition does not hold
<span class="lineno"> 4334 </span>implTryProveBVProp :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4335 </span>                      ExprVar (LLVMPointerType w) -&gt; BVProp w -&gt;
<span class="lineno"> 4336 </span>                      ImplM vars s r (ps :&gt; LLVMPointerType w) ps ()
<span class="lineno"> 4337 </span><span class="decl"><span class="nottickedoff">implTryProveBVProp x p =</span>
<span class="lineno"> 4338 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \i -&gt;</span>
<span class="lineno"> 4339 </span><span class="spaces">  </span><span class="nottickedoff">let str = renderDoc (permPretty i p) in</span>
<span class="lineno"> 4340 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 (Impl1_TryProveBVProp x p str)</span>
<span class="lineno"> 4341 </span><span class="spaces">  </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (const $ pure ()))</span></span>
<span class="lineno"> 4342 </span>
<span class="lineno"> 4343 </span>-- | Try to prove a sequence of propositions using 'implTryProveBVProp'
<span class="lineno"> 4344 </span>implTryProveBVProps :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4345 </span>                       ExprVar (LLVMPointerType w) -&gt; [BVProp w] -&gt;
<span class="lineno"> 4346 </span>                       ImplM vars s r (ps :&gt; LLVMPointerType w) ps ()
<span class="lineno"> 4347 </span><span class="decl"><span class="nottickedoff">implTryProveBVProps x [] = introConjM x</span>
<span class="lineno"> 4348 </span><span class="spaces"></span><span class="nottickedoff">implTryProveBVProps x (prop:props) =</span>
<span class="lineno"> 4349 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProp x prop &gt;&gt;&gt;</span>
<span class="lineno"> 4350 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProps x props &gt;&gt;&gt;</span>
<span class="lineno"> 4351 </span><span class="spaces">  </span><span class="nottickedoff">implInsertConjM x (Perm_BVProp prop) (map Perm_BVProp props) 0</span></span>
<span class="lineno"> 4352 </span>
<span class="lineno"> 4353 </span>-- | Drop a permission from the top of the stack
<span class="lineno"> 4354 </span>implDropM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4355 </span>             ImplM vars s r ps (ps :&gt; a) ()
<span class="lineno"> 4356 </span><span class="decl"><span class="nottickedoff">implDropM x p = implSimplM Proxy (SImpl_Drop x p)</span></span>
<span class="lineno"> 4357 </span>
<span class="lineno"> 4358 </span>-- | Drop zero or more permissions from the top of the stack
<span class="lineno"> 4359 </span>implDropMultiM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; DistPerms ps' -&gt;
<span class="lineno"> 4360 </span>                  ImplM vars s r ps (ps :++: ps') ()
<span class="lineno"> 4361 </span><span class="decl"><span class="nottickedoff">implDropMultiM MNil = return ()</span>
<span class="lineno"> 4362 </span><span class="spaces"></span><span class="nottickedoff">implDropMultiM (ps :&gt;: VarAndPerm x p) = implDropM x p &gt;&gt;&gt; implDropMultiM ps</span></span>
<span class="lineno"> 4363 </span>
<span class="lineno"> 4364 </span>-- | Copy a permission on the top of the stack, assuming it is copyable
<span class="lineno"> 4365 </span>implCopyM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4366 </span>             ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4367 </span><span class="decl"><span class="nottickedoff">implCopyM x p = implSimplM Proxy (SImpl_Copy x p)</span></span>
<span class="lineno"> 4368 </span>
<span class="lineno"> 4369 </span>-- | Push a copyable permission using 'implPushM', copy that permission, and
<span class="lineno"> 4370 </span>-- then pop it back to the variable permission for @x@
<span class="lineno"> 4371 </span>implPushCopyM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4372 </span>                 ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 4373 </span><span class="decl"><span class="nottickedoff">implPushCopyM x p =</span>
<span class="lineno"> 4374 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implCopyM x p &gt;&gt;&gt; implPopM x p</span></span> -- NOTE: must be implPopM and
<span class="lineno"> 4375 </span>                                                   -- not recombinePerm
<span class="lineno"> 4376 </span>
<span class="lineno"> 4377 </span>-- | Swap the top two permissions on the top of the stack
<span class="lineno"> 4378 </span>implSwapM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4379 </span>             ExprVar b -&gt; ValuePerm b -&gt;
<span class="lineno"> 4380 </span>             ImplM vars s r (ps :&gt; b :&gt; a) (ps :&gt; a :&gt; b) ()
<span class="lineno"> 4381 </span><span class="decl"><span class="nottickedoff">implSwapM x p1 y p2 = implSimplM Proxy (SImpl_Swap x p1 y p2)</span></span>
<span class="lineno"> 4382 </span>
<span class="lineno"> 4383 </span>-- | Move permission @p@ that is on the stack below two lists @ps1@ and @ps2@
<span class="lineno"> 4384 </span>-- towards the top of the stack by moving it between @ps1@ and @ps2@. That is,
<span class="lineno"> 4385 </span>-- change the stack
<span class="lineno"> 4386 </span>--
<span class="lineno"> 4387 </span>-- &gt; perms, p, p1_1, ..., p1_n, p2_1, ..., p2_m
<span class="lineno"> 4388 </span>--
<span class="lineno"> 4389 </span>-- to
<span class="lineno"> 4390 </span>--
<span class="lineno"> 4391 </span>-- &gt; perms, p1_1, ..., p1_n, p, p2_1, ..., p2_m
<span class="lineno"> 4392 </span>implMoveUpM ::
<span class="lineno"> 4393 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 4394 </span>  prx ps -&gt; RAssign f ps1 -&gt; ExprVar a -&gt; RAssign f ps2 -&gt;
<span class="lineno"> 4395 </span>  ImplM vars s r (ps :++: ps1 :&gt; a :++: ps2) (ps :&gt; a :++: ps1 :++: ps2) ()
<span class="lineno"> 4396 </span><span class="decl"><span class="nottickedoff">implMoveUpM (ps :: prx ps) ps1 (x :: ExprVar a) ps2 =</span>
<span class="lineno"> 4397 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: this is gross! Find a better way to do all this!</span>
<span class="lineno"> 4398 </span><span class="spaces">  </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 4399 </span><span class="spaces">  </span><span class="nottickedoff">let (perms0x, perms12) =</span>
<span class="lineno"> 4400 </span><span class="spaces">        </span><span class="nottickedoff">splitDistPerms (Proxy :: Proxy (ps :&gt; a)) (RL.append ps1 ps2) perms</span>
<span class="lineno"> 4401 </span><span class="spaces">      </span><span class="nottickedoff">(perms1, perms2) = splitDistPerms ps1 ps2 perms12 in</span>
<span class="lineno"> 4402 </span><span class="spaces">  </span><span class="nottickedoff">case (perms0x, RL.appendRNilConsEq ps x (RL.append ps1 ps2)) of</span>
<span class="lineno"> 4403 </span><span class="spaces">    </span><span class="nottickedoff">(DistPermsCons _perms0 x' p, Refl)</span>
<span class="lineno"> 4404 </span><span class="spaces">      </span><span class="nottickedoff">| Just Refl &lt;- testEquality x x' -&gt;</span>
<span class="lineno"> 4405 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM (Proxy :: Proxy ps) (SImpl_MoveUp perms1 x p perms2)</span>
<span class="lineno"> 4406 </span><span class="spaces">    </span><span class="nottickedoff">(DistPermsCons _ _x' _, _) -&gt; error &quot;implMoveUpM: unexpected variable&quot;</span></span>
<span class="lineno"> 4407 </span>
<span class="lineno"> 4408 </span>reflU :: () :~: ()
<span class="lineno"> 4409 </span><span class="decl"><span class="nottickedoff">reflU = Refl</span></span>
<span class="lineno"> 4410 </span>
<span class="lineno"> 4411 </span>-- | Same as 'implMoveUpM' except the type lists are associated differently
<span class="lineno"> 4412 </span>implMoveUpM' ::
<span class="lineno"> 4413 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 4414 </span>  prx ps -&gt; RAssign f ps1 -&gt; ExprVar a -&gt; RAssign f ps2 -&gt;
<span class="lineno"> 4415 </span>  ImplM vars s r ((ps :++: ps1) :++: (RNil :&gt; a :++: ps2))
<span class="lineno"> 4416 </span>                 ((ps :&gt; a :++: ps1) :++: ps2) ()
<span class="lineno"> 4417 </span><span class="decl"><span class="nottickedoff">implMoveUpM' (ps :: prx ps) (ps1 :: RAssign f ps1) (x :: ExprVar a)</span>
<span class="lineno"> 4418 </span><span class="spaces">             </span><span class="nottickedoff">(ps2 :: RAssign f ps2)</span>
<span class="lineno"> 4419 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: build these proofs instead of just coercing them</span>
<span class="lineno"> 4420 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- unsafeCoerce reflU ::</span>
<span class="lineno"> 4421 </span><span class="spaces">      </span><span class="nottickedoff">((ps :++: ps1) :++: (RNil :&gt; a :++: ps2)) :~: (ps :++: ps1 :&gt; a :++: ps2)</span>
<span class="lineno"> 4422 </span><span class="spaces">  </span><span class="nottickedoff">, Refl &lt;- (unsafeCoerce reflU) ::</span>
<span class="lineno"> 4423 </span><span class="spaces">      </span><span class="nottickedoff">((ps :&gt; a :++: ps1) :++: ps2) :~: (ps :&gt; a :++: ps1 :++: ps2) =</span>
<span class="lineno"> 4424 </span><span class="spaces">    </span><span class="nottickedoff">implMoveUpM ps ps1 x ps2</span></span>
<span class="lineno"> 4425 </span>
<span class="lineno"> 4426 </span>-- | Move permission @p@ that is on the stack between two lists @ps1@ and @ps2@
<span class="lineno"> 4427 </span>-- towards the bottom of the stack by moving it below both @ps1@ and @ps2@. That
<span class="lineno"> 4428 </span>-- is, change the stack
<span class="lineno"> 4429 </span>--
<span class="lineno"> 4430 </span>-- &gt; perms, p1_1, ..., p1_n, p, p2_1, ..., p2_m
<span class="lineno"> 4431 </span>--
<span class="lineno"> 4432 </span>-- to
<span class="lineno"> 4433 </span>--
<span class="lineno"> 4434 </span>-- &gt; perms, p, p1_1, ..., p1_n, p2_1, ..., p2_m
<span class="lineno"> 4435 </span>implMoveDownM ::
<span class="lineno"> 4436 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 4437 </span>  prx ps -&gt; RAssign f (ps1 :&gt; a) -&gt; ExprVar a -&gt; RAssign f ps2 -&gt;
<span class="lineno"> 4438 </span>  ImplM vars s r (ps :&gt; a :++: ps1 :++: ps2) (ps :++: ps1 :&gt; a :++: ps2) ()
<span class="lineno"> 4439 </span><span class="decl"><span class="nottickedoff">implMoveDownM (ps :: prx ps) ps1x (x :: ExprVar a) ps2 =</span>
<span class="lineno"> 4440 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: this is gross! Find a better way to do all this!</span>
<span class="lineno"> 4441 </span><span class="spaces">  </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 4442 </span><span class="spaces">  </span><span class="nottickedoff">let (_, perms1x2) = splitDistPerms ps (RL.append ps1x ps2) perms</span>
<span class="lineno"> 4443 </span><span class="spaces">      </span><span class="nottickedoff">(perms1x, perms2) = splitDistPerms ps1x ps2 perms1x2 in</span>
<span class="lineno"> 4444 </span><span class="spaces">  </span><span class="nottickedoff">case (perms1x, RL.appendRNilConsEq ps (RL.head ps1x) (RL.append</span>
<span class="lineno"> 4445 </span><span class="spaces">                                                        </span><span class="nottickedoff">(RL.tail ps1x) ps2)) of</span>
<span class="lineno"> 4446 </span><span class="spaces">    </span><span class="nottickedoff">(DistPermsCons perms1 x' p, Refl)</span>
<span class="lineno"> 4447 </span><span class="spaces">      </span><span class="nottickedoff">| Just Refl &lt;- testEquality x x' -&gt;</span>
<span class="lineno"> 4448 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM (Proxy :: Proxy ps) (SImpl_MoveDown perms1 x p perms2)</span>
<span class="lineno"> 4449 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;implMoveDownM: unexpected variable&quot;</span></span>
<span class="lineno"> 4450 </span>
<span class="lineno"> 4451 </span>-- | Same as 'implMoveDownM' except the type lists are associated differently
<span class="lineno"> 4452 </span>implMoveDownM' ::
<span class="lineno"> 4453 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 4454 </span>  prx ps -&gt; RAssign f (ps1 :&gt; a) -&gt; ExprVar a -&gt; RAssign f ps2 -&gt;
<span class="lineno"> 4455 </span>  ImplM vars s r ((ps :&gt; a :++: ps1) :++: ps2)
<span class="lineno"> 4456 </span>                 ((ps :++: ps1) :++: (RNil :&gt; a :++: ps2)) ()
<span class="lineno"> 4457 </span><span class="decl"><span class="nottickedoff">implMoveDownM' (ps :: prx ps) (ps1x :: RAssign f (ps1 :&gt; a)) (x :: ExprVar a)</span>
<span class="lineno"> 4458 </span><span class="spaces">               </span><span class="nottickedoff">(ps2 :: RAssign f ps2)</span>
<span class="lineno"> 4459 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: build these proofs instead of just coercing them</span>
<span class="lineno"> 4460 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- unsafeCoerce reflU ::</span>
<span class="lineno"> 4461 </span><span class="spaces">      </span><span class="nottickedoff">((ps :&gt; a :++: ps1) :++: ps2) :~: (ps :&gt; a :++: ps1 :++: ps2)</span>
<span class="lineno"> 4462 </span><span class="spaces">  </span><span class="nottickedoff">, Refl &lt;- unsafeCoerce reflU ::</span>
<span class="lineno"> 4463 </span><span class="spaces">      </span><span class="nottickedoff">((ps :++: ps1) :++: (RNil :&gt; a :++: ps2)) :~: (ps :++: ps1 :&gt; a :++: ps2)</span>
<span class="lineno"> 4464 </span><span class="spaces">  </span><span class="nottickedoff">= implMoveDownM ps ps1x x ps2</span></span>
<span class="lineno"> 4465 </span>
<span class="lineno"> 4466 </span>-- | Eliminate disjunctives and existentials on the top of the stack and return
<span class="lineno"> 4467 </span>-- the resulting permission
<span class="lineno"> 4468 </span>elimOrsExistsM :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4469 </span>                  ImplM vars s r (ps :&gt; a) (ps :&gt; a) (ValuePerm a)
<span class="lineno"> 4470 </span><span class="decl"><span class="nottickedoff">elimOrsExistsM x =</span>
<span class="lineno"> 4471 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;= \case</span>
<span class="lineno"> 4472 </span><span class="spaces">    </span><span class="nottickedoff">p@(ValPerm_Or _ _) -&gt; implElimOrsM x p &gt;&gt;&gt; elimOrsExistsM x</span>
<span class="lineno"> 4473 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Exists mb_p -&gt;</span>
<span class="lineno"> 4474 </span><span class="spaces">      </span><span class="nottickedoff">implElimExistsM x mb_p &gt;&gt;&gt; elimOrsExistsM x</span>
<span class="lineno"> 4475 </span><span class="spaces">    </span><span class="nottickedoff">p -&gt; pure p</span></span>
<span class="lineno"> 4476 </span>
<span class="lineno"> 4477 </span>-- | Eliminate disjunctives, existentials, recusive permissions, and
<span class="lineno"> 4478 </span>-- defined permissions on the top of the stack
<span class="lineno"> 4479 </span>elimOrsExistsNamesM :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4480 </span>                       ImplM vars s r (ps :&gt; a) (ps :&gt; a) (ValuePerm a)
<span class="lineno"> 4481 </span><span class="decl"><span class="nottickedoff">elimOrsExistsNamesM x =</span>
<span class="lineno"> 4482 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;= \case</span>
<span class="lineno"> 4483 </span><span class="spaces">    </span><span class="nottickedoff">p@(ValPerm_Or _ _) -&gt; implElimOrsM x p &gt;&gt;&gt; elimOrsExistsNamesM x</span>
<span class="lineno"> 4484 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Exists mb_p -&gt;</span>
<span class="lineno"> 4485 </span><span class="spaces">      </span><span class="nottickedoff">implElimExistsM x mb_p &gt;&gt;&gt; elimOrsExistsNamesM x</span>
<span class="lineno"> 4486 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Named npn args off</span>
<span class="lineno"> 4487 </span><span class="spaces">      </span><span class="nottickedoff">| TrueRepr &lt;- nameCanFoldRepr npn -&gt;</span>
<span class="lineno"> 4488 </span><span class="spaces">        </span><span class="nottickedoff">implUnfoldNamedM x npn args off &gt;&gt;&gt; elimOrsExistsNamesM x</span>
<span class="lineno"> 4489 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Named npn args off</span>
<span class="lineno"> 4490 </span><span class="spaces">      </span><span class="nottickedoff">| TrueRepr &lt;- nameIsConjRepr npn -&gt;</span>
<span class="lineno"> 4491 </span><span class="spaces">        </span><span class="nottickedoff">implNamedToConjM x npn args off &gt;&gt;&gt; getTopDistPerm x</span>
<span class="lineno"> 4492 </span><span class="spaces">    </span><span class="nottickedoff">p -&gt; pure p</span></span>
<span class="lineno"> 4493 </span>
<span class="lineno"> 4494 </span>-- | Eliminate any disjunctions, existentials, recursive permissions, or defined
<span class="lineno"> 4495 </span>-- permissions for a variable and then return the resulting \&quot;simple\&quot; permission
<span class="lineno"> 4496 </span>getSimpleVarPerm :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4497 </span>                    ImplM vars s r ps ps (ValuePerm a)
<span class="lineno"> 4498 </span><span class="decl"><span class="nottickedoff">getSimpleVarPerm x =</span>
<span class="lineno"> 4499 </span><span class="spaces">  </span><span class="nottickedoff">getPerm x &gt;&gt;= \p_init -&gt;</span>
<span class="lineno"> 4500 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p_init &gt;&gt;&gt;</span>
<span class="lineno"> 4501 </span><span class="spaces">  </span><span class="nottickedoff">elimOrsExistsNamesM x &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 4502 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x p &gt;&gt;&gt; pure p</span></span>
<span class="lineno"> 4503 </span>
<span class="lineno"> 4504 </span>-- | Eliminate any disjunctions, existentials, recursive permissions, or defined
<span class="lineno"> 4505 </span>-- permissions for a variable to try to get an equality permission
<span class="lineno"> 4506 </span>-- @eq(e)@. Return @e@ if this is successful.
<span class="lineno"> 4507 </span>getVarEqPerm :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4508 </span>                ImplM vars s r ps ps (Maybe (PermExpr a))
<span class="lineno"> 4509 </span><span class="decl"><span class="nottickedoff">getVarEqPerm x =</span>
<span class="lineno"> 4510 </span><span class="spaces">  </span><span class="nottickedoff">getPerm x &gt;&gt;= \p_init -&gt;</span>
<span class="lineno"> 4511 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p_init &gt;&gt;&gt;</span>
<span class="lineno"> 4512 </span><span class="spaces">  </span><span class="nottickedoff">elimOrsExistsNamesM x &gt;&gt;&gt;=</span>
<span class="lineno"> 4513 </span><span class="spaces">  </span><span class="nottickedoff">\case</span>
<span class="lineno"> 4514 </span><span class="spaces">    </span><span class="nottickedoff">p@(ValPerm_Eq e) -&gt; implPopM x p &gt;&gt;&gt; pure (Just e)</span>
<span class="lineno"> 4515 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Conj [Perm_Struct ps] -&gt;</span>
<span class="lineno"> 4516 </span><span class="spaces">      </span><span class="nottickedoff">implElimStructAllFields x ps &gt;&gt;&gt;= \ys -&gt;</span>
<span class="lineno"> 4517 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_StructPermToEq x $ namesToExprs ys) &gt;&gt;&gt;</span>
<span class="lineno"> 4518 </span><span class="spaces">      </span><span class="nottickedoff">implPopM x (ValPerm_Eq $ PExpr_Struct $ namesToExprs ys) &gt;&gt;&gt;</span>
<span class="lineno"> 4519 </span><span class="spaces">      </span><span class="nottickedoff">pure (Just $ PExpr_Struct $ namesToExprs ys)</span>
<span class="lineno"> 4520 </span><span class="spaces">    </span><span class="nottickedoff">p -&gt; implPopM x p &gt;&gt;&gt; pure Nothing</span></span>
<span class="lineno"> 4521 </span>
<span class="lineno"> 4522 </span>-- | Eliminate any disjunctions, existentials, recursive permissions, or defined
<span class="lineno"> 4523 </span>-- permissions for any variables in the supplied expression and substitute any
<span class="lineno"> 4524 </span>-- equality permissions for those variables. Also eta-expand any struct
<span class="lineno"> 4525 </span>-- variables to a struct of variables using 'implElimStructAllFields'.
<span class="lineno"> 4526 </span>getEqualsExpr :: NuMatchingAny1 r =&gt; PermExpr a -&gt;
<span class="lineno"> 4527 </span>                 ImplM vars s r ps ps (PermExpr a)
<span class="lineno"> 4528 </span><span class="decl"><span class="nottickedoff">getEqualsExpr e@(PExpr_Var x) =</span>
<span class="lineno"> 4529 </span><span class="spaces">  </span><span class="nottickedoff">getVarEqPerm x &gt;&gt;= \case Just e' -&gt; getEqualsExpr e'</span>
<span class="lineno"> 4530 </span><span class="spaces">                           </span><span class="nottickedoff">Nothing -&gt; pure e</span>
<span class="lineno"> 4531 </span><span class="spaces"></span><span class="nottickedoff">getEqualsExpr (PExpr_BV factors off) =</span>
<span class="lineno"> 4532 </span><span class="spaces">  </span><span class="nottickedoff">foldr bvAdd (PExpr_BV [] off) &lt;$&gt;</span>
<span class="lineno"> 4533 </span><span class="spaces">  </span><span class="nottickedoff">mapM (\(BVFactor (BV.BV i) x) -&gt;</span>
<span class="lineno"> 4534 </span><span class="spaces">         </span><span class="nottickedoff">bvMult i &lt;$&gt; getEqualsExpr (PExpr_Var x)) factors</span>
<span class="lineno"> 4535 </span><span class="spaces"></span><span class="nottickedoff">getEqualsExpr (PExpr_LLVMWord e) =</span>
<span class="lineno"> 4536 </span><span class="spaces">  </span><span class="nottickedoff">PExpr_LLVMWord &lt;$&gt; getEqualsExpr e</span>
<span class="lineno"> 4537 </span><span class="spaces"></span><span class="nottickedoff">getEqualsExpr (PExpr_LLVMOffset x off) =</span>
<span class="lineno"> 4538 </span><span class="spaces">  </span><span class="nottickedoff">addLLVMOffset &lt;$&gt; getEqualsExpr (PExpr_Var x) &lt;*&gt; getEqualsExpr off</span>
<span class="lineno"> 4539 </span><span class="spaces"></span><span class="nottickedoff">getEqualsExpr e = pure e</span></span>
<span class="lineno"> 4540 </span>
<span class="lineno"> 4541 </span>
<span class="lineno"> 4542 </span>-- | Introduce a proof of @x:eq(x)@ onto the top of the stack
<span class="lineno"> 4543 </span>introEqReflM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 4544 </span><span class="decl"><span class="nottickedoff">introEqReflM x = implSimplM Proxy (SImpl_IntroEqRefl x)</span></span>
<span class="lineno"> 4545 </span>
<span class="lineno"> 4546 </span>-- | Invert a proof of @x:eq(y)@ on the top of the stack to one of @y:eq(x)@
<span class="lineno"> 4547 </span>invertEqM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ExprVar a -&gt;
<span class="lineno"> 4548 </span>             ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4549 </span><span class="decl"><span class="nottickedoff">invertEqM x y = implSimplM Proxy (SImpl_InvertEq x y)</span></span>
<span class="lineno"> 4550 </span>
<span class="lineno"> 4551 </span>-- | Prove @x:eq(y)@ by proving equality permissions for both @x@ and @y@ to the
<span class="lineno"> 4552 </span>-- same expression, thereby implementing a form of transitivity of equality
<span class="lineno"> 4553 </span>-- where the second equality is inversted:
<span class="lineno"> 4554 </span>invTransEqM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno"> 4555 </span>               ImplM vars s r (ps :&gt; a) (ps :&gt; a :&gt; a) ()
<span class="lineno"> 4556 </span><span class="decl"><span class="nottickedoff">invTransEqM x y e = implSimplM Proxy (SImpl_InvTransEq x y e)</span></span>
<span class="lineno"> 4557 </span>
<span class="lineno"> 4558 </span>
<span class="lineno"> 4559 </span>-- | For a unit variable @x@ and a unit-typed epxression @e@, prove @x:eq(e)@
<span class="lineno"> 4560 </span>unitEqM :: NuMatchingAny1 r =&gt; ExprVar UnitType -&gt; PermExpr UnitType -&gt;
<span class="lineno"> 4561 </span>           ImplM vars s r (ps :&gt; UnitType) ps ()
<span class="lineno"> 4562 </span><span class="decl"><span class="nottickedoff">unitEqM x e = implSimplM Proxy (SImpl_UnitEq x e)</span></span>
<span class="lineno"> 4563 </span>
<span class="lineno"> 4564 </span>
<span class="lineno"> 4565 </span>-- | Copy an @x:eq(e)@ permission on the top of the stack
<span class="lineno"> 4566 </span>introEqCopyM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno"> 4567 </span>                ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4568 </span><span class="decl"><span class="nottickedoff">introEqCopyM x e = implSimplM Proxy (SImpl_CopyEq x e)</span></span>
<span class="lineno"> 4569 </span>
<span class="lineno"> 4570 </span>-- | Cast an @eq(llvmword(y))@ proof to an @eq(llvmword(e))@ proof using a
<span class="lineno"> 4571 </span>-- proof of @y:eq(e)@
<span class="lineno"> 4572 </span>llvmWordEqM :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4573 </span>               ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4574 </span>               ExprVar (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4575 </span>               ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 4576 </span>               (ps :&gt; LLVMPointerType w :&gt; BVType w) ()
<span class="lineno"> 4577 </span><span class="decl"><span class="nottickedoff">llvmWordEqM x y e = implSimplM Proxy (SImpl_LLVMWordEq x y e)</span></span>
<span class="lineno"> 4578 </span>
<span class="lineno"> 4579 </span>-- | Cast a @y:p@ perm on the top of the stack to an @x:p@ perm using an
<span class="lineno"> 4580 </span>-- @x:eq(y)@ just below it on the stack
<span class="lineno"> 4581 </span>introCastM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4582 </span>              ImplM vars s r (ps :&gt; a) (ps :&gt; a :&gt; a) ()
<span class="lineno"> 4583 </span><span class="decl"><span class="nottickedoff">introCastM x y p = implSimplM Proxy (SImpl_Cast x y p)</span></span>
<span class="lineno"> 4584 </span>
<span class="lineno"> 4585 </span>-- | Prove a sequence of equality permissions @x1:eq(e1),...,xn:eq(en)@, where
<span class="lineno"> 4586 </span>-- each is proved either by reflexivity, if it is of the form @x:eq(x)@, or by
<span class="lineno"> 4587 </span>-- copying an equality permission already held by the variable in quesiton, if
<span class="lineno"> 4588 </span>-- it is not. It is an error if any of the supplied perms are not equality
<span class="lineno"> 4589 </span>-- perms, or if any @xi@ does not have permission @eq(ei)@ in the current
<span class="lineno"> 4590 </span>-- permission set for @ei@ not equal to @xi@.
<span class="lineno"> 4591 </span>implProveEqPerms :: NuMatchingAny1 r =&gt; HasCallStack =&gt; DistPerms ps' -&gt;
<span class="lineno"> 4592 </span>                    ImplM vars s r (ps :++: (RNil :&gt; a :++: ps')) (ps :&gt; a) ()
<span class="lineno"> 4593 </span><span class="decl"><span class="nottickedoff">implProveEqPerms DistPermsNil = pure ()</span>
<span class="lineno"> 4594 </span><span class="spaces"></span><span class="nottickedoff">implProveEqPerms (DistPermsCons ps' x (ValPerm_Eq (PExpr_Var y)))</span>
<span class="lineno"> 4595 </span><span class="spaces">  </span><span class="nottickedoff">| x == y</span>
<span class="lineno"> 4596 </span><span class="spaces">  </span><span class="nottickedoff">= implProveEqPerms ps' &gt;&gt;&gt; introEqReflM x</span>
<span class="lineno"> 4597 </span><span class="spaces"></span><span class="nottickedoff">implProveEqPerms (DistPermsCons ps' x (ValPerm_Eq (PExpr_LLVMOffset y off)))</span>
<span class="lineno"> 4598 </span><span class="spaces">  </span><span class="nottickedoff">| x == y, bvMatchConstInt off == Just 0</span>
<span class="lineno"> 4599 </span><span class="spaces">  </span><span class="nottickedoff">= implProveEqPerms ps' &gt;&gt;&gt; implSimplM Proxy (SImpl_LLVMOffsetZeroEq x)</span>
<span class="lineno"> 4600 </span><span class="spaces"></span><span class="nottickedoff">implProveEqPerms (DistPermsCons ps' x p@(ValPerm_Eq _)) =</span>
<span class="lineno"> 4601 </span><span class="spaces">  </span><span class="nottickedoff">implProveEqPerms ps' &gt;&gt;&gt; implPushCopyM x p</span>
<span class="lineno"> 4602 </span><span class="spaces"></span><span class="nottickedoff">implProveEqPerms _ = error &quot;implProveEqPerms: non-equality permission&quot;</span></span>
<span class="lineno"> 4603 </span>
<span class="lineno"> 4604 </span>-- | Cast a proof of @x:p@ to one of @x:p'@ using a proof that @p=p'@
<span class="lineno"> 4605 </span>implCastPermM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4606 </span>                 Proxy ps -&gt; ExprVar a -&gt; SomeEqProof (ValuePerm a) -&gt;
<span class="lineno"> 4607 </span>                 ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4608 </span><span class="decl"><span class="nottickedoff">implCastPermM ps x some_eqp</span>
<span class="lineno"> 4609 </span><span class="spaces">  </span><span class="nottickedoff">| UnSomeEqProof eqp &lt;- unSomeEqProof some_eqp</span>
<span class="lineno"> 4610 </span><span class="spaces">  </span><span class="nottickedoff">, Refl &lt;- RL.appendAssoc ps (MNil :&gt;: eqProofLHS eqp) (eqProofPerms eqp) =</span>
<span class="lineno"> 4611 </span><span class="spaces">    </span><span class="nottickedoff">implProveEqPerms (eqProofPerms eqp) &gt;&gt;&gt;</span>
<span class="lineno"> 4612 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM ps (SImpl_CastPerm x eqp) &gt;&gt;&gt;</span>
<span class="lineno"> 4613 </span><span class="spaces">    </span><span class="nottickedoff">implDropMultiM (eqProofPerms eqp)</span></span>
<span class="lineno"> 4614 </span>
<span class="lineno"> 4615 </span>distPermsProxy :: DistPerms ps -&gt; Proxy ps
<span class="lineno"> 4616 </span><span class="decl"><span class="nottickedoff">distPermsProxy _ = Proxy</span></span>
<span class="lineno"> 4617 </span>
<span class="lineno"> 4618 </span>-- | Cast a permission somewhere in the stack using an equality proof
<span class="lineno"> 4619 </span>implCastStackElemM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; Member ps a -&gt;
<span class="lineno"> 4620 </span>                      EqProof ps' (ValuePerm a) -&gt;
<span class="lineno"> 4621 </span>                      ImplM vars s r (ps :++: ps') (ps :++: ps') ()
<span class="lineno"> 4622 </span><span class="decl"><span class="nottickedoff">implCastStackElemM memb eqp =</span>
<span class="lineno"> 4623 </span><span class="spaces">  </span><span class="nottickedoff">let ps' = eqProofPerms eqp in</span>
<span class="lineno"> 4624 </span><span class="spaces">  </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \all_perms -&gt;</span>
<span class="lineno"> 4625 </span><span class="spaces">  </span><span class="nottickedoff">let ps = fst $ RL.split Proxy ps' all_perms in</span>
<span class="lineno"> 4626 </span><span class="spaces">  </span><span class="nottickedoff">case RL.memberSplitAt ps memb of</span>
<span class="lineno"> 4627 </span><span class="spaces">    </span><span class="nottickedoff">RL.SplitAtMemberRet ps0 px@(VarAndPerm x _) ps1 -&gt;</span>
<span class="lineno"> 4628 </span><span class="spaces">      </span><span class="nottickedoff">implMoveUpM' ps0 ps1 x ps' &gt;&gt;&gt;</span>
<span class="lineno"> 4629 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM (distPermsProxy $ RL.append ps0 ps1) (SImpl_CastPerm x eqp) &gt;&gt;&gt;</span>
<span class="lineno"> 4630 </span><span class="spaces">      </span><span class="nottickedoff">implMoveDownM' ps0 (ps1 :&gt;: px) x ps'</span></span>
<span class="lineno"> 4631 </span>
<span class="lineno"> 4632 </span>-- | Cast all of the permissions on the stack using 'implCastPermM'
<span class="lineno"> 4633 </span>implCastStackM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4634 </span>                  EqProof ps' (ValuePerms ps) -&gt;
<span class="lineno"> 4635 </span>                  ImplM vars s r ps (ps :++: ps') ()
<span class="lineno"> 4636 </span><span class="decl"><span class="nottickedoff">implCastStackM eqp =</span>
<span class="lineno"> 4637 </span><span class="spaces">  </span><span class="nottickedoff">RL.foldr (\memb m -&gt;</span>
<span class="lineno"> 4638 </span><span class="spaces">             </span><span class="nottickedoff">implCastStackElemM memb (fmap (RL.get memb) eqp) &gt;&gt;&gt; m)</span>
<span class="lineno"> 4639 </span><span class="spaces">  </span><span class="nottickedoff">(implDropMultiM (eqProofPerms eqp))</span>
<span class="lineno"> 4640 </span><span class="spaces">  </span><span class="nottickedoff">(RL.members $ eqProofLHS eqp)</span></span>
<span class="lineno"> 4641 </span>
<span class="lineno"> 4642 </span>-- | Introduce a proof of @x:true@ onto the top of the stack, which is the same
<span class="lineno"> 4643 </span>-- as an empty conjunction
<span class="lineno"> 4644 </span>introConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4645 </span>              ExprVar a -&gt; ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 4646 </span><span class="decl"><span class="nottickedoff">introConjM x = implSimplM Proxy (SImpl_IntroConj x)</span></span>
<span class="lineno"> 4647 </span>
<span class="lineno"> 4648 </span>-- | Extract the @i@th atomic permission from the conjunct on the top of the
<span class="lineno"> 4649 </span>-- stack and put it just below the top of the stack
<span class="lineno"> 4650 </span>implExtractConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4651 </span>                    ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4652 </span>                    ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4653 </span><span class="decl"><span class="nottickedoff">implExtractConjM x ps i = implSimplM Proxy (SImpl_ExtractConj x ps i)</span></span>
<span class="lineno"> 4654 </span>
<span class="lineno"> 4655 </span>-- | Extract the @i@th atomic permission from the conjunct on the top of the
<span class="lineno"> 4656 </span>-- stack and push it to the top of the stack; i.e., call 'implExtractConjM' and
<span class="lineno"> 4657 </span>-- then swap the top two stack elements
<span class="lineno"> 4658 </span>implExtractSwapConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4659 </span>                        ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4660 </span>                        ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4661 </span><span class="decl"><span class="nottickedoff">implExtractSwapConjM x ps i =</span>
<span class="lineno"> 4662 </span><span class="spaces">  </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 4663 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x (ValPerm_Conj1 $ ps!!i) x (ValPerm_Conj $ deleteNth i ps)</span></span>
<span class="lineno"> 4664 </span>
<span class="lineno"> 4665 </span>-- | Combine the top two conjunctive permissions on the stack
<span class="lineno"> 4666 </span>implAppendConjsM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4667 </span>                    [AtomicPerm a] -&gt; [AtomicPerm a] -&gt;
<span class="lineno"> 4668 </span>                    ImplM vars s r (ps :&gt; a) (ps :&gt; a :&gt; a) ()
<span class="lineno"> 4669 </span><span class="decl"><span class="nottickedoff">implAppendConjsM x ps1 ps2 = implSimplM Proxy (SImpl_AppendConjs x ps1 ps2)</span></span>
<span class="lineno"> 4670 </span>
<span class="lineno"> 4671 </span>-- | Split the conjuctive permissions on the top of the stack into the first @i@
<span class="lineno"> 4672 </span>-- and the remaining conjuncts after those
<span class="lineno"> 4673 </span>implSplitConjsM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4674 </span>                   ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4675 </span>                   ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4676 </span><span class="decl"><span class="nottickedoff">implSplitConjsM x ps i = implSimplM Proxy (SImpl_SplitConjs x ps i)</span></span>
<span class="lineno"> 4677 </span>
<span class="lineno"> 4678 </span>-- | Split the conjuctive permissions on the top of the stack into the first @i@
<span class="lineno"> 4679 </span>-- and the remaining conjuncts after those, and then swap them
<span class="lineno"> 4680 </span>implSplitSwapConjsM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4681 </span>                       ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4682 </span>                       ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4683 </span><span class="decl"><span class="nottickedoff">implSplitSwapConjsM x ps i =</span>
<span class="lineno"> 4684 </span><span class="spaces">  </span><span class="nottickedoff">implSplitConjsM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 4685 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x (ValPerm_Conj $ take i ps) x (ValPerm_Conj $ drop i ps)</span></span>
<span class="lineno"> 4686 </span>
<span class="lineno"> 4687 </span>-- | Copy the @i@th atomic permission in the conjunct on the top of the stack,
<span class="lineno"> 4688 </span>-- assuming that conjunction contains the given atomic permissions and that the
<span class="lineno"> 4689 </span>-- given conjunct is copyable, and put the copied atomic permission just below
<span class="lineno"> 4690 </span>-- the top of the stack
<span class="lineno"> 4691 </span>implCopyConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4692 </span>                 ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4693 </span>                 ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4694 </span><span class="decl"><span class="nottickedoff">implCopyConjM x ps i = implSimplM Proxy (SImpl_CopyConj x ps i)</span></span>
<span class="lineno"> 4695 </span>
<span class="lineno"> 4696 </span>-- | Copy the @i@th atomic permission in the conjunct on the top of the stack
<span class="lineno"> 4697 </span>-- and push it to the top of the stack; i.e., call 'implCopyConjM' and then swap
<span class="lineno"> 4698 </span>-- the top two stack elements
<span class="lineno"> 4699 </span>implCopySwapConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4700 </span>                     ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4701 </span>                     ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4702 </span><span class="decl"><span class="nottickedoff">implCopySwapConjM x ps i =</span>
<span class="lineno"> 4703 </span><span class="spaces">  </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 4704 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x (ValPerm_Conj1 $ ps!!i) x (ValPerm_Conj ps)</span></span>
<span class="lineno"> 4705 </span>
<span class="lineno"> 4706 </span>-- | Either extract or copy the @i@th atomic permission in the conjunct on the
<span class="lineno"> 4707 </span>-- top of the stack, leaving the extracted or copied permission just below the
<span class="lineno"> 4708 </span>-- top of the stack and the remaining other permissions on top of the stack.
<span class="lineno"> 4709 </span>-- Return the list of conjuncts remaining on top of the stack.
<span class="lineno"> 4710 </span>implGetConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4711 </span>                ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4712 </span>                ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) [AtomicPerm a]
<span class="lineno"> 4713 </span><span class="decl"><span class="nottickedoff">implGetConjM x ps i =</span>
<span class="lineno"> 4714 </span><span class="spaces">  </span><span class="nottickedoff">if atomicPermIsCopyable (ps!!i) then</span>
<span class="lineno"> 4715 </span><span class="spaces">    </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt; return ps</span>
<span class="lineno"> 4716 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 4717 </span><span class="spaces">    </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt; return (deleteNth i ps)</span></span>
<span class="lineno"> 4718 </span>
<span class="lineno"> 4719 </span>-- | Either extract or copy the @i@th atomic permission in the conjunct on the
<span class="lineno"> 4720 </span>-- top of the stack, leaving the extracted or copied permission on top of the
<span class="lineno"> 4721 </span>-- stack and the remaining other permissions just below it. Return the list of
<span class="lineno"> 4722 </span>-- conjuncts remaining just below the top of the stack.
<span class="lineno"> 4723 </span>implGetSwapConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4724 </span>                    ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4725 </span>                    ImplM vars s r (ps :&gt; a :&gt; a) (ps :&gt; a) [AtomicPerm a]
<span class="lineno"> 4726 </span><span class="decl"><span class="nottickedoff">implGetSwapConjM x ps i =</span>
<span class="lineno"> 4727 </span><span class="spaces">  </span><span class="nottickedoff">if atomicPermIsCopyable (ps!!i) then</span>
<span class="lineno"> 4728 </span><span class="spaces">    </span><span class="nottickedoff">implCopySwapConjM x ps i &gt;&gt;&gt; return ps</span>
<span class="lineno"> 4729 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 4730 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps i &gt;&gt;&gt; return (deleteNth i ps)</span></span>
<span class="lineno"> 4731 </span>
<span class="lineno"> 4732 </span>-- | Either extract or copy the @i@th atomic permission in the conjunct on the
<span class="lineno"> 4733 </span>-- top of the stack, popping the remaining permissions
<span class="lineno"> 4734 </span>implGetPopConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4735 </span>                   ExprVar a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4736 </span>                   ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4737 </span><span class="decl"><span class="nottickedoff">implGetPopConjM x ps i =</span>
<span class="lineno"> 4738 </span><span class="spaces">  </span><span class="nottickedoff">if atomicPermIsCopyable (ps!!i) then</span>
<span class="lineno"> 4739 </span><span class="spaces">    </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 4740 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x (ValPerm_Conj ps)</span>
<span class="lineno"> 4741 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 4742 </span><span class="spaces">    </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 4743 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x (ValPerm_Conj $ deleteNth i ps)</span></span>
<span class="lineno"> 4744 </span>
<span class="lineno"> 4745 </span>-- | If the top element of the stack is copyable, then copy it and pop it, and
<span class="lineno"> 4746 </span>-- otherwise just leave it alone on top of the stack
<span class="lineno"> 4747 </span>implMaybeCopyPopM :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 4748 </span>                     ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4749 </span>                     ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4750 </span><span class="decl"><span class="nottickedoff">implMaybeCopyPopM x p | permIsCopyable p = implCopyM x p &gt;&gt;&gt; implPopM x p</span>
<span class="lineno"> 4751 </span><span class="spaces"></span><span class="nottickedoff">implMaybeCopyPopM _ _ = pure ()</span></span>
<span class="lineno"> 4752 </span>
<span class="lineno"> 4753 </span>-- | Insert an atomic permission below the top of the stack at the @i@th
<span class="lineno"> 4754 </span>-- position in the conjunct on the top of the stack, where @i@ must be between
<span class="lineno"> 4755 </span>implInsertConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4756 </span>                   AtomicPerm a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4757 </span>                   ImplM vars s r (ps :&gt; a) (ps :&gt; a :&gt; a) ()
<span class="lineno"> 4758 </span><span class="decl"><span class="nottickedoff">implInsertConjM x p ps i = implSimplM Proxy (SImpl_InsertConj x p ps i)</span></span>
<span class="lineno"> 4759 </span>
<span class="lineno"> 4760 </span>-- | Insert an atomic permission on the top of the stack into the @i@th position
<span class="lineno"> 4761 </span>-- in the conjunct below it on the of the stack; that is, swap the top two
<span class="lineno"> 4762 </span>-- permissions and call 'implInsertConjM'
<span class="lineno"> 4763 </span>implSwapInsertConjM :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 4764 </span>                       AtomicPerm a -&gt; [AtomicPerm a] -&gt; Int -&gt;
<span class="lineno"> 4765 </span>                       ImplM vars s r (ps :&gt; a) (ps :&gt; a :&gt; a) ()
<span class="lineno"> 4766 </span><span class="decl"><span class="nottickedoff">implSwapInsertConjM x p ps i =</span>
<span class="lineno"> 4767 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x (ValPerm_Conj ps) x (ValPerm_Conj1 p) &gt;&gt;&gt;</span>
<span class="lineno"> 4768 </span><span class="spaces">  </span><span class="nottickedoff">implInsertConjM x p ps i</span></span>
<span class="lineno"> 4769 </span>
<span class="lineno"> 4770 </span>-- | Apply the left or-introduction rule to the top of the permission stack,
<span class="lineno"> 4771 </span>-- changing it from @x:p1@ to @x:(p1 \/ p2)@
<span class="lineno"> 4772 </span>introOrLM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4773 </span>             ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4774 </span><span class="decl"><span class="nottickedoff">introOrLM x p1 p2 = implSimplM Proxy (SImpl_IntroOrL x p1 p2)</span></span>
<span class="lineno"> 4775 </span>
<span class="lineno"> 4776 </span>-- | Apply the right or-introduction rule to the top of the permission stack,
<span class="lineno"> 4777 </span>-- changing it from @x:p2@ to @x:(p1 \/ p2)@
<span class="lineno"> 4778 </span>introOrRM :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt; ValuePerm a -&gt;
<span class="lineno"> 4779 </span>             ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4780 </span><span class="decl"><span class="nottickedoff">introOrRM x p1 p2 = implSimplM Proxy (SImpl_IntroOrR x p1 p2)</span></span>
<span class="lineno"> 4781 </span>
<span class="lineno"> 4782 </span>-- | Apply existential introduction to the top of the permission stack, changing
<span class="lineno"> 4783 </span>-- it from @[e/x]p@ to @exists (x:tp).p@
<span class="lineno"> 4784 </span>--
<span class="lineno"> 4785 </span>-- FIXME: is there some way we could \&quot;type-check\&quot; this, to ensure that the
<span class="lineno"> 4786 </span>-- permission on the top of the stack really equals @[e/x]p@?
<span class="lineno"> 4787 </span>introExistsM :: (KnownRepr TypeRepr tp, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4788 </span>                ExprVar a -&gt; PermExpr tp -&gt; Binding tp (ValuePerm a) -&gt;
<span class="lineno"> 4789 </span>                ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4790 </span><span class="decl"><span class="nottickedoff">introExistsM x e p_body = implSimplM Proxy (SImpl_IntroExists x e p_body)</span></span>
<span class="lineno"> 4791 </span>
<span class="lineno"> 4792 </span>-- | Cast a proof of @x:eq(LLVMWord(e1))@ to @x:eq(LLVMWord(e2))@ on the top of
<span class="lineno"> 4793 </span>-- the stack
<span class="lineno"> 4794 </span>castLLVMWordEqM ::
<span class="lineno"> 4795 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4796 </span>  ExprVar (LLVMPointerType w) -&gt; PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4797 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 4798 </span><span class="decl"><span class="nottickedoff">castLLVMWordEqM x e1 e2 =</span>
<span class="lineno"> 4799 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProp x (BVProp_Eq e1 e2) &gt;&gt;&gt;</span>
<span class="lineno"> 4800 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_CastLLVMWord x e1 e2)</span></span>
<span class="lineno"> 4801 </span>
<span class="lineno"> 4802 </span>-- | Cast a @y:p@ on the top of the stack to @x:(p - off)@ using a
<span class="lineno"> 4803 </span>-- proof of @x:eq(y+off)@ just below it on the stack
<span class="lineno"> 4804 </span>castLLVMPtrM :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4805 </span>                ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4806 </span>                ValuePerm (LLVMPointerType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4807 </span>                ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4808 </span>                ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 4809 </span>                (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w) ()
<span class="lineno"> 4810 </span><span class="decl"><span class="nottickedoff">castLLVMPtrM y p off x = implSimplM Proxy (SImpl_CastLLVMPtr y p off x)</span></span>
<span class="lineno"> 4811 </span>
<span class="lineno"> 4812 </span>-- | Cast a @y:eq(word(e))@ on the top of the stack to @x:eq(word(e+off))@ using
<span class="lineno"> 4813 </span>-- a proof of @x:eq(y+off)@ just below it on the stack
<span class="lineno"> 4814 </span>offsetLLVMWordM :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4815 </span>                   ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4816 </span>                   PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4817 </span>                   ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4818 </span>                   ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 4819 </span>                   (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w) ()
<span class="lineno"> 4820 </span><span class="decl"><span class="nottickedoff">offsetLLVMWordM y e off x = implSimplM Proxy (SImpl_OffsetLLVMWord y e off x)</span></span>
<span class="lineno"> 4821 </span>
<span class="lineno"> 4822 </span>-- | Cast a proof of @x:free(e1)@ on the top of the stack to one of @x:free(e2)@
<span class="lineno"> 4823 </span>-- by first proving that @e1=e2@
<span class="lineno"> 4824 </span>castLLVMFreeM :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4825 </span>                 ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 4826 </span>                 PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 4827 </span>                 ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 4828 </span>                 (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 4829 </span><span class="decl"><span class="nottickedoff">castLLVMFreeM x e1 e2 =</span>
<span class="lineno"> 4830 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProp x (BVProp_Eq e1 e2) &gt;&gt;&gt;</span>
<span class="lineno"> 4831 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_CastLLVMFree x e1 e2)</span></span>
<span class="lineno"> 4832 </span>
<span class="lineno"> 4833 </span>-- | Fold a named permission (other than an opaque permission)
<span class="lineno"> 4834 </span>implFoldNamedM :: (NameSortCanFold ns ~ 'True, NuMatchingAny1 r) =&gt; ExprVar a -&gt;
<span class="lineno"> 4835 </span>                  NamedPermName ns args a -&gt; PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 4836 </span>                  ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4837 </span><span class="decl"><span class="nottickedoff">implFoldNamedM x npn args off =</span>
<span class="lineno"> 4838 </span><span class="spaces">  </span><span class="nottickedoff">do np &lt;- implLookupNamedPerm npn</span>
<span class="lineno"> 4839 </span><span class="spaces">     </span><span class="nottickedoff">implSimplM Proxy (SImpl_FoldNamed x np args off)</span></span>
<span class="lineno"> 4840 </span>
<span class="lineno"> 4841 </span>-- | Unfold a named permission (other than an opaque permission), returning the
<span class="lineno"> 4842 </span>-- unfolding
<span class="lineno"> 4843 </span>implUnfoldNamedM :: (NameSortCanFold ns ~ 'True, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4844 </span>                    ExprVar a -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 4845 </span>                    PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 4846 </span>                    ImplM vars s r (ps :&gt; a) (ps :&gt; a) (ValuePerm a)
<span class="lineno"> 4847 </span><span class="decl"><span class="nottickedoff">implUnfoldNamedM x npn args off =</span>
<span class="lineno"> 4848 </span><span class="spaces">  </span><span class="nottickedoff">do np &lt;- implLookupNamedPerm npn</span>
<span class="lineno"> 4849 </span><span class="spaces">     </span><span class="nottickedoff">implSimplM Proxy (SImpl_UnfoldNamed x np args off)</span>
<span class="lineno"> 4850 </span><span class="spaces">     </span><span class="nottickedoff">pure (unfoldPerm np args off)</span></span>
<span class="lineno"> 4851 </span>
<span class="lineno"> 4852 </span>-- | Map a named permission that is conjoinable to a conjunction
<span class="lineno"> 4853 </span>implNamedToConjM :: (NameSortIsConj ns ~ 'True, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4854 </span>                    ExprVar a -&gt; NamedPermName ns args a -&gt;
<span class="lineno"> 4855 </span>                    PermExprs args -&gt; PermOffset a -&gt;
<span class="lineno"> 4856 </span>                    ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4857 </span><span class="decl"><span class="nottickedoff">implNamedToConjM x npn args off =</span>
<span class="lineno"> 4858 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedToConj x npn args off)</span></span>
<span class="lineno"> 4859 </span>
<span class="lineno"> 4860 </span>-- | Map a conjuctive named permission to a named permission
<span class="lineno"> 4861 </span>implNamedFromConjM :: (NameSortIsConj ns ~ 'True, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4862 </span>                      ExprVar a -&gt; NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 4863 </span>                      PermOffset a -&gt; ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 4864 </span><span class="decl"><span class="nottickedoff">implNamedFromConjM x npn args off =</span>
<span class="lineno"> 4865 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedFromConj x npn args off)</span></span>
<span class="lineno"> 4866 </span>
<span class="lineno"> 4867 </span>-- | Begin a fresh lifetime, returning the lifetime that was created and popping
<span class="lineno"> 4868 </span>-- its @lowned@ permission off of the stack
<span class="lineno"> 4869 </span>implBeginLifetimeM :: NuMatchingAny1 r =&gt;
<span class="lineno"> 4870 </span>                      ImplM vars s r ps ps (ExprVar LifetimeType)
<span class="lineno"> 4871 </span><span class="decl"><span class="nottickedoff">implBeginLifetimeM =</span>
<span class="lineno"> 4872 </span><span class="spaces">  </span><span class="nottickedoff">implApplyImpl1 Impl1_BeginLifetime</span>
<span class="lineno"> 4873 </span><span class="spaces">    </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (\(_ :&gt;: n) -&gt; pure n)) &gt;&gt;&gt;= \l -&gt;</span>
<span class="lineno"> 4874 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm l (ValPerm_LOwned [] CruCtxNil CruCtxNil MNil MNil) &gt;&gt;&gt;</span>
<span class="lineno"> 4875 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt; pretty &quot;Beginning lifetime:&quot; &lt;+&gt; permPretty i l) &gt;&gt;&gt;</span>
<span class="lineno"> 4876 </span><span class="spaces">  </span><span class="nottickedoff">pure l</span></span>
<span class="lineno"> 4877 </span>
<span class="lineno"> 4878 </span>-- | End a lifetime, assuming the top of the stack is of the form
<span class="lineno"> 4879 </span>--
<span class="lineno"> 4880 </span>-- &gt; ps, ps_in, l:lowned(ps_in -o ps_out)
<span class="lineno"> 4881 </span>--
<span class="lineno"> 4882 </span>-- Remove @l@ from any other @lowned@ permissions held by other variables.
<span class="lineno"> 4883 </span>-- Recombine all the returned permissions @ps_out@ and @l:lfinished@ returned by
<span class="lineno"> 4884 </span>-- ending @l@, leaving just @ps@ on the stack.
<span class="lineno"> 4885 </span>implEndLifetimeM :: NuMatchingAny1 r =&gt; Proxy ps -&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 4886 </span>                    CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 4887 </span>                    ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 4888 </span>                    ImplM vars s r ps (ps :++: ps_in :&gt; LifetimeType) ()
<span class="lineno"> 4889 </span><span class="decl"><span class="nottickedoff">implEndLifetimeM ps l tps_in tps_out ps_in ps_out</span>
<span class="lineno"> 4890 </span><span class="spaces">  </span><span class="nottickedoff">| Just dps_out &lt;- exprPermsToDistPerms ps_out</span>
<span class="lineno"> 4891 </span><span class="spaces">  </span><span class="nottickedoff">, isJust (exprPermsToDistPerms ps_in) =</span>
<span class="lineno"> 4892 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM ps (SImpl_EndLifetime l tps_in tps_out ps_in ps_out) &gt;&gt;&gt;</span>
<span class="lineno"> 4893 </span><span class="spaces">    </span><span class="nottickedoff">implTraceM (\i -&gt; pretty &quot;Ending lifetime:&quot; &lt;+&gt; permPretty i l) &gt;&gt;&gt;</span>
<span class="lineno"> 4894 </span><span class="spaces">    </span><span class="nottickedoff">implDropLifetimePermsM l &gt;&gt;&gt;</span>
<span class="lineno"> 4895 </span><span class="spaces">    </span><span class="nottickedoff">recombinePermsPartial ps (DistPermsCons dps_out l ValPerm_LFinished)</span>
<span class="lineno"> 4896 </span><span class="spaces"></span><span class="nottickedoff">implEndLifetimeM _ _ _ _ _ _ = implFailM (LifetimeError EndLifetimeError)</span></span>
<span class="lineno"> 4897 </span>
<span class="lineno"> 4898 </span>-- | Drop any permissions of the form @x:[l]p@ in the primary permissions for
<span class="lineno"> 4899 </span>-- @x@, which are supplied as an argument
<span class="lineno"> 4900 </span>implDropLifetimeConjsM :: NuMatchingAny1 r =&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 4901 </span>                          ExprVar a -&gt; [AtomicPerm a] -&gt;
<span class="lineno"> 4902 </span>                          ImplM vars s r ps ps ()
<span class="lineno"> 4903 </span><span class="decl"><span class="nottickedoff">implDropLifetimeConjsM l x ps</span>
<span class="lineno"> 4904 </span><span class="spaces">  </span><span class="nottickedoff">| Just i &lt;- findIndex (\p -&gt; atomicPermLifetime p == Just (PExpr_Var l)) ps =</span>
<span class="lineno"> 4905 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 4906 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 4907 </span><span class="spaces">    </span><span class="nottickedoff">implDropM x (ValPerm_Conj1 (ps!!i)) &gt;&gt;&gt;</span>
<span class="lineno"> 4908 </span><span class="spaces">    </span><span class="nottickedoff">let ps' = deleteNth i ps in</span>
<span class="lineno"> 4909 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 4910 </span><span class="spaces">    </span><span class="nottickedoff">implDropLifetimeConjsM l x ps'</span>
<span class="lineno"> 4911 </span><span class="spaces"></span><span class="nottickedoff">implDropLifetimeConjsM _ _ _ = return ()</span></span>
<span class="lineno"> 4912 </span>
<span class="lineno"> 4913 </span>-- | Find all primary permissions of the form @x:[l]p@ and drop them, assuming
<span class="lineno"> 4914 </span>-- that we have just ended lifetime @l@
<span class="lineno"> 4915 </span>implDropLifetimePermsM :: NuMatchingAny1 r =&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 4916 </span>                          ImplM vars s r ps ps ()
<span class="lineno"> 4917 </span><span class="decl"><span class="nottickedoff">implDropLifetimePermsM l =</span>
<span class="lineno"> 4918 </span><span class="spaces">  </span><span class="nottickedoff">(NameMap.assocs &lt;$&gt; view varPermMap &lt;$&gt; getPerms) &gt;&gt;&gt;= \vars_and_perms -&gt;</span>
<span class="lineno"> 4919 </span><span class="spaces">  </span><span class="nottickedoff">forM_ vars_and_perms $ \case</span>
<span class="lineno"> 4920 </span><span class="spaces">  </span><span class="nottickedoff">NameAndElem x (ValPerm_Conj ps) -&gt;</span>
<span class="lineno"> 4921 </span><span class="spaces">    </span><span class="nottickedoff">implDropLifetimeConjsM l x ps</span>
<span class="lineno"> 4922 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; return ()</span></span>
<span class="lineno"> 4923 </span>
<span class="lineno"> 4924 </span>-- | Save a permission for later by splitting it into part that is in the
<span class="lineno"> 4925 </span>-- current lifetime and part that is saved in the lifetime for later. Assume
<span class="lineno"> 4926 </span>-- permissions
<span class="lineno"> 4927 </span>--
<span class="lineno"> 4928 </span>-- &gt; x:F&lt;l&gt; * l:[l2]lcurrent * l2:lowned ps
<span class="lineno"> 4929 </span>--
<span class="lineno"> 4930 </span>-- are on the top of the stack, and return @x:F&lt;l2&gt;@ on top of the stack,
<span class="lineno"> 4931 </span>-- popping the new @lowned@ permission on @l2@
<span class="lineno"> 4932 </span>implSplitLifetimeM :: (KnownRepr TypeRepr a, NuMatchingAny1 r) =&gt;
<span class="lineno"> 4933 </span>                      ExprVar a -&gt; LifetimeFunctor args a -&gt;
<span class="lineno"> 4934 </span>                      PermExprs args -&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 4935 </span>                      ExprVar LifetimeType -&gt; [PermExpr LifetimeType] -&gt;
<span class="lineno"> 4936 </span>                      CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 4937 </span>                      ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 4938 </span>                      ImplM vars s r (ps :&gt; a)
<span class="lineno"> 4939 </span>                      (ps :&gt; a :&gt; LifetimeType :&gt; LifetimeType) ()
<span class="lineno"> 4940 </span><span class="decl"><span class="nottickedoff">implSplitLifetimeM x f args l l2 sub_ls tps_in tps_out ps_in ps_out =</span>
<span class="lineno"> 4941 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 4942 </span><span class="spaces">               </span><span class="nottickedoff">sep [pretty &quot;Splitting lifetime to&quot; &lt;+&gt; permPretty i l2 &lt;&gt; colon,</span>
<span class="lineno"> 4943 </span><span class="spaces">                    </span><span class="nottickedoff">permPretty i x &lt;&gt; colon &lt;&gt;</span>
<span class="lineno"> 4944 </span><span class="spaces">                    </span><span class="nottickedoff">permPretty i (ltFuncMinApply f l)]) &gt;&gt;&gt;</span>
<span class="lineno"> 4945 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_SplitLifetime x f args l l2</span>
<span class="lineno"> 4946 </span><span class="spaces">                    </span><span class="nottickedoff">sub_ls tps_in tps_out ps_in ps_out) &gt;&gt;&gt;</span>
<span class="lineno"> 4947 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistPerm l2 &gt;&gt;&gt;= recombinePerm l2</span></span>
<span class="lineno"> 4948 </span>
<span class="lineno"> 4949 </span>
<span class="lineno"> 4950 </span>-- | Subsume a smaller lifetime @l2@ inside a bigger lifetime @l1@, by adding
<span class="lineno"> 4951 </span>-- @l2@ to the lifetimes contained in the @lowned@ permission for @l@. Assume
<span class="lineno"> 4952 </span>-- the top of the stack is @l1:lowned[ls] (ps_in1 -o ps_out1)@, and replace that
<span class="lineno"> 4953 </span>-- permission with @l1:lowned[l2,ls] (ps_in1 -o ps_out1)@.
<span class="lineno"> 4954 </span>implSubsumeLifetimeM :: NuMatchingAny1 r =&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 4955 </span>                        [PermExpr LifetimeType] -&gt;
<span class="lineno"> 4956 </span>                        CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 4957 </span>                        ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 4958 </span>                        PermExpr LifetimeType -&gt;
<span class="lineno"> 4959 </span>                        ImplM vars s r (ps :&gt; LifetimeType)
<span class="lineno"> 4960 </span>                        (ps :&gt; LifetimeType) ()
<span class="lineno"> 4961 </span><span class="decl"><span class="nottickedoff">implSubsumeLifetimeM l ls tps_in tps_out ps_in ps_out l2 =</span>
<span class="lineno"> 4962 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_SubsumeLifetime l ls tps_in tps_out ps_in ps_out l2)</span></span>
<span class="lineno"> 4963 </span>
<span class="lineno"> 4964 </span>
<span class="lineno"> 4965 </span>-- | Prove a lifetime @l@ is current during a lifetime @l2@ it contains,
<span class="lineno"> 4966 </span>-- assuming the permission
<span class="lineno"> 4967 </span>--
<span class="lineno"> 4968 </span>-- &gt; l1:lowned[ls1,l2,ls2] (ps_in -o ps_out)
<span class="lineno"> 4969 </span>--
<span class="lineno"> 4970 </span>-- is on top of the stack, and replacing it with @l1:[l2]lcurrent@.
<span class="lineno"> 4971 </span>implContainedLifetimeCurrentM :: NuMatchingAny1 r =&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 4972 </span>                                 [PermExpr LifetimeType] -&gt;
<span class="lineno"> 4973 </span>                                 CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 4974 </span>                                 ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 4975 </span>                                 PermExpr LifetimeType -&gt;
<span class="lineno"> 4976 </span>                                 ImplM vars s r (ps :&gt; LifetimeType)
<span class="lineno"> 4977 </span>                                 (ps :&gt; LifetimeType) ()
<span class="lineno"> 4978 </span><span class="decl"><span class="nottickedoff">implContainedLifetimeCurrentM l ls tps_in tps_out ps_in ps_out l2 =</span>
<span class="lineno"> 4979 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ContainedLifetimeCurrent</span>
<span class="lineno"> 4980 </span><span class="spaces">                    </span><span class="nottickedoff">l ls tps_in tps_out ps_in ps_out l2) &gt;&gt;&gt;</span>
<span class="lineno"> 4981 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm l (ValPerm_LOwned ls tps_in tps_out ps_in ps_out)</span></span>
<span class="lineno"> 4982 </span>
<span class="lineno"> 4983 </span>
<span class="lineno"> 4984 </span>-- | Remove a finshed contained lifetime from an @lowned@ permission. Assume the
<span class="lineno"> 4985 </span>-- permissions
<span class="lineno"> 4986 </span>--
<span class="lineno"> 4987 </span>-- &gt; l1:lowned[ls] (ps_in -o ps_out) * l2:lfinished
<span class="lineno"> 4988 </span>--
<span class="lineno"> 4989 </span>-- are on top of the stack where @l2@ is in @ls@, and remove @l2@ from the
<span class="lineno"> 4990 </span>-- contained lifetimes @ls@ of @l1@, popping the resulting @lowned@ permission
<span class="lineno"> 4991 </span>-- on @l1@ off of the stack.
<span class="lineno"> 4992 </span>implRemoveContainedLifetimeM :: NuMatchingAny1 r =&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 4993 </span>                                [PermExpr LifetimeType] -&gt;
<span class="lineno"> 4994 </span>                                CruCtx ps_in -&gt; CruCtx ps_out -&gt;
<span class="lineno"> 4995 </span>                                ExprPerms ps_in -&gt; ExprPerms ps_out -&gt;
<span class="lineno"> 4996 </span>                                ExprVar LifetimeType -&gt;
<span class="lineno"> 4997 </span>                                ImplM vars s r ps
<span class="lineno"> 4998 </span>                                (ps :&gt; LifetimeType :&gt; LifetimeType) ()
<span class="lineno"> 4999 </span><span class="decl"><span class="nottickedoff">implRemoveContainedLifetimeM l ls tps_in tps_out ps_in ps_out l2 =</span>
<span class="lineno"> 5000 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_RemoveContainedLifetime</span>
<span class="lineno"> 5001 </span><span class="spaces">                    </span><span class="nottickedoff">l ls tps_in tps_out ps_in ps_out l2) &gt;&gt;&gt;</span>
<span class="lineno"> 5002 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm l (ValPerm_LOwned (delete (PExpr_Var l2) ls)</span>
<span class="lineno"> 5003 </span><span class="spaces">                   </span><span class="nottickedoff">tps_in tps_out ps_in ps_out)</span></span>
<span class="lineno"> 5004 </span>
<span class="lineno"> 5005 </span>-- | Find all equality permissions @eq(e)@ contained in a permission we
<span class="lineno"> 5006 </span>-- currently hold on @x@, and return all of the free variables of @e@ along with
<span class="lineno"> 5007 </span>-- their contained eq vars
<span class="lineno"> 5008 </span>getContainedEqVars :: ExprVar a -&gt; ImplM vars s r ps ps (NameSet CrucibleType)
<span class="lineno"> 5009 </span><span class="decl"><span class="nottickedoff">getContainedEqVars x = getContainedEqVarsExcept (NameSet.singleton x) x</span></span>
<span class="lineno"> 5010 </span>
<span class="lineno"> 5011 </span>-- | Find all equality permissions @eq(e)@ contained in a permission we
<span class="lineno"> 5012 </span>-- currently hold on @x@, and return all of the free variables of @e@ not in the
<span class="lineno"> 5013 </span>-- supplied set, along with their contained eq vars
<span class="lineno"> 5014 </span>getContainedEqVarsExcept :: NameSet CrucibleType -&gt; ExprVar a -&gt;
<span class="lineno"> 5015 </span>                            ImplM vars s r ps ps (NameSet CrucibleType)
<span class="lineno"> 5016 </span><span class="decl"><span class="nottickedoff">getContainedEqVarsExcept excl x =</span>
<span class="lineno"> 5017 </span><span class="spaces">  </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 5018 </span><span class="spaces">  </span><span class="nottickedoff">let p_eq_vars = containedEqVars p</span>
<span class="lineno"> 5019 </span><span class="spaces">      </span><span class="nottickedoff">new_excl = NameSet.union excl p_eq_vars</span>
<span class="lineno"> 5020 </span><span class="spaces">      </span><span class="nottickedoff">new_vars = NameSet.difference p_eq_vars excl in</span>
<span class="lineno"> 5021 </span><span class="spaces">  </span><span class="nottickedoff">NameSet.unions &lt;$&gt; (new_vars :) &lt;$&gt;</span>
<span class="lineno"> 5022 </span><span class="spaces">  </span><span class="nottickedoff">mapM (\(NameSet.SomeName y) -&gt;</span>
<span class="lineno"> 5023 </span><span class="spaces">         </span><span class="nottickedoff">getContainedEqVarsExcept new_excl y) (NameSet.toList new_vars)</span></span>
<span class="lineno"> 5024 </span>
<span class="lineno"> 5025 </span>-- | Find all lifetimes that we currently own which could, if ended, help prove
<span class="lineno"> 5026 </span>-- the specified permissions, and return them with their @lowned@ permissions,
<span class="lineno"> 5027 </span>-- in a topological order, where child lifetimes come before their parents.
<span class="lineno"> 5028 </span>lifetimesThatCouldProve :: NuMatchingAny1 r =&gt; Mb vars (DistPerms ps') -&gt;
<span class="lineno"> 5029 </span>                           ImplM vars s r ps ps [ExprVar LifetimeType]
<span class="lineno"> 5030 </span><span class="decl"><span class="nottickedoff">lifetimesThatCouldProve mb_ps =</span>
<span class="lineno"> 5031 </span><span class="spaces">  </span><span class="nottickedoff">do varTypes &lt;- use implStateVars</span>
<span class="lineno"> 5032 </span><span class="spaces">     </span><span class="nottickedoff">-- Cast all lowneds we currently hold using any equality perms we hold</span>
<span class="lineno"> 5033 </span><span class="spaces">     </span><span class="nottickedoff">(unzip -&gt; (ls, ps)) &lt;- implFindLOwnedPerms</span>
<span class="lineno"> 5034 </span><span class="spaces">     </span><span class="nottickedoff">ps' &lt;- substEqs ps</span>
<span class="lineno"> 5035 </span><span class="spaces">     </span><span class="nottickedoff">let ls_ps' = zip ls ps'</span>
<span class="lineno"> 5036 </span><span class="spaces">     </span><span class="nottickedoff">-- Convert mb_ps to ExprPerms so we can cast them as well; DistPerms can't</span>
<span class="lineno"> 5037 </span><span class="spaces">     </span><span class="nottickedoff">-- be cast because casting substitutes expressions for variables, and</span>
<span class="lineno"> 5038 </span><span class="spaces">     </span><span class="nottickedoff">-- DistPerms are pairs of a variable with a permission</span>
<span class="lineno"> 5039 </span><span class="spaces">     </span><span class="nottickedoff">mb_ps' &lt;-</span>
<span class="lineno"> 5040 </span><span class="spaces">       </span><span class="nottickedoff">give (cruCtxProxies varTypes) $</span>
<span class="lineno"> 5041 </span><span class="spaces">       </span><span class="nottickedoff">substEqs (mbDistPermsToExprPerms mb_ps)</span>
<span class="lineno"> 5042 </span><span class="spaces">     </span><span class="nottickedoff">-- For all permissions x:p in mb_ps that we need to prove, find all the</span>
<span class="lineno"> 5043 </span><span class="spaces">     </span><span class="nottickedoff">-- variables y such that an eq(e) permission with y in the free variables</span>
<span class="lineno"> 5044 </span><span class="spaces">     </span><span class="nottickedoff">-- of e is contained in a permission we currently hold on x</span>
<span class="lineno"> 5045 </span><span class="spaces">     </span><span class="nottickedoff">containedVars &lt;-</span>
<span class="lineno"> 5046 </span><span class="spaces">       </span><span class="nottickedoff">NameSet.unions &lt;$&gt;</span>
<span class="lineno"> 5047 </span><span class="spaces">       </span><span class="nottickedoff">mapM (\(NameSet.SomeName n) -&gt;</span>
<span class="lineno"> 5048 </span><span class="spaces">              </span><span class="nottickedoff">getContainedEqVars n) (mbExprPermsVarsList mb_ps')</span>
<span class="lineno"> 5049 </span><span class="spaces">     </span><span class="nottickedoff">-- Make sure we don't end any lifetimes that we still need in mb_ps</span>
<span class="lineno"> 5050 </span><span class="spaces">     </span><span class="nottickedoff">let needed_ls = lownedsInMbExprPerms mb_ps'</span>
<span class="lineno"> 5051 </span><span class="spaces">     </span><span class="nottickedoff">-- Find any lifetime in ps' not in needed_ls that could prove a permission</span>
<span class="lineno"> 5052 </span><span class="spaces">     </span><span class="nottickedoff">-- we need in mb_ps'</span>
<span class="lineno"> 5053 </span><span class="spaces">     </span><span class="nottickedoff">return $ map fst $ sortLOwnedPerms $ flip mapMaybe ls_ps' $ \case</span>
<span class="lineno"> 5054 </span><span class="spaces">       </span><span class="nottickedoff">(l, p@(ValPerm_LOwned _ _ _ _ ps_out))</span>
<span class="lineno"> 5055 </span><span class="spaces">         </span><span class="nottickedoff">| notElem l needed_ls</span>
<span class="lineno"> 5056 </span><span class="spaces">         </span><span class="nottickedoff">, lownedPermsCouldProve varTypes ps_out mb_ps' ||</span>
<span class="lineno"> 5057 </span><span class="spaces">           </span><span class="nottickedoff">not (NameSet.null $</span>
<span class="lineno"> 5058 </span><span class="spaces">                </span><span class="nottickedoff">NameSet.intersection containedVars $</span>
<span class="lineno"> 5059 </span><span class="spaces">                </span><span class="nottickedoff">exprPermsVarsSet ps_out) -&gt;</span>
<span class="lineno"> 5060 </span><span class="spaces">           </span><span class="nottickedoff">Just (l,p)</span>
<span class="lineno"> 5061 </span><span class="spaces">       </span><span class="nottickedoff">(l, p@(ValPerm_LOwnedSimple _ ps_out))</span>
<span class="lineno"> 5062 </span><span class="spaces">         </span><span class="nottickedoff">| notElem l needed_ls</span>
<span class="lineno"> 5063 </span><span class="spaces">         </span><span class="nottickedoff">, lownedPermsCouldProve varTypes ps_out mb_ps' ||</span>
<span class="lineno"> 5064 </span><span class="spaces">           </span><span class="nottickedoff">not (NameSet.null $</span>
<span class="lineno"> 5065 </span><span class="spaces">                </span><span class="nottickedoff">NameSet.intersection containedVars $</span>
<span class="lineno"> 5066 </span><span class="spaces">                </span><span class="nottickedoff">exprPermsVarsSet ps_out) -&gt; Just (l,p)</span>
<span class="lineno"> 5067 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno"> 5068 </span>
<span class="lineno"> 5069 </span>-- | Combine proofs of @x:ptr(pps,(off,spl) |-&gt; eq(y))@ and @y:p@ on the top of
<span class="lineno"> 5070 </span>-- the permission stack into a proof of @x:ptr(pps,(off,spl |-&gt; p))@
<span class="lineno"> 5071 </span>introLLVMFieldContentsM ::
<span class="lineno"> 5072 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5073 </span>  ExprVar (LLVMPointerType w) -&gt; ExprVar (LLVMPointerType sz) -&gt;
<span class="lineno"> 5074 </span>  LLVMFieldPerm w sz -&gt;
<span class="lineno"> 5075 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w :&gt;
<span class="lineno"> 5076 </span>                                            LLVMPointerType sz) ()
<span class="lineno"> 5077 </span><span class="decl"><span class="nottickedoff">introLLVMFieldContentsM x y fp =</span>
<span class="lineno"> 5078 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMFieldContents x y fp)</span></span>
<span class="lineno"> 5079 </span>
<span class="lineno"> 5080 </span>-- | Coerce the contents of a field permission on top of the stack to @true@
<span class="lineno"> 5081 </span>implLLVMFieldSetTrue ::
<span class="lineno"> 5082 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 5083 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 5084 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5085 </span><span class="decl"><span class="nottickedoff">implLLVMFieldSetTrue x fp =</span>
<span class="lineno"> 5086 </span><span class="spaces">  </span><span class="nottickedoff">implElimLLVMFieldContentsM x fp &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 5087 </span><span class="spaces">  </span><span class="nottickedoff">introConjM y &gt;&gt;&gt;</span>
<span class="lineno"> 5088 </span><span class="spaces">  </span><span class="nottickedoff">let fp_true = llvmFieldSetTrue fp fp in</span>
<span class="lineno"> 5089 </span><span class="spaces">  </span><span class="nottickedoff">introLLVMFieldContentsM x y fp_true</span></span>
<span class="lineno"> 5090 </span>
<span class="lineno"> 5091 </span>-- | Start with a pointer permission on top of the stack and try to coerce it to
<span class="lineno"> 5092 </span>-- a pointer permission whose contents are of the form @(eq(llvmword(e)))@. If
<span class="lineno"> 5093 </span>-- successful, return @e@, otherwise coerce to a field with @true@ contents and
<span class="lineno"> 5094 </span>-- return 'Nothing'.
<span class="lineno"> 5095 </span>implLLVMFieldTryProveWordEq ::
<span class="lineno"> 5096 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 5097 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt;
<span class="lineno"> 5098 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5099 </span>  (Maybe (PermExpr (BVType sz)))
<span class="lineno"> 5100 </span><span class="decl"><span class="nottickedoff">implLLVMFieldTryProveWordEq x fp =</span>
<span class="lineno"> 5101 </span><span class="spaces">  </span><span class="nottickedoff">implElimLLVMFieldContentsM x fp &gt;&gt;&gt;= \y -&gt; getPerm y &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 5102 </span><span class="spaces">  </span><span class="nottickedoff">implPushM y p &gt;&gt;&gt; implMaybeCopyPopM y p &gt;&gt;&gt; elimOrsExistsNamesM y &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5103 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Eq e -&gt;</span>
<span class="lineno"> 5104 </span><span class="spaces">    </span><span class="nottickedoff">substEqsWithProof e &gt;&gt;&gt;= \eqp -&gt;</span>
<span class="lineno"> 5105 </span><span class="spaces">    </span><span class="nottickedoff">case someEqProofRHS eqp of</span>
<span class="lineno"> 5106 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_LLVMWord e' -&gt;</span>
<span class="lineno"> 5107 </span><span class="spaces">        </span><span class="nottickedoff">implCastPermM Proxy y (fmap ValPerm_Eq eqp) &gt;&gt;&gt;</span>
<span class="lineno"> 5108 </span><span class="spaces">        </span><span class="nottickedoff">let fp' = llvmFieldSetEqWord fp e' in</span>
<span class="lineno"> 5109 </span><span class="spaces">        </span><span class="nottickedoff">introLLVMFieldContentsM x y fp' &gt;&gt;&gt;</span>
<span class="lineno"> 5110 </span><span class="spaces">        </span><span class="nottickedoff">return (Just e')</span>
<span class="lineno"> 5111 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 5112 </span><span class="spaces">        </span><span class="nottickedoff">implDropM y p &gt;&gt;&gt; implLLVMFieldSetTrue x (llvmFieldSetEqVar fp y) &gt;&gt;&gt;</span>
<span class="lineno"> 5113 </span><span class="spaces">        </span><span class="nottickedoff">return Nothing</span>
<span class="lineno"> 5114 </span><span class="spaces">  </span><span class="nottickedoff">p' -&gt;</span>
<span class="lineno"> 5115 </span><span class="spaces">    </span><span class="nottickedoff">implDropM y p' &gt;&gt;&gt; implLLVMFieldSetTrue x (llvmFieldSetEqVar fp y) &gt;&gt;&gt;</span>
<span class="lineno"> 5116 </span><span class="spaces">    </span><span class="nottickedoff">return Nothing</span></span>
<span class="lineno"> 5117 </span>
<span class="lineno"> 5118 </span>-- | Like 'implLLVMFieldTryeProveWordEq' but for two field permissions in the
<span class="lineno"> 5119 </span>-- top two slots on the stack
<span class="lineno"> 5120 </span>implLLVMFieldTryProveWordEq2 ::
<span class="lineno"> 5121 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1,
<span class="lineno"> 5122 </span>   1 &lt;= sz2, KnownNat sz2) =&gt;
<span class="lineno"> 5123 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz1 -&gt; LLVMFieldPerm w sz2 -&gt;
<span class="lineno"> 5124 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5125 </span>  (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5126 </span>  (Maybe (PermExpr (BVType sz1), PermExpr (BVType sz2)))
<span class="lineno"> 5127 </span><span class="decl"><span class="nottickedoff">implLLVMFieldTryProveWordEq2 x fp1 fp2 =</span>
<span class="lineno"> 5128 </span><span class="spaces">  </span><span class="nottickedoff">implLLVMFieldTryProveWordEq x fp2 &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5129 </span><span class="spaces">  </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5130 </span><span class="spaces">    </span><span class="nottickedoff">let fp2_true = llvmFieldSetTrue fp2 fp2 in</span>
<span class="lineno"> 5131 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM x (ValPerm_LLVMField fp1) x (ValPerm_LLVMField fp2_true) &gt;&gt;&gt;</span>
<span class="lineno"> 5132 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldSetTrue x fp1 &gt;&gt;&gt;</span>
<span class="lineno"> 5133 </span><span class="spaces">    </span><span class="nottickedoff">let fp1_true = llvmFieldSetTrue fp1 fp1 in</span>
<span class="lineno"> 5134 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM x (ValPerm_LLVMField fp2_true) x (ValPerm_LLVMField fp1_true) &gt;&gt;&gt;</span>
<span class="lineno"> 5135 </span><span class="spaces">    </span><span class="nottickedoff">return Nothing</span>
<span class="lineno"> 5136 </span><span class="spaces">  </span><span class="nottickedoff">Just e2 -&gt;</span>
<span class="lineno"> 5137 </span><span class="spaces">    </span><span class="nottickedoff">let fp2' = llvmFieldSetEqWord fp2 e2 in</span>
<span class="lineno"> 5138 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM x (ValPerm_LLVMField fp1) x (ValPerm_LLVMField fp2') &gt;&gt;&gt;</span>
<span class="lineno"> 5139 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldTryProveWordEq x fp1 &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5140 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5141 </span><span class="spaces">        </span><span class="nottickedoff">let fp1_true = llvmFieldSetTrue fp1 fp1 in</span>
<span class="lineno"> 5142 </span><span class="spaces">        </span><span class="nottickedoff">implSwapM x (ValPerm_LLVMField fp2') x (ValPerm_LLVMField fp1_true) &gt;&gt;&gt;</span>
<span class="lineno"> 5143 </span><span class="spaces">        </span><span class="nottickedoff">implLLVMFieldSetTrue x fp2' &gt;&gt;&gt;</span>
<span class="lineno"> 5144 </span><span class="spaces">        </span><span class="nottickedoff">return Nothing</span>
<span class="lineno"> 5145 </span><span class="spaces">      </span><span class="nottickedoff">Just e1 -&gt;</span>
<span class="lineno"> 5146 </span><span class="spaces">        </span><span class="nottickedoff">let fp1' = llvmFieldSetEqWord fp1 e1 in</span>
<span class="lineno"> 5147 </span><span class="spaces">        </span><span class="nottickedoff">implSwapM x (ValPerm_LLVMField fp2') x (ValPerm_LLVMField fp1') &gt;&gt;&gt;</span>
<span class="lineno"> 5148 </span><span class="spaces">        </span><span class="nottickedoff">return (Just (e1, e2))</span></span>
<span class="lineno"> 5149 </span>
<span class="lineno"> 5150 </span>-- | Attempt to split a pointer permission @ptr((rw,off,sz) |-&gt; p)@ on top of
<span class="lineno"> 5151 </span>-- the stack into two permissions of the form @ptr((rw,off,8*len) |-&gt; p1)@ and
<span class="lineno"> 5152 </span>-- @ptr((rw,off+len,sz-(8*len)) |-&gt; p2)@, that is, into one field of size @len@
<span class="lineno"> 5153 </span>-- bytes and one field of the remaining size. If @p@ can be coerced to an
<span class="lineno"> 5154 </span>-- equality permission @eq(llvmword(bv))@ for a known constant bitvector @bv@,
<span class="lineno"> 5155 </span>-- then @p1@ and @p2@ are equalities to the split of @bv@ into known smaller
<span class="lineno"> 5156 </span>-- bitvectors, and otherwise they are both @true@.
<span class="lineno"> 5157 </span>implLLVMFieldSplit ::
<span class="lineno"> 5158 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 5159 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt; Integer -&gt;
<span class="lineno"> 5160 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5161 </span>  (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5162 </span>  (AtomicPerm (LLVMPointerType w), AtomicPerm (LLVMPointerType w))
<span class="lineno"> 5163 </span><span class="decl"><span class="nottickedoff">implLLVMFieldSplit x fp sz_bytes</span>
<span class="lineno"> 5164 </span><span class="spaces">  </span><span class="nottickedoff">| Just (Some sz) &lt;- someNat (sz_bytes * 8)</span>
<span class="lineno"> 5165 </span><span class="spaces">  </span><span class="nottickedoff">, Just fp_m_sz &lt;- subNat' (llvmFieldSize fp) sz</span>
<span class="lineno"> 5166 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq sz (llvmFieldSize fp)</span>
<span class="lineno"> 5167 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) sz</span>
<span class="lineno"> 5168 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) fp_m_sz =</span>
<span class="lineno"> 5169 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat sz $ withKnownNat fp_m_sz $</span>
<span class="lineno"> 5170 </span><span class="spaces">    </span><span class="nottickedoff">use implStateEndianness &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 5171 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldTryProveWordEq x fp &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5172 </span><span class="spaces">      </span><span class="nottickedoff">Just e -&gt;</span>
<span class="lineno"> 5173 </span><span class="spaces">        </span><span class="nottickedoff">implApplyImpl1</span>
<span class="lineno"> 5174 </span><span class="spaces">        </span><span class="nottickedoff">(Impl1_SplitLLVMWordField x (llvmFieldSetEqWord fp e) sz endianness)</span>
<span class="lineno"> 5175 </span><span class="spaces">        </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (const $ return ())) &gt;&gt;&gt;</span>
<span class="lineno"> 5176 </span><span class="spaces">        </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;=</span>
<span class="lineno"> 5177 </span><span class="spaces">        </span><span class="nottickedoff">\case</span>
<span class="lineno"> 5178 </span><span class="spaces">          </span><span class="nottickedoff">(_ :&gt;: VarAndPerm _ (ValPerm_Conj1 p1) :&gt;:</span>
<span class="lineno"> 5179 </span><span class="spaces">           </span><span class="nottickedoff">VarAndPerm _ (ValPerm_Conj1 p2) :&gt;:</span>
<span class="lineno"> 5180 </span><span class="spaces">           </span><span class="nottickedoff">VarAndPerm y p_y :&gt;: VarAndPerm z p_z) -&gt;</span>
<span class="lineno"> 5181 </span><span class="spaces">            </span><span class="nottickedoff">recombinePerm z p_z &gt;&gt;&gt; recombinePerm y p_y &gt;&gt;&gt; return (p1,p2)</span>
<span class="lineno"> 5182 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; error &quot;implLLVMFieldSplit: unexpected permission stack&quot;</span>
<span class="lineno"> 5183 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5184 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM Proxy (SImpl_SplitLLVMTrueField x</span>
<span class="lineno"> 5185 </span><span class="spaces">                          </span><span class="nottickedoff">(llvmFieldSetTrue fp fp) sz fp_m_sz) &gt;&gt;&gt;</span>
<span class="lineno"> 5186 </span><span class="spaces">        </span><span class="nottickedoff">return (Perm_LLVMField (llvmFieldSetTrue fp sz),</span>
<span class="lineno"> 5187 </span><span class="spaces">                </span><span class="nottickedoff">Perm_LLVMField (llvmFieldAddOffsetInt</span>
<span class="lineno"> 5188 </span><span class="spaces">                                </span><span class="nottickedoff">(llvmFieldSetTrue fp fp_m_sz)</span>
<span class="lineno"> 5189 </span><span class="spaces">                                </span><span class="nottickedoff">sz_bytes))</span>
<span class="lineno"> 5190 </span><span class="spaces"></span><span class="nottickedoff">implLLVMFieldSplit _ _ _ =</span>
<span class="lineno"> 5191 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;implLLVMFieldSplit: malformed input permissions&quot;</span></span>
<span class="lineno"> 5192 </span>
<span class="lineno"> 5193 </span>-- | Attempt to truncate a pointer permission @ptr((rw,off,sz) |-&gt; p)@ on top of
<span class="lineno"> 5194 </span>-- the stack into a permission of the form @ptr((rw,off,sz') |-&gt; p')@ for @sz'@
<span class="lineno"> 5195 </span>-- smaller than @sz@. If @p@ can be coerced to an equality permission
<span class="lineno"> 5196 </span>-- @eq(llvmword(bv))@ for a known constant bitvector @bv@, then @p'@ is an
<span class="lineno"> 5197 </span>-- equality to the truncation of @bv@. If @p@ can be coerced to an equality
<span class="lineno"> 5198 </span>-- permission @eq(llvmword(e))@ to some non-constant @e@, @p'@ is an equality to
<span class="lineno"> 5199 </span>-- a fresh bitvector variable. Otherwise @p'@ is just @true@.
<span class="lineno"> 5200 </span>implLLVMFieldTruncate ::
<span class="lineno"> 5201 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 5202 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt; NatRepr sz' -&gt;
<span class="lineno"> 5203 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5204 </span>  (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5205 </span>  (AtomicPerm (LLVMPointerType w))
<span class="lineno"> 5206 </span><span class="decl"><span class="nottickedoff">implLLVMFieldTruncate x fp sz'</span>
<span class="lineno"> 5207 </span><span class="spaces">  </span><span class="nottickedoff">| Left LeqProof &lt;- decideLeq sz' (llvmFieldSize fp)</span>
<span class="lineno"> 5208 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) sz' =</span>
<span class="lineno"> 5209 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat sz' $</span>
<span class="lineno"> 5210 </span><span class="spaces">    </span><span class="nottickedoff">use implStateEndianness &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 5211 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldTryProveWordEq x fp &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5212 </span><span class="spaces">      </span><span class="nottickedoff">Just e -&gt;</span>
<span class="lineno"> 5213 </span><span class="spaces">        </span><span class="nottickedoff">implApplyImpl1</span>
<span class="lineno"> 5214 </span><span class="spaces">        </span><span class="nottickedoff">(Impl1_TruncateLLVMWordField x (llvmFieldSetEqWord fp e) sz' endianness)</span>
<span class="lineno"> 5215 </span><span class="spaces">        </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (const $ return ())) &gt;&gt;&gt;</span>
<span class="lineno"> 5216 </span><span class="spaces">        </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;=</span>
<span class="lineno"> 5217 </span><span class="spaces">        </span><span class="nottickedoff">\case</span>
<span class="lineno"> 5218 </span><span class="spaces">          </span><span class="nottickedoff">(_ :&gt;: VarAndPerm _ (ValPerm_Conj1 p) :&gt;: VarAndPerm y p_y) -&gt;</span>
<span class="lineno"> 5219 </span><span class="spaces">            </span><span class="nottickedoff">recombinePerm y p_y &gt;&gt;&gt; return p</span>
<span class="lineno"> 5220 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; error &quot;implLLVMFieldTruncate: unexpected permission stack&quot;</span>
<span class="lineno"> 5221 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5222 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM Proxy (SImpl_TruncateLLVMTrueField x</span>
<span class="lineno"> 5223 </span><span class="spaces">                          </span><span class="nottickedoff">(llvmFieldSetTrue fp fp) sz') &gt;&gt;&gt;</span>
<span class="lineno"> 5224 </span><span class="spaces">        </span><span class="nottickedoff">return (Perm_LLVMField (llvmFieldSetTrue fp sz'))</span>
<span class="lineno"> 5225 </span><span class="spaces"></span><span class="nottickedoff">implLLVMFieldTruncate _ _ _ =</span>
<span class="lineno"> 5226 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;implLLVMFieldTruncate: malformed input permissions&quot;</span></span>
<span class="lineno"> 5227 </span>
<span class="lineno"> 5228 </span>-- | Concatentate two pointer permissions @ptr((rw,off,sz1) |-&gt; p1)@ and
<span class="lineno"> 5229 </span>-- @ptr((rw,off+sz1/8,sz2) |-&gt; p2)@ into a single pointer permission of the form
<span class="lineno"> 5230 </span>-- @ptr((rw,off,sz1+sz2) |-&gt; p)@. If @p1@ and @p2@ are both equality permissions
<span class="lineno"> 5231 </span>-- @eq(llvmword(bv))@ for known constant bitvectors, then the output contents
<span class="lineno"> 5232 </span>-- permission @p@ is an equality to the concatenated of these bitvectors. If
<span class="lineno"> 5233 </span>-- @p1@ and @p2@ are both equality permissions to bitvector expressions (at
<span class="lineno"> 5234 </span>-- least one of which is non-constant), then @p@ is an equality to a fresh
<span class="lineno"> 5235 </span>-- variable. Otherwise @p@ is just @true@.
<span class="lineno"> 5236 </span>implLLVMFieldConcat ::
<span class="lineno"> 5237 </span>  (NuMatchingAny1 r, 1 &lt;= w, KnownNat w, 1 &lt;= sz1, KnownNat sz1,
<span class="lineno"> 5238 </span>   1 &lt;= sz2, KnownNat sz2) =&gt;
<span class="lineno"> 5239 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMFieldPerm w sz1 -&gt; LLVMFieldPerm w sz2 -&gt;
<span class="lineno"> 5240 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5241 </span>  (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5242 </span>  ()
<span class="lineno"> 5243 </span><span class="decl"><span class="nottickedoff">implLLVMFieldConcat x fp1 fp2</span>
<span class="lineno"> 5244 </span><span class="spaces">  </span><span class="nottickedoff">| LeqProof &lt;- leqAddPos fp1 fp2 =</span>
<span class="lineno"> 5245 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat (addNat (natRepr fp1) (natRepr fp2)) $</span>
<span class="lineno"> 5246 </span><span class="spaces">    </span><span class="nottickedoff">use implStateEndianness &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 5247 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldTryProveWordEq2 x fp1 fp2 &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5248 </span><span class="spaces">      </span><span class="nottickedoff">Just (e1, e2) -&gt;</span>
<span class="lineno"> 5249 </span><span class="spaces">        </span><span class="nottickedoff">implApplyImpl1</span>
<span class="lineno"> 5250 </span><span class="spaces">        </span><span class="nottickedoff">(Impl1_ConcatLLVMWordFields x (llvmFieldSetEqWord fp1 e1) e2 endianness)</span>
<span class="lineno"> 5251 </span><span class="spaces">        </span><span class="nottickedoff">(MNil :&gt;: Impl1Cont (const $ return ())) &gt;&gt;&gt;</span>
<span class="lineno"> 5252 </span><span class="spaces">        </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \(_ :&gt;: VarAndPerm y p_y) -&gt;</span>
<span class="lineno"> 5253 </span><span class="spaces">        </span><span class="nottickedoff">recombinePerm y p_y</span>
<span class="lineno"> 5254 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5255 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM Proxy (SImpl_ConcatLLVMTrueFields x</span>
<span class="lineno"> 5256 </span><span class="spaces">                          </span><span class="nottickedoff">(llvmFieldSetTrue fp1 fp1)</span>
<span class="lineno"> 5257 </span><span class="spaces">                          </span><span class="nottickedoff">(llvmFieldSize fp2))</span></span>
<span class="lineno"> 5258 </span>
<span class="lineno"> 5259 </span>-- | Borrow a cell from an LLVM array permission on the top of the stack, after
<span class="lineno"> 5260 </span>-- proving (with 'implTryProveBVProps') that the index is in the array exclusive
<span class="lineno"> 5261 </span>-- of any outstanding borrows (see 'llvmArrayCellInArray'). Return the
<span class="lineno"> 5262 </span>-- resulting array permission with the borrow and the borrowed cell permission,
<span class="lineno"> 5263 </span>-- leaving the array permission on top of the stack and the cell permission just
<span class="lineno"> 5264 </span>-- below it on the stack.
<span class="lineno"> 5265 </span>implLLVMArrayCellBorrow ::
<span class="lineno"> 5266 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5267 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5268 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5269 </span>  (ps :&gt; LLVMPointerType w) (LLVMArrayPerm w, LLVMBlockPerm w)
<span class="lineno"> 5270 </span><span class="decl"><span class="nottickedoff">implLLVMArrayCellBorrow x ap cell =</span>
<span class="lineno"> 5271 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProps x (llvmArrayCellInArray ap cell) &gt;&gt;&gt;</span>
<span class="lineno"> 5272 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayCellBorrow x ap cell) &gt;&gt;&gt;</span>
<span class="lineno"> 5273 </span><span class="spaces">  </span><span class="nottickedoff">pure (llvmArrayAddBorrow (FieldBorrow cell) ap,</span>
<span class="lineno"> 5274 </span><span class="spaces">        </span><span class="nottickedoff">llvmArrayCellPerm ap cell)</span></span>
<span class="lineno"> 5275 </span>
<span class="lineno"> 5276 </span>-- | Copy a cell from an LLVM array permission on the top of the stack, after
<span class="lineno"> 5277 </span>-- proving (with 'implTryProveBVProps') that the index is in the array exclusive
<span class="lineno"> 5278 </span>-- of any outstanding borrows (see 'llvmArrayCellInArray')
<span class="lineno"> 5279 </span>implLLVMArrayCellCopy ::
<span class="lineno"> 5280 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5281 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5282 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w
<span class="lineno"> 5283 </span>                  :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5284 </span><span class="decl"><span class="nottickedoff">implLLVMArrayCellCopy x ap cell =</span>
<span class="lineno"> 5285 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProps x (llvmArrayCellInArray ap cell) &gt;&gt;&gt;</span>
<span class="lineno"> 5286 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayCellCopy x ap cell)</span></span>
<span class="lineno"> 5287 </span>
<span class="lineno"> 5288 </span>-- | Copy or borrow a cell from an LLVM array permission on top of the stack,
<span class="lineno"> 5289 </span>-- depending on whether the array is copyable, after proving (with
<span class="lineno"> 5290 </span>-- 'implTryProveBVProps') that the index is in the array exclusive of any
<span class="lineno"> 5291 </span>-- outstanding borrows (see 'llvmArrayCellInArray'). Return the resulting array
<span class="lineno"> 5292 </span>-- permission with the borrow and the borrowed cell permission, leaving the
<span class="lineno"> 5293 </span>-- array permission on top of the stack and the cell permission just below it on
<span class="lineno"> 5294 </span>-- the stack.
<span class="lineno"> 5295 </span>implLLVMArrayCellGet ::
<span class="lineno"> 5296 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5297 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5298 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w
<span class="lineno"> 5299 </span>                  :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5300 </span>  (LLVMArrayPerm w, LLVMBlockPerm w)
<span class="lineno"> 5301 </span><span class="decl"><span class="nottickedoff">implLLVMArrayCellGet x ap cell =</span>
<span class="lineno"> 5302 </span><span class="spaces">  </span><span class="nottickedoff">if atomicPermIsCopyable (Perm_LLVMArray ap) then</span>
<span class="lineno"> 5303 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayCellCopy x ap cell &gt;&gt;&gt;</span>
<span class="lineno"> 5304 </span><span class="spaces">    </span><span class="nottickedoff">return (ap, llvmArrayCellPerm ap cell)</span>
<span class="lineno"> 5305 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 5306 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayCellBorrow x ap cell</span></span>
<span class="lineno"> 5307 </span>
<span class="lineno"> 5308 </span>-- | Return a cell that has been borrowed from an array permission, where the
<span class="lineno"> 5309 </span>-- array permission is on the top of the stack and the cell permission borrowed
<span class="lineno"> 5310 </span>-- from it is just below it
<span class="lineno"> 5311 </span>implLLVMArrayCellReturn ::
<span class="lineno"> 5312 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5313 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5314 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5315 </span>  (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w) ()
<span class="lineno"> 5316 </span><span class="decl"><span class="nottickedoff">implLLVMArrayCellReturn x ap cell =</span>
<span class="lineno"> 5317 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayCellReturn x ap cell)</span></span>
<span class="lineno"> 5318 </span>
<span class="lineno"> 5319 </span>-- | Borrow a sub-array from an array @ap@ using 'SImpl_LLVMArrayBorrow',
<span class="lineno"> 5320 </span>-- leaving the remainder of @ap@ on the top of the stack and the borrowed
<span class="lineno"> 5321 </span>-- sub-array just beneath it. Return the remainder of @ap@.
<span class="lineno"> 5322 </span>implLLVMArrayBorrow ::
<span class="lineno"> 5323 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5324 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5325 </span>  PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5326 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5327 </span>  (ps :&gt; LLVMPointerType w) (LLVMArrayPerm w)
<span class="lineno"> 5328 </span><span class="decl"><span class="nottickedoff">implLLVMArrayBorrow x ap off len =</span>
<span class="lineno"> 5329 </span><span class="spaces">  </span><span class="nottickedoff">let sub_ap = llvmMakeSubArray ap off len in</span>
<span class="lineno"> 5330 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProps x (llvmArrayContainsArray ap sub_ap) &gt;&gt;&gt;</span>
<span class="lineno"> 5331 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayBorrow x ap off len) &gt;&gt;&gt;</span>
<span class="lineno"> 5332 </span><span class="spaces">  </span><span class="nottickedoff">return (llvmArrayAddBorrow (llvmSubArrayBorrow ap sub_ap) $</span>
<span class="lineno"> 5333 </span><span class="spaces">          </span><span class="nottickedoff">llvmArrayRemArrayBorrows ap sub_ap)</span></span>
<span class="lineno"> 5334 </span>
<span class="lineno"> 5335 </span>-- | Copy a sub-array from an array @ap@ as per 'SImpl_LLVMArrayCopy', leaving
<span class="lineno"> 5336 </span>-- @ap@ on the top of the stack and the borrowed sub-array just beneath
<span class="lineno"> 5337 </span>-- it. Return the remainder of @ap@ that is on top of the stack.
<span class="lineno"> 5338 </span>implLLVMArrayCopy ::
<span class="lineno"> 5339 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5340 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5341 </span>  PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5342 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5343 </span>  (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5344 </span><span class="decl"><span class="nottickedoff">implLLVMArrayCopy x ap off len =</span>
<span class="lineno"> 5345 </span><span class="spaces">  </span><span class="nottickedoff">implTryProveBVProps x (llvmArrayContainsArray ap $</span>
<span class="lineno"> 5346 </span><span class="spaces">                         </span><span class="nottickedoff">llvmMakeSubArray ap off len) &gt;&gt;&gt;</span>
<span class="lineno"> 5347 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayCopy x ap off len)</span></span>
<span class="lineno"> 5348 </span>
<span class="lineno"> 5349 </span>-- | Copy or borrow a sub-array from an array @ap@, depending on whether @ap@ is
<span class="lineno"> 5350 </span>-- copyable, assuming @ap@ is on top of the stack. Leave the remainder of @ap@
<span class="lineno"> 5351 </span>-- on top of the stack and the sub-array just below it. Return the remainder of
<span class="lineno"> 5352 </span>-- @ap@ that was left on top of the stack.
<span class="lineno"> 5353 </span>implLLVMArrayGet ::
<span class="lineno"> 5354 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5355 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5356 </span>  PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5357 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5358 </span>  (ps :&gt; LLVMPointerType w) (LLVMArrayPerm w)
<span class="lineno"> 5359 </span><span class="decl"><span class="nottickedoff">implLLVMArrayGet x ap off len</span>
<span class="lineno"> 5360 </span><span class="spaces">  </span><span class="nottickedoff">| atomicPermIsCopyable (Perm_LLVMArray ap) =</span>
<span class="lineno"> 5361 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayCopy x ap off len &gt;&gt;&gt; return ap</span>
<span class="lineno"> 5362 </span><span class="spaces"></span><span class="nottickedoff">implLLVMArrayGet x ap off len = implLLVMArrayBorrow x ap off len</span></span>
<span class="lineno"> 5363 </span>
<span class="lineno"> 5364 </span>
<span class="lineno"> 5365 </span>-- | Return a borrowed sub-array to an array as per 'SImpl_LLVMArrayReturn',
<span class="lineno"> 5366 </span>-- where the borrowed array permission is just below the top of the stack and
<span class="lineno"> 5367 </span>-- the array it was borrowed from is on top of the stack.  Return the new array
<span class="lineno"> 5368 </span>-- permission after the return that is now on the top of the stack.
<span class="lineno"> 5369 </span>implLLVMArrayReturn ::
<span class="lineno"> 5370 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5371 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5372 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5373 </span>  (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5374 </span>  (LLVMArrayPerm w)
<span class="lineno"> 5375 </span><span class="decl"><span class="nottickedoff">implLLVMArrayReturn x ap ret_ap =</span>
<span class="lineno"> 5376 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayReturn x ap ret_ap) &gt;&gt;&gt;</span>
<span class="lineno"> 5377 </span><span class="spaces">  </span><span class="nottickedoff">pure (llvmArrayRemBorrow (llvmSubArrayBorrow ap ret_ap) $</span>
<span class="lineno"> 5378 </span><span class="spaces">        </span><span class="nottickedoff">llvmArrayAddArrayBorrows ap ret_ap)</span></span>
<span class="lineno"> 5379 </span>
<span class="lineno"> 5380 </span>-- | Add a borrow to an LLVM array permission by borrowing its corresponding
<span class="lineno"> 5381 </span>-- permission, failing if that is not possible because the borrow is not in
<span class="lineno"> 5382 </span>-- range of the array. The permission that is borrowed is left on top of the
<span class="lineno"> 5383 </span>-- stack and returned as a return value.
<span class="lineno"> 5384 </span>implLLVMArrayBorrowBorrow ::
<span class="lineno"> 5385 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5386 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt;
<span class="lineno"> 5387 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w)
<span class="lineno"> 5388 </span>  (ps :&gt; LLVMPointerType w) (ValuePerm (LLVMPointerType w))
<span class="lineno"> 5389 </span><span class="decl"><span class="nottickedoff">implLLVMArrayBorrowBorrow x ap (FieldBorrow cell) =</span>
<span class="lineno"> 5390 </span><span class="spaces">  </span><span class="nottickedoff">implLLVMArrayCellBorrow x ap cell &gt;&gt;&gt;= \(ap',bp) -&gt;</span>
<span class="lineno"> 5391 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x (ValPerm_LLVMBlock bp) x (ValPerm_LLVMArray ap') &gt;&gt;&gt;</span>
<span class="lineno"> 5392 </span><span class="spaces">  </span><span class="nottickedoff">return (ValPerm_LLVMBlock bp)</span>
<span class="lineno"> 5393 </span><span class="spaces"></span><span class="nottickedoff">implLLVMArrayBorrowBorrow x ap (RangeBorrow (BVRange cell len)) =</span>
<span class="lineno"> 5394 </span><span class="spaces">  </span><span class="nottickedoff">let off = llvmArrayCellToAbsOffset ap cell</span>
<span class="lineno"> 5395 </span><span class="spaces">      </span><span class="nottickedoff">p = ValPerm_LLVMArray $ llvmMakeSubArray ap off len in</span>
<span class="lineno"> 5396 </span><span class="spaces">  </span><span class="nottickedoff">implLLVMArrayBorrow x ap off len &gt;&gt;&gt;= \ap' -&gt;</span>
<span class="lineno"> 5397 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x p x (ValPerm_LLVMArray ap') &gt;&gt;&gt; return p</span></span>
<span class="lineno"> 5398 </span>
<span class="lineno"> 5399 </span>-- | Return a borrow to an LLVM array permission, assuming the array is at the
<span class="lineno"> 5400 </span>-- top of the stack and the borrowed permission, which should be that returned
<span class="lineno"> 5401 </span>-- by 'permForLLVMArrayBorrow', is just below it
<span class="lineno"> 5402 </span>implLLVMArrayReturnBorrow ::
<span class="lineno"> 5403 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5404 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; LLVMArrayBorrow w -&gt;
<span class="lineno"> 5405 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w
<span class="lineno"> 5406 </span>                                            :&gt; LLVMPointerType w) ()
<span class="lineno"> 5407 </span><span class="decl"><span class="nottickedoff">implLLVMArrayReturnBorrow x ap (FieldBorrow cell) =</span>
<span class="lineno"> 5408 </span><span class="spaces">  </span><span class="nottickedoff">implLLVMArrayCellReturn x ap cell</span>
<span class="lineno"> 5409 </span><span class="spaces"></span><span class="nottickedoff">implLLVMArrayReturnBorrow x ap b@(RangeBorrow _)</span>
<span class="lineno"> 5410 </span><span class="spaces">  </span><span class="nottickedoff">| ValPerm_Conj1 (Perm_LLVMArray ap_ret) &lt;- permForLLVMArrayBorrow ap b =</span>
<span class="lineno"> 5411 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayReturn x ap ap_ret &gt;&gt;&gt;</span>
<span class="lineno"> 5412 </span><span class="spaces">    </span><span class="nottickedoff">pure ()</span>
<span class="lineno"> 5413 </span><span class="spaces"></span><span class="nottickedoff">implLLVMArrayReturnBorrow _ _ _ = error &quot;implLLVMArrayReturnBorrow&quot;</span></span>
<span class="lineno"> 5414 </span>
<span class="lineno"> 5415 </span>
<span class="lineno"> 5416 </span>-- | Append to array permissions, assuming one ends where the other begins and
<span class="lineno"> 5417 </span>-- that they have the same stride and fields
<span class="lineno"> 5418 </span>implLLVMArrayAppend ::
<span class="lineno"> 5419 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5420 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5421 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w
<span class="lineno"> 5422 </span>                                            :&gt; LLVMPointerType w) ()
<span class="lineno"> 5423 </span><span class="decl"><span class="nottickedoff">implLLVMArrayAppend x ap1 ap2 =</span>
<span class="lineno"> 5424 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayAppend x ap1 ap2)</span></span>
<span class="lineno"> 5425 </span>
<span class="lineno"> 5426 </span>
<span class="lineno"> 5427 </span>-- | Rearrange the order of the borrows in the input array permission to match
<span class="lineno"> 5428 </span>-- the given list, assuming the two have the same elements
<span class="lineno"> 5429 </span>implLLVMArrayRearrange ::
<span class="lineno"> 5430 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5431 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt; [LLVMArrayBorrow w] -&gt;
<span class="lineno"> 5432 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5433 </span><span class="decl"><span class="nottickedoff">implLLVMArrayRearrange x ap bs =</span>
<span class="lineno"> 5434 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayRearrange x ap bs)</span></span>
<span class="lineno"> 5435 </span>
<span class="lineno"> 5436 </span>-- | Prove an empty array with length 0
<span class="lineno"> 5437 </span>implLLVMArrayEmpty ::
<span class="lineno"> 5438 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5439 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5440 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) ps ()
<span class="lineno"> 5441 </span><span class="decl"><span class="nottickedoff">implLLVMArrayEmpty x ap = implSimplM Proxy (SImpl_LLVMArrayEmpty x ap)</span></span>
<span class="lineno"> 5442 </span>
<span class="lineno"> 5443 </span>-- | Prove an array permission whose borrows cover the array using a permission
<span class="lineno"> 5444 </span>-- that instantiates at least one of its cells
<span class="lineno"> 5445 </span>implLLVMArrayBorrowed ::
<span class="lineno"> 5446 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5447 </span>  ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt; LLVMArrayPerm w -&gt;
<span class="lineno"> 5448 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5449 </span><span class="decl"><span class="nottickedoff">implLLVMArrayBorrowed x blk ap =</span>
<span class="lineno"> 5450 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayBorrowed x blk ap)</span></span>
<span class="lineno"> 5451 </span>
<span class="lineno"> 5452 </span>-- | Prove the @memblock@ permission returned by @'llvmAtomicPermToBlock' p@
<span class="lineno"> 5453 </span>-- from a proof of @p@ on top of the stack, assuming it returned one
<span class="lineno"> 5454 </span>implIntroLLVMBlock :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5455 </span>                      ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 5456 </span>                      AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 5457 </span>                      ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5458 </span>                      (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5459 </span><span class="decl"><span class="nottickedoff">implIntroLLVMBlock x (Perm_LLVMField fp) =</span>
<span class="lineno"> 5460 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockField x fp)</span>
<span class="lineno"> 5461 </span><span class="spaces"></span><span class="nottickedoff">implIntroLLVMBlock x p@(Perm_LLVMArray ap)</span>
<span class="lineno"> 5462 </span><span class="spaces">  </span><span class="nottickedoff">| isJust (llvmAtomicPermToBlock p) =</span>
<span class="lineno"> 5463 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockArray x ap)</span>
<span class="lineno"> 5464 </span><span class="spaces"></span><span class="nottickedoff">implIntroLLVMBlock _ (Perm_LLVMBlock _bp) = pure ()</span>
<span class="lineno"> 5465 </span><span class="spaces"></span><span class="nottickedoff">implIntroLLVMBlock _ _ = error &quot;implIntroLLVMBlock: malformed permission&quot;</span></span>
<span class="lineno"> 5466 </span>
<span class="lineno"> 5467 </span>-- | Prove a @memblock@ permission with a foldable named shape from its
<span class="lineno"> 5468 </span>-- unfolding, assuming that unfolding is on the top of the stack
<span class="lineno"> 5469 </span>implIntroLLVMBlockNamed :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5470 </span>                           ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 5471 </span>                           ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5472 </span>                           (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5473 </span><span class="decl"><span class="nottickedoff">implIntroLLVMBlockNamed x bp</span>
<span class="lineno"> 5474 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_NamedShape _ _ nmsh _ &lt;- llvmBlockShape bp</span>
<span class="lineno"> 5475 </span><span class="spaces">  </span><span class="nottickedoff">, TrueRepr &lt;- namedShapeCanUnfoldRepr nmsh =</span>
<span class="lineno"> 5476 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockNamed x bp nmsh)</span>
<span class="lineno"> 5477 </span><span class="spaces"></span><span class="nottickedoff">implIntroLLVMBlockNamed _ _ =</span>
<span class="lineno"> 5478 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;implIntroLLVMBlockNamed: malformed permission&quot;</span></span>
<span class="lineno"> 5479 </span>
<span class="lineno"> 5480 </span>
<span class="lineno"> 5481 </span>-- | Eliminate a @memblock@ permission on the top of the stack, if possible,
<span class="lineno"> 5482 </span>-- otherwise fail. Specifically, this means to perform one step of @memblock@
<span class="lineno"> 5483 </span>-- elimination, depening on the shape of the @memblock@ permission.
<span class="lineno"> 5484 </span>implElimLLVMBlock :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5485 </span>                     ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 5486 </span>                     ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5487 </span>                     (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5488 </span>
<span class="lineno"> 5489 </span>-- Eliminate the empty shape to an array of bytes
<span class="lineno"> 5490 </span><span class="decl"><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape = PExpr_EmptyShape }) =</span>
<span class="lineno"> 5491 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockToBytes x bp)</span>
<span class="lineno"> 5492 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5493 </span><span class="spaces"></span><span class="nottickedoff">-- If the \&quot;natural\&quot; length of the shape of a memblock permission is smaller than</span>
<span class="lineno"> 5494 </span><span class="spaces"></span><span class="nottickedoff">-- its actual length, sequence with the empty shape and then eliminate</span>
<span class="lineno"> 5495 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp</span>
<span class="lineno"> 5496 </span><span class="spaces">  </span><span class="nottickedoff">| Just sh_len &lt;- llvmShapeLength $ llvmBlockShape bp</span>
<span class="lineno"> 5497 </span><span class="spaces">  </span><span class="nottickedoff">, bvLt sh_len $ llvmBlockLen bp =</span>
<span class="lineno"> 5498 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockSeqEmpty x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 5499 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockSeq x bp PExpr_EmptyShape)</span>
<span class="lineno"> 5500 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5501 </span><span class="spaces"></span><span class="nottickedoff">-- Eliminate modalities on named shapes</span>
<span class="lineno"> 5502 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5503 </span><span class="spaces">                                          </span><span class="nottickedoff">PExpr_NamedShape rw l _ _ })</span>
<span class="lineno"> 5504 </span><span class="spaces">  </span><span class="nottickedoff">| isJust rw || isJust l</span>
<span class="lineno"> 5505 </span><span class="spaces">  </span><span class="nottickedoff">= implSimplM Proxy (SImpl_ElimLLVMBlockNamedMods x bp)</span>
<span class="lineno"> 5506 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5507 </span><span class="spaces"></span><span class="nottickedoff">-- Unfold defined or recursive named shapes</span>
<span class="lineno"> 5508 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5509 </span><span class="spaces">                                          </span><span class="nottickedoff">PExpr_NamedShape rw l nmsh args })</span>
<span class="lineno"> 5510 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- namedShapeCanUnfoldRepr nmsh</span>
<span class="lineno"> 5511 </span><span class="spaces">  </span><span class="nottickedoff">, isJust (unfoldModalizeNamedShape rw l nmsh args) =</span>
<span class="lineno"> 5512 </span><span class="spaces">    </span><span class="nottickedoff">(if namedShapeIsRecursive nmsh</span>
<span class="lineno"> 5513 </span><span class="spaces">     </span><span class="nottickedoff">then implSetRecRecurseLeftM else pure ()) &gt;&gt;&gt;</span>
<span class="lineno"> 5514 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockNamed x bp nmsh)</span>
<span class="lineno"> 5515 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5516 </span><span class="spaces"></span><span class="nottickedoff">-- For shape eqsh(len,y), prove y:block(sh) for some sh and then apply</span>
<span class="lineno"> 5517 </span><span class="spaces"></span><span class="nottickedoff">-- SImpl_IntroLLVMBlockFromEq</span>
<span class="lineno"> 5518 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5519 </span><span class="spaces">                                          </span><span class="nottickedoff">PExpr_EqShape len (PExpr_Var y) })</span>
<span class="lineno"> 5520 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq len (llvmBlockLen bp) =</span>
<span class="lineno"> 5521 </span><span class="spaces">    </span><span class="nottickedoff">mbVarsM () &gt;&gt;&gt;= \mb_unit -&gt;</span>
<span class="lineno"> 5522 </span><span class="spaces">    </span><span class="nottickedoff">withExtVarsM (proveVarImplInt y $ mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 5523 </span><span class="spaces">                  </span><span class="nottickedoff">flip mbConst mb_unit $</span>
<span class="lineno"> 5524 </span><span class="spaces">                  </span><span class="nottickedoff">nu $ \sh -&gt; ValPerm_Conj1 $</span>
<span class="lineno"> 5525 </span><span class="spaces">                              </span><span class="nottickedoff">Perm_LLVMBlockShape $ PExpr_Var sh) &gt;&gt;&gt;= \(_, sh) -&gt;</span>
<span class="lineno"> 5526 </span><span class="spaces">    </span><span class="nottickedoff">let bp' = bp { llvmBlockShape = sh } in</span>
<span class="lineno"> 5527 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockFromEq x bp' y)</span>
<span class="lineno"> 5528 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5529 </span><span class="spaces"></span><span class="nottickedoff">-- For [l]ptrsh(rw,sh), eliminate to a pointer to a memblock with shape sh</span>
<span class="lineno"> 5530 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape = PExpr_PtrShape _ _ _ })</span>
<span class="lineno"> 5531 </span><span class="spaces">  </span><span class="nottickedoff">| isJust (llvmBlockPtrShapeUnfold bp) =</span>
<span class="lineno"> 5532 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockPtr x bp)</span>
<span class="lineno"> 5533 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5534 </span><span class="spaces"></span><span class="nottickedoff">-- For a field shape, eliminate to a field permission</span>
<span class="lineno"> 5535 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm</span>
<span class="lineno"> 5536 </span><span class="spaces">                        </span><span class="nottickedoff">{ llvmBlockShape =</span>
<span class="lineno"> 5537 </span><span class="spaces">                            </span><span class="nottickedoff">PExpr_FieldShape (LLVMFieldShape p) })</span>
<span class="lineno"> 5538 </span><span class="spaces">  </span><span class="nottickedoff">| Just fp &lt;- llvmBlockPermToField (exprLLVMTypeWidth p) bp</span>
<span class="lineno"> 5539 </span><span class="spaces">  </span><span class="nottickedoff">, bvEq (llvmFieldLen fp) (llvmBlockLen bp) =</span>
<span class="lineno"> 5540 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockField x fp)</span>
<span class="lineno"> 5541 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5542 </span><span class="spaces"></span><span class="nottickedoff">-- For an array shape of the right length, eliminate to an array permission</span>
<span class="lineno"> 5543 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp</span>
<span class="lineno"> 5544 </span><span class="spaces">  </span><span class="nottickedoff">| Just ap &lt;- llvmBlockPermToArray bp</span>
<span class="lineno"> 5545 </span><span class="spaces">  </span><span class="nottickedoff">, bvEq (llvmArrayLengthBytes ap) (llvmBlockLen bp) =</span>
<span class="lineno"> 5546 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockArray x bp)</span>
<span class="lineno"> 5547 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5548 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: if we match an array shape here, its stride*length must be greater</span>
<span class="lineno"> 5549 </span><span class="spaces"></span><span class="nottickedoff">-- than the length of bp, so we should truncate it</span>
<span class="lineno"> 5550 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 5551 </span><span class="spaces"></span><span class="nottickedoff">-- implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5552 </span><span class="spaces"></span><span class="nottickedoff">--                                           PExpr_ArrayShape _ _ _ }) =</span>
<span class="lineno"> 5553 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5554 </span><span class="spaces"></span><span class="nottickedoff">-- For a tuple shape, eliminate the tuple</span>
<span class="lineno"> 5555 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape = PExpr_TupShape sh }) =</span>
<span class="lineno"> 5556 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockTuple x (bp { llvmBlockShape = sh }))</span>
<span class="lineno"> 5557 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5558 </span><span class="spaces"></span><span class="nottickedoff">-- Special case: for shape sh1;emptysh where the natural length of sh1 is the</span>
<span class="lineno"> 5559 </span><span class="spaces"></span><span class="nottickedoff">-- same as the length of the block permission, eliminate the emptysh, converting</span>
<span class="lineno"> 5560 </span><span class="spaces"></span><span class="nottickedoff">-- to a memblock permission of shape sh1</span>
<span class="lineno"> 5561 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5562 </span><span class="spaces">                                          </span><span class="nottickedoff">PExpr_SeqShape sh PExpr_EmptyShape })</span>
<span class="lineno"> 5563 </span><span class="spaces">  </span><span class="nottickedoff">| Just len &lt;- llvmShapeLength sh</span>
<span class="lineno"> 5564 </span><span class="spaces">  </span><span class="nottickedoff">, bvEq len (llvmBlockLen bp) =</span>
<span class="lineno"> 5565 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockSeqEmpty x</span>
<span class="lineno"> 5566 </span><span class="spaces">                      </span><span class="nottickedoff">(bp { llvmBlockShape = sh }))</span>
<span class="lineno"> 5567 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5568 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise, for a sequence shape sh1;sh2, eliminate to two memblock</span>
<span class="lineno"> 5569 </span><span class="spaces"></span><span class="nottickedoff">-- permissions, of shapes sh1 and sh2</span>
<span class="lineno"> 5570 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5571 </span><span class="spaces">                                          </span><span class="nottickedoff">PExpr_SeqShape sh1 sh2 })</span>
<span class="lineno"> 5572 </span><span class="spaces">  </span><span class="nottickedoff">| isJust $ llvmShapeLength sh1 =</span>
<span class="lineno"> 5573 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockSeq</span>
<span class="lineno"> 5574 </span><span class="spaces">                      </span><span class="nottickedoff">x (bp { llvmBlockShape = sh1 }) sh2)</span>
<span class="lineno"> 5575 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5576 </span><span class="spaces"></span><span class="nottickedoff">-- For an or shape, eliminate to a disjunctive permisison</span>
<span class="lineno"> 5577 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5578 </span><span class="spaces">                                        </span><span class="nottickedoff">PExpr_OrShape sh1 (matchOrShapes -&gt; shs) }) =</span>
<span class="lineno"> 5579 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockOr x bp (sh1:shs))</span>
<span class="lineno"> 5580 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5581 </span><span class="spaces"></span><span class="nottickedoff">-- For an existential shape, eliminate to an existential permisison</span>
<span class="lineno"> 5582 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5583 </span><span class="spaces">                                        </span><span class="nottickedoff">PExpr_ExShape _mb_sh }) =</span>
<span class="lineno"> 5584 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockEx x bp)</span>
<span class="lineno"> 5585 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5586 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock x bp@(LLVMBlockPerm { llvmBlockShape =</span>
<span class="lineno"> 5587 </span><span class="spaces">                                        </span><span class="nottickedoff">PExpr_FalseShape }) =</span>
<span class="lineno"> 5588 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockFalse x bp)</span>
<span class="lineno"> 5589 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5590 </span><span class="spaces"></span><span class="nottickedoff">-- If none of the above cases matched, we cannot eliminate, so fail</span>
<span class="lineno"> 5591 </span><span class="spaces"></span><span class="nottickedoff">implElimLLVMBlock _ bp =</span>
<span class="lineno"> 5592 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 5593 </span><span class="spaces">    </span><span class="nottickedoff">implFailM $ MemBlockError $ permPretty ppinfo (Perm_LLVMBlock bp)</span></span>
<span class="lineno"> 5594 </span>
<span class="lineno"> 5595 </span>-- | Destruct a shape @sh1 orsh (sh2 orsh (... orsh shn))@ that is a
<span class="lineno"> 5596 </span>-- right-nested disjunctive shape into the list @[sh1,...,shn]@ of disjuncts
<span class="lineno"> 5597 </span>matchOrShapes :: PermExpr (LLVMShapeType w) -&gt; [PermExpr (LLVMShapeType w)]
<span class="lineno"> 5598 </span><span class="decl"><span class="nottickedoff">matchOrShapes (PExpr_OrShape sh1 (matchOrShapes -&gt; shs)) = sh1 : shs</span>
<span class="lineno"> 5599 </span><span class="spaces"></span><span class="nottickedoff">matchOrShapes sh = [sh]</span></span>
<span class="lineno"> 5600 </span>
<span class="lineno"> 5601 </span>-- | Assume the top of the stack contains @x:ps@, which are all the permissions
<span class="lineno"> 5602 </span>-- for @x@. Extract the @i@th conjuct from @ps@, which should be a @memblock@
<span class="lineno"> 5603 </span>-- permission, pop the remaining permissions back to @x@, eliminate the
<span class="lineno"> 5604 </span>-- @memblock@ permission using 'implElimLLVMBlock' if possible, and recombine
<span class="lineno"> 5605 </span>-- all the resulting permissions. If the block permission cannot be eliminated,
<span class="lineno"> 5606 </span>-- then fail.
<span class="lineno"> 5607 </span>implElimPopIthLLVMBlock :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5608 </span>                           ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 5609 </span>                           [AtomicPerm (LLVMPointerType w)] -&gt; Int -&gt;
<span class="lineno"> 5610 </span>                           ImplM vars s r ps (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5611 </span><span class="decl"><span class="nottickedoff">implElimPopIthLLVMBlock x ps i</span>
<span class="lineno"> 5612 </span><span class="spaces">  </span><span class="nottickedoff">| Perm_LLVMBlock bp &lt;- ps!!i =</span>
<span class="lineno"> 5613 </span><span class="spaces">    </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 5614 </span><span class="spaces">    </span><span class="nottickedoff">implElimLLVMBlock x bp &gt;&gt;&gt; getTopDistPerm x &gt;&gt;&gt;= \p' -&gt; recombinePerm x p'</span>
<span class="lineno"> 5615 </span><span class="spaces"></span><span class="nottickedoff">implElimPopIthLLVMBlock _ _ _ = error &quot;implElimPopIthLLVMBlock: malformed inputs&quot;</span></span>
<span class="lineno"> 5616 </span>
<span class="lineno"> 5617 </span>
<span class="lineno"> 5618 </span>-- | Assume the top of the stack contains @x:p1*...*pn@, which are all the
<span class="lineno"> 5619 </span>-- permissions for @x@. Extract the @i@th conjuct @pi@, which should be a
<span class="lineno"> 5620 </span>-- @memblock@ permission. Eliminate that @memblock@ permission using
<span class="lineno"> 5621 </span>-- 'implElimLLVMBlock' if possible to atomic permissions @x:q1*...*qm@, and
<span class="lineno"> 5622 </span>-- append the resulting atomic permissions @qi@ to the top of the stack, leaving
<span class="lineno"> 5623 </span>--
<span class="lineno"> 5624 </span>-- &gt; x:ps1 * ... * pi-1 * pi+1 * ... * pn * q1 * ... * qm
<span class="lineno"> 5625 </span>--
<span class="lineno"> 5626 </span>-- on top of the stack. Return the list of atomic permissions that are now on
<span class="lineno"> 5627 </span>-- top of the stack. If the @memblock@ permission @pi@ cannot be elimnated, then
<span class="lineno"> 5628 </span>-- fail.
<span class="lineno"> 5629 </span>implElimAppendIthLLVMBlock :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5630 </span>                              ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 5631 </span>                              [AtomicPerm (LLVMPointerType w)] -&gt; Int -&gt;
<span class="lineno"> 5632 </span>                              ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5633 </span>                              (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5634 </span>                              [AtomicPerm (LLVMPointerType w)]
<span class="lineno"> 5635 </span><span class="decl"><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i</span>
<span class="lineno"> 5636 </span><span class="spaces">  </span><span class="nottickedoff">| Perm_LLVMBlock bp &lt;- ps!!i =</span>
<span class="lineno"> 5637 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps i &gt;&gt;&gt; implElimLLVMBlock x bp &gt;&gt;&gt;</span>
<span class="lineno"> 5638 </span><span class="spaces">    </span><span class="nottickedoff">elimOrsExistsM x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 5639 </span><span class="spaces">      </span><span class="nottickedoff">(ValPerm_Conj ps') -&gt;</span>
<span class="lineno"> 5640 </span><span class="spaces">        </span><span class="nottickedoff">implAppendConjsM x (deleteNth i ps) ps' &gt;&gt;&gt; return (deleteNth i ps ++ ps')</span>
<span class="lineno"> 5641 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error (&quot;implElimAppendIthLLVMBlock: unexpected non-conjunctive perm &quot;</span>
<span class="lineno"> 5642 </span><span class="spaces">                  </span><span class="nottickedoff">++ &quot;returned by implElimLLVMBlock&quot;)</span>
<span class="lineno"> 5643 </span><span class="spaces"></span><span class="nottickedoff">implElimAppendIthLLVMBlock _ _ _ =</span>
<span class="lineno"> 5644 </span><span class="spaces">  </span><span class="nottickedoff">error &quot;implElimAppendIthLLVMBlock: malformed inputs&quot;</span></span>
<span class="lineno"> 5645 </span>
<span class="lineno"> 5646 </span>
<span class="lineno"> 5647 </span>-- | Return the indices in a list of permissions for all of those that could be
<span class="lineno"> 5648 </span>-- used to prove a permission containing the specified offset. Field and block
<span class="lineno"> 5649 </span>-- permissions can only be used if they definitely (in the sense of
<span class="lineno"> 5650 </span>-- 'bvPropHolds') contain the offset, while the 'Bool' flag indicates whether
<span class="lineno"> 5651 </span>-- array permissions are allowed to only possibly contain (in the sense of
<span class="lineno"> 5652 </span>-- 'bvPropCouldHold') the offset.
<span class="lineno"> 5653 </span>permIndicesForProvingOffset :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5654 </span>                            [AtomicPerm (LLVMPointerType w)] -&gt; Bool -&gt;
<span class="lineno"> 5655 </span>                            PermExpr (BVType w) -&gt; [Int]
<span class="lineno"> 5656 </span>-- Special case: if we have an any permission, return just it
<span class="lineno"> 5657 </span><span class="decl"><span class="nottickedoff">permIndicesForProvingOffset ps _ _</span>
<span class="lineno"> 5658 </span><span class="spaces">  </span><span class="nottickedoff">| Just i &lt;- findIndex (== Perm_Any) ps = [i]</span>
<span class="lineno"> 5659 </span><span class="spaces"></span><span class="nottickedoff">permIndicesForProvingOffset ps imprecise_p off =</span>
<span class="lineno"> 5660 </span><span class="spaces">  </span><span class="nottickedoff">let ixs_holdss = flip findMaybeIndices ps $ \p -&gt;</span>
<span class="lineno"> 5661 </span><span class="spaces">        </span><span class="nottickedoff">case llvmPermContainsOffset off p of</span>
<span class="lineno"> 5662 </span><span class="spaces">          </span><span class="nottickedoff">Just (_, holds) | holds || imprecise_p -&gt; Just holds</span>
<span class="lineno"> 5663 </span><span class="spaces">          </span><span class="nottickedoff">-- Just _ | llvmPermContainsArray p &amp;&amp; imprecise_p -&gt; Just False</span>
<span class="lineno"> 5664 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; Nothing in</span>
<span class="lineno"> 5665 </span><span class="spaces">  </span><span class="nottickedoff">case find (\(_,holds) -&gt; holds) ixs_holdss of</span>
<span class="lineno"> 5666 </span><span class="spaces">    </span><span class="nottickedoff">Just (i,_) -&gt; [i]</span>
<span class="lineno"> 5667 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; map fst ixs_holdss</span></span>
<span class="lineno"> 5668 </span>
<span class="lineno"> 5669 </span>-- | Assume @x:p@ is on top of the stack, where @p@ is a @memblock@ permission
<span class="lineno"> 5670 </span>-- that contains the supplied offset @off@, and repeatedly eliminate this
<span class="lineno"> 5671 </span>-- @memblock@ permission until @p@ has been converted to a non-@memblock@
<span class="lineno"> 5672 </span>-- permission @p'@ that contains @off@. Leave @p'@ on top of the stack, return
<span class="lineno"> 5673 </span>-- it as the return value, and recombine any other permissions that are yielded
<span class="lineno"> 5674 </span>-- by this elimination.
<span class="lineno"> 5675 </span>--
<span class="lineno"> 5676 </span>-- The notion of \&quot;contains\&quot; is determined by the supplied @imprecise_p@ flag: a
<span class="lineno"> 5677 </span>-- 'True' makes this mean \&quot;could contain\&quot; in the sense of 'bvPropCouldHold',
<span class="lineno"> 5678 </span>-- while 'False' makes this mean \&quot;definitely contains\&quot; in the sense of
<span class="lineno"> 5679 </span>-- 'bvPropHolds'.
<span class="lineno"> 5680 </span>--
<span class="lineno"> 5681 </span>-- If there are multiple ways to eliminate @p@ to a @p'@ that contains @off@
<span class="lineno"> 5682 </span>-- (which is only possible when @imprecise_p@ is 'True'), return each of them,
<span class="lineno"> 5683 </span>-- using 'implCatchM' to combine the different computation paths.
<span class="lineno"> 5684 </span>--
<span class="lineno"> 5685 </span>-- If no matches are found, fail using 'implFailVarM', citing the supplied
<span class="lineno"> 5686 </span>-- permission as the one we are trying to prove.
<span class="lineno"> 5687 </span>implElimLLVMBlockForOffset :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5688 </span>                              ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 5689 </span>                              Bool -&gt; PermExpr (BVType w) -&gt;
<span class="lineno"> 5690 </span>                              Mb vars (ValuePerm (LLVMPointerType w)) -&gt;
<span class="lineno"> 5691 </span>                              ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5692 </span>                              (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5693 </span>                              (AtomicPerm (LLVMPointerType w))
<span class="lineno"> 5694 </span><span class="decl"><span class="nottickedoff">implElimLLVMBlockForOffset x bp imprecise_p off mb_p =</span>
<span class="lineno"> 5695 </span><span class="spaces">  </span><span class="nottickedoff">implElimLLVMBlock x bp &gt;&gt;&gt; elimOrsExistsNamesM x &gt;&gt;&gt;= \p' -&gt;</span>
<span class="lineno"> 5696 </span><span class="spaces">  </span><span class="nottickedoff">case p' of</span>
<span class="lineno"> 5697 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Conj ps -&gt;</span>
<span class="lineno"> 5698 </span><span class="spaces">      </span><span class="nottickedoff">implGetLLVMPermForOffset x ps imprecise_p True off mb_p</span>
<span class="lineno"> 5699 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 5700 </span><span class="spaces">      </span><span class="nottickedoff">-- FIXME: handle eq perms here</span>
<span class="lineno"> 5701 </span><span class="spaces">      </span><span class="nottickedoff">implFailVarM &quot;implElimLLVMBlockForOffset&quot; x (ValPerm_LLVMBlock bp) mb_p</span></span>
<span class="lineno"> 5702 </span>
<span class="lineno"> 5703 </span>-- | Assume @x:p1*...*pn@ is on top of the stack, and try to find a permission
<span class="lineno"> 5704 </span>-- @pi@ that contains a given offset @off@. If a @pi@ is found that definitely
<span class="lineno"> 5705 </span>-- contains @off@, in the sense of 'bvPropHolds', it is selected. Otherwise, if
<span class="lineno"> 5706 </span>-- the first 'Bool' flag is 'True', imprecise matches are allowed, which are
<span class="lineno"> 5707 </span>-- permissions @pi@ that could contain @off@ in the sense of 'bvPropCouldHold',
<span class="lineno"> 5708 </span>-- and all of these matches are selected. Use 'implCatchM' to try each selected
<span class="lineno"> 5709 </span>-- @pi@ and fall back to the next one if it leads to a failure. If the selected
<span class="lineno"> 5710 </span>-- @pi@ is a @memblock@ permission and the second 'Bool' flag is 'True', it is
<span class="lineno"> 5711 </span>-- then repeatedly eliminated in the sense of 'implElimLLVMBlock' until a
<span class="lineno"> 5712 </span>-- non-@memblock@ permission containing @off@ results, and this permission is
<span class="lineno"> 5713 </span>-- then used as the new @pi@. The resulting permission @pi@ is then left on top
<span class="lineno"> 5714 </span>-- of the stack and returned by the function, while the remaining permissions
<span class="lineno"> 5715 </span>-- for @x@ are recombined with any other existing permissions for @x@. If no
<span class="lineno"> 5716 </span>-- matches are found, fail using 'implFailVarM', citing the supplied permission
<span class="lineno"> 5717 </span>-- as the one we are trying to prove.
<span class="lineno"> 5718 </span>implGetLLVMPermForOffset ::
<span class="lineno"> 5719 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 5720 </span>  ExprVar (LLVMPointerType w) {- ^ the variable @x@ -} -&gt;
<span class="lineno"> 5721 </span>  [AtomicPerm (LLVMPointerType w)]  {- ^ the permissions held for @x@ -} -&gt;
<span class="lineno"> 5722 </span>  Bool {- ^ whether imprecise matches are allowed -} -&gt;
<span class="lineno"> 5723 </span>  Bool  {- ^ whether block permissions should be eliminated -} -&gt;
<span class="lineno"> 5724 </span>  PermExpr (BVType w) {- ^ the offset we are looking for -} -&gt;
<span class="lineno"> 5725 </span>  Mb vars (ValuePerm (LLVMPointerType w)) {- ^ the perm we want to prove -} -&gt;
<span class="lineno"> 5726 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5727 </span>  (AtomicPerm (LLVMPointerType w))
<span class="lineno"> 5728 </span>
<span class="lineno"> 5729 </span><span class="decl"><span class="nottickedoff">implGetLLVMPermForOffset x ps imprecise_p elim_blocks_p off mb_p =</span>
<span class="lineno"> 5730 </span><span class="spaces">  </span><span class="nottickedoff">case permIndicesForProvingOffset ps imprecise_p off of</span>
<span class="lineno"> 5731 </span><span class="spaces">    </span><span class="nottickedoff">-- If we didn't find any matches, try to unfold on the left</span>
<span class="lineno"> 5732 </span><span class="spaces">    </span><span class="nottickedoff">[] -&gt;</span>
<span class="lineno"> 5733 </span><span class="spaces">      </span><span class="nottickedoff">implUnfoldOrFail x ps mb_p &gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 5734 </span><span class="spaces">      </span><span class="nottickedoff">elimOrsExistsNamesM x &gt;&gt;&gt;= \p'' -&gt;</span>
<span class="lineno"> 5735 </span><span class="spaces">      </span><span class="nottickedoff">(case p'' of</span>
<span class="lineno"> 5736 </span><span class="spaces">          </span><span class="nottickedoff">ValPerm_Conj ps' -&gt;</span>
<span class="lineno"> 5737 </span><span class="spaces">            </span><span class="nottickedoff">implGetLLVMPermForOffset x ps' imprecise_p elim_blocks_p off mb_p</span>
<span class="lineno"> 5738 </span><span class="spaces">          </span><span class="nottickedoff">-- FIXME: handle eq perms here</span>
<span class="lineno"> 5739 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; implFailVarM &quot;implGetLLVMPermForOffset&quot; x (ValPerm_Conj ps) mb_p)</span>
<span class="lineno"> 5740 </span><span class="spaces">    </span><span class="nottickedoff">ixs -&gt;</span>
<span class="lineno"> 5741 </span><span class="spaces">      </span><span class="nottickedoff">foldr1 (implCatchM &quot;implGetLLVMPermForOffset&quot; (ColonPair x mb_p)) $</span>
<span class="lineno"> 5742 </span><span class="spaces">      </span><span class="nottickedoff">flip map ixs $ \i -&gt;</span>
<span class="lineno"> 5743 </span><span class="spaces">      </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 5744 </span><span class="spaces">      </span><span class="nottickedoff">let ps' = deleteNth i ps in</span>
<span class="lineno"> 5745 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 5746 </span><span class="spaces">      </span><span class="nottickedoff">case ps!!i of</span>
<span class="lineno"> 5747 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMBlock bp</span>
<span class="lineno"> 5748 </span><span class="spaces">          </span><span class="nottickedoff">| elim_blocks_p -&gt;</span>
<span class="lineno"> 5749 </span><span class="spaces">            </span><span class="nottickedoff">implElimLLVMBlockForOffset x bp imprecise_p off mb_p</span>
<span class="lineno"> 5750 </span><span class="spaces">        </span><span class="nottickedoff">p_i -&gt; return p_i</span></span>
<span class="lineno"> 5751 </span>
<span class="lineno"> 5752 </span>
<span class="lineno"> 5753 </span>-- | Prove a @memblock@ permission with shape @sh1 orsh sh2 orsh ... orsh shn@
<span class="lineno"> 5754 </span>-- from one with shape @shi@.
<span class="lineno"> 5755 </span>implIntroOrShapeMultiM :: (NuMatchingAny1 r, 1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 5756 </span>                          ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 5757 </span>                          [PermExpr (LLVMShapeType w)] -&gt; Int -&gt;
<span class="lineno"> 5758 </span>                          ImplM vars s r (ps :&gt; LLVMPointerType w)
<span class="lineno"> 5759 </span>                          (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 5760 </span>-- Special case: if we take the or of a single shape, it is that shape itself,
<span class="lineno"> 5761 </span>-- so we don't need to do anything
<span class="lineno"> 5762 </span><span class="decl"><span class="nottickedoff">implIntroOrShapeMultiM _x _bp [_sh] 0 = return ()</span>
<span class="lineno"> 5763 </span><span class="spaces"></span><span class="nottickedoff">implIntroOrShapeMultiM x bp (sh1 : shs) 0 =</span>
<span class="lineno"> 5764 </span><span class="spaces">  </span><span class="nottickedoff">let sh2 = foldr1 PExpr_OrShape shs in</span>
<span class="lineno"> 5765 </span><span class="spaces">  </span><span class="nottickedoff">introOrLM x</span>
<span class="lineno"> 5766 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_LLVMBlock $ bp { llvmBlockShape = sh1 })</span>
<span class="lineno"> 5767 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_LLVMBlock $ bp { llvmBlockShape = sh2 }) &gt;&gt;&gt;</span>
<span class="lineno"> 5768 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockOr</span>
<span class="lineno"> 5769 </span><span class="spaces">                    </span><span class="nottickedoff">x (bp { llvmBlockShape = sh1 }) sh2)</span>
<span class="lineno"> 5770 </span><span class="spaces"></span><span class="nottickedoff">implIntroOrShapeMultiM x bp (sh1 : shs) i =</span>
<span class="lineno"> 5771 </span><span class="spaces">  </span><span class="nottickedoff">implIntroOrShapeMultiM x bp shs (i-1) &gt;&gt;&gt;</span>
<span class="lineno"> 5772 </span><span class="spaces">  </span><span class="nottickedoff">let sh2 = foldr1 PExpr_OrShape shs in</span>
<span class="lineno"> 5773 </span><span class="spaces">  </span><span class="nottickedoff">introOrRM x</span>
<span class="lineno"> 5774 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_LLVMBlock $ bp { llvmBlockShape = sh1 })</span>
<span class="lineno"> 5775 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_LLVMBlock $ bp { llvmBlockShape = sh2 }) &gt;&gt;&gt;</span>
<span class="lineno"> 5776 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockOr</span>
<span class="lineno"> 5777 </span><span class="spaces">                    </span><span class="nottickedoff">x (bp { llvmBlockShape = sh1 }) sh2)</span>
<span class="lineno"> 5778 </span><span class="spaces"></span><span class="nottickedoff">implIntroOrShapeMultiM _ _ _ _ = error &quot;implIntroOrShapeMultiM&quot;</span></span>
<span class="lineno"> 5779 </span>
<span class="lineno"> 5780 </span>
<span class="lineno"> 5781 </span>----------------------------------------------------------------------
<span class="lineno"> 5782 </span>-- * Support for Proving Lifetimes Are Current
<span class="lineno"> 5783 </span>----------------------------------------------------------------------
<span class="lineno"> 5784 </span>
<span class="lineno"> 5785 </span>-- | Build a 'LifetimeCurrentPerms' to prove that a lifetime @l@ is current in
<span class="lineno"> 5786 </span>-- the current permission set, failing if this is not possible
<span class="lineno"> 5787 </span>getLifetimeCurrentPerms :: NuMatchingAny1 r =&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 5788 </span>                           ImplM vars s r ps ps (Some LifetimeCurrentPerms)
<span class="lineno"> 5789 </span><span class="decl"><span class="nottickedoff">getLifetimeCurrentPerms PExpr_Always = pure $ Some AlwaysCurrentPerms</span>
<span class="lineno"> 5790 </span><span class="spaces"></span><span class="nottickedoff">getLifetimeCurrentPerms (PExpr_Var l) =</span>
<span class="lineno"> 5791 </span><span class="spaces">  </span><span class="nottickedoff">getPerm l &gt;&gt;= \case</span>
<span class="lineno"> 5792 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_LOwned ls tps_in tps_out ps_in ps_out -&gt;</span>
<span class="lineno"> 5793 </span><span class="spaces">      </span><span class="nottickedoff">pure $ Some $ LOwnedCurrentPerms l ls tps_in tps_out ps_in ps_out</span>
<span class="lineno"> 5794 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_LOwnedSimple tps ps -&gt;</span>
<span class="lineno"> 5795 </span><span class="spaces">      </span><span class="nottickedoff">pure $ Some $ LOwnedSimpleCurrentPerms l tps ps</span>
<span class="lineno"> 5796 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_LCurrent l' -&gt;</span>
<span class="lineno"> 5797 </span><span class="spaces">      </span><span class="nottickedoff">getLifetimeCurrentPerms l' &gt;&gt;= \some_cur_perms -&gt;</span>
<span class="lineno"> 5798 </span><span class="spaces">      </span><span class="nottickedoff">case some_cur_perms of</span>
<span class="lineno"> 5799 </span><span class="spaces">        </span><span class="nottickedoff">Some cur_perms -&gt; pure $ Some $ CurrentTransPerms cur_perms l</span>
<span class="lineno"> 5800 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 5801 </span><span class="spaces">      </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 5802 </span><span class="spaces">        </span><span class="nottickedoff">implFailM $ LifetimeError (LifetimeCurrentError $ permPretty ppinfo l)</span></span>
<span class="lineno"> 5803 </span>
<span class="lineno"> 5804 </span>-- | Prove the permissions represented by a 'LifetimeCurrentPerms'
<span class="lineno"> 5805 </span>proveLifetimeCurrent :: NuMatchingAny1 r =&gt; LifetimeCurrentPerms ps_l -&gt;
<span class="lineno"> 5806 </span>                        ImplM vars s r (ps :++: ps_l) ps ()
<span class="lineno"> 5807 </span><span class="decl"><span class="nottickedoff">proveLifetimeCurrent AlwaysCurrentPerms = pure ()</span>
<span class="lineno"> 5808 </span><span class="spaces"></span><span class="nottickedoff">proveLifetimeCurrent (LOwnedCurrentPerms l ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 5809 </span><span class="spaces">  </span><span class="nottickedoff">implPushM l (ValPerm_LOwned ls tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 5810 </span><span class="spaces"></span><span class="nottickedoff">proveLifetimeCurrent (LOwnedSimpleCurrentPerms l tps ps) =</span>
<span class="lineno"> 5811 </span><span class="spaces">  </span><span class="nottickedoff">implPushM l (ValPerm_LOwnedSimple tps ps)</span>
<span class="lineno"> 5812 </span><span class="spaces"></span><span class="nottickedoff">proveLifetimeCurrent (CurrentTransPerms cur_perms l) =</span>
<span class="lineno"> 5813 </span><span class="spaces">  </span><span class="nottickedoff">proveLifetimeCurrent cur_perms &gt;&gt;&gt;</span>
<span class="lineno"> 5814 </span><span class="spaces">  </span><span class="nottickedoff">let l' = lifetimeCurrentPermsLifetime cur_perms</span>
<span class="lineno"> 5815 </span><span class="spaces">      </span><span class="nottickedoff">p_l_cur = ValPerm_LCurrent l' in</span>
<span class="lineno"> 5816 </span><span class="spaces">  </span><span class="nottickedoff">implPushCopyM l p_l_cur</span></span>
<span class="lineno"> 5817 </span>
<span class="lineno"> 5818 </span>
<span class="lineno"> 5819 </span>----------------------------------------------------------------------
<span class="lineno"> 5820 </span>-- * Recombining Permissions
<span class="lineno"> 5821 </span>----------------------------------------------------------------------
<span class="lineno"> 5822 </span>
<span class="lineno"> 5823 </span>-- | Simplify an equality permission @x:eq(e)@ that we assume is on the top of
<span class="lineno"> 5824 </span>-- the stack by substituting any equality permissions on variables in @e@,
<span class="lineno"> 5825 </span>-- returning the resulting expression
<span class="lineno"> 5826 </span>simplEqPerm :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; PermExpr a -&gt;
<span class="lineno"> 5827 </span>               ImplM vars s r (as :&gt; a) (as :&gt; a) (PermExpr a)
<span class="lineno"> 5828 </span><span class="decl"><span class="nottickedoff">simplEqPerm x e@(PExpr_Var y) =</span>
<span class="lineno"> 5829 </span><span class="spaces">  </span><span class="nottickedoff">getPerm y &gt;&gt;= \case</span>
<span class="lineno"> 5830 </span><span class="spaces">  </span><span class="nottickedoff">p@(ValPerm_Eq e') -&gt; implPushCopyM y p &gt;&gt;&gt; introCastM x y p &gt;&gt;&gt; pure e'</span>
<span class="lineno"> 5831 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; pure e</span>
<span class="lineno"> 5832 </span><span class="spaces"></span><span class="nottickedoff">simplEqPerm x e@(PExpr_LLVMOffset y off) =</span>
<span class="lineno"> 5833 </span><span class="spaces">  </span><span class="nottickedoff">getPerm y &gt;&gt;= \case</span>
<span class="lineno"> 5834 </span><span class="spaces">  </span><span class="nottickedoff">p@(ValPerm_Eq e') -&gt;</span>
<span class="lineno"> 5835 </span><span class="spaces">    </span><span class="nottickedoff">implPushCopyM y p &gt;&gt;&gt; castLLVMPtrM y p off x &gt;&gt;&gt; pure (addLLVMOffset e' off)</span>
<span class="lineno"> 5836 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; pure e</span>
<span class="lineno"> 5837 </span><span class="spaces"></span><span class="nottickedoff">simplEqPerm _ e = pure e</span></span>
<span class="lineno"> 5838 </span>
<span class="lineno"> 5839 </span>-- | Recombine the permission @x:p@ on top of the stack back into the existing
<span class="lineno"> 5840 </span>-- permission for @x@
<span class="lineno"> 5841 </span>recombinePerm :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 5842 </span>                 ImplM vars s r as (as :&gt; a) ()
<span class="lineno"> 5843 </span><span class="decl"><span class="nottickedoff">recombinePerm x p = getPerm x &gt;&gt;&gt;= \x_p -&gt; recombinePermExpl x x_p p</span></span>
<span class="lineno"> 5844 </span>
<span class="lineno"> 5845 </span>-- | Recombine the permission @x:p@ on top of the stack back into the existing
<span class="lineno"> 5846 </span>-- permission @x_p@ for @x@, where @x_p@ is given explicitly as the first
<span class="lineno"> 5847 </span>-- permission argument and @p@ is the second
<span class="lineno"> 5848 </span>recombinePermExpl :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 5849 </span>                     ValuePerm a -&gt; ImplM vars s r as (as :&gt; a) ()
<span class="lineno"> 5850 </span><span class="decl"><span class="nottickedoff">recombinePermExpl x x_p p =</span>
<span class="lineno"> 5851 </span><span class="spaces">  </span><span class="nottickedoff">implVerbTraceM (\i -&gt;</span>
<span class="lineno"> 5852 </span><span class="spaces">                   </span><span class="nottickedoff">sep [pretty &quot;recombinePerm&quot; &lt;+&gt;</span>
<span class="lineno"> 5853 </span><span class="spaces">                        </span><span class="nottickedoff">permPretty i x &lt;&gt; colon &lt;&gt; permPretty i x_p,</span>
<span class="lineno"> 5854 </span><span class="spaces">                        </span><span class="nottickedoff">pretty &quot;&lt;-&quot; &lt;+&gt; permPretty i p]) &gt;&gt;&gt;</span>
<span class="lineno"> 5855 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm' x x_p p</span></span>
<span class="lineno"> 5856 </span>
<span class="lineno"> 5857 </span>-- | This is the implementation of 'recombinePermExpl'; see the documentation
<span class="lineno"> 5858 </span>-- for that function for details
<span class="lineno"> 5859 </span>recombinePerm' :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 5860 </span>                  ExprVar a -&gt; ValuePerm a -&gt; ValuePerm a -&gt;
<span class="lineno"> 5861 </span>                  ImplM vars s r as (as :&gt; a) ()
<span class="lineno"> 5862 </span><span class="decl"><span class="nottickedoff">recombinePerm' x _ p@ValPerm_True = implDropM x p</span>
<span class="lineno"> 5863 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x _ ValPerm_False = implElimFalseM x</span>
<span class="lineno"> 5864 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x _ p@(ValPerm_Eq (PExpr_Var y)) | y == x = implDropM x p</span>
<span class="lineno"> 5865 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x ValPerm_True (ValPerm_Eq e) =</span>
<span class="lineno"> 5866 </span><span class="spaces">  </span><span class="nottickedoff">simplEqPerm x e &gt;&gt;&gt;= \e' -&gt; implPopM x (ValPerm_Eq e')</span>
<span class="lineno"> 5867 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p (ValPerm_LOwnedSimple tps lops) =</span>
<span class="lineno"> 5868 </span><span class="spaces">  </span><span class="nottickedoff">case lownedPermsSimpleIn x lops of</span>
<span class="lineno"> 5869 </span><span class="spaces">    </span><span class="nottickedoff">Just ps_simple -&gt;</span>
<span class="lineno"> 5870 </span><span class="spaces">      </span><span class="nottickedoff">-- If p is a simple lowned permission, eliminate it</span>
<span class="lineno"> 5871 </span><span class="spaces">      </span><span class="nottickedoff">-- FIXME: do we want to do this? If not, we need more subtle rules for proving</span>
<span class="lineno"> 5872 </span><span class="spaces">      </span><span class="nottickedoff">-- simple lowned permissions, and probably widening support for it too...</span>
<span class="lineno"> 5873 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLOwnedSimple x tps lops) &gt;&gt;&gt;</span>
<span class="lineno"> 5874 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm' x x_p (ValPerm_LOwned [] tps tps ps_simple lops)</span>
<span class="lineno"> 5875 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 5876 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;recombinePerm: cannot compute input permissions for simple lowned permission&quot;</span>
<span class="lineno"> 5877 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x ValPerm_True p = implPopM x p</span>
<span class="lineno"> 5878 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x (ValPerm_Eq (PExpr_Var y)) _</span>
<span class="lineno"> 5879 </span><span class="spaces">  </span><span class="nottickedoff">| y == x = error &quot;recombinePerm: variable x has permission eq(x)!&quot;</span>
<span class="lineno"> 5880 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x (ValPerm_Eq e1) p@(ValPerm_Eq e2)</span>
<span class="lineno"> 5881 </span><span class="spaces">  </span><span class="nottickedoff">| e1 == e2 = implDropM x p</span>
<span class="lineno"> 5882 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p@(ValPerm_Eq (PExpr_Var y)) p =</span>
<span class="lineno"> 5883 </span><span class="spaces">  </span><span class="nottickedoff">implPushCopyM x x_p &gt;&gt;&gt;</span>
<span class="lineno"> 5884 </span><span class="spaces">  </span><span class="nottickedoff">invertEqM x y &gt;&gt;&gt; implSwapM x p y (ValPerm_Eq (PExpr_Var x)) &gt;&gt;&gt;</span>
<span class="lineno"> 5885 </span><span class="spaces">  </span><span class="nottickedoff">introCastM y x p &gt;&gt;&gt; getPerm y &gt;&gt;&gt;= \y_p -&gt; recombinePermExpl y y_p p</span>
<span class="lineno"> 5886 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p@(ValPerm_Eq (PExpr_LLVMOffset y off)) p =</span>
<span class="lineno"> 5887 </span><span class="spaces">  </span><span class="nottickedoff">implPushCopyM x x_p &gt;&gt;&gt;</span>
<span class="lineno"> 5888 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_InvertLLVMOffsetEq x off y) &gt;&gt;&gt;</span>
<span class="lineno"> 5889 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x p y (ValPerm_Eq (PExpr_LLVMOffset x (bvNegate off))) &gt;&gt;&gt;</span>
<span class="lineno"> 5890 </span><span class="spaces">  </span><span class="nottickedoff">castLLVMPtrM x p (bvNegate off) y &gt;&gt;&gt;</span>
<span class="lineno"> 5891 </span><span class="spaces">  </span><span class="nottickedoff">getPerm y &gt;&gt;&gt;= \y_p -&gt;</span>
<span class="lineno"> 5892 </span><span class="spaces">  </span><span class="nottickedoff">recombinePermExpl y y_p (offsetLLVMPerm off p)</span>
<span class="lineno"> 5893 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x _p p'@(ValPerm_Eq PExpr_Unit) =</span>
<span class="lineno"> 5894 </span><span class="spaces">  </span><span class="nottickedoff">-- When trying to combine a permission x:eq(()), just drop this permission</span>
<span class="lineno"> 5895 </span><span class="spaces">  </span><span class="nottickedoff">implDropM x p'</span>
<span class="lineno"> 5896 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x (ValPerm_Eq e1) (ValPerm_Eq e2)</span>
<span class="lineno"> 5897 </span><span class="spaces">  </span><span class="nottickedoff">| exprsUnequal e1 e2 =</span>
<span class="lineno"> 5898 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x (ValPerm_Eq e1) &gt;&gt;&gt;</span>
<span class="lineno"> 5899 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroAnyEqEq x e2 e1) &gt;&gt;&gt;</span>
<span class="lineno"> 5900 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x ValPerm_Any</span>
<span class="lineno"> 5901 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x (ValPerm_Conj ps) (ValPerm_Eq (PExpr_LLVMWord e))</span>
<span class="lineno"> 5902 </span><span class="spaces">  </span><span class="nottickedoff">| Just i &lt;- findIndex isLLVMPointerPerm ps =</span>
<span class="lineno"> 5903 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x (ValPerm_Conj ps) &gt;&gt;&gt; implGetConjM x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 5904 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 5905 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroAnyWordPtr x e (ps!!i)) &gt;&gt;&gt;</span>
<span class="lineno"> 5906 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x ValPerm_Any</span>
<span class="lineno"> 5907 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x p p'@(ValPerm_Eq _) =</span>
<span class="lineno"> 5908 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: we could handle this by swapping the stack with the variable perm and</span>
<span class="lineno"> 5909 </span><span class="spaces">  </span><span class="nottickedoff">-- calling recombinePerm again, but this could potentially create permission</span>
<span class="lineno"> 5910 </span><span class="spaces">  </span><span class="nottickedoff">-- equality cycles with, e.g., x:eq(y) * y:eq(x). So instead we just drop the</span>
<span class="lineno"> 5911 </span><span class="spaces">  </span><span class="nottickedoff">-- new equality permission.</span>
<span class="lineno"> 5912 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 5913 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;recombinePerm: unexpected equality permission being recombined&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 5914 </span><span class="spaces">               </span><span class="nottickedoff">permPretty i x &lt;+&gt; colon &lt;+&gt; permPretty i p &lt;+&gt;</span>
<span class="lineno"> 5915 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;&lt;-&quot; &lt;+&gt; permPretty i p') &gt;&gt;&gt;</span>
<span class="lineno"> 5916 </span><span class="spaces">  </span><span class="nottickedoff">implDropM x p'</span>
<span class="lineno"> 5917 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p (ValPerm_Or _ _) =</span>
<span class="lineno"> 5918 </span><span class="spaces">  </span><span class="nottickedoff">elimOrsExistsM x &gt;&gt;&gt;= \p' -&gt; recombinePermExpl x x_p p'</span>
<span class="lineno"> 5919 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p (ValPerm_Exists _) =</span>
<span class="lineno"> 5920 </span><span class="spaces">  </span><span class="nottickedoff">elimOrsExistsM x &gt;&gt;&gt;= \p' -&gt; recombinePermExpl x x_p p'</span>
<span class="lineno"> 5921 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p@(ValPerm_Or _ _) p =</span>
<span class="lineno"> 5922 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x x_p &gt;&gt;&gt; elimOrsExistsM x &gt;&gt;&gt;= \x_p' -&gt;</span>
<span class="lineno"> 5923 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x x_p' &gt;&gt;&gt; recombinePermExpl x x_p' p</span>
<span class="lineno"> 5924 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p@(ValPerm_Exists _) p =</span>
<span class="lineno"> 5925 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x x_p &gt;&gt;&gt; elimOrsExistsM x &gt;&gt;&gt;= \x_p' -&gt;</span>
<span class="lineno"> 5926 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x x_p' &gt;&gt;&gt; recombinePermExpl x x_p' p</span>
<span class="lineno"> 5927 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x (ValPerm_Conj x_ps) (ValPerm_Conj (p:ps)) =</span>
<span class="lineno"> 5928 </span><span class="spaces">  </span><span class="nottickedoff">implExtractConjM x (p:ps) 0 &gt;&gt;&gt;</span>
<span class="lineno"> 5929 </span><span class="spaces">  </span><span class="nottickedoff">implSwapM x (ValPerm_Conj1 p) x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 5930 </span><span class="spaces">  </span><span class="nottickedoff">recombinePermConj x x_ps p &gt;&gt;&gt;</span>
<span class="lineno"> 5931 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 5932 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p (ValPerm_Named npn args off)</span>
<span class="lineno"> 5933 </span><span class="spaces">  </span><span class="nottickedoff">-- When recombining a conjuctive named permission, turn it into a conjunction</span>
<span class="lineno"> 5934 </span><span class="spaces">  </span><span class="nottickedoff">-- and recombine it</span>
<span class="lineno"> 5935 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- nameIsConjRepr npn =</span>
<span class="lineno"> 5936 </span><span class="spaces">    </span><span class="nottickedoff">implNamedToConjM x npn args off &gt;&gt;&gt;</span>
<span class="lineno"> 5937 </span><span class="spaces">    </span><span class="nottickedoff">recombinePermExpl x x_p (ValPerm_Conj1 $ Perm_NamedConj npn args off)</span>
<span class="lineno"> 5938 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p (ValPerm_Named npn args off)</span>
<span class="lineno"> 5939 </span><span class="spaces">  </span><span class="nottickedoff">-- When recombining a non-conjuctive but unfoldable named permission, unfold</span>
<span class="lineno"> 5940 </span><span class="spaces">  </span><span class="nottickedoff">-- it and recombine it</span>
<span class="lineno"> 5941 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- nameCanFoldRepr npn =</span>
<span class="lineno"> 5942 </span><span class="spaces">    </span><span class="nottickedoff">implUnfoldNamedM x npn args off &gt;&gt;&gt;= \p' -&gt;</span>
<span class="lineno"> 5943 </span><span class="spaces">    </span><span class="nottickedoff">recombinePermExpl x x_p p'</span>
<span class="lineno"> 5944 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p@(ValPerm_Named npn args off) p</span>
<span class="lineno"> 5945 </span><span class="spaces">  </span><span class="nottickedoff">-- When recombining into a conjuctive named permission, turn it into a</span>
<span class="lineno"> 5946 </span><span class="spaces">  </span><span class="nottickedoff">-- conjunction and recombine it</span>
<span class="lineno"> 5947 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- nameIsConjRepr npn =</span>
<span class="lineno"> 5948 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x x_p &gt;&gt;&gt; implNamedToConjM x npn args off &gt;&gt;&gt;</span>
<span class="lineno"> 5949 </span><span class="spaces">    </span><span class="nottickedoff">let x_p' = ValPerm_Conj1 $ Perm_NamedConj npn args off in</span>
<span class="lineno"> 5950 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x x_p' &gt;&gt;&gt; recombinePermExpl x x_p' p</span>
<span class="lineno"> 5951 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x x_p@(ValPerm_Named npn args off) p</span>
<span class="lineno"> 5952 </span><span class="spaces">  </span><span class="nottickedoff">-- When recombining into a non-conjuctive but unfoldable named permission, unfold</span>
<span class="lineno"> 5953 </span><span class="spaces">  </span><span class="nottickedoff">-- it and recombine it</span>
<span class="lineno"> 5954 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- nameCanFoldRepr npn =</span>
<span class="lineno"> 5955 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x x_p &gt;&gt;&gt; implUnfoldNamedM x npn args off &gt;&gt;&gt;= \x_p' -&gt;</span>
<span class="lineno"> 5956 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x x_p' &gt;&gt;&gt; recombinePermExpl x x_p' p</span>
<span class="lineno"> 5957 </span><span class="spaces"></span><span class="nottickedoff">recombinePerm' x _ p = implDropM x p</span></span>
<span class="lineno"> 5958 </span>
<span class="lineno"> 5959 </span>-- | Recombine a single conjuct @x:p@ on top of the stack back into the existing
<span class="lineno"> 5960 </span>-- conjuctive permission @x_p1 * ... * x_pn@ for @x@, returning the resulting
<span class="lineno"> 5961 </span>-- permission conjucts for @x@
<span class="lineno"> 5962 </span>recombinePermConj :: HasCallStack =&gt; NuMatchingAny1 r =&gt; ExprVar a -&gt; [AtomicPerm a] -&gt;
<span class="lineno"> 5963 </span>                     AtomicPerm a -&gt; ImplM vars s r as (as :&gt; a) ()
<span class="lineno"> 5964 </span>
<span class="lineno"> 5965 </span>-- If p is a field permission whose range is a subset of that of a permission we
<span class="lineno"> 5966 </span>-- already hold, drop it
<span class="lineno"> 5967 </span><span class="decl"><span class="nottickedoff">recombinePermConj x x_ps (Perm_LLVMField fp)</span>
<span class="lineno"> 5968 </span><span class="spaces">  </span><span class="nottickedoff">| any (llvmAtomicPermContainsRange $ llvmFieldRange fp) x_ps =</span>
<span class="lineno"> 5969 </span><span class="spaces">    </span><span class="nottickedoff">implDropM x $ ValPerm_LLVMField fp</span>
<span class="lineno"> 5970 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5971 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: if p is a field permission whose range overlaps with but is not wholly</span>
<span class="lineno"> 5972 </span><span class="spaces"></span><span class="nottickedoff">-- contained in a permission we already hold, split it and recombine parts of it</span>
<span class="lineno"> 5973 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5974 </span><span class="spaces"></span><span class="nottickedoff">-- If p is an array read permission whose offsets match an existing array</span>
<span class="lineno"> 5975 </span><span class="spaces"></span><span class="nottickedoff">-- permission, drop it</span>
<span class="lineno"> 5976 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x x_ps p@(Perm_LLVMArray ap)</span>
<span class="lineno"> 5977 </span><span class="spaces">  </span><span class="nottickedoff">| Just _ &lt;-</span>
<span class="lineno"> 5978 </span><span class="spaces">      </span><span class="nottickedoff">find (\case Perm_LLVMArray ap' -&gt;</span>
<span class="lineno"> 5979 </span><span class="spaces">                    </span><span class="nottickedoff">bvEq (llvmArrayOffset ap') (llvmArrayOffset ap) &amp;&amp;</span>
<span class="lineno"> 5980 </span><span class="spaces">                    </span><span class="nottickedoff">bvEq (llvmArrayLen ap') (llvmArrayLen ap)</span>
<span class="lineno"> 5981 </span><span class="spaces">                  </span><span class="nottickedoff">_ -&gt; False) x_ps</span>
<span class="lineno"> 5982 </span><span class="spaces">  </span><span class="nottickedoff">, PExpr_Read &lt;- llvmArrayRW ap =</span>
<span class="lineno"> 5983 </span><span class="spaces">    </span><span class="nottickedoff">implDropM x (ValPerm_Conj1 p)</span>
<span class="lineno"> 5984 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5985 </span><span class="spaces"></span><span class="nottickedoff">-- If p is an is_llvmptr permission and x_ps already contains one, drop it</span>
<span class="lineno"> 5986 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x x_ps p@Perm_IsLLVMPtr</span>
<span class="lineno"> 5987 </span><span class="spaces">  </span><span class="nottickedoff">| elem Perm_IsLLVMPtr x_ps =</span>
<span class="lineno"> 5988 </span><span class="spaces">    </span><span class="nottickedoff">implDropM x (ValPerm_Conj1 p)</span>
<span class="lineno"> 5989 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5990 </span><span class="spaces"></span><span class="nottickedoff">-- NOTE: we do not return a field that was borrowed from an array, because if we</span>
<span class="lineno"> 5991 </span><span class="spaces"></span><span class="nottickedoff">-- have a field (or block) that was borrowed from an array, it almost certainly</span>
<span class="lineno"> 5992 </span><span class="spaces"></span><span class="nottickedoff">-- was borrowed because we accessed it, so it will contain eq permissions, which</span>
<span class="lineno"> 5993 </span><span class="spaces"></span><span class="nottickedoff">-- make it a stronger permission than the cell permission in the array</span>
<span class="lineno"> 5994 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 5995 </span><span class="spaces"></span><span class="nottickedoff">-- If p is an array that was borrowed from some other array, return it</span>
<span class="lineno"> 5996 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x x_ps (Perm_LLVMArray ap)</span>
<span class="lineno"> 5997 </span><span class="spaces">  </span><span class="nottickedoff">| (ap_bigger,i):_ &lt;-</span>
<span class="lineno"> 5998 </span><span class="spaces">      </span><span class="nottickedoff">flip mapMaybe (zip x_ps [0::Int ..])</span>
<span class="lineno"> 5999 </span><span class="spaces">      </span><span class="nottickedoff">(\case (Perm_LLVMArray ap', i)</span>
<span class="lineno"> 6000 </span><span class="spaces">               </span><span class="nottickedoff">| isJust (llvmArrayIsOffsetArray ap' ap) &amp;&amp;</span>
<span class="lineno"> 6001 </span><span class="spaces">                 </span><span class="nottickedoff">elem (llvmSubArrayBorrow ap' ap) (llvmArrayBorrows ap') &amp;&amp;</span>
<span class="lineno"> 6002 </span><span class="spaces">                 </span><span class="nottickedoff">llvmArrayStride ap' == llvmArrayStride ap &amp;&amp;</span>
<span class="lineno"> 6003 </span><span class="spaces">                 </span><span class="nottickedoff">llvmArrayCellShape ap' == llvmArrayCellShape ap -&gt;</span>
<span class="lineno"> 6004 </span><span class="spaces">                 </span><span class="nottickedoff">return (ap', i)</span>
<span class="lineno"> 6005 </span><span class="spaces">             </span><span class="nottickedoff">_ -&gt; Nothing) =</span>
<span class="lineno"> 6006 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x (ValPerm_Conj x_ps) &gt;&gt;&gt; implExtractConjM x x_ps i &gt;&gt;&gt;</span>
<span class="lineno"> 6007 </span><span class="spaces">    </span><span class="nottickedoff">let x_ps' = deleteNth i x_ps in</span>
<span class="lineno"> 6008 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x (ValPerm_Conj x_ps') &gt;&gt;&gt;</span>
<span class="lineno"> 6009 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayReturn x ap_bigger ap &gt;&gt;&gt;= \ap_bigger' -&gt;</span>
<span class="lineno"> 6010 </span><span class="spaces">    </span><span class="nottickedoff">recombinePermConj x x_ps' (Perm_LLVMArray ap_bigger')</span>
<span class="lineno"> 6011 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6012 </span><span class="spaces"></span><span class="nottickedoff">-- If p is a memblock permission whose range is a subset of that of a permission</span>
<span class="lineno"> 6013 </span><span class="spaces"></span><span class="nottickedoff">-- we already hold, drop it</span>
<span class="lineno"> 6014 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x x_ps (Perm_LLVMBlock bp)</span>
<span class="lineno"> 6015 </span><span class="spaces">  </span><span class="nottickedoff">| any (llvmAtomicPermContainsRange $ llvmBlockRange bp) x_ps =</span>
<span class="lineno"> 6016 </span><span class="spaces">    </span><span class="nottickedoff">implDropM x $ ValPerm_LLVMBlock bp</span>
<span class="lineno"> 6017 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6018 </span><span class="spaces"></span><span class="nottickedoff">-- If p is a memblock permission whose range overlaps with but is not wholly</span>
<span class="lineno"> 6019 </span><span class="spaces"></span><span class="nottickedoff">-- contained in a permission we already hold, eliminate it and recombine</span>
<span class="lineno"> 6020 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 6021 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: if the elimination fails, this shouldn't fail, it should just</span>
<span class="lineno"> 6022 </span><span class="spaces"></span><span class="nottickedoff">-- recombine without eliminating, so we should special case those shapes where</span>
<span class="lineno"> 6023 </span><span class="spaces"></span><span class="nottickedoff">-- the elimination will fail</span>
<span class="lineno"> 6024 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 6025 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x x_ps (Perm_LLVMBlock bp)</span>
<span class="lineno"> 6026 </span><span class="spaces">  </span><span class="nottickedoff">| any (llvmAtomicPermOverlapsRange $ llvmBlockRange bp) x_ps =</span>
<span class="lineno"> 6027 </span><span class="spaces">    </span><span class="nottickedoff">implElimLLVMBlock x bp &gt;&gt;&gt;</span>
<span class="lineno"> 6028 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 6029 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x p</span>
<span class="lineno"> 6030 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 6031 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6032 </span><span class="spaces"></span><span class="nottickedoff">-- If p is a memblock permission on the false shape, eliminate the block to</span>
<span class="lineno"> 6033 </span><span class="spaces"></span><span class="nottickedoff">-- a false permission (and eliminate the false permission itself)</span>
<span class="lineno"> 6034 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x _ (Perm_LLVMBlock bp)</span>
<span class="lineno"> 6035 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_FalseShape &lt;- llvmBlockShape bp</span>
<span class="lineno"> 6036 </span><span class="spaces">  </span><span class="nottickedoff">= implElimLLVMBlock x bp &gt;&gt;&gt; implElimFalseM x</span>
<span class="lineno"> 6037 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6038 </span><span class="spaces"></span><span class="nottickedoff">-- Default case: insert p at the end of the x_ps</span>
<span class="lineno"> 6039 </span><span class="spaces"></span><span class="nottickedoff">recombinePermConj x x_ps p =</span>
<span class="lineno"> 6040 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x (ValPerm_Conj x_ps) &gt;&gt;&gt;</span>
<span class="lineno"> 6041 </span><span class="spaces">  </span><span class="nottickedoff">implInsertConjM x p x_ps (length x_ps) &gt;&gt;&gt;</span>
<span class="lineno"> 6042 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x (ValPerm_Conj (x_ps ++ [p]))</span></span>
<span class="lineno"> 6043 </span>
<span class="lineno"> 6044 </span>
<span class="lineno"> 6045 </span>-- | Recombine the permissions on the stack back into the permission set
<span class="lineno"> 6046 </span>recombinePerms :: HasCallStack =&gt; NuMatchingAny1 r =&gt; DistPerms ps -&gt; ImplM vars s r RNil ps ()
<span class="lineno"> 6047 </span><span class="decl"><span class="nottickedoff">recombinePerms DistPermsNil = pure ()</span>
<span class="lineno"> 6048 </span><span class="spaces"></span><span class="nottickedoff">recombinePerms (DistPermsCons ps' x p) =</span>
<span class="lineno"> 6049 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt; recombinePerms ps'</span></span>
<span class="lineno"> 6050 </span>
<span class="lineno"> 6051 </span>-- | Recombine some of the permissions on the stack back into the permission set
<span class="lineno"> 6052 </span>recombinePermsPartial :: HasCallStack =&gt; NuMatchingAny1 r =&gt; f ps -&gt; DistPerms ps' -&gt;
<span class="lineno"> 6053 </span>                         ImplM vars s r ps (ps :++: ps') ()
<span class="lineno"> 6054 </span><span class="decl"><span class="nottickedoff">recombinePermsPartial _ DistPermsNil = pure ()</span>
<span class="lineno"> 6055 </span><span class="spaces"></span><span class="nottickedoff">recombinePermsPartial ps (DistPermsCons ps' x p) =</span>
<span class="lineno"> 6056 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt; recombinePermsPartial ps ps'</span></span>
<span class="lineno"> 6057 </span>
<span class="lineno"> 6058 </span>-- | Recombine some of the permissions on the stack back into the permission
<span class="lineno"> 6059 </span>-- set, but in reverse order
<span class="lineno"> 6060 </span>recombinePermsRevPartial :: HasCallStack =&gt; NuMatchingAny1 r =&gt; RAssign Proxy ps1 -&gt; DistPerms ps2 -&gt;
<span class="lineno"> 6061 </span>                            ImplM vars s r ps1 (ps1 :++: ps2) ()
<span class="lineno"> 6062 </span><span class="decl"><span class="nottickedoff">recombinePermsRevPartial _ DistPermsNil = return ()</span>
<span class="lineno"> 6063 </span><span class="spaces"></span><span class="nottickedoff">recombinePermsRevPartial ps1 ps2@(DistPermsCons ps2' x p) =</span>
<span class="lineno"> 6064 </span><span class="spaces">  </span><span class="nottickedoff">implMoveDownM ps1 (rlToProxies ps2) x MNil &gt;&gt;&gt;</span>
<span class="lineno"> 6065 </span><span class="spaces">  </span><span class="nottickedoff">recombinePermsRevPartial (ps1 :&gt;: Proxy) ps2' &gt;&gt;&gt;</span>
<span class="lineno"> 6066 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm x p</span></span>
<span class="lineno"> 6067 </span>
<span class="lineno"> 6068 </span>-- | Recombine the permissions on the stack back into the permission set, but in
<span class="lineno"> 6069 </span>-- reverse order
<span class="lineno"> 6070 </span>recombinePermsRev :: HasCallStack =&gt; NuMatchingAny1 r =&gt; DistPerms ps -&gt;
<span class="lineno"> 6071 </span>                     ImplM vars s r RNil ps ()
<span class="lineno"> 6072 </span><span class="decl"><span class="nottickedoff">recombinePermsRev ps</span>
<span class="lineno"> 6073 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- RL.prependRNilEq ps = recombinePermsRevPartial MNil ps</span></span>
<span class="lineno"> 6074 </span>
<span class="lineno"> 6075 </span>-- | Recombine the permissions for a 'LifetimeCurrentPerms' list
<span class="lineno"> 6076 </span>recombineLifetimeCurrentPerms :: HasCallStack =&gt; NuMatchingAny1 r =&gt;
<span class="lineno"> 6077 </span>                                 LifetimeCurrentPerms ps_l -&gt;
<span class="lineno"> 6078 </span>                                 ImplM vars s r ps (ps :++: ps_l) ()
<span class="lineno"> 6079 </span><span class="decl"><span class="nottickedoff">recombineLifetimeCurrentPerms AlwaysCurrentPerms = pure ()</span>
<span class="lineno"> 6080 </span><span class="spaces"></span><span class="nottickedoff">recombineLifetimeCurrentPerms (LOwnedCurrentPerms l ls tps_in tps_out ps_in ps_out) =</span>
<span class="lineno"> 6081 </span><span class="spaces">  </span><span class="nottickedoff">recombinePermExpl l ValPerm_True (ValPerm_LOwned ls tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 6082 </span><span class="spaces"></span><span class="nottickedoff">recombineLifetimeCurrentPerms (LOwnedSimpleCurrentPerms l tps ps) =</span>
<span class="lineno"> 6083 </span><span class="spaces">  </span><span class="nottickedoff">recombinePermExpl l ValPerm_True (ValPerm_LOwnedSimple tps ps)</span>
<span class="lineno"> 6084 </span><span class="spaces"></span><span class="nottickedoff">recombineLifetimeCurrentPerms (CurrentTransPerms cur_perms l) =</span>
<span class="lineno"> 6085 </span><span class="spaces">  </span><span class="nottickedoff">implDropM l (ValPerm_LCurrent $ lifetimeCurrentPermsLifetime cur_perms) &gt;&gt;&gt;</span>
<span class="lineno"> 6086 </span><span class="spaces">  </span><span class="nottickedoff">recombineLifetimeCurrentPerms cur_perms</span></span>
<span class="lineno"> 6087 </span>
<span class="lineno"> 6088 </span>
<span class="lineno"> 6089 </span>----------------------------------------------------------------------
<span class="lineno"> 6090 </span>-- * Proving Equalities
<span class="lineno"> 6091 </span>----------------------------------------------------------------------
<span class="lineno"> 6092 </span>
<span class="lineno"> 6093 </span>-- | Typeclass for the generic function that tries to extend the current partial
<span class="lineno"> 6094 </span>-- substitution to unify an expression with an expression pattern and returns a
<span class="lineno"> 6095 </span>-- proof of the equality on success
<span class="lineno"> 6096 </span>class ProveEq a where
<span class="lineno"> 6097 </span>  proveEq :: NuMatchingAny1 r =&gt; a -&gt; Mb vars a -&gt;
<span class="lineno"> 6098 </span>             ImplM vars s r ps ps (SomeEqProof a)
<span class="lineno"> 6099 </span>
<span class="lineno"> 6100 </span>instance (Eq a, Eq b, ProveEq a, ProveEq b, NuMatching a, NuMatching b,
<span class="lineno"> 6101 </span>          Substable PermSubst a Identity,
<span class="lineno"> 6102 </span>          Substable PermSubst b Identity) =&gt; ProveEq (a,b) where
<span class="lineno"> 6103 </span>  <span class="decl"><span class="nottickedoff">proveEq (a,b) mb_ab =</span>
<span class="lineno"> 6104 </span><span class="spaces">    </span><span class="nottickedoff">do eqp1 &lt;- proveEq a (mbFst mb_ab)</span>
<span class="lineno"> 6105 </span><span class="spaces">       </span><span class="nottickedoff">eqp2 &lt;- proveEq b (mbSnd mb_ab)</span>
<span class="lineno"> 6106 </span><span class="spaces">       </span><span class="nottickedoff">pure ((,) &lt;$&gt; eqp1 &lt;*&gt; eqp2)</span></span>
<span class="lineno"> 6107 </span>
<span class="lineno"> 6108 </span>instance (Eq a, Eq b, Eq c, ProveEq a, ProveEq b, ProveEq c,
<span class="lineno"> 6109 </span>          NuMatching a, NuMatching b, NuMatching c,
<span class="lineno"> 6110 </span>          Substable PermSubst a Identity,
<span class="lineno"> 6111 </span>          Substable PermSubst b Identity,
<span class="lineno"> 6112 </span>          Substable PermSubst c Identity) =&gt; ProveEq (a,b,c) where
<span class="lineno"> 6113 </span>  <span class="decl"><span class="nottickedoff">proveEq (a,b,c) mb_abc =</span>
<span class="lineno"> 6114 </span><span class="spaces">    </span><span class="nottickedoff">do eqp1 &lt;- proveEq a (mbFst3 mb_abc)</span>
<span class="lineno"> 6115 </span><span class="spaces">       </span><span class="nottickedoff">eqp2 &lt;- proveEq b (mbSnd3 mb_abc)</span>
<span class="lineno"> 6116 </span><span class="spaces">       </span><span class="nottickedoff">eqp3 &lt;- proveEq c (mbThd3 mb_abc)</span>
<span class="lineno"> 6117 </span><span class="spaces">       </span><span class="nottickedoff">pure ((,,) &lt;$&gt; eqp1 &lt;*&gt; eqp2 &lt;*&gt; eqp3)</span></span>
<span class="lineno"> 6118 </span>
<span class="lineno"> 6119 </span>instance ProveEq (PermExpr a) where
<span class="lineno"> 6120 </span>  <span class="decl"><span class="nottickedoff">proveEq e mb_e =</span>
<span class="lineno"> 6121 </span><span class="spaces">    </span><span class="nottickedoff">do psubst &lt;- getPSubst</span>
<span class="lineno"> 6122 </span><span class="spaces">       </span><span class="nottickedoff">proveEqH psubst e mb_e</span></span>
<span class="lineno"> 6123 </span>
<span class="lineno"> 6124 </span>instance ProveEq (LLVMFramePerm w) where
<span class="lineno"> 6125 </span>  <span class="decl"><span class="nottickedoff">proveEq [] [nuP| [] |] = pure $ SomeEqProofRefl []</span>
<span class="lineno"> 6126 </span><span class="spaces">  </span><span class="nottickedoff">proveEq ((e,i):fperms) [nuP| ((mb_e,mb_i)):mb_fperms |]</span>
<span class="lineno"> 6127 </span><span class="spaces">    </span><span class="nottickedoff">| mbLift mb_i == i =</span>
<span class="lineno"> 6128 </span><span class="spaces">      </span><span class="nottickedoff">do eqp1 &lt;- proveEq e mb_e</span>
<span class="lineno"> 6129 </span><span class="spaces">         </span><span class="nottickedoff">eqp2 &lt;- proveEq fperms mb_fperms</span>
<span class="lineno"> 6130 </span><span class="spaces">         </span><span class="nottickedoff">pure (App.liftA2 (\x y -&gt; (x,i):y) eqp1 eqp2)</span>
<span class="lineno"> 6131 </span><span class="spaces">  </span><span class="nottickedoff">proveEq perms mb =</span>
<span class="lineno"> 6132 </span><span class="spaces">    </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 6133 </span><span class="spaces">      </span><span class="nottickedoff">implFailM $ EqualityProofError</span>
<span class="lineno"> 6134 </span><span class="spaces">                    </span><span class="nottickedoff">(permPretty ppinfo perms)</span>
<span class="lineno"> 6135 </span><span class="spaces">                    </span><span class="nottickedoff">(permPretty ppinfo mb)</span></span>
<span class="lineno"> 6136 </span>
<span class="lineno"> 6137 </span>instance ProveEq (LLVMBlockPerm w) where
<span class="lineno"> 6138 </span>  <span class="decl"><span class="nottickedoff">proveEq bp mb_bp =</span>
<span class="lineno"> 6139 </span><span class="spaces">    </span><span class="nottickedoff">do eqp_rw  &lt;- proveEq (llvmBlockRW       bp) (mbLLVMBlockRW       mb_bp)</span>
<span class="lineno"> 6140 </span><span class="spaces">       </span><span class="nottickedoff">eqp_l   &lt;- proveEq (llvmBlockLifetime bp) (mbLLVMBlockLifetime mb_bp)</span>
<span class="lineno"> 6141 </span><span class="spaces">       </span><span class="nottickedoff">eqp_off &lt;- proveEq (llvmBlockOffset   bp) (mbLLVMBlockOffset   mb_bp)</span>
<span class="lineno"> 6142 </span><span class="spaces">       </span><span class="nottickedoff">eqp_len &lt;- proveEq (llvmBlockLen      bp) (mbLLVMBlockLen      mb_bp)</span>
<span class="lineno"> 6143 </span><span class="spaces">       </span><span class="nottickedoff">eqp_sh  &lt;- proveEq (llvmBlockShape    bp) (mbLLVMBlockShape    mb_bp)</span>
<span class="lineno"> 6144 </span><span class="spaces">       </span><span class="nottickedoff">pure (LLVMBlockPerm &lt;$&gt;</span>
<span class="lineno"> 6145 </span><span class="spaces">              </span><span class="nottickedoff">eqp_rw &lt;*&gt; eqp_l &lt;*&gt; eqp_off &lt;*&gt; eqp_len &lt;*&gt; eqp_sh)</span></span>
<span class="lineno"> 6146 </span>
<span class="lineno"> 6147 </span>
<span class="lineno"> 6148 </span>-- | Substitute any equality permissions for the variables in an expression,
<span class="lineno"> 6149 </span>-- returning a proof that the input expression equals the output. Unlike
<span class="lineno"> 6150 </span>-- 'getEqualsExpr', this does not eliminate any permissions, because it is used
<span class="lineno"> 6151 </span>-- by 'proveEq' to instantiate existential variables, and we do not want to have
<span class="lineno"> 6152 </span>-- to eliminate perms just to set @z=e@.
<span class="lineno"> 6153 </span>--
<span class="lineno"> 6154 </span>-- FIXME: maybe 'getEqualsExpr' should also not eliminate permissions?
<span class="lineno"> 6155 </span>substEqsWithProof :: (AbstractVars a, FreeVars a,
<span class="lineno"> 6156 </span>                      Substable PermSubst a Identity, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6157 </span>                     a -&gt; ImplM vars s r ps ps (SomeEqProof a)
<span class="lineno"> 6158 </span><span class="decl"><span class="nottickedoff">substEqsWithProof a =</span>
<span class="lineno"> 6159 </span><span class="spaces">  </span><span class="nottickedoff">do var_ps &lt;- use (implStatePerms . varPermMap)</span>
<span class="lineno"> 6160 </span><span class="spaces">     </span><span class="nottickedoff">pure (someEqProofFromSubst var_ps a)</span></span>
<span class="lineno"> 6161 </span>
<span class="lineno"> 6162 </span>-- | Substitute any equality permissions for the variables in an expression
<span class="lineno"> 6163 </span>-- using 'substEqsWithProof', but just return the result expression and not the
<span class="lineno"> 6164 </span>-- proof
<span class="lineno"> 6165 </span>substEqs :: (AbstractVars a, FreeVars a,
<span class="lineno"> 6166 </span>             Substable PermSubst a Identity, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6167 </span>            a -&gt; ImplM vars s r ps ps a
<span class="lineno"> 6168 </span><span class="decl"><span class="nottickedoff">substEqs a = someEqProofRHS &lt;$&gt; substEqsWithProof a</span></span>
<span class="lineno"> 6169 </span>
<span class="lineno"> 6170 </span>-- | The main work horse for 'proveEq' on expressions
<span class="lineno"> 6171 </span>proveEqH :: forall vars a s r ps. NuMatchingAny1 r =&gt; HasCallStack =&gt;
<span class="lineno"> 6172 </span>            PartialSubst vars -&gt; PermExpr a -&gt;
<span class="lineno"> 6173 </span>            Mb vars (PermExpr a) -&gt;
<span class="lineno"> 6174 </span>            ImplM vars s r ps ps (SomeEqProof (PermExpr a))
<span class="lineno"> 6175 </span><span class="decl"><span class="nottickedoff">proveEqH psubst e mb_e = case (e, mbMatch mb_e) of</span>
<span class="lineno"> 6176 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6177 </span><span class="spaces">  </span><span class="nottickedoff">-- If the RHS is an unset variable z, simplify e using any available equality</span>
<span class="lineno"> 6178 </span><span class="spaces">  </span><span class="nottickedoff">-- proofs to some e' and set z=e'</span>
<span class="lineno"> 6179 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| PExpr_Var z |])</span>
<span class="lineno"> 6180 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP z</span>
<span class="lineno"> 6181 </span><span class="spaces">    </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb -&gt;</span>
<span class="lineno"> 6182 </span><span class="spaces">      </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (unset var):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6183 </span><span class="spaces">      </span><span class="nottickedoff">substEqsWithProof e &gt;&gt;= \eqp -&gt;</span>
<span class="lineno"> 6184 </span><span class="spaces">      </span><span class="nottickedoff">setVarM memb (someEqProofRHS eqp) &gt;&gt;&gt; pure eqp</span>
<span class="lineno"> 6185 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6186 </span><span class="spaces">  </span><span class="nottickedoff">-- If the RHS is an unset variable z plus an offset o, simplify e using any</span>
<span class="lineno"> 6187 </span><span class="spaces">  </span><span class="nottickedoff">-- available equality proofs to some e' and set z equal to e' minus o</span>
<span class="lineno"> 6188 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| PExpr_LLVMOffset z mb_off |])</span>
<span class="lineno"> 6189 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP z</span>
<span class="lineno"> 6190 </span><span class="spaces">    </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 6191 </span><span class="spaces">    </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst mb_off -&gt;</span>
<span class="lineno"> 6192 </span><span class="spaces">      </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (unset var + offset):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6193 </span><span class="spaces">      </span><span class="nottickedoff">substEqsWithProof e &gt;&gt;= \eqp -&gt;</span>
<span class="lineno"> 6194 </span><span class="spaces">      </span><span class="nottickedoff">setVarM memb (someEqProofRHS eqp `addLLVMOffset` bvNegate off) &gt;&gt;&gt; pure eqp</span>
<span class="lineno"> 6195 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6196 </span><span class="spaces">  </span><span class="nottickedoff">-- If the RHS is a set variable, substitute for it and recurse</span>
<span class="lineno"> 6197 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| PExpr_Var z |])</span>
<span class="lineno"> 6198 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP z</span>
<span class="lineno"> 6199 </span><span class="spaces">    </span><span class="nottickedoff">, Just e' &lt;- psubstLookup psubst memb -&gt;</span>
<span class="lineno"> 6200 </span><span class="spaces">      </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (set var):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6201 </span><span class="spaces">      </span><span class="nottickedoff">proveEqH psubst e (mbConst e' z)</span>
<span class="lineno"> 6202 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6203 </span><span class="spaces">  </span><span class="nottickedoff">-- If the RHS = LHS, do a proof by reflexivity</span>
<span class="lineno"> 6204 </span><span class="spaces">  </span><span class="nottickedoff">_ | Just e' &lt;- partialSubst psubst mb_e</span>
<span class="lineno"> 6205 </span><span class="spaces">    </span><span class="nottickedoff">, e == e' -&gt;</span>
<span class="lineno"> 6206 </span><span class="spaces">      </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (reflexivity):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6207 </span><span class="spaces">        </span><span class="nottickedoff">pure (SomeEqProofRefl e)</span>
<span class="lineno"> 6208 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6209 </span><span class="spaces">  </span><span class="nottickedoff">-- To prove x=y, try to see if either side has an eq permission, if necessary by</span>
<span class="lineno"> 6210 </span><span class="spaces">  </span><span class="nottickedoff">-- eliminating compound permissions, and proceed by transitivity if possible</span>
<span class="lineno"> 6211 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Var x, [nuMP| PExpr_Var mb_y |])</span>
<span class="lineno"> 6212 </span><span class="spaces">    </span><span class="nottickedoff">| Right y &lt;- mbNameBoundP mb_y -&gt;</span>
<span class="lineno"> 6213 </span><span class="spaces">      </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (left eq):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6214 </span><span class="spaces">      </span><span class="nottickedoff">getPerm x &gt;&gt;= \x_p -&gt;</span>
<span class="lineno"> 6215 </span><span class="spaces">      </span><span class="nottickedoff">getPerm y &gt;&gt;= \y_p -&gt;</span>
<span class="lineno"> 6216 </span><span class="spaces">      </span><span class="nottickedoff">case (x_p, y_p) of</span>
<span class="lineno"> 6217 </span><span class="spaces">        </span><span class="nottickedoff">(ValPerm_Eq e', _) -&gt;</span>
<span class="lineno"> 6218 </span><span class="spaces">          </span><span class="nottickedoff">-- If we have x:eq(e'), prove e' = y and apply transitivity</span>
<span class="lineno"> 6219 </span><span class="spaces">          </span><span class="nottickedoff">proveEq e' mb_e &gt;&gt;= \some_eqp -&gt;</span>
<span class="lineno"> 6220 </span><span class="spaces">          </span><span class="nottickedoff">pure $ someEqProofTrans (someEqProof1 x e' True) some_eqp</span>
<span class="lineno"> 6221 </span><span class="spaces">        </span><span class="nottickedoff">(_, ValPerm_Eq e') -&gt;</span>
<span class="lineno"> 6222 </span><span class="spaces">          </span><span class="nottickedoff">-- If we have y:eq(e'), prove x = e' and apply transitivity</span>
<span class="lineno"> 6223 </span><span class="spaces">          </span><span class="nottickedoff">proveEq e (mbConst e' mb_e) &gt;&gt;= \some_eqp -&gt;</span>
<span class="lineno"> 6224 </span><span class="spaces">          </span><span class="nottickedoff">pure $ someEqProofTrans some_eqp (someEqProof1 y e' False)</span>
<span class="lineno"> 6225 </span><span class="spaces">        </span><span class="nottickedoff">(_, _) -&gt;</span>
<span class="lineno"> 6226 </span><span class="spaces">          </span><span class="nottickedoff">-- If we have no equality perms, eliminate perms on x and y to see if we</span>
<span class="lineno"> 6227 </span><span class="spaces">          </span><span class="nottickedoff">-- can get one; if so, recurse, and otherwise, raise an error</span>
<span class="lineno"> 6228 </span><span class="spaces">          </span><span class="nottickedoff">getVarEqPerm x &gt;&gt;= \case</span>
<span class="lineno"> 6229 </span><span class="spaces">          </span><span class="nottickedoff">Just _ -&gt; proveEqH psubst e mb_e</span>
<span class="lineno"> 6230 </span><span class="spaces">          </span><span class="nottickedoff">Nothing -&gt; getVarEqPerm y &gt;&gt;= \case</span>
<span class="lineno"> 6231 </span><span class="spaces">            </span><span class="nottickedoff">Just _ -&gt; proveEqH psubst e mb_e</span>
<span class="lineno"> 6232 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 6233 </span><span class="spaces">              </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 6234 </span><span class="spaces">                </span><span class="nottickedoff">implFailM $ EqualityProofError</span>
<span class="lineno"> 6235 </span><span class="spaces">                              </span><span class="nottickedoff">(permPretty ppinfo e)</span>
<span class="lineno"> 6236 </span><span class="spaces">                              </span><span class="nottickedoff">(permPretty ppinfo mb_e)</span>
<span class="lineno"> 6237 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6238 </span><span class="spaces">  </span><span class="nottickedoff">-- To prove @x &amp;+ o = e@, we subtract @o@ from the RHS and recurse</span>
<span class="lineno"> 6239 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_LLVMOffset x off, _) -&gt;</span>
<span class="lineno"> 6240 </span><span class="spaces">    </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (offsetL):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6241 </span><span class="spaces">    </span><span class="nottickedoff">proveEq (PExpr_Var x) (fmap (`addLLVMOffset` bvNegate off) mb_e) &gt;&gt;= \some_eqp -&gt;</span>
<span class="lineno"> 6242 </span><span class="spaces">    </span><span class="nottickedoff">pure $ fmap (`addLLVMOffset` off) some_eqp</span>
<span class="lineno"> 6243 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6244 </span><span class="spaces">  </span><span class="nottickedoff">-- To prove @x = x &amp;+ o@, we prove that @0 = o@ and combine it with the fact</span>
<span class="lineno"> 6245 </span><span class="spaces">  </span><span class="nottickedoff">-- that @x = x &amp;+ 0@ ('someEqProofZeroOffset') using transitivity</span>
<span class="lineno"> 6246 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Var x, [nuMP| PExpr_LLVMOffset mb_y mb_off |])</span>
<span class="lineno"> 6247 </span><span class="spaces">    </span><span class="nottickedoff">| Right y &lt;- mbNameBoundP mb_y</span>
<span class="lineno"> 6248 </span><span class="spaces">    </span><span class="nottickedoff">, x == y -&gt;</span>
<span class="lineno"> 6249 </span><span class="spaces">      </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (offsetR):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6250 </span><span class="spaces">      </span><span class="nottickedoff">proveEq (zeroOfType (BVRepr knownNat)) mb_off &gt;&gt;= \some_eqp -&gt;</span>
<span class="lineno"> 6251 </span><span class="spaces">      </span><span class="nottickedoff">pure $ someEqProofTrans (someEqProofZeroOffset y)</span>
<span class="lineno"> 6252 </span><span class="spaces">                              </span><span class="nottickedoff">(fmap (PExpr_LLVMOffset y) some_eqp)</span>
<span class="lineno"> 6253 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6254 </span><span class="spaces">  </span><span class="nottickedoff">-- To prove x=e, try to see if x:eq(e') and proceed by transitivity</span>
<span class="lineno"> 6255 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_Var x, _) -&gt;</span>
<span class="lineno"> 6256 </span><span class="spaces">    </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (x=e):&quot; &lt;+&gt;</span>
<span class="lineno"> 6257 </span><span class="spaces">    </span><span class="nottickedoff">--                   permPretty i x &lt;+&gt; pretty &quot;=&quot; &lt;+&gt; permPretty i mb_e) &gt;&gt;&gt;</span>
<span class="lineno"> 6258 </span><span class="spaces">    </span><span class="nottickedoff">getVarEqPerm x &gt;&gt;= \case</span>
<span class="lineno"> 6259 </span><span class="spaces">    </span><span class="nottickedoff">Just e' -&gt;</span>
<span class="lineno"> 6260 </span><span class="spaces">      </span><span class="nottickedoff">proveEq e' mb_e &gt;&gt;= \eqp2 -&gt;</span>
<span class="lineno"> 6261 </span><span class="spaces">      </span><span class="nottickedoff">pure (someEqProofTrans (someEqProof1 x e' True) eqp2)</span>
<span class="lineno"> 6262 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 6263 </span><span class="spaces">      </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 6264 </span><span class="spaces">      </span><span class="nottickedoff">implFailM $ EqualityProofError</span>
<span class="lineno"> 6265 </span><span class="spaces">                    </span><span class="nottickedoff">(permPretty ppinfo e)</span>
<span class="lineno"> 6266 </span><span class="spaces">                    </span><span class="nottickedoff">(permPretty ppinfo mb_e)</span>
<span class="lineno"> 6267 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6268 </span><span class="spaces">  </span><span class="nottickedoff">-- To prove e=x, try to see if x:eq(e') and proceed by transitivity</span>
<span class="lineno"> 6269 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| PExpr_Var z |])</span>
<span class="lineno"> 6270 </span><span class="spaces">    </span><span class="nottickedoff">| Right x &lt;- mbNameBoundP z -&gt;</span>
<span class="lineno"> 6271 </span><span class="spaces">    </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (e=x):&quot; &lt;+&gt;</span>
<span class="lineno"> 6272 </span><span class="spaces">    </span><span class="nottickedoff">--                   permPretty i e &lt;+&gt; pretty &quot;=&quot; &lt;+&gt; permPretty i x) &gt;&gt;&gt;</span>
<span class="lineno"> 6273 </span><span class="spaces">      </span><span class="nottickedoff">getVarEqPerm x &gt;&gt;= \case</span>
<span class="lineno"> 6274 </span><span class="spaces">        </span><span class="nottickedoff">Just e' -&gt;</span>
<span class="lineno"> 6275 </span><span class="spaces">          </span><span class="nottickedoff">proveEq e (mbConst e' mb_e) &gt;&gt;= \eqp -&gt;</span>
<span class="lineno"> 6276 </span><span class="spaces">          </span><span class="nottickedoff">pure (someEqProofTrans eqp (someEqProof1 x e' False))</span>
<span class="lineno"> 6277 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 6278 </span><span class="spaces">          </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 6279 </span><span class="spaces">          </span><span class="nottickedoff">implFailM $ EqualityProofError</span>
<span class="lineno"> 6280 </span><span class="spaces">                        </span><span class="nottickedoff">(permPretty ppinfo e)</span>
<span class="lineno"> 6281 </span><span class="spaces">                        </span><span class="nottickedoff">(permPretty ppinfo mb_e)</span>
<span class="lineno"> 6282 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6283 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: if proving word(e1)=word(e2) for ground e2, we could add an assertion</span>
<span class="lineno"> 6284 </span><span class="spaces">  </span><span class="nottickedoff">-- that e1=e2 using a BVProp_Eq</span>
<span class="lineno"> 6285 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6286 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove word(e1) = word(e2) by proving e1=e2</span>
<span class="lineno"> 6287 </span><span class="spaces">  </span><span class="nottickedoff">(PExpr_LLVMWord e', [nuMP| PExpr_LLVMWord mb_e' |]) -&gt;</span>
<span class="lineno"> 6288 </span><span class="spaces">    </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (word):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6289 </span><span class="spaces">    </span><span class="nottickedoff">fmap PExpr_LLVMWord &lt;$&gt; proveEqH psubst e' mb_e'</span>
<span class="lineno"> 6290 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6291 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove e = L_1*y_1 + ... + L_k*y_k + N*z + M where z is an unset variable,</span>
<span class="lineno"> 6292 </span><span class="spaces">  </span><span class="nottickedoff">-- each y_i is either a set variable with value e_i or an unbound variable</span>
<span class="lineno"> 6293 </span><span class="spaces">  </span><span class="nottickedoff">-- with e_i = y_i, and e - (L_1*e_1 + ... + L_k*e_k + M) is divisible by N,</span>
<span class="lineno"> 6294 </span><span class="spaces">  </span><span class="nottickedoff">-- by setting z = (e - (L_1*e_1 + ... + L_k*e_k + M))/N</span>
<span class="lineno"> 6295 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| PExpr_BV mb_factors (BV.BV mb_m) |])</span>
<span class="lineno"> 6296 </span><span class="spaces">    </span><span class="nottickedoff">| Just (n, memb, e_factors) &lt;- getUnsetBVFactor psubst mb_factors</span>
<span class="lineno"> 6297 </span><span class="spaces">    </span><span class="nottickedoff">, e' &lt;- bvSub e (bvAdd e_factors (bvInt $ mbLift mb_m))</span>
<span class="lineno"> 6298 </span><span class="spaces">    </span><span class="nottickedoff">, bvIsZero (bvMod e' n) -&gt;</span>
<span class="lineno"> 6299 </span><span class="spaces">    </span><span class="nottickedoff">-- implTraceM (\i -&gt; pretty &quot;proveEqH (bv):&quot; &lt;+&gt; permPretty i e) &gt;&gt;&gt;</span>
<span class="lineno"> 6300 </span><span class="spaces">      </span><span class="nottickedoff">setVarM memb (bvDiv e' n) &gt;&gt;&gt; pure (SomeEqProofRefl e)</span>
<span class="lineno"> 6301 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6302 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: add cases to prove struct(es1)=struct(es2)</span>
<span class="lineno"> 6303 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6304 </span><span class="spaces">  </span><span class="nottickedoff">-- Otherwise give up!</span>
<span class="lineno"> 6305 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 6306 </span><span class="spaces">         </span><span class="nottickedoff">implFailM $ EqualityProofError</span>
<span class="lineno"> 6307 </span><span class="spaces">                       </span><span class="nottickedoff">(permPretty ppinfo e)</span>
<span class="lineno"> 6308 </span><span class="spaces">                       </span><span class="nottickedoff">(permPretty ppinfo mb_e)</span></span>
<span class="lineno"> 6309 </span>
<span class="lineno"> 6310 </span>
<span class="lineno"> 6311 </span>-- | Build a proof on the top of the stack that @x:eq(e)@
<span class="lineno"> 6312 </span>proveVarEq :: NuMatchingAny1 r =&gt; ExprVar a -&gt; Mb vars (PermExpr a) -&gt;
<span class="lineno"> 6313 </span>              ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 6314 </span><span class="decl"><span class="nottickedoff">proveVarEq x mb_e =</span>
<span class="lineno"> 6315 </span><span class="spaces">  </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 6316 </span><span class="spaces">  </span><span class="nottickedoff">p@(ValPerm_Conj ps)</span>
<span class="lineno"> 6317 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex (== Perm_Any) ps -&gt;</span>
<span class="lineno"> 6318 </span><span class="spaces">      </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implCopyConjM x ps i &gt;&gt;&gt; implPopM x p &gt;&gt;&gt;</span>
<span class="lineno"> 6319 </span><span class="spaces">      </span><span class="nottickedoff">-- Zero out all bound variables in mb_e that have not yet been set</span>
<span class="lineno"> 6320 </span><span class="spaces">      </span><span class="nottickedoff">mapM_ (\(Some memb) -&gt; zeroUnsetVarM memb) (boundVars mb_e) &gt;&gt;&gt;</span>
<span class="lineno"> 6321 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_e &quot;proveVarEq&quot; &gt;&gt;&gt;= \e -&gt;</span>
<span class="lineno"> 6322 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimAnyToEq x e)</span>
<span class="lineno"> 6323 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 6324 </span><span class="spaces">    </span><span class="nottickedoff">proveEq (PExpr_Var x) mb_e &gt;&gt;&gt;= \some_eqp -&gt;</span>
<span class="lineno"> 6325 </span><span class="spaces">    </span><span class="nottickedoff">introEqReflM x &gt;&gt;&gt; implCastPermM Proxy x (fmap ValPerm_Eq some_eqp)</span></span>
<span class="lineno"> 6326 </span>
<span class="lineno"> 6327 </span>-- | Build proofs that @x1:eq(e1),...,xn:eq(en)@ on top of the stack
<span class="lineno"> 6328 </span>proveVarsEq :: NuMatchingAny1 r =&gt; RAssign ExprVar as -&gt;
<span class="lineno"> 6329 </span>               Mb vars (RAssign PermExpr as) -&gt;
<span class="lineno"> 6330 </span>               ImplM vars s r (ps :++: as) ps ()
<span class="lineno"> 6331 </span><span class="decl"><span class="nottickedoff">proveVarsEq MNil _ = return ()</span>
<span class="lineno"> 6332 </span><span class="spaces"></span><span class="nottickedoff">proveVarsEq (xs' :&gt;: x) es =</span>
<span class="lineno"> 6333 </span><span class="spaces">  </span><span class="nottickedoff">let [nuMP| es' :&gt;: mb_e |] = mbMatch es in</span>
<span class="lineno"> 6334 </span><span class="spaces">  </span><span class="nottickedoff">proveVarsEq xs' es' &gt;&gt;&gt; proveVarEq x mb_e</span></span>
<span class="lineno"> 6335 </span>
<span class="lineno"> 6336 </span>-- | Prove that @e1=e2@ using 'proveEq' and then cast permission @x:(f e1)@,
<span class="lineno"> 6337 </span>-- which is on top of the stack, to @x:(f e2)@
<span class="lineno"> 6338 </span>proveEqCast :: (ProveEq a, NuMatchingAny1 r) =&gt; ExprVar b -&gt;
<span class="lineno"> 6339 </span>               (a -&gt; ValuePerm b) -&gt; a -&gt; Mb vars a -&gt;
<span class="lineno"> 6340 </span>               ImplM vars s r (ps :&gt; b) (ps :&gt; b) ()
<span class="lineno"> 6341 </span><span class="decl"><span class="nottickedoff">proveEqCast x f e mb_e =</span>
<span class="lineno"> 6342 </span><span class="spaces">  </span><span class="nottickedoff">do some_eqp &lt;- proveEq e mb_e</span>
<span class="lineno"> 6343 </span><span class="spaces">     </span><span class="nottickedoff">implCastPermM Proxy x (fmap f some_eqp)</span></span>
<span class="lineno"> 6344 </span>
<span class="lineno"> 6345 </span>
<span class="lineno"> 6346 </span>----------------------------------------------------------------------
<span class="lineno"> 6347 </span>-- * Modality Proofs
<span class="lineno"> 6348 </span>----------------------------------------------------------------------
<span class="lineno"> 6349 </span>
<span class="lineno"> 6350 </span>-- | Take in a variable @x@, a function @F@ from read/write modalities to atomic
<span class="lineno"> 6351 </span>-- permissions, a read/write modality @rw@, a modality-in-binding @mb_rw@, and
<span class="lineno"> 6352 </span>-- an implication rule to coerce from @F(rw)@ to @F('PExpr_Read')@. Attempt to
<span class="lineno"> 6353 </span>-- coerce permission @x:F(rw)@ to @x:F(mb_rw)@, instantiating existential
<span class="lineno"> 6354 </span>-- variables in @mb_rw@ if necessary. Return the resulting instantiation of
<span class="lineno"> 6355 </span>-- @mb_rw@.
<span class="lineno"> 6356 </span>equalizeRWs :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 6357 </span>               (PermExpr RWModalityType -&gt; ValuePerm a) -&gt;
<span class="lineno"> 6358 </span>               PermExpr RWModalityType -&gt; Mb vars (PermExpr RWModalityType) -&gt;
<span class="lineno"> 6359 </span>               SimplImpl (RNil :&gt; a) (RNil :&gt; a) -&gt;
<span class="lineno"> 6360 </span>               ImplM vars s r (ps :&gt; a) (ps :&gt; a) (PermExpr RWModalityType)
<span class="lineno"> 6361 </span><span class="decl"><span class="nottickedoff">equalizeRWs x f rw mb_rw impl =</span>
<span class="lineno"> 6362 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt; equalizeRWsH x f rw psubst mb_rw impl</span></span>
<span class="lineno"> 6363 </span>
<span class="lineno"> 6364 </span>-- | The main implementation of 'equalizeRWs'
<span class="lineno"> 6365 </span>equalizeRWsH :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 6366 </span>                (PermExpr RWModalityType -&gt; ValuePerm a) -&gt;
<span class="lineno"> 6367 </span>                PermExpr RWModalityType -&gt; PartialSubst vars -&gt;
<span class="lineno"> 6368 </span>                Mb vars (PermExpr RWModalityType) -&gt;
<span class="lineno"> 6369 </span>                SimplImpl (RNil :&gt; a) (RNil :&gt; a) -&gt;
<span class="lineno"> 6370 </span>                ImplM vars s r (ps :&gt; a) (ps :&gt; a) (PermExpr RWModalityType)
<span class="lineno"> 6371 </span>
<span class="lineno"> 6372 </span>-- If rw and mb_rw are already equal, just return rw
<span class="lineno"> 6373 </span><span class="decl"><span class="nottickedoff">equalizeRWsH _ _ rw psubst mb_rw _</span>
<span class="lineno"> 6374 </span><span class="spaces">  </span><span class="nottickedoff">| Just rw' &lt;- partialSubst psubst mb_rw</span>
<span class="lineno"> 6375 </span><span class="spaces">  </span><span class="nottickedoff">, rw == rw' = return rw</span>
<span class="lineno"> 6376 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6377 </span><span class="spaces"></span><span class="nottickedoff">-- If mb_rw is read, weaken rw to read using the supplied rule</span>
<span class="lineno"> 6378 </span><span class="spaces"></span><span class="nottickedoff">equalizeRWsH _ _ _ psubst mb_rw impl</span>
<span class="lineno"> 6379 </span><span class="spaces">  </span><span class="nottickedoff">| Just PExpr_Read &lt;- partialSubst psubst mb_rw =</span>
<span class="lineno"> 6380 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy impl &gt;&gt;&gt; return PExpr_Read</span>
<span class="lineno"> 6381 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6382 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise, prove rw = mb_rw and cast f(rw) to f(mb_rw)</span>
<span class="lineno"> 6383 </span><span class="spaces"></span><span class="nottickedoff">equalizeRWsH x f rw _ mb_rw _ =</span>
<span class="lineno"> 6384 </span><span class="spaces">  </span><span class="nottickedoff">proveEqCast x f rw mb_rw &gt;&gt;&gt;</span>
<span class="lineno"> 6385 </span><span class="spaces">  </span><span class="nottickedoff">partialSubstForceM mb_rw &quot;equalizeRWs: incomplete psubst&quot;</span></span>
<span class="lineno"> 6386 </span>
<span class="lineno"> 6387 </span>
<span class="lineno"> 6388 </span>-- | Take a variable @x@, a lifetime functor @F@, a lifetime @l@, and a desired
<span class="lineno"> 6389 </span>-- lifetime-in-bindings @mb_l@, assuming the permission @x:F&lt;l&gt;@ is on the top
<span class="lineno"> 6390 </span>-- of the stack. Try to coerce the permission to @x:F&lt;mb_l&gt;@, possibly by
<span class="lineno"> 6391 </span>-- instantiating existential variables in @mb_l@ and/or splitting lifetimes.
<span class="lineno"> 6392 </span>-- Return the resulting lifetime used for @mb_l@.
<span class="lineno"> 6393 </span>proveVarLifetimeFunctor ::
<span class="lineno"> 6394 </span>  (KnownRepr TypeRepr a, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6395 </span>  ExprVar a -&gt; LifetimeFunctor args a -&gt; PermExprs args -&gt;
<span class="lineno"> 6396 </span>  PermExpr LifetimeType -&gt; Mb vars (PermExpr LifetimeType) -&gt;
<span class="lineno"> 6397 </span>  ImplM vars s r (ps :&gt; a) (ps :&gt; a) (PermExpr LifetimeType)
<span class="lineno"> 6398 </span><span class="decl"><span class="nottickedoff">proveVarLifetimeFunctor x f args l mb_l =</span>
<span class="lineno"> 6399 </span><span class="spaces">  </span><span class="nottickedoff">do psubst &lt;- getPSubst</span>
<span class="lineno"> 6400 </span><span class="spaces">     </span><span class="nottickedoff">proveVarLifetimeFunctor' x f args l mb_l psubst</span></span>
<span class="lineno"> 6401 </span>
<span class="lineno"> 6402 </span>-- | The main workhorse for 'proveVarLifetimeFunctor'
<span class="lineno"> 6403 </span>proveVarLifetimeFunctor' ::
<span class="lineno"> 6404 </span>  (KnownRepr TypeRepr a, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6405 </span>  ExprVar a -&gt; LifetimeFunctor args a -&gt; PermExprs args -&gt;
<span class="lineno"> 6406 </span>  PermExpr LifetimeType -&gt; Mb vars (PermExpr LifetimeType) -&gt;
<span class="lineno"> 6407 </span>  PartialSubst vars -&gt;
<span class="lineno"> 6408 </span>  ImplM vars s r (ps :&gt; a) (ps :&gt; a) (PermExpr LifetimeType)
<span class="lineno"> 6409 </span><span class="decl"><span class="nottickedoff">proveVarLifetimeFunctor' x f args l mb_l psubst = case mbMatch mb_l of</span>
<span class="lineno"> 6410 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6411 </span><span class="spaces">  </span><span class="nottickedoff">-- If mb_l is an unset evar, set mb_l = l and return</span>
<span class="lineno"> 6412 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var mb_z |]</span>
<span class="lineno"> 6413 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 6414 </span><span class="spaces">    </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb -&gt;</span>
<span class="lineno"> 6415 </span><span class="spaces">      </span><span class="nottickedoff">setVarM memb l &gt;&gt;&gt; return l</span>
<span class="lineno"> 6416 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6417 </span><span class="spaces">  </span><span class="nottickedoff">-- If mb_l is a set evar, substitute for it and recurse</span>
<span class="lineno"> 6418 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var mb_z |]</span>
<span class="lineno"> 6419 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 6420 </span><span class="spaces">    </span><span class="nottickedoff">, Just l2 &lt;- psubstLookup psubst memb -&gt;</span>
<span class="lineno"> 6421 </span><span class="spaces">      </span><span class="nottickedoff">proveVarLifetimeFunctor' x f args l (mbConst l2 mb_z) psubst</span>
<span class="lineno"> 6422 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6423 </span><span class="spaces">  </span><span class="nottickedoff">-- If mb_l==l, we are done</span>
<span class="lineno"> 6424 </span><span class="spaces">  </span><span class="nottickedoff">_ | mbLift $ fmap (== l) mb_l -&gt;</span>
<span class="lineno"> 6425 </span><span class="spaces">      </span><span class="nottickedoff">return l</span>
<span class="lineno"> 6426 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6427 </span><span class="spaces">  </span><span class="nottickedoff">-- If mb_l is a free variable l2 /= l, we need to split or weaken the lifetime</span>
<span class="lineno"> 6428 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var mb_z |]</span>
<span class="lineno"> 6429 </span><span class="spaces">    </span><span class="nottickedoff">| Right l2 &lt;- mbNameBoundP mb_z -&gt;</span>
<span class="lineno"> 6430 </span><span class="spaces">      </span><span class="nottickedoff">getPerm l2 &gt;&gt;= \case</span>
<span class="lineno"> 6431 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6432 </span><span class="spaces">        </span><span class="nottickedoff">-- If we have l2:lowned ps, prove l:[l2]lcurrent * l2:lowned ps' for</span>
<span class="lineno"> 6433 </span><span class="spaces">        </span><span class="nottickedoff">-- some ps' and then split the lifetime of x. Note that, in proving</span>
<span class="lineno"> 6434 </span><span class="spaces">        </span><span class="nottickedoff">-- l:[l2]lcurrent, we can change the lowned permission for l2,</span>
<span class="lineno"> 6435 </span><span class="spaces">        </span><span class="nottickedoff">-- specifically if we subsume l1 into l2.</span>
<span class="lineno"> 6436 </span><span class="spaces">        </span><span class="nottickedoff">ValPerm_LOwned _ _ _ _ _ -&gt;</span>
<span class="lineno"> 6437 </span><span class="spaces">          </span><span class="nottickedoff">let (l',l'_p) = lcurrentPerm l l2 in</span>
<span class="lineno"> 6438 </span><span class="spaces">          </span><span class="nottickedoff">proveVarImplInt l' (mbConst l'_p mb_z) &gt;&gt;&gt;</span>
<span class="lineno"> 6439 </span><span class="spaces">          </span><span class="nottickedoff">getPerm l2 &gt;&gt;&gt;= \case</span>
<span class="lineno"> 6440 </span><span class="spaces">            </span><span class="nottickedoff">l2_p@(ValPerm_LOwned sub_ls tps_in tps_out ps_in ps_out) -&gt;</span>
<span class="lineno"> 6441 </span><span class="spaces">              </span><span class="nottickedoff">implPushM l2 l2_p &gt;&gt;&gt;</span>
<span class="lineno"> 6442 </span><span class="spaces">              </span><span class="nottickedoff">implSplitLifetimeM x f args l l2 sub_ls tps_in tps_out ps_in ps_out &gt;&gt;&gt;</span>
<span class="lineno"> 6443 </span><span class="spaces">              </span><span class="nottickedoff">return (PExpr_Var l2)</span>
<span class="lineno"> 6444 </span><span class="spaces">            </span><span class="nottickedoff">_ -&gt; error (&quot;proveVarLifetimeFunctor: unexpected error: &quot;</span>
<span class="lineno"> 6445 </span><span class="spaces">                        </span><span class="nottickedoff">++ &quot;l2 lost its lowned perms&quot;)</span>
<span class="lineno"> 6446 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6447 </span><span class="spaces">        </span><span class="nottickedoff">-- Otherwise, prove l:[l2]lcurrent and weaken the lifetime</span>
<span class="lineno"> 6448 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 6449 </span><span class="spaces">          </span><span class="nottickedoff">let (l',l'_p) = lcurrentPerm l l2 in</span>
<span class="lineno"> 6450 </span><span class="spaces">          </span><span class="nottickedoff">proveVarImplInt l' (mbConst l'_p mb_z) &gt;&gt;&gt;</span>
<span class="lineno"> 6451 </span><span class="spaces">          </span><span class="nottickedoff">implSimplM Proxy (SImpl_WeakenLifetime x f args l l2) &gt;&gt;&gt;</span>
<span class="lineno"> 6452 </span><span class="spaces">          </span><span class="nottickedoff">return (PExpr_Var l2)</span>
<span class="lineno"> 6453 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6454 </span><span class="spaces">  </span><span class="nottickedoff">-- Otherwise, fail; this should only include the case where the RHS is always</span>
<span class="lineno"> 6455 </span><span class="spaces">  </span><span class="nottickedoff">-- but the LHS is not, which we cannot do anything with</span>
<span class="lineno"> 6456 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 6457 </span><span class="spaces">    </span><span class="nottickedoff">implFailVarM &quot;proveVarLifetimeFunctor&quot; x (ltFuncApply f args l)</span>
<span class="lineno"> 6458 </span><span class="spaces">    </span><span class="nottickedoff">(fmap (ltFuncApply f args) mb_l)</span></span>
<span class="lineno"> 6459 </span>
<span class="lineno"> 6460 </span>
<span class="lineno"> 6461 </span>----------------------------------------------------------------------
<span class="lineno"> 6462 </span>-- * Solving for Permission List Implications
<span class="lineno"> 6463 </span>----------------------------------------------------------------------
<span class="lineno"> 6464 </span>
<span class="lineno"> 6465 </span>-- | A permission that needs to be proved for an implication
<span class="lineno"> 6466 </span>data NeededPerm a
<span class="lineno"> 6467 </span>     -- | An equality permission that is needed
<span class="lineno"> 6468 </span>  = NeededEq (EqPerm a)
<span class="lineno"> 6469 </span>    -- | A block or struct permission for a range
<span class="lineno"> 6470 </span>  | NeededRange (ExprVar a) (MbRangeForType a)
<span class="lineno"> 6471 </span>
<span class="lineno"> 6472 </span>instance PermPretty (NeededPerm a) where
<span class="lineno"> 6473 </span>  <span class="decl"><span class="nottickedoff">permPrettyM (NeededEq eq_perm) =</span>
<span class="lineno"> 6474 </span><span class="spaces">    </span><span class="nottickedoff">do x_pp &lt;- permPrettyM (eqPermVar eq_perm)</span>
<span class="lineno"> 6475 </span><span class="spaces">       </span><span class="nottickedoff">p_pp &lt;- permPrettyM (eqPermPerm eq_perm)</span>
<span class="lineno"> 6476 </span><span class="spaces">       </span><span class="nottickedoff">return (x_pp &lt;&gt; colon &lt;&gt; p_pp)</span>
<span class="lineno"> 6477 </span><span class="spaces">  </span><span class="nottickedoff">permPrettyM (NeededRange x rng) =</span>
<span class="lineno"> 6478 </span><span class="spaces">    </span><span class="nottickedoff">do x_pp &lt;- permPrettyM x</span>
<span class="lineno"> 6479 </span><span class="spaces">       </span><span class="nottickedoff">rng_pp &lt;- permPrettyM rng</span>
<span class="lineno"> 6480 </span><span class="spaces">       </span><span class="nottickedoff">return (x_pp &lt;&gt; colon &lt;&gt; pretty &quot;range&quot; &lt;&gt; parens (rng_pp))</span></span>
<span class="lineno"> 6481 </span>
<span class="lineno"> 6482 </span>instance PermPrettyF NeededPerm where
<span class="lineno"> 6483 </span>  <span class="decl"><span class="nottickedoff">permPrettyMF = permPrettyM</span></span>
<span class="lineno"> 6484 </span>
<span class="lineno"> 6485 </span>-- | A sequence of permissions in bindings that need to be proved
<span class="lineno"> 6486 </span>type NeededPerms = Some (RAssign NeededPerm)
<span class="lineno"> 6487 </span>
<span class="lineno"> 6488 </span>-- | Convert a sequence of 'EqPerm's to a 'NeededPerms'
<span class="lineno"> 6489 </span>eqPermsToNeededPerms :: Some (RAssign EqPerm) -&gt; NeededPerms
<span class="lineno"> 6490 </span><span class="decl"><span class="nottickedoff">eqPermsToNeededPerms = fmapF (RL.map NeededEq)</span></span>
<span class="lineno"> 6491 </span>
<span class="lineno"> 6492 </span>-- | Convert a sequence of 'MbRangeForType's to a 'NeededPerms'
<span class="lineno"> 6493 </span>neededPermsForRanges :: ExprVar a -&gt; [MbRangeForType a] -&gt; NeededPerms
<span class="lineno"> 6494 </span><span class="decl"><span class="nottickedoff">neededPermsForRanges x rngs =</span>
<span class="lineno"> 6495 </span><span class="spaces">  </span><span class="nottickedoff">concatSomeRAssign $ map (\rng -&gt; Some (MNil :&gt;: NeededRange x rng)) rngs</span></span>
<span class="lineno"> 6496 </span>
<span class="lineno"> 6497 </span>-- | No permissions needed
<span class="lineno"> 6498 </span>neededPerms0 :: NeededPerms
<span class="lineno"> 6499 </span><span class="decl"><span class="nottickedoff">neededPerms0 = Some MNil</span></span>
<span class="lineno"> 6500 </span>
<span class="lineno"> 6501 </span>-- | A permission in some context of existential variables extending @vars@
<span class="lineno"> 6502 </span>data SomeMbPerm vars a where
<span class="lineno"> 6503 </span>  SomeMbPerm :: CruCtx vars' -&gt;
<span class="lineno"> 6504 </span>                Mb (vars :++: vars') (ValuePerm a) -&gt;
<span class="lineno"> 6505 </span>                SomeMbPerm vars a
<span class="lineno"> 6506 </span>
<span class="lineno"> 6507 </span>-- | Convert an 'MbRangeForType' to a corresponding permission-in-binding
<span class="lineno"> 6508 </span>someMbPermForRange :: RAssign Proxy vars -&gt; MbRangeForType a -&gt;
<span class="lineno"> 6509 </span>                      SomeMbPerm vars a
<span class="lineno"> 6510 </span><span class="decl"><span class="nottickedoff">someMbPermForRange vars (MbRangeForLLVMType vars' mb_rw mb_l mb_rng) =</span>
<span class="lineno"> 6511 </span><span class="spaces">  </span><span class="nottickedoff">SomeMbPerm (CruCtxCons vars' knownRepr) $</span>
<span class="lineno"> 6512 </span><span class="spaces">  </span><span class="nottickedoff">mbCombine (cruCtxProxies vars' :&gt;: Proxy) $ nuMulti vars $ const $</span>
<span class="lineno"> 6513 </span><span class="spaces">  </span><span class="nottickedoff">mbCombine (MNil :&gt;: Proxy) $</span>
<span class="lineno"> 6514 </span><span class="spaces">  </span><span class="nottickedoff">mbMap3 (\rw l rng -&gt; nu $ \sh -&gt;</span>
<span class="lineno"> 6515 </span><span class="spaces">           </span><span class="nottickedoff">ValPerm_LLVMBlock $</span>
<span class="lineno"> 6516 </span><span class="spaces">           </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockRW = rw,</span>
<span class="lineno"> 6517 </span><span class="spaces">                           </span><span class="nottickedoff">llvmBlockLifetime = l,</span>
<span class="lineno"> 6518 </span><span class="spaces">                           </span><span class="nottickedoff">llvmBlockOffset = bvRangeOffset rng,</span>
<span class="lineno"> 6519 </span><span class="spaces">                           </span><span class="nottickedoff">llvmBlockLen = bvRangeLength rng,</span>
<span class="lineno"> 6520 </span><span class="spaces">                           </span><span class="nottickedoff">llvmBlockShape = PExpr_Var sh })</span>
<span class="lineno"> 6521 </span><span class="spaces">  </span><span class="nottickedoff">mb_rw mb_l mb_rng</span></span>
<span class="lineno"> 6522 </span>
<span class="lineno"> 6523 </span>-- | Prove a 'SomeMbPerm'
<span class="lineno"> 6524 </span>proveSomeMbPerm :: NuMatchingAny1 r =&gt; ExprVar a -&gt; SomeMbPerm vars a -&gt;
<span class="lineno"> 6525 </span>                   ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 6526 </span><span class="decl"><span class="nottickedoff">proveSomeMbPerm x (SomeMbPerm ctx mb_p) =</span>
<span class="lineno"> 6527 </span><span class="spaces">  </span><span class="nottickedoff">withExtVarsMultiM ctx $ proveVarImplInt x mb_p</span></span>
<span class="lineno"> 6528 </span>
<span class="lineno"> 6529 </span>-- | Prove the permission represented by a 'NeededPerm', returning zero or more
<span class="lineno"> 6530 </span>-- auxiliary permissions that are also needed
<span class="lineno"> 6531 </span>proveNeededPerm :: NuMatchingAny1 r =&gt; RAssign Proxy vars -&gt; NeededPerm a -&gt;
<span class="lineno"> 6532 </span>                   ImplM vars s r (ps :&gt; a) ps (Some DistPerms)
<span class="lineno"> 6533 </span><span class="decl"><span class="nottickedoff">proveNeededPerm _ (NeededEq eq_perm) =</span>
<span class="lineno"> 6534 </span><span class="spaces">  </span><span class="nottickedoff">mbVarsM (eqPermPerm eq_perm) &gt;&gt;&gt;= \mb_p -&gt;</span>
<span class="lineno"> 6535 </span><span class="spaces">  </span><span class="nottickedoff">proveVarImplInt (eqPermVar eq_perm) mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 6536 </span><span class="spaces">  </span><span class="nottickedoff">return (Some MNil)</span>
<span class="lineno"> 6537 </span><span class="spaces"></span><span class="nottickedoff">proveNeededPerm vars (NeededRange x rng@(MbRangeForLLVMType _ _ _ _)) =</span>
<span class="lineno"> 6538 </span><span class="spaces">  </span><span class="nottickedoff">proveSomeMbPerm x (someMbPermForRange vars rng) &gt;&gt;&gt;</span>
<span class="lineno"> 6539 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 6540 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_LLVMBlock bp) -&gt;</span>
<span class="lineno"> 6541 </span><span class="spaces">    </span><span class="nottickedoff">case NameSet.toRAssign (findEqVarFieldsInShape (llvmBlockShape bp)) of</span>
<span class="lineno"> 6542 </span><span class="spaces">      </span><span class="nottickedoff">NameSet.SomeRAssign ns -&gt;</span>
<span class="lineno"> 6543 </span><span class="spaces">        </span><span class="nottickedoff">Some &lt;$&gt; traverseRAssign (\n -&gt; VarAndPerm n &lt;$&gt; getPerm n) ns</span>
<span class="lineno"> 6544 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; error &quot;proveNeededPerm: expected block permission&quot;</span></span>
<span class="lineno"> 6545 </span>
<span class="lineno"> 6546 </span>-- | Prove the permissions represented by a sequence of 'NeededPerms', returning
<span class="lineno"> 6547 </span>-- zero or more auxiliary permissions that are also needed
<span class="lineno"> 6548 </span>proveNeededPerms :: NuMatchingAny1 r =&gt; RAssign Proxy vars -&gt;
<span class="lineno"> 6549 </span>                    RAssign NeededPerm ps' -&gt;
<span class="lineno"> 6550 </span>                    ImplM vars s r (ps :++: ps') ps (Some DistPerms)
<span class="lineno"> 6551 </span><span class="decl"><span class="nottickedoff">proveNeededPerms _ MNil = return (Some MNil)</span>
<span class="lineno"> 6552 </span><span class="spaces"></span><span class="nottickedoff">proveNeededPerms vars (ps :&gt;: p) =</span>
<span class="lineno"> 6553 </span><span class="spaces">  </span><span class="nottickedoff">proveNeededPerms vars ps &gt;&gt;&gt;= \auxs1 -&gt;</span>
<span class="lineno"> 6554 </span><span class="spaces">  </span><span class="nottickedoff">proveNeededPerm vars p &gt;&gt;&gt;= \auxs2 -&gt;</span>
<span class="lineno"> 6555 </span><span class="spaces">  </span><span class="nottickedoff">return (apSomeRAssign auxs1 auxs2)</span></span>
<span class="lineno"> 6556 </span>
<span class="lineno"> 6557 </span>-- | Call 'proveNeededPerms' and then reassociate the resulting stack
<span class="lineno"> 6558 </span>proveNeededPermsAssoc ::
<span class="lineno"> 6559 </span>  NuMatchingAny1 r =&gt; RAssign Proxy vars -&gt;
<span class="lineno"> 6560 </span>  prx ps -&gt; prx1 ps1 -&gt; RAssign NeededPerm ps2 -&gt;
<span class="lineno"> 6561 </span>  ImplM vars s r (ps :++: (ps1 :++: ps2)) (ps :++: ps1) (Some DistPerms)
<span class="lineno"> 6562 </span><span class="decl"><span class="nottickedoff">proveNeededPermsAssoc vars ps ps1 ps2</span>
<span class="lineno"> 6563 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- RL.appendAssoc ps ps1 ps2</span>
<span class="lineno"> 6564 </span><span class="spaces">  </span><span class="nottickedoff">= proveNeededPerms vars ps2</span></span>
<span class="lineno"> 6565 </span>
<span class="lineno"> 6566 </span>-- | If the second argument is an unset variable, set it to the first, otherwise
<span class="lineno"> 6567 </span>-- do nothing
<span class="lineno"> 6568 </span>tryUnifyVars :: PermExpr a -&gt; Mb vars (PermExpr a) -&gt; ImplM vars s r ps ps ()
<span class="lineno"> 6569 </span><span class="decl"><span class="nottickedoff">tryUnifyVars x mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 6570 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var mb_x' |]</span>
<span class="lineno"> 6571 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_x' -&gt;</span>
<span class="lineno"> 6572 </span><span class="spaces">      </span><span class="nottickedoff">do psubst &lt;- getPSubst</span>
<span class="lineno"> 6573 </span><span class="spaces">         </span><span class="nottickedoff">case psubstLookup psubst memb of</span>
<span class="lineno"> 6574 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt; setVarM memb x</span>
<span class="lineno"> 6575 </span><span class="spaces">           </span><span class="nottickedoff">_ -&gt; pure ()</span>
<span class="lineno"> 6576 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; pure ()</span></span>
<span class="lineno"> 6577 </span>
<span class="lineno"> 6578 </span>-- | Get the ranges of offsets covered by the current permissions on an
<span class="lineno"> 6579 </span>-- expression, eliminating permissions if necessary
<span class="lineno"> 6580 </span>getExprRanges :: NuMatchingAny1 r =&gt; TypeRepr a -&gt; PermExpr a -&gt;
<span class="lineno"> 6581 </span>                 ImplM vars s r ps ps [MbRangeForType a]
<span class="lineno"> 6582 </span><span class="decl"><span class="nottickedoff">getExprRanges tp (asVar -&gt; Just x) =</span>
<span class="lineno"> 6583 </span><span class="spaces">  </span><span class="nottickedoff">getSimpleVarPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 6584 </span><span class="spaces">  </span><span class="nottickedoff">p@(ValPerm_Conj _) -&gt; return $ getOffsets p</span>
<span class="lineno"> 6585 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_Eq e -&gt; getExprRanges tp e</span>
<span class="lineno"> 6586 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; return []</span>
<span class="lineno"> 6587 </span><span class="spaces"></span><span class="nottickedoff">getExprRanges tp (asVarOffset -&gt; Just (x,off)) =</span>
<span class="lineno"> 6588 </span><span class="spaces">  </span><span class="nottickedoff">map (offsetMbRangeForType $ negatePermOffset off) &lt;$&gt;</span>
<span class="lineno"> 6589 </span><span class="spaces">  </span><span class="nottickedoff">getExprRanges tp (PExpr_Var x)</span>
<span class="lineno"> 6590 </span><span class="spaces"></span><span class="nottickedoff">getExprRanges _ _ = pure []</span></span>
<span class="lineno"> 6591 </span>
<span class="lineno"> 6592 </span>-- | The second stage of 'solveForPermListImpl', after equality permissions have
<span class="lineno"> 6593 </span>-- been substituted into the 'ExprPerms'
<span class="lineno"> 6594 </span>solveForPermListImplH :: NuMatchingAny1 r =&gt; RAssign Proxy vars -&gt;
<span class="lineno"> 6595 </span>                         ExprPerms ps_l -&gt; CruCtx ps_r -&gt; ExprPerms ps_r -&gt;
<span class="lineno"> 6596 </span>                         ImplM vars s r ps ps NeededPerms
<span class="lineno"> 6597 </span>-- If the RHS is empty, we are done
<span class="lineno"> 6598 </span><span class="decl"><span class="nottickedoff">solveForPermListImplH _ _ _ MNil =</span>
<span class="lineno"> 6599 </span><span class="spaces">  </span><span class="nottickedoff">pure neededPerms0</span>
<span class="lineno"> 6600 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6601 </span><span class="spaces"></span><span class="nottickedoff">-- If the RHS is a varible x, get all the offsets mentioned in RHS permissions</span>
<span class="lineno"> 6602 </span><span class="spaces"></span><span class="nottickedoff">-- for x, subtract any ranges on the LHS for x, and then return block</span>
<span class="lineno"> 6603 </span><span class="spaces"></span><span class="nottickedoff">-- permisisons for any of the remaining ranges that are currently held for x</span>
<span class="lineno"> 6604 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 6605 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: mbRangeFTsDelete always treats evars on the left and right as distinct</span>
<span class="lineno"> 6606 </span><span class="spaces"></span><span class="nottickedoff">-- fresh expressions, whereas RHS evars could be instantiated to expressions,</span>
<span class="lineno"> 6607 </span><span class="spaces"></span><span class="nottickedoff">-- even LHS evars. This means that this implementaiton of solveForPermListImpl</span>
<span class="lineno"> 6608 </span><span class="spaces"></span><span class="nottickedoff">-- will require more permissions from the current primary permissions on a</span>
<span class="lineno"> 6609 </span><span class="spaces"></span><span class="nottickedoff">-- variable than strictly needed when the RHS covers an existentially-quantified</span>
<span class="lineno"> 6610 </span><span class="spaces"></span><span class="nottickedoff">-- range of offsets</span>
<span class="lineno"> 6611 </span><span class="spaces"></span><span class="nottickedoff">solveForPermListImplH vars ps_l (CruCtxCons tps_r' tp_r) (ps_r' :&gt;: e_and_p)</span>
<span class="lineno"> 6612 </span><span class="spaces">  </span><span class="nottickedoff">| Just (VarAndPerm x p) &lt;- exprPermVarAndPerm e_and_p</span>
<span class="lineno"> 6613 </span><span class="spaces">  </span><span class="nottickedoff">, lhs_ps &lt;- exprPermsForVar x ps_l</span>
<span class="lineno"> 6614 </span><span class="spaces">  </span><span class="nottickedoff">, lhs_rngs &lt;- concatMap getOffsets lhs_ps</span>
<span class="lineno"> 6615 </span><span class="spaces">  </span><span class="nottickedoff">, rhs_rngs &lt;- getOffsets p</span>
<span class="lineno"> 6616 </span><span class="spaces">  </span><span class="nottickedoff">, needed_rngs &lt;- mbRangeFTsDelete rhs_rngs lhs_rngs =</span>
<span class="lineno"> 6617 </span><span class="spaces">    </span><span class="nottickedoff">getExprRanges tp_r (PExpr_Var x) &gt;&gt;&gt;= \expr_rngs -&gt;</span>
<span class="lineno"> 6618 </span><span class="spaces">    </span><span class="nottickedoff">let res_rngs = mbRangeFTsSubsetTo needed_rngs expr_rngs in</span>
<span class="lineno"> 6619 </span><span class="spaces">    </span><span class="nottickedoff">implVerbTraceM</span>
<span class="lineno"> 6620 </span><span class="spaces">    </span><span class="nottickedoff">(\i -&gt; pretty &quot;solveForPermListImplH&quot; &lt;+&gt;</span>
<span class="lineno"> 6621 </span><span class="spaces">           </span><span class="nottickedoff">permPretty i x &lt;&gt; colon &lt;&gt; line &lt;&gt; pretty &quot;  &quot; &lt;&gt;</span>
<span class="lineno"> 6622 </span><span class="spaces">           </span><span class="nottickedoff">align (sep [pretty &quot;RHS:&quot; &lt;+&gt; permPretty i p,</span>
<span class="lineno"> 6623 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;LHS:&quot; &lt;+&gt; permPretty i lhs_ps,</span>
<span class="lineno"> 6624 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;Needed ranges:&quot; &lt;+&gt; permPretty i needed_rngs,</span>
<span class="lineno"> 6625 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;Held ranges:&quot; &lt;+&gt; permPretty i expr_rngs,</span>
<span class="lineno"> 6626 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;Result ranges:&quot; &lt;+&gt; permPretty i res_rngs]))</span>
<span class="lineno"> 6627 </span><span class="spaces">    </span><span class="nottickedoff">&gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 6628 </span><span class="spaces">    </span><span class="nottickedoff">apSomeRAssign (neededPermsForRanges x res_rngs) &lt;$&gt;</span>
<span class="lineno"> 6629 </span><span class="spaces">    </span><span class="nottickedoff">solveForPermListImplH vars ps_l tps_r' ps_r'</span>
<span class="lineno"> 6630 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6631 </span><span class="spaces"></span><span class="nottickedoff">-- If the RHS is not a variable, ignore it and keep going</span>
<span class="lineno"> 6632 </span><span class="spaces"></span><span class="nottickedoff">solveForPermListImplH vars ps_l (CruCtxCons tps_r' _) (ps_r' :&gt;: _) =</span>
<span class="lineno"> 6633 </span><span class="spaces">  </span><span class="nottickedoff">solveForPermListImplH vars ps_l tps_r' ps_r'</span></span>
<span class="lineno"> 6634 </span>
<span class="lineno"> 6635 </span>-- | Determine what additional permissions from the current set of variable
<span class="lineno"> 6636 </span>-- permissions, if any, would be needed to prove one list of permissions implies
<span class="lineno"> 6637 </span>-- another. This is just a \&quot;best guess\&quot;, so just do nothing and return if
<span class="lineno"> 6638 </span>-- nothing can be done.
<span class="lineno"> 6639 </span>--
<span class="lineno"> 6640 </span>-- At a high level, this algorithm currently works as follows. It starts by
<span class="lineno"> 6641 </span>-- substituting any equality permissions in the current permission set,
<span class="lineno"> 6642 </span>-- returning those equalities as needed permissions. Next, it finds all LLVM
<span class="lineno"> 6643 </span>-- pointer offsets and ranges of offsets for any LLVM variable @x@ that are
<span class="lineno"> 6644 </span>-- mentioned on the right and subtracts those for the same variable that are
<span class="lineno"> 6645 </span>-- mentioned on the left. It then returns ranges for any of these remaining
<span class="lineno"> 6646 </span>-- offsets that are held as permissions in the current permission set. The
<span class="lineno"> 6647 </span>-- intuition is that these offsets are the ones that are important to the right-
<span class="lineno"> 6648 </span>-- or left-hand sides, but we don't know exactly how the proof will go, so we
<span class="lineno"> 6649 </span>-- only pick those offsets that can actually be satisfied by the current
<span class="lineno"> 6650 </span>-- permission set without failing.
<span class="lineno"> 6651 </span>solveForPermListImpl :: NuMatchingAny1 r =&gt; ExprPerms ps_l -&gt;
<span class="lineno"> 6652 </span>                        CruCtx ps_r -&gt; Mb vars (ExprPerms ps_r) -&gt;
<span class="lineno"> 6653 </span>                        ImplM vars s r ps ps NeededPerms
<span class="lineno"> 6654 </span><span class="decl"><span class="nottickedoff">solveForPermListImpl ps_l tps_r mb_ps_r =</span>
<span class="lineno"> 6655 </span><span class="spaces">  </span><span class="nottickedoff">let prxs = mbToProxy mb_ps_r in</span>
<span class="lineno"> 6656 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME HERE: eliminate struct variables</span>
<span class="lineno"> 6657 </span><span class="spaces">  </span><span class="nottickedoff">substEqsWithProof ps_l &gt;&gt;&gt;= \eqp_l -&gt;</span>
<span class="lineno"> 6658 </span><span class="spaces">  </span><span class="nottickedoff">(psubstProxies &lt;$&gt; getPSubst) &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 6659 </span><span class="spaces">  </span><span class="nottickedoff">partialSubstForceM mb_ps_r &quot;solveForPermListImpl&quot; &gt;&gt;&gt;= \ps_r -&gt;</span>
<span class="lineno"> 6660 </span><span class="spaces">  </span><span class="nottickedoff">give prxs (substEqsWithProof ps_r) &gt;&gt;&gt;= \eqp_r -&gt;</span>
<span class="lineno"> 6661 </span><span class="spaces">  </span><span class="nottickedoff">let neededs1 = eqPermsToNeededPerms $ someEqProofEqs eqp_l</span>
<span class="lineno"> 6662 </span><span class="spaces">      </span><span class="nottickedoff">neededs2 = eqPermsToNeededPerms $ someEqProofEqs eqp_r</span>
<span class="lineno"> 6663 </span><span class="spaces">      </span><span class="nottickedoff">neededs = apSomeRAssign neededs1 neededs2</span>
<span class="lineno"> 6664 </span><span class="spaces">      </span><span class="nottickedoff">ps_l' = someEqProofRHS eqp_l</span>
<span class="lineno"> 6665 </span><span class="spaces">      </span><span class="nottickedoff">ps_r' = someEqProofRHS eqp_r in</span>
<span class="lineno"> 6666 </span><span class="spaces">  </span><span class="nottickedoff">apSomeRAssign neededs &lt;$&gt; solveForPermListImplH vars ps_l' tps_r ps_r'</span></span>
<span class="lineno"> 6667 </span>
<span class="lineno"> 6668 </span>
<span class="lineno"> 6669 </span>----------------------------------------------------------------------
<span class="lineno"> 6670 </span>-- * Proving Field Permissions
<span class="lineno"> 6671 </span>----------------------------------------------------------------------
<span class="lineno"> 6672 </span>
<span class="lineno"> 6673 </span>-- | Prove an LLVM field permission @x:ptr((rw,off) |-&gt; p)@ from permissions
<span class="lineno"> 6674 </span>-- @x:p1*...*pn@ on the top of the stack, and ensure that any remaining
<span class="lineno"> 6675 </span>-- permissions for @x@ get popped back to the primary permissions for @x@. This
<span class="lineno"> 6676 </span>-- function does not unfold named permissions in the @pi@s.
<span class="lineno"> 6677 </span>proveVarLLVMField ::
<span class="lineno"> 6678 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6679 </span>  ExprVar (LLVMPointerType w) -&gt; [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 6680 </span>  PermExpr (BVType w) -&gt; Mb vars (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 6681 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 6682 </span>
<span class="lineno"> 6683 </span><span class="decl"><span class="nottickedoff">proveVarLLVMField x ps off mb_fp =</span>
<span class="lineno"> 6684 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 6685 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;proveVarLLVMField:&quot; &lt;+&gt; permPretty i x &lt;&gt; colon &lt;&gt;</span>
<span class="lineno"> 6686 </span><span class="spaces">               </span><span class="nottickedoff">align (sep [PP.group (permPretty i (ValPerm_Conj ps)),</span>
<span class="lineno"> 6687 </span><span class="spaces">                           </span><span class="nottickedoff">pretty &quot;-o&quot;,</span>
<span class="lineno"> 6688 </span><span class="spaces">                           </span><span class="nottickedoff">PP.group (permPretty i mb_fp</span>
<span class="lineno"> 6689 </span><span class="spaces">                                     </span><span class="nottickedoff">&lt;+&gt; pretty &quot;@&quot; &lt;+&gt; permPretty i off)])) &gt;&gt;&gt;</span>
<span class="lineno"> 6690 </span><span class="spaces">  </span><span class="nottickedoff">implGetLLVMPermForOffset x ps True True off</span>
<span class="lineno"> 6691 </span><span class="spaces">  </span><span class="nottickedoff">(mbValPerm_LLVMField mb_fp) &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 6692 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMFieldH x p off mb_fp</span></span>
<span class="lineno"> 6693 </span>
<span class="lineno"> 6694 </span>-- | Prove an LLVM field permission @mb_fp@ from an atomic permission @x:p@ on
<span class="lineno"> 6695 </span>-- the top of the stack, assuming that the offset of @mb_fp@ is @off@ and that
<span class="lineno"> 6696 </span>-- @p@ could (in the sense of 'bvPropCouldHold') contain the offset @off@
<span class="lineno"> 6697 </span>proveVarLLVMFieldH ::
<span class="lineno"> 6698 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6699 </span>  ExprVar (LLVMPointerType w) -&gt; AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 6700 </span>  PermExpr (BVType w) -&gt; Mb vars (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 6701 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 6702 </span>
<span class="lineno"> 6703 </span><span class="decl"><span class="nottickedoff">proveVarLLVMFieldH x p off mb_fp =</span>
<span class="lineno"> 6704 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 6705 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;proveVarLLVMFieldH:&quot; &lt;+&gt; permPretty i x &lt;&gt; colon &lt;&gt;</span>
<span class="lineno"> 6706 </span><span class="spaces">               </span><span class="nottickedoff">align (sep [PP.group (permPretty i p),</span>
<span class="lineno"> 6707 </span><span class="spaces">                           </span><span class="nottickedoff">pretty &quot;-o&quot;,</span>
<span class="lineno"> 6708 </span><span class="spaces">                           </span><span class="nottickedoff">PP.group (permPretty i mb_fp)])) &gt;&gt;&gt;</span>
<span class="lineno"> 6709 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMFieldH2 x p off mb_fp</span></span>
<span class="lineno"> 6710 </span>
<span class="lineno"> 6711 </span>proveVarLLVMFieldH2 ::
<span class="lineno"> 6712 </span>  (1 &lt;= w, KnownNat w, 1 &lt;= sz, KnownNat sz, NuMatchingAny1 r) =&gt;
<span class="lineno"> 6713 </span>  ExprVar (LLVMPointerType w) -&gt; AtomicPerm (LLVMPointerType w) -&gt;
<span class="lineno"> 6714 </span>  PermExpr (BVType w) -&gt; Mb vars (LLVMFieldPerm w sz) -&gt;
<span class="lineno"> 6715 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 6716 </span>
<span class="lineno"> 6717 </span>-- If we have a field permission of the correct size on the left, use it to
<span class="lineno"> 6718 </span>-- prove the field permission on the right
<span class="lineno"> 6719 </span><span class="decl"><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6720 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq (llvmFieldOffset fp) off</span>
<span class="lineno"> 6721 </span><span class="spaces">  </span><span class="nottickedoff">, Just Refl &lt;- testEquality (llvmFieldSize fp) (mbLLVMFieldSize mb_fp) =</span>
<span class="lineno"> 6722 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 1: make sure to have a variable for the contents</span>
<span class="lineno"> 6723 </span><span class="spaces">    </span><span class="nottickedoff">implElimLLVMFieldContentsM x fp &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 6724 </span><span class="spaces">    </span><span class="nottickedoff">let fp' = fp { llvmFieldContents = ValPerm_Eq (PExpr_Var y) } in</span>
<span class="lineno"> 6725 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6726 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 2: prove the contents</span>
<span class="lineno"> 6727 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt y (mbLLVMFieldContents mb_fp) &gt;&gt;&gt;</span>
<span class="lineno"> 6728 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM (mbLLVMFieldContents mb_fp)</span>
<span class="lineno"> 6729 </span><span class="spaces">    </span><span class="nottickedoff">&quot;proveVarLLVMFieldH&quot; &gt;&gt;&gt;= \p_y -&gt;</span>
<span class="lineno"> 6730 </span><span class="spaces">    </span><span class="nottickedoff">let fp'' = fp' { llvmFieldContents = p_y } in</span>
<span class="lineno"> 6731 </span><span class="spaces">    </span><span class="nottickedoff">introLLVMFieldContentsM x y fp'' &gt;&gt;&gt;</span>
<span class="lineno"> 6732 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6733 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 3: change the lifetime if needed. This is done after proving the</span>
<span class="lineno"> 6734 </span><span class="spaces">    </span><span class="nottickedoff">-- contents, so that, if we need to split the lifetime, we don't split the</span>
<span class="lineno"> 6735 </span><span class="spaces">    </span><span class="nottickedoff">-- lifetime of a pointer permission with eq(y) permissions, as that would</span>
<span class="lineno"> 6736 </span><span class="spaces">    </span><span class="nottickedoff">-- require the pointer to be constant until the end of the new lifetime.</span>
<span class="lineno"> 6737 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 6738 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: probably the right way to do this would be to first check if there</span>
<span class="lineno"> 6739 </span><span class="spaces">    </span><span class="nottickedoff">-- is going to be a borrow, and if so then recall the field permissions for</span>
<span class="lineno"> 6740 </span><span class="spaces">    </span><span class="nottickedoff">-- fp immediately before we do said borrow. Maybe this could be part of</span>
<span class="lineno"> 6741 </span><span class="spaces">    </span><span class="nottickedoff">-- proveVarLifetimeFunctor?</span>
<span class="lineno"> 6742 </span><span class="spaces">    </span><span class="nottickedoff">let (f, args) = fieldToLTFunc fp'' in</span>
<span class="lineno"> 6743 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLifetimeFunctor x f args (llvmFieldLifetime fp'')</span>
<span class="lineno"> 6744 </span><span class="spaces">    </span><span class="nottickedoff">(mbLLVMFieldLifetime mb_fp) &gt;&gt;&gt;= \l -&gt;</span>
<span class="lineno"> 6745 </span><span class="spaces">    </span><span class="nottickedoff">let fp''' = fp'' { llvmFieldLifetime = l } in</span>
<span class="lineno"> 6746 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6747 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 4: equalize the read/write modalities. This is done after changing</span>
<span class="lineno"> 6748 </span><span class="spaces">    </span><span class="nottickedoff">-- the lifetime so that the original modality is recovered after any borrow</span>
<span class="lineno"> 6749 </span><span class="spaces">    </span><span class="nottickedoff">-- performed above is over.</span>
<span class="lineno"> 6750 </span><span class="spaces">    </span><span class="nottickedoff">equalizeRWs x (\rw -&gt; ValPerm_LLVMField $ fp''' { llvmFieldRW = rw })</span>
<span class="lineno"> 6751 </span><span class="spaces">    </span><span class="nottickedoff">(llvmFieldRW fp) (mbLLVMFieldRW mb_fp)</span>
<span class="lineno"> 6752 </span><span class="spaces">    </span><span class="nottickedoff">(SImpl_DemoteLLVMFieldRW x fp''') &gt;&gt;&gt;= \rw' -&gt;</span>
<span class="lineno"> 6753 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6754 </span><span class="spaces">    </span><span class="nottickedoff">-- Step 5: duplicate the field permission if it is copyable, and then return</span>
<span class="lineno"> 6755 </span><span class="spaces">    </span><span class="nottickedoff">let fp'''' = fp''' { llvmFieldRW = rw' } in</span>
<span class="lineno"> 6756 </span><span class="spaces">    </span><span class="nottickedoff">(if atomicPermIsCopyable (Perm_LLVMField fp'''') then</span>
<span class="lineno"> 6757 </span><span class="spaces">       </span><span class="nottickedoff">implCopyM x (ValPerm_LLVMField fp'''') &gt;&gt;&gt;</span>
<span class="lineno"> 6758 </span><span class="spaces">       </span><span class="nottickedoff">recombinePerm x (ValPerm_LLVMField fp'''')</span>
<span class="lineno"> 6759 </span><span class="spaces">     </span><span class="nottickedoff">else return ()) &gt;&gt;&gt;</span>
<span class="lineno"> 6760 </span><span class="spaces">    </span><span class="nottickedoff">return ()</span>
<span class="lineno"> 6761 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6762 </span><span class="spaces"></span><span class="nottickedoff">-- If we have a field permission with the correct offset that is bigger than the</span>
<span class="lineno"> 6763 </span><span class="spaces"></span><span class="nottickedoff">-- size of the desired field permission rounded up to the nearest byte, split</span>
<span class="lineno"> 6764 </span><span class="spaces"></span><span class="nottickedoff">-- the field permission we have and recurse</span>
<span class="lineno"> 6765 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6766 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq (llvmFieldOffset fp) off</span>
<span class="lineno"> 6767 </span><span class="spaces">  </span><span class="nottickedoff">, sz &lt;- mbLLVMFieldSize mb_fp</span>
<span class="lineno"> 6768 </span><span class="spaces">  </span><span class="nottickedoff">, sz_bytes &lt;- (intValue sz + 7) `div` 8</span>
<span class="lineno"> 6769 </span><span class="spaces">  </span><span class="nottickedoff">, sz_bytes &lt; llvmFieldSizeBytes fp =</span>
<span class="lineno"> 6770 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldSplit x fp sz_bytes &gt;&gt;&gt;= \(p1, p2) -&gt;</span>
<span class="lineno"> 6771 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj1 p2) &gt;&gt;&gt;</span>
<span class="lineno"> 6772 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMFieldH x p1 off mb_fp</span>
<span class="lineno"> 6773 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6774 </span><span class="spaces"></span><span class="nottickedoff">-- If we have a field permission with the correct offset that is bigger than the</span>
<span class="lineno"> 6775 </span><span class="spaces"></span><span class="nottickedoff">-- desired field permission but did not match the previous case, then the</span>
<span class="lineno"> 6776 </span><span class="spaces"></span><span class="nottickedoff">-- desired field is some uneven number of bits smaller than the field we have,</span>
<span class="lineno"> 6777 </span><span class="spaces"></span><span class="nottickedoff">-- so all we can do is truncate the field we have</span>
<span class="lineno"> 6778 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6779 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq (llvmFieldOffset fp) off</span>
<span class="lineno"> 6780 </span><span class="spaces">  </span><span class="nottickedoff">, sz &lt;- mbLLVMFieldSize mb_fp</span>
<span class="lineno"> 6781 </span><span class="spaces">  </span><span class="nottickedoff">, intValue sz &lt; intValue (llvmFieldSize fp) =</span>
<span class="lineno"> 6782 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldTruncate x fp sz &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 6783 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMFieldH x p off mb_fp</span>
<span class="lineno"> 6784 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6785 </span><span class="spaces"></span><span class="nottickedoff">-- If we have a field permission with the correct offset that is smaller than</span>
<span class="lineno"> 6786 </span><span class="spaces"></span><span class="nottickedoff">-- the desired field permission, split the desired field permission into two,</span>
<span class="lineno"> 6787 </span><span class="spaces"></span><span class="nottickedoff">-- recursively prove the first of these from fp, prove the second with some</span>
<span class="lineno"> 6788 </span><span class="spaces"></span><span class="nottickedoff">-- other permissions, and then concatenate the results</span>
<span class="lineno"> 6789 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6790 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq (llvmFieldOffset fp) off</span>
<span class="lineno"> 6791 </span><span class="spaces">  </span><span class="nottickedoff">, sz &lt;- llvmFieldSize fp</span>
<span class="lineno"> 6792 </span><span class="spaces">  </span><span class="nottickedoff">, mb_sz &lt;- mbLLVMFieldSize mb_fp</span>
<span class="lineno"> 6793 </span><span class="spaces">  </span><span class="nottickedoff">, Just (sz' :: NatRepr sz') &lt;- subNat' mb_sz sz -- sz + sz' = mb_sz</span>
<span class="lineno"> 6794 </span><span class="spaces">  </span><span class="nottickedoff">, Left leq' &lt;- decideLeq (knownNat @1) sz'</span>
<span class="lineno"> 6795 </span><span class="spaces">  </span><span class="nottickedoff">, intValue sz `mod` 8 == 0</span>
<span class="lineno"> 6796 </span><span class="spaces">  </span><span class="nottickedoff">, sz_bytes &lt;- intValue sz `div` 8 =</span>
<span class="lineno"> 6797 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6798 </span><span class="spaces">    </span><span class="nottickedoff">-- First, eliminate fp to point to a variable y, and prove mb_fp with</span>
<span class="lineno"> 6799 </span><span class="spaces">    </span><span class="nottickedoff">-- contents (and size) set to y</span>
<span class="lineno"> 6800 </span><span class="spaces">    </span><span class="nottickedoff">implElimLLVMFieldContentsM x fp &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 6801 </span><span class="spaces">    </span><span class="nottickedoff">let fp' = fp { llvmFieldContents = ValPerm_Eq (PExpr_Var y) } in</span>
<span class="lineno"> 6802 </span><span class="spaces">    </span><span class="nottickedoff">let mb_fp1 = fmap (flip llvmFieldSetContents</span>
<span class="lineno"> 6803 </span><span class="spaces">                       </span><span class="nottickedoff">(ValPerm_Eq (PExpr_Var y))) mb_fp in</span>
<span class="lineno"> 6804 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMFieldH x (Perm_LLVMField fp') off mb_fp1 &gt;&gt;&gt;</span>
<span class="lineno"> 6805 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \p_top1 -&gt;</span>
<span class="lineno"> 6806 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6807 </span><span class="spaces">    </span><span class="nottickedoff">-- Next, prove the rest of mb_fp, at offset off+sz_bytes and with contents</span>
<span class="lineno"> 6808 </span><span class="spaces">    </span><span class="nottickedoff">-- equal to some variable z</span>
<span class="lineno"> 6809 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat sz' $ withLeqProof leq' $</span>
<span class="lineno"> 6810 </span><span class="spaces">    </span><span class="nottickedoff">let mb_fp2 =</span>
<span class="lineno"> 6811 </span><span class="spaces">          </span><span class="nottickedoff">mbCombine (MNil :&gt;: (Proxy :: Proxy (LLVMPointerType sz'))) $</span>
<span class="lineno"> 6812 </span><span class="spaces">          </span><span class="nottickedoff">fmap (\fp_rhs -&gt; nu $ \(z :: Name (LLVMPointerType sz')) -&gt;</span>
<span class="lineno"> 6813 </span><span class="spaces">                 </span><span class="nottickedoff">fp_rhs { llvmFieldOffset = bvAdd off (bvInt sz_bytes),</span>
<span class="lineno"> 6814 </span><span class="spaces">                          </span><span class="nottickedoff">llvmFieldContents = ValPerm_Eq (PExpr_Var z) })</span>
<span class="lineno"> 6815 </span><span class="spaces">          </span><span class="nottickedoff">mb_fp in</span>
<span class="lineno"> 6816 </span><span class="spaces">    </span><span class="nottickedoff">withExtVarsM (proveVarImplInt x $ mbValPerm_LLVMField mb_fp2) &gt;&gt;&gt;</span>
<span class="lineno"> 6817 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \p_top2 -&gt;</span>
<span class="lineno"> 6818 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6819 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, combine these two pieces of mb_fp into a single permission, and</span>
<span class="lineno"> 6820 </span><span class="spaces">    </span><span class="nottickedoff">-- use this permission to prove the one we needed to begin with</span>
<span class="lineno"> 6821 </span><span class="spaces">    </span><span class="nottickedoff">case (p_top1, p_top2) of</span>
<span class="lineno"> 6822 </span><span class="spaces">      </span><span class="nottickedoff">(ValPerm_LLVMField fp1, ValPerm_LLVMField fp2) -&gt;</span>
<span class="lineno"> 6823 </span><span class="spaces">        </span><span class="nottickedoff">implLLVMFieldConcat x fp1 fp2 &gt;&gt;&gt;</span>
<span class="lineno"> 6824 </span><span class="spaces">        </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 6825 </span><span class="spaces">        </span><span class="nottickedoff">(ValPerm_LLVMField fp_concat) -&gt;</span>
<span class="lineno"> 6826 </span><span class="spaces">          </span><span class="nottickedoff">proveVarLLVMFieldH x (Perm_LLVMField fp_concat) off mb_fp</span>
<span class="lineno"> 6827 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMFieldH2: expected field permission&quot;</span>
<span class="lineno"> 6828 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMFieldH2: expected field permissions&quot;</span>
<span class="lineno"> 6829 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6830 </span><span class="spaces"></span><span class="nottickedoff">-- If we have a field permission that contains the correct offset but doesn't</span>
<span class="lineno"> 6831 </span><span class="spaces"></span><span class="nottickedoff">-- start at it, then split it and recurse</span>
<span class="lineno"> 6832 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6833 </span><span class="spaces">  </span><span class="nottickedoff">| not $ bvEq (llvmFieldOffset fp) off</span>
<span class="lineno"> 6834 </span><span class="spaces">  </span><span class="nottickedoff">, bvInRange off (llvmFieldRange fp)</span>
<span class="lineno"> 6835 </span><span class="spaces">  </span><span class="nottickedoff">, Just split_off &lt;- bvMatchConstInt (bvSub off $ llvmFieldOffset fp) =</span>
<span class="lineno"> 6836 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMFieldSplit x fp split_off &gt;&gt;&gt;= \(p1, p2) -&gt;</span>
<span class="lineno"> 6837 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM x (ValPerm_Conj1 p1) x (ValPerm_Conj1 p2) &gt;&gt;&gt;</span>
<span class="lineno"> 6838 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj1 p1) &gt;&gt;&gt;</span>
<span class="lineno"> 6839 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMFieldH x p2 off mb_fp</span>
<span class="lineno"> 6840 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6841 </span><span class="spaces"></span><span class="nottickedoff">-- If we have a block permission on the left, eliminate it</span>
<span class="lineno"> 6842 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMBlock bp) off mb_fp =</span>
<span class="lineno"> 6843 </span><span class="spaces">  </span><span class="nottickedoff">implElimLLVMBlockForOffset x bp True off (mbValPerm_LLVMField mb_fp) &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 6844 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMFieldH x p off mb_fp</span>
<span class="lineno"> 6845 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6846 </span><span class="spaces"></span><span class="nottickedoff">-- If we have an array permission on the left such that @off@ matches an index</span>
<span class="lineno"> 6847 </span><span class="spaces"></span><span class="nottickedoff">-- into that array permission and mb_fp fits into the cell of that index, copy</span>
<span class="lineno"> 6848 </span><span class="spaces"></span><span class="nottickedoff">-- or borrow the corresponding cell and recurse</span>
<span class="lineno"> 6849 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMArray ap) off mb_fp</span>
<span class="lineno"> 6850 </span><span class="spaces">  </span><span class="nottickedoff">| Just ix &lt;- matchLLVMArrayIndex ap off</span>
<span class="lineno"> 6851 </span><span class="spaces">  </span><span class="nottickedoff">, cell &lt;- llvmArrayIndexCell ix</span>
<span class="lineno"> 6852 </span><span class="spaces">  </span><span class="nottickedoff">, sz_int &lt;- intValue (mbLLVMFieldSize mb_fp) `div` 8</span>
<span class="lineno"> 6853 </span><span class="spaces">  </span><span class="nottickedoff">, BV.asUnsigned (llvmArrayIndexOffset ix) + sz_int &lt;= (toInteger $</span>
<span class="lineno"> 6854 </span><span class="spaces">                                                         </span><span class="nottickedoff">llvmArrayStride ap) =</span>
<span class="lineno"> 6855 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayCellGet x ap cell &gt;&gt;&gt;= \(ap', bp) -&gt;</span>
<span class="lineno"> 6856 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_LLVMArray ap') &gt;&gt;&gt;</span>
<span class="lineno"> 6857 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMFieldH x (Perm_LLVMBlock bp) off mb_fp</span>
<span class="lineno"> 6858 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6859 </span><span class="spaces"></span><span class="nottickedoff">-- If we have an array on the left with a sub-array of the same size as mb_fp,</span>
<span class="lineno"> 6860 </span><span class="spaces"></span><span class="nottickedoff">-- prove that sub-array, convert it to a field, and recurse</span>
<span class="lineno"> 6861 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x (Perm_LLVMArray ap) off mb_fp</span>
<span class="lineno"> 6862 </span><span class="spaces">  </span><span class="nottickedoff">| Just ix &lt;- matchLLVMArrayIndex ap off</span>
<span class="lineno"> 6863 </span><span class="spaces">  </span><span class="nottickedoff">, BV.BV 0 &lt;- llvmArrayIndexOffset ix</span>
<span class="lineno"> 6864 </span><span class="spaces">  </span><span class="nottickedoff">, sz &lt;- mbLLVMFieldSize mb_fp</span>
<span class="lineno"> 6865 </span><span class="spaces">  </span><span class="nottickedoff">, num_cells &lt;- intValue sz `div` llvmArrayStrideBits ap</span>
<span class="lineno"> 6866 </span><span class="spaces">  </span><span class="nottickedoff">, cell &lt;- llvmArrayIndexCell ix</span>
<span class="lineno"> 6867 </span><span class="spaces">  </span><span class="nottickedoff">, sub_ap &lt;- ap { llvmArrayOffset = llvmArrayCellToAbsOffset ap cell,</span>
<span class="lineno"> 6868 </span><span class="spaces">                   </span><span class="nottickedoff">llvmArrayLen = bvInt num_cells,</span>
<span class="lineno"> 6869 </span><span class="spaces">                   </span><span class="nottickedoff">llvmArrayBorrows = [] }</span>
<span class="lineno"> 6870 </span><span class="spaces">  </span><span class="nottickedoff">, Just fp &lt;- llvmArrayToField sz sub_ap =</span>
<span class="lineno"> 6871 </span><span class="spaces">    </span><span class="nottickedoff">mbVarsM sub_ap &gt;&gt;&gt;= \mb_sub_ap -&gt;</span>
<span class="lineno"> 6872 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMArray x [Perm_LLVMArray ap] mb_sub_ap &gt;&gt;&gt;</span>
<span class="lineno"> 6873 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayToField x sub_ap sz) &gt;&gt;&gt;</span>
<span class="lineno"> 6874 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMFieldH x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6875 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6876 </span><span class="spaces"></span><span class="nottickedoff">-- If we have an any permission, eliminate it to a field and recurse</span>
<span class="lineno"> 6877 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x Perm_Any off (mb_fp :: Mb vars (LLVMFieldPerm w sz)) =</span>
<span class="lineno"> 6878 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 6879 </span><span class="spaces">  </span><span class="nottickedoff">let l = fromMaybe PExpr_Always (partialSubst psubst $</span>
<span class="lineno"> 6880 </span><span class="spaces">                                  </span><span class="nottickedoff">mbLLVMFieldLifetime mb_fp)</span>
<span class="lineno"> 6881 </span><span class="spaces">      </span><span class="nottickedoff">rw = fromMaybe PExpr_Write $ partialSubst psubst $ mbLLVMFieldRW mb_fp</span>
<span class="lineno"> 6882 </span><span class="spaces">      </span><span class="nottickedoff">p = ValPerm_Any :: ValuePerm (LLVMPointerType sz)</span>
<span class="lineno"> 6883 </span><span class="spaces">      </span><span class="nottickedoff">fp = LLVMFieldPerm rw l off p in</span>
<span class="lineno"> 6884 </span><span class="spaces">  </span><span class="nottickedoff">implCopyM x ValPerm_Any &gt;&gt;&gt; recombinePerm x ValPerm_Any &gt;&gt;&gt;</span>
<span class="lineno"> 6885 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimAnyToPtr x fp) &gt;&gt;&gt;</span>
<span class="lineno"> 6886 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMFieldH x (Perm_LLVMField fp) off mb_fp</span>
<span class="lineno"> 6887 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 6888 </span><span class="spaces"></span><span class="nottickedoff">-- If none of the above cases match, then fail</span>
<span class="lineno"> 6889 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMFieldH2 x p _ mb_fp =</span>
<span class="lineno"> 6890 </span><span class="spaces">  </span><span class="nottickedoff">implFailVarM &quot;proveVarLLVMFieldH&quot; x (ValPerm_Conj1 p)</span>
<span class="lineno"> 6891 </span><span class="spaces">  </span><span class="nottickedoff">(mbValPerm_LLVMField mb_fp)</span></span>
<span class="lineno"> 6892 </span>
<span class="lineno"> 6893 </span>----------------------------------------------------------------------
<span class="lineno"> 6894 </span>-- * Proving LLVM Array Permissions
<span class="lineno"> 6895 </span>----------------------------------------------------------------------
<span class="lineno"> 6896 </span>
<span class="lineno"> 6897 </span>-- FIXME: look over this stuff and make sure there isn't something useful in
<span class="lineno"> 6898 </span>-- here before removing it...
<span class="lineno"> 6899 </span>{-
<span class="lineno"> 6900 </span>-- | Search for a permission that _could_ prove a block at an offset in the
<span class="lineno"> 6901 </span>-- given range
<span class="lineno"> 6902 </span>findSomeBlock :: forall w. (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 6903 </span>                 [AtomicPerm (LLVMPointerType w)] -&gt; BVRange w -&gt;
<span class="lineno"> 6904 </span>                 Maybe (LLVMBlockPerm w)
<span class="lineno"> 6905 </span>findSomeBlock ps range = msum (couldProve &lt;$&gt; ps)
<span class="lineno"> 6906 </span>  where
<span class="lineno"> 6907 </span>    couldProve :: AtomicPerm (LLVMPointerType w) -&gt; Maybe (LLVMBlockPerm w)
<span class="lineno"> 6908 </span>    couldProve p =
<span class="lineno"> 6909 </span>      case p of
<span class="lineno"> 6910 </span>        Perm_LLVMArray (llvmArrayToBlocks -&gt; Just (bp:_))
<span class="lineno"> 6911 </span>          | bvCouldBeInRange (llvmBlockOffset bp) range -&gt; Just bp
<span class="lineno"> 6912 </span>        (llvmAtomicPermToBlock -&gt; Just bp)
<span class="lineno"> 6913 </span>          | bvCouldBeInRange (llvmBlockOffset bp) range -&gt; Just bp
<span class="lineno"> 6914 </span>        _ -&gt; Nothing
<span class="lineno"> 6915 </span>
<span class="lineno"> 6916 </span>-- | Given a list ps of permissions, find the subseqeuences of ps
<span class="lineno"> 6917 </span>-- that could cover the given array permission. Also returns the permissions
<span class="lineno"> 6918 </span>-- corresponding to the  given ranges.
<span class="lineno"> 6919 </span>gatherRangesForArray ::
<span class="lineno"> 6920 </span>  forall w.
<span class="lineno"> 6921 </span>  (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 6922 </span>  [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 6923 </span>  LLVMArrayPerm w -&gt;
<span class="lineno"> 6924 </span>  [[(Maybe (AtomicPerm (LLVMPointerType w)), LLVMArrayBorrow w)]]
<span class="lineno"> 6925 </span>gatherRangesForArray lhs rhs =
<span class="lineno"> 6926 </span>  collectRanges False (llvmArrayOffset rhs) (lhs_ranges ++ rhs_ranges)
<span class="lineno"> 6927 </span>  where
<span class="lineno"> 6928 </span>    -- This is what we have to work with:
<span class="lineno"> 6929 </span>    lhs_not_borrows = filterBorrowedPermissions lhs
<span class="lineno"> 6930 </span>    -- For each possible lhs permission, calculate the corresponding borrow
<span class="lineno"> 6931 </span>    lhs_ranges = [ (Just p, b) | p &lt;- lhs_not_borrows
<span class="lineno"> 6932 </span>                               , b &lt;- maybeToList (permToLLVMArrayBorrow rhs p) ]
<span class="lineno"> 6933 </span>    -- We don't need to worry about covering  the bits of the rhs that are borrowed
<span class="lineno"> 6934 </span>    rhs_ranges = [ (Nothing, b) | b &lt;- llvmArrayBorrows rhs ]
<span class="lineno"> 6935 </span>    -- This is the extent of the rhs array permission
<span class="lineno"> 6936 </span>    rhs_off_bytes = bvAdd (llvmArrayOffset rhs) (llvmArrayLengthBytes rhs)
<span class="lineno"> 6937 </span>
<span class="lineno"> 6938 </span>    -- check if the given offset is covered by the given borrow/range.
<span class="lineno"> 6939 </span>    -- the first parameter controls whether the start of the range must
<span class="lineno"> 6940 </span>    -- be equal to the given offset, or merely fall in the range
<span class="lineno"> 6941 </span>    rangeForOffset prec off (_, b) =
<span class="lineno"> 6942 </span>      if prec then bvEq off (bvRangeOffset range) else bvPropCouldHold prop
<span class="lineno"> 6943 </span>      where
<span class="lineno"> 6944 </span>        range = llvmArrayAbsBorrowRange rhs b
<span class="lineno"> 6945 </span>        prop = bvPropInRange off range
<span class="lineno"> 6946 </span>
<span class="lineno"> 6947 </span>    -- Build the possible sequences of permissions that cover the rhs.
<span class="lineno"> 6948 </span>    -- The Bool flag allows the first permission to _maybe_ cover the first offset,
<span class="lineno"> 6949 </span>    -- (it is set to True, i.e. the permission 'must' cover the desired offset,
<span class="lineno"> 6950 </span>    -- in recursive calls)
<span class="lineno"> 6951 </span>    collectRanges ::
<span class="lineno"> 6952 </span>      Bool -&gt;
<span class="lineno"> 6953 </span>      PermExpr (BVType w) -&gt;
<span class="lineno"> 6954 </span>      [(Maybe (AtomicPerm (LLVMPointerType w)), LLVMArrayBorrow w)] -&gt;
<span class="lineno"> 6955 </span>      [[(Maybe (AtomicPerm (LLVMPointerType w)), LLVMArrayBorrow w)]]
<span class="lineno"> 6956 </span>    collectRanges prec off0 ranges
<span class="lineno"> 6957 </span>      | bvLeq rhs_off_bytes off0 = [[]]
<span class="lineno"> 6958 </span>      | otherwise =
<span class="lineno"> 6959 </span>            [ h:rest | h@(_, b) &lt;- filter (rangeForOffset prec off0) ranges,
<span class="lineno"> 6960 </span>                       let r           = llvmArrayAbsBorrowRange rhs b,
<span class="lineno"> 6961 </span>                       let next_offset = bvRangeOffset r `bvAdd` bvRangeLength r,
<span class="lineno"> 6962 </span>                       rest &lt;- collectRanges True next_offset (filter (/= h) ranges) ]
<span class="lineno"> 6963 </span>
<span class="lineno"> 6964 </span>-- | Given atomic permissions @lhs@ and array permission @rhs@, construct a new
<span class="lineno"> 6965 </span>-- array permission that covers @rhs@, but is entirely borrowed. Each borrow of
<span class="lineno"> 6966 </span>-- the new permission corresponds to some permission in @lhs@ OR a borrow that
<span class="lineno"> 6967 </span>-- already exists in @rhs@.
<span class="lineno"> 6968 </span>--
<span class="lineno"> 6969 </span>-- Also returns the AtomicPerms corresponding to the borrows in the returned
<span class="lineno"> 6970 </span>-- array perm.
<span class="lineno"> 6971 </span>borrowedLLVMArrayForArray ::
<span class="lineno"> 6972 </span>  forall w.
<span class="lineno"> 6973 </span>  (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 6974 </span>  [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 6975 </span>  LLVMArrayPerm w -&gt;
<span class="lineno"> 6976 </span>  Maybe ([AtomicPerm (LLVMPointerType w)], LLVMArrayPerm w)
<span class="lineno"> 6977 </span>borrowedLLVMArrayForArray lhs rhs =
<span class="lineno"> 6978 </span>  case gatherRangesForArray lhs rhs of
<span class="lineno"> 6979 </span>    -- NOTE: This only returns the first such sequence
<span class="lineno"> 6980 </span>    (unzip -&gt; (ps, bs)):_
<span class="lineno"> 6981 </span>      | not (null rs)
<span class="lineno"> 6982 </span>      , Just n &lt;- len' -&gt;
<span class="lineno"> 6983 </span>      Just (catMaybes ps, rhs { llvmArrayBorrows = bs'
<span class="lineno"> 6984 </span>                              , llvmArrayLen     = n
<span class="lineno"> 6985 </span>                              , llvmArrayOffset  = o'
<span class="lineno"> 6986 </span>                              })
<span class="lineno"> 6987 </span>      where
<span class="lineno"> 6988 </span>        rs        = llvmArrayAbsBorrowRange rhs &lt;$&gt; bs
<span class="lineno"> 6989 </span>        (r', rs') = expectLengthAtLeastOne rs
<span class="lineno"> 6990 </span>
<span class="lineno"> 6991 </span>        bs'  = chopBorrows [] bs (llvmArrayBorrows rhs) ++ llvmArrayBorrows rhs
<span class="lineno"> 6992 </span>        o'   = bvRangeOffset r'
<span class="lineno"> 6993 </span>        v    = bvRangeOffset rs' `bvAdd` bvRangeLength rs'
<span class="lineno"> 6994 </span>        len' = matchLLVMArrayCell rhs v
<span class="lineno"> 6995 </span>    _ -&gt; Nothing
<span class="lineno"> 6996 </span>
<span class="lineno"> 6997 </span>  where
<span class="lineno"> 6998 </span>    overlapsWith b = or . fmap (not . bvPropCouldHold) . llvmArrayBorrowsDisjoint b
<span class="lineno"> 6999 </span>
<span class="lineno"> 7000 </span>    -- We need to chop up any ranges that overlap with borrows on the rhs
<span class="lineno"> 7001 </span>    chopBorrows bs_skip bs_lhs bs_rhs
<span class="lineno"> 7002 </span>      | Just bi    &lt;- findIndex (`notElem` bs_rhs) bs_lhs
<span class="lineno"> 7003 </span>      , Just b_rhs &lt;- find (overlapsWith (bs_lhs!!bi)) bs_rhs
<span class="lineno"> 7004 </span>      = let b         = bs_lhs!!bi
<span class="lineno"> 7005 </span>            b_rhs_off = llvmArrayBorrowCells b_rhs
<span class="lineno"> 7006 </span>            bs_lhs'   =  llvmArrayBorrowRangeDelete b b_rhs_off ++ deleteNth bi bs_lhs
<span class="lineno"> 7007 </span>        in chopBorrows bs_skip bs_lhs' bs_rhs
<span class="lineno"> 7008 </span>      | Just bi    &lt;- findIndex (`notElem` bs_rhs) bs_lhs
<span class="lineno"> 7009 </span>      = chopBorrows ((bs_lhs!!bi):bs_skip) (deleteNth bi bs_lhs) bs_rhs
<span class="lineno"> 7010 </span>      | otherwise
<span class="lineno"> 7011 </span>      = bs_skip ++ bs_lhs
<span class="lineno"> 7012 </span>-}
<span class="lineno"> 7013 </span>
<span class="lineno"> 7014 </span>
<span class="lineno"> 7015 </span>-- | Prove an LLVM array permission @ap@ from permissions @x:(p1 * ... *pn)@ on
<span class="lineno"> 7016 </span>-- the top of the stack, ensuring that any remaining permissions for @x@ get
<span class="lineno"> 7017 </span>-- popped back to the primary permissions for @x@. This function does not unfold
<span class="lineno"> 7018 </span>-- named permissions in the @pi@s.
<span class="lineno"> 7019 </span>proveVarLLVMArray ::
<span class="lineno"> 7020 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7021 </span>  [AtomicPerm (LLVMPointerType w)] -&gt; Mb vars (LLVMArrayPerm w) -&gt;
<span class="lineno"> 7022 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7023 </span>
<span class="lineno"> 7024 </span><span class="decl"><span class="nottickedoff">proveVarLLVMArray x ps mb_ap =</span>
<span class="lineno"> 7025 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 7026 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;proveVarLLVMArray:&quot; &lt;+&gt; permPretty i x &lt;&gt; colon &lt;&gt;</span>
<span class="lineno"> 7027 </span><span class="spaces">               </span><span class="nottickedoff">align (sep [PP.group (permPretty i (ValPerm_Conj ps)),</span>
<span class="lineno"> 7028 </span><span class="spaces">                           </span><span class="nottickedoff">pretty &quot;-o&quot;,</span>
<span class="lineno"> 7029 </span><span class="spaces">                           </span><span class="nottickedoff">PP.group (permPretty i mb_ap)])) &gt;&gt;&gt;</span>
<span class="lineno"> 7030 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 7031 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMArrayH x psubst ps mb_ap</span></span>
<span class="lineno"> 7032 </span>
<span class="lineno"> 7033 </span>-- | The main implementation of 'proveVarLLVMArray'. At a high level, the
<span class="lineno"> 7034 </span>-- algorithm chooses one of the ways that an array permission can be proved,
<span class="lineno"> 7035 </span>-- which are:
<span class="lineno"> 7036 </span>--
<span class="lineno"> 7037 </span>-- 1. From an array permission with the same offset and length;
<span class="lineno"> 7038 </span>--
<span class="lineno"> 7039 </span>-- 2. By borrowing or copying a portion of a larger array permission;
<span class="lineno"> 7040 </span>--
<span class="lineno"> 7041 </span>-- 3. By constructing a fully borrowed array using 'SImpl_LLVMArrayBorrowed'; or
<span class="lineno"> 7042 </span>--
<span class="lineno"> 7043 </span>-- 4. By eliminating a @memblock@ permission with array shape.
<span class="lineno"> 7044 </span>--
<span class="lineno"> 7045 </span>-- NOTE: these \&quot;ways\&quot; do *not* line up with the cases of the function, labeled
<span class="lineno"> 7046 </span>-- as \&quot;case 1\&quot;, \&quot;case 2\&quot;, etc. outputs in the code below.
<span class="lineno"> 7047 </span>--
<span class="lineno"> 7048 </span>-- To determine which way to use, the algorithm searches for a permission
<span class="lineno"> 7049 </span>-- currently held on the left that is either an array permission with exactly
<span class="lineno"> 7050 </span>-- the required offset and length or that includes them in its range, or is a
<span class="lineno"> 7051 </span>-- block permission that that includes the required offset and length in its
<span class="lineno"> 7052 </span>-- range. Currently, there are no rules for changing the stride of an array, so
<span class="lineno"> 7053 </span>-- arrays with different strides are not considered. If no such permission is
<span class="lineno"> 7054 </span>-- found on the left, then a fully borrowed array permission is created, where
<span class="lineno"> 7055 </span>-- the borrows are calculated to either line up with the ranges of permissions
<span class="lineno"> 7056 </span>-- we already hold on the left, so they can be returned, or to be in the desired
<span class="lineno"> 7057 </span>-- output permission, so we do not have to return them.
<span class="lineno"> 7058 </span>--
<span class="lineno"> 7059 </span>-- In all of these ways, an array permission with the required offset and
<span class="lineno"> 7060 </span>-- length is either found on the left or created, and all ways then reduce to
<span class="lineno"> 7061 </span>-- way 1. At this point, the algorithm equalizes the borrows, meaning that it
<span class="lineno"> 7062 </span>-- returns any borrows on the left that are not on the right (where the right is
<span class="lineno"> 7063 </span>-- the desired output permission) and borrows any borrows on the right that are
<span class="lineno"> 7064 </span>-- not on the left. It then adjusts the read/write and lifetime modalities and
<span class="lineno"> 7065 </span>-- coerces the cell permissions if necessary. These steps are performed by the
<span class="lineno"> 7066 </span>-- helper function 'proveVarLLVMArray_FromArray'.
<span class="lineno"> 7067 </span>proveVarLLVMArrayH ::
<span class="lineno"> 7068 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7069 </span>  PartialSubst vars -&gt; [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 7070 </span>  Mb vars (LLVMArrayPerm w) -&gt;
<span class="lineno"> 7071 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7072 </span>
<span class="lineno"> 7073 </span>-- Special case: if the length is 0, prove an empty array
<span class="lineno"> 7074 </span><span class="decl"><span class="nottickedoff">proveVarLLVMArrayH x psubst ps mb_ap</span>
<span class="lineno"> 7075 </span><span class="spaces">  </span><span class="nottickedoff">| Just len &lt;- partialSubst psubst $ mbLLVMArrayLen mb_ap</span>
<span class="lineno"> 7076 </span><span class="spaces">  </span><span class="nottickedoff">, bvIsZero len =</span>
<span class="lineno"> 7077 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 7078 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_ap &quot;proveVarLLVMArray: incomplete psubst&quot; &gt;&gt;&gt;= \ap -&gt;</span>
<span class="lineno"> 7079 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayEmpty x ap</span>
<span class="lineno"> 7080 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7081 </span><span class="spaces"></span><span class="nottickedoff">-- If we have a single array permission that covers the RHS, then we are using</span>
<span class="lineno"> 7082 </span><span class="spaces"></span><span class="nottickedoff">-- way 1 or 2, so either use that or borrow or copy a portion of it and proceed</span>
<span class="lineno"> 7083 </span><span class="spaces"></span><span class="nottickedoff">-- to proveVarLLVMArray_FromArray</span>
<span class="lineno"> 7084 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArrayH x psubst ps mb_ap</span>
<span class="lineno"> 7085 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMArrayOffset mb_ap</span>
<span class="lineno"> 7086 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMArrayLen mb_ap</span>
<span class="lineno"> 7087 </span><span class="spaces">  </span><span class="nottickedoff">, Just lenBytes &lt;- partialSubst psubst $ mbLLVMArrayLenBytes mb_ap</span>
<span class="lineno"> 7088 </span><span class="spaces">  </span><span class="nottickedoff">, stride &lt;- mbLLVMArrayStride mb_ap</span>
<span class="lineno"> 7089 </span><span class="spaces">  </span><span class="nottickedoff">, Just bs  &lt;- partialSubst psubst $ mbLLVMArrayBorrows mb_ap</span>
<span class="lineno"> 7090 </span><span class="spaces">  </span><span class="nottickedoff">, Just i   &lt;- findIndex (suitableAP off lenBytes stride bs) ps</span>
<span class="lineno"> 7091 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMArray ap_lhs &lt;- ps!!i =</span>
<span class="lineno"> 7092 </span><span class="spaces">    </span><span class="nottickedoff">implVerbTraceM (\info -&gt; pretty &quot;proveVarLLVMArrayH case 1: using&quot; &lt;+&gt;</span>
<span class="lineno"> 7093 </span><span class="spaces">                             </span><span class="nottickedoff">permPretty info ap_lhs) &gt;&gt;&gt;</span>
<span class="lineno"> 7094 </span><span class="spaces">    </span><span class="nottickedoff">implGetConjM x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7095 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 7096 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7097 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM (mbLLVMArrayBorrows mb_ap)</span>
<span class="lineno"> 7098 </span><span class="spaces">    </span><span class="nottickedoff">&quot;proveVarLLVMArrayH: incomplete array borrows&quot; &gt;&gt;&gt;</span>
<span class="lineno"> 7099 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7100 </span><span class="spaces">    </span><span class="nottickedoff">if bvEq off (llvmArrayOffset ap_lhs) &amp;&amp; bvEq len (llvmArrayLen ap_lhs) then</span>
<span class="lineno"> 7101 </span><span class="spaces">      </span><span class="nottickedoff">proveVarLLVMArray_FromArray x ap_lhs len bs mb_ap</span>
<span class="lineno"> 7102 </span><span class="spaces">    </span><span class="nottickedoff">else</span>
<span class="lineno"> 7103 </span><span class="spaces">      </span><span class="nottickedoff">implLLVMArrayGet x ap_lhs off len &gt;&gt;&gt;= \ap_lhs' -&gt;</span>
<span class="lineno"> 7104 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x (ValPerm_LLVMArray ap_lhs') &gt;&gt;&gt;</span>
<span class="lineno"> 7105 </span><span class="spaces">      </span><span class="nottickedoff">proveVarLLVMArray_FromArray x (llvmMakeSubArray ap_lhs off len) len bs mb_ap</span>
<span class="lineno"> 7106 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 7107 </span><span class="spaces">    </span><span class="nottickedoff">-- Test if an atomic permission is a &quot;suitable&quot; array permission for the</span>
<span class="lineno"> 7108 </span><span class="spaces">    </span><span class="nottickedoff">-- given offset, length, stride, and borrows, meaning that it has the</span>
<span class="lineno"> 7109 </span><span class="spaces">    </span><span class="nottickedoff">-- given stride, could contain the given offset and length, and either</span>
<span class="lineno"> 7110 </span><span class="spaces">    </span><span class="nottickedoff">-- has exactly the given borrows or at least does not have all of the</span>
<span class="lineno"> 7111 </span><span class="spaces">    </span><span class="nottickedoff">-- given offset and length borrowed</span>
<span class="lineno"> 7112 </span><span class="spaces">    </span><span class="nottickedoff">suitableAP ::</span>
<span class="lineno"> 7113 </span><span class="spaces">      </span><span class="nottickedoff">(1 &lt;= w, KnownNat w) =&gt;</span>
<span class="lineno"> 7114 </span><span class="spaces">      </span><span class="nottickedoff">PermExpr (BVType w) -&gt; PermExpr (BVType w) -&gt; Bytes -&gt;</span>
<span class="lineno"> 7115 </span><span class="spaces">      </span><span class="nottickedoff">[LLVMArrayBorrow w] -&gt; AtomicPerm (LLVMPointerType w) -&gt; Bool</span>
<span class="lineno"> 7116 </span><span class="spaces">    </span><span class="nottickedoff">suitableAP off len stride bs (Perm_LLVMArray ap) =</span>
<span class="lineno"> 7117 </span><span class="spaces">      </span><span class="nottickedoff">-- Test that the strides are equal</span>
<span class="lineno"> 7118 </span><span class="spaces">      </span><span class="nottickedoff">llvmArrayStride ap == stride &amp;&amp;</span>
<span class="lineno"> 7119 </span><span class="spaces">      </span><span class="nottickedoff">-- Test if this permission *could* cover the desired off/len</span>
<span class="lineno"> 7120 </span><span class="spaces">      </span><span class="nottickedoff">all bvPropCouldHold (bvPropRangeSubset (BVRange off len)</span>
<span class="lineno"> 7121 </span><span class="spaces">                                             </span><span class="nottickedoff">(llvmArrayAbsOffsets ap)) &amp;&amp;</span>
<span class="lineno"> 7122 </span><span class="spaces">      </span><span class="nottickedoff">-- Test that either the sets of borrows are equal ...</span>
<span class="lineno"> 7123 </span><span class="spaces">      </span><span class="nottickedoff">((all (flip elem bs) (llvmArrayBorrows ap) &amp;&amp;</span>
<span class="lineno"> 7124 </span><span class="spaces">        </span><span class="nottickedoff">all (flip elem (llvmArrayBorrows ap)) bs) ||</span>
<span class="lineno"> 7125 </span><span class="spaces">       </span><span class="nottickedoff">-- ...or the range [off,len) is not fully borrowed</span>
<span class="lineno"> 7126 </span><span class="spaces">       </span><span class="nottickedoff">not (llvmArrayRangeIsBorrowed ap (BVRange off len)))</span>
<span class="lineno"> 7127 </span><span class="spaces">    </span><span class="nottickedoff">suitableAP _ _ _ _ _ = False</span>
<span class="lineno"> 7128 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7129 </span><span class="spaces"></span><span class="nottickedoff">-- Check if there is a block that contains the required offset and length, in</span>
<span class="lineno"> 7130 </span><span class="spaces"></span><span class="nottickedoff">-- which case eliminate it, allowing us to either satisfy way 4 (eliminate a</span>
<span class="lineno"> 7131 </span><span class="spaces"></span><span class="nottickedoff">-- memblock to an array), or to generate a set of permissions that can contain</span>
<span class="lineno"> 7132 </span><span class="spaces"></span><span class="nottickedoff">-- array and/or pointer permissions that can be used to satisfy one of ways 1-3</span>
<span class="lineno"> 7133 </span><span class="spaces"></span><span class="nottickedoff">-- when we recurse</span>
<span class="lineno"> 7134 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArrayH x psubst ps mb_ap</span>
<span class="lineno"> 7135 </span><span class="spaces">  </span><span class="nottickedoff">| Just rng &lt;- partialSubst psubst $ mbLLVMArrayRange mb_ap</span>
<span class="lineno"> 7136 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (\p -&gt; isLLVMBlockPerm p &amp;&amp;</span>
<span class="lineno"> 7137 </span><span class="spaces">                               </span><span class="nottickedoff">llvmAtomicPermCouldContainRange rng p) ps =</span>
<span class="lineno"> 7138 </span><span class="spaces">    </span><span class="nottickedoff">implVerbTraceM (\info -&gt; pretty &quot;proveVarLLVMArrayH case 2: eliminating&quot; &lt;+&gt;</span>
<span class="lineno"> 7139 </span><span class="spaces">                             </span><span class="nottickedoff">permPretty info (ps!!i)) &gt;&gt;&gt;</span>
<span class="lineno"> 7140 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7141 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMArray x ps' mb_ap</span>
<span class="lineno"> 7142 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7143 </span><span class="spaces"></span><span class="nottickedoff">-- This case prepares us to hit case 4 below, which needs the modalities of</span>
<span class="lineno"> 7144 </span><span class="spaces"></span><span class="nottickedoff">-- mb_ap to be determined; this is done by finding an arbitrary permission on</span>
<span class="lineno"> 7145 </span><span class="spaces"></span><span class="nottickedoff">-- the left that overlaps with a non-borrowed portion of mb_ap and using it to</span>
<span class="lineno"> 7146 </span><span class="spaces"></span><span class="nottickedoff">-- instantiate the modalities</span>
<span class="lineno"> 7147 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArrayH x psubst ps mb_ap</span>
<span class="lineno"> 7148 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMArrayOffset mb_ap</span>
<span class="lineno"> 7149 </span><span class="spaces">  </span><span class="nottickedoff">, Just lenBytes &lt;- partialSubst psubst $ mbLLVMArrayLenBytes mb_ap</span>
<span class="lineno"> 7150 </span><span class="spaces">  </span><span class="nottickedoff">, not (isJust $ partialSubst psubst $ mbLLVMArrayRW mb_ap) ||</span>
<span class="lineno"> 7151 </span><span class="spaces">    </span><span class="nottickedoff">not (isJust $ partialSubst psubst $ mbLLVMArrayLifetime mb_ap)</span>
<span class="lineno"> 7152 </span><span class="spaces">  </span><span class="nottickedoff">, Just p &lt;- find (llvmAtomicPermCouldOverlapRange (BVRange off lenBytes)) ps</span>
<span class="lineno"> 7153 </span><span class="spaces">  </span><span class="nottickedoff">, Just rw &lt;- atomicPermModality p</span>
<span class="lineno"> 7154 </span><span class="spaces">  </span><span class="nottickedoff">, Just l &lt;- atomicPermLifetime p =</span>
<span class="lineno"> 7155 </span><span class="spaces">    </span><span class="nottickedoff">implVerbTraceM (\_ -&gt; pretty &quot;proveVarLLVMArrayH case 3 (unifying vars)&quot;) &gt;&gt;&gt;</span>
<span class="lineno"> 7156 </span><span class="spaces">    </span><span class="nottickedoff">tryUnifyVars rw (mbLLVMArrayRW mb_ap) &gt;&gt;&gt;</span>
<span class="lineno"> 7157 </span><span class="spaces">    </span><span class="nottickedoff">tryUnifyVars l (mbLLVMArrayLifetime mb_ap) &gt;&gt;&gt;</span>
<span class="lineno"> 7158 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMArray x ps mb_ap</span>
<span class="lineno"> 7159 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7160 </span><span class="spaces"></span><span class="nottickedoff">-- If none of the above match, try and build a completely borrowed array whose</span>
<span class="lineno"> 7161 </span><span class="spaces"></span><span class="nottickedoff">-- borrows are made up of either borrows in the desired output permission mb_ap</span>
<span class="lineno"> 7162 </span><span class="spaces"></span><span class="nottickedoff">-- or are ranges on permissions that we already hold on the left, which is way 3</span>
<span class="lineno"> 7163 </span><span class="spaces"></span><span class="nottickedoff">-- for building an array permission</span>
<span class="lineno"> 7164 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArrayH x psubst ps mb_ap</span>
<span class="lineno"> 7165 </span><span class="spaces">  </span><span class="nottickedoff">| Just ap &lt;- partialSubst psubst mb_ap</span>
<span class="lineno"> 7166 </span><span class="spaces">  </span><span class="nottickedoff">, len &lt;- llvmArrayLen ap</span>
<span class="lineno"> 7167 </span><span class="spaces">  </span><span class="nottickedoff">, lhs_cells@(lhs_cell_rng:_) &lt;- concatMap (permCells ap) ps</span>
<span class="lineno"> 7168 </span><span class="spaces">  </span><span class="nottickedoff">, rhs_cells &lt;- map llvmArrayBorrowCells (llvmArrayBorrows ap)</span>
<span class="lineno"> 7169 </span><span class="spaces">  </span><span class="nottickedoff">, Just cells &lt;- gatherCoveringRanges (llvmArrayCells ap) (rhs_cells ++</span>
<span class="lineno"> 7170 </span><span class="spaces">                                                            </span><span class="nottickedoff">lhs_cells)</span>
<span class="lineno"> 7171 </span><span class="spaces">  </span><span class="nottickedoff">, bs &lt;- map cellRangeToBorrow cells</span>
<span class="lineno"> 7172 </span><span class="spaces">  </span><span class="nottickedoff">, ap_borrowed &lt;- ap { llvmArrayBorrows = bs }</span>
<span class="lineno"> 7173 </span><span class="spaces">  </span><span class="nottickedoff">, cell_bp &lt;- blockForCell ap (bvRangeOffset lhs_cell_rng) =</span>
<span class="lineno"> 7174 </span><span class="spaces">    </span><span class="nottickedoff">implVerbTraceM (\i -&gt; hang 2 $</span>
<span class="lineno"> 7175 </span><span class="spaces">                          </span><span class="nottickedoff">sep [pretty &quot;proveVarLLVMArrayH case 4&quot;,</span>
<span class="lineno"> 7176 </span><span class="spaces">                               </span><span class="nottickedoff">pretty &quot;cell ranges = &quot; &lt;&gt; permPretty i cells,</span>
<span class="lineno"> 7177 </span><span class="spaces">                               </span><span class="nottickedoff">pretty &quot;bp = &quot; &lt;&gt; permPretty i cell_bp]) &gt;&gt;&gt;</span>
<span class="lineno"> 7178 </span><span class="spaces">    </span><span class="nottickedoff">mbVarsM cell_bp &gt;&gt;&gt;= \mb_cell_bp -&gt;</span>
<span class="lineno"> 7179 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlock x ps mb_cell_bp &gt;&gt;&gt;</span>
<span class="lineno"> 7180 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayBorrowed x cell_bp ap_borrowed &gt;&gt;&gt;</span>
<span class="lineno"> 7181 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj1 (Perm_LLVMBlock cell_bp)) &gt;&gt;&gt;</span>
<span class="lineno"> 7182 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMArray_FromArray x ap_borrowed len (llvmArrayBorrows ap) mb_ap</span>
<span class="lineno"> 7183 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 7184 </span><span class="spaces">    </span><span class="nottickedoff">-- Comupte the range of array cells in ap that an atomic permission</span>
<span class="lineno"> 7185 </span><span class="spaces">    </span><span class="nottickedoff">-- corresponds to, if any, as long as it is not wholly borrowed</span>
<span class="lineno"> 7186 </span><span class="spaces">    </span><span class="nottickedoff">permCells :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;</span>
<span class="lineno"> 7187 </span><span class="spaces">                 </span><span class="nottickedoff">AtomicPerm (LLVMPointerType w) -&gt; [BVRange w]</span>
<span class="lineno"> 7188 </span><span class="spaces">    </span><span class="nottickedoff">permCells ap p = mapMaybe (llvmArrayAbsOffsetsToCells ap) (permOffsets p)</span>
<span class="lineno"> 7189 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7190 </span><span class="spaces">    </span><span class="nottickedoff">-- Compute the range of offsets in an atomic permission, if any, using the</span>
<span class="lineno"> 7191 </span><span class="spaces">    </span><span class="nottickedoff">-- whole range of an array permission iff it is not fully borrowed</span>
<span class="lineno"> 7192 </span><span class="spaces">    </span><span class="nottickedoff">permOffsets :: (1 &lt;= w, KnownNat w) =&gt; AtomicPerm (LLVMPointerType w) -&gt;</span>
<span class="lineno"> 7193 </span><span class="spaces">                   </span><span class="nottickedoff">[BVRange w]</span>
<span class="lineno"> 7194 </span><span class="spaces">    </span><span class="nottickedoff">permOffsets (Perm_LLVMArray ap) =</span>
<span class="lineno"> 7195 </span><span class="spaces">      </span><span class="nottickedoff">bvRangesDelete (llvmArrayRange ap) $</span>
<span class="lineno"> 7196 </span><span class="spaces">      </span><span class="nottickedoff">map (llvmArrayAbsBorrowRange ap) (llvmArrayBorrows ap)</span>
<span class="lineno"> 7197 </span><span class="spaces">    </span><span class="nottickedoff">permOffsets p = maybeToList $ llvmAtomicPermRange p</span>
<span class="lineno"> 7198 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7199 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert a range to a borrow</span>
<span class="lineno"> 7200 </span><span class="spaces">    </span><span class="nottickedoff">cellRangeToBorrow :: (1 &lt;= w, KnownNat w) =&gt; BVRange w -&gt; LLVMArrayBorrow w</span>
<span class="lineno"> 7201 </span><span class="spaces">    </span><span class="nottickedoff">cellRangeToBorrow (BVRange cell (bvMatchConstInt -&gt; Just 1)) =</span>
<span class="lineno"> 7202 </span><span class="spaces">      </span><span class="nottickedoff">FieldBorrow cell</span>
<span class="lineno"> 7203 </span><span class="spaces">    </span><span class="nottickedoff">cellRangeToBorrow rng = RangeBorrow rng</span>
<span class="lineno"> 7204 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7205 </span><span class="spaces">    </span><span class="nottickedoff">-- Create a block permission for a cell in an array</span>
<span class="lineno"> 7206 </span><span class="spaces">    </span><span class="nottickedoff">blockForCell :: (1 &lt;= w, KnownNat w) =&gt; LLVMArrayPerm w -&gt;</span>
<span class="lineno"> 7207 </span><span class="spaces">                    </span><span class="nottickedoff">PermExpr (BVType w) -&gt; LLVMBlockPerm w</span>
<span class="lineno"> 7208 </span><span class="spaces">    </span><span class="nottickedoff">blockForCell ap cell =</span>
<span class="lineno"> 7209 </span><span class="spaces">      </span><span class="nottickedoff">LLVMBlockPerm { llvmBlockRW = llvmArrayRW ap,</span>
<span class="lineno"> 7210 </span><span class="spaces">                      </span><span class="nottickedoff">llvmBlockLifetime = llvmArrayLifetime ap,</span>
<span class="lineno"> 7211 </span><span class="spaces">                      </span><span class="nottickedoff">llvmBlockOffset = llvmArrayCellToAbsOffset ap cell,</span>
<span class="lineno"> 7212 </span><span class="spaces">                      </span><span class="nottickedoff">llvmBlockLen = bvInt (toInteger $ llvmArrayStride ap),</span>
<span class="lineno"> 7213 </span><span class="spaces">                      </span><span class="nottickedoff">llvmBlockShape = llvmArrayCellShape ap }</span>
<span class="lineno"> 7214 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7215 </span><span class="spaces"></span><span class="nottickedoff">-- If we get here, then there is no covering of the offsets needed for mb_ap, so</span>
<span class="lineno"> 7216 </span><span class="spaces"></span><span class="nottickedoff">-- there is no possible way we could prove mb_ap, and thus we fail</span>
<span class="lineno"> 7217 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArrayH x _ ps mb_ap =</span>
<span class="lineno"> 7218 </span><span class="spaces">  </span><span class="nottickedoff">implFailVarM &quot;proveVarLLVMArrayH&quot; x (ValPerm_Conj ps)</span>
<span class="lineno"> 7219 </span><span class="spaces">  </span><span class="nottickedoff">(mbValPerm_LLVMArray mb_ap)</span></span>
<span class="lineno"> 7220 </span>
<span class="lineno"> 7221 </span>
<span class="lineno"> 7222 </span>-- | Prove an array permission @mb_ap@ using the array permission @ap_lhs@ on
<span class="lineno"> 7223 </span>-- top of the stack, assuming that @ap_lhs@ has the same offset and stride as
<span class="lineno"> 7224 </span>-- @ap@ and that @ap@ has length and borrows given by the supplied arguments.
<span class="lineno"> 7225 </span>proveVarLLVMArray_FromArray ::
<span class="lineno"> 7226 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7227 </span>  LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt; [LLVMArrayBorrow w] -&gt;
<span class="lineno"> 7228 </span>  Mb vars (LLVMArrayPerm w) -&gt;
<span class="lineno"> 7229 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7230 </span>
<span class="lineno"> 7231 </span><span class="decl"><span class="nottickedoff">proveVarLLVMArray_FromArray x ap_lhs len bs mb_ap =</span>
<span class="lineno"> 7232 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\info -&gt;</span>
<span class="lineno"> 7233 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;proveVarLLVMArray_FromArray:&quot; &lt;+&gt;</span>
<span class="lineno"> 7234 </span><span class="spaces">               </span><span class="nottickedoff">permPretty info x &lt;&gt; colon &lt;&gt;</span>
<span class="lineno"> 7235 </span><span class="spaces">               </span><span class="nottickedoff">align (sep [permPretty info (ValPerm_LLVMArray ap_lhs),</span>
<span class="lineno"> 7236 </span><span class="spaces">                           </span><span class="nottickedoff">pretty &quot;-o&quot;,</span>
<span class="lineno"> 7237 </span><span class="spaces">                           </span><span class="nottickedoff">PP.group (permPretty info mb_ap),</span>
<span class="lineno"> 7238 </span><span class="spaces">                           </span><span class="nottickedoff">pretty &quot;bs = &quot; &lt;&gt; permPretty info bs])) &gt;&gt;&gt;</span>
<span class="lineno"> 7239 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMArray_FromArrayH x ap_lhs len bs mb_ap</span></span>
<span class="lineno"> 7240 </span>
<span class="lineno"> 7241 </span>-- | The implementation of 'proveVarLLVMArray_FromArray'
<span class="lineno"> 7242 </span>proveVarLLVMArray_FromArrayH ::
<span class="lineno"> 7243 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7244 </span>  LLVMArrayPerm w -&gt; PermExpr (BVType w) -&gt; [LLVMArrayBorrow w] -&gt;
<span class="lineno"> 7245 </span>  Mb vars (LLVMArrayPerm w) -&gt;
<span class="lineno"> 7246 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7247 </span>
<span class="lineno"> 7248 </span>-- If there is a borrow in ap_lhs that is not in ap, return it to ap_lhs
<span class="lineno"> 7249 </span>--
<span class="lineno"> 7250 </span>-- FIXME: when an array is returned to ap_lhs, this code requires all of it to
<span class="lineno"> 7251 </span>-- be returned, with no borrows, even though it could be that some portion of
<span class="lineno"> 7252 </span>-- that borrow is borrowed in mb_ap. E.g., if ap_lhs has the range [0,8)
<span class="lineno"> 7253 </span>-- borrowed while mb_ap only needs to have [2,3) borrowed, this code will first
<span class="lineno"> 7254 </span>-- return all of [0,8) and then borrow [2,3), while the array return rule allows
<span class="lineno"> 7255 </span>-- all of [0,8) except [2,3) to be returned as one step.
<span class="lineno"> 7256 </span><span class="decl"><span class="nottickedoff">proveVarLLVMArray_FromArrayH x ap_lhs len bs mb_ap</span>
<span class="lineno"> 7257 </span><span class="spaces">  </span><span class="nottickedoff">| Just b &lt;- find (flip notElem bs) (llvmArrayBorrows ap_lhs) =</span>
<span class="lineno"> 7258 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7259 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove the borrowed perm</span>
<span class="lineno"> 7260 </span><span class="spaces">    </span><span class="nottickedoff">let p = permForLLVMArrayBorrow ap_lhs b in</span>
<span class="lineno"> 7261 </span><span class="spaces">    </span><span class="nottickedoff">mbVarsM p &gt;&gt;&gt;= \mb_p -&gt;</span>
<span class="lineno"> 7262 </span><span class="spaces">    </span><span class="nottickedoff">implTraceM (\info -&gt;</span>
<span class="lineno"> 7263 </span><span class="spaces">                 </span><span class="nottickedoff">hang 2 $</span>
<span class="lineno"> 7264 </span><span class="spaces">                 </span><span class="nottickedoff">sep [pretty &quot;Proving borrowed permission...&quot;,</span>
<span class="lineno"> 7265 </span><span class="spaces">                      </span><span class="nottickedoff">permPretty info p,</span>
<span class="lineno"> 7266 </span><span class="spaces">                      </span><span class="nottickedoff">pretty &quot;For borrow:&quot; &lt;+&gt; permPretty info b,</span>
<span class="lineno"> 7267 </span><span class="spaces">                      </span><span class="nottickedoff">pretty &quot;From array:&quot; &lt;+&gt; permPretty info ap_lhs]) &gt;&gt;&gt;</span>
<span class="lineno"> 7268 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt x mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 7269 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM x (ValPerm_Conj1 $ Perm_LLVMArray ap_lhs) x p &gt;&gt;&gt;</span>
<span class="lineno"> 7270 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7271 </span><span class="spaces">    </span><span class="nottickedoff">-- Return the borrowed perm to ap_lhs to get ap</span>
<span class="lineno"> 7272 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayReturnBorrow x ap_lhs b &gt;&gt;&gt;</span>
<span class="lineno"> 7273 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7274 </span><span class="spaces">    </span><span class="nottickedoff">-- Continue proving mb_ap with the updated ap_lhs</span>
<span class="lineno"> 7275 </span><span class="spaces">    </span><span class="nottickedoff">let ap_lhs' = llvmArrayRemBorrow b ap_lhs in</span>
<span class="lineno"> 7276 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMArray_FromArray x ap_lhs' len bs mb_ap</span>
<span class="lineno"> 7277 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7278 </span><span class="spaces"></span><span class="nottickedoff">-- If there is a borrow in ap that is not in ap_lhs, borrow it from ap_lhs. Note</span>
<span class="lineno"> 7279 </span><span class="spaces"></span><span class="nottickedoff">-- the assymmetry with the previous case: we only add borrows if we definitely</span>
<span class="lineno"> 7280 </span><span class="spaces"></span><span class="nottickedoff">-- have to, but we remove borrows if we might have to.</span>
<span class="lineno"> 7281 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArray_FromArrayH x ap_lhs len bs mb_ap</span>
<span class="lineno"> 7282 </span><span class="spaces">  </span><span class="nottickedoff">| Just b &lt;- find (flip notElem (llvmArrayBorrows ap_lhs)) bs =</span>
<span class="lineno"> 7283 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7284 </span><span class="spaces">    </span><span class="nottickedoff">-- Borrow the permission if that is possible; this will fail if ap has a</span>
<span class="lineno"> 7285 </span><span class="spaces">    </span><span class="nottickedoff">-- borrow that is not actually in its range</span>
<span class="lineno"> 7286 </span><span class="spaces">    </span><span class="nottickedoff">implLLVMArrayBorrowBorrow x ap_lhs b &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 7287 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt;</span>
<span class="lineno"> 7288 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7289 </span><span class="spaces">    </span><span class="nottickedoff">-- Continue proving mb_ap with the updated ap_lhs</span>
<span class="lineno"> 7290 </span><span class="spaces">    </span><span class="nottickedoff">let ap_lhs' = llvmArrayAddBorrow b ap_lhs in</span>
<span class="lineno"> 7291 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMArray_FromArray x ap_lhs' len bs mb_ap</span>
<span class="lineno"> 7292 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7293 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7294 </span><span class="spaces"></span><span class="nottickedoff">-- If we get here then ap_lhs and ap have the same borrows, offset, length, and</span>
<span class="lineno"> 7295 </span><span class="spaces"></span><span class="nottickedoff">-- stride, so equalize their modalities, prove the shape of mb_ap from that of</span>
<span class="lineno"> 7296 </span><span class="spaces"></span><span class="nottickedoff">-- ap_lhs, rearrange their borrows, and we are done</span>
<span class="lineno"> 7297 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMArray_FromArrayH x ap_lhs _ bs mb_ap =</span>
<span class="lineno"> 7298 </span><span class="spaces">  </span><span class="nottickedoff">-- Coerce the rw modality of ap_lhs to that of mb_ap, if possibe</span>
<span class="lineno"> 7299 </span><span class="spaces">  </span><span class="nottickedoff">equalizeRWs x (\rw -&gt; ValPerm_LLVMArray $ ap_lhs { llvmArrayRW = rw })</span>
<span class="lineno"> 7300 </span><span class="spaces">  </span><span class="nottickedoff">(llvmArrayRW ap_lhs) (mbLLVMArrayRW mb_ap)</span>
<span class="lineno"> 7301 </span><span class="spaces">  </span><span class="nottickedoff">(SImpl_DemoteLLVMArrayRW x ap_lhs) &gt;&gt;&gt;= \rw -&gt;</span>
<span class="lineno"> 7302 </span><span class="spaces">  </span><span class="nottickedoff">let ap_lhs' = ap_lhs { llvmArrayRW = rw } in</span>
<span class="lineno"> 7303 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7304 </span><span class="spaces">  </span><span class="nottickedoff">-- Coerce the lifetime of ap_lhs to that of mb_ap, if possible</span>
<span class="lineno"> 7305 </span><span class="spaces">  </span><span class="nottickedoff">let (f, args) = arrayToLTFunc ap_lhs' in</span>
<span class="lineno"> 7306 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLifetimeFunctor x f args (llvmArrayLifetime ap_lhs)</span>
<span class="lineno"> 7307 </span><span class="spaces">  </span><span class="nottickedoff">(mbLLVMArrayLifetime mb_ap) &gt;&gt;&gt;= \l -&gt;</span>
<span class="lineno"> 7308 </span><span class="spaces">  </span><span class="nottickedoff">let ap_lhs'' = ap_lhs' { llvmArrayLifetime = l } in</span>
<span class="lineno"> 7309 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7310 </span><span class="spaces">  </span><span class="nottickedoff">-- Coerce the shape of ap_lhs to that of mb_ap, if necessary. Note that all</span>
<span class="lineno"> 7311 </span><span class="spaces">  </span><span class="nottickedoff">-- the fields of ap should be defined at this point except possible its cell</span>
<span class="lineno"> 7312 </span><span class="spaces">  </span><span class="nottickedoff">-- shape, but we cannot handle instantiating evars inside local implications,</span>
<span class="lineno"> 7313 </span><span class="spaces">  </span><span class="nottickedoff">-- so we require it to be defined as well, and we substitute into mb_ap.</span>
<span class="lineno"> 7314 </span><span class="spaces">  </span><span class="nottickedoff">partialSubstForceM mb_ap &quot;proveVarLLVMArray: incomplete psubst&quot; &gt;&gt;&gt;= \ap -&gt;</span>
<span class="lineno"> 7315 </span><span class="spaces">  </span><span class="nottickedoff">let sh = llvmArrayCellShape ap in</span>
<span class="lineno"> 7316 </span><span class="spaces">  </span><span class="nottickedoff">(if sh == llvmArrayCellShape ap_lhs then</span>
<span class="lineno"> 7317 </span><span class="spaces">     </span><span class="nottickedoff">-- If the shapes are already equal, do nothing</span>
<span class="lineno"> 7318 </span><span class="spaces">     </span><span class="nottickedoff">return ap_lhs''</span>
<span class="lineno"> 7319 </span><span class="spaces">   </span><span class="nottickedoff">else</span>
<span class="lineno"> 7320 </span><span class="spaces">     </span><span class="nottickedoff">-- Otherwise, coerce the contents</span>
<span class="lineno"> 7321 </span><span class="spaces">     </span><span class="nottickedoff">let dps_in = nu $ \y -&gt; distPerms1 y $ ValPerm_LLVMBlock $</span>
<span class="lineno"> 7322 </span><span class="spaces">                             </span><span class="nottickedoff">llvmArrayCellPerm ap_lhs'' $ bvInt 0</span>
<span class="lineno"> 7323 </span><span class="spaces">         </span><span class="nottickedoff">dps_out = nu $ \y -&gt; distPerms1 y $ ValPerm_LLVMBlock $</span>
<span class="lineno"> 7324 </span><span class="spaces">                              </span><span class="nottickedoff">llvmArrayCellPerm ap $ bvInt 0 in</span>
<span class="lineno"> 7325 </span><span class="spaces">     </span><span class="nottickedoff">localMbProveVars dps_in dps_out &gt;&gt;&gt;= \mb_impl -&gt;</span>
<span class="lineno"> 7326 </span><span class="spaces">     </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayContents x ap_lhs'' sh mb_impl) &gt;&gt;&gt;</span>
<span class="lineno"> 7327 </span><span class="spaces">     </span><span class="nottickedoff">return (ap_lhs'' { llvmArrayCellShape = sh })) &gt;&gt;&gt;= \ap_lhs''' -&gt;</span>
<span class="lineno"> 7328 </span><span class="spaces">  </span><span class="nottickedoff">-- Finally, rearrange the borrows of ap_lhs to match bs</span>
<span class="lineno"> 7329 </span><span class="spaces">  </span><span class="nottickedoff">implLLVMArrayRearrange x ap_lhs''' bs</span></span>
<span class="lineno"> 7330 </span>
<span class="lineno"> 7331 </span>----------------------------------------------------------------------
<span class="lineno"> 7332 </span>-- * Proving Named Permission Arguments
<span class="lineno"> 7333 </span>----------------------------------------------------------------------
<span class="lineno"> 7334 </span>
<span class="lineno"> 7335 </span>-- | Prove @P&lt;args1&gt; |- P&lt;args2&gt;@ by weakening the arguments in @args1@ and
<span class="lineno"> 7336 </span>-- substituting for free variablers in @args2@ until the arguments are
<span class="lineno"> 7337 </span>-- equal. The weakening steps include:
<span class="lineno"> 7338 </span>--
<span class="lineno"> 7339 </span>-- * Replacing 'Write' arguments with 'Read';
<span class="lineno"> 7340 </span>--
<span class="lineno"> 7341 </span>-- * Replacing a bigger lifetime @l1@ with a smaller one @l2@, defined by the
<span class="lineno"> 7342 </span>-- existence of a @l2:[l1]lcurrent@;
<span class="lineno"> 7343 </span>--
<span class="lineno"> 7344 </span>-- * Replacing all lifetime arguments with a single @lowned@ lifetime @l@, by
<span class="lineno"> 7345 </span>-- splitting the lifetime of the input permission
<span class="lineno"> 7346 </span>--
<span class="lineno"> 7347 </span>-- FIXME: currently this does not do the lifetime splitting step
<span class="lineno"> 7348 </span>proveNamedArgs :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 7349 </span>                  NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 7350 </span>                  PermOffset a -&gt; Mb vars (PermExprs args) -&gt;
<span class="lineno"> 7351 </span>                  ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 7352 </span><span class="decl"><span class="nottickedoff">proveNamedArgs x npn args off mb_args =</span>
<span class="lineno"> 7353 </span><span class="spaces">  </span><span class="nottickedoff">do _ &lt;- implTraceM (\i -&gt; pretty &quot;proveNamedArgs:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 7354 </span><span class="spaces">                       </span><span class="nottickedoff">ppImpl i x (ValPerm_Named npn args off)</span>
<span class="lineno"> 7355 </span><span class="spaces">                       </span><span class="nottickedoff">(fmap (\args' -&gt; ValPerm_Named npn args' off) mb_args))</span>
<span class="lineno"> 7356 </span><span class="spaces">     </span><span class="nottickedoff">psubst &lt;- getPSubst</span>
<span class="lineno"> 7357 </span><span class="spaces">     </span><span class="nottickedoff">mapM_ (\case Some memb -&gt;</span>
<span class="lineno"> 7358 </span><span class="spaces">                    </span><span class="nottickedoff">proveNamedArg x npn args off memb psubst $</span>
<span class="lineno"> 7359 </span><span class="spaces">                    </span><span class="nottickedoff">fmap (`nthPermExpr` memb) mb_args)</span>
<span class="lineno"> 7360 </span><span class="spaces">       </span><span class="nottickedoff">(getPermExprsMembers args)</span></span>
<span class="lineno"> 7361 </span>
<span class="lineno"> 7362 </span>
<span class="lineno"> 7363 </span>-- | Prove @P&lt;args1,arg,args2&gt; |- P&lt;args1,arg',args2&gt;@ where @arg@ is specified
<span class="lineno"> 7364 </span>-- by a 'Member' proof in the input @args@ and @arg'@ potentially has
<span class="lineno"> 7365 </span>-- existential variables. Assume the LHS is on the top of the stack and leave
<span class="lineno"> 7366 </span>-- the RHS, if proved, on the top of the stack.
<span class="lineno"> 7367 </span>proveNamedArg :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 7368 </span>                 NamedPermName ns args a -&gt; PermExprs args -&gt;
<span class="lineno"> 7369 </span>                 PermOffset a -&gt; Member args b -&gt; PartialSubst vars -&gt;
<span class="lineno"> 7370 </span>                 Mb vars (PermExpr b) -&gt;
<span class="lineno"> 7371 </span>                 ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 7372 </span><span class="decl"><span class="nottickedoff">proveNamedArg x npn args off memb psubst arg = case mbMatch arg of</span>
<span class="lineno"> 7373 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7374 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove P&lt;args1,always,args2&gt; -o P&lt;args1,l,args2&gt; for free variable l</span>
<span class="lineno"> 7375 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var z |]</span>
<span class="lineno"> 7376 </span><span class="spaces">    </span><span class="nottickedoff">| PExpr_Always &lt;- nthPermExpr args memb</span>
<span class="lineno"> 7377 </span><span class="spaces">    </span><span class="nottickedoff">, Right l &lt;- mbNameBoundP z -&gt;</span>
<span class="lineno"> 7378 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedArgAlways x npn args off memb (PExpr_Var l))</span>
<span class="lineno"> 7379 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7380 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove P&lt;args1,always,args2&gt; -o P&lt;args1,l,args2&gt; for assigned variable l</span>
<span class="lineno"> 7381 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var z |]</span>
<span class="lineno"> 7382 </span><span class="spaces">    </span><span class="nottickedoff">| PExpr_Always &lt;- nthPermExpr args memb</span>
<span class="lineno"> 7383 </span><span class="spaces">    </span><span class="nottickedoff">, Left memb_z &lt;- mbNameBoundP z</span>
<span class="lineno"> 7384 </span><span class="spaces">    </span><span class="nottickedoff">, Just e &lt;- psubstLookup psubst memb_z -&gt;</span>
<span class="lineno"> 7385 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedArgAlways x npn args off memb e)</span>
<span class="lineno"> 7386 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7387 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove P&lt;args1,l1,args2&gt; -o P&lt;args1,l2,args2&gt; for l1/=l2 using l1:[l2]lcurrent</span>
<span class="lineno"> 7388 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var z |]</span>
<span class="lineno"> 7389 </span><span class="spaces">    </span><span class="nottickedoff">| Right l1 &lt;- mbNameBoundP z</span>
<span class="lineno"> 7390 </span><span class="spaces">    </span><span class="nottickedoff">, LifetimeRepr &lt;- cruCtxLookup (namedPermNameArgs npn) memb</span>
<span class="lineno"> 7391 </span><span class="spaces">    </span><span class="nottickedoff">, PExpr_Var l2 &lt;- nthPermExpr args memb</span>
<span class="lineno"> 7392 </span><span class="spaces">    </span><span class="nottickedoff">, l1 /= l2 -&gt;</span>
<span class="lineno"> 7393 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplInt l1 (mbConst (ValPerm_LCurrent $ PExpr_Var l2) arg) &gt;&gt;&gt;</span>
<span class="lineno"> 7394 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedArgCurrent x npn args off memb (PExpr_Var l2))</span>
<span class="lineno"> 7395 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7396 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove P&lt;args1,W,args2&gt; -o P&lt;args1,rw,args2&gt; for any variable rw</span>
<span class="lineno"> 7397 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_Var z |]</span>
<span class="lineno"> 7398 </span><span class="spaces">    </span><span class="nottickedoff">| Right rw &lt;- mbNameBoundP z</span>
<span class="lineno"> 7399 </span><span class="spaces">    </span><span class="nottickedoff">, PExpr_RWModality Write &lt;- nthPermExpr args memb -&gt;</span>
<span class="lineno"> 7400 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedArgWrite x npn args off memb (PExpr_Var rw))</span>
<span class="lineno"> 7401 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7402 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove P&lt;args1,rw,args2&gt; -o P&lt;args1,R,args2&gt; for any rw</span>
<span class="lineno"> 7403 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| PExpr_RWModality Read |] -&gt;</span>
<span class="lineno"> 7404 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_NamedArgRead x npn args off memb)</span>
<span class="lineno"> 7405 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7406 </span><span class="spaces">  </span><span class="nottickedoff">-- Otherwise, prove P&lt;args1,e1,args2&gt; -o P&lt;args1,e2,args2&gt; by proving e1=e2</span>
<span class="lineno"> 7407 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 7408 </span><span class="spaces">    </span><span class="nottickedoff">proveEqCast x (\e -&gt; ValPerm_Named npn (setNthPermExpr args memb e) off)</span>
<span class="lineno"> 7409 </span><span class="spaces">    </span><span class="nottickedoff">(nthPermExpr args memb) arg</span></span>
<span class="lineno"> 7410 </span>
<span class="lineno"> 7411 </span>
<span class="lineno"> 7412 </span>{-
<span class="lineno"> 7413 </span>  -- Prove x:P&lt;args,p1&gt; -o x:P&lt;args,p2&gt; when P is a reachability permission by
<span class="lineno"> 7414 </span>  -- eliminating the LHS into x:P&lt;args,eq(y)&gt; and y:p1, proving y:P&lt;args,p2&gt;, and
<span class="lineno"> 7415 </span>  -- applying transitivity of reachability permissions
<span class="lineno"> 7416 </span>  [nuMP| PExpr_ValPerm mb_p |]
<span class="lineno"> 7417 </span>    | RecursiveSortRepr b TrueRepr &lt;- namedPermNameSort npn
<span class="lineno"> 7418 </span>    , NameReachConstr &lt;- namedPermNameReachConstr npn -&gt;
<span class="lineno"> 7419 </span>      implLookupNamedPerm npn &gt;&gt;&gt;= \(NamedPerm_Rec rp) -&gt;
<span class="lineno"> 7420 </span>      implElimReachabilityPermM x rp args off p &gt;&gt;&gt;= \y -&gt;
<span class="lineno"> 7421 </span>      proveVarImpl y (fmap (\e' -&gt;
<span class="lineno"> 7422 </span>                             ValPerm_Named npn (PExprs_Cons
<span class="lineno"> 7423 </span>                                                args e') off) mb_e) &gt;&gt;&gt;
<span class="lineno"> 7424 </span>      partialSubstForceM mb_p
<span class="lineno"> 7425 </span>      &quot;proveNamedArg: incomplete psubst: p_y&quot; &gt;&gt;&gt;= \p_y -&gt;
<span class="lineno"> 7426 </span>      implSimplM Proxy (SImpl_ReachabilityTrans x rp args off y p_y)
<span class="lineno"> 7427 </span>-}
<span class="lineno"> 7428 </span>
<span class="lineno"> 7429 </span>{-
<span class="lineno"> 7430 </span>  -- Fail in any other case
<span class="lineno"> 7431 </span>  _ -&gt;
<span class="lineno"> 7432 </span>    implFailVarM &quot;proveNamedArg&quot; x
<span class="lineno"> 7433 </span>    (ValPerm_Named npn args off)
<span class="lineno"> 7434 </span>    (fmap (\args' -&gt;
<span class="lineno"> 7435 </span>            ValPerm_Named npn (setNthPermExpr args memb args') off) mb_arg)
<span class="lineno"> 7436 </span>-}
<span class="lineno"> 7437 </span>
<span class="lineno"> 7438 </span>----------------------------------------------------------------------
<span class="lineno"> 7439 </span>-- * Proving LLVM Block Permissions
<span class="lineno"> 7440 </span>----------------------------------------------------------------------
<span class="lineno"> 7441 </span>
<span class="lineno"> 7442 </span>-- FIXME HERE: maybe use implGetLLVMPermForOffset for proveVarLLVMBlock?
<span class="lineno"> 7443 </span>
<span class="lineno"> 7444 </span>-- | Prove a @memblock@ permission from the conjunction of the supplied atomic
<span class="lineno"> 7445 </span>-- permissions which are on the top of the stack
<span class="lineno"> 7446 </span>proveVarLLVMBlock ::
<span class="lineno"> 7447 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7448 </span>  [AtomicPerm (LLVMPointerType w)] -&gt; Mb vars (LLVMBlockPerm w) -&gt;
<span class="lineno"> 7449 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7450 </span><span class="decl"><span class="nottickedoff">proveVarLLVMBlock x ps mb_bp =</span>
<span class="lineno"> 7451 </span><span class="spaces">  </span><span class="nottickedoff">do psubst &lt;- getPSubst</span>
<span class="lineno"> 7452 </span><span class="spaces">     </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst [mb_bp]</span></span>
<span class="lineno"> 7453 </span>
<span class="lineno"> 7454 </span>-- | Prove a conjunction of block and atomic permissions for @x@ from the
<span class="lineno"> 7455 </span>-- permissions on top of the stack, which are given by the second argument.
<span class="lineno"> 7456 </span>--
<span class="lineno"> 7457 </span>-- A central motivation of this algorithm is to do as little elimination on the
<span class="lineno"> 7458 </span>-- left or introduction on the right as possible, in order to build the smallest
<span class="lineno"> 7459 </span>-- derivation we can. The algorithm iterates through the block permissions on
<span class="lineno"> 7460 </span>-- the right, trying for each of them to match it up with a block permission on
<span class="lineno"> 7461 </span>-- the left. The first stage of the algorithm attempts to break down permissions
<span class="lineno"> 7462 </span>-- on the left that overlap with but are not contained in the current block
<span class="lineno"> 7463 </span>-- permission on the right we are trying to prove, so that we end up with
<span class="lineno"> 7464 </span>-- permissions on the left that are no bigger than the right. This stage is
<span class="lineno"> 7465 </span>-- performed by 'proveVarLLVMBlocks1'. The algorithm then repeatedly breaks down
<span class="lineno"> 7466 </span>-- the right-hand block permission we are trying to prove, going back to stage
<span class="lineno"> 7467 </span>-- one if necessary if this leads to it being smaller than some left-hand
<span class="lineno"> 7468 </span>-- permission, until we either get a precise match or we eventually break the
<span class="lineno"> 7469 </span>-- right-hand permission down to block permission whose offset, size, and shape
<span class="lineno"> 7470 </span>-- matches one on the left. This stage is performed by 'proveVarLLVMBlocks2'.
<span class="lineno"> 7471 </span>proveVarLLVMBlocks ::
<span class="lineno"> 7472 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7473 </span>  [AtomicPerm (LLVMPointerType w)] -&gt; PartialSubst vars -&gt;
<span class="lineno"> 7474 </span>  [Mb vars (LLVMBlockPerm w)] -&gt;
<span class="lineno"> 7475 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7476 </span>
<span class="lineno"> 7477 </span><span class="decl"><span class="nottickedoff">proveVarLLVMBlocks x ps psubst mb_bps =</span>
<span class="lineno"> 7478 </span><span class="spaces">  </span><span class="nottickedoff">-- This substitution is to only print the existential vars once, on the</span>
<span class="lineno"> 7479 </span><span class="spaces">  </span><span class="nottickedoff">-- outside; also, substituting here ensures that we only traverse the</span>
<span class="lineno"> 7480 </span><span class="spaces">  </span><span class="nottickedoff">-- permissions once</span>
<span class="lineno"> 7481 </span><span class="spaces">  </span><span class="nottickedoff">mbSubstM (\s -&gt; map s mb_bps) &gt;&gt;&gt;= \mb_bps' -&gt;</span>
<span class="lineno"> 7482 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM</span>
<span class="lineno"> 7483 </span><span class="spaces">  </span><span class="nottickedoff">(\i -&gt; sep [pretty &quot;proveVarLLVMBlocks&quot;,</span>
<span class="lineno"> 7484 </span><span class="spaces">              </span><span class="nottickedoff">permPretty i x &lt;&gt; colon &lt;&gt; permPretty i ps,</span>
<span class="lineno"> 7485 </span><span class="spaces">              </span><span class="nottickedoff">pretty &quot;-o&quot;, permPretty i mb_bps']) &gt;&gt;&gt;</span>
<span class="lineno"> 7486 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst mb_bps</span></span>
<span class="lineno"> 7487 </span>
<span class="lineno"> 7488 </span>
<span class="lineno"> 7489 </span>-- | Call 'proveVarLLVMBlock' in a context extended with a fresh existential
<span class="lineno"> 7490 </span>-- variable, which is used only in the first block permission we want to prove,
<span class="lineno"> 7491 </span>-- and return the value assigned to that evar
<span class="lineno"> 7492 </span>proveVarLLVMBlocksExt1 ::
<span class="lineno"> 7493 </span>  (1 &lt;= w, KnownNat w, KnownRepr TypeRepr tp, NuMatchingAny1 r) =&gt;
<span class="lineno"> 7494 </span>  ExprVar (LLVMPointerType w) -&gt; [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 7495 </span>  PartialSubst vars -&gt; Mb (vars :&gt; tp) (LLVMBlockPerm w) -&gt;
<span class="lineno"> 7496 </span>  [Mb vars (LLVMBlockPerm w)] -&gt;
<span class="lineno"> 7497 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) (PermExpr tp)
<span class="lineno"> 7498 </span><span class="decl"><span class="nottickedoff">proveVarLLVMBlocksExt1 x ps psubst mb_bp_ext mb_bps =</span>
<span class="lineno"> 7499 </span><span class="spaces">  </span><span class="nottickedoff">fmap snd $ withExtVarsM $</span>
<span class="lineno"> 7500 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMBlocks x ps (extPSubst psubst)</span>
<span class="lineno"> 7501 </span><span class="spaces">  </span><span class="nottickedoff">(mb_bp_ext : map extMb mb_bps)</span></span>
<span class="lineno"> 7502 </span>
<span class="lineno"> 7503 </span>-- | Like 'proveVarLLVMBlockExt1' but bind 2 existential variables, which can be
<span class="lineno"> 7504 </span>-- used in 0 or more block permissions we want to prove
<span class="lineno"> 7505 </span>proveVarLLVMBlocksExt2 ::
<span class="lineno"> 7506 </span>  (1 &lt;= w, KnownNat w, KnownRepr TypeRepr tp1,
<span class="lineno"> 7507 </span>   KnownRepr TypeRepr tp2, NuMatchingAny1 r) =&gt;
<span class="lineno"> 7508 </span>  ExprVar (LLVMPointerType w) -&gt; [AtomicPerm (LLVMPointerType w)] -&gt;
<span class="lineno"> 7509 </span>  PartialSubst vars -&gt; Mb (vars :&gt; tp1 :&gt; tp2) [LLVMBlockPerm w] -&gt;
<span class="lineno"> 7510 </span>  [Mb vars (LLVMBlockPerm w)] -&gt;
<span class="lineno"> 7511 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 7512 </span>  (PermExpr tp1, PermExpr tp2)
<span class="lineno"> 7513 </span><span class="decl"><span class="nottickedoff">proveVarLLVMBlocksExt2 x ps psubst mb_bps_ext mb_bps =</span>
<span class="lineno"> 7514 </span><span class="spaces">  </span><span class="nottickedoff">withExtVarsM</span>
<span class="lineno"> 7515 </span><span class="spaces">  </span><span class="nottickedoff">(withExtVarsM $</span>
<span class="lineno"> 7516 </span><span class="spaces">   </span><span class="nottickedoff">proveVarLLVMBlocks x ps (extPSubst $ extPSubst psubst)</span>
<span class="lineno"> 7517 </span><span class="spaces">   </span><span class="nottickedoff">(mbList mb_bps_ext ++ (map (extMb . extMb) mb_bps))) &gt;&gt;= \((_,e2),e1) -&gt;</span>
<span class="lineno"> 7518 </span><span class="spaces">  </span><span class="nottickedoff">pure (e1,e2)</span></span>
<span class="lineno"> 7519 </span>
<span class="lineno"> 7520 </span>-- | Assume the first block permission is on top of the stack, and attempt to
<span class="lineno"> 7521 </span>-- coerce its read-write modality and lifetime to those of the second, leaving
<span class="lineno"> 7522 </span>-- the resulting block permission on top of the stack. Return the resulting
<span class="lineno"> 7523 </span>-- block permission.
<span class="lineno"> 7524 </span>equalizeBlockModalities :: (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt;
<span class="lineno"> 7525 </span>                           ExprVar (LLVMPointerType w) -&gt; LLVMBlockPerm w -&gt;
<span class="lineno"> 7526 </span>                           Mb vars (LLVMBlockPerm w) -&gt;
<span class="lineno"> 7527 </span>                           ImplM vars s r
<span class="lineno"> 7528 </span>                           (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w)
<span class="lineno"> 7529 </span>                           (LLVMBlockPerm w)
<span class="lineno"> 7530 </span><span class="decl"><span class="nottickedoff">equalizeBlockModalities x bp mb_bp =</span>
<span class="lineno"> 7531 </span><span class="spaces">  </span><span class="nottickedoff">equalizeRWs x (\rw -&gt; ValPerm_LLVMBlock $ bp { llvmBlockRW = rw })</span>
<span class="lineno"> 7532 </span><span class="spaces">  </span><span class="nottickedoff">(llvmBlockRW bp) (mbLLVMBlockRW mb_bp) (SImpl_DemoteLLVMBlockRW x bp)</span>
<span class="lineno"> 7533 </span><span class="spaces">  </span><span class="nottickedoff">&gt;&gt;&gt;= \rw -&gt;</span>
<span class="lineno"> 7534 </span><span class="spaces">  </span><span class="nottickedoff">let bp' = bp { llvmBlockRW = rw }</span>
<span class="lineno"> 7535 </span><span class="spaces">      </span><span class="nottickedoff">(f, args) = blockToLTFunc bp' in</span>
<span class="lineno"> 7536 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLifetimeFunctor x f args (llvmBlockLifetime bp)</span>
<span class="lineno"> 7537 </span><span class="spaces">  </span><span class="nottickedoff">(mbLLVMBlockLifetime mb_bp) &gt;&gt;&gt;= \l -&gt;</span>
<span class="lineno"> 7538 </span><span class="spaces">  </span><span class="nottickedoff">return (bp' { llvmBlockLifetime = l })</span></span>
<span class="lineno"> 7539 </span>
<span class="lineno"> 7540 </span>
<span class="lineno"> 7541 </span>-- | Stage 1 of 'proveVarLLVMBlocks'. See that comments on that function.
<span class="lineno"> 7542 </span>proveVarLLVMBlocks1 ::
<span class="lineno"> 7543 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7544 </span>  [AtomicPerm (LLVMPointerType w)] -&gt; PartialSubst vars -&gt;
<span class="lineno"> 7545 </span>  [Mb vars (LLVMBlockPerm w)] -&gt;
<span class="lineno"> 7546 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7547 </span>
<span class="lineno"> 7548 </span>-- We are done, yay! Pop ps and build a true permission
<span class="lineno"> 7549 </span><span class="decl"><span class="nottickedoff">proveVarLLVMBlocks1 x ps _ [] =</span>
<span class="lineno"> 7550 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt; introConjM x</span>
<span class="lineno"> 7551 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7552 </span><span class="spaces"></span><span class="nottickedoff">-- If the offset, length, and shape of the top block matches one that we already</span>
<span class="lineno"> 7553 </span><span class="spaces"></span><span class="nottickedoff">-- have, just cast the rwmodality and lifetime and prove the remaining perms</span>
<span class="lineno"> 7554 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst (mb_bp:mb_bps)</span>
<span class="lineno"> 7555 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7556 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7557 </span><span class="spaces">  </span><span class="nottickedoff">, Just sh &lt;- partialSubst psubst $ mbLLVMBlockShape mb_bp</span>
<span class="lineno"> 7558 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (\case</span>
<span class="lineno"> 7559 </span><span class="spaces">                            </span><span class="nottickedoff">Perm_LLVMBlock bp -&gt;</span>
<span class="lineno"> 7560 </span><span class="spaces">                              </span><span class="nottickedoff">bvEq (llvmBlockOffset bp) off &amp;&amp;</span>
<span class="lineno"> 7561 </span><span class="spaces">                              </span><span class="nottickedoff">bvEq (llvmBlockLen bp) len &amp;&amp;</span>
<span class="lineno"> 7562 </span><span class="spaces">                              </span><span class="nottickedoff">llvmBlockShape bp == sh</span>
<span class="lineno"> 7563 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; False) ps</span>
<span class="lineno"> 7564 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMBlock bp &lt;- ps!!i =</span>
<span class="lineno"> 7565 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7566 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the memblock perm we chose to the top of the stack</span>
<span class="lineno"> 7567 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 7568 </span><span class="spaces">    </span><span class="nottickedoff">let ps' = deleteNth i ps in</span>
<span class="lineno"> 7569 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7570 </span><span class="spaces">    </span><span class="nottickedoff">-- Make the input block have the required modalities</span>
<span class="lineno"> 7571 </span><span class="spaces">    </span><span class="nottickedoff">equalizeBlockModalities x bp mb_bp &gt;&gt;&gt;= \bp' -&gt;</span>
<span class="lineno"> 7572 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7573 </span><span class="spaces">    </span><span class="nottickedoff">-- Duplicate and save the block permission if it is copyable</span>
<span class="lineno"> 7574 </span><span class="spaces">    </span><span class="nottickedoff">(if atomicPermIsCopyable (Perm_LLVMBlock bp') then</span>
<span class="lineno"> 7575 </span><span class="spaces">       </span><span class="nottickedoff">implCopyM x (ValPerm_LLVMBlock bp') &gt;&gt;&gt;</span>
<span class="lineno"> 7576 </span><span class="spaces">       </span><span class="nottickedoff">recombinePerm x (ValPerm_LLVMBlock bp')</span>
<span class="lineno"> 7577 </span><span class="spaces">     </span><span class="nottickedoff">else return ()) &gt;&gt;&gt;</span>
<span class="lineno"> 7578 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7579 </span><span class="spaces">    </span><span class="nottickedoff">-- Move it down below ps'</span>
<span class="lineno"> 7580 </span><span class="spaces">    </span><span class="nottickedoff">implSwapM x (ValPerm_Conj ps') x (ValPerm_LLVMBlock bp') &gt;&gt;&gt;</span>
<span class="lineno"> 7581 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7582 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively prove the remaining perms</span>
<span class="lineno"> 7583 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 7584 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks1&quot; x &gt;&gt;&gt;= \ps_out -&gt;</span>
<span class="lineno"> 7585 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7586 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, combine the one memblock perm we chose with the rest of them</span>
<span class="lineno"> 7587 </span><span class="spaces">    </span><span class="nottickedoff">implInsertConjM x (Perm_LLVMBlock bp') ps_out 0</span>
<span class="lineno"> 7588 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7589 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7590 </span><span class="spaces"></span><span class="nottickedoff">-- If the offset and length of the top block matches one that we already have on</span>
<span class="lineno"> 7591 </span><span class="spaces"></span><span class="nottickedoff">-- the left, but the left-hand permission has either a defined shape or a named</span>
<span class="lineno"> 7592 </span><span class="spaces"></span><span class="nottickedoff">-- shape with modalities, eliminate the left-hand block.</span>
<span class="lineno"> 7593 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst mb_bps_in@(mb_bp:_)</span>
<span class="lineno"> 7594 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7595 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7596 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex</span>
<span class="lineno"> 7597 </span><span class="spaces">    </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 7598 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMBlock bp</span>
<span class="lineno"> 7599 </span><span class="spaces">          </span><span class="nottickedoff">| PExpr_NamedShape _ _ nmsh _ &lt;- llvmBlockShape bp</span>
<span class="lineno"> 7600 </span><span class="spaces">          </span><span class="nottickedoff">, DefinedShapeBody _ &lt;- namedShapeBody nmsh -&gt;</span>
<span class="lineno"> 7601 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmBlockOffset bp) off &amp;&amp;</span>
<span class="lineno"> 7602 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmBlockLen bp) len</span>
<span class="lineno"> 7603 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7604 </span><span class="spaces">          </span><span class="nottickedoff">| PExpr_NamedShape maybe_rw maybe_l _ _ &lt;- llvmBlockShape bp</span>
<span class="lineno"> 7605 </span><span class="spaces">          </span><span class="nottickedoff">, isJust maybe_rw || isJust maybe_l -&gt;</span>
<span class="lineno"> 7606 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmBlockOffset bp) off &amp;&amp;</span>
<span class="lineno"> 7607 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmBlockLen bp) len</span>
<span class="lineno"> 7608 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7609 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; False) ps =</span>
<span class="lineno"> 7610 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7611 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst mb_bps_in</span>
<span class="lineno"> 7612 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7613 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7614 </span><span class="spaces"></span><span class="nottickedoff">-- If the offset and length of the top block matches one that we already have on</span>
<span class="lineno"> 7615 </span><span class="spaces"></span><span class="nottickedoff">-- the left, but the left-hand permission has an unneeded empty shape at the</span>
<span class="lineno"> 7616 </span><span class="spaces"></span><span class="nottickedoff">-- end, i.e., is of the form sh;emptysh where the natural length of sh is the</span>
<span class="lineno"> 7617 </span><span class="spaces"></span><span class="nottickedoff">-- length of the left-hand permission, remove that trailing empty shape</span>
<span class="lineno"> 7618 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst mb_bps_in@(mb_bp:_)</span>
<span class="lineno"> 7619 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7620 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7621 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex</span>
<span class="lineno"> 7622 </span><span class="spaces">    </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 7623 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMBlock bp</span>
<span class="lineno"> 7624 </span><span class="spaces">          </span><span class="nottickedoff">| PExpr_SeqShape sh1 PExpr_EmptyShape &lt;- llvmBlockShape bp</span>
<span class="lineno"> 7625 </span><span class="spaces">          </span><span class="nottickedoff">, Just len' &lt;- llvmShapeLength sh1 -&gt;</span>
<span class="lineno"> 7626 </span><span class="spaces">            </span><span class="nottickedoff">bvEq (llvmBlockOffset bp) off &amp;&amp;</span>
<span class="lineno"> 7627 </span><span class="spaces">            </span><span class="nottickedoff">bvEq (llvmBlockLen bp) len &amp;&amp;</span>
<span class="lineno"> 7628 </span><span class="spaces">            </span><span class="nottickedoff">bvEq len len'</span>
<span class="lineno"> 7629 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; False) ps =</span>
<span class="lineno"> 7630 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7631 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst mb_bps_in</span>
<span class="lineno"> 7632 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7633 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7634 </span><span class="spaces"></span><span class="nottickedoff">-- If there is a left-hand permission with empty shape whose range overlaps with</span>
<span class="lineno"> 7635 </span><span class="spaces"></span><span class="nottickedoff">-- but is not contained in that of mb_bp, split it into pieces wholly contained</span>
<span class="lineno"> 7636 </span><span class="spaces"></span><span class="nottickedoff">-- in or disjoint from the range of mb_bp; i.e., split it at the beginning</span>
<span class="lineno"> 7637 </span><span class="spaces"></span><span class="nottickedoff">-- and/or end of mb_bp. We exclude mb_bp with length 0 as a pathological edge</span>
<span class="lineno"> 7638 </span><span class="spaces"></span><span class="nottickedoff">-- case.</span>
<span class="lineno"> 7639 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst mb_bps_in@(mb_bp:_)</span>
<span class="lineno"> 7640 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7641 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7642 </span><span class="spaces">  </span><span class="nottickedoff">, rng &lt;- BVRange off len</span>
<span class="lineno"> 7643 </span><span class="spaces">  </span><span class="nottickedoff">, not (bvIsZero len)</span>
<span class="lineno"> 7644 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (\case</span>
<span class="lineno"> 7645 </span><span class="spaces">                            </span><span class="nottickedoff">Perm_LLVMBlock bp -&gt;</span>
<span class="lineno"> 7646 </span><span class="spaces">                              </span><span class="nottickedoff">llvmBlockShape bp == PExpr_EmptyShape &amp;&amp;</span>
<span class="lineno"> 7647 </span><span class="spaces">                              </span><span class="nottickedoff">bvRangesOverlap (llvmBlockRange bp) rng &amp;&amp;</span>
<span class="lineno"> 7648 </span><span class="spaces">                              </span><span class="nottickedoff">not (bvRangeSubset (llvmBlockRange bp) rng)</span>
<span class="lineno"> 7649 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; False) ps</span>
<span class="lineno"> 7650 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMBlock bp &lt;- ps!!i =</span>
<span class="lineno"> 7651 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 7652 </span><span class="spaces">    </span><span class="nottickedoff">-- If the end of mb_bp is contained in bp, split bp at the end of mb_bp,</span>
<span class="lineno"> 7653 </span><span class="spaces">    </span><span class="nottickedoff">-- otherwise split it at the beginning of mb_bp</span>
<span class="lineno"> 7654 </span><span class="spaces">    </span><span class="nottickedoff">let len1 = if bvInRange (bvAdd off len) (llvmBlockRange bp) then</span>
<span class="lineno"> 7655 </span><span class="spaces">                 </span><span class="nottickedoff">bvSub (bvAdd off len) (llvmBlockOffset bp)</span>
<span class="lineno"> 7656 </span><span class="spaces">               </span><span class="nottickedoff">else</span>
<span class="lineno"> 7657 </span><span class="spaces">                 </span><span class="nottickedoff">bvSub off (llvmBlockOffset bp) in</span>
<span class="lineno"> 7658 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_SplitLLVMBlockEmpty x bp len1) &gt;&gt;&gt;</span>
<span class="lineno"> 7659 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks1&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7660 </span><span class="spaces">    </span><span class="nottickedoff">implAppendConjsM x (deleteNth i ps) ps' &gt;&gt;&gt;</span>
<span class="lineno"> 7661 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x (deleteNth i ps ++ ps') psubst mb_bps_in</span>
<span class="lineno"> 7662 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7663 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7664 </span><span class="spaces"></span><span class="nottickedoff">-- If there is a left-hand permission whose range overlaps with but is not</span>
<span class="lineno"> 7665 </span><span class="spaces"></span><span class="nottickedoff">-- contained in that of mb_bp, eliminate it. Note that we exclude mb_bp with</span>
<span class="lineno"> 7666 </span><span class="spaces"></span><span class="nottickedoff">-- length 0 for this case, since eliminating on the left does not help prove</span>
<span class="lineno"> 7667 </span><span class="spaces"></span><span class="nottickedoff">-- these permissions.</span>
<span class="lineno"> 7668 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst mb_bps_in@(mb_bp:_)</span>
<span class="lineno"> 7669 </span><span class="spaces">  </span><span class="nottickedoff">| Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7670 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7671 </span><span class="spaces">  </span><span class="nottickedoff">, not (bvIsZero len)</span>
<span class="lineno"> 7672 </span><span class="spaces">  </span><span class="nottickedoff">, rng &lt;- BVRange off len</span>
<span class="lineno"> 7673 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (\case</span>
<span class="lineno"> 7674 </span><span class="spaces">                            </span><span class="nottickedoff">Perm_LLVMBlock bp -&gt;</span>
<span class="lineno"> 7675 </span><span class="spaces">                              </span><span class="nottickedoff">bvRangesOverlap (llvmBlockRange bp) rng &amp;&amp;</span>
<span class="lineno"> 7676 </span><span class="spaces">                              </span><span class="nottickedoff">not (bvRangeSubset (llvmBlockRange bp) rng)</span>
<span class="lineno"> 7677 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; False) ps =</span>
<span class="lineno"> 7678 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7679 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst mb_bps_in</span>
<span class="lineno"> 7680 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7681 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7682 </span><span class="spaces"></span><span class="nottickedoff">-- If none of the above cases match for stage 1, proceed to stage 2, which</span>
<span class="lineno"> 7683 </span><span class="spaces"></span><span class="nottickedoff">-- operates by induction on the shape</span>
<span class="lineno"> 7684 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks1 x ps psubst (mb_bp:mb_bps) =</span>
<span class="lineno"> 7685 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp (mbMatch $</span>
<span class="lineno"> 7686 </span><span class="spaces">                                         </span><span class="nottickedoff">mbLLVMBlockShape mb_bp) mb_bps</span></span>
<span class="lineno"> 7687 </span>
<span class="lineno"> 7688 </span>
<span class="lineno"> 7689 </span>-- | Stage 2 of 'proveVarLLVMBlocks'. See that comments on that function. The
<span class="lineno"> 7690 </span>-- 5th argument is the shape of the 4th argument.
<span class="lineno"> 7691 </span>proveVarLLVMBlocks2 ::
<span class="lineno"> 7692 </span>  (1 &lt;= w, KnownNat w, NuMatchingAny1 r) =&gt; ExprVar (LLVMPointerType w) -&gt;
<span class="lineno"> 7693 </span>  [AtomicPerm (LLVMPointerType w)] -&gt; PartialSubst vars -&gt;
<span class="lineno"> 7694 </span>  Mb vars (LLVMBlockPerm w) -&gt; MatchedMb vars (PermExpr (LLVMShapeType w)) -&gt;
<span class="lineno"> 7695 </span>  [Mb vars (LLVMBlockPerm w)] -&gt;
<span class="lineno"> 7696 </span>  ImplM vars s r (ps :&gt; LLVMPointerType w) (ps :&gt; LLVMPointerType w) ()
<span class="lineno"> 7697 </span>
<span class="lineno"> 7698 </span>-- If proving the empty shape for length 0, recursively prove everything else
<span class="lineno"> 7699 </span>-- and then use the empty introduction rule
<span class="lineno"> 7700 </span><span class="decl"><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp [nuMP| PExpr_EmptyShape |] mb_bps</span>
<span class="lineno"> 7701 </span><span class="spaces">  </span><span class="nottickedoff">| Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7702 </span><span class="spaces">  </span><span class="nottickedoff">, bvIsZero len =</span>
<span class="lineno"> 7703 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7704 </span><span class="spaces">    </span><span class="nottickedoff">-- Do the recursive call without the empty shape and remember what</span>
<span class="lineno"> 7705 </span><span class="spaces">    </span><span class="nottickedoff">-- permissions it proved</span>
<span class="lineno"> 7706 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 7707 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps_out -&gt;</span>
<span class="lineno"> 7708 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7709 </span><span class="spaces">    </span><span class="nottickedoff">-- Substitute into the required block perm and prove it with</span>
<span class="lineno"> 7710 </span><span class="spaces">    </span><span class="nottickedoff">-- SImpl_IntroLLVMBlockEmpty</span>
<span class="lineno"> 7711 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 7712 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: if the rwmodality or lifetime are still unset at this point, we</span>
<span class="lineno"> 7713 </span><span class="spaces">    </span><span class="nottickedoff">-- could set them to default values, but this will be a rare case</span>
<span class="lineno"> 7714 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlock&quot; &gt;&gt;&gt;= \bp -&gt;</span>
<span class="lineno"> 7715 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockEmpty x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 7716 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7717 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, recombine the resulting permission with the rest of them</span>
<span class="lineno"> 7718 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps_out 0</span>
<span class="lineno"> 7719 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7720 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7721 </span><span class="spaces"></span><span class="nottickedoff">-- If proving the empty shape otherwise, prove an arbitrary memblock permission,</span>
<span class="lineno"> 7722 </span><span class="spaces"></span><span class="nottickedoff">-- i.e., with shape y for evar y, and coerce it to the empty shape</span>
<span class="lineno"> 7723 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp [nuMP| PExpr_EmptyShape |] mb_bps =</span>
<span class="lineno"> 7724 </span><span class="spaces">  </span><span class="nottickedoff">-- Locally bind z_sh for the shape of the memblock perm and recurse</span>
<span class="lineno"> 7725 </span><span class="spaces">  </span><span class="nottickedoff">let mb_bp' =</span>
<span class="lineno"> 7726 </span><span class="spaces">        </span><span class="nottickedoff">mbCombine RL.typeCtxProxies $</span>
<span class="lineno"> 7727 </span><span class="spaces">        </span><span class="nottickedoff">mbMapCl $(mkClosed [| \bp -&gt; nu $ \z_sh -&gt;</span>
<span class="lineno"> 7728 </span><span class="spaces">                             </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_Var z_sh } |]) mb_bp in</span>
<span class="lineno"> 7729 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMBlocksExt1 x ps psubst mb_bp' mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 7730 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7731 </span><span class="spaces">  </span><span class="nottickedoff">-- Extract out the block perm we proved and coerce it to the empty shape</span>
<span class="lineno"> 7732 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps_out -&gt;</span>
<span class="lineno"> 7733 </span><span class="spaces">  </span><span class="nottickedoff">let (ps_out_hd, ps_out') = expectLengthAtLeastOne ps_out</span>
<span class="lineno"> 7734 </span><span class="spaces">      </span><span class="nottickedoff">bp = case ps_out_hd of</span>
<span class="lineno"> 7735 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMBlock bp_ -&gt; bp_</span>
<span class="lineno"> 7736 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected block permission&quot; in</span>
<span class="lineno"> 7737 </span><span class="spaces">  </span><span class="nottickedoff">implSplitSwapConjsM x ps_out 1 &gt;&gt;&gt;</span>
<span class="lineno"> 7738 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_CoerceLLVMBlockEmpty x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 7739 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7740 </span><span class="spaces">  </span><span class="nottickedoff">-- Finally, recombine the resulting permission with the rest of them</span>
<span class="lineno"> 7741 </span><span class="spaces">  </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock $</span>
<span class="lineno"> 7742 </span><span class="spaces">                         </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_EmptyShape }) ps_out' 0</span>
<span class="lineno"> 7743 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7744 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7745 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a memblock permission (with shape other than emptysh, as it does</span>
<span class="lineno"> 7746 </span><span class="spaces"></span><span class="nottickedoff">-- not match the above cases) whose length is longer than the natural length of</span>
<span class="lineno"> 7747 </span><span class="spaces"></span><span class="nottickedoff">-- its shape, prove the memblock with the natural length as well as an</span>
<span class="lineno"> 7748 </span><span class="spaces"></span><span class="nottickedoff">-- additional memblock with empty shape and then sequence them together.</span>
<span class="lineno"> 7749 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp _ mb_bps</span>
<span class="lineno"> 7750 </span><span class="spaces">  </span><span class="nottickedoff">| Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 7751 </span><span class="spaces">  </span><span class="nottickedoff">, mbLift $ fmap (maybe False (`bvLt` len)</span>
<span class="lineno"> 7752 </span><span class="spaces">                   </span><span class="nottickedoff">. llvmShapeLength . llvmBlockShape) mb_bp =</span>
<span class="lineno"> 7753 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7754 </span><span class="spaces">  </span><span class="nottickedoff">-- First, build the list of the correctly-sized perm + the empty shape one</span>
<span class="lineno"> 7755 </span><span class="spaces">  </span><span class="nottickedoff">let mb_bps' =</span>
<span class="lineno"> 7756 </span><span class="spaces">        </span><span class="nottickedoff">mbMapCl</span>
<span class="lineno"> 7757 </span><span class="spaces">        </span><span class="nottickedoff">$(mkClosed</span>
<span class="lineno"> 7758 </span><span class="spaces">          </span><span class="nottickedoff">[| \bp -&gt;</span>
<span class="lineno"> 7759 </span><span class="spaces">            </span><span class="nottickedoff">let sh_len = fromJust (llvmShapeLength (llvmBlockShape bp)) in</span>
<span class="lineno"> 7760 </span><span class="spaces">            </span><span class="nottickedoff">[bp { llvmBlockLen = sh_len },</span>
<span class="lineno"> 7761 </span><span class="spaces">             </span><span class="nottickedoff">bp { llvmBlockOffset = bvAdd (llvmBlockOffset bp) sh_len,</span>
<span class="lineno"> 7762 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) sh_len,</span>
<span class="lineno"> 7763 </span><span class="spaces">                  </span><span class="nottickedoff">llvmBlockShape = PExpr_EmptyShape }] |]) mb_bp in</span>
<span class="lineno"> 7764 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7765 </span><span class="spaces">  </span><span class="nottickedoff">-- Next, do the recursive call</span>
<span class="lineno"> 7766 </span><span class="spaces">  </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mbList mb_bps' ++ mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 7767 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7768 </span><span class="spaces">  </span><span class="nottickedoff">-- Move the correctly-sized perm + the empty shape one to the top of the</span>
<span class="lineno"> 7769 </span><span class="spaces">  </span><span class="nottickedoff">-- stack and sequence them, and then eliminate the empty shape at the end</span>
<span class="lineno"> 7770 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7771 </span><span class="spaces">  </span><span class="nottickedoff">let (bp1,bp2,ps'') = case ps' of</span>
<span class="lineno"> 7772 </span><span class="spaces">        </span><span class="nottickedoff">(Perm_LLVMBlock bp1_ : Perm_LLVMBlock bp2_ : ps''_) -&gt;</span>
<span class="lineno"> 7773 </span><span class="spaces">          </span><span class="nottickedoff">(bp1_,bp2_,ps''_)</span>
<span class="lineno"> 7774 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected two block permissions&quot;</span>
<span class="lineno"> 7775 </span><span class="spaces">      </span><span class="nottickedoff">len2 = llvmBlockLen bp2</span>
<span class="lineno"> 7776 </span><span class="spaces">      </span><span class="nottickedoff">bp_out = bp1 { llvmBlockLen = bvAdd (llvmBlockLen bp1) len2 } in</span>
<span class="lineno"> 7777 </span><span class="spaces">  </span><span class="nottickedoff">implSplitSwapConjsM x ps' 2 &gt;&gt;&gt;</span>
<span class="lineno"> 7778 </span><span class="spaces">  </span><span class="nottickedoff">implSplitConjsM x [Perm_LLVMBlock bp1, Perm_LLVMBlock bp2] 1 &gt;&gt;&gt;</span>
<span class="lineno"> 7779 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockSeq x bp1 len2 PExpr_EmptyShape) &gt;&gt;&gt;</span>
<span class="lineno"> 7780 </span><span class="spaces">  </span><span class="nottickedoff">implSimplM Proxy (SImpl_ElimLLVMBlockSeqEmpty x bp_out) &gt;&gt;&gt;</span>
<span class="lineno"> 7781 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7782 </span><span class="spaces">  </span><span class="nottickedoff">-- Finally, recombine the resulting permission with the rest of them</span>
<span class="lineno"> 7783 </span><span class="spaces">  </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp_out) ps'' 0</span>
<span class="lineno"> 7784 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7785 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7786 </span><span class="spaces"></span><span class="nottickedoff">-- For a named shape with modalities, prove it without the modalities first and</span>
<span class="lineno"> 7787 </span><span class="spaces"></span><span class="nottickedoff">-- then add the modalities</span>
<span class="lineno"> 7788 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7789 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_NamedShape mb_maybe_rw mb_maybe_l _ _ |] &lt;- mb_sh</span>
<span class="lineno"> 7790 </span><span class="spaces">  </span><span class="nottickedoff">, isJust (mbMaybe mb_maybe_rw) || isJust (mbMaybe mb_maybe_l) =</span>
<span class="lineno"> 7791 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7792 </span><span class="spaces">    </span><span class="nottickedoff">-- Recurse using the shape without the modalities</span>
<span class="lineno"> 7793 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' =</span>
<span class="lineno"> 7794 </span><span class="spaces">          </span><span class="nottickedoff">flip mbMapCl mb_bp</span>
<span class="lineno"> 7795 </span><span class="spaces">          </span><span class="nottickedoff">$(mkClosed</span>
<span class="lineno"> 7796 </span><span class="spaces">            </span><span class="nottickedoff">[| \bp -&gt; case llvmBlockShape bp of</span>
<span class="lineno"> 7797 </span><span class="spaces">                </span><span class="nottickedoff">PExpr_NamedShape maybe_rw maybe_l nmsh args</span>
<span class="lineno"> 7798 </span><span class="spaces">                  </span><span class="nottickedoff">| rw &lt;- fromMaybe (llvmBlockRW bp) maybe_rw</span>
<span class="lineno"> 7799 </span><span class="spaces">                  </span><span class="nottickedoff">, l &lt;- fromMaybe (llvmBlockLifetime bp) maybe_l -&gt;</span>
<span class="lineno"> 7800 </span><span class="spaces">                    </span><span class="nottickedoff">bp { llvmBlockRW = rw, llvmBlockLifetime = l,</span>
<span class="lineno"> 7801 </span><span class="spaces">                         </span><span class="nottickedoff">llvmBlockShape =</span>
<span class="lineno"> 7802 </span><span class="spaces">                           </span><span class="nottickedoff">PExpr_NamedShape Nothing Nothing nmsh args }</span>
<span class="lineno"> 7803 </span><span class="spaces">                </span><span class="nottickedoff">_ -&gt; error &quot;Unreachable!&quot; |]) in</span>
<span class="lineno"> 7804 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp' : mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 7805 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7806 </span><span class="spaces">    </span><span class="nottickedoff">-- Extract out the block perm we proved</span>
<span class="lineno"> 7807 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps_out -&gt;</span>
<span class="lineno"> 7808 </span><span class="spaces">    </span><span class="nottickedoff">let (_, ps_out') = expectLengthAtLeastOne ps_out in</span>
<span class="lineno"> 7809 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps_out 1 &gt;&gt;&gt;</span>
<span class="lineno"> 7810 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7811 </span><span class="spaces">    </span><span class="nottickedoff">-- Introduce the modalities</span>
<span class="lineno"> 7812 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlocks&quot; &gt;&gt;&gt;= \bp -&gt;</span>
<span class="lineno"> 7813 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockNamedMods x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 7814 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7815 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, recombine the resulting permission with the rest of them</span>
<span class="lineno"> 7816 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps_out' 0</span>
<span class="lineno"> 7817 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7818 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7819 </span><span class="spaces"></span><span class="nottickedoff">-- For a recursive named shape with an equality permission on the left that has</span>
<span class="lineno"> 7820 </span><span class="spaces"></span><span class="nottickedoff">-- the same offset and length, eliminate the equality permission, because it</span>
<span class="lineno"> 7821 </span><span class="spaces"></span><span class="nottickedoff">-- might expose an occurrence of the same recursive named shape on the left, and</span>
<span class="lineno"> 7822 </span><span class="spaces"></span><span class="nottickedoff">-- because eliminating it is necessary anyway (unless the recursive permission</span>
<span class="lineno"> 7823 </span><span class="spaces"></span><span class="nottickedoff">-- on the right unfolds to an equality shape, which should never be the case in</span>
<span class="lineno"> 7824 </span><span class="spaces"></span><span class="nottickedoff">-- practice)</span>
<span class="lineno"> 7825 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7826 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_NamedShape _ _ mb_nmsh _ |] &lt;- mb_sh</span>
<span class="lineno"> 7827 </span><span class="spaces">  </span><span class="nottickedoff">, mbNamedShapeIsRecursive mb_nmsh</span>
<span class="lineno"> 7828 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7829 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst $ mbLLVMBlockLen mb_bp</span>
<span class="lineno"> 7830 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex</span>
<span class="lineno"> 7831 </span><span class="spaces">    </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 7832 </span><span class="spaces">        </span><span class="nottickedoff">Perm_LLVMBlock bp</span>
<span class="lineno"> 7833 </span><span class="spaces">          </span><span class="nottickedoff">| PExpr_EqShape _ _ &lt;- llvmBlockShape bp -&gt;</span>
<span class="lineno"> 7834 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmBlockOffset bp) off &amp;&amp;</span>
<span class="lineno"> 7835 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmBlockLen bp) len</span>
<span class="lineno"> 7836 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; False) ps =</span>
<span class="lineno"> 7837 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7838 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst (mb_bp:mb_bps)</span>
<span class="lineno"> 7839 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7840 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7841 </span><span class="spaces"></span><span class="nottickedoff">-- For an unfoldable named shape, prove its unfolding first and then fold it</span>
<span class="lineno"> 7842 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7843 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_NamedShape _ _ mb_nmsh _ |] &lt;- mb_sh</span>
<span class="lineno"> 7844 </span><span class="spaces">  </span><span class="nottickedoff">, Just mb_bp' &lt;- mbUnfoldModalizeNamedShapeBlock mb_bp =</span>
<span class="lineno"> 7845 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7846 </span><span class="spaces">    </span><span class="nottickedoff">-- Recurse using the unfolded shape</span>
<span class="lineno"> 7847 </span><span class="spaces">    </span><span class="nottickedoff">(if mbNamedShapeIsRecursive mb_nmsh then implSetRecRecurseRightM</span>
<span class="lineno"> 7848 </span><span class="spaces">     </span><span class="nottickedoff">else return ()) &gt;&gt;&gt;</span>
<span class="lineno"> 7849 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp' : mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 7850 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7851 </span><span class="spaces">    </span><span class="nottickedoff">-- Extract out the block perm we proved</span>
<span class="lineno"> 7852 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps_out -&gt;</span>
<span class="lineno"> 7853 </span><span class="spaces">    </span><span class="nottickedoff">let (ps_out_hd, ps_out') = expectLengthAtLeastOne ps_out</span>
<span class="lineno"> 7854 </span><span class="spaces">        </span><span class="nottickedoff">bp = case ps_out_hd of</span>
<span class="lineno"> 7855 </span><span class="spaces">          </span><span class="nottickedoff">Perm_LLVMBlock bp_ -&gt; bp_</span>
<span class="lineno"> 7856 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected block permission&quot; in</span>
<span class="lineno"> 7857 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps_out 1 &gt;&gt;&gt;</span>
<span class="lineno"> 7858 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7859 </span><span class="spaces">    </span><span class="nottickedoff">-- Fold the named shape</span>
<span class="lineno"> 7860 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM (mbLLVMBlockShape mb_bp) &quot;proveVarLLVMBlocks&quot; &gt;&gt;&gt;= \sh -&gt;</span>
<span class="lineno"> 7861 </span><span class="spaces">    </span><span class="nottickedoff">let bp' = bp { llvmBlockShape = sh } in</span>
<span class="lineno"> 7862 </span><span class="spaces">    </span><span class="nottickedoff">implIntroLLVMBlockNamed x bp' &gt;&gt;&gt;</span>
<span class="lineno"> 7863 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7864 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, recombine the resulting permission with the rest of them</span>
<span class="lineno"> 7865 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp') ps_out' 0</span>
<span class="lineno"> 7866 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7867 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7868 </span><span class="spaces"></span><span class="nottickedoff">-- If proving an opaque named shape, the only way to prove the memblock</span>
<span class="lineno"> 7869 </span><span class="spaces"></span><span class="nottickedoff">-- permission is to have it on the left, but we don't have a memblock permission</span>
<span class="lineno"> 7870 </span><span class="spaces"></span><span class="nottickedoff">-- on the left with this exact offset, length, and shape, because it would have</span>
<span class="lineno"> 7871 </span><span class="spaces"></span><span class="nottickedoff">-- matched some previous case, so try to eliminate a memblock and recurse</span>
<span class="lineno"> 7872 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7873 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_NamedShape _ _ mb_nmsh _ |] &lt;- mb_sh</span>
<span class="lineno"> 7874 </span><span class="spaces">  </span><span class="nottickedoff">, FalseRepr &lt;- mbNamedShapeCanUnfoldRepr mb_nmsh</span>
<span class="lineno"> 7875 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7876 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (\case</span>
<span class="lineno"> 7877 </span><span class="spaces">                            </span><span class="nottickedoff">p@(Perm_LLVMBlock _) -&gt;</span>
<span class="lineno"> 7878 </span><span class="spaces">                              </span><span class="nottickedoff">isJust (llvmPermContainsOffset off p)</span>
<span class="lineno"> 7879 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; False) ps</span>
<span class="lineno"> 7880 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMBlock _ &lt;- ps!!i =</span>
<span class="lineno"> 7881 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7882 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst (mb_bp:mb_bps)</span>
<span class="lineno"> 7883 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7884 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7885 </span><span class="spaces"></span><span class="nottickedoff">-- If proving an equality shape eqsh(len,z) for evar z which has already been</span>
<span class="lineno"> 7886 </span><span class="spaces"></span><span class="nottickedoff">-- set, substitute for z and recurse</span>
<span class="lineno"> 7887 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7888 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_EqShape _ (PExpr_Var mb_z) |] &lt;- mb_sh</span>
<span class="lineno"> 7889 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 7890 </span><span class="spaces">  </span><span class="nottickedoff">, Just blk &lt;- psubstLookup psubst memb =</span>
<span class="lineno"> 7891 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' =</span>
<span class="lineno"> 7892 </span><span class="spaces">          </span><span class="nottickedoff">fmap (\bp -&gt;</span>
<span class="lineno"> 7893 </span><span class="spaces">                 </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 7894 </span><span class="spaces">                   </span><span class="nottickedoff">PExpr_EqShape len _ -&gt;</span>
<span class="lineno"> 7895 </span><span class="spaces">                     </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_EqShape len blk }</span>
<span class="lineno"> 7896 </span><span class="spaces">                   </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected eq shape&quot;) mb_bp in</span>
<span class="lineno"> 7897 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp' : mb_bps)</span>
<span class="lineno"> 7898 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7899 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7900 </span><span class="spaces"></span><span class="nottickedoff">-- If proving an equality shape eqsh(len,z) for unset evar z, prove any memblock</span>
<span class="lineno"> 7901 </span><span class="spaces"></span><span class="nottickedoff">-- perm with the given offset and length and eliminate it to an llvmblock with</span>
<span class="lineno"> 7902 </span><span class="spaces"></span><span class="nottickedoff">-- an equality shape</span>
<span class="lineno"> 7903 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7904 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_EqShape mb_len (PExpr_Var mb_z) |] &lt;- mb_sh</span>
<span class="lineno"> 7905 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 7906 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst mb_len</span>
<span class="lineno"> 7907 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb =</span>
<span class="lineno"> 7908 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7909 </span><span class="spaces">    </span><span class="nottickedoff">-- Locally bind z_sh for the shape of the memblock perm and recurse</span>
<span class="lineno"> 7910 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' =</span>
<span class="lineno"> 7911 </span><span class="spaces">          </span><span class="nottickedoff">mbCombine RL.typeCtxProxies $ flip mbMapCl mb_bp $</span>
<span class="lineno"> 7912 </span><span class="spaces">          </span><span class="nottickedoff">$(mkClosed [| \bp -&gt; nu $ \z_sh -&gt;</span>
<span class="lineno"> 7913 </span><span class="spaces">                       </span><span class="nottickedoff">bp { llvmBlockShape = PExpr_Var z_sh } |]) in</span>
<span class="lineno"> 7914 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocksExt1 x ps psubst mb_bp' mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 7915 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7916 </span><span class="spaces">    </span><span class="nottickedoff">-- Extract out the block perm we proved</span>
<span class="lineno"> 7917 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps_out -&gt;</span>
<span class="lineno"> 7918 </span><span class="spaces">    </span><span class="nottickedoff">let (ps_out_hd, ps_out') = expectLengthAtLeastOne ps_out</span>
<span class="lineno"> 7919 </span><span class="spaces">        </span><span class="nottickedoff">bp = case ps_out_hd of</span>
<span class="lineno"> 7920 </span><span class="spaces">          </span><span class="nottickedoff">Perm_LLVMBlock bp_ -&gt; bp_</span>
<span class="lineno"> 7921 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected block perm&quot; in</span>
<span class="lineno"> 7922 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps_out 1 &gt;&gt;&gt;</span>
<span class="lineno"> 7923 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7924 </span><span class="spaces">    </span><span class="nottickedoff">-- Eliminate that block perm to have an equality shape, and set z to the</span>
<span class="lineno"> 7925 </span><span class="spaces">    </span><span class="nottickedoff">-- resulting block</span>
<span class="lineno"> 7926 </span><span class="spaces">    </span><span class="nottickedoff">implElimLLVMBlockToEq x bp &gt;&gt;&gt;= \y_blk -&gt;</span>
<span class="lineno"> 7927 </span><span class="spaces">    </span><span class="nottickedoff">let bp' = bp { llvmBlockShape = PExpr_EqShape len $ PExpr_Var y_blk } in</span>
<span class="lineno"> 7928 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb (PExpr_Var y_blk) &gt;&gt;&gt;</span>
<span class="lineno"> 7929 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7930 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, recombine the resulting permission with the rest of them</span>
<span class="lineno"> 7931 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp') ps_out' 0</span>
<span class="lineno"> 7932 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7933 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7934 </span><span class="spaces"></span><span class="nottickedoff">-- If z is a free variable, the only way to prove the memblock permission is to</span>
<span class="lineno"> 7935 </span><span class="spaces"></span><span class="nottickedoff">-- have it on the left, but we don't have a memblock permission on the left with</span>
<span class="lineno"> 7936 </span><span class="spaces"></span><span class="nottickedoff">-- this exactly offset, length, and shape, because it would have matched the</span>
<span class="lineno"> 7937 </span><span class="spaces"></span><span class="nottickedoff">-- first case above, so try to eliminate a memblock and recurse</span>
<span class="lineno"> 7938 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7939 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_EqShape _ (PExpr_Var mb_z) |] &lt;- mb_sh</span>
<span class="lineno"> 7940 </span><span class="spaces">  </span><span class="nottickedoff">, Right _ &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 7941 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp</span>
<span class="lineno"> 7942 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (\case</span>
<span class="lineno"> 7943 </span><span class="spaces">                            </span><span class="nottickedoff">p@(Perm_LLVMBlock _) -&gt;</span>
<span class="lineno"> 7944 </span><span class="spaces">                              </span><span class="nottickedoff">isJust (llvmPermContainsOffset off p)</span>
<span class="lineno"> 7945 </span><span class="spaces">                            </span><span class="nottickedoff">_ -&gt; False) ps</span>
<span class="lineno"> 7946 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMBlock _ &lt;- ps!!i =</span>
<span class="lineno"> 7947 </span><span class="spaces">    </span><span class="nottickedoff">implElimAppendIthLLVMBlock x ps i &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7948 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst (mb_bp:mb_bps)</span>
<span class="lineno"> 7949 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7950 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7951 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a pointer shape, prove the 'llvmBlockPtrShapeUnfold' permission,</span>
<span class="lineno"> 7952 </span><span class="spaces"></span><span class="nottickedoff">-- assuming it is defined</span>
<span class="lineno"> 7953 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7954 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_PtrShape _ _ _ |] &lt;- mb_sh</span>
<span class="lineno"> 7955 </span><span class="spaces">  </span><span class="nottickedoff">, [nuP| Just mb_bp' |] &lt;- mbMapCl $(mkClosed</span>
<span class="lineno"> 7956 </span><span class="spaces">                                      </span><span class="nottickedoff">[| llvmBlockPtrShapeUnfold |]) mb_bp =</span>
<span class="lineno"> 7957 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7958 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively prove the required field permission and all the other block</span>
<span class="lineno"> 7959 </span><span class="spaces">    </span><span class="nottickedoff">-- permissions</span>
<span class="lineno"> 7960 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp':mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 7961 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7962 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the pointer permission we proved to the top of the stack</span>
<span class="lineno"> 7963 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7964 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps' 0 &gt;&gt;&gt;</span>
<span class="lineno"> 7965 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7966 </span><span class="spaces">    </span><span class="nottickedoff">-- Use the SImpl_IntroLLVMBlockPtr rule to prove the required memblock perm</span>
<span class="lineno"> 7967 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlocks&quot; &gt;&gt;&gt;= \bp -&gt;</span>
<span class="lineno"> 7968 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockPtr x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 7969 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7970 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, move the memblock perm we proved back into position</span>
<span class="lineno"> 7971 </span><span class="spaces">    </span><span class="nottickedoff">let (_, ps'') = expectLengthAtLeastOne ps' in</span>
<span class="lineno"> 7972 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps'' 0</span>
<span class="lineno"> 7973 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7974 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7975 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a field shape, prove the remaining blocks and then prove the</span>
<span class="lineno"> 7976 </span><span class="spaces"></span><span class="nottickedoff">-- corresponding field permission</span>
<span class="lineno"> 7977 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 7978 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: instead of proving the field for this field shape after the remaining</span>
<span class="lineno"> 7979 </span><span class="spaces"></span><span class="nottickedoff">-- shapes, proveVarLLVMBlocks should collect all field and array shapes that</span>
<span class="lineno"> 7980 </span><span class="spaces"></span><span class="nottickedoff">-- need to be proved and bottom out with a call to proveVarConjImpl, so that</span>
<span class="lineno"> 7981 </span><span class="spaces"></span><span class="nottickedoff">-- each of these shapes is proved in the proper order to make sure all variables</span>
<span class="lineno"> 7982 </span><span class="spaces"></span><span class="nottickedoff">-- get determined. The current approach just happens to work because the only</span>
<span class="lineno"> 7983 </span><span class="spaces"></span><span class="nottickedoff">-- undetermined variables in shapes coming from Rust types most of the time are</span>
<span class="lineno"> 7984 </span><span class="spaces"></span><span class="nottickedoff">-- the lengths of slices, which are stored after the array.</span>
<span class="lineno"> 7985 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 7986 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_FieldShape (LLVMFieldShape mb_p) |] &lt;- mb_sh</span>
<span class="lineno"> 7987 </span><span class="spaces">  </span><span class="nottickedoff">, sz &lt;- mbExprLLVMTypeWidth mb_p</span>
<span class="lineno"> 7988 </span><span class="spaces">  </span><span class="nottickedoff">, [nuP| Just mb_fp |] &lt;- mbMapCl ($(mkClosed [| llvmBlockPermToField |])</span>
<span class="lineno"> 7989 </span><span class="spaces">                                    </span><span class="nottickedoff">`clApply` toClosed sz) mb_bp =</span>
<span class="lineno"> 7990 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7991 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively prove the remaining block permissions</span>
<span class="lineno"> 7992 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 7993 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 7994 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 7995 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove the corresponding field permission</span>
<span class="lineno"> 7996 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt x (mbValPerm_LLVMField mb_fp) &gt;&gt;&gt;</span>
<span class="lineno"> 7997 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 7998 </span><span class="spaces">      </span><span class="nottickedoff">(ValPerm_LLVMField fp) -&gt;</span>
<span class="lineno"> 7999 </span><span class="spaces">        </span><span class="nottickedoff">-- Finally, convert the field perm to a block and move it into position</span>
<span class="lineno"> 8000 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockField x fp) &gt;&gt;&gt;</span>
<span class="lineno"> 8001 </span><span class="spaces">        </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock $ llvmFieldPermToBlock fp) ps' 0</span>
<span class="lineno"> 8002 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected field permission&quot;</span>
<span class="lineno"> 8003 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8004 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8005 </span><span class="spaces"></span><span class="nottickedoff">-- If proving an array shape, prove the remaining blocks and then prove the</span>
<span class="lineno"> 8006 </span><span class="spaces"></span><span class="nottickedoff">-- corresponding array permission</span>
<span class="lineno"> 8007 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 8008 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: see above FIXME on proving field shapes</span>
<span class="lineno"> 8009 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8010 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_ArrayShape _ _ _ |] &lt;- mb_sh =</span>
<span class="lineno"> 8011 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively prove the remaining block permissions</span>
<span class="lineno"> 8012 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 8013 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8014 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8015 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove the corresponding array permission</span>
<span class="lineno"> 8016 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt x (mbMapCl $(mkClosed [| ValPerm_LLVMArray . fromJust .</span>
<span class="lineno"> 8017 </span><span class="spaces">                                             </span><span class="nottickedoff">llvmBlockPermToArray |]) mb_bp) &gt;&gt;&gt;</span>
<span class="lineno"> 8018 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 8019 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_LLVMArray ap -&gt;</span>
<span class="lineno"> 8020 </span><span class="spaces">        </span><span class="nottickedoff">-- Finally, convert the array perm to a block and move it into position</span>
<span class="lineno"> 8021 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockArray x ap) &gt;&gt;&gt;</span>
<span class="lineno"> 8022 </span><span class="spaces">        </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock $ fromJust $</span>
<span class="lineno"> 8023 </span><span class="spaces">                               </span><span class="nottickedoff">llvmArrayPermToBlock ap) ps' 0</span>
<span class="lineno"> 8024 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected array permission&quot;</span>
<span class="lineno"> 8025 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8026 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a tuple shape, prove the contents of the tuple and add the tuple</span>
<span class="lineno"> 8027 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8028 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_TupShape _ |] &lt;- mb_sh =</span>
<span class="lineno"> 8029 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8030 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively call proveVarLLVMBlocks with sh in place of tuplesh(sh)</span>
<span class="lineno"> 8031 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' = mbMapCl $(mkClosed</span>
<span class="lineno"> 8032 </span><span class="spaces">                           </span><span class="nottickedoff">[| \bp -&gt;</span>
<span class="lineno"> 8033 </span><span class="spaces">                             </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 8034 </span><span class="spaces">                               </span><span class="nottickedoff">PExpr_TupShape sh -&gt;</span>
<span class="lineno"> 8035 </span><span class="spaces">                                 </span><span class="nottickedoff">bp { llvmBlockShape = sh }</span>
<span class="lineno"> 8036 </span><span class="spaces">                               </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected tuple shape&quot;</span>
<span class="lineno"> 8037 </span><span class="spaces">                            </span><span class="nottickedoff">|]) mb_bp in</span>
<span class="lineno"> 8038 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp':mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 8039 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8040 </span><span class="spaces">    </span><span class="nottickedoff">-- Extract the sh permission from the top of the stack and tuple it</span>
<span class="lineno"> 8041 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8042 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps' 0 &gt;&gt;&gt;</span>
<span class="lineno"> 8043 </span><span class="spaces">    </span><span class="nottickedoff">let (ps_hd', ps'') = expectLengthAtLeastOne ps'</span>
<span class="lineno"> 8044 </span><span class="spaces">        </span><span class="nottickedoff">bp = case ps_hd' of</span>
<span class="lineno"> 8045 </span><span class="spaces">          </span><span class="nottickedoff">Perm_LLVMBlock bp_ -&gt; bp_</span>
<span class="lineno"> 8046 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; panic &quot;proveVarLLVMBlocks2&quot; [&quot;expected block permission&quot;]</span>
<span class="lineno"> 8047 </span><span class="spaces">        </span><span class="nottickedoff">sh = llvmBlockShape bp in</span>
<span class="lineno"> 8048 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockTuple x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 8049 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8050 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, put the new tuplesh(sh) permission back in place</span>
<span class="lineno"> 8051 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock</span>
<span class="lineno"> 8052 </span><span class="spaces">                           </span><span class="nottickedoff">(bp { llvmBlockShape = PExpr_TupShape sh }))</span>
<span class="lineno"> 8053 </span><span class="spaces">                        </span><span class="nottickedoff">ps'' 0</span>
<span class="lineno"> 8054 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8055 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a sequence shape with an unneeded empty shape, i.e., of the form</span>
<span class="lineno"> 8056 </span><span class="spaces"></span><span class="nottickedoff">-- sh1;emptysh where the length of sh1 equals the entire length of the required</span>
<span class="lineno"> 8057 </span><span class="spaces"></span><span class="nottickedoff">-- memblock permission, then prove sh1 by itself and then add the empty shape</span>
<span class="lineno"> 8058 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8059 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_SeqShape _ PExpr_EmptyShape |] &lt;- mb_sh</span>
<span class="lineno"> 8060 </span><span class="spaces">  </span><span class="nottickedoff">, mbLift $ mbMapCl $(mkClosed</span>
<span class="lineno"> 8061 </span><span class="spaces">                       </span><span class="nottickedoff">[| \bp -&gt;</span>
<span class="lineno"> 8062 </span><span class="spaces">                         </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 8063 </span><span class="spaces">                           </span><span class="nottickedoff">PExpr_SeqShape sh1 _ -&gt;</span>
<span class="lineno"> 8064 </span><span class="spaces">                             </span><span class="nottickedoff">bvEq (llvmBlockLen bp) (fromJust $</span>
<span class="lineno"> 8065 </span><span class="spaces">                                                     </span><span class="nottickedoff">llvmShapeLength sh1)</span>
<span class="lineno"> 8066 </span><span class="spaces">                           </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected seq shape&quot;</span>
<span class="lineno"> 8067 </span><span class="spaces">                        </span><span class="nottickedoff">|]) mb_bp =</span>
<span class="lineno"> 8068 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively call proveVarLLVMBlocks with sh1 in place of sh1;emptysh</span>
<span class="lineno"> 8069 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' = mbMapCl $(mkClosed</span>
<span class="lineno"> 8070 </span><span class="spaces">                           </span><span class="nottickedoff">[| \bp -&gt;</span>
<span class="lineno"> 8071 </span><span class="spaces">                             </span><span class="nottickedoff">case llvmBlockShape bp of</span>
<span class="lineno"> 8072 </span><span class="spaces">                               </span><span class="nottickedoff">PExpr_SeqShape sh1 _ -&gt;</span>
<span class="lineno"> 8073 </span><span class="spaces">                                 </span><span class="nottickedoff">bp { llvmBlockShape = sh1 }</span>
<span class="lineno"> 8074 </span><span class="spaces">                               </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected seq shape&quot;</span>
<span class="lineno"> 8075 </span><span class="spaces">                            </span><span class="nottickedoff">|]) mb_bp in</span>
<span class="lineno"> 8076 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp':mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 8077 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8078 </span><span class="spaces">    </span><span class="nottickedoff">-- Extract the sh1 permission from the top of the stack and sequence an</span>
<span class="lineno"> 8079 </span><span class="spaces">    </span><span class="nottickedoff">-- empty shape onto the end of it</span>
<span class="lineno"> 8080 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8081 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps' 0 &gt;&gt;&gt;</span>
<span class="lineno"> 8082 </span><span class="spaces">    </span><span class="nottickedoff">let (ps_hd', ps'') = expectLengthAtLeastOne ps'</span>
<span class="lineno"> 8083 </span><span class="spaces">        </span><span class="nottickedoff">bp = case ps_hd' of</span>
<span class="lineno"> 8084 </span><span class="spaces">          </span><span class="nottickedoff">Perm_LLVMBlock bp_ -&gt; bp_</span>
<span class="lineno"> 8085 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected block permission&quot;</span>
<span class="lineno"> 8086 </span><span class="spaces">        </span><span class="nottickedoff">sh1 = llvmBlockShape bp in</span>
<span class="lineno"> 8087 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockSeqEmpty x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 8088 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8089 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, put the new sh1;emptysh permission back in place</span>
<span class="lineno"> 8090 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock</span>
<span class="lineno"> 8091 </span><span class="spaces">                           </span><span class="nottickedoff">(bp { llvmBlockShape =</span>
<span class="lineno"> 8092 </span><span class="spaces">                                   </span><span class="nottickedoff">PExpr_SeqShape sh1 PExpr_EmptyShape }))</span>
<span class="lineno"> 8093 </span><span class="spaces">                        </span><span class="nottickedoff">ps'' 0</span>
<span class="lineno"> 8094 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8095 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8096 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a sequence shape otherwise, prove the two shapes and combine them;</span>
<span class="lineno"> 8097 </span><span class="spaces"></span><span class="nottickedoff">-- this requires the first shape to have a well-defined length</span>
<span class="lineno"> 8098 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8099 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_SeqShape mb_sh1 _ |] &lt;- mb_sh</span>
<span class="lineno"> 8100 </span><span class="spaces">  </span><span class="nottickedoff">, mbLift $ mbMapCl $(mkClosed [| isJust . llvmShapeLength |]) mb_sh1 =</span>
<span class="lineno"> 8101 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8102 </span><span class="spaces">    </span><span class="nottickedoff">-- Add the two shapes to mb_bps and recursively call proveVarLLVMBlocks</span>
<span class="lineno"> 8103 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bps12 =</span>
<span class="lineno"> 8104 </span><span class="spaces">          </span><span class="nottickedoff">mbMapCl</span>
<span class="lineno"> 8105 </span><span class="spaces">          </span><span class="nottickedoff">$(mkClosed [| \bp -&gt;</span>
<span class="lineno"> 8106 </span><span class="spaces">                       </span><span class="nottickedoff">let (sh1,sh2) = case llvmBlockShape bp of</span>
<span class="lineno"> 8107 </span><span class="spaces">                             </span><span class="nottickedoff">PExpr_SeqShape sh1_ sh2_ -&gt; (sh1_,sh2_)</span>
<span class="lineno"> 8108 </span><span class="spaces">                             </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected seq shape&quot; in</span>
<span class="lineno"> 8109 </span><span class="spaces">                       </span><span class="nottickedoff">let len1 = fromJust (llvmShapeLength sh1) in</span>
<span class="lineno"> 8110 </span><span class="spaces">                       </span><span class="nottickedoff">[bp { llvmBlockLen = len1, llvmBlockShape = sh1 },</span>
<span class="lineno"> 8111 </span><span class="spaces">                        </span><span class="nottickedoff">bp { llvmBlockOffset = bvAdd (llvmBlockOffset bp) len1,</span>
<span class="lineno"> 8112 </span><span class="spaces">                             </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) len1,</span>
<span class="lineno"> 8113 </span><span class="spaces">                             </span><span class="nottickedoff">llvmBlockShape = sh2 }] |])</span>
<span class="lineno"> 8114 </span><span class="spaces">          </span><span class="nottickedoff">mb_bp in</span>
<span class="lineno"> 8115 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mbList mb_bps12 ++ mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 8116 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8117 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the block permissions we proved to the top of the stack</span>
<span class="lineno"> 8118 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8119 </span><span class="spaces">    </span><span class="nottickedoff">let (bp1,bp2,ps'') =</span>
<span class="lineno"> 8120 </span><span class="spaces">          </span><span class="nottickedoff">(case ps' of</span>
<span class="lineno"> 8121 </span><span class="spaces">              </span><span class="nottickedoff">(Perm_LLVMBlock bp1_ : Perm_LLVMBlock bp2_ : ps''_) -&gt;</span>
<span class="lineno"> 8122 </span><span class="spaces">                </span><span class="nottickedoff">(bp1_,bp2_,ps''_)</span>
<span class="lineno"> 8123 </span><span class="spaces">              </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected 2 block permissions&quot;)</span>
<span class="lineno"> 8124 </span><span class="spaces">        </span><span class="nottickedoff">len2 = llvmBlockLen bp2</span>
<span class="lineno"> 8125 </span><span class="spaces">        </span><span class="nottickedoff">sh2 = llvmBlockShape bp2 in</span>
<span class="lineno"> 8126 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps' 2 &gt;&gt;&gt;</span>
<span class="lineno"> 8127 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8128 </span><span class="spaces">    </span><span class="nottickedoff">-- Use the SImpl_IntroLLVMBlockSeq rule combine them into one memblock perm</span>
<span class="lineno"> 8129 </span><span class="spaces">    </span><span class="nottickedoff">implSplitConjsM x [Perm_LLVMBlock bp1, Perm_LLVMBlock bp2] 1 &gt;&gt;&gt;</span>
<span class="lineno"> 8130 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockSeq x bp1 len2 sh2) &gt;&gt;&gt;</span>
<span class="lineno"> 8131 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8132 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, move the memblock perm we proved back into position</span>
<span class="lineno"> 8133 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlock&quot; &gt;&gt;&gt;= \bp -&gt;</span>
<span class="lineno"> 8134 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps'' 0</span>
<span class="lineno"> 8135 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8136 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8137 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a tagged union shape, first prove an equality permission for the</span>
<span class="lineno"> 8138 </span><span class="spaces"></span><span class="nottickedoff">-- tag and then use that equality permission to</span>
<span class="lineno"> 8139 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp _ mb_bps</span>
<span class="lineno"> 8140 </span><span class="spaces">  </span><span class="nottickedoff">| Just [nuP| SomeTaggedUnionShape mb_tag_u |] &lt;- mbLLVMBlockToTaggedUnion mb_bp</span>
<span class="lineno"> 8141 </span><span class="spaces">  </span><span class="nottickedoff">, mb_shs &lt;- mbTaggedUnionDisjs mb_tag_u</span>
<span class="lineno"> 8142 </span><span class="spaces">  </span><span class="nottickedoff">, mb_tag_fp &lt;- mbTaggedUnionExTagPerm mb_bp</span>
<span class="lineno"> 8143 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst $ mbLLVMBlockOffset mb_bp =</span>
<span class="lineno"> 8144 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8145 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove permission x:ptr((R,off) |-&gt; eq(z)) with existential variable z to</span>
<span class="lineno"> 8146 </span><span class="spaces">    </span><span class="nottickedoff">-- get the tag value for the tagged union, then take it off the stack</span>
<span class="lineno"> 8147 </span><span class="spaces">    </span><span class="nottickedoff">withExtVarsM (proveVarLLVMField x ps off mb_tag_fp) &gt;&gt;&gt;= \((), e_tag) -&gt;</span>
<span class="lineno"> 8148 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \p' -&gt;</span>
<span class="lineno"> 8149 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x p' &gt;&gt;&gt;</span>
<span class="lineno"> 8150 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8151 </span><span class="spaces">    </span><span class="nottickedoff">-- Find the disjunct corresponding to e_tag, if there is one; if e_tag is</span>
<span class="lineno"> 8152 </span><span class="spaces">    </span><span class="nottickedoff">-- known to be different from all possible tags, we can fail right away;</span>
<span class="lineno"> 8153 </span><span class="spaces">    </span><span class="nottickedoff">-- otherwise, we don't know which disjunct to use, so return each of them in</span>
<span class="lineno"> 8154 </span><span class="spaces">    </span><span class="nottickedoff">-- turn, combining them with implCatchM</span>
<span class="lineno"> 8155 </span><span class="spaces">    </span><span class="nottickedoff">(getEqualsExpr e_tag &gt;&gt;&gt;= \case</span>
<span class="lineno"> 8156 </span><span class="spaces">        </span><span class="nottickedoff">(bvMatchConst -&gt; Just tag_bv)</span>
<span class="lineno"> 8157 </span><span class="spaces">          </span><span class="nottickedoff">| Just i &lt;- mbFindTaggedUnionIndex tag_bv mb_tag_u -&gt; return i</span>
<span class="lineno"> 8158 </span><span class="spaces">        </span><span class="nottickedoff">(bvMatchConst -&gt; Just _) -&gt;</span>
<span class="lineno"> 8159 </span><span class="spaces">          </span><span class="nottickedoff">implFailVarM</span>
<span class="lineno"> 8160 </span><span class="spaces">          </span><span class="nottickedoff">&quot;proveVarLLVMBlock (tag does not match any in disjuctive shape)&quot;</span>
<span class="lineno"> 8161 </span><span class="spaces">          </span><span class="nottickedoff">x (ValPerm_Conj ps) (mbValPerm_LLVMBlock mb_bp)</span>
<span class="lineno"> 8162 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 8163 </span><span class="spaces">          </span><span class="nottickedoff">let len =</span>
<span class="lineno"> 8164 </span><span class="spaces">                </span><span class="nottickedoff">mbLift $ mbMapCl $(mkClosed [| length .</span>
<span class="lineno"> 8165 </span><span class="spaces">                                             </span><span class="nottickedoff">taggedUnionDisjs |]) mb_tag_u in</span>
<span class="lineno"> 8166 </span><span class="spaces">          </span><span class="nottickedoff">foldr1 (implCatchM &quot;proveVarLLVMBlocks2&quot;</span>
<span class="lineno"> 8167 </span><span class="spaces">                  </span><span class="nottickedoff">(ColonPair x (mb_bp:mb_bps))) $</span>
<span class="lineno"> 8168 </span><span class="spaces">          </span><span class="nottickedoff">map return [0..len-1]) &gt;&gt;&gt;= \i -&gt;</span>
<span class="lineno"> 8169 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8170 </span><span class="spaces">    </span><span class="nottickedoff">-- Get the permissions we now have for x and push them back to the top of</span>
<span class="lineno"> 8171 </span><span class="spaces">    </span><span class="nottickedoff">-- the stack</span>
<span class="lineno"> 8172 </span><span class="spaces">    </span><span class="nottickedoff">getAtomicPerms x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8173 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 8174 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8175 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively prove the ith disjunct and all the rest of mb_bps</span>
<span class="lineno"> 8176 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps' psubst (mbTaggedUnionNthDisjBlock i mb_bp</span>
<span class="lineno"> 8177 </span><span class="spaces">                                     </span><span class="nottickedoff">: mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 8178 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8179 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the block permission with shape mb_sh to the top of the stack</span>
<span class="lineno"> 8180 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps'' -&gt;</span>
<span class="lineno"> 8181 </span><span class="spaces">    </span><span class="nottickedoff">implExtractSwapConjM x ps'' 0 &gt;&gt;&gt;</span>
<span class="lineno"> 8182 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8183 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, weaken the block permission to be the desired tagged union</span>
<span class="lineno"> 8184 </span><span class="spaces">    </span><span class="nottickedoff">-- shape, and move it back into position</span>
<span class="lineno"> 8185 </span><span class="spaces">    </span><span class="nottickedoff">let (_, ps''') = expectLengthAtLeastOne ps'' in</span>
<span class="lineno"> 8186 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_shs &quot;proveVarLLVMBlock&quot; &gt;&gt;&gt;= \shs -&gt;</span>
<span class="lineno"> 8187 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlock&quot; &gt;&gt;&gt;= \bp -&gt;</span>
<span class="lineno"> 8188 </span><span class="spaces">    </span><span class="nottickedoff">implIntroOrShapeMultiM x bp shs i &gt;&gt;&gt;</span>
<span class="lineno"> 8189 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps''' 0</span>
<span class="lineno"> 8190 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8191 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8192 </span><span class="spaces"></span><span class="nottickedoff">-- If proving a disjunctive shape, try to prove one of the disjuncts</span>
<span class="lineno"> 8193 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8194 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_OrShape _ _ |] &lt;- mb_sh =</span>
<span class="lineno"> 8195 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8196 </span><span class="spaces">    </span><span class="nottickedoff">-- Build a computation that tries returning True here, and if that fails</span>
<span class="lineno"> 8197 </span><span class="spaces">    </span><span class="nottickedoff">-- returns False; True is used for sh1 while False is used for sh2</span>
<span class="lineno"> 8198 </span><span class="spaces">    </span><span class="nottickedoff">implCatchM &quot;proveVarLLVMBlocks2&quot; (ColonPair x (mb_bp:mb_bps))</span>
<span class="lineno"> 8199 </span><span class="spaces">               </span><span class="nottickedoff">(pure True) (pure False) &gt;&gt;&gt;= \is_case1 -&gt;</span>
<span class="lineno"> 8200 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8201 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove the chosen shape by recursively calling proveVarLLVMBlocks</span>
<span class="lineno"> 8202 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' = mbDisjBlockToSubShape is_case1 mb_bp in</span>
<span class="lineno"> 8203 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp' : mb_bps) &gt;&gt;&gt;</span>
<span class="lineno"> 8204 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8205 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the block permission we proved to the top of the stack</span>
<span class="lineno"> 8206 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8207 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps' 1 &gt;&gt;&gt;</span>
<span class="lineno"> 8208 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8209 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove the disjunction of the two memblock permissions</span>
<span class="lineno"> 8210 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlock&quot; &gt;&gt;&gt;= \bp -&gt;</span>
<span class="lineno"> 8211 </span><span class="spaces">    </span><span class="nottickedoff">let (sh1, sh2) = case llvmBlockShape bp of</span>
<span class="lineno"> 8212 </span><span class="spaces">          </span><span class="nottickedoff">PExpr_OrShape sh1' sh2' -&gt; (sh1',sh2')</span>
<span class="lineno"> 8213 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: expected or shape&quot; in</span>
<span class="lineno"> 8214 </span><span class="spaces">    </span><span class="nottickedoff">let introM = if is_case1 then introOrLM else introOrRM in</span>
<span class="lineno"> 8215 </span><span class="spaces">    </span><span class="nottickedoff">introM x (ValPerm_LLVMBlock $ bp { llvmBlockShape = sh1 })</span>
<span class="lineno"> 8216 </span><span class="spaces">    </span><span class="nottickedoff">(ValPerm_LLVMBlock $ bp { llvmBlockShape = sh2 }) &gt;&gt;&gt;</span>
<span class="lineno"> 8217 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8218 </span><span class="spaces">    </span><span class="nottickedoff">-- Now coerce the disjunctive permission on top of the stack to an or shape,</span>
<span class="lineno"> 8219 </span><span class="spaces">    </span><span class="nottickedoff">-- and move it back into position</span>
<span class="lineno"> 8220 </span><span class="spaces">    </span><span class="nottickedoff">let (_, ps'') = expectLengthAtLeastOne ps' in</span>
<span class="lineno"> 8221 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockOr</span>
<span class="lineno"> 8222 </span><span class="spaces">                      </span><span class="nottickedoff">x (bp { llvmBlockShape = sh1 }) sh2) &gt;&gt;&gt;</span>
<span class="lineno"> 8223 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps'' 0</span>
<span class="lineno"> 8224 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8225 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8226 </span><span class="spaces"></span><span class="nottickedoff">-- If proving an existential shape, introduce an evar and recurse</span>
<span class="lineno"> 8227 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8228 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_ExShape mb_mb_sh |] &lt;- mb_sh</span>
<span class="lineno"> 8229 </span><span class="spaces">  </span><span class="nottickedoff">, (_ :: Mb ctx (Binding a (PermExpr (LLVMShapeType w)))) &lt;- mb_mb_sh</span>
<span class="lineno"> 8230 </span><span class="spaces">  </span><span class="nottickedoff">, a &lt;- knownRepr :: TypeRepr a</span>
<span class="lineno"> 8231 </span><span class="spaces">  </span><span class="nottickedoff">, mb_bp' &lt;- mbExBlockToSubShape a mb_bp =</span>
<span class="lineno"> 8232 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8233 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove the sub-shape in the context of a new existential variable</span>
<span class="lineno"> 8234 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocksExt1 x ps psubst mb_bp' mb_bps &gt;&gt;&gt;= \e -&gt;</span>
<span class="lineno"> 8235 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8236 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the block permission we proved to the top of the stack</span>
<span class="lineno"> 8237 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistConj &quot;proveVarLLVMBlocks2&quot; x &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8238 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps' 1 &gt;&gt;&gt;</span>
<span class="lineno"> 8239 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8240 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove an existential around the memblock permission we proved</span>
<span class="lineno"> 8241 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_bp &quot;proveVarLLVMBlock&quot; &gt;&gt;&gt;= \bp_out -&gt;</span>
<span class="lineno"> 8242 </span><span class="spaces">    </span><span class="nottickedoff">introExistsM x e (mbValPerm_LLVMBlock $ exBlockToSubShape a bp_out) &gt;&gt;&gt;</span>
<span class="lineno"> 8243 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8244 </span><span class="spaces">    </span><span class="nottickedoff">-- Now coerce the existential permission on top of the stack to a memblock</span>
<span class="lineno"> 8245 </span><span class="spaces">    </span><span class="nottickedoff">-- perm with existential shape, and move it back into position</span>
<span class="lineno"> 8246 </span><span class="spaces">    </span><span class="nottickedoff">let (_, ps'') = expectLengthAtLeastOne ps' in</span>
<span class="lineno"> 8247 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockEx x bp_out) &gt;&gt;&gt;</span>
<span class="lineno"> 8248 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp_out) ps'' 0</span>
<span class="lineno"> 8249 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8250 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8251 </span><span class="spaces"></span><span class="nottickedoff">-- If proving an evar shape that has already been set, substitute and recurse</span>
<span class="lineno"> 8252 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8253 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8254 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8255 </span><span class="spaces">  </span><span class="nottickedoff">, Just sh &lt;- psubstLookup psubst memb =</span>
<span class="lineno"> 8256 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' = fmap (\bp -&gt; bp { llvmBlockShape = sh }) mb_bp in</span>
<span class="lineno"> 8257 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp' : mb_bps)</span>
<span class="lineno"> 8258 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8259 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8260 </span><span class="spaces"></span><span class="nottickedoff">-- If z is unset and len == 0, just set z to the empty shape and recurse in</span>
<span class="lineno"> 8261 </span><span class="spaces"></span><span class="nottickedoff">-- order to call the len == 0 empty shape case above</span>
<span class="lineno"> 8262 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8263 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8264 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8265 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 8266 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 8267 </span><span class="spaces">  </span><span class="nottickedoff">, bvIsZero len =</span>
<span class="lineno"> 8268 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb PExpr_EmptyShape &gt;&gt;&gt;</span>
<span class="lineno"> 8269 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' = mbMapCl $(mkClosed</span>
<span class="lineno"> 8270 </span><span class="spaces">                           </span><span class="nottickedoff">[| \bp -&gt; bp { llvmBlockShape =</span>
<span class="lineno"> 8271 </span><span class="spaces">                                            </span><span class="nottickedoff">PExpr_EmptyShape } |]) mb_bp in</span>
<span class="lineno"> 8272 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst (mb_bp' : mb_bps)</span>
<span class="lineno"> 8273 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8274 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8275 </span><span class="spaces"></span><span class="nottickedoff">-- If the shape of mb_bp is an unset variable z, mb_bp has a fixed constant</span>
<span class="lineno"> 8276 </span><span class="spaces"></span><span class="nottickedoff">-- length, and there is an any permission on the left, recursively prove a</span>
<span class="lineno"> 8277 </span><span class="spaces"></span><span class="nottickedoff">-- memblock permission with shape fieldsh(any)</span>
<span class="lineno"> 8278 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8279 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8280 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8281 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 8282 </span><span class="spaces">  </span><span class="nottickedoff">, elem Perm_Any ps</span>
<span class="lineno"> 8283 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 8284 </span><span class="spaces">  </span><span class="nottickedoff">, Just len_int &lt;- bvMatchConstInt len</span>
<span class="lineno"> 8285 </span><span class="spaces">  </span><span class="nottickedoff">, Just (Some (sz :: NatRepr sz)) &lt;- someNat (8 * len_int)</span>
<span class="lineno"> 8286 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) sz</span>
<span class="lineno"> 8287 </span><span class="spaces">  </span><span class="nottickedoff">, p &lt;- ValPerm_Any :: ValuePerm (LLVMPointerType sz) =</span>
<span class="lineno"> 8288 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb (withKnownNat sz $ PExpr_FieldShape $ LLVMFieldShape p) &gt;&gt;&gt;</span>
<span class="lineno"> 8289 </span><span class="spaces">    </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst' -&gt;</span>
<span class="lineno"> 8290 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst' mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8291 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8292 </span><span class="spaces"></span><span class="nottickedoff">-- If the shape of mb_bp is an unset variable z and there is a field permission</span>
<span class="lineno"> 8293 </span><span class="spaces"></span><span class="nottickedoff">-- on the left that contains all the offsets of mb_bp, recursively prove a</span>
<span class="lineno"> 8294 </span><span class="spaces"></span><span class="nottickedoff">-- memblock permission with shape fieldsh(eq(y)) for fresh evar y, which is the</span>
<span class="lineno"> 8295 </span><span class="spaces"></span><span class="nottickedoff">-- most general field permission</span>
<span class="lineno"> 8296 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8297 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8298 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8299 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 8300 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst (mbLLVMBlockOffset mb_bp)</span>
<span class="lineno"> 8301 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 8302 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (llvmPermContainsOffsetBool off) ps</span>
<span class="lineno"> 8303 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMField fp &lt;- ps!!i</span>
<span class="lineno"> 8304 </span><span class="spaces">  </span><span class="nottickedoff">, len1 &lt;- bvSub (llvmFieldEndOffset fp) off</span>
<span class="lineno"> 8305 </span><span class="spaces">  </span><span class="nottickedoff">, bvLeq len len1</span>
<span class="lineno"> 8306 </span><span class="spaces">  </span><span class="nottickedoff">, Just len1_int &lt;- bvMatchConstInt len1</span>
<span class="lineno"> 8307 </span><span class="spaces">  </span><span class="nottickedoff">, Just (Some (sz1 :: NatRepr sz1)) &lt;- someNat (8 * len1_int)</span>
<span class="lineno"> 8308 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) sz1 =</span>
<span class="lineno"> 8309 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8310 </span><span class="spaces">    </span><span class="nottickedoff">-- Recursively prove a membblock with shape fieldsh(eq(y)) for fresh evar y</span>
<span class="lineno"> 8311 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat sz1 $</span>
<span class="lineno"> 8312 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bp' =</span>
<span class="lineno"> 8313 </span><span class="spaces">          </span><span class="nottickedoff">mbCombine (MNil :&gt;: (Proxy :: Proxy (LLVMPointerType sz1))) $</span>
<span class="lineno"> 8314 </span><span class="spaces">          </span><span class="nottickedoff">mbMapCl $(mkClosed</span>
<span class="lineno"> 8315 </span><span class="spaces">                    </span><span class="nottickedoff">[| \bp -&gt; nu $ \y -&gt;</span>
<span class="lineno"> 8316 </span><span class="spaces">                      </span><span class="nottickedoff">bp { llvmBlockShape =</span>
<span class="lineno"> 8317 </span><span class="spaces">                           </span><span class="nottickedoff">PExpr_FieldShape $ LLVMFieldShape $</span>
<span class="lineno"> 8318 </span><span class="spaces">                           </span><span class="nottickedoff">ValPerm_Eq $ PExpr_Var y } |]) mb_bp in</span>
<span class="lineno"> 8319 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocksExt1 x ps psubst mb_bp' mb_bps &gt;&gt;&gt;= \e -&gt;</span>
<span class="lineno"> 8320 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8321 </span><span class="spaces">    </span><span class="nottickedoff">-- Set z = fieldsh(eq(e)) where e was the value we determined for y;</span>
<span class="lineno"> 8322 </span><span class="spaces">    </span><span class="nottickedoff">-- otherwise we are done, because our required block perm is already proved</span>
<span class="lineno"> 8323 </span><span class="spaces">    </span><span class="nottickedoff">-- and in the correct spot on the stack</span>
<span class="lineno"> 8324 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb (PExpr_FieldShape $ LLVMFieldShape $ ValPerm_Eq e)</span>
<span class="lineno"> 8325 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8326 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8327 </span><span class="spaces"></span><span class="nottickedoff">-- If the shape of mb_bp is an unset variable z and there is an array permission</span>
<span class="lineno"> 8328 </span><span class="spaces"></span><span class="nottickedoff">-- on the left that contains all the offsets of mb_bp, recursively prove a</span>
<span class="lineno"> 8329 </span><span class="spaces"></span><span class="nottickedoff">-- memblock permission with the corresponding array shape</span>
<span class="lineno"> 8330 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8331 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8332 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8333 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 8334 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst (mbLLVMBlockOffset mb_bp)</span>
<span class="lineno"> 8335 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 8336 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (llvmPermContainsOffsetBool off) ps</span>
<span class="lineno"> 8337 </span><span class="spaces">  </span><span class="nottickedoff">, (Perm_LLVMArray ap) &lt;- ps!!i</span>
<span class="lineno"> 8338 </span><span class="spaces">  </span><span class="nottickedoff">, Just (LLVMArrayIndex bp_cell (BV.BV 0)) &lt;- matchLLVMArrayIndex ap off</span>
<span class="lineno"> 8339 </span><span class="spaces">  </span><span class="nottickedoff">, bvIsZero (bvMod len (llvmArrayStride ap))</span>
<span class="lineno"> 8340 </span><span class="spaces">  </span><span class="nottickedoff">, sh_len &lt;- bvDiv len (llvmArrayStride ap)</span>
<span class="lineno"> 8341 </span><span class="spaces">  </span><span class="nottickedoff">, bvLeq (bvAdd bp_cell sh_len) (llvmArrayLen ap)</span>
<span class="lineno"> 8342 </span><span class="spaces">  </span><span class="nottickedoff">, sh &lt;- PExpr_ArrayShape sh_len (llvmArrayStride ap) (llvmArrayCellShape ap) =</span>
<span class="lineno"> 8343 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb sh &gt;&gt;&gt;</span>
<span class="lineno"> 8344 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst</span>
<span class="lineno"> 8345 </span><span class="spaces">    </span><span class="nottickedoff">(fmap (\bp -&gt; bp { llvmBlockShape = sh }) mb_bp : mb_bps)</span>
<span class="lineno"> 8346 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8347 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8348 </span><span class="spaces"></span><span class="nottickedoff">-- If the shape of mb_bp is an unset variable z and there is a block permission</span>
<span class="lineno"> 8349 </span><span class="spaces"></span><span class="nottickedoff">-- on the left with the required offset and length, set z to the shape of that</span>
<span class="lineno"> 8350 </span><span class="spaces"></span><span class="nottickedoff">-- block permission and recurse. Note that proveVarLLVMBlocks1 removes the case</span>
<span class="lineno"> 8351 </span><span class="spaces"></span><span class="nottickedoff">-- where there is a block permission that overlaps with mb_bp.</span>
<span class="lineno"> 8352 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8353 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8354 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8355 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 8356 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst (mbLLVMBlockOffset mb_bp)</span>
<span class="lineno"> 8357 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 8358 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (llvmPermContainsOffsetBool off) ps</span>
<span class="lineno"> 8359 </span><span class="spaces">  </span><span class="nottickedoff">, (Perm_LLVMBlock bp_lhs) &lt;- ps!!i</span>
<span class="lineno"> 8360 </span><span class="spaces">  </span><span class="nottickedoff">, bvEq off (llvmBlockOffset bp_lhs)</span>
<span class="lineno"> 8361 </span><span class="spaces">  </span><span class="nottickedoff">, bvEq len (llvmBlockLen bp_lhs)</span>
<span class="lineno"> 8362 </span><span class="spaces">  </span><span class="nottickedoff">, sh_lhs &lt;- llvmBlockShape bp_lhs =</span>
<span class="lineno"> 8363 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb sh_lhs &gt;&gt;&gt;</span>
<span class="lineno"> 8364 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocks x ps psubst</span>
<span class="lineno"> 8365 </span><span class="spaces">    </span><span class="nottickedoff">(fmap (\bp -&gt; bp { llvmBlockShape = sh_lhs }) mb_bp : mb_bps)</span>
<span class="lineno"> 8366 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8367 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8368 </span><span class="spaces"></span><span class="nottickedoff">-- If z is unset and there is an atomic permission that contains the required</span>
<span class="lineno"> 8369 </span><span class="spaces"></span><span class="nottickedoff">-- offset of mb_bp but is shorter than mb_bp, split mb_bp into two memblock</span>
<span class="lineno"> 8370 </span><span class="spaces"></span><span class="nottickedoff">-- permissions with unknown shapes but where the first has the length of this</span>
<span class="lineno"> 8371 </span><span class="spaces"></span><span class="nottickedoff">-- atomic permission, and then recurse</span>
<span class="lineno"> 8372 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps psubst mb_bp mb_sh mb_bps</span>
<span class="lineno"> 8373 </span><span class="spaces">  </span><span class="nottickedoff">| [nuMP| PExpr_Var mb_z |] &lt;- mb_sh</span>
<span class="lineno"> 8374 </span><span class="spaces">  </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_z</span>
<span class="lineno"> 8375 </span><span class="spaces">  </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb</span>
<span class="lineno"> 8376 </span><span class="spaces">  </span><span class="nottickedoff">, Just off &lt;- partialSubst psubst (mbLLVMBlockOffset mb_bp)</span>
<span class="lineno"> 8377 </span><span class="spaces">  </span><span class="nottickedoff">, Just len &lt;- partialSubst psubst (mbLLVMBlockLen mb_bp)</span>
<span class="lineno"> 8378 </span><span class="spaces">  </span><span class="nottickedoff">, Just i &lt;- findIndex (llvmPermContainsOffsetBool off) ps</span>
<span class="lineno"> 8379 </span><span class="spaces">  </span><span class="nottickedoff">, Just end_lhs &lt;- llvmAtomicPermEndOffset (ps!!i)</span>
<span class="lineno"> 8380 </span><span class="spaces">  </span><span class="nottickedoff">, len1 &lt;- bvSub end_lhs off</span>
<span class="lineno"> 8381 </span><span class="spaces">  </span><span class="nottickedoff">, bvLt len1 len =</span>
<span class="lineno"> 8382 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8383 </span><span class="spaces">    </span><span class="nottickedoff">-- Build existential memblock perms with fresh variables for shapes, where</span>
<span class="lineno"> 8384 </span><span class="spaces">    </span><span class="nottickedoff">-- the first one has the length of the atomic perm we found and the other</span>
<span class="lineno"> 8385 </span><span class="spaces">    </span><span class="nottickedoff">-- has the remaining length, and recurse</span>
<span class="lineno"> 8386 </span><span class="spaces">    </span><span class="nottickedoff">let mb_bps12 =</span>
<span class="lineno"> 8387 </span><span class="spaces">          </span><span class="nottickedoff">mbCombine RL.typeCtxProxies $ flip fmap mb_bp $ \bp -&gt;</span>
<span class="lineno"> 8388 </span><span class="spaces">          </span><span class="nottickedoff">nuMulti (MNil :&gt;: Proxy :&gt;: Proxy) $ \(_ :&gt;: z_sh1 :&gt;: z_sh2) -&gt;</span>
<span class="lineno"> 8389 </span><span class="spaces">          </span><span class="nottickedoff">[bp { llvmBlockLen = len1, llvmBlockShape = PExpr_Var z_sh1 },</span>
<span class="lineno"> 8390 </span><span class="spaces">           </span><span class="nottickedoff">bp { llvmBlockOffset = bvAdd (llvmBlockOffset bp) len1,</span>
<span class="lineno"> 8391 </span><span class="spaces">                </span><span class="nottickedoff">llvmBlockLen = bvSub (llvmBlockLen bp) len1,</span>
<span class="lineno"> 8392 </span><span class="spaces">                </span><span class="nottickedoff">llvmBlockShape = PExpr_Var z_sh2 }] in</span>
<span class="lineno"> 8393 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMBlocksExt2 x ps psubst mb_bps12 mb_bps &gt;&gt;&gt;</span>
<span class="lineno"> 8394 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8395 </span><span class="spaces">    </span><span class="nottickedoff">-- Move the two block permissions we proved to the top of the stack</span>
<span class="lineno"> 8396 </span><span class="spaces">    </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \p_top -&gt;</span>
<span class="lineno"> 8397 </span><span class="spaces">    </span><span class="nottickedoff">(case p_top of</span>
<span class="lineno"> 8398 </span><span class="spaces">        </span><span class="nottickedoff">ValPerm_Conj</span>
<span class="lineno"> 8399 </span><span class="spaces">          </span><span class="nottickedoff">ps_ret@(Perm_LLVMBlock bp1 : Perm_LLVMBlock bp2 : ps_ret') -&gt;</span>
<span class="lineno"> 8400 </span><span class="spaces">          </span><span class="nottickedoff">return (ps_ret, bp1, bp2, ps_ret')</span>
<span class="lineno"> 8401 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; error &quot;proveVarLLVMBlocks2: unexpected permission on top of the stack&quot;)</span>
<span class="lineno"> 8402 </span><span class="spaces">    </span><span class="nottickedoff">&gt;&gt;&gt;= \(ps_ret, bp1, bp2, ps_ret') -&gt;</span>
<span class="lineno"> 8403 </span><span class="spaces">    </span><span class="nottickedoff">let len2 = llvmBlockLen bp2</span>
<span class="lineno"> 8404 </span><span class="spaces">        </span><span class="nottickedoff">sh2 = llvmBlockShape bp2 in</span>
<span class="lineno"> 8405 </span><span class="spaces">    </span><span class="nottickedoff">implSplitSwapConjsM x ps_ret 2 &gt;&gt;&gt;</span>
<span class="lineno"> 8406 </span><span class="spaces">    </span><span class="nottickedoff">implSplitConjsM x (map Perm_LLVMBlock [bp1,bp2]) 1 &gt;&gt;&gt;</span>
<span class="lineno"> 8407 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8408 </span><span class="spaces">    </span><span class="nottickedoff">-- Sequence these two block permissions together</span>
<span class="lineno"> 8409 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroLLVMBlockSeq x bp1 len2 sh2) &gt;&gt;&gt;</span>
<span class="lineno"> 8410 </span><span class="spaces">    </span><span class="nottickedoff">let bp = bp1 { llvmBlockLen = bvAdd (llvmBlockLen bp1) len2,</span>
<span class="lineno"> 8411 </span><span class="spaces">                   </span><span class="nottickedoff">llvmBlockShape = PExpr_SeqShape (llvmBlockShape bp1) sh2 } in</span>
<span class="lineno"> 8412 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8413 </span><span class="spaces">    </span><span class="nottickedoff">-- Finally, set z to the memblock permission we ended up proving, and move</span>
<span class="lineno"> 8414 </span><span class="spaces">    </span><span class="nottickedoff">-- this proof back into position</span>
<span class="lineno"> 8415 </span><span class="spaces">    </span><span class="nottickedoff">setVarM memb (llvmBlockShape bp) &gt;&gt;&gt;</span>
<span class="lineno"> 8416 </span><span class="spaces">    </span><span class="nottickedoff">implSwapInsertConjM x (Perm_LLVMBlock bp) ps_ret' 0</span>
<span class="lineno"> 8417 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8418 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8419 </span><span class="spaces"></span><span class="nottickedoff">proveVarLLVMBlocks2 x ps _ mb_bp _ mb_bps =</span>
<span class="lineno"> 8420 </span><span class="spaces">  </span><span class="nottickedoff">mbSubstM (\s -&gt; ValPerm_Conj (map (Perm_LLVMBlock . s)</span>
<span class="lineno"> 8421 </span><span class="spaces">                                </span><span class="nottickedoff">(mb_bp:mb_bps))) &gt;&gt;&gt;= \mb_bps' -&gt;</span>
<span class="lineno"> 8422 </span><span class="spaces">  </span><span class="nottickedoff">implFailVarM &quot;proveVarLLVMBlock&quot; x (ValPerm_Conj ps) mb_bps'</span></span>
<span class="lineno"> 8423 </span>
<span class="lineno"> 8424 </span>
<span class="lineno"> 8425 </span>----------------------------------------------------------------------
<span class="lineno"> 8426 </span>-- * Proving and Eliminating Recursive Permissions
<span class="lineno"> 8427 </span>----------------------------------------------------------------------
<span class="lineno"> 8428 </span>
<span class="lineno"> 8429 </span>-- | Assuming @x:p1@ is on top of the stack, unfold a foldable named permission
<span class="lineno"> 8430 </span>-- in @p1@. If an 'Int' @i@ is supplied, then @p1@ is a conjunctive permission
<span class="lineno"> 8431 </span>-- whose @i@th conjunct is the named permisison to be unfolded; otherwise @p1@
<span class="lineno"> 8432 </span>-- itself is the named permission to be unfolded. Leave the resulting unfolded
<span class="lineno"> 8433 </span>-- permission on top of the stack, recombining any additional permissions (in
<span class="lineno"> 8434 </span>-- the former case, where a single conjunct is unfolded) back into the primary
<span class="lineno"> 8435 </span>-- permissions of @x@, and return that unfolded permission.
<span class="lineno"> 8436 </span>implUnfoldLeft :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 8437 </span>                  Maybe Int -&gt; ImplM vars s r (ps :&gt; a) (ps :&gt; a) (ValuePerm a)
<span class="lineno"> 8438 </span><span class="decl"><span class="nottickedoff">implUnfoldLeft x (ValPerm_Named npn args off) Nothing</span>
<span class="lineno"> 8439 </span><span class="spaces">  </span><span class="nottickedoff">| TrueRepr &lt;- nameCanFoldRepr npn =</span>
<span class="lineno"> 8440 </span><span class="spaces">    </span><span class="nottickedoff">(case namedPermNameSort npn of</span>
<span class="lineno"> 8441 </span><span class="spaces">        </span><span class="nottickedoff">RecursiveSortRepr _ _ -&gt; implSetRecRecurseLeftM</span>
<span class="lineno"> 8442 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; pure ()) &gt;&gt;&gt;</span>
<span class="lineno"> 8443 </span><span class="spaces">    </span><span class="nottickedoff">implUnfoldNamedM x npn args off &gt;&gt;&gt;= \p' -&gt;</span>
<span class="lineno"> 8444 </span><span class="spaces">    </span><span class="nottickedoff">return p'</span>
<span class="lineno"> 8445 </span><span class="spaces"></span><span class="nottickedoff">implUnfoldLeft x (ValPerm_Conj ps) (Just i)</span>
<span class="lineno"> 8446 </span><span class="spaces">  </span><span class="nottickedoff">| i &lt; length ps</span>
<span class="lineno"> 8447 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_NamedConj npn args off &lt;- ps!!i</span>
<span class="lineno"> 8448 </span><span class="spaces">  </span><span class="nottickedoff">, TrueRepr &lt;- nameCanFoldRepr npn =</span>
<span class="lineno"> 8449 </span><span class="spaces">    </span><span class="nottickedoff">(case namedPermNameSort npn of</span>
<span class="lineno"> 8450 </span><span class="spaces">        </span><span class="nottickedoff">RecursiveSortRepr _ _ -&gt; implSetRecRecurseLeftM</span>
<span class="lineno"> 8451 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; pure ()) &gt;&gt;&gt;</span>
<span class="lineno"> 8452 </span><span class="spaces">    </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 8453 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8454 </span><span class="spaces">    </span><span class="nottickedoff">implNamedFromConjM x npn args off &gt;&gt;&gt;</span>
<span class="lineno"> 8455 </span><span class="spaces">    </span><span class="nottickedoff">implUnfoldNamedM x npn args off &gt;&gt;&gt;= \p' -&gt;</span>
<span class="lineno"> 8456 </span><span class="spaces">    </span><span class="nottickedoff">return p'</span>
<span class="lineno"> 8457 </span><span class="spaces"></span><span class="nottickedoff">implUnfoldLeft _ _ _ = error (&quot;implUnfoldLeft: malformed inputs&quot;)</span></span>
<span class="lineno"> 8458 </span>
<span class="lineno"> 8459 </span>
<span class="lineno"> 8460 </span>-- | Assume that @x:(p1 * ... * pn)@ is on top of the stack, and try to find
<span class="lineno"> 8461 </span>-- some @pi@ that can be unfolded. If successful, recombine the remaining @pj@
<span class="lineno"> 8462 </span>-- to the primary permission for @x@, unfold @pi@, leave it on top of the stack,
<span class="lineno"> 8463 </span>-- and return its unfolded permission. Otherwise fail using 'implFailVarM',
<span class="lineno"> 8464 </span>-- citing the supplied permission in binding as the one we were trying to prove.
<span class="lineno"> 8465 </span>implUnfoldOrFail :: NuMatchingAny1 r =&gt; ExprVar a -&gt; [AtomicPerm a] -&gt;
<span class="lineno"> 8466 </span>                    Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 8467 </span>                    ImplM vars s r (ps :&gt; a) (ps :&gt; a) (ValuePerm a)
<span class="lineno"> 8468 </span><span class="decl"><span class="nottickedoff">implUnfoldOrFail x ps mb_p =</span>
<span class="lineno"> 8469 </span><span class="spaces">  </span><span class="nottickedoff">let p_l = ValPerm_Conj ps in</span>
<span class="lineno"> 8470 </span><span class="spaces">  </span><span class="nottickedoff">use implStateRecRecurseFlag &gt;&gt;= \flag -&gt;</span>
<span class="lineno"> 8471 </span><span class="spaces">  </span><span class="nottickedoff">case () of</span>
<span class="lineno"> 8472 </span><span class="spaces">    </span><span class="nottickedoff">-- We can always unfold a defined name on the left</span>
<span class="lineno"> 8473 </span><span class="spaces">    </span><span class="nottickedoff">_ | Just i &lt;- findIndex isDefinedConjPerm ps -&gt;</span>
<span class="lineno"> 8474 </span><span class="spaces">        </span><span class="nottickedoff">implUnfoldLeft x p_l (Just i)</span>
<span class="lineno"> 8475 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8476 </span><span class="spaces">    </span><span class="nottickedoff">-- If flag allows it, we can unfold a recursive name on the left</span>
<span class="lineno"> 8477 </span><span class="spaces">    </span><span class="nottickedoff">_ | Just i &lt;- findIndex isRecursiveConjPerm ps</span>
<span class="lineno"> 8478 </span><span class="spaces">      </span><span class="nottickedoff">, flag /= RecRight -&gt;</span>
<span class="lineno"> 8479 </span><span class="spaces">        </span><span class="nottickedoff">implUnfoldLeft x p_l (Just i)</span>
<span class="lineno"> 8480 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8481 </span><span class="spaces">    </span><span class="nottickedoff">-- Otherwise, we fail</span>
<span class="lineno"> 8482 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; implFailVarM &quot;implUnfoldOrFail&quot; x p_l mb_p</span></span>
<span class="lineno"> 8483 </span>
<span class="lineno"> 8484 </span>
<span class="lineno"> 8485 </span>-- | Prove @x:p1 |- x:p2@ by unfolding a foldable named permission in @p1@ and
<span class="lineno"> 8486 </span>-- then recursively proving @x:p2@ from the resulting permissions. If an 'Int'
<span class="lineno"> 8487 </span>-- @i@ is supplied, then @p1@ is a conjunctive permission whose @i@th conjunct
<span class="lineno"> 8488 </span>-- is the named permisison to be unfolded; otherwise @p1@ itself is the named
<span class="lineno"> 8489 </span>-- permission to be unfolded. Assume that @x:p1@ is on top of the stack.
<span class="lineno"> 8490 </span>proveVarImplUnfoldLeft :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 8491 </span>                          Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 8492 </span>                          Maybe Int -&gt; ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 8493 </span>
<span class="lineno"> 8494 </span><span class="decl"><span class="nottickedoff">proveVarImplUnfoldLeft x p mb_p maybe_i =</span>
<span class="lineno"> 8495 </span><span class="spaces">  </span><span class="nottickedoff">implUnfoldLeft x p maybe_i &gt;&gt;&gt;= \p' -&gt; recombinePerm x p' &gt;&gt;&gt;</span>
<span class="lineno"> 8496 </span><span class="spaces">  </span><span class="nottickedoff">proveVarImplInt x mb_p</span></span>
<span class="lineno"> 8497 </span>
<span class="lineno"> 8498 </span>
<span class="lineno"> 8499 </span>-- | Prove @x:p1 |- x:P&lt;args&gt;\@off@ where @P@ is foldable by first proving the
<span class="lineno"> 8500 </span>-- unfolding of @P@ folding it. Assume that @x:p1@ is on top of the stack.
<span class="lineno"> 8501 </span>proveVarImplFoldRight :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 8502 </span>                         Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 8503 </span>                         ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 8504 </span><span class="decl"><span class="nottickedoff">proveVarImplFoldRight x p mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 8505 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| ValPerm_Named mb_npn mb_args mb_off |]</span>
<span class="lineno"> 8506 </span><span class="spaces">    </span><span class="nottickedoff">| npn &lt;- mbLift mb_npn</span>
<span class="lineno"> 8507 </span><span class="spaces">    </span><span class="nottickedoff">, TrueRepr &lt;- nameCanFoldRepr npn -&gt;</span>
<span class="lineno"> 8508 </span><span class="spaces">      </span><span class="nottickedoff">(case namedPermNameSort npn of</span>
<span class="lineno"> 8509 </span><span class="spaces">          </span><span class="nottickedoff">RecursiveSortRepr _ _ -&gt; implSetRecRecurseRightM</span>
<span class="lineno"> 8510 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; pure ()) &gt;&gt;&gt;</span>
<span class="lineno"> 8511 </span><span class="spaces">      </span><span class="nottickedoff">implLookupNamedPerm npn &gt;&gt;&gt;= \np -&gt;</span>
<span class="lineno"> 8512 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt;</span>
<span class="lineno"> 8513 </span><span class="spaces">      </span><span class="nottickedoff">-- FIXME: how to replace this mbMap2 with mbMapCl, to avoid refreshing all</span>
<span class="lineno"> 8514 </span><span class="spaces">      </span><span class="nottickedoff">-- the names in mb_args and mb_off? Maybe they aren't that big anyway...</span>
<span class="lineno"> 8515 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplInt x (mbMap2 (unfoldPerm np) mb_args mb_off) &gt;&gt;&gt;</span>
<span class="lineno"> 8516 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_args &quot;proveVarImplFoldRight&quot; &gt;&gt;&gt;= \args -&gt;</span>
<span class="lineno"> 8517 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_off &quot;proveVarImplFoldRight&quot; &gt;&gt;&gt;= \off -&gt;</span>
<span class="lineno"> 8518 </span><span class="spaces">      </span><span class="nottickedoff">implFoldNamedM x npn args off</span>
<span class="lineno"> 8519 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 8520 </span><span class="spaces">    </span><span class="nottickedoff">error (&quot;proveVarImplFoldRight: malformed inputs&quot;)</span></span>
<span class="lineno"> 8521 </span>
<span class="lineno"> 8522 </span>
<span class="lineno"> 8523 </span>----------------------------------------------------------------------
<span class="lineno"> 8524 </span>-- * Proving Atomic Permissions
<span class="lineno"> 8525 </span>----------------------------------------------------------------------
<span class="lineno"> 8526 </span>
<span class="lineno"> 8527 </span>-- | We were not able to prove @x:(p1 * ... * pn) |- x:p@ as is, so try
<span class="lineno"> 8528 </span>-- unfolding named permissions in the @pi@s as a last resort. If there are none,
<span class="lineno"> 8529 </span>-- or our recursion flag does not allow it, then fail.
<span class="lineno"> 8530 </span>proveVarAtomicImplUnfoldOrFail :: NuMatchingAny1 r =&gt; ExprVar a -&gt;
<span class="lineno"> 8531 </span>                                  [AtomicPerm a] -&gt; Mb vars (AtomicPerm a) -&gt;
<span class="lineno"> 8532 </span>                                  ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 8533 </span><span class="decl"><span class="nottickedoff">proveVarAtomicImplUnfoldOrFail x ps mb_ap =</span>
<span class="lineno"> 8534 </span><span class="spaces">  </span><span class="nottickedoff">let mb_p = mbValPerm_Conj1 mb_ap in</span>
<span class="lineno"> 8535 </span><span class="spaces">  </span><span class="nottickedoff">implUnfoldOrFail x ps mb_p &gt;&gt;&gt;= \p' -&gt; recombinePerm x p' &gt;&gt;&gt;</span>
<span class="lineno"> 8536 </span><span class="spaces">  </span><span class="nottickedoff">proveVarImplInt x mb_p</span></span>
<span class="lineno"> 8537 </span>
<span class="lineno"> 8538 </span>
<span class="lineno"> 8539 </span>-- | Prove @x:(p1 * ... * pn) |- x:p@ for some atomic permission @p@, assuming
<span class="lineno"> 8540 </span>-- the LHS is on the top of the stack and represents all the permissions on @x@,
<span class="lineno"> 8541 </span>-- i.e., we also assume the variable permissions for @x@ are currently
<span class="lineno"> 8542 </span>-- @true@. Any remaining perms for @x@ are popped off of the stack.
<span class="lineno"> 8543 </span>proveVarAtomicImpl ::
<span class="lineno"> 8544 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 8545 </span>  HasCallStack =&gt;
<span class="lineno"> 8546 </span>  ExprVar a -&gt;
<span class="lineno"> 8547 </span>  [AtomicPerm a] -&gt;
<span class="lineno"> 8548 </span>  Mb vars (AtomicPerm a) -&gt;
<span class="lineno"> 8549 </span>  ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 8550 </span><span class="decl"><span class="nottickedoff">proveVarAtomicImpl x ps mb_p = case mbMatch mb_p of</span>
<span class="lineno"> 8551 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8552 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMField mb_fp |] -&gt;</span>
<span class="lineno"> 8553 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM (mbLLVMFieldOffset mb_fp) &quot;proveVarPtrPerms&quot; &gt;&gt;&gt;= \off -&gt;</span>
<span class="lineno"> 8554 </span><span class="spaces">    </span><span class="nottickedoff">proveVarLLVMField x ps off mb_fp</span>
<span class="lineno"> 8555 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMArray mb_ap |] -&gt; proveVarLLVMArray x ps mb_ap</span>
<span class="lineno"> 8556 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMBlock mb_bp |] -&gt; proveVarLLVMBlock x ps mb_bp</span>
<span class="lineno"> 8557 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8558 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMFree mb_e |] -&gt;</span>
<span class="lineno"> 8559 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_e &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \e -&gt;</span>
<span class="lineno"> 8560 </span><span class="spaces">    </span><span class="nottickedoff">case findMaybeIndices (\case</span>
<span class="lineno"> 8561 </span><span class="spaces">                              </span><span class="nottickedoff">Perm_LLVMFree e' -&gt; Just e'</span>
<span class="lineno"> 8562 </span><span class="spaces">                              </span><span class="nottickedoff">_ -&gt; Nothing) ps of</span>
<span class="lineno"> 8563 </span><span class="spaces">      </span><span class="nottickedoff">(i, e'):_ -&gt;</span>
<span class="lineno"> 8564 </span><span class="spaces">        </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8565 </span><span class="spaces">        </span><span class="nottickedoff">castLLVMFreeM x e' e</span>
<span class="lineno"> 8566 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; proveVarAtomicImplUnfoldOrFail x ps mb_p</span>
<span class="lineno"> 8567 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8568 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMFunPtr tp mb_p' |] -&gt;</span>
<span class="lineno"> 8569 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_p' &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 8570 </span><span class="spaces">    </span><span class="nottickedoff">case elemIndex (Perm_LLVMFunPtr (mbLift tp) p) ps of</span>
<span class="lineno"> 8571 </span><span class="spaces">      </span><span class="nottickedoff">Just i -&gt; implCopyConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 8572 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; proveVarAtomicImplUnfoldOrFail x ps mb_p</span>
<span class="lineno"> 8573 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8574 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |]</span>
<span class="lineno"> 8575 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- elemIndex Perm_IsLLVMPtr ps -&gt;</span>
<span class="lineno"> 8576 </span><span class="spaces">      </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 8577 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8578 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |]</span>
<span class="lineno"> 8579 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex isLLVMFieldPerm ps</span>
<span class="lineno"> 8580 </span><span class="spaces">    </span><span class="nottickedoff">, p@(Perm_LLVMField fp) &lt;- ps !! i -&gt;</span>
<span class="lineno"> 8581 </span><span class="spaces">      </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8582 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMFieldIsPtr x fp) &gt;&gt;&gt;</span>
<span class="lineno"> 8583 </span><span class="spaces">      </span><span class="nottickedoff">implPushM x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8584 </span><span class="spaces">      </span><span class="nottickedoff">implInsertConjM x p (deleteNth i ps) i &gt;&gt;&gt;</span>
<span class="lineno"> 8585 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 8586 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8587 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |]</span>
<span class="lineno"> 8588 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex isLLVMArrayPerm ps</span>
<span class="lineno"> 8589 </span><span class="spaces">    </span><span class="nottickedoff">, p@(Perm_LLVMArray ap) &lt;- ps !! i -&gt;</span>
<span class="lineno"> 8590 </span><span class="spaces">      </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8591 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMArrayIsPtr x ap) &gt;&gt;&gt;</span>
<span class="lineno"> 8592 </span><span class="spaces">      </span><span class="nottickedoff">implPushM x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8593 </span><span class="spaces">      </span><span class="nottickedoff">implInsertConjM x p (deleteNth i ps) i &gt;&gt;&gt;</span>
<span class="lineno"> 8594 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 8595 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8596 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |]</span>
<span class="lineno"> 8597 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex isLLVMBlockPerm ps</span>
<span class="lineno"> 8598 </span><span class="spaces">    </span><span class="nottickedoff">, p@(Perm_LLVMBlock bp) &lt;- ps !! i -&gt;</span>
<span class="lineno"> 8599 </span><span class="spaces">      </span><span class="nottickedoff">implExtractConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8600 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_LLVMBlockIsPtr x bp) &gt;&gt;&gt;</span>
<span class="lineno"> 8601 </span><span class="spaces">      </span><span class="nottickedoff">implPushM x (ValPerm_Conj $ deleteNth i ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8602 </span><span class="spaces">      </span><span class="nottickedoff">implInsertConjM x p (deleteNth i ps) i &gt;&gt;&gt;</span>
<span class="lineno"> 8603 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 8604 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8605 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_IsLLVMPtr |] -&gt;</span>
<span class="lineno"> 8606 </span><span class="spaces">    </span><span class="nottickedoff">proveVarAtomicImplUnfoldOrFail x ps mb_p</span>
<span class="lineno"> 8607 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8608 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMBlockShape mb_sh |]</span>
<span class="lineno"> 8609 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex (\case</span>
<span class="lineno"> 8610 </span><span class="spaces">                              </span><span class="nottickedoff">Perm_LLVMBlockShape _ -&gt; True</span>
<span class="lineno"> 8611 </span><span class="spaces">                              </span><span class="nottickedoff">_ -&gt; False) ps</span>
<span class="lineno"> 8612 </span><span class="spaces">    </span><span class="nottickedoff">, Perm_LLVMBlockShape sh &lt;- ps!!i -&gt;</span>
<span class="lineno"> 8613 </span><span class="spaces">      </span><span class="nottickedoff">implGetPopConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 8614 </span><span class="spaces">      </span><span class="nottickedoff">proveEqCast x (ValPerm_Conj1 . Perm_LLVMBlockShape) sh mb_sh</span>
<span class="lineno"> 8615 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8616 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_NamedConj mb_n mb_args mb_off |] -&gt;</span>
<span class="lineno"> 8617 </span><span class="spaces">    </span><span class="nottickedoff">let n = mbLift mb_n in</span>
<span class="lineno"> 8618 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplH x (ValPerm_Conj ps) (mbMap2 (ValPerm_Named n)</span>
<span class="lineno"> 8619 </span><span class="spaces">                                       </span><span class="nottickedoff">mb_args mb_off) &gt;&gt;&gt;</span>
<span class="lineno"> 8620 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_args &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \args -&gt;</span>
<span class="lineno"> 8621 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_off &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \off -&gt;</span>
<span class="lineno"> 8622 </span><span class="spaces">    </span><span class="nottickedoff">implNamedToConjM x n args off</span>
<span class="lineno"> 8623 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8624 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LLVMFrame mb_fperms |]</span>
<span class="lineno"> 8625 </span><span class="spaces">    </span><span class="nottickedoff">| [Perm_LLVMFrame fperms] &lt;- ps -&gt;</span>
<span class="lineno"> 8626 </span><span class="spaces">      </span><span class="nottickedoff">proveEq fperms mb_fperms &gt;&gt;&gt;= \eqp -&gt;</span>
<span class="lineno"> 8627 </span><span class="spaces">      </span><span class="nottickedoff">implCastPermM Proxy x (fmap (ValPerm_Conj1 . Perm_LLVMFrame) eqp)</span>
<span class="lineno"> 8628 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8629 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME HERE: eventually we should handle lowned permissions on the right</span>
<span class="lineno"> 8630 </span><span class="spaces">  </span><span class="nottickedoff">-- with arbitrary contained lifetimes, by equalizing the two sides</span>
<span class="lineno"> 8631 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LOwned [] _ _ _ _ |]</span>
<span class="lineno"> 8632 </span><span class="spaces">    </span><span class="nottickedoff">| [Perm_LOwned (PExpr_Var l2:_) _ _ _ _] &lt;- ps -&gt;</span>
<span class="lineno"> 8633 </span><span class="spaces">      </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt; implEndLifetimeRecM l2 &gt;&gt;&gt;</span>
<span class="lineno"> 8634 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplInt x (mbValPerm_Conj1 mb_p)</span>
<span class="lineno"> 8635 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8636 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LOwned [] mb_tps_inR mb_tps_outR mb_ps_inR mb_ps_outR |]</span>
<span class="lineno"> 8637 </span><span class="spaces">    </span><span class="nottickedoff">| [Perm_LOwned [] tps_inL tps_outL ps_inL ps_outL] &lt;- ps</span>
<span class="lineno"> 8638 </span><span class="spaces">    </span><span class="nottickedoff">, tps_inR &lt;- mbLift mb_tps_inR</span>
<span class="lineno"> 8639 </span><span class="spaces">    </span><span class="nottickedoff">, tps_outR &lt;- mbLift mb_tps_outR -&gt;</span>
<span class="lineno"> 8640 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8641 </span><span class="spaces">      </span><span class="nottickedoff">-- Compute the necessary &quot;permission subtractions&quot; to figure out what</span>
<span class="lineno"> 8642 </span><span class="spaces">      </span><span class="nottickedoff">-- additional permissions are needed to prove both ps_inR -o ps_inL and</span>
<span class="lineno"> 8643 </span><span class="spaces">      </span><span class="nottickedoff">-- ps_outL -o ps_outR. These required permissions are called ps1 and ps2,</span>
<span class="lineno"> 8644 </span><span class="spaces">      </span><span class="nottickedoff">-- respectively. Note that the RHS for both of these implications needs to</span>
<span class="lineno"> 8645 </span><span class="spaces">      </span><span class="nottickedoff">-- be in a name-binding for the evars and the LHS needs to not be in a</span>
<span class="lineno"> 8646 </span><span class="spaces">      </span><span class="nottickedoff">-- name-binding, so ps_inR cannot have any evars.</span>
<span class="lineno"> 8647 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_ps_inR &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \ps_inR -&gt;</span>
<span class="lineno"> 8648 </span><span class="spaces">      </span><span class="nottickedoff">let mb_ps_inL = mbConst ps_inL mb_ps_inR in</span>
<span class="lineno"> 8649 </span><span class="spaces">      </span><span class="nottickedoff">solveForPermListImpl ps_inR tps_inL mb_ps_inL &gt;&gt;&gt;= \(Some neededs1) -&gt;</span>
<span class="lineno"> 8650 </span><span class="spaces">      </span><span class="nottickedoff">solveForPermListImpl ps_outL tps_outR mb_ps_outR &gt;&gt;&gt;= \(Some neededs2) -&gt;</span>
<span class="lineno"> 8651 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8652 </span><span class="spaces">      </span><span class="nottickedoff">-- Prove neededs1 and neededs2 along with their corresponding auxiliary</span>
<span class="lineno"> 8653 </span><span class="spaces">      </span><span class="nottickedoff">-- permissions, and then look at the substitution instances of these</span>
<span class="lineno"> 8654 </span><span class="spaces">      </span><span class="nottickedoff">-- permissions that were actually proved on top of the stack. We do it</span>
<span class="lineno"> 8655 </span><span class="spaces">      </span><span class="nottickedoff">-- this way because we can't substitute expressions for variables in a</span>
<span class="lineno"> 8656 </span><span class="spaces">      </span><span class="nottickedoff">-- DistPerms, because DistPerms need to have variables on the LHSs and not</span>
<span class="lineno"> 8657 </span><span class="spaces">      </span><span class="nottickedoff">-- arbitrary expressions</span>
<span class="lineno"> 8658 </span><span class="spaces">      </span><span class="nottickedoff">implTraceM (\i -&gt; hang 2</span>
<span class="lineno"> 8659 </span><span class="spaces">                        </span><span class="nottickedoff">(pretty &quot;Proving needed perms for lowned implication:&quot;</span>
<span class="lineno"> 8660 </span><span class="spaces">                         </span><span class="nottickedoff">&lt;&gt; line &lt;&gt; permPretty i neededs1 &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 8661 </span><span class="spaces">                         </span><span class="nottickedoff">pretty &quot;And:&quot; &lt;&gt; line &lt;&gt; permPretty i neededs2)) &gt;&gt;&gt;</span>
<span class="lineno"> 8662 </span><span class="spaces">      </span><span class="nottickedoff">getVarProxies &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 8663 </span><span class="spaces">      </span><span class="nottickedoff">getDistPermsProxies &gt;&gt;&gt;= \prxs0_a -&gt;</span>
<span class="lineno"> 8664 </span><span class="spaces">      </span><span class="nottickedoff">let prxs0 = RL.tail prxs0_a in</span>
<span class="lineno"> 8665 </span><span class="spaces">      </span><span class="nottickedoff">proveNeededPerms vars neededs1 &gt;&gt;&gt;= \(Some auxs1) -&gt;</span>
<span class="lineno"> 8666 </span><span class="spaces">      </span><span class="nottickedoff">mbVarsM auxs1 &gt;&gt;&gt;= \mb_auxs1 -&gt;</span>
<span class="lineno"> 8667 </span><span class="spaces">      </span><span class="nottickedoff">proveVarsImplAppendIntAssoc prxs0_a neededs1 mb_auxs1 &gt;&gt;&gt;</span>
<span class="lineno"> 8668 </span><span class="spaces">      </span><span class="nottickedoff">let prxs1 = rlToProxies neededs1 `RL.append` rlToProxies auxs1 in</span>
<span class="lineno"> 8669 </span><span class="spaces">      </span><span class="nottickedoff">proveNeededPermsAssoc vars prxs0_a prxs1 neededs2 &gt;&gt;&gt;= \(Some auxs2) -&gt;</span>
<span class="lineno"> 8670 </span><span class="spaces">      </span><span class="nottickedoff">mbVarsM auxs2 &gt;&gt;&gt;= \mb_auxs2 -&gt;</span>
<span class="lineno"> 8671 </span><span class="spaces">      </span><span class="nottickedoff">proveVarsImplAppendIntAssoc4 prxs0_a prxs1 neededs2 mb_auxs2 &gt;&gt;&gt;</span>
<span class="lineno"> 8672 </span><span class="spaces">      </span><span class="nottickedoff">let prxs2 = rlToProxies neededs2 `RL.append` rlToProxies auxs2</span>
<span class="lineno"> 8673 </span><span class="spaces">          </span><span class="nottickedoff">prxs12 = RL.append prxs1 prxs2 in</span>
<span class="lineno"> 8674 </span><span class="spaces">      </span><span class="nottickedoff">getTopDistPerms prxs0_a prxs12 &gt;&gt;&gt;= \ps12 -&gt;</span>
<span class="lineno"> 8675 </span><span class="spaces">      </span><span class="nottickedoff">let (ps1,ps2) = RL.split prxs1 prxs2 ps12 in</span>
<span class="lineno"> 8676 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_ps_outR &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \ps_outR -&gt;</span>
<span class="lineno"> 8677 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8678 </span><span class="spaces">      </span><span class="nottickedoff">-- Build the local implications ps_inR -o ps_inL and ps_outL -o ps_outR</span>
<span class="lineno"> 8679 </span><span class="spaces">      </span><span class="nottickedoff">(case (exprPermsToDistPerms ps_inL, exprPermsToDistPerms ps_outL,</span>
<span class="lineno"> 8680 </span><span class="spaces">             </span><span class="nottickedoff">exprPermsToDistPerms ps_inR, exprPermsToDistPerms ps_outR) of</span>
<span class="lineno"> 8681 </span><span class="spaces">          </span><span class="nottickedoff">(Just dps_inL, Just dps_outL, Just dps_inR, Just dps_outR) -&gt;</span>
<span class="lineno"> 8682 </span><span class="spaces">            </span><span class="nottickedoff">pure (dps_inL, dps_outL, dps_inR, dps_outR)</span>
<span class="lineno"> 8683 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; implFailM (LifetimeError ImplicationLifetimeError))</span>
<span class="lineno"> 8684 </span><span class="spaces">      </span><span class="nottickedoff">&gt;&gt;&gt;= \(dps_inL, dps_outL, dps_inR, dps_outR) -&gt;</span>
<span class="lineno"> 8685 </span><span class="spaces">      </span><span class="nottickedoff">localProveVars (RL.append ps1 dps_inR) dps_inL &gt;&gt;&gt;= \impl_in -&gt;</span>
<span class="lineno"> 8686 </span><span class="spaces">      </span><span class="nottickedoff">localProveVars (RL.append ps2 dps_outL) dps_outR &gt;&gt;&gt;= \impl_out -&gt;</span>
<span class="lineno"> 8687 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8688 </span><span class="spaces">      </span><span class="nottickedoff">-- Finally, apply the MapLifetime proof step, first moving the input</span>
<span class="lineno"> 8689 </span><span class="spaces">      </span><span class="nottickedoff">-- lowned permissions to the top of the stack</span>
<span class="lineno"> 8690 </span><span class="spaces">      </span><span class="nottickedoff">implMoveUpM prxs0 ps12 x MNil &gt;&gt;&gt;</span>
<span class="lineno"> 8691 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM Proxy (SImpl_MapLifetime x []</span>
<span class="lineno"> 8692 </span><span class="spaces">                        </span><span class="nottickedoff">tps_inL tps_outL ps_inL ps_outL</span>
<span class="lineno"> 8693 </span><span class="spaces">                        </span><span class="nottickedoff">tps_inR tps_outR ps_inR ps_outR</span>
<span class="lineno"> 8694 </span><span class="spaces">                        </span><span class="nottickedoff">ps1 ps2 impl_in impl_out)</span>
<span class="lineno"> 8695 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8696 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LOwnedSimple mb_tps mb_lops |]</span>
<span class="lineno"> 8697 </span><span class="spaces">    </span><span class="nottickedoff">| Just mb_dps &lt;- mbMaybe (mbMapCl</span>
<span class="lineno"> 8698 </span><span class="spaces">                              </span><span class="nottickedoff">$(mkClosed [| exprPermsToDistPerms |]) mb_lops) -&gt;</span>
<span class="lineno"> 8699 </span><span class="spaces">      </span><span class="nottickedoff">-- Pop the permissions for x, and prove the mb_lops permissions that are</span>
<span class="lineno"> 8700 </span><span class="spaces">      </span><span class="nottickedoff">-- going to be borrowed by the lifetime x</span>
<span class="lineno"> 8701 </span><span class="spaces">      </span><span class="nottickedoff">implPopM x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8702 </span><span class="spaces">      </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \(ps0 :: DistPerms ps0) -&gt;</span>
<span class="lineno"> 8703 </span><span class="spaces">      </span><span class="nottickedoff">proveVarsImplAppendInt mb_dps &gt;&gt;&gt;</span>
<span class="lineno"> 8704 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_lops &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \lops -&gt;</span>
<span class="lineno"> 8705 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8706 </span><span class="spaces">      </span><span class="nottickedoff">-- Prove an empty lowned permission for x</span>
<span class="lineno"> 8707 </span><span class="spaces">      </span><span class="nottickedoff">mbVarsM (distPerms1 x $</span>
<span class="lineno"> 8708 </span><span class="spaces">               </span><span class="nottickedoff">ValPerm_LOwned [] CruCtxNil CruCtxNil MNil MNil) &gt;&gt;&gt;= \mb_p' -&gt;</span>
<span class="lineno"> 8709 </span><span class="spaces">      </span><span class="nottickedoff">proveVarsImplAppendInt mb_p' &gt;&gt;&gt;</span>
<span class="lineno"> 8710 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8711 </span><span class="spaces">      </span><span class="nottickedoff">-- Coerce the lowned permission to a simple lowned permission, and then</span>
<span class="lineno"> 8712 </span><span class="spaces">      </span><span class="nottickedoff">-- recombine all the resulting permissions for mb_lops</span>
<span class="lineno"> 8713 </span><span class="spaces">      </span><span class="nottickedoff">let tps = mbLift mb_tps in</span>
<span class="lineno"> 8714 </span><span class="spaces">      </span><span class="nottickedoff">implSimplM (Proxy :: Proxy ps0) (SImpl_IntroLOwnedSimple x tps lops) &gt;&gt;&gt;</span>
<span class="lineno"> 8715 </span><span class="spaces">      </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 8716 </span><span class="spaces">      </span><span class="nottickedoff">let (_, ps_lops_l@(ps_lops :&gt;: p_l)) =</span>
<span class="lineno"> 8717 </span><span class="spaces">            </span><span class="nottickedoff">RL.split ps0 (rlToProxies lops :&gt;: Proxy) perms in</span>
<span class="lineno"> 8718 </span><span class="spaces">      </span><span class="nottickedoff">implMoveDownM ps0 ps_lops_l x MNil &gt;&gt;&gt;</span>
<span class="lineno"> 8719 </span><span class="spaces">      </span><span class="nottickedoff">recombinePermsPartial (ps0 :&gt;: p_l) ps_lops</span>
<span class="lineno"> 8720 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8721 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LCurrent mb_l' |] -&gt;</span>
<span class="lineno"> 8722 </span><span class="spaces">    </span><span class="nottickedoff">-- We are trying to prove x is current whenever l' is, meaning that the</span>
<span class="lineno"> 8723 </span><span class="spaces">    </span><span class="nottickedoff">-- duration of l' is guaranteed to be contained inside that of x</span>
<span class="lineno"> 8724 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_l' &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \l' -&gt;</span>
<span class="lineno"> 8725 </span><span class="spaces">    </span><span class="nottickedoff">case ps of</span>
<span class="lineno"> 8726 </span><span class="spaces">      </span><span class="nottickedoff">_ | l' == PExpr_Var x -&gt;</span>
<span class="lineno"> 8727 </span><span class="spaces">          </span><span class="nottickedoff">-- If l' == x, proceed by reflexivity of lcurrent</span>
<span class="lineno"> 8728 </span><span class="spaces">          </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8729 </span><span class="spaces">          </span><span class="nottickedoff">implSimplM Proxy (SImpl_LCurrentRefl x)</span>
<span class="lineno"> 8730 </span><span class="spaces">      </span><span class="nottickedoff">[Perm_LCurrent l]</span>
<span class="lineno"> 8731 </span><span class="spaces">        </span><span class="nottickedoff">-- If we already have x:lcurrent l' on the LHS, we are done</span>
<span class="lineno"> 8732 </span><span class="spaces">        </span><span class="nottickedoff">| l == l' -&gt; pure ()</span>
<span class="lineno"> 8733 </span><span class="spaces">      </span><span class="nottickedoff">[Perm_LCurrent (PExpr_Var l)] -&gt;</span>
<span class="lineno"> 8734 </span><span class="spaces">        </span><span class="nottickedoff">-- If we have x:lcurrent l for some other l, prove l:lcurrent l' and</span>
<span class="lineno"> 8735 </span><span class="spaces">        </span><span class="nottickedoff">-- proceed by transitivity of lcurent</span>
<span class="lineno"> 8736 </span><span class="spaces">        </span><span class="nottickedoff">proveVarImplInt l (mbValPerm_Conj1 mb_p) &gt;&gt;&gt;</span>
<span class="lineno"> 8737 </span><span class="spaces">        </span><span class="nottickedoff">implSimplM Proxy (SImpl_LCurrentTrans x l l')</span>
<span class="lineno"> 8738 </span><span class="spaces">      </span><span class="nottickedoff">[Perm_LOwned ls tps_in tps_out ps_in ps_out]</span>
<span class="lineno"> 8739 </span><span class="spaces">        </span><span class="nottickedoff">| elem l' ls -&gt;</span>
<span class="lineno"> 8740 </span><span class="spaces">          </span><span class="nottickedoff">-- If we already have a lifetime ownership permission for x that</span>
<span class="lineno"> 8741 </span><span class="spaces">          </span><span class="nottickedoff">-- contains l' as a sub-lifetime, use that</span>
<span class="lineno"> 8742 </span><span class="spaces">          </span><span class="nottickedoff">implContainedLifetimeCurrentM x ls tps_in tps_out ps_in ps_out l'</span>
<span class="lineno"> 8743 </span><span class="spaces">      </span><span class="nottickedoff">[Perm_LOwned ls tps_in tps_out ps_in ps_out]</span>
<span class="lineno"> 8744 </span><span class="spaces">        </span><span class="nottickedoff">| PExpr_Var n' &lt;- l' -&gt;</span>
<span class="lineno"> 8745 </span><span class="spaces">          </span><span class="nottickedoff">-- If we have a lifetime ownership permission for x that does not</span>
<span class="lineno"> 8746 </span><span class="spaces">          </span><span class="nottickedoff">-- contain l', add l' as a sub-lifetime of x, but only if l' does not</span>
<span class="lineno"> 8747 </span><span class="spaces">          </span><span class="nottickedoff">-- already contain x</span>
<span class="lineno"> 8748 </span><span class="spaces">          </span><span class="nottickedoff">containedLifetimes n' &gt;&gt;&gt;= \sub_ls -&gt;</span>
<span class="lineno"> 8749 </span><span class="spaces">          </span><span class="nottickedoff">if elem x sub_ls then</span>
<span class="lineno"> 8750 </span><span class="spaces">            </span><span class="nottickedoff">proveVarAtomicImplUnfoldOrFail x ps mb_p</span>
<span class="lineno"> 8751 </span><span class="spaces">          </span><span class="nottickedoff">else</span>
<span class="lineno"> 8752 </span><span class="spaces">            </span><span class="nottickedoff">implSubsumeLifetimeM x ls tps_in tps_out ps_in ps_out l' &gt;&gt;&gt;</span>
<span class="lineno"> 8753 </span><span class="spaces">            </span><span class="nottickedoff">implContainedLifetimeCurrentM x (l':ls) tps_in tps_out ps_in ps_out l'</span>
<span class="lineno"> 8754 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; proveVarAtomicImplUnfoldOrFail x ps mb_p</span>
<span class="lineno"> 8755 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8756 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_LFinished |] -&gt;</span>
<span class="lineno"> 8757 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt; implEndLifetimeRecM x &gt;&gt;&gt;</span>
<span class="lineno"> 8758 </span><span class="spaces">    </span><span class="nottickedoff">implPushCopyM x ValPerm_LFinished</span>
<span class="lineno"> 8759 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8760 </span><span class="spaces">  </span><span class="nottickedoff">-- If we have a struct permission on the left, eliminate it to a sequence of</span>
<span class="lineno"> 8761 </span><span class="spaces">  </span><span class="nottickedoff">-- variables and prove the required permissions for each variable</span>
<span class="lineno"> 8762 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_Struct mb_str_ps |]</span>
<span class="lineno"> 8763 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex isStructPerm ps</span>
<span class="lineno"> 8764 </span><span class="spaces">    </span><span class="nottickedoff">, Perm_Struct str_ps &lt;- ps!!i -&gt;</span>
<span class="lineno"> 8765 </span><span class="spaces">      </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 8766 </span><span class="spaces">      </span><span class="nottickedoff">implGetPopConjM x ps i &gt;&gt;&gt; implElimStructAllFields x str_ps &gt;&gt;&gt;= \ys -&gt;</span>
<span class="lineno"> 8767 </span><span class="spaces">      </span><span class="nottickedoff">proveVarsImplAppendInt (fmap (valuePermsToDistPerms ys) mb_str_ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8768 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_str_ps &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \str_ps' -&gt;</span>
<span class="lineno"> 8769 </span><span class="spaces">      </span><span class="nottickedoff">implMoveUpM (distPermsSnoc perms) str_ps' x MNil &gt;&gt;&gt;</span>
<span class="lineno"> 8770 </span><span class="spaces">      </span><span class="nottickedoff">implIntroStructAllFields x</span>
<span class="lineno"> 8771 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8772 </span><span class="spaces">  </span><span class="nottickedoff">-- If we do not have a struct permission on the left, introduce a vacuous struct</span>
<span class="lineno"> 8773 </span><span class="spaces">  </span><span class="nottickedoff">-- permission and fall back to the previous case</span>
<span class="lineno"> 8774 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_Struct mb_str_ps |] -&gt;</span>
<span class="lineno"> 8775 </span><span class="spaces">    </span><span class="nottickedoff">let prxs = mbLift $ fmap rlToProxies mb_str_ps in</span>
<span class="lineno"> 8776 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_IntroStructTrue x prxs) &gt;&gt;&gt;</span>
<span class="lineno"> 8777 </span><span class="spaces">    </span><span class="nottickedoff">implInsertConjM x (Perm_Struct $ trueValuePerms prxs) ps (length ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8778 </span><span class="spaces">    </span><span class="nottickedoff">proveVarAtomicImpl x (ps ++ [Perm_Struct $ trueValuePerms prxs]) mb_p</span>
<span class="lineno"> 8779 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8780 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: existential Perm_Fun vars don't seem to make sense, as they translate</span>
<span class="lineno"> 8781 </span><span class="spaces">  </span><span class="nottickedoff">-- to a weird form of polymorphism...</span>
<span class="lineno"> 8782 </span><span class="spaces">  </span><span class="nottickedoff">{-</span>
<span class="lineno"> 8783 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_Fun (PExpr_Var z) |]</span>
<span class="lineno"> 8784 </span><span class="spaces">    </span><span class="nottickedoff">| [Perm_Fun fun_perm] &lt;- ps</span>
<span class="lineno"> 8785 </span><span class="spaces">    </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP z -&gt;</span>
<span class="lineno"> 8786 </span><span class="spaces">      </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 8787 </span><span class="spaces">      </span><span class="nottickedoff">case psubstLookup psubst memb of</span>
<span class="lineno"> 8788 </span><span class="spaces">        </span><span class="nottickedoff">Just fun_perm'</span>
<span class="lineno"> 8789 </span><span class="spaces">          </span><span class="nottickedoff">| Just Refl &lt;- funPermEq fun_perm fun_perm' -&gt; pure ()</span>
<span class="lineno"> 8790 </span><span class="spaces">        </span><span class="nottickedoff">Just _ -&gt; implFailM</span>
<span class="lineno"> 8791 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; setVarM memb fun_perm</span>
<span class="lineno"> 8792 </span><span class="spaces">  </span><span class="nottickedoff">-}</span>
<span class="lineno"> 8793 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8794 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_Fun mb_fun_perm |] -&gt;</span>
<span class="lineno"> 8795 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_fun_perm &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \fun_perm' -&gt;</span>
<span class="lineno"> 8796 </span><span class="spaces">    </span><span class="nottickedoff">foldr (\(i::Int,p) rest -&gt;</span>
<span class="lineno"> 8797 </span><span class="spaces">            </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 8798 </span><span class="spaces">              </span><span class="nottickedoff">Perm_Fun fun_perm</span>
<span class="lineno"> 8799 </span><span class="spaces">                </span><span class="nottickedoff">| Just (Refl,Refl,Refl,Refl) &lt;- funPermEq4 fun_perm fun_perm' -&gt;</span>
<span class="lineno"> 8800 </span><span class="spaces">                  </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt; recombinePerm x (ValPerm_Conj ps)</span>
<span class="lineno"> 8801 </span><span class="spaces">              </span><span class="nottickedoff">_ -&gt; rest)</span>
<span class="lineno"> 8802 </span><span class="spaces">    </span><span class="nottickedoff">(proveVarAtomicImplUnfoldOrFail x ps mb_p)</span>
<span class="lineno"> 8803 </span><span class="spaces">    </span><span class="nottickedoff">(zip [0..] ps)</span>
<span class="lineno"> 8804 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8805 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_BVProp mb_prop |] -&gt;</span>
<span class="lineno"> 8806 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 8807 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_prop &quot;proveVarAtomicImpl&quot; &gt;&gt;&gt;= \prop -&gt;</span>
<span class="lineno"> 8808 </span><span class="spaces">    </span><span class="nottickedoff">implTryProveBVProp x prop</span>
<span class="lineno"> 8809 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8810 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| Perm_Any |]</span>
<span class="lineno"> 8811 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex (== Perm_Any) ps -&gt;</span>
<span class="lineno"> 8812 </span><span class="spaces">      </span><span class="nottickedoff">implCopyConjM x ps i &gt;&gt;&gt; implPopM x (ValPerm_Conj ps)</span>
<span class="lineno"> 8813 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8814 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; proveVarAtomicImplUnfoldOrFail x ps mb_p</span></span>
<span class="lineno"> 8815 </span>
<span class="lineno"> 8816 </span>
<span class="lineno"> 8817 </span>-- | Prove @x:(p1 * ... * pn) |- x:(p1' * ... * pm')@ assuming that the LHS
<span class="lineno"> 8818 </span>-- conjunction is on the top of the stack, and push any leftover permissions for
<span class="lineno"> 8819 </span>-- @x@ back to the primary permissions for @x@.
<span class="lineno"> 8820 </span>--
<span class="lineno"> 8821 </span>-- The main complexity here is in dealing with the fact that both the left- and
<span class="lineno"> 8822 </span>-- right-hand sides could contain recursive permissions. We can't unfold
<span class="lineno"> 8823 </span>-- recursive permissions on both sides, because this could lead to an infinite
<span class="lineno"> 8824 </span>-- loop, where proving the unfolded implication depends on proving another copy
<span class="lineno"> 8825 </span>-- of the same implication. Instead, when we get to such a case, we have to pick
<span class="lineno"> 8826 </span>-- one side or the other to unfold, and then disallow unfolding the other side.
<span class="lineno"> 8827 </span>-- The exception is when we have an instance of the same recursive name on each
<span class="lineno"> 8828 </span>-- side, in which case we can prove the right-hand one from the left-hand one
<span class="lineno"> 8829 </span>-- and not unfold either side.
<span class="lineno"> 8830 </span>--
<span class="lineno"> 8831 </span>-- Additionally, the existence of recursive names on either side could be masked
<span class="lineno"> 8832 </span>-- by the existence of defined names that unfold to recursive names, so we have
<span class="lineno"> 8833 </span>-- to resolve all the defined names first.
<span class="lineno"> 8834 </span>--
<span class="lineno"> 8835 </span>-- Most of this machinery is actually handled by the 'proveVarImplH' cases for
<span class="lineno"> 8836 </span>-- recursive and defined names. Here, we just have to make sure to prove defined
<span class="lineno"> 8837 </span>-- names first, followed by recursive names and then other permissions.
<span class="lineno"> 8838 </span>proveVarConjImpl :: NuMatchingAny1 r =&gt; ExprVar a -&gt; [AtomicPerm a] -&gt;
<span class="lineno"> 8839 </span>                    Mb vars [AtomicPerm a] -&gt;
<span class="lineno"> 8840 </span>                    ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 8841 </span>
<span class="lineno"> 8842 </span>-- If we are done, we are done
<span class="lineno"> 8843 </span><span class="decl"><span class="nottickedoff">proveVarConjImpl x ps (mbMatch -&gt; [nuMP| [] |]) =</span>
<span class="lineno"> 8844 </span><span class="spaces">  </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps) &gt;&gt;&gt; introConjM x</span>
<span class="lineno"> 8845 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8846 </span><span class="spaces"></span><span class="nottickedoff">-- If there is a defined or recursive name on the right, prove it first,</span>
<span class="lineno"> 8847 </span><span class="spaces"></span><span class="nottickedoff">-- ensuring that we only choose recursive names if there are no defined ones,</span>
<span class="lineno"> 8848 </span><span class="spaces"></span><span class="nottickedoff">-- and that, in all cases, we choose a permission that is provable with the</span>
<span class="lineno"> 8849 </span><span class="spaces"></span><span class="nottickedoff">-- currently-set evars</span>
<span class="lineno"> 8850 </span><span class="spaces"></span><span class="nottickedoff">proveVarConjImpl x ps_lhs mb_ps =</span>
<span class="lineno"> 8851 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 8852 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch $</span>
<span class="lineno"> 8853 </span><span class="spaces">       </span><span class="nottickedoff">mbMapClWithVars</span>
<span class="lineno"> 8854 </span><span class="spaces">       </span><span class="nottickedoff">($(mkClosed</span>
<span class="lineno"> 8855 </span><span class="spaces">          </span><span class="nottickedoff">[| \unsetVarsBool ns ps -&gt;</span>
<span class="lineno"> 8856 </span><span class="spaces">            </span><span class="nottickedoff">let unsetVars = nameSetFromFlags ns unsetVarsBool in</span>
<span class="lineno"> 8857 </span><span class="spaces">            </span><span class="nottickedoff">findBestIndex</span>
<span class="lineno"> 8858 </span><span class="spaces">            </span><span class="nottickedoff">(\p -&gt; case isProvablePerm unsetVars Nothing (ValPerm_Conj1 p) of</span>
<span class="lineno"> 8859 </span><span class="spaces">                </span><span class="nottickedoff">rank | rank &gt; 0 &amp;&amp; isDefinedConjPerm p -&gt; isProvablePermMax + 2</span>
<span class="lineno"> 8860 </span><span class="spaces">                </span><span class="nottickedoff">rank | rank &gt; 0 &amp;&amp; isRecursiveConjPerm p -&gt; isProvablePermMax + 1</span>
<span class="lineno"> 8861 </span><span class="spaces">                </span><span class="nottickedoff">rank -&gt; rank)</span>
<span class="lineno"> 8862 </span><span class="spaces">            </span><span class="nottickedoff">ps |])</span>
<span class="lineno"> 8863 </span><span class="spaces">        </span><span class="nottickedoff">`clApply` toClosed (psubstUnsetVarsBool psubst)) mb_ps of</span>
<span class="lineno"> 8864 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Just mb_i |] -&gt;</span>
<span class="lineno"> 8865 </span><span class="spaces">      </span><span class="nottickedoff">let i = mbLift mb_i in</span>
<span class="lineno"> 8866 </span><span class="spaces">      </span><span class="nottickedoff">let mb_p = mbNth i mb_ps in</span>
<span class="lineno"> 8867 </span><span class="spaces">      </span><span class="nottickedoff">let mb_ps' = mbDeleteNth i mb_ps in</span>
<span class="lineno"> 8868 </span><span class="spaces">      </span><span class="nottickedoff">proveVarAtomicImpl x ps_lhs mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 8869 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplInt x (mbValPerm_Conj mb_ps') &gt;&gt;&gt;</span>
<span class="lineno"> 8870 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_ps' &quot;proveVarConjImpl&quot; &gt;&gt;&gt;= \ps' -&gt;</span>
<span class="lineno"> 8871 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_p &quot;proveVarConjImpl&quot; &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 8872 </span><span class="spaces">      </span><span class="nottickedoff">implInsertConjM x p ps' i</span>
<span class="lineno"> 8873 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Nothing |] -&gt;</span>
<span class="lineno"> 8874 </span><span class="spaces">      </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 8875 </span><span class="spaces">      </span><span class="nottickedoff">implFailM $ InsufficientVariablesError $</span>
<span class="lineno"> 8876 </span><span class="spaces">      </span><span class="nottickedoff">permPretty ppinfo (fmap ValPerm_Conj mb_ps)</span></span>
<span class="lineno"> 8877 </span>
<span class="lineno"> 8878 </span>
<span class="lineno"> 8879 </span>
<span class="lineno"> 8880 </span>----------------------------------------------------------------------
<span class="lineno"> 8881 </span>-- * Proving Permission Implications
<span class="lineno"> 8882 </span>----------------------------------------------------------------------
<span class="lineno"> 8883 </span>
<span class="lineno"> 8884 </span>-- | Prove @x:p'@, where @p@ may have existentially-quantified variables in
<span class="lineno"> 8885 </span>-- it. The \&quot;@Int@\&quot; suffix indicates that this call is internal to the
<span class="lineno"> 8886 </span>-- implication prover, similar to 'proveVarsImplAppendInt', meaning that this
<span class="lineno"> 8887 </span>-- version will not end lifetimes, which must be done at the top level.
<span class="lineno"> 8888 </span>proveVarImplInt :: NuMatchingAny1 r =&gt; ExprVar a -&gt; Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 8889 </span>                   ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 8890 </span><span class="decl"><span class="nottickedoff">proveVarImplInt x mb_p =</span>
<span class="lineno"> 8891 </span><span class="spaces">  </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= \ !p -&gt;</span>
<span class="lineno"> 8892 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt;</span>
<span class="lineno"> 8893 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt; pretty &quot;proveVarImpl:&quot; &lt;&gt; softline &lt;&gt; ppImpl i x p mb_p) &gt;&gt;&gt;</span>
<span class="lineno"> 8894 </span><span class="spaces">  </span><span class="nottickedoff">proveVarImplH x p mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 8895 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8896 </span><span class="spaces">  </span><span class="nottickedoff">-- Check that the top of the stack == mb_p</span>
<span class="lineno"> 8897 </span><span class="spaces">  </span><span class="nottickedoff">partialSubstForceM mb_p &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p_req -&gt;</span>
<span class="lineno"> 8898 </span><span class="spaces">  </span><span class="nottickedoff">getTopDistPerm x &gt;&gt;&gt;= \p_actual -&gt;</span>
<span class="lineno"> 8899 </span><span class="spaces">  </span><span class="nottickedoff">if p_req == p_actual then pure () else</span>
<span class="lineno"> 8900 </span><span class="spaces">    </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 8901 </span><span class="spaces">                 </span><span class="nottickedoff">pretty &quot;proveVarImpl: incorrect permission on top of the stack&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 8902 </span><span class="spaces">                 </span><span class="nottickedoff">pretty &quot;expected:&quot; &lt;+&gt; permPretty i p_req &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 8903 </span><span class="spaces">                 </span><span class="nottickedoff">pretty &quot;actual:&quot; &lt;+&gt; permPretty i p_actual) &gt;&gt;&gt;= error</span></span>
<span class="lineno"> 8904 </span>
<span class="lineno"> 8905 </span>-- | Prove @x:p'@ assuming that the primary permissions for @x@ have all been
<span class="lineno"> 8906 </span>-- pushed to the top of the stack and are equal to @p@. Pop the remaining
<span class="lineno"> 8907 </span>-- permissions for @x@ back to its primary permission when we are finished.
<span class="lineno"> 8908 </span>proveVarImplH :: NuMatchingAny1 r =&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 8909 </span>                 Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 8910 </span>                 ImplM vars s r (ps :&gt; a) (ps :&gt; a) ()
<span class="lineno"> 8911 </span><span class="decl"><span class="nottickedoff">proveVarImplH x p mb_p = case (p, mbMatch mb_p) of</span>
<span class="lineno"> 8912 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8913 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove an empty conjunction trivially</span>
<span class="lineno"> 8914 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Conj [] |]) -&gt; recombinePerm x p &gt;&gt;&gt; introConjM x</span>
<span class="lineno"> 8915 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8916 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove x:eq(e) by calling proveVarEq; note that we do not eliminate</span>
<span class="lineno"> 8917 </span><span class="spaces">  </span><span class="nottickedoff">-- disjunctive permissions first because some trivial equalities do not require</span>
<span class="lineno"> 8918 </span><span class="spaces">  </span><span class="nottickedoff">-- any eq permissions on the left, and we do not eliminate equalities on the</span>
<span class="lineno"> 8919 </span><span class="spaces">  </span><span class="nottickedoff">-- left first because that may be the equality we are trying to prove!</span>
<span class="lineno"> 8920 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Eq e |]) -&gt; recombinePerm x p &gt;&gt;&gt; proveVarEq x e</span>
<span class="lineno"> 8921 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8922 </span><span class="spaces">  </span><span class="nottickedoff">-- Eliminate any disjunctions and existentials on the left</span>
<span class="lineno"> 8923 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Or _ _, _) -&gt;</span>
<span class="lineno"> 8924 </span><span class="spaces">    </span><span class="nottickedoff">elimOrsExistsM x &gt;&gt;&gt;= \ !p' -&gt; proveVarImplH x p' mb_p</span>
<span class="lineno"> 8925 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8926 </span><span class="spaces">  </span><span class="nottickedoff">-- Eliminate any disjunctions and existentials on the left</span>
<span class="lineno"> 8927 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Exists _, _) -&gt;</span>
<span class="lineno"> 8928 </span><span class="spaces">    </span><span class="nottickedoff">elimOrsExistsM x &gt;&gt;&gt;= \ !p' -&gt; proveVarImplH x p' mb_p</span>
<span class="lineno"> 8929 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8930 </span><span class="spaces">  </span><span class="nottickedoff">-- Eliminate an equality permission for a variable on the left, i.e., prove x:p</span>
<span class="lineno"> 8931 </span><span class="spaces">  </span><span class="nottickedoff">-- from x:eq(y) by first proving y:p and then casting</span>
<span class="lineno"> 8932 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq (PExpr_Var y), _) -&gt;</span>
<span class="lineno"> 8933 </span><span class="spaces">    </span><span class="nottickedoff">introEqCopyM x (PExpr_Var y) &gt;&gt;&gt;</span>
<span class="lineno"> 8934 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt;</span>
<span class="lineno"> 8935 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt y mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 8936 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_p &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p' -&gt;</span>
<span class="lineno"> 8937 </span><span class="spaces">    </span><span class="nottickedoff">introCastM x y p'</span>
<span class="lineno"> 8938 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8939 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove x:eq(y &amp;+ off) |- x:p by proving y:p@off and then casting</span>
<span class="lineno"> 8940 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq e@(PExpr_LLVMOffset y off), _) -&gt;</span>
<span class="lineno"> 8941 </span><span class="spaces">      </span><span class="nottickedoff">introEqCopyM x e &gt;&gt;&gt; recombinePerm x p &gt;&gt;&gt;</span>
<span class="lineno"> 8942 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplInt y (fmap (offsetLLVMPerm off) mb_p) &gt;&gt;&gt;</span>
<span class="lineno"> 8943 </span><span class="spaces">      </span><span class="nottickedoff">partialSubstForceM mb_p &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p_r -&gt;</span>
<span class="lineno"> 8944 </span><span class="spaces">      </span><span class="nottickedoff">castLLVMPtrM y (offsetLLVMPerm off p_r) off x</span>
<span class="lineno"> 8945 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8946 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove x:(p1 \/ p2) by trying to prove x:p1 and x:p2 in two branches</span>
<span class="lineno"> 8947 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Or mb_p1 mb_p2 |]) -&gt;</span>
<span class="lineno"> 8948 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt;</span>
<span class="lineno"> 8949 </span><span class="spaces">    </span><span class="nottickedoff">implCatchM &quot;proveVarImplH&quot; (ColonPair x mb_p)</span>
<span class="lineno"> 8950 </span><span class="spaces">    </span><span class="nottickedoff">(proveVarImplInt x mb_p1 &gt;&gt;&gt;</span>
<span class="lineno"> 8951 </span><span class="spaces">     </span><span class="nottickedoff">partialSubstForceM mb_p1 &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p1 -&gt;</span>
<span class="lineno"> 8952 </span><span class="spaces">     </span><span class="nottickedoff">partialSubstForceM mb_p2 &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p2 -&gt;</span>
<span class="lineno"> 8953 </span><span class="spaces">     </span><span class="nottickedoff">introOrLM x p1 p2)</span>
<span class="lineno"> 8954 </span><span class="spaces">    </span><span class="nottickedoff">(proveVarImplInt x mb_p2 &gt;&gt;&gt;</span>
<span class="lineno"> 8955 </span><span class="spaces">     </span><span class="nottickedoff">partialSubstForceM mb_p1 &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p1 -&gt;</span>
<span class="lineno"> 8956 </span><span class="spaces">     </span><span class="nottickedoff">partialSubstForceM mb_p2 &quot;proveVarImpl&quot; &gt;&gt;&gt;= \p2 -&gt;</span>
<span class="lineno"> 8957 </span><span class="spaces">     </span><span class="nottickedoff">introOrRM x p1 p2)</span>
<span class="lineno"> 8958 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8959 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove x:exists (z:tp).p by proving x:p in an extended vars context</span>
<span class="lineno"> 8960 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Exists mb_p' |]) -&gt;</span>
<span class="lineno"> 8961 </span><span class="spaces">    </span><span class="nottickedoff">withExtVarsM (proveVarImplH x p (mbCombine RL.typeCtxProxies mb_p')) &gt;&gt;&gt;= \((), e) -&gt;</span>
<span class="lineno"> 8962 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_p' &quot;proveVarImpl&quot; &gt;&gt;&gt;=</span>
<span class="lineno"> 8963 </span><span class="spaces">    </span><span class="nottickedoff">introExistsM x e</span>
<span class="lineno"> 8964 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8965 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args1,e1&gt; |- P&lt;args2,e2&gt; for the same reachability permission,</span>
<span class="lineno"> 8966 </span><span class="spaces">  </span><span class="nottickedoff">-- try to prove the RHS by either reflexivity, meaning x:eq(e2), or</span>
<span class="lineno"> 8967 </span><span class="spaces">  </span><span class="nottickedoff">-- transitivity, meaning e1:P&lt;args2,e2&gt;</span>
<span class="lineno"> 8968 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named npn args1 off, [nuMP| ValPerm_Named mb_npn mb_args2 mb_off |])</span>
<span class="lineno"> 8969 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq npn (mbLift mb_npn)</span>
<span class="lineno"> 8970 </span><span class="spaces">    </span><span class="nottickedoff">, mbLift (fmap (offsetsEq off) mb_off)</span>
<span class="lineno"> 8971 </span><span class="spaces">    </span><span class="nottickedoff">, RecursiveSortRepr _ TrueRepr &lt;- namedPermNameSort npn</span>
<span class="lineno"> 8972 </span><span class="spaces">    </span><span class="nottickedoff">, NameReachConstr &lt;- namedPermNameReachConstr npn</span>
<span class="lineno"> 8973 </span><span class="spaces">    </span><span class="nottickedoff">, PExprs_Cons args1_pre e1 &lt;- args1</span>
<span class="lineno"> 8974 </span><span class="spaces">    </span><span class="nottickedoff">, [nuMP| PExprs_Cons mb_args2_pre mb_e2 |] &lt;- mbMatch mb_args2 -&gt;</span>
<span class="lineno"> 8975 </span><span class="spaces">      </span><span class="nottickedoff">implCatchM &quot;proveVarImplH&quot; (ColonPair x mb_p)</span>
<span class="lineno"> 8976 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8977 </span><span class="spaces">      </span><span class="nottickedoff">-- Reflexivity branch: pop x:P&lt;...&gt;, prove x:eq(e), and use reflexivity</span>
<span class="lineno"> 8978 </span><span class="spaces">      </span><span class="nottickedoff">(recombinePerm x p &gt;&gt;&gt; proveVarImplInt x (mbValPerm_Eq mb_e2) &gt;&gt;&gt;</span>
<span class="lineno"> 8979 </span><span class="spaces">       </span><span class="nottickedoff">partialSubstForceM mb_args2 &quot;proveVarImpl&quot; &gt;&gt;&gt;= \args2 -&gt;</span>
<span class="lineno"> 8980 </span><span class="spaces">        </span><span class="nottickedoff">implReachabilityReflM x npn args2 off)</span>
<span class="lineno"> 8981 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 8982 </span><span class="spaces">      </span><span class="nottickedoff">-- Transitivity branch: copy x:P&lt;args1,e1&gt; if possible, equalize the</span>
<span class="lineno"> 8983 </span><span class="spaces">      </span><span class="nottickedoff">-- arguments by proving x:P&lt;args2,e1&gt;, introduce variable y:eq(e1), prove</span>
<span class="lineno"> 8984 </span><span class="spaces">      </span><span class="nottickedoff">-- y:P&lt;args2,e2&gt;, and then finally use transitivity</span>
<span class="lineno"> 8985 </span><span class="spaces">      </span><span class="nottickedoff">(implMaybeCopyPopM x p &gt;&gt;&gt;</span>
<span class="lineno"> 8986 </span><span class="spaces">       </span><span class="nottickedoff">proveNamedArgs x npn args1 off (fmap (:&gt;: e1) mb_args2_pre) &gt;&gt;&gt;</span>
<span class="lineno"> 8987 </span><span class="spaces">       </span><span class="nottickedoff">(case e1 of</span>
<span class="lineno"> 8988 </span><span class="spaces">           </span><span class="nottickedoff">PExpr_Var y -&gt; pure y</span>
<span class="lineno"> 8989 </span><span class="spaces">           </span><span class="nottickedoff">_  -&gt;</span>
<span class="lineno"> 8990 </span><span class="spaces">             </span><span class="nottickedoff">-- If e1 is not a variable, bind a fresh variable y:eq(e1), then</span>
<span class="lineno"> 8991 </span><span class="spaces">             </span><span class="nottickedoff">-- cast x:P&lt;args1,e1&gt; to x:P&lt;args1,y&gt;</span>
<span class="lineno"> 8992 </span><span class="spaces">             </span><span class="nottickedoff">implGetVarType x &gt;&gt;&gt;= \tp -&gt;</span>
<span class="lineno"> 8993 </span><span class="spaces">             </span><span class="nottickedoff">implLetBindVar tp e1 &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 8994 </span><span class="spaces">             </span><span class="nottickedoff">proveEqCast x (\z -&gt; ValPerm_Named npn (args1_pre :&gt;: z) off) e1</span>
<span class="lineno"> 8995 </span><span class="spaces">             </span><span class="nottickedoff">(fmap (const $ PExpr_Var y) mb_npn) &gt;&gt;&gt;</span>
<span class="lineno"> 8996 </span><span class="spaces">             </span><span class="nottickedoff">pure y) &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 8997 </span><span class="spaces">       </span><span class="nottickedoff">proveVarImplInt y mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 8998 </span><span class="spaces">       </span><span class="nottickedoff">partialSubstForceM mb_args2 &quot;proveVarImpl&quot; &gt;&gt;&gt;= \args2 -&gt;</span>
<span class="lineno"> 8999 </span><span class="spaces">       </span><span class="nottickedoff">implReachabilityTransM x npn args2 off y)</span>
<span class="lineno"> 9000 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9001 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args1&gt; |- P&lt;args2&gt; for the same named permission, try to</span>
<span class="lineno"> 9002 </span><span class="spaces">  </span><span class="nottickedoff">-- equalize the arguments and the offsets using proveNamedArgs. Note that we</span>
<span class="lineno"> 9003 </span><span class="spaces">  </span><span class="nottickedoff">-- currently are *not* solving for offsets on the right, meaning that</span>
<span class="lineno"> 9004 </span><span class="spaces">  </span><span class="nottickedoff">-- proveVarImplInt will fail for offsets with existential variables in them.</span>
<span class="lineno"> 9005 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named npn args off, [nuMP| ValPerm_Named mb_npn mb_args mb_off |])</span>
<span class="lineno"> 9006 </span><span class="spaces">    </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;- testNamedPermNameEq npn (mbLift mb_npn)</span>
<span class="lineno"> 9007 </span><span class="spaces">    </span><span class="nottickedoff">, mbLift (fmap (offsetsEq off) mb_off) -&gt;</span>
<span class="lineno"> 9008 </span><span class="spaces">      </span><span class="nottickedoff">implMaybeCopyPopM x p &gt;&gt;&gt;</span>
<span class="lineno"> 9009 </span><span class="spaces">      </span><span class="nottickedoff">proveNamedArgs x npn args off mb_args</span>
<span class="lineno"> 9010 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9011 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving x:p1 * ... * pn |- P&lt;args&gt;@off where P&lt;args'&gt;@off for some args'</span>
<span class="lineno"> 9012 </span><span class="spaces">  </span><span class="nottickedoff">-- occurs as one of the pi, then reduce to the above case</span>
<span class="lineno"> 9013 </span><span class="spaces">  </span><span class="nottickedoff">--</span>
<span class="lineno"> 9014 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: if P is a defined permission, then it is possible that we can't prove</span>
<span class="lineno"> 9015 </span><span class="spaces">  </span><span class="nottickedoff">-- P&lt;args'&gt; |- P&lt;args&gt; but could still prove x:p1 * ... |- P&lt;args&gt; by unfolding</span>
<span class="lineno"> 9016 </span><span class="spaces">  </span><span class="nottickedoff">-- P, so we should also check that args' is compatible in some way with args</span>
<span class="lineno"> 9017 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj ps, [nuMP| ValPerm_Named mb_npn mb_args mb_off |])</span>
<span class="lineno"> 9018 </span><span class="spaces">    </span><span class="nottickedoff">| npn &lt;- mbLift mb_npn</span>
<span class="lineno"> 9019 </span><span class="spaces">    </span><span class="nottickedoff">, TrueRepr &lt;- nameIsConjRepr npn</span>
<span class="lineno"> 9020 </span><span class="spaces">    </span><span class="nottickedoff">, (i, (args, off)):_ &lt;-</span>
<span class="lineno"> 9021 </span><span class="spaces">        </span><span class="nottickedoff">findMaybeIndices (\case</span>
<span class="lineno"> 9022 </span><span class="spaces">                             </span><span class="nottickedoff">Perm_NamedConj npn' args off</span>
<span class="lineno"> 9023 </span><span class="spaces">                               </span><span class="nottickedoff">| Just (Refl, Refl, Refl) &lt;-</span>
<span class="lineno"> 9024 </span><span class="spaces">                                   </span><span class="nottickedoff">testNamedPermNameEq npn npn'</span>
<span class="lineno"> 9025 </span><span class="spaces">                               </span><span class="nottickedoff">, mbLift (fmap (offsetsEq off) mb_off) -&gt;</span>
<span class="lineno"> 9026 </span><span class="spaces">                                 </span><span class="nottickedoff">Just (args, off)</span>
<span class="lineno"> 9027 </span><span class="spaces">                             </span><span class="nottickedoff">_ -&gt; Nothing) ps -&gt;</span>
<span class="lineno"> 9028 </span><span class="spaces">      </span><span class="nottickedoff">implGetPopConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 9029 </span><span class="spaces">      </span><span class="nottickedoff">implNamedFromConjM x npn args off &gt;&gt;&gt;</span>
<span class="lineno"> 9030 </span><span class="spaces">      </span><span class="nottickedoff">proveNamedArgs x npn args off mb_args</span>
<span class="lineno"> 9031 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9032 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args&gt; where P is defined, unfold P</span>
<span class="lineno"> 9033 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Named mb_npn _ _ |])</span>
<span class="lineno"> 9034 </span><span class="spaces">    </span><span class="nottickedoff">| DefinedSortRepr _ &lt;- namedPermNameSort $ mbLift mb_npn -&gt;</span>
<span class="lineno"> 9035 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplFoldRight x p mb_p</span>
<span class="lineno"> 9036 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9037 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args1&gt; |- p where P is defined, unfold P</span>
<span class="lineno"> 9038 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named npn _ _, _)</span>
<span class="lineno"> 9039 </span><span class="spaces">    </span><span class="nottickedoff">| DefinedSortRepr _ &lt;- namedPermNameSort npn -&gt;</span>
<span class="lineno"> 9040 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplUnfoldLeft x p mb_p Nothing</span>
<span class="lineno"> 9041 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9042 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving x:p1 * ... * P&lt;args1&gt; * ... |- p where P is defined, unfold P</span>
<span class="lineno"> 9043 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj ps, _)</span>
<span class="lineno"> 9044 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex isDefinedConjPerm ps -&gt;</span>
<span class="lineno"> 9045 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplUnfoldLeft x p mb_p (Just i)</span>
<span class="lineno"> 9046 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9047 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P1&lt;args1&gt; |- P2&lt;args2&gt; where both P1 and P2 are recursive, try</span>
<span class="lineno"> 9048 </span><span class="spaces">  </span><span class="nottickedoff">-- unfolding P1 or P2, depending on the recursion flags</span>
<span class="lineno"> 9049 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named npn1 _ _, [nuMP| ValPerm_Named mb_npn2 _ _ |])</span>
<span class="lineno"> 9050 </span><span class="spaces">    </span><span class="nottickedoff">| RecursiveSortRepr _ _ &lt;- namedPermNameSort npn1</span>
<span class="lineno"> 9051 </span><span class="spaces">    </span><span class="nottickedoff">, RecursiveSortRepr _ _ &lt;- namedPermNameSort $ mbLift mb_npn2 -&gt;</span>
<span class="lineno"> 9052 </span><span class="spaces">      </span><span class="nottickedoff">implRecFlagCaseM</span>
<span class="lineno"> 9053 </span><span class="spaces">      </span><span class="nottickedoff">&quot;proveVarImplH&quot; (ColonPair x mb_p)</span>
<span class="lineno"> 9054 </span><span class="spaces">      </span><span class="nottickedoff">(proveVarImplFoldRight x p mb_p)</span>
<span class="lineno"> 9055 </span><span class="spaces">      </span><span class="nottickedoff">(proveVarImplUnfoldLeft x p mb_p Nothing)</span>
<span class="lineno"> 9056 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9057 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving x:p1 * ... |- P&lt;args&gt; where both P and at least one of the pi are</span>
<span class="lineno"> 9058 </span><span class="spaces">  </span><span class="nottickedoff">-- recursive, try unfolding P or the LHS, depending on the recursion flags. Note</span>
<span class="lineno"> 9059 </span><span class="spaces">  </span><span class="nottickedoff">-- that there are no defined perms on the LHS at this point because that would</span>
<span class="lineno"> 9060 </span><span class="spaces">  </span><span class="nottickedoff">-- have been caught by one of the above cases.</span>
<span class="lineno"> 9061 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj ps, [nuMP| ValPerm_Named mb_npn _ _ |])</span>
<span class="lineno"> 9062 </span><span class="spaces">    </span><span class="nottickedoff">| Just i &lt;- findIndex isRecursiveConjPerm ps</span>
<span class="lineno"> 9063 </span><span class="spaces">    </span><span class="nottickedoff">, RecursiveSortRepr _ _ &lt;- namedPermNameSort $ mbLift mb_npn -&gt;</span>
<span class="lineno"> 9064 </span><span class="spaces">      </span><span class="nottickedoff">implRecFlagCaseM</span>
<span class="lineno"> 9065 </span><span class="spaces">      </span><span class="nottickedoff">&quot;proveVarImplH&quot; (ColonPair x mb_p)</span>
<span class="lineno"> 9066 </span><span class="spaces">      </span><span class="nottickedoff">(proveVarImplUnfoldLeft x p mb_p (Just i))</span>
<span class="lineno"> 9067 </span><span class="spaces">      </span><span class="nottickedoff">(proveVarImplFoldRight x p mb_p)</span>
<span class="lineno"> 9068 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9069 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args&gt; where P is recursive and we have gotten to this case, we</span>
<span class="lineno"> 9070 </span><span class="spaces">  </span><span class="nottickedoff">-- know there are no recursive perms on the left, so unfold P</span>
<span class="lineno"> 9071 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Named mb_npn _ _ |])</span>
<span class="lineno"> 9072 </span><span class="spaces">    </span><span class="nottickedoff">| RecursiveSortRepr _ _ &lt;- namedPermNameSort $ mbLift mb_npn -&gt;</span>
<span class="lineno"> 9073 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplFoldRight x p mb_p</span>
<span class="lineno"> 9074 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9075 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args&gt; |- p1 * ... * pn for a conjoinable P, then change the LHS</span>
<span class="lineno"> 9076 </span><span class="spaces">  </span><span class="nottickedoff">-- to a conjunction and recurse</span>
<span class="lineno"> 9077 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named npn args off, _)</span>
<span class="lineno"> 9078 </span><span class="spaces">    </span><span class="nottickedoff">| TrueRepr &lt;- nameIsConjRepr npn -&gt;</span>
<span class="lineno"> 9079 </span><span class="spaces">      </span><span class="nottickedoff">implNamedToConjM x npn args off &gt;&gt;&gt;</span>
<span class="lineno"> 9080 </span><span class="spaces">      </span><span class="nottickedoff">proveVarImplH x (ValPerm_Conj1 $ Perm_NamedConj npn args off) mb_p</span>
<span class="lineno"> 9081 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9082 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving P&lt;args&gt; |- p1 * ... * pn for a non-conjoinable recursive P, then</span>
<span class="lineno"> 9083 </span><span class="spaces">  </span><span class="nottickedoff">-- we unfold P because we will have to at some point to prove a conjunction</span>
<span class="lineno"> 9084 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Named _ _ _, _) -&gt;</span>
<span class="lineno"> 9085 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplUnfoldLeft x p mb_p Nothing</span>
<span class="lineno"> 9086 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9087 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9088 </span><span class="spaces">  </span><span class="nottickedoff">{- FIXME: This is an example of how we used embedMbImplM to prove the body</span>
<span class="lineno"> 9089 </span><span class="spaces">     </span><span class="nottickedoff">of one mu from another; remove it when we have used it for arrays</span>
<span class="lineno"> 9090 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Mu p_body, [nuMP| ValPerm_Mu mb_p'_body |]) -&gt;</span>
<span class="lineno"> 9091 </span><span class="spaces">    </span><span class="nottickedoff">partialSubstForceM mb_p'_body</span>
<span class="lineno"> 9092 </span><span class="spaces">    </span><span class="nottickedoff">&quot;proveVarImpl: incomplete psubst: implMu&quot; &gt;&gt;&gt;= \p'_body -&gt;</span>
<span class="lineno"> 9093 </span><span class="spaces">    </span><span class="nottickedoff">embedMbImplM (fmap (\p -&gt; distPermSet $ distPerms1 x p) p_body)</span>
<span class="lineno"> 9094 </span><span class="spaces">    </span><span class="nottickedoff">(mbMap2 (\p p' -&gt; proveVarImplH x p (emptyMb p') &gt;&gt;&gt; pure Refl)</span>
<span class="lineno"> 9095 </span><span class="spaces">     </span><span class="nottickedoff">p_body p'_body) &gt;&gt;&gt;= \mb_impl -&gt;</span>
<span class="lineno"> 9096 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_Mu x p_body p'_body mb_impl)</span>
<span class="lineno"> 9097 </span><span class="spaces">  </span><span class="nottickedoff">-}</span>
<span class="lineno"> 9098 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9099 </span><span class="spaces">  </span><span class="nottickedoff">-- If x:eq(LLVMword(e)) then we cannot prove any pointer permissions for it</span>
<span class="lineno"> 9100 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq (PExpr_LLVMWord _), [nuMP| ValPerm_Conj _ |]) -&gt;</span>
<span class="lineno"> 9101 </span><span class="spaces">    </span><span class="nottickedoff">implFailVarM &quot;proveVarImplH&quot; x p mb_p</span>
<span class="lineno"> 9102 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9103 </span><span class="spaces">  </span><span class="nottickedoff">-- If x:eq(struct(e1,...,en)) then we eliminate to x:struct(eq(e1),...,eq(en))</span>
<span class="lineno"> 9104 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq (PExpr_Struct exprs), [nuMP| ValPerm_Conj _ |]) -&gt;</span>
<span class="lineno"> 9105 </span><span class="spaces">    </span><span class="nottickedoff">implSimplM Proxy (SImpl_StructEqToPerm x exprs) &gt;&gt;&gt;</span>
<span class="lineno"> 9106 </span><span class="spaces">    </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj1 $ Perm_Struct $</span>
<span class="lineno"> 9107 </span><span class="spaces">                </span><span class="nottickedoff">RL.map ValPerm_Eq $ exprsToRAssign exprs) &gt;&gt;&gt;</span>
<span class="lineno"> 9108 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt x mb_p</span>
<span class="lineno"> 9109 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9110 </span><span class="spaces">  </span><span class="nottickedoff">-- If proving a function permission for an x we know equals a constant function</span>
<span class="lineno"> 9111 </span><span class="spaces">  </span><span class="nottickedoff">-- handle f, look up the function permission for f</span>
<span class="lineno"> 9112 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq (PExpr_Fun f), [nuMP| ValPerm_Conj [Perm_Fun mb_fun_perm] |]) -&gt;</span>
<span class="lineno"> 9113 </span><span class="spaces">    </span><span class="nottickedoff">use implStatePermEnv &gt;&gt;&gt;= \env -&gt;</span>
<span class="lineno"> 9114 </span><span class="spaces">    </span><span class="nottickedoff">case lookupFunPerm env f of</span>
<span class="lineno"> 9115 </span><span class="spaces">      </span><span class="nottickedoff">Just (SomeFunPerm fun_perm, ident)</span>
<span class="lineno"> 9116 </span><span class="spaces">        </span><span class="nottickedoff">| [nuMP| Just (Refl,Refl,Refl, Refl) |] &lt;-</span>
<span class="lineno"> 9117 </span><span class="spaces">            </span><span class="nottickedoff">mbMatch $ fmap (funPermEq4 fun_perm) mb_fun_perm -&gt;</span>
<span class="lineno"> 9118 </span><span class="spaces">          </span><span class="nottickedoff">introEqCopyM x (PExpr_Fun f) &gt;&gt;&gt;</span>
<span class="lineno"> 9119 </span><span class="spaces">          </span><span class="nottickedoff">recombinePerm x p &gt;&gt;&gt;</span>
<span class="lineno"> 9120 </span><span class="spaces">          </span><span class="nottickedoff">implSimplM Proxy (SImpl_ConstFunPerm x f fun_perm ident)</span>
<span class="lineno"> 9121 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; implFailVarM &quot;proveVarImplH&quot; x p mb_p</span>
<span class="lineno"> 9122 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9123 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Eq _, [nuMP| ValPerm_Conj _ |]) -&gt;</span>
<span class="lineno"> 9124 </span><span class="spaces">    </span><span class="nottickedoff">implFailVarM &quot;proveVarImplH&quot; x p mb_p</span>
<span class="lineno"> 9125 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME HERE: are there other x:eq(e) |- x:pps cases?</span>
<span class="lineno"> 9126 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9127 </span><span class="spaces">  </span><span class="nottickedoff">-- For conjunction |- conjunction, call proveVarConjImpl</span>
<span class="lineno"> 9128 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Conj ps, [nuMP| ValPerm_Conj mb_ps |]) -&gt;</span>
<span class="lineno"> 9129 </span><span class="spaces">    </span><span class="nottickedoff">proveVarConjImpl x ps mb_ps</span>
<span class="lineno"> 9130 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9131 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove x:p |- x:z@off for existential variable z by setting z = p</span>
<span class="lineno"> 9132 </span><span class="spaces">  </span><span class="nottickedoff">(_, [nuMP| ValPerm_Var z mb_off |])</span>
<span class="lineno"> 9133 </span><span class="spaces">    </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP z -&gt;</span>
<span class="lineno"> 9134 </span><span class="spaces">      </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 9135 </span><span class="spaces">      </span><span class="nottickedoff">case (partialSubst psubst mb_off, psubstLookup psubst memb) of</span>
<span class="lineno"> 9136 </span><span class="spaces">        </span><span class="nottickedoff">(Just off, Just (PExpr_ValPerm p')) -&gt;</span>
<span class="lineno"> 9137 </span><span class="spaces">          </span><span class="nottickedoff">let mb_p' = fmap (const $ offsetPerm off p') z in</span>
<span class="lineno"> 9138 </span><span class="spaces">          </span><span class="nottickedoff">implTraceM (\i -&gt; pretty &quot;proveVarImplH:&quot; &lt;&gt; softline &lt;&gt; ppImpl i x p mb_p') &gt;&gt;&gt;</span>
<span class="lineno"> 9139 </span><span class="spaces">          </span><span class="nottickedoff">proveVarImplH x p mb_p'</span>
<span class="lineno"> 9140 </span><span class="spaces">        </span><span class="nottickedoff">(Just off, Just (PExpr_Var z')) -&gt;</span>
<span class="lineno"> 9141 </span><span class="spaces">          </span><span class="nottickedoff">let mb_p' = fmap (const $ ValPerm_Var z' off) z in</span>
<span class="lineno"> 9142 </span><span class="spaces">          </span><span class="nottickedoff">implTraceM (\i -&gt; pretty &quot;proveVarImplH:&quot; &lt;&gt; softline &lt;&gt; ppImpl i x p mb_p') &gt;&gt;&gt;</span>
<span class="lineno"> 9143 </span><span class="spaces">          </span><span class="nottickedoff">proveVarImplH x p mb_p'</span>
<span class="lineno"> 9144 </span><span class="spaces">        </span><span class="nottickedoff">(Just off, Nothing) -&gt;</span>
<span class="lineno"> 9145 </span><span class="spaces">          </span><span class="nottickedoff">setVarM memb (PExpr_ValPerm $ offsetPerm (negatePermOffset off) p) &gt;&gt;&gt;</span>
<span class="lineno"> 9146 </span><span class="spaces">          </span><span class="nottickedoff">implMaybeCopyPopM x p</span>
<span class="lineno"> 9147 </span><span class="spaces">        </span><span class="nottickedoff">(Nothing, _) -&gt;</span>
<span class="lineno"> 9148 </span><span class="spaces">          </span><span class="nottickedoff">implFailVarM &quot;proveVarImplH&quot; x p mb_p</span>
<span class="lineno"> 9149 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9150 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove x:z@off |- x:z@off for variable z by reflexivity</span>
<span class="lineno"> 9151 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_Var z off, [nuMP| ValPerm_Var mb_z' mb_off |])</span>
<span class="lineno"> 9152 </span><span class="spaces">    </span><span class="nottickedoff">| Right z' &lt;- mbNameBoundP mb_z'</span>
<span class="lineno"> 9153 </span><span class="spaces">    </span><span class="nottickedoff">, z' == z</span>
<span class="lineno"> 9154 </span><span class="spaces">    </span><span class="nottickedoff">, mbLift (fmap (offsetsEq off) mb_off) -&gt; pure ()</span>
<span class="lineno"> 9155 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9156 </span><span class="spaces">  </span><span class="nottickedoff">-- Fail if nothing else matched</span>
<span class="lineno"> 9157 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt; implFailVarM &quot;proveVarImplH&quot; x p mb_p</span></span>
<span class="lineno"> 9158 </span>
<span class="lineno"> 9159 </span>
<span class="lineno"> 9160 </span>----------------------------------------------------------------------
<span class="lineno"> 9161 </span>-- * Proving Permission Implications for Existential Variables
<span class="lineno"> 9162 </span>----------------------------------------------------------------------
<span class="lineno"> 9163 </span>
<span class="lineno"> 9164 </span>-- | Prove an existentially-quantified permission where the variable holding the
<span class="lineno"> 9165 </span>-- permission could itself be existentially-quantified. If that variable is
<span class="lineno"> 9166 </span>-- existentially quantified, be sure to instantiate it with a variable that is
<span class="lineno"> 9167 </span>-- locally bound inside the current implication proof, i.e., that is returned by
<span class="lineno"> 9168 </span>-- 'getVarVarM'. Return the variable that was used.
<span class="lineno"> 9169 </span>proveExVarImpl :: NuMatchingAny1 r =&gt; PartialSubst vars -&gt; Mb vars (Name tp) -&gt;
<span class="lineno"> 9170 </span>                  Mb vars (ValuePerm tp) -&gt;
<span class="lineno"> 9171 </span>                  ImplM vars s r (ps :&gt; tp) ps (Name tp)
<span class="lineno"> 9172 </span>
<span class="lineno"> 9173 </span>-- If the variable is a free variable, just call proveVarImpl
<span class="lineno"> 9174 </span><span class="decl"><span class="nottickedoff">proveExVarImpl _psubst mb_x mb_p</span>
<span class="lineno"> 9175 </span><span class="spaces">  </span><span class="nottickedoff">| Right n &lt;- mbNameBoundP mb_x</span>
<span class="lineno"> 9176 </span><span class="spaces">  </span><span class="nottickedoff">= proveVarImplInt n mb_p &gt;&gt;&gt; pure n</span>
<span class="lineno"> 9177 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9178 </span><span class="spaces"></span><span class="nottickedoff">-- If the variable is instantiated to a non-variable expression, bind a fresh</span>
<span class="lineno"> 9179 </span><span class="spaces"></span><span class="nottickedoff">-- variable for it and then call proveVarImpl</span>
<span class="lineno"> 9180 </span><span class="spaces"></span><span class="nottickedoff">proveExVarImpl psubst mb_x mb_p</span>
<span class="lineno"> 9181 </span><span class="spaces">  </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_x</span>
<span class="lineno"> 9182 </span><span class="spaces">  </span><span class="nottickedoff">, Just _ &lt;- psubstLookup psubst memb =</span>
<span class="lineno"> 9183 </span><span class="spaces">    </span><span class="nottickedoff">getVarVarM memb &gt;&gt;&gt;= \n -&gt;</span>
<span class="lineno"> 9184 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImplInt n mb_p &gt;&gt;&gt; pure n</span>
<span class="lineno"> 9185 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9186 </span><span class="spaces"></span><span class="nottickedoff">-- Special case: if proving an LLVM frame permission, look for an LLVM frame in</span>
<span class="lineno"> 9187 </span><span class="spaces"></span><span class="nottickedoff">-- the current context and use it</span>
<span class="lineno"> 9188 </span><span class="spaces"></span><span class="nottickedoff">proveExVarImpl _ mb_x mb_p@(mbMatch -&gt; [nuMP| ValPerm_Conj [Perm_LLVMFrame _] |])</span>
<span class="lineno"> 9189 </span><span class="spaces">  </span><span class="nottickedoff">| Left memb &lt;- mbNameBoundP mb_x =</span>
<span class="lineno"> 9190 </span><span class="spaces">    </span><span class="nottickedoff">getExVarType memb &gt;&gt;&gt;= \x_tp -&gt;</span>
<span class="lineno"> 9191 </span><span class="spaces">    </span><span class="nottickedoff">implFindVarOfType x_tp &gt;&gt;&gt;= \maybe_n -&gt;</span>
<span class="lineno"> 9192 </span><span class="spaces">    </span><span class="nottickedoff">case maybe_n of</span>
<span class="lineno"> 9193 </span><span class="spaces">      </span><span class="nottickedoff">Just n -&gt;</span>
<span class="lineno"> 9194 </span><span class="spaces">        </span><span class="nottickedoff">-- NOTE: we still need to call getVarVarM to get a locally-bound var</span>
<span class="lineno"> 9195 </span><span class="spaces">        </span><span class="nottickedoff">setVarM memb (PExpr_Var n) &gt;&gt;&gt;</span>
<span class="lineno"> 9196 </span><span class="spaces">        </span><span class="nottickedoff">getVarVarM memb &gt;&gt;&gt;= \n' -&gt;</span>
<span class="lineno"> 9197 </span><span class="spaces">        </span><span class="nottickedoff">proveVarImplInt n' mb_p &gt;&gt;&gt; pure n'</span>
<span class="lineno"> 9198 </span><span class="spaces">      </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 9199 </span><span class="spaces">        </span><span class="nottickedoff">implFailM NoFrameInScopeError</span>
<span class="lineno"> 9200 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9201 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise we fail</span>
<span class="lineno"> 9202 </span><span class="spaces"></span><span class="nottickedoff">proveExVarImpl _ mb_x mb_p =</span>
<span class="lineno"> 9203 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 9204 </span><span class="spaces">    </span><span class="nottickedoff">implFailM $ ExistentialError</span>
<span class="lineno"> 9205 </span><span class="spaces">                  </span><span class="nottickedoff">(permPretty ppinfo mb_x)</span>
<span class="lineno"> 9206 </span><span class="spaces">                  </span><span class="nottickedoff">(permPretty ppinfo mb_p)</span></span>
<span class="lineno"> 9207 </span>
<span class="lineno"> 9208 </span>
<span class="lineno"> 9209 </span>----------------------------------------------------------------------
<span class="lineno"> 9210 </span>-- * Proving Multiple Permission Implications
<span class="lineno"> 9211 </span>----------------------------------------------------------------------
<span class="lineno"> 9212 </span>
<span class="lineno"> 9213 </span>-- | A list of distinguished permissions with existential variables
<span class="lineno"> 9214 </span>type ExDistPerms vars ps = Mb vars (DistPerms ps)
<span class="lineno"> 9215 </span>
<span class="lineno"> 9216 </span>-- | Existentially quantify a list of distinguished permissions over the empty
<span class="lineno"> 9217 </span>-- set of existential variables
<span class="lineno"> 9218 </span>distPermsToExDistPerms :: DistPerms ps -&gt; ExDistPerms RNil ps
<span class="lineno"> 9219 </span><span class="decl"><span class="nottickedoff">distPermsToExDistPerms = emptyMb</span></span>
<span class="lineno"> 9220 </span>
<span class="lineno"> 9221 </span>-- | Substitute arguments into a function permission to get the existentially
<span class="lineno"> 9222 </span>-- quantified input permissions needed on the arguments
<span class="lineno"> 9223 </span>funPermExDistIns :: FunPerm ghosts args gouts ret -&gt; RAssign Name args -&gt;
<span class="lineno"> 9224 </span>                    ExDistPerms ghosts (ghosts :++: args)
<span class="lineno"> 9225 </span><span class="decl"><span class="nottickedoff">funPermExDistIns fun_perm args =</span>
<span class="lineno"> 9226 </span><span class="spaces">  </span><span class="nottickedoff">fmap (varSubst (permVarSubstOfNames args)) $ mbSeparate args $</span>
<span class="lineno"> 9227 </span><span class="spaces">  </span><span class="nottickedoff">mbValuePermsToDistPerms $ funPermIns fun_perm</span></span>
<span class="lineno"> 9228 </span>
<span class="lineno"> 9229 </span>-- | Make a \&quot;base case\&quot; 'DistPermsSplit' where the split is at the end
<span class="lineno"> 9230 </span>baseDistPermsSplit :: DistPerms ps -&gt; ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 9231 </span>                      DistPermsSplit (ps :&gt; a)
<span class="lineno"> 9232 </span><span class="decl"><span class="nottickedoff">baseDistPermsSplit ps x p =</span>
<span class="lineno"> 9233 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsSplit (rlToProxies ps) MNil ps x p</span></span>
<span class="lineno"> 9234 </span>
<span class="lineno"> 9235 </span>-- | Extend the @ps@ argument of a 'DistPermsSplit'
<span class="lineno"> 9236 </span>extDistPermsSplit :: DistPermsSplit ps -&gt; ExprVar b -&gt; ValuePerm b -&gt;
<span class="lineno"> 9237 </span>                     DistPermsSplit (ps :&gt; b)
<span class="lineno"> 9238 </span><span class="decl"><span class="nottickedoff">extDistPermsSplit (DistPermsSplit prxs1 prxs2 ps12 x p) y p' =</span>
<span class="lineno"> 9239 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsSplit prxs1 (prxs2 :&gt;: Proxy) (DistPermsCons ps12 y p') x p</span></span>
<span class="lineno"> 9240 </span>
<span class="lineno"> 9241 </span>
<span class="lineno"> 9242 </span>-- | The maximum priority returned by 'isProvablePerm'
<span class="lineno"> 9243 </span>isProvablePermMax :: Int
<span class="lineno"> 9244 </span><span class="decl"><span class="nottickedoff">isProvablePermMax = 3</span></span>
<span class="lineno"> 9245 </span>
<span class="lineno"> 9246 </span>-- | Test if a permission is of a form where 'proveExVarImpl' will succeed,
<span class="lineno"> 9247 </span>-- given the current set of existential variables whose values have not been
<span class="lineno"> 9248 </span>-- set. Return a priority for the permission, where higher priorities are proved
<span class="lineno"> 9249 </span>-- first and 0 means it cannot be proved.
<span class="lineno"> 9250 </span>isProvablePerm :: NameSet CrucibleType -&gt; Maybe (ExprVar a) -&gt;
<span class="lineno"> 9251 </span>                  ValuePerm a -&gt; Int
<span class="lineno"> 9252 </span>
<span class="lineno"> 9253 </span>-- Simple lifetime permissions should be proved first, so get highest priority
<span class="lineno"> 9254 </span><span class="decl"><span class="nottickedoff">isProvablePerm unsetVars maybe_x p@(ValPerm_Conj [Perm_LOwnedSimple _ _])</span>
<span class="lineno"> 9255 </span><span class="spaces">  </span><span class="nottickedoff">| neededs &lt;- maybe id (\x -&gt; NameSet.insert x) maybe_x $ neededVars p</span>
<span class="lineno"> 9256 </span><span class="spaces">  </span><span class="nottickedoff">, NameSet.null $ NameSet.intersection neededs unsetVars = 3</span>
<span class="lineno"> 9257 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9258 </span><span class="spaces"></span><span class="nottickedoff">-- Lifetime permissions can always be proved, but we want to prove them after</span>
<span class="lineno"> 9259 </span><span class="spaces"></span><span class="nottickedoff">-- any other permissions that might depend on them, so they get priority 1</span>
<span class="lineno"> 9260 </span><span class="spaces"></span><span class="nottickedoff">isProvablePerm _ _ (ValPerm_Conj ps)</span>
<span class="lineno"> 9261 </span><span class="spaces">  </span><span class="nottickedoff">| any (isJust . isLifetimePerm) ps = 1</span>
<span class="lineno"> 9262 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9263 </span><span class="spaces"></span><span class="nottickedoff">-- If x and all the needed vars in p are set, we can prove x:p</span>
<span class="lineno"> 9264 </span><span class="spaces"></span><span class="nottickedoff">isProvablePerm unsetVars maybe_x p</span>
<span class="lineno"> 9265 </span><span class="spaces">  </span><span class="nottickedoff">| neededs &lt;- maybe id (\x -&gt; NameSet.insert x) maybe_x $ neededVars p</span>
<span class="lineno"> 9266 </span><span class="spaces">  </span><span class="nottickedoff">, NameSet.null $ NameSet.intersection neededs unsetVars = 2</span>
<span class="lineno"> 9267 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9268 </span><span class="spaces"></span><span class="nottickedoff">-- Special case: an LLVMFrame permission can always be proved</span>
<span class="lineno"> 9269 </span><span class="spaces"></span><span class="nottickedoff">isProvablePerm _ _ (ValPerm_Conj [Perm_LLVMFrame _]) = 2</span>
<span class="lineno"> 9270 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9271 </span><span class="spaces"></span><span class="nottickedoff">-- Special case: a variable permission X can always be proved when the variable</span>
<span class="lineno"> 9272 </span><span class="spaces"></span><span class="nottickedoff">-- x and the offset are known, since X is either a free variable, so we can</span>
<span class="lineno"> 9273 </span><span class="spaces"></span><span class="nottickedoff">-- substitute the current permissions on x, or X is set to a ground permission,</span>
<span class="lineno"> 9274 </span><span class="spaces"></span><span class="nottickedoff">-- so we can definitely try to prove it</span>
<span class="lineno"> 9275 </span><span class="spaces"></span><span class="nottickedoff">isProvablePerm unsetVars maybe_x (ValPerm_Var _ off)</span>
<span class="lineno"> 9276 </span><span class="spaces">  </span><span class="nottickedoff">| neededs &lt;- maybe id (\x -&gt; NameSet.insert x) maybe_x $ freeVars off</span>
<span class="lineno"> 9277 </span><span class="spaces">  </span><span class="nottickedoff">, NameSet.null $ NameSet.intersection neededs unsetVars = 2</span>
<span class="lineno"> 9278 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 9279 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise we cannot prove the permission, so we return priority 0</span>
<span class="lineno"> 9280 </span><span class="spaces"></span><span class="nottickedoff">isProvablePerm _ _ _ = 0</span></span>
<span class="lineno"> 9281 </span>
<span class="lineno"> 9282 </span>
<span class="lineno"> 9283 </span>-- | Choose the next permission in the supplied list to try to prove by picking
<span class="lineno"> 9284 </span>-- one with maximal priority, as returned by 'isProvablePerm', and return its
<span class="lineno"> 9285 </span>-- location in the supplied list along with its priority. We assume that the
<span class="lineno"> 9286 </span>-- list is non-empty.
<span class="lineno"> 9287 </span>findProvablePerm :: NameSet CrucibleType -&gt; DistPerms ps -&gt;
<span class="lineno"> 9288 </span>                    (Int, DistPermsSplit ps)
<span class="lineno"> 9289 </span><span class="decl"><span class="nottickedoff">findProvablePerm unsetVars ps = case ps of</span>
<span class="lineno"> 9290 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsNil -&gt; error &quot;findProvablePerm: empty list&quot;</span>
<span class="lineno"> 9291 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons DistPermsNil x p -&gt;</span>
<span class="lineno"> 9292 </span><span class="spaces">    </span><span class="nottickedoff">(isProvablePerm unsetVars (Just x) p,</span>
<span class="lineno"> 9293 </span><span class="spaces">     </span><span class="nottickedoff">baseDistPermsSplit DistPermsNil x p)</span>
<span class="lineno"> 9294 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons ps' x p -&gt;</span>
<span class="lineno"> 9295 </span><span class="spaces">    </span><span class="nottickedoff">let (best_rank,best) = findProvablePerm unsetVars ps' in</span>
<span class="lineno"> 9296 </span><span class="spaces">    </span><span class="nottickedoff">let rank = isProvablePerm unsetVars (Just x) p in</span>
<span class="lineno"> 9297 </span><span class="spaces">    </span><span class="nottickedoff">if rank &gt; best_rank then</span>
<span class="lineno"> 9298 </span><span class="spaces">      </span><span class="nottickedoff">(rank, baseDistPermsSplit ps' x p)</span>
<span class="lineno"> 9299 </span><span class="spaces">    </span><span class="nottickedoff">else</span>
<span class="lineno"> 9300 </span><span class="spaces">      </span><span class="nottickedoff">(best_rank, extDistPermsSplit best x p)</span></span>
<span class="lineno"> 9301 </span>
<span class="lineno"> 9302 </span>
<span class="lineno"> 9303 </span>-- | Find all existential lifetime variables with @lowned@ permissions in an
<span class="lineno"> 9304 </span>-- 'ExDistPerms' list, and instantiate them with fresh lifetimes
<span class="lineno"> 9305 </span>instantiateLifetimeVars :: NuMatchingAny1 r =&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 9306 </span>                           ImplM vars s r ps_in ps_in ()
<span class="lineno"> 9307 </span><span class="decl"><span class="nottickedoff">instantiateLifetimeVars mb_ps =</span>
<span class="lineno"> 9308 </span><span class="spaces">  </span><span class="nottickedoff">do psubst &lt;- getPSubst</span>
<span class="lineno"> 9309 </span><span class="spaces">     </span><span class="nottickedoff">instantiateLifetimeVars' psubst mb_ps</span></span>
<span class="lineno"> 9310 </span>
<span class="lineno"> 9311 </span>-- | The main loop for 'instantiateLifetimeVars'
<span class="lineno"> 9312 </span>instantiateLifetimeVars' :: NuMatchingAny1 r =&gt; PartialSubst vars -&gt;
<span class="lineno"> 9313 </span>                            ExDistPerms vars ps -&gt; ImplM vars s r ps_in ps_in ()
<span class="lineno"> 9314 </span><span class="decl"><span class="nottickedoff">instantiateLifetimeVars' psubst mb_ps = case mbMatch mb_ps of</span>
<span class="lineno"> 9315 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| DistPermsNil |] -&gt; pure ()</span>
<span class="lineno"> 9316 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| DistPermsCons mb_ps' mb_x (ValPerm_Conj1 mb_p) |]</span>
<span class="lineno"> 9317 </span><span class="spaces">    </span><span class="nottickedoff">| [nuP| Just Refl |] &lt;- mbMapCl $(mkClosed</span>
<span class="lineno"> 9318 </span><span class="spaces">                                      </span><span class="nottickedoff">[| isLifetimeOwnershipPerm |]) mb_p</span>
<span class="lineno"> 9319 </span><span class="spaces">    </span><span class="nottickedoff">, Left memb &lt;- mbNameBoundP mb_x</span>
<span class="lineno"> 9320 </span><span class="spaces">    </span><span class="nottickedoff">, Nothing &lt;- psubstLookup psubst memb -&gt;</span>
<span class="lineno"> 9321 </span><span class="spaces">      </span><span class="nottickedoff">implBeginLifetimeM &gt;&gt;&gt;= \l -&gt;</span>
<span class="lineno"> 9322 </span><span class="spaces">      </span><span class="nottickedoff">setVarM memb (PExpr_Var l) &gt;&gt;&gt;</span>
<span class="lineno"> 9323 </span><span class="spaces">      </span><span class="nottickedoff">instantiateLifetimeVars' (psubstSet memb (PExpr_Var l) psubst) mb_ps'</span>
<span class="lineno"> 9324 </span><span class="spaces">  </span><span class="nottickedoff">[nuMP| DistPermsCons mb_ps' _ _ |] -&gt;</span>
<span class="lineno"> 9325 </span><span class="spaces">    </span><span class="nottickedoff">instantiateLifetimeVars' psubst mb_ps'</span></span>
<span class="lineno"> 9326 </span>
<span class="lineno"> 9327 </span>
<span class="lineno"> 9328 </span>-- | Internal-only version of 'proveVarsImplAppend' that is called recursively
<span class="lineno"> 9329 </span>-- by the implication prover. The distinction is that this version does not end
<span class="lineno"> 9330 </span>-- any lifetimes, because lifetimes are only ended at the top level, by
<span class="lineno"> 9331 </span>-- 'proveVarsImplAppend'.
<span class="lineno"> 9332 </span>proveVarsImplAppendInt :: NuMatchingAny1 r =&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 9333 </span>                          ImplM vars s r (ps_in :++: ps) ps_in ()
<span class="lineno"> 9334 </span><span class="decl"><span class="nottickedoff">proveVarsImplAppendInt (mbMatch -&gt; [nuMP| DistPermsNil |]) = return ()</span>
<span class="lineno"> 9335 </span><span class="spaces"></span><span class="nottickedoff">proveVarsImplAppendInt mb_ps =</span>
<span class="lineno"> 9336 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 9337 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePerms &gt;&gt;&gt;= \cur_perms -&gt;</span>
<span class="lineno"> 9338 </span><span class="spaces">  </span><span class="nottickedoff">case mbMatch $</span>
<span class="lineno"> 9339 </span><span class="spaces">       </span><span class="nottickedoff">mbMapClWithVars</span>
<span class="lineno"> 9340 </span><span class="spaces">       </span><span class="nottickedoff">($(mkClosed</span>
<span class="lineno"> 9341 </span><span class="spaces">          </span><span class="nottickedoff">[| \unsetVarsBool ns ps -&gt;</span>
<span class="lineno"> 9342 </span><span class="spaces">            </span><span class="nottickedoff">let unsetVars = nameSetFromFlags ns unsetVarsBool in</span>
<span class="lineno"> 9343 </span><span class="spaces">            </span><span class="nottickedoff">findProvablePerm unsetVars ps |])</span>
<span class="lineno"> 9344 </span><span class="spaces">        </span><span class="nottickedoff">`clApply` toClosed (psubstUnsetVarsBool psubst)) mb_ps of</span>
<span class="lineno"> 9345 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| (mb_rank, DistPermsSplit prxs1 prxs2 ps12 mb_x mb_p) |] -&gt;</span>
<span class="lineno"> 9346 </span><span class="spaces">      </span><span class="nottickedoff">if mbLift mb_rank &gt; 0 then</span>
<span class="lineno"> 9347 </span><span class="spaces">        </span><span class="nottickedoff">proveExVarImpl psubst mb_x mb_p &gt;&gt;&gt;= \x -&gt;</span>
<span class="lineno"> 9348 </span><span class="spaces">        </span><span class="nottickedoff">proveVarsImplAppendInt ps12 &gt;&gt;&gt;</span>
<span class="lineno"> 9349 </span><span class="spaces">        </span><span class="nottickedoff">implMoveUpM cur_perms (mbLift prxs1) x (mbLift prxs2)</span>
<span class="lineno"> 9350 </span><span class="spaces">      </span><span class="nottickedoff">else</span>
<span class="lineno"> 9351 </span><span class="spaces">        </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 9352 </span><span class="spaces">        </span><span class="nottickedoff">implFailM $ InsufficientVariablesError $</span>
<span class="lineno"> 9353 </span><span class="spaces">        </span><span class="nottickedoff">permPretty ppinfo mb_ps</span></span>
<span class="lineno"> 9354 </span>
<span class="lineno"> 9355 </span>-- | Like 'proveVarsImplAppendInt' but re-associate the appends
<span class="lineno"> 9356 </span>proveVarsImplAppendIntAssoc ::
<span class="lineno"> 9357 </span>  NuMatchingAny1 r =&gt; prx ps_in -&gt; prx1 ps1 -&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 9358 </span>  ImplM vars s r (ps_in :++: (ps1 :++: ps)) (ps_in :++: ps1) ()
<span class="lineno"> 9359 </span><span class="decl"><span class="nottickedoff">proveVarsImplAppendIntAssoc ps_in ps1 ps</span>
<span class="lineno"> 9360 </span><span class="spaces">  </span><span class="nottickedoff">| ps_prxs &lt;- mbLift $ mbMapCl $(mkClosed [| rlToProxies |]) ps</span>
<span class="lineno"> 9361 </span><span class="spaces">  </span><span class="nottickedoff">, Refl &lt;- RL.appendAssoc ps_in ps1 ps_prxs =</span>
<span class="lineno"> 9362 </span><span class="spaces">    </span><span class="nottickedoff">proveVarsImplAppendInt ps</span></span>
<span class="lineno"> 9363 </span>
<span class="lineno"> 9364 </span>-- | Like 'proveVarsImplAppendInt' but re-associate the appends
<span class="lineno"> 9365 </span>proveVarsImplAppendIntAssoc4 ::
<span class="lineno"> 9366 </span>  NuMatchingAny1 r =&gt; prx ps_in -&gt; prx1 ps1 -&gt; prx2 ps2 -&gt;
<span class="lineno"> 9367 </span>  ExDistPerms vars ps -&gt;
<span class="lineno"> 9368 </span>  ImplM vars s r (ps_in :++: (ps1 :++: (ps2 :++: ps))) (ps_in :++: (ps1 :++: ps2)) ()
<span class="lineno"> 9369 </span><span class="decl"><span class="nottickedoff">proveVarsImplAppendIntAssoc4 ps_in (ps1 :: prx1 ps1) (ps2 :: prx2 ps2) ps</span>
<span class="lineno"> 9370 </span><span class="spaces">  </span><span class="nottickedoff">| ps_prxs &lt;- mbLift $ mbMapCl $(mkClosed [| rlToProxies |]) ps</span>
<span class="lineno"> 9371 </span><span class="spaces">  </span><span class="nottickedoff">, ps12 &lt;- Proxy :: Proxy (ps1 :++: ps2)</span>
<span class="lineno"> 9372 </span><span class="spaces">  </span><span class="nottickedoff">, Refl &lt;- RL.appendAssoc ps1 ps2 ps_prxs =</span>
<span class="lineno"> 9373 </span><span class="spaces">    </span><span class="nottickedoff">proveVarsImplAppendIntAssoc ps_in ps12 ps</span></span>
<span class="lineno"> 9374 </span>
<span class="lineno"> 9375 </span>-- | Prove a list of existentially-quantified distinguished permissions and put
<span class="lineno"> 9376 </span>-- those proofs onto the stack. This is the same as 'proveVarsImplAppendInt'
<span class="lineno"> 9377 </span>-- except that the stack starts out empty and is replaced by the proofs, rather
<span class="lineno"> 9378 </span>-- than appending the proofs to the stack that is already there.
<span class="lineno"> 9379 </span>proveVarsImplInt :: NuMatchingAny1 r =&gt; ExDistPerms vars as -&gt;
<span class="lineno"> 9380 </span>                    ImplM vars s r as RNil ()
<span class="lineno"> 9381 </span><span class="decl"><span class="nottickedoff">proveVarsImplInt ps</span>
<span class="lineno"> 9382 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- mbLift (fmap RL.prependRNilEq $ mbDistPermsToValuePerms ps) =</span>
<span class="lineno"> 9383 </span><span class="spaces">    </span><span class="nottickedoff">proveVarsImplAppendInt ps</span></span>
<span class="lineno"> 9384 </span>
<span class="lineno"> 9385 </span>-- | Prove one sequence of permissions from another and capture the proof as a
<span class="lineno"> 9386 </span>-- 'LocalPermImpl'
<span class="lineno"> 9387 </span>localProveVars :: NuMatchingAny1 r =&gt; DistPerms ps_in -&gt; DistPerms ps_out -&gt;
<span class="lineno"> 9388 </span>                  ImplM vars s r ps ps (LocalPermImpl ps_in ps_out)
<span class="lineno"> 9389 </span><span class="decl"><span class="nottickedoff">localProveVars ps_in ps_out =</span>
<span class="lineno"> 9390 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt; sep [pretty &quot;localProveVars:&quot;, permPretty i ps_in,</span>
<span class="lineno"> 9391 </span><span class="spaces">                         </span><span class="nottickedoff">pretty &quot;-o&quot;, permPretty i ps_out]) &gt;&gt;&gt;</span>
<span class="lineno"> 9392 </span><span class="spaces">  </span><span class="nottickedoff">LocalPermImpl &lt;$&gt;</span>
<span class="lineno"> 9393 </span><span class="spaces">  </span><span class="nottickedoff">embedImplM ps_in (recombinePermsRev ps_in &gt;&gt;&gt;</span>
<span class="lineno"> 9394 </span><span class="spaces">                    </span><span class="nottickedoff">proveVarsImplInt (emptyMb ps_out) &gt;&gt;&gt;</span>
<span class="lineno"> 9395 </span><span class="spaces">                    </span><span class="nottickedoff">pure (LocalImplRet Refl))</span></span>
<span class="lineno"> 9396 </span>
<span class="lineno"> 9397 </span>-- | Prove one sequence of permissions over an extended set of local variables
<span class="lineno"> 9398 </span>-- from another and capture the proof as a 'LocalPermImpl' in a binding
<span class="lineno"> 9399 </span>localMbProveVars :: NuMatchingAny1 r =&gt; KnownRepr CruCtx ctx =&gt;
<span class="lineno"> 9400 </span>                    Mb ctx (DistPerms ps_in) -&gt; Mb ctx (DistPerms ps_out) -&gt;
<span class="lineno"> 9401 </span>                    ImplM vars s r ps ps (Mb ctx (LocalPermImpl ps_in ps_out))
<span class="lineno"> 9402 </span><span class="decl"><span class="nottickedoff">localMbProveVars mb_ps_in mb_ps_out =</span>
<span class="lineno"> 9403 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt; sep [pretty &quot;localMbProveVars:&quot;, permPretty i mb_ps_in,</span>
<span class="lineno"> 9404 </span><span class="spaces">                         </span><span class="nottickedoff">pretty &quot;-o&quot;, permPretty i mb_ps_out]) &gt;&gt;&gt;</span>
<span class="lineno"> 9405 </span><span class="spaces">  </span><span class="nottickedoff">fmap LocalPermImpl &lt;$&gt;</span>
<span class="lineno"> 9406 </span><span class="spaces">  </span><span class="nottickedoff">embedMbImplM mb_ps_in (mbMap2</span>
<span class="lineno"> 9407 </span><span class="spaces">                         </span><span class="nottickedoff">(\ps_in ps_out -&gt;</span>
<span class="lineno"> 9408 </span><span class="spaces">                           </span><span class="nottickedoff">recombinePermsRev ps_in &gt;&gt;&gt;</span>
<span class="lineno"> 9409 </span><span class="spaces">                           </span><span class="nottickedoff">proveVarsImplInt (emptyMb ps_out) &gt;&gt;&gt;</span>
<span class="lineno"> 9410 </span><span class="spaces">                           </span><span class="nottickedoff">pure (LocalImplRet Refl))</span>
<span class="lineno"> 9411 </span><span class="spaces">                         </span><span class="nottickedoff">mb_ps_in mb_ps_out)</span></span>
<span class="lineno"> 9412 </span>
<span class="lineno"> 9413 </span>
<span class="lineno"> 9414 </span>----------------------------------------------------------------------
<span class="lineno"> 9415 </span>-- * External Entrypoints to the Implication Prover
<span class="lineno"> 9416 </span>----------------------------------------------------------------------
<span class="lineno"> 9417 </span>
<span class="lineno"> 9418 </span>-- | End a lifetime and, recursively, all lifetimes it contains, assuming that
<span class="lineno"> 9419 </span>-- @lowned@ permissions are held for all of those lifetimes. For each lifetime
<span class="lineno"> 9420 </span>-- that is ended, prove its required input permissions and recombine the
<span class="lineno"> 9421 </span>-- resulting output permissions. Also remove each ended lifetime from any
<span class="lineno"> 9422 </span>-- @lowned@ permission in the variable permissions that contains it. If a
<span class="lineno"> 9423 </span>-- lifetime has already ended, do nothing.
<span class="lineno"> 9424 </span>implEndLifetimeRecM :: NuMatchingAny1 r =&gt; ExprVar LifetimeType -&gt;
<span class="lineno"> 9425 </span>                       ImplM vars s r ps ps ()
<span class="lineno"> 9426 </span><span class="decl"><span class="nottickedoff">implEndLifetimeRecM l =</span>
<span class="lineno"> 9427 </span><span class="spaces">  </span><span class="nottickedoff">implVerbTraceM (\i -&gt; pretty &quot;implEndLifetimeRecM&quot; &lt;+&gt; permPretty i l) &gt;&gt;&gt;</span>
<span class="lineno"> 9428 </span><span class="spaces">  </span><span class="nottickedoff">getPerm l &gt;&gt;&gt;= \case</span>
<span class="lineno"> 9429 </span><span class="spaces">  </span><span class="nottickedoff">ValPerm_LFinished -&gt; return ()</span>
<span class="lineno"> 9430 </span><span class="spaces">  </span><span class="nottickedoff">p@(ValPerm_LOwned [] tps_in tps_out ps_in ps_out)</span>
<span class="lineno"> 9431 </span><span class="spaces">    </span><span class="nottickedoff">| Just dps_in &lt;- exprPermsToDistPerms ps_in -&gt;</span>
<span class="lineno"> 9432 </span><span class="spaces">      </span><span class="nottickedoff">-- Get the permission stack on entry</span>
<span class="lineno"> 9433 </span><span class="spaces">      </span><span class="nottickedoff">getDistPerms &gt;&gt;&gt;= \ps0 -&gt;</span>
<span class="lineno"> 9434 </span><span class="spaces">      </span><span class="nottickedoff">-- Save the lowned permission for l</span>
<span class="lineno"> 9435 </span><span class="spaces">      </span><span class="nottickedoff">implPushM l p &gt;&gt;&gt;</span>
<span class="lineno"> 9436 </span><span class="spaces">      </span><span class="nottickedoff">-- Prove the required input permissions ps_in for ending l</span>
<span class="lineno"> 9437 </span><span class="spaces">      </span><span class="nottickedoff">mbVarsM dps_in &gt;&gt;&gt;= \mb_dps_in -&gt;</span>
<span class="lineno"> 9438 </span><span class="spaces">      </span><span class="nottickedoff">proveVarsImplAppendInt mb_dps_in &gt;&gt;&gt;</span>
<span class="lineno"> 9439 </span><span class="spaces">      </span><span class="nottickedoff">-- Move the lowned permission for l to the top of the stack</span>
<span class="lineno"> 9440 </span><span class="spaces">      </span><span class="nottickedoff">implMoveUpM ps0 ps_in l MNil &gt;&gt;&gt;</span>
<span class="lineno"> 9441 </span><span class="spaces">      </span><span class="nottickedoff">-- End l</span>
<span class="lineno"> 9442 </span><span class="spaces">      </span><span class="nottickedoff">implEndLifetimeM Proxy l tps_in tps_out ps_in ps_out &gt;&gt;&gt;</span>
<span class="lineno"> 9443 </span><span class="spaces">      </span><span class="nottickedoff">-- Find all lowned perms that contain l and remove l from them</span>
<span class="lineno"> 9444 </span><span class="spaces">      </span><span class="nottickedoff">implFindLOwnedPerms &gt;&gt;&gt;= \lowned_ps -&gt;</span>
<span class="lineno"> 9445 </span><span class="spaces">      </span><span class="nottickedoff">forM_ lowned_ps $ \case</span>
<span class="lineno"> 9446 </span><span class="spaces">        </span><span class="nottickedoff">(l', p'@(ValPerm_LOwned ls' tps_in' tps_out' ps_in' ps_out'))</span>
<span class="lineno"> 9447 </span><span class="spaces">          </span><span class="nottickedoff">| elem (PExpr_Var l) ls' -&gt;</span>
<span class="lineno"> 9448 </span><span class="spaces">            </span><span class="nottickedoff">implPushM l' p' &gt;&gt;&gt; implPushCopyM l ValPerm_LFinished &gt;&gt;&gt;</span>
<span class="lineno"> 9449 </span><span class="spaces">            </span><span class="nottickedoff">implRemoveContainedLifetimeM l' ls' tps_in' tps_out' ps_in' ps_out' l</span>
<span class="lineno"> 9450 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; return ()</span>
<span class="lineno"> 9451 </span><span class="spaces">  </span><span class="nottickedoff">(ValPerm_LOwned ((asVar -&gt; Just l') : _) _ _ _ _) -&gt;</span>
<span class="lineno"> 9452 </span><span class="spaces">    </span><span class="nottickedoff">implEndLifetimeRecM l' &gt;&gt;&gt; implEndLifetimeRecM l</span>
<span class="lineno"> 9453 </span><span class="spaces">  </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 9454 </span><span class="spaces">    </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 9455 </span><span class="spaces">                 </span><span class="nottickedoff">pretty &quot;implEndLifetimeRecM: could not end lifetime: &quot; &lt;&gt;</span>
<span class="lineno"> 9456 </span><span class="spaces">                 </span><span class="nottickedoff">permPretty i l) &gt;&gt;&gt;</span>
<span class="lineno"> 9457 </span><span class="spaces">    </span><span class="nottickedoff">implFailM (LifetimeError EndLifetimeError)</span></span>
<span class="lineno"> 9458 </span>
<span class="lineno"> 9459 </span>-- | Prove a list of existentially-quantified distinguished permissions, adding
<span class="lineno"> 9460 </span>-- those proofs to the top of the stack. In the case that a the variable itself
<span class="lineno"> 9461 </span>-- whose permissions are being proved is existentially-quantified --- that is,
<span class="lineno"> 9462 </span>-- if we are proving @x:p@ for existentially-quantified @x@ --- then the
<span class="lineno"> 9463 </span>-- resulting permission on top of the stack will be @y:[e/x]p@, where @y@ is a
<span class="lineno"> 9464 </span>-- fresh variable and @e@ is the expression used to instantiate @x@.
<span class="lineno"> 9465 </span>proveVarsImplAppend :: NuMatchingAny1 r =&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 9466 </span>                       ImplM vars s r (ps_in :++: ps) ps_in ()
<span class="lineno"> 9467 </span><span class="decl"><span class="nottickedoff">proveVarsImplAppend mb_ps =</span>
<span class="lineno"> 9468 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePerms &gt;&gt;&gt;= \(_ :: PermSet ps_in) -&gt;</span>
<span class="lineno"> 9469 </span><span class="spaces">  </span><span class="nottickedoff">lifetimesThatCouldProve mb_ps &gt;&gt;&gt;= \ls -&gt;</span>
<span class="lineno"> 9470 </span><span class="spaces">  </span><span class="nottickedoff">implVerbTraceM (\i -&gt; pretty &quot;Lifetimes that could prove:&quot; &lt;+&gt; permPretty i ls) &gt;&gt;&gt;</span>
<span class="lineno"> 9471 </span><span class="spaces">  </span><span class="nottickedoff">foldr1 (implCatchM &quot;proveVarsImplAppend&quot; mb_ps)</span>
<span class="lineno"> 9472 </span><span class="spaces">  </span><span class="nottickedoff">((proveVarsImplAppendInt mb_ps)</span>
<span class="lineno"> 9473 </span><span class="spaces">   </span><span class="nottickedoff">:</span>
<span class="lineno"> 9474 </span><span class="spaces">   </span><span class="nottickedoff">flip map ls</span>
<span class="lineno"> 9475 </span><span class="spaces">   </span><span class="nottickedoff">(\l -&gt;</span>
<span class="lineno"> 9476 </span><span class="spaces">     </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 9477 </span><span class="spaces">                  </span><span class="nottickedoff">sep [pretty &quot;Ending lifetime&quot; &lt;+&gt; permPretty i l,</span>
<span class="lineno"> 9478 </span><span class="spaces">                       </span><span class="nottickedoff">pretty &quot;in order to prove:&quot;,</span>
<span class="lineno"> 9479 </span><span class="spaces">                       </span><span class="nottickedoff">permPretty i mb_ps]) &gt;&gt;&gt;</span>
<span class="lineno"> 9480 </span><span class="spaces">     </span><span class="nottickedoff">implEndLifetimeRecM l &gt;&gt;&gt; proveVarsImplAppend mb_ps))</span></span>
<span class="lineno"> 9481 </span>
<span class="lineno"> 9482 </span>-- | Prove a list of existentially-quantified distinguished permissions and put
<span class="lineno"> 9483 </span>-- those proofs onto the stack. This is the same as 'proveVarsImplAppend' except
<span class="lineno"> 9484 </span>-- that the stack starts out empty and is replaced by the proofs, rather than
<span class="lineno"> 9485 </span>-- appending the proofs to the stack that is already there.
<span class="lineno"> 9486 </span>proveVarsImpl :: NuMatchingAny1 r =&gt; ExDistPerms vars as -&gt;
<span class="lineno"> 9487 </span>                 ImplM vars s r as RNil ()
<span class="lineno"> 9488 </span><span class="decl"><span class="nottickedoff">proveVarsImpl ps</span>
<span class="lineno"> 9489 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- mbLift (fmap RL.prependRNilEq $ mbDistPermsToValuePerms ps) =</span>
<span class="lineno"> 9490 </span><span class="spaces">    </span><span class="nottickedoff">proveVarsImplAppend ps</span></span>
<span class="lineno"> 9491 </span>
<span class="lineno"> 9492 </span>-- | Prove a list of existentially-quantified distinguished permissions and put
<span class="lineno"> 9493 </span>-- those proofs onto the stack, and then return the expressions assigned to the
<span class="lineno"> 9494 </span>-- existential variables
<span class="lineno"> 9495 </span>proveVarsImplEVarExprs :: NuMatchingAny1 r =&gt; ExDistPerms vars as -&gt;
<span class="lineno"> 9496 </span>                          ImplM vars s r as RNil (PermExprs vars)
<span class="lineno"> 9497 </span><span class="decl"><span class="nottickedoff">proveVarsImplEVarExprs ps =</span>
<span class="lineno"> 9498 </span><span class="spaces">  </span><span class="nottickedoff">proveVarsImpl ps &gt;&gt;&gt;</span>
<span class="lineno"> 9499 </span><span class="spaces">  </span><span class="nottickedoff">use implStateVars &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 9500 </span><span class="spaces">  </span><span class="nottickedoff">fmap (exprsOfSubst . completePSubst vars) getPSubst</span></span>
<span class="lineno"> 9501 </span>
<span class="lineno"> 9502 </span>-- | Prove a list of existentially-quantified permissions and put the proofs on
<span class="lineno"> 9503 </span>-- the stack, similarly to 'proveVarsImpl', but ensure that the existential
<span class="lineno"> 9504 </span>-- variables are themselves only instanitated with variables, not arbitrary
<span class="lineno"> 9505 </span>-- terms. The variables must be distinct from each other and from any other
<span class="lineno"> 9506 </span>-- variables in scope. Return the variables used to instantiate the evars.
<span class="lineno"> 9507 </span>proveVarsImplVarEVars :: NuMatchingAny1 r =&gt; ExDistPerms vars as -&gt;
<span class="lineno"> 9508 </span>                         ImplM vars s r as RNil (RAssign ExprVar vars)
<span class="lineno"> 9509 </span><span class="decl"><span class="nottickedoff">proveVarsImplVarEVars mb_ps =</span>
<span class="lineno"> 9510 </span><span class="spaces">  </span><span class="nottickedoff">-- First, prove the required permissions mb_ps. Note that this will prove</span>
<span class="lineno"> 9511 </span><span class="spaces">  </span><span class="nottickedoff">-- [es/vars]mb_ps, for some instantiation es for the evars vars. The rest of</span>
<span class="lineno"> 9512 </span><span class="spaces">  </span><span class="nottickedoff">-- this function is then to cast this to [xs/vars]mb_ps for fresh vars xs.</span>
<span class="lineno"> 9513 </span><span class="spaces">  </span><span class="nottickedoff">proveVarsImpl mb_ps &gt;&gt;&gt;</span>
<span class="lineno"> 9514 </span><span class="spaces">  </span><span class="nottickedoff">-- Next, call getVarVarM to get fresh variables for all the evars</span>
<span class="lineno"> 9515 </span><span class="spaces">  </span><span class="nottickedoff">use implStateVars &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 9516 </span><span class="spaces">  </span><span class="nottickedoff">let var_membs = RL.members $ cruCtxProxies vars in</span>
<span class="lineno"> 9517 </span><span class="spaces">  </span><span class="nottickedoff">traverseRAssign getVarVarM var_membs &gt;&gt;&gt;= \xs -&gt;</span>
<span class="lineno"> 9518 </span><span class="spaces">  </span><span class="nottickedoff">-- Now get the instantiations es for the evars; NOTE: we call completePSubst</span>
<span class="lineno"> 9519 </span><span class="spaces">  </span><span class="nottickedoff">-- as a convenience, but all evars should be set by getVarVarM</span>
<span class="lineno"> 9520 </span><span class="spaces">  </span><span class="nottickedoff">getPSubst &gt;&gt;&gt;= \psubst -&gt;</span>
<span class="lineno"> 9521 </span><span class="spaces">  </span><span class="nottickedoff">let s = completePSubst vars psubst</span>
<span class="lineno"> 9522 </span><span class="spaces">      </span><span class="nottickedoff">es = exprsOfSubst s</span>
<span class="lineno"> 9523 </span><span class="spaces">      </span><span class="nottickedoff">mb_es = fmap (const es) mb_ps in</span>
<span class="lineno"> 9524 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove that x:eq(e) for each evar x and its instantiation e</span>
<span class="lineno"> 9525 </span><span class="spaces">  </span><span class="nottickedoff">proveVarsEq xs mb_es &gt;&gt;&gt;</span>
<span class="lineno"> 9526 </span><span class="spaces">  </span><span class="nottickedoff">-- Build the proof that [es/vars]mb_ps = [xs/vars]mb_ps</span>
<span class="lineno"> 9527 </span><span class="spaces">  </span><span class="nottickedoff">let eqpf =</span>
<span class="lineno"> 9528 </span><span class="spaces">        </span><span class="nottickedoff">fmap (\es' -&gt; subst (substOfExprs es') $</span>
<span class="lineno"> 9529 </span><span class="spaces">                      </span><span class="nottickedoff">mbDistPermsToValuePerms mb_ps) $</span>
<span class="lineno"> 9530 </span><span class="spaces">        </span><span class="nottickedoff">eqProofFromPermsRev xs es in</span>
<span class="lineno"> 9531 </span><span class="spaces">  </span><span class="nottickedoff">-- Use eqpf to cast the permission stack</span>
<span class="lineno"> 9532 </span><span class="spaces">  </span><span class="nottickedoff">implCastStackM eqpf &gt;&gt;&gt;</span>
<span class="lineno"> 9533 </span><span class="spaces">  </span><span class="nottickedoff">return xs</span></span>
<span class="lineno"> 9534 </span>
<span class="lineno"> 9535 </span>-- | Prove @x:p'@, where @p@ may have existentially-quantified variables in it.
<span class="lineno"> 9536 </span>proveVarImpl :: NuMatchingAny1 r =&gt; ExprVar a -&gt; Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 9537 </span>                ImplM vars s r (ps :&gt; a) ps ()
<span class="lineno"> 9538 </span><span class="decl"><span class="nottickedoff">proveVarImpl x mb_p = proveVarsImplAppend $ fmap (distPerms1 x) mb_p</span></span>
<span class="lineno"> 9539 </span>
<span class="lineno"> 9540 </span>-- | Terminate the current proof branch with a failure
<span class="lineno"> 9541 </span>implFailM :: NuMatchingAny1 r =&gt; ImplError -&gt; ImplM vars s r ps_any ps a
<span class="lineno"> 9542 </span><span class="decl"><span class="nottickedoff">implFailM err =</span>
<span class="lineno"> 9543 </span><span class="spaces">  </span><span class="nottickedoff">use implStateFailPrefix &gt;&gt;&gt;= \prefix -&gt;</span>
<span class="lineno"> 9544 </span><span class="spaces">    </span><span class="nottickedoff">implTraceM (const $ pretty $ prefix &lt;&gt; ppError err) &gt;&gt;&gt;</span>
<span class="lineno"> 9545 </span><span class="spaces">    </span><span class="nottickedoff">implApplyImpl1 (Impl1_Fail err) MNil</span></span>
<span class="lineno"> 9546 </span>
<span class="lineno"> 9547 </span>-- | Terminate the current proof branch with a failure proving @x:p -o mb_p@
<span class="lineno"> 9548 </span>implFailVarM :: NuMatchingAny1 r =&gt; String -&gt; ExprVar tp -&gt; ValuePerm tp -&gt;
<span class="lineno"> 9549 </span>                Mb vars (ValuePerm tp) -&gt; ImplM vars s r ps_any ps a
<span class="lineno"> 9550 </span><span class="decl"><span class="nottickedoff">implFailVarM f x p mb_p =</span>
<span class="lineno"> 9551 </span><span class="spaces">  </span><span class="nottickedoff">use implStatePPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 9552 </span><span class="spaces">  </span><span class="nottickedoff">use implStateVars &gt;&gt;&gt;= \ctx -&gt;</span>
<span class="lineno"> 9553 </span><span class="spaces">  </span><span class="nottickedoff">findPermsContainingVar x &gt;&gt;&gt;= \case</span>
<span class="lineno"> 9554 </span><span class="spaces">    </span><span class="nottickedoff">(Some distperms) -&gt;</span>
<span class="lineno"> 9555 </span><span class="spaces">      </span><span class="nottickedoff">implFailM $ ImplVariableError</span>
<span class="lineno"> 9556 </span><span class="spaces">                    </span><span class="nottickedoff">(ppImpl ppinfo x p mb_p)</span>
<span class="lineno"> 9557 </span><span class="spaces">                    </span><span class="nottickedoff">f</span>
<span class="lineno"> 9558 </span><span class="spaces">                    </span><span class="nottickedoff">(permPretty ppinfo x, x)</span>
<span class="lineno"> 9559 </span><span class="spaces">                    </span><span class="nottickedoff">(permPretty ppinfo p, p)</span>
<span class="lineno"> 9560 </span><span class="spaces">                    </span><span class="nottickedoff">ctx</span>
<span class="lineno"> 9561 </span><span class="spaces">                    </span><span class="nottickedoff">distperms</span></span>
<span class="lineno"> 9562 </span>
<span class="lineno"> 9563 </span>instance ErrorPretty ImplError where
<span class="lineno"> 9564 </span>  <span class="decl"><span class="nottickedoff">ppError (GeneralError doc) = renderDoc doc</span>
<span class="lineno"> 9565 </span><span class="spaces">  </span><span class="nottickedoff">ppError NoFrameInScopeError =</span>
<span class="lineno"> 9566 </span><span class="spaces">    </span><span class="nottickedoff">&quot;No LLVM frame in scope&quot;</span>
<span class="lineno"> 9567 </span><span class="spaces">  </span><span class="nottickedoff">ppError ArrayStepError =</span>
<span class="lineno"> 9568 </span><span class="spaces">    </span><span class="nottickedoff">&quot;Error proving array permissions&quot;</span>
<span class="lineno"> 9569 </span><span class="spaces">  </span><span class="nottickedoff">ppError MuUnfoldError =</span>
<span class="lineno"> 9570 </span><span class="spaces">    </span><span class="nottickedoff">&quot;Tried to unfold a mu on the left after unfolding on the right&quot;</span>
<span class="lineno"> 9571 </span><span class="spaces">  </span><span class="nottickedoff">ppError FunctionPermissionError =</span>
<span class="lineno"> 9572 </span><span class="spaces">    </span><span class="nottickedoff">&quot;Could not find function permission&quot;</span>
<span class="lineno"> 9573 </span><span class="spaces">  </span><span class="nottickedoff">ppError (PartialSubstitutionError caller doc) = renderDoc $</span>
<span class="lineno"> 9574 </span><span class="spaces">    </span><span class="nottickedoff">sep [ pretty (&quot;Incomplete susbtitution in &quot; ++ caller ++ &quot; for: &quot;)</span>
<span class="lineno"> 9575 </span><span class="spaces">        </span><span class="nottickedoff">, doc ]</span>
<span class="lineno"> 9576 </span><span class="spaces">  </span><span class="nottickedoff">ppError (LifetimeError EndLifetimeError) =</span>
<span class="lineno"> 9577 </span><span class="spaces">    </span><span class="nottickedoff">&quot;implEndLifetimeM: lownedPermsToDistPerms&quot;</span>
<span class="lineno"> 9578 </span><span class="spaces">  </span><span class="nottickedoff">ppError (LifetimeError ImplicationLifetimeError) =</span>
<span class="lineno"> 9579 </span><span class="spaces">    </span><span class="nottickedoff">&quot;proveVarAtomicImpl: lownedPermsToDistPerms&quot;</span>
<span class="lineno"> 9580 </span><span class="spaces">  </span><span class="nottickedoff">ppError (LifetimeError (LifetimeCurrentError doc)) = renderDoc $</span>
<span class="lineno"> 9581 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;Could not prove lifetime is current:&quot; &lt;+&gt; doc</span>
<span class="lineno"> 9582 </span><span class="spaces">  </span><span class="nottickedoff">ppError (MemBlockError doc) = renderDoc $</span>
<span class="lineno"> 9583 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;Could not eliminate permission&quot; &lt;+&gt; doc</span>
<span class="lineno"> 9584 </span><span class="spaces">    </span><span class="nottickedoff">-- permPretty pp (Perm_LLVMBlock bp)</span>
<span class="lineno"> 9585 </span><span class="spaces">  </span><span class="nottickedoff">ppError (EqualityProofError edoc mbedoc) = renderDoc $</span>
<span class="lineno"> 9586 </span><span class="spaces">    </span><span class="nottickedoff">sep [ pretty &quot;proveEq&quot; &lt;&gt; colon &lt;+&gt; pretty &quot;Could not prove&quot;</span>
<span class="lineno"> 9587 </span><span class="spaces">        </span><span class="nottickedoff">, edoc &lt;+&gt; pretty &quot;=&quot; &lt;+&gt; mbedoc]</span>
<span class="lineno"> 9588 </span><span class="spaces">  </span><span class="nottickedoff">ppError (InsufficientVariablesError doc) = renderDoc $</span>
<span class="lineno"> 9589 </span><span class="spaces">    </span><span class="nottickedoff">sep [PP.fillSep [PP.pretty</span>
<span class="lineno"> 9590 </span><span class="spaces">          </span><span class="nottickedoff">&quot;Could not determine enough variables to prove permissions:&quot;,</span>
<span class="lineno"> 9591 </span><span class="spaces">          </span><span class="nottickedoff">doc]]</span>
<span class="lineno"> 9592 </span><span class="spaces">  </span><span class="nottickedoff">ppError (ExistentialError docx docp ) = renderDoc $</span>
<span class="lineno"> 9593 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;proveExVarImpl: existential variable&quot; &lt;+&gt;</span>
<span class="lineno"> 9594 </span><span class="spaces">    </span><span class="nottickedoff">docx &lt;+&gt;</span>
<span class="lineno"> 9595 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;not resolved when trying to prove:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 9596 </span><span class="spaces">    </span><span class="nottickedoff">docp</span>
<span class="lineno"> 9597 </span><span class="spaces">  </span><span class="nottickedoff">ppError (ImplVariableError doc f _ev _vp _ctx _dp) = renderDoc $</span>
<span class="lineno"> 9598 </span><span class="spaces">    </span><span class="nottickedoff">sep [ pretty f &lt;&gt; colon &lt;+&gt; pretty &quot;Could not prove&quot;</span>
<span class="lineno"> 9599 </span><span class="spaces">        </span><span class="nottickedoff">, doc ]</span></span>
<span class="lineno"> 9600 </span>
<span class="lineno"> 9601 </span>-- | Try to prove @x:p@, returning whether or not this was successful
<span class="lineno"> 9602 </span>checkVarImpl ::
<span class="lineno"> 9603 </span>  PermSet ps_in -&gt;
<span class="lineno"> 9604 </span>  ImplM RNil Int (Constant ()) ps_out ps_in a -&gt;
<span class="lineno"> 9605 </span>  Bool
<span class="lineno"> 9606 </span><span class="decl"><span class="nottickedoff">checkVarImpl ps act = 0 /= permImplSucceeds (evalState st (toClosed 0))</span>
<span class="lineno"> 9607 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 9608 </span><span class="spaces">    </span><span class="nottickedoff">st = runImplM</span>
<span class="lineno"> 9609 </span><span class="spaces">           </span><span class="nottickedoff">CruCtxNil</span>
<span class="lineno"> 9610 </span><span class="spaces">           </span><span class="nottickedoff">ps</span>
<span class="lineno"> 9611 </span><span class="spaces">           </span><span class="nottickedoff">emptyPermEnv</span>
<span class="lineno"> 9612 </span><span class="spaces">           </span><span class="nottickedoff">emptyPPInfo</span>
<span class="lineno"> 9613 </span><span class="spaces">           </span><span class="nottickedoff">&quot;checkVarImpl&quot;</span>
<span class="lineno"> 9614 </span><span class="spaces">           </span><span class="nottickedoff">(DebugLevel 2)</span>
<span class="lineno"> 9615 </span><span class="spaces">           </span><span class="nottickedoff">NameMap.empty</span>
<span class="lineno"> 9616 </span><span class="spaces">           </span><span class="nottickedoff">Nothing</span>
<span class="lineno"> 9617 </span><span class="spaces">           </span><span class="nottickedoff">LittleEndian</span>
<span class="lineno"> 9618 </span><span class="spaces">           </span><span class="nottickedoff">act</span>
<span class="lineno"> 9619 </span><span class="spaces">           </span><span class="nottickedoff">(\_ -&gt; return (Constant ()))</span></span>

</pre>
</body>
</html>
