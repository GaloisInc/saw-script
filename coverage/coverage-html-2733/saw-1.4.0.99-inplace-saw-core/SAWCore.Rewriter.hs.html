<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">    2 </span>{-# LANGUAGE DeriveFunctor #-}
<span class="lineno">    3 </span>{-# LANGUAGE DeriveFoldable #-}
<span class="lineno">    4 </span>{-# LANGUAGE DeriveTraversable #-}
<span class="lineno">    5 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">    6 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    7 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">    8 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    9 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   10 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   11 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   12 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>{- |
<span class="lineno">   15 </span>Module      : SAWCore.Rewriter
<span class="lineno">   16 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">   17 </span>License     : BSD3
<span class="lineno">   18 </span>Maintainer  : jhendrix@galois.com
<span class="lineno">   19 </span>Stability   : experimental
<span class="lineno">   20 </span>Portability : non-portable (language extensions)
<span class="lineno">   21 </span>-}
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>module SAWCore.Rewriter
<span class="lineno">   24 </span>  ( -- * Rewrite rules
<span class="lineno">   25 </span>    RewriteRule
<span class="lineno">   26 </span>  , ctxtRewriteRule
<span class="lineno">   27 </span>  , lhsRewriteRule
<span class="lineno">   28 </span>  , rhsRewriteRule
<span class="lineno">   29 </span>  , annRewriteRule
<span class="lineno">   30 </span>  , ruleOfTerm
<span class="lineno">   31 </span>  , ruleOfTerms
<span class="lineno">   32 </span>  , ruleOfProp
<span class="lineno">   33 </span>  , propOfRewriteRule
<span class="lineno">   34 </span>  , scDefRewriteRules
<span class="lineno">   35 </span>  , scEqsRewriteRules
<span class="lineno">   36 </span>  , scEqRewriteRule
<span class="lineno">   37 </span>    -- * Simplification sets
<span class="lineno">   38 </span>  , Simpset
<span class="lineno">   39 </span>  , emptySimpset
<span class="lineno">   40 </span>  , addRule
<span class="lineno">   41 </span>  , delRule
<span class="lineno">   42 </span>  , addRules
<span class="lineno">   43 </span>  , addSimp
<span class="lineno">   44 </span>  , delSimp
<span class="lineno">   45 </span>  , addConv
<span class="lineno">   46 </span>  , addConvs
<span class="lineno">   47 </span>  , scSimpset
<span class="lineno">   48 </span>  , listRules
<span class="lineno">   49 </span>  , shallowRule
<span class="lineno">   50 </span>  -- * Term rewriting
<span class="lineno">   51 </span>  , rewriteSharedTerm
<span class="lineno">   52 </span>  , rewriteSharedTermTypeSafe
<span class="lineno">   53 </span>  -- * Matching
<span class="lineno">   54 </span>  , scMatch
<span class="lineno">   55 </span>  -- * SharedContext
<span class="lineno">   56 </span>  , rewritingSharedContext
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>  , replaceTerm
<span class="lineno">   59 </span>  , hoistIfs
<span class="lineno">   60 </span>  ) where
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>import Control.Monad (MonadPlus(..), (&gt;=&gt;), guard)
<span class="lineno">   63 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   64 </span>import Control.Monad.Trans.Maybe
<span class="lineno">   65 </span>import Data.IntMap (IntMap)
<span class="lineno">   66 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   67 </span>import Data.IntSet (IntSet)
<span class="lineno">   68 </span>import qualified Data.IntSet as IntSet
<span class="lineno">   69 </span>import Data.IORef
<span class="lineno">   70 </span>import qualified Data.Foldable as Foldable
<span class="lineno">   71 </span>import qualified Data.List as List
<span class="lineno">   72 </span>import Data.List.Extra (nubOrd)
<span class="lineno">   73 </span>import Data.Map (Map)
<span class="lineno">   74 </span>import qualified Data.Map as Map
<span class="lineno">   75 </span>import Data.Set (Set)
<span class="lineno">   76 </span>import qualified Data.Set as Set
<span class="lineno">   77 </span>import Control.Monad.Trans.Writer.Strict
<span class="lineno">   78 </span>import Numeric.Natural
<span class="lineno">   79 </span>
<span class="lineno">   80 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts)
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>import SAWCore.Cache
<span class="lineno">   83 </span>import SAWCore.Conversion
<span class="lineno">   84 </span>import SAWCore.Module
<span class="lineno">   85 </span>  ( ctorName
<span class="lineno">   86 </span>  , ctorNumParams
<span class="lineno">   87 </span>  , lookupVarIndexInMap
<span class="lineno">   88 </span>  , Ctor(..)
<span class="lineno">   89 </span>  , DataType(..)
<span class="lineno">   90 </span>  , Def(..)
<span class="lineno">   91 </span>  , ResolvedName(..)
<span class="lineno">   92 </span>  )
<span class="lineno">   93 </span>import SAWCore.Name
<span class="lineno">   94 </span>import SAWCore.Panic (panic)
<span class="lineno">   95 </span>import qualified SAWCore.Recognizer as R
<span class="lineno">   96 </span>import SAWCore.SharedTerm
<span class="lineno">   97 </span>import SAWCore.Term.Functor
<span class="lineno">   98 </span>import SAWCore.Term.Pretty (scPrettyTerm)
<span class="lineno">   99 </span>import SAWCore.Term.Raw
<span class="lineno">  100 </span>import qualified SAWCore.TermNet as Net
<span class="lineno">  101 </span>import SAWCore.Prelude.Constants
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>data RewriteRule a
<span class="lineno">  104 </span>  = RewriteRule
<span class="lineno">  105 </span>    { <span class="istickedoff"><span class="decl"><span class="istickedoff">ctxt</span></span></span> :: [(VarName, Term)]
<span class="lineno">  106 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">lhs</span></span></span> :: Term
<span class="lineno">  107 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">rhs</span></span></span> :: Term
<span class="lineno">  108 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">permutative</span></span></span> :: Bool
<span class="lineno">  109 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">shallow</span></span></span> :: Bool
<span class="lineno">  110 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">annotation</span></span></span> :: Maybe a
<span class="lineno">  111 </span>    }
<span class="lineno">  112 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  113 </span>-- ^ Invariant: The set of loose variables in @lhs@ must be exactly
<span class="lineno">  114 </span>-- @[0 .. length ctxt - 1]@. The @rhs@ may contain a subset of these.
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>-- NB, exclude the annotation from equality tests
<span class="lineno">  117 </span>instance <span class="decl"><span class="nottickedoff">Eq (RewriteRule a)</span></span> where
<span class="lineno">  118 </span>  <span class="decl"><span class="istickedoff">RewriteRule c1 l1 r1 p1 s1 _a1 == RewriteRule c2 l2 r2 p2 s2 _a2 =</span>
<span class="lineno">  119 </span><span class="spaces">    </span><span class="istickedoff">c1 == c2 &amp;&amp; l1 == l2 &amp;&amp; r1 == r2 &amp;&amp; p1 == p2 &amp;&amp; s1 == s2</span></span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>ctxtRewriteRule :: RewriteRule a -&gt; [(VarName, Term)]
<span class="lineno">  122 </span><span class="decl"><span class="nottickedoff">ctxtRewriteRule = ctxt</span></span>
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>lhsRewriteRule :: RewriteRule a -&gt; Term
<span class="lineno">  125 </span><span class="decl"><span class="nottickedoff">lhsRewriteRule = lhs</span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>rhsRewriteRule :: RewriteRule a -&gt; Term
<span class="lineno">  128 </span><span class="decl"><span class="nottickedoff">rhsRewriteRule = rhs</span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>annRewriteRule :: RewriteRule a -&gt; Maybe a
<span class="lineno">  131 </span><span class="decl"><span class="nottickedoff">annRewriteRule = annotation</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>instance Net.Pattern (RewriteRule a) where
<span class="lineno">  134 </span>  <span class="decl"><span class="nottickedoff">toPat (RewriteRule _ lhs _ _ _ _) = Net.toPat lhs</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>-- | Convert a rewrite rule to a proposition (a 'Term' of SAWCore type
<span class="lineno">  137 </span>-- @Prop@) representing the meaning of the rewrite rule.
<span class="lineno">  138 </span>propOfRewriteRule :: SharedContext -&gt; RewriteRule a -&gt; IO Term
<span class="lineno">  139 </span><span class="decl"><span class="nottickedoff">propOfRewriteRule sc rule =</span>
<span class="lineno">  140 </span><span class="spaces">  </span><span class="nottickedoff">do ty &lt;- scTypeOf sc (lhs rule)</span>
<span class="lineno">  141 </span><span class="spaces">     </span><span class="nottickedoff">eq &lt;- scGlobalApply sc &quot;Prelude.Eq&quot; [ty, lhs rule, rhs rule]</span>
<span class="lineno">  142 </span><span class="spaces">     </span><span class="nottickedoff">scPiList sc (ctxt rule) eq</span></span>
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>----------------------------------------------------------------------
<span class="lineno">  145 </span>-- Matching
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>data MatchState =
<span class="lineno">  148 </span>  MatchState
<span class="lineno">  149 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">substitution</span></span></span> :: IntMap Term
<span class="lineno">  150 </span>    -- ^ Mapping of variables, indexed by 'VarIndex'
<span class="lineno">  151 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">constraints</span></span></span> :: [(Term, Natural)]
<span class="lineno">  152 </span>  }
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>emptyMatchState :: MatchState
<span class="lineno">  155 </span><span class="decl"><span class="istickedoff">emptyMatchState = MatchState { substitution = IntMap.empty, constraints = [] }</span></span>
<span class="lineno">  156 </span>
<span class="lineno">  157 </span>
<span class="lineno">  158 </span>-- First-order matching
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | Equivalent to @(lookup k t, insert k x t)@.
<span class="lineno">  161 </span>insertLookup :: VarIndex -&gt; a -&gt; IntMap a -&gt; (Maybe a, IntMap a)
<span class="lineno">  162 </span><span class="decl"><span class="istickedoff">insertLookup k x t = IntMap.insertLookupWithKey (\_ a _ -&gt; a) k x t</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>firstOrderMatch :: [(VarName, Term)] -&gt; Term -&gt; Term -&gt; Maybe (IntMap Term)
<span class="lineno">  165 </span><span class="decl"><span class="istickedoff">firstOrderMatch ctxt pat term = match pat term IntMap.empty</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  167 </span><span class="spaces">    </span><span class="istickedoff">ixs :: IntSet</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">ixs = IntSet.fromList (map (vnIndex . fst) ctxt)</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">match :: Term -&gt; Term -&gt; IntMap Term -&gt; Maybe (IntMap Term)</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">match x y m =</span>
<span class="lineno">  171 </span><span class="spaces">      </span><span class="istickedoff">case (unwrapTermF x, unwrapTermF y) of</span>
<span class="lineno">  172 </span><span class="spaces">        </span><span class="istickedoff">(Variable (vnIndex -&gt; i) _, _) | IntSet.member i ixs -&gt;</span>
<span class="lineno">  173 </span><span class="spaces">            </span><span class="istickedoff">case my' of</span>
<span class="lineno">  174 </span><span class="spaces">              </span><span class="istickedoff">Nothing -&gt; Just m'</span>
<span class="lineno">  175 </span><span class="spaces">              </span><span class="istickedoff">Just y' -&gt; <span class="nottickedoff">if alphaEquiv y y' then Just m' else Nothing</span></span>
<span class="lineno">  176 </span><span class="spaces">            </span><span class="istickedoff">where (my', m') = insertLookup i y m</span>
<span class="lineno">  177 </span><span class="spaces">        </span><span class="istickedoff">(App x1 x2, App y1 y2) -&gt;</span>
<span class="lineno">  178 </span><span class="spaces">            </span><span class="istickedoff">match x1 y1 m &gt;&gt;= match x2 y2</span>
<span class="lineno">  179 </span><span class="spaces">        </span><span class="istickedoff">(FTermF xf, FTermF yf) -&gt;</span>
<span class="lineno">  180 </span><span class="spaces">            </span><span class="istickedoff">do zf &lt;- zipWithFlatTermF match xf yf</span>
<span class="lineno">  181 </span><span class="spaces">               </span><span class="istickedoff">Foldable.foldl (&gt;=&gt;) Just zf <span class="nottickedoff">m</span></span>
<span class="lineno">  182 </span><span class="spaces">        </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  183 </span><span class="spaces">            </span><span class="istickedoff">if alphaEquiv x y then Just m else Nothing</span></span>
<span class="lineno">  184 </span>-- ^ Precondition: Every loose variable in the pattern @pat@ must
<span class="lineno">  185 </span>-- occur as the 2nd argument of an @App@ constructor. This ensures
<span class="lineno">  186 </span>-- that instantiations are well-typed.
<span class="lineno">  187 </span>
<span class="lineno">  188 </span>-- | Test if a term is a constant natural number
<span class="lineno">  189 </span>asConstantNat :: Term -&gt; Maybe Natural
<span class="lineno">  190 </span><span class="decl"><span class="istickedoff">asConstantNat t =</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="istickedoff">case t of</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">(R.asGlobalApply preludeZeroIdent -&gt; Just []) -&gt; <span class="nottickedoff">Just 0</span></span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">(R.asGlobalApply preludeSuccIdent -&gt; Just [x]) -&gt; <span class="nottickedoff">(+ 1)</span> &lt;$&gt; asConstantNat x</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  195 </span><span class="spaces">      </span><span class="istickedoff">do let (f, xs) = R.asApplyAll t</span>
<span class="lineno">  196 </span><span class="spaces">         </span><span class="istickedoff">i &lt;- R.asGlobalDef f</span>
<span class="lineno">  197 </span><span class="spaces">         </span><span class="istickedoff">case xs of</span>
<span class="lineno">  198 </span><span class="spaces">           </span><span class="istickedoff">[x, y]</span>
<span class="lineno">  199 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlyfalse">i == &quot;Prelude.addNat&quot;</span> -&gt; <span class="nottickedoff">(+) &lt;$&gt; asConstantNat x &lt;*&gt; asConstantNat y</span></span>
<span class="lineno">  200 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlyfalse">i == &quot;Prelude.mulNat&quot;</span> -&gt; <span class="nottickedoff">(*) &lt;$&gt; asConstantNat x &lt;*&gt; asConstantNat y</span></span>
<span class="lineno">  201 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlyfalse">i == &quot;Prelude.expNat&quot;</span> -&gt; <span class="nottickedoff">(^) &lt;$&gt; asConstantNat x &lt;*&gt; asConstantNat y</span></span>
<span class="lineno">  202 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlyfalse">i == &quot;Prelude.subNat&quot;</span> -&gt;</span>
<span class="lineno">  203 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do x' &lt;- asConstantNat x</span></span>
<span class="lineno">  204 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">y' &lt;- asConstantNat y</span></span>
<span class="lineno">  205 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">guard (x' &gt;= y')</span></span>
<span class="lineno">  206 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">return (x' - y')</span></span>
<span class="lineno">  207 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlyfalse">i == &quot;Prelude.divNat&quot;</span> -&gt;</span>
<span class="lineno">  208 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do x' &lt;- asConstantNat x</span></span>
<span class="lineno">  209 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">y' &lt;- asConstantNat y</span></span>
<span class="lineno">  210 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">guard (y' &gt; 0)</span></span>
<span class="lineno">  211 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">return (x' `div` y')</span></span>
<span class="lineno">  212 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlyfalse">i == &quot;Prelude.remNat&quot;</span> -&gt;</span>
<span class="lineno">  213 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">do x' &lt;- asConstantNat x</span></span>
<span class="lineno">  214 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">y' &lt;- asConstantNat y</span></span>
<span class="lineno">  215 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">guard (y' &gt; 0)</span></span>
<span class="lineno">  216 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff">return (x' `rem` y')</span></span>
<span class="lineno">  217 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>-- | An enhanced matcher that can handle higher-order patterns.
<span class="lineno">  220 </span>--
<span class="lineno">  221 </span>--   This matching procedure will attempt to find an instantiation
<span class="lineno">  222 </span>--   for the dangling variables appearing in @pattern@.
<span class="lineno">  223 </span>--   The resulting instantation will return terms that are in the same
<span class="lineno">  224 </span>--   variable-scoping context as @term@.  In particular, if @term@
<span class="lineno">  225 </span>--   is closed, then the terms in the instantiation will also be closed.
<span class="lineno">  226 </span>scMatch ::
<span class="lineno">  227 </span>  SharedContext -&gt;
<span class="lineno">  228 </span>  [(VarName, Term)] {- ^ context of unification variables in pattern -} -&gt;
<span class="lineno">  229 </span>  Term {- ^ pattern -} -&gt;
<span class="lineno">  230 </span>  Term {- ^ term -} -&gt;
<span class="lineno">  231 </span>  IO (Maybe (IntMap Term))
<span class="lineno">  232 </span><span class="decl"><span class="istickedoff">scMatch sc ctxt pat term =</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">runMaybeT $</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="istickedoff">do -- lift $ putStrLn $ &quot;********** scMatch **********&quot;</span>
<span class="lineno">  235 </span><span class="spaces">     </span><span class="istickedoff">MatchState inst cs &lt;- match IntSet.empty pat term emptyMatchState</span>
<span class="lineno">  236 </span><span class="spaces">     </span><span class="istickedoff">mapM_ (check inst) cs</span>
<span class="lineno">  237 </span><span class="spaces">     </span><span class="istickedoff">return inst</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">-- The set of VarIndexes of the unification variables</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="istickedoff">ixs :: IntSet</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">ixs = IntSet.fromList (map (vnIndex . fst) ctxt)</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">-- Check that a constraint of the form pat = n for natural number literal n</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">-- is satisfied by the supplied substitution (aka instantiation) inst</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">check :: IntMap Term -&gt; (Term, Natural) -&gt; MaybeT IO ()</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">check inst (t, n) = do</span>
<span class="lineno">  246 </span><span class="spaces">      </span><span class="istickedoff">--lift $ putStrLn $ &quot;checking: &quot; ++ show (t, n)</span>
<span class="lineno">  247 </span><span class="spaces">      </span><span class="istickedoff">-- apply substitution to the term</span>
<span class="lineno">  248 </span><span class="spaces">      </span><span class="istickedoff">t' &lt;- lift $ scInstantiateExt sc inst t</span>
<span class="lineno">  249 </span><span class="spaces">      </span><span class="istickedoff">--lift $ putStrLn $ &quot;t': &quot; ++ show t'</span>
<span class="lineno">  250 </span><span class="spaces">      </span><span class="istickedoff">-- constant-fold nat operations</span>
<span class="lineno">  251 </span><span class="spaces">      </span><span class="istickedoff">-- ensure that it evaluates to the same number</span>
<span class="lineno">  252 </span><span class="spaces">      </span><span class="istickedoff">case asConstantNat t' of</span>
<span class="lineno">  253 </span><span class="spaces">        </span><span class="istickedoff">Just i | <span class="nottickedoff">i == n</span> -&gt; <span class="nottickedoff">return ()</span></span>
<span class="lineno">  254 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; mzero</span>
<span class="lineno">  255 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">-- Check if a term is a higher-order variable pattern, i.e., a free variable</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">-- (meaning one that can match anything) applied to 0 or more bound variable</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">-- arguments.</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">asVarPat :: IntSet -&gt; Term -&gt; Maybe (VarIndex, [(VarName, Term)])</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">asVarPat locals = go []</span>
<span class="lineno">  261 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  262 </span><span class="spaces">        </span><span class="istickedoff">go js x =</span>
<span class="lineno">  263 </span><span class="spaces">          </span><span class="istickedoff">case unwrapTermF x of</span>
<span class="lineno">  264 </span><span class="spaces">            </span><span class="istickedoff">Variable nm _tp</span>
<span class="lineno">  265 </span><span class="spaces">              </span><span class="istickedoff">| IntSet.member (vnIndex nm) ixs -&gt; Just (vnIndex nm, js)</span>
<span class="lineno">  266 </span><span class="spaces">              </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>  -&gt; Nothing</span>
<span class="lineno">  267 </span><span class="spaces">            </span><span class="istickedoff">App t (unwrapTermF -&gt; Variable nm tp)</span>
<span class="lineno">  268 </span><span class="spaces">              </span><span class="istickedoff">| IntSet.member (vnIndex nm) locals -&gt; go <span class="nottickedoff">((nm, tp) : js)</span> t</span>
<span class="lineno">  269 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno">  270 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="istickedoff">-- Test if term y matches pattern x, meaning whether there is a substitution</span>
<span class="lineno">  272 </span><span class="spaces">    </span><span class="istickedoff">-- to the free variables of x to make it equal to y.</span>
<span class="lineno">  273 </span><span class="spaces">    </span><span class="istickedoff">-- The IntSet contains the VarIndexes named variables that are locally bound.</span>
<span class="lineno">  274 </span><span class="spaces">    </span><span class="istickedoff">match :: IntSet -&gt; Term -&gt; Term -&gt; MatchState -&gt; MaybeT IO MatchState</span>
<span class="lineno">  275 </span><span class="spaces">    </span><span class="istickedoff">match _ t@(STApp{stAppIndex = i}) (STApp{stAppIndex = j}) s</span>
<span class="lineno">  276 </span><span class="spaces">      </span><span class="istickedoff">| closedTerm t &amp;&amp; i == j = return s</span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">match locals x y s@(MatchState m cs) =</span>
<span class="lineno">  278 </span><span class="spaces">      </span><span class="istickedoff">-- (lift $ putStrLn $ &quot;matching (lhs): &quot; ++ scPrettyTerm PPS.defaultOpts x) &gt;&gt;</span>
<span class="lineno">  279 </span><span class="spaces">      </span><span class="istickedoff">-- (lift $ putStrLn $ &quot;matching (rhs): &quot; ++ scPrettyTerm PPS.defaultOpts y) &gt;&gt;</span>
<span class="lineno">  280 </span><span class="spaces">      </span><span class="istickedoff">case asVarPat locals x of</span>
<span class="lineno">  281 </span><span class="spaces">        </span><span class="istickedoff">-- If the lhs pattern is of the form (?u b1..bk) where ?u is a</span>
<span class="lineno">  282 </span><span class="spaces">        </span><span class="istickedoff">-- unification variable and b1..bk are all locally bound</span>
<span class="lineno">  283 </span><span class="spaces">        </span><span class="istickedoff">-- variables: First check whether the rhs contains any locally</span>
<span class="lineno">  284 </span><span class="spaces">        </span><span class="istickedoff">-- bound variables *not* in the list b1..bk. If it contains any</span>
<span class="lineno">  285 </span><span class="spaces">        </span><span class="istickedoff">-- others, then there is no match. If it only uses a subset of</span>
<span class="lineno">  286 </span><span class="spaces">        </span><span class="istickedoff">-- b1..bk, then we can instantiate ?u to (\b1..bk -&gt; rhs).</span>
<span class="lineno">  287 </span><span class="spaces">        </span><span class="istickedoff">Just (i, vs) -&gt;</span>
<span class="lineno">  288 </span><span class="spaces">          </span><span class="istickedoff">do -- ensure parameter variables are distinct</span>
<span class="lineno">  289 </span><span class="spaces">             </span><span class="istickedoff">guard (Set.size (Set.fromList vs) == length vs)</span>
<span class="lineno">  290 </span><span class="spaces">             </span><span class="istickedoff">-- ensure y mentions only variables that are in vs</span>
<span class="lineno">  291 </span><span class="spaces">             </span><span class="istickedoff">let <span class="nottickedoff">vset = IntSet.fromList (map (vnIndex . fst) vs)</span></span>
<span class="lineno">  292 </span><span class="spaces">             </span><span class="istickedoff">guard (IntSet.disjoint (IntSet.difference locals <span class="nottickedoff">vset</span>) <span class="nottickedoff">(freeVars y)</span>)</span>
<span class="lineno">  293 </span><span class="spaces">             </span><span class="istickedoff">y2 &lt;- lift $ scLambdaList <span class="nottickedoff">sc</span> vs y</span>
<span class="lineno">  294 </span><span class="spaces">             </span><span class="istickedoff">let (my3, m') = insertLookup i y2 m</span>
<span class="lineno">  295 </span><span class="spaces">             </span><span class="istickedoff">case my3 of</span>
<span class="lineno">  296 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; return (MatchState m' cs)</span>
<span class="lineno">  297 </span><span class="spaces">               </span><span class="istickedoff">Just y3 -&gt; if y2 == y3 then return (MatchState m' cs) else mzero</span>
<span class="lineno">  298 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  299 </span><span class="spaces">          </span><span class="istickedoff">case (unwrapTermF x, unwrapTermF y) of</span>
<span class="lineno">  300 </span><span class="spaces">            </span><span class="istickedoff">(_, FTermF (NatLit n))</span>
<span class="lineno">  301 </span><span class="spaces">              </span><span class="istickedoff">| Just [x'] &lt;- R.asGlobalApply preludeSuccIdent x</span>
<span class="lineno">  302 </span><span class="spaces">              </span><span class="istickedoff">, n &gt; 0 -&gt;</span>
<span class="lineno">  303 </span><span class="spaces">                </span><span class="istickedoff">do y' &lt;- lift $ scNat sc (n-1)</span>
<span class="lineno">  304 </span><span class="spaces">                   </span><span class="istickedoff">match locals x' y' s</span>
<span class="lineno">  305 </span><span class="spaces">            </span><span class="istickedoff">-- check that neither x nor y contains bound variables less than `depth`</span>
<span class="lineno">  306 </span><span class="spaces">            </span><span class="istickedoff">(FTermF xf, FTermF yf) -&gt;</span>
<span class="lineno">  307 </span><span class="spaces">              </span><span class="istickedoff">case zipWithFlatTermF (match locals) xf yf of</span>
<span class="lineno">  308 </span><span class="spaces">                </span><span class="istickedoff">Nothing -&gt; mzero</span>
<span class="lineno">  309 </span><span class="spaces">                </span><span class="istickedoff">Just zf -&gt; Foldable.foldl (&gt;=&gt;) return zf s</span>
<span class="lineno">  310 </span><span class="spaces">            </span><span class="istickedoff">(App x1 x2, App y1 y2) -&gt;</span>
<span class="lineno">  311 </span><span class="spaces">              </span><span class="istickedoff">match locals x1 y1 s &gt;&gt;= match locals x2 y2</span>
<span class="lineno">  312 </span><span class="spaces">            </span><span class="istickedoff">(Lambda nm t1 x1, Lambda _ t2 x2) -&gt;</span>
<span class="lineno">  313 </span><span class="spaces">              </span><span class="istickedoff">match <span class="nottickedoff">locals</span> t1 t2 s &gt;&gt;= match (IntSet.insert (vnIndex nm) locals) x1 x2</span>
<span class="lineno">  314 </span><span class="spaces">            </span><span class="istickedoff">(Pi nm t1 x1, Pi _ t2 x2) -&gt;</span>
<span class="lineno">  315 </span><span class="spaces">              </span><span class="istickedoff">match locals t1 t2 s &gt;&gt;= <span class="nottickedoff">match (IntSet.insert (vnIndex nm) locals) x1 x2</span></span>
<span class="lineno">  316 </span><span class="spaces">            </span><span class="istickedoff">(App _ _, FTermF (NatLit n)) -&gt;</span>
<span class="lineno">  317 </span><span class="spaces">              </span><span class="istickedoff">-- add deferred constraint</span>
<span class="lineno">  318 </span><span class="spaces">              </span><span class="istickedoff">return (MatchState m ((x, <span class="nottickedoff">n</span>) : <span class="nottickedoff">cs</span>))</span>
<span class="lineno">  319 </span><span class="spaces">            </span><span class="istickedoff">(_, _) -&gt;</span>
<span class="lineno">  320 </span><span class="spaces">              </span><span class="istickedoff">-- other possible matches are local vars and constants</span>
<span class="lineno">  321 </span><span class="spaces">              </span><span class="istickedoff">if x == y then return s else mzero</span></span>
<span class="lineno">  322 </span>
<span class="lineno">  323 </span>----------------------------------------------------------------------
<span class="lineno">  324 </span>-- Building rewrite rules
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>eqIdent :: Ident
<span class="lineno">  327 </span><span class="decl"><span class="istickedoff">eqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;Eq&quot;</span></span>
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>ecEqIdent :: Ident
<span class="lineno">  330 </span><span class="decl"><span class="istickedoff">ecEqIdent = mkIdent (mkModuleName [&quot;Cryptol&quot;]) &quot;ecEq&quot;</span></span>
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>bvEqIdent :: Ident
<span class="lineno">  333 </span><span class="decl"><span class="istickedoff">bvEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;bvEq&quot;</span></span>
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>boolEqIdent :: Ident
<span class="lineno">  336 </span><span class="decl"><span class="istickedoff">boolEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;boolEq&quot;</span></span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>vecEqIdent :: Ident
<span class="lineno">  339 </span><span class="decl"><span class="istickedoff">vecEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;vecEq&quot;</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>pairEqIdent :: Ident
<span class="lineno">  342 </span><span class="decl"><span class="istickedoff">pairEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;pairEq&quot;</span></span>
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>arrayEqIdent :: Ident
<span class="lineno">  345 </span><span class="decl"><span class="istickedoff">arrayEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;arrayEq&quot;</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>equalNatIdent :: Ident
<span class="lineno">  348 </span><span class="decl"><span class="istickedoff">equalNatIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;equalNat&quot;</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>intEqIdent :: Ident
<span class="lineno">  351 </span><span class="decl"><span class="istickedoff">intEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;intEq&quot;</span></span>
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>intModEqIdent :: Ident
<span class="lineno">  354 </span><span class="decl"><span class="istickedoff">intModEqIdent = mkIdent (mkModuleName [&quot;Prelude&quot;]) &quot;intModEq&quot;</span></span>
<span class="lineno">  355 </span>
<span class="lineno">  356 </span>-- | Converts a universally quantified equality proposition from a
<span class="lineno">  357 </span>-- Term representation to a RewriteRule.
<span class="lineno">  358 </span>ruleOfTerm :: Term -&gt; Maybe a -&gt; RewriteRule a
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff">ruleOfTerm t ann =</span>
<span class="lineno">  360 </span><span class="spaces">  </span><span class="istickedoff">do let (vars, body) = R.asPiList t</span>
<span class="lineno">  361 </span><span class="spaces">     </span><span class="istickedoff">case R.asGlobalApply eqIdent body of</span>
<span class="lineno">  362 </span><span class="spaces">       </span><span class="istickedoff">Just [_, x, y] -&gt; mkRewriteRule vars x y False ann</span>
<span class="lineno">  363 </span><span class="spaces">       </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;ruleOfTerm&quot; [&quot;Illegal argument&quot;]</span></span></span>
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>-- Test whether a rewrite rule is permutative
<span class="lineno">  366 </span>-- this is a rule that immediately loops whether used forwards or backwards.
<span class="lineno">  367 </span>rulePermutes :: [(VarName, Term)] -&gt; Term -&gt; Term -&gt; Bool
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">rulePermutes ctxt lhs rhs =</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">case firstOrderMatch ctxt lhs rhs of</span>
<span class="lineno">  370 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; False -- rhs is not an instance of lhs</span>
<span class="lineno">  371 </span><span class="spaces">        </span><span class="istickedoff">Just _ -&gt;</span>
<span class="lineno">  372 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case firstOrderMatch ctxt rhs lhs of</span></span>
<span class="lineno">  373 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt; False -- but here we have a looping rule, not good!</span></span>
<span class="lineno">  374 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Just _ -&gt; True</span></span></span>
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>mkRewriteRule :: [(VarName, Term)] -&gt; Term -&gt; Term -&gt; Bool -&gt; Maybe a -&gt; RewriteRule a
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">mkRewriteRule c l r shallow ann =</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="istickedoff">RewriteRule</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">{ ctxt = c</span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">, lhs = l</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="istickedoff">, rhs = r</span>
<span class="lineno">  382 </span><span class="spaces">    </span><span class="istickedoff">, permutative = rulePermutes c l r</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="istickedoff">, shallow = shallow</span>
<span class="lineno">  384 </span><span class="spaces">    </span><span class="istickedoff">, annotation = ann</span>
<span class="lineno">  385 </span><span class="spaces">    </span><span class="istickedoff">}</span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>-- | Converts a universally quantified equality proposition between the
<span class="lineno">  388 </span>-- two given terms to a RewriteRule.
<span class="lineno">  389 </span>ruleOfTerms :: Term -&gt; Term -&gt; RewriteRule a
<span class="lineno">  390 </span><span class="decl"><span class="istickedoff">ruleOfTerms l r = mkRewriteRule [] l r False Nothing</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>-- | Converts a parameterized equality predicate to a RewriteRule,
<span class="lineno">  393 </span>-- returning 'Nothing' if the predicate is not an equation.
<span class="lineno">  394 </span>ruleOfProp :: SharedContext -&gt; Term -&gt; Maybe a -&gt; IO (Maybe (RewriteRule a))
<span class="lineno">  395 </span><span class="decl"><span class="istickedoff">ruleOfProp sc term ann =</span>
<span class="lineno">  396 </span><span class="spaces">  </span><span class="istickedoff">case R.asPi term of</span>
<span class="lineno">  397 </span><span class="spaces">  </span><span class="istickedoff">Just (nm, tp, body) -&gt;</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="istickedoff">do rule &lt;- ruleOfProp sc body ann</span>
<span class="lineno">  399 </span><span class="spaces">       </span><span class="istickedoff">pure $ (\r -&gt; r { ctxt = (nm, tp) : ctxt r}) &lt;$&gt; rule</span>
<span class="lineno">  400 </span><span class="spaces">  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">case R.asLambda term of</span>
<span class="lineno">  402 </span><span class="spaces">    </span><span class="istickedoff">Just (nm, tp, body) -&gt;</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do rule &lt;- ruleOfProp sc body ann</span></span>
<span class="lineno">  404 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">pure $ (\r -&gt; r { ctxt = (nm, tp) : ctxt r}) &lt;$&gt; rule</span></span>
<span class="lineno">  405 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  406 </span><span class="spaces">      </span><span class="istickedoff">case term of</span>
<span class="lineno">  407 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply ecEqIdent -&gt; Just [_, _, x, y]) -&gt; eqRule x y</span>
<span class="lineno">  408 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply bvEqIdent -&gt; Just [_, x, y]) -&gt; eqRule x y</span>
<span class="lineno">  409 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply equalNatIdent -&gt; Just [x, y]) -&gt; <span class="nottickedoff">eqRule x y</span></span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply boolEqIdent -&gt; Just [x, y]) -&gt; <span class="nottickedoff">eqRule x y</span></span>
<span class="lineno">  411 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply vecEqIdent -&gt; Just [_, _, _, x, y]) -&gt; <span class="nottickedoff">eqRule x y</span></span>
<span class="lineno">  412 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply pairEqIdent -&gt; Just [_, _, _, _, x, y]) -&gt; eqRule x y</span>
<span class="lineno">  413 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply arrayEqIdent -&gt; Just [_, _, x, y]) -&gt; <span class="nottickedoff">eqRule x y</span></span>
<span class="lineno">  414 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply intEqIdent -&gt; Just [x, y]) -&gt; eqRule x y</span>
<span class="lineno">  415 </span><span class="spaces">        </span><span class="istickedoff">(R.asGlobalApply intModEqIdent -&gt; Just [_, x, y]) -&gt; eqRule x y</span>
<span class="lineno">  416 </span><span class="spaces">        </span><span class="istickedoff">(unwrapTermF -&gt; Constant nm) -&gt;</span>
<span class="lineno">  417 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do mres &lt;- lookupVarIndexInMap (nameIndex nm) &lt;$&gt; scGetModuleMap sc</span></span>
<span class="lineno">  418 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">case mres of</span></span>
<span class="lineno">  419 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">Just (ResolvedDef (defBody -&gt; Just body)) -&gt; ruleOfProp sc body ann</span></span>
<span class="lineno">  420 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; pure Nothing</span></span>
<span class="lineno">  421 </span><span class="spaces">        </span><span class="istickedoff">(R.asEq -&gt; Just (_, x, y)) -&gt; <span class="nottickedoff">eqRule x y</span></span>
<span class="lineno">  422 </span><span class="spaces">        </span><span class="istickedoff">(R.asEqTrue -&gt; Just body) -&gt; ruleOfProp sc body ann</span>
<span class="lineno">  423 </span><span class="spaces">        </span><span class="istickedoff">(R.asApplyAll -&gt; (R.asConstant -&gt; Just nm, args)) -&gt;</span>
<span class="lineno">  424 </span><span class="spaces">          </span><span class="istickedoff">do mres &lt;- lookupVarIndexInMap (nameIndex nm) &lt;$&gt; scGetModuleMap sc</span>
<span class="lineno">  425 </span><span class="spaces">             </span><span class="istickedoff">case mres of</span>
<span class="lineno">  426 </span><span class="spaces">               </span><span class="istickedoff">Just (ResolvedDef (defBody -&gt; Just body)) -&gt;</span>
<span class="lineno">  427 </span><span class="spaces">                 </span><span class="istickedoff">do app &lt;- scApplyAllBeta sc body args</span>
<span class="lineno">  428 </span><span class="spaces">                    </span><span class="istickedoff">ruleOfProp <span class="nottickedoff">sc</span> app <span class="nottickedoff">ann</span></span>
<span class="lineno">  429 </span><span class="spaces">               </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno">  430 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno">  431 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  433 </span><span class="spaces">    </span><span class="istickedoff">eqRule x y = pure $ Just $ mkRewriteRule [] x y False ann</span></span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>-- | Generate a rewrite rule from the type of an identifier, using 'ruleOfTerm'
<span class="lineno">  436 </span>scEqRewriteRule :: SharedContext -&gt; Ident -&gt; IO (RewriteRule a)
<span class="lineno">  437 </span><span class="decl"><span class="istickedoff">scEqRewriteRule sc i = ruleOfTerm &lt;$&gt; scTypeOfIdent sc i &lt;*&gt; pure Nothing</span></span>
<span class="lineno">  438 </span>
<span class="lineno">  439 </span>-- | Collects rewrite rules from named constants, whose types must be equations.
<span class="lineno">  440 </span>scEqsRewriteRules :: SharedContext -&gt; [Ident] -&gt; IO [RewriteRule a]
<span class="lineno">  441 </span><span class="decl"><span class="istickedoff">scEqsRewriteRules sc = mapM (scEqRewriteRule sc)</span></span>
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>-- | Transform the given rewrite rule to a set of one or more
<span class="lineno">  444 </span>-- equivalent rewrite rules, if possible.
<span class="lineno">  445 </span>--
<span class="lineno">  446 </span>-- * If the rhs is a lambda, then add an argument to the lhs.
<span class="lineno">  447 </span>-- * If the rhs is a recursor, then split into a separate rule for each constructor.
<span class="lineno">  448 </span>-- * If the rhs is a record, then split into a separate rule for each accessor.
<span class="lineno">  449 </span>scExpandRewriteRule :: SharedContext -&gt; RewriteRule a -&gt; IO (Maybe [RewriteRule a])
<span class="lineno">  450 </span><span class="decl"><span class="istickedoff">scExpandRewriteRule sc (RewriteRule ctxt lhs rhs _ shallow ann) =</span>
<span class="lineno">  451 </span><span class="spaces">  </span><span class="istickedoff">case R.asLambda rhs of</span>
<span class="lineno">  452 </span><span class="spaces">  </span><span class="istickedoff">Just (nm, tp, body) -&gt;</span>
<span class="lineno">  453 </span><span class="spaces">    </span><span class="istickedoff">do let ctxt' = ctxt ++ [(nm, tp)]</span>
<span class="lineno">  454 </span><span class="spaces">       </span><span class="istickedoff">var0 &lt;- scVariable sc nm tp</span>
<span class="lineno">  455 </span><span class="spaces">       </span><span class="istickedoff">lhs' &lt;- scApply sc lhs var0</span>
<span class="lineno">  456 </span><span class="spaces">       </span><span class="istickedoff">pure $ Just [mkRewriteRule ctxt' lhs' body shallow ann]</span>
<span class="lineno">  457 </span><span class="spaces">  </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">case rhs of</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">(R.asRecordValue -&gt; Just m) -&gt;</span>
<span class="lineno">  460 </span><span class="spaces">      </span><span class="istickedoff">do let mkRule (k, x) =</span>
<span class="lineno">  461 </span><span class="spaces">               </span><span class="istickedoff">do l &lt;- scRecordSelect sc lhs k</span>
<span class="lineno">  462 </span><span class="spaces">                  </span><span class="istickedoff">return (mkRewriteRule ctxt l x shallow ann)</span>
<span class="lineno">  463 </span><span class="spaces">         </span><span class="istickedoff">Just &lt;$&gt; traverse mkRule (Map.assocs m)</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">(R.asApplyAll -&gt;</span>
<span class="lineno">  465 </span><span class="spaces">     </span><span class="istickedoff">(R.asRecursorApp -&gt; Just (r, crec),</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="istickedoff">splitAt (recursorNumParams crec) -&gt;</span>
<span class="lineno">  467 </span><span class="spaces">      </span><span class="istickedoff">(params,</span>
<span class="lineno">  468 </span><span class="spaces">       </span><span class="istickedoff">motive :</span>
<span class="lineno">  469 </span><span class="spaces">       </span><span class="istickedoff">(splitAt (length (recursorCtorOrder crec)) -&gt;</span>
<span class="lineno">  470 </span><span class="spaces">        </span><span class="istickedoff">(elims,</span>
<span class="lineno">  471 </span><span class="spaces">         </span><span class="istickedoff">splitAt (recursorNumIxs crec) -&gt;</span>
<span class="lineno">  472 </span><span class="spaces">         </span><span class="istickedoff">(_ixs, (R.asVariable -&gt; Just (x, xt)) : more))))))</span>
<span class="lineno">  473 </span><span class="spaces">      </span><span class="istickedoff">| (ctxt1, _ : ctxt2) &lt;- break ((== x) . fst) ctxt -&gt;</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">do -- ti is the type of the value being scrutinized</span>
<span class="lineno">  475 </span><span class="spaces">         </span><span class="istickedoff">ti &lt;- scWhnf sc xt</span>
<span class="lineno">  476 </span><span class="spaces">         </span><span class="istickedoff">-- The datatype parameters are also in context @ctxt1@.</span>
<span class="lineno">  477 </span><span class="spaces">         </span><span class="istickedoff">let (_d, (params1, _ixs)) = fmap (splitAt (recursorNumParams crec)) (R.asApplyAll ti)</span>
<span class="lineno">  478 </span><span class="spaces">         </span><span class="istickedoff">let ctorRule ctor =</span>
<span class="lineno">  479 </span><span class="spaces">               </span><span class="istickedoff">do -- Compute the argument types @argTs@.</span>
<span class="lineno">  480 </span><span class="spaces">                  </span><span class="istickedoff">ctorT &lt;- piAppType (ctorType ctor) params1</span>
<span class="lineno">  481 </span><span class="spaces">                  </span><span class="istickedoff">argCtx &lt;- fst &lt;$&gt; asFreshPiList sc ctorT</span>
<span class="lineno">  482 </span><span class="spaces">                  </span><span class="istickedoff">-- Build a fully-applied constructor @c@.</span>
<span class="lineno">  483 </span><span class="spaces">                  </span><span class="istickedoff">args &lt;- scVariables sc argCtx</span>
<span class="lineno">  484 </span><span class="spaces">                  </span><span class="istickedoff">c &lt;- scConstApply sc (ctorName ctor) (params1 ++ args)</span>
<span class="lineno">  485 </span><span class="spaces">                  </span><span class="istickedoff">-- Define function to substitute the constructor @c@</span>
<span class="lineno">  486 </span><span class="spaces">                  </span><span class="istickedoff">-- in for the old local variable @x@.</span>
<span class="lineno">  487 </span><span class="spaces">                  </span><span class="istickedoff">let subst = IntMap.singleton (vnIndex x) c</span>
<span class="lineno">  488 </span><span class="spaces">                  </span><span class="istickedoff">let adjust t = scInstantiateExt sc subst t</span>
<span class="lineno">  489 </span><span class="spaces">                  </span><span class="istickedoff">-- Build the list of types of the new context.</span>
<span class="lineno">  490 </span><span class="spaces">                  </span><span class="istickedoff">ctxt2' &lt;- traverse (traverse adjust) ctxt2</span>
<span class="lineno">  491 </span><span class="spaces">                  </span><span class="istickedoff">let ctxt' = ctxt1 ++ argCtx ++ ctxt2'</span>
<span class="lineno">  492 </span><span class="spaces">                  </span><span class="istickedoff">-- Substitute the new constructor value to make the</span>
<span class="lineno">  493 </span><span class="spaces">                  </span><span class="istickedoff">-- new lhs and rhs in context @ctxt'@.</span>
<span class="lineno">  494 </span><span class="spaces">                  </span><span class="istickedoff">lhs' &lt;- adjust lhs</span>
<span class="lineno">  495 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  496 </span><span class="spaces">                  </span><span class="istickedoff">r'  &lt;- adjust r</span>
<span class="lineno">  497 </span><span class="spaces">                  </span><span class="istickedoff">more' &lt;- traverse <span class="nottickedoff">adjust</span> more</span>
<span class="lineno">  498 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  499 </span><span class="spaces">                  </span><span class="istickedoff">rhs1 &lt;- scReduceRecursor sc r' crec params motive elims (ctorName ctor) args</span>
<span class="lineno">  500 </span><span class="spaces">                  </span><span class="istickedoff">rhs2 &lt;- scApplyAll <span class="nottickedoff">sc</span> rhs1 more'</span>
<span class="lineno">  501 </span><span class="spaces">                  </span><span class="istickedoff">rhs3 &lt;- betaReduce rhs2</span>
<span class="lineno">  502 </span><span class="spaces">                  </span><span class="istickedoff">-- re-fold recursive occurrences of the original rhs</span>
<span class="lineno">  503 </span><span class="spaces">                  </span><span class="istickedoff">let ss = addRule (mkRewriteRule <span class="nottickedoff">ctxt</span> rhs lhs <span class="nottickedoff">shallow</span> <span class="nottickedoff">Nothing</span>) emptySimpset</span>
<span class="lineno">  504 </span><span class="spaces">                  </span><span class="istickedoff">(_,rhs') &lt;- rewriteSharedTerm sc (ss :: Simpset ()) rhs3</span>
<span class="lineno">  505 </span><span class="spaces">                  </span><span class="istickedoff">return (mkRewriteRule ctxt' lhs' rhs' shallow ann)</span>
<span class="lineno">  506 </span><span class="spaces">         </span><span class="istickedoff">let d = recursorDataType crec</span>
<span class="lineno">  507 </span><span class="spaces">         </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  508 </span><span class="spaces">         </span><span class="istickedoff">dt &lt;-</span>
<span class="lineno">  509 </span><span class="spaces">           </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex d) mm of</span>
<span class="lineno">  510 </span><span class="spaces">             </span><span class="istickedoff">Just (ResolvedDataType dt) -&gt; pure dt</span>
<span class="lineno">  511 </span><span class="spaces">             </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">panic &quot;scExpandRewriteRule&quot; [&quot;Datatype not found: &quot; &lt;&gt; toAbsoluteName (nameInfo d)]</span></span>
<span class="lineno">  512 </span><span class="spaces">         </span><span class="istickedoff">rules &lt;- traverse ctorRule (dtCtors dt)</span>
<span class="lineno">  513 </span><span class="spaces">         </span><span class="istickedoff">return (Just rules)</span>
<span class="lineno">  514 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; return Nothing</span>
<span class="lineno">  515 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  516 </span><span class="spaces">    </span><span class="istickedoff">piAppType :: Term -&gt; [Term] -&gt; IO Term</span>
<span class="lineno">  517 </span><span class="spaces">    </span><span class="istickedoff">piAppType funtype [] = return funtype</span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="istickedoff">piAppType funtype (arg : args) =</span>
<span class="lineno">  519 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do funtype' &lt;- reducePi sc funtype arg</span></span>
<span class="lineno">  520 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">piAppType funtype' args</span></span>
<span class="lineno">  521 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  522 </span><span class="spaces">    </span><span class="istickedoff">betaReduce :: Term -&gt; IO Term</span>
<span class="lineno">  523 </span><span class="spaces">    </span><span class="istickedoff">betaReduce t =</span>
<span class="lineno">  524 </span><span class="spaces">      </span><span class="istickedoff">case R.asApp t of</span>
<span class="lineno">  525 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; return t</span>
<span class="lineno">  526 </span><span class="spaces">        </span><span class="istickedoff">Just (f, arg) -&gt;</span>
<span class="lineno">  527 </span><span class="spaces">          </span><span class="istickedoff">do f' &lt;- betaReduce f</span>
<span class="lineno">  528 </span><span class="spaces">             </span><span class="istickedoff">case R.asLambda f' of</span>
<span class="lineno">  529 </span><span class="spaces">               </span><span class="istickedoff">Nothing -&gt; scApply sc f' arg</span>
<span class="lineno">  530 </span><span class="spaces">               </span><span class="istickedoff">Just (vn, _, body) -&gt;</span>
<span class="lineno">  531 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">scInstantiateExt sc (IntMap.singleton (vnIndex vn) arg) body</span></span></span>
<span class="lineno">  532 </span>
<span class="lineno">  533 </span>-- | Like 'R.asPiList', but freshen all variables in the context.
<span class="lineno">  534 </span>asFreshPiList :: SharedContext -&gt; Term -&gt; IO ([(VarName, Term)], Term)
<span class="lineno">  535 </span><span class="decl"><span class="istickedoff">asFreshPiList sc t =</span>
<span class="lineno">  536 </span><span class="spaces">  </span><span class="istickedoff">case R.asPi t of</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; pure ([], <span class="nottickedoff">t</span>)</span>
<span class="lineno">  538 </span><span class="spaces">    </span><span class="istickedoff">Just (x, t1, t2) -&gt;</span>
<span class="lineno">  539 </span><span class="spaces">      </span><span class="istickedoff">do -- never use &quot;_&quot; as the base name</span>
<span class="lineno">  540 </span><span class="spaces">         </span><span class="istickedoff">let basename = if <span class="tickonlytrue">vnName x == &quot;_&quot;</span> then &quot;_x&quot; else <span class="nottickedoff">vnName x</span></span>
<span class="lineno">  541 </span><span class="spaces">         </span><span class="istickedoff">x' &lt;- scFreshVarName sc basename</span>
<span class="lineno">  542 </span><span class="spaces">         </span><span class="istickedoff">var &lt;- scVariable sc x' t1</span>
<span class="lineno">  543 </span><span class="spaces">         </span><span class="istickedoff">t2' &lt;- scInstantiateExt <span class="nottickedoff">sc</span> (IntMap.singleton (vnIndex x) <span class="nottickedoff">var</span>) t2</span>
<span class="lineno">  544 </span><span class="spaces">         </span><span class="istickedoff">(ctx, body) &lt;- asFreshPiList <span class="nottickedoff">sc</span> t2'</span>
<span class="lineno">  545 </span><span class="spaces">         </span><span class="istickedoff">pure ((x', t1) : ctx, <span class="nottickedoff">body</span>)</span></span>
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>-- | Repeatedly apply the rule transformations in 'scExpandRewriteRule'.
<span class="lineno">  548 </span>scExpandRewriteRules :: SharedContext -&gt; [RewriteRule a] -&gt; IO [RewriteRule a]
<span class="lineno">  549 </span><span class="decl"><span class="istickedoff">scExpandRewriteRules sc rs =</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">case rs of</span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; return []</span>
<span class="lineno">  552 </span><span class="spaces">    </span><span class="istickedoff">r : rs2 -&gt;</span>
<span class="lineno">  553 </span><span class="spaces">      </span><span class="istickedoff">do m &lt;- scExpandRewriteRule sc r</span>
<span class="lineno">  554 </span><span class="spaces">         </span><span class="istickedoff">case m of</span>
<span class="lineno">  555 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; (r :) &lt;$&gt; scExpandRewriteRules sc rs2</span>
<span class="lineno">  556 </span><span class="spaces">           </span><span class="istickedoff">Just rs1 -&gt; scExpandRewriteRules sc (rs1 ++ rs2)</span></span>
<span class="lineno">  557 </span>
<span class="lineno">  558 </span>-- | Create a rewrite rule for a definition that expands the definition, if it
<span class="lineno">  559 </span>-- has a body to expand to, otherwise return the empty list
<span class="lineno">  560 </span>scDefRewriteRules :: SharedContext -&gt; Def -&gt; IO [RewriteRule a]
<span class="lineno">  561 </span><span class="decl"><span class="istickedoff">scDefRewriteRules sc d =</span>
<span class="lineno">  562 </span><span class="spaces">  </span><span class="istickedoff">case defBody d of</span>
<span class="lineno">  563 </span><span class="spaces">    </span><span class="istickedoff">Just body -&gt;</span>
<span class="lineno">  564 </span><span class="spaces">      </span><span class="istickedoff">do lhs &lt;- scDefTerm sc d</span>
<span class="lineno">  565 </span><span class="spaces">         </span><span class="istickedoff">rhs &lt;- scSharedTerm sc body</span>
<span class="lineno">  566 </span><span class="spaces">         </span><span class="istickedoff">scExpandRewriteRules sc [mkRewriteRule [] lhs rhs False Nothing]</span>
<span class="lineno">  567 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  568 </span><span class="spaces">      </span><span class="istickedoff">pure []</span></span>
<span class="lineno">  569 </span>
<span class="lineno">  570 </span>-- | A &quot;shallow&quot; rule is one where further
<span class="lineno">  571 </span>--   rewrites are not applied to the result
<span class="lineno">  572 </span>--   of a rewrite.
<span class="lineno">  573 </span>shallowRule :: RewriteRule a -&gt; RewriteRule a
<span class="lineno">  574 </span><span class="decl"><span class="nottickedoff">shallowRule r = r{ shallow = True }</span></span>
<span class="lineno">  575 </span>
<span class="lineno">  576 </span>----------------------------------------------------------------------
<span class="lineno">  577 </span>-- Simpsets
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>-- | Invariant: 'Simpset's should not contain reflexive rules. We avoid
<span class="lineno">  580 </span>-- adding them in 'addRule' below.
<span class="lineno">  581 </span>type Simpset a = Net.Net (Either (RewriteRule a) Conversion)
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>emptySimpset :: Simpset a
<span class="lineno">  584 </span><span class="decl"><span class="istickedoff">emptySimpset = Net.empty</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>addRule :: RewriteRule a -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  587 </span><span class="decl"><span class="istickedoff">addRule rule | lhs rule /= rhs rule = Net.insert_term (lhs rule, Left rule)</span>
<span class="lineno">  588 </span><span class="spaces">             </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = id</span></span>
<span class="lineno">  589 </span>
<span class="lineno">  590 </span>delRule :: RewriteRule a -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  591 </span><span class="decl"><span class="nottickedoff">delRule rule = Net.delete_term (lhs rule, Left rule)</span></span>
<span class="lineno">  592 </span>
<span class="lineno">  593 </span>addRules :: [RewriteRule a] -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  594 </span><span class="decl"><span class="istickedoff">addRules rules ss = foldr addRule ss rules</span></span>
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>addSimp :: Term -&gt; Maybe a -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  597 </span><span class="decl"><span class="nottickedoff">addSimp prop ann = addRule (ruleOfTerm prop ann)</span></span>
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>delSimp :: Term -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  600 </span><span class="decl"><span class="nottickedoff">delSimp prop = delRule (ruleOfTerm prop Nothing)</span></span>
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>addConv :: Conversion -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  603 </span><span class="decl"><span class="istickedoff">addConv conv = Net.insert_term (conv, Right conv)</span></span>
<span class="lineno">  604 </span>
<span class="lineno">  605 </span>addConvs :: [Conversion] -&gt; Simpset a -&gt; Simpset a
<span class="lineno">  606 </span><span class="decl"><span class="istickedoff">addConvs convs ss = foldr addConv ss convs</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>scSimpset :: SharedContext -&gt; [Def] -&gt; [Ident] -&gt; [Conversion] -&gt; IO (Simpset a)
<span class="lineno">  609 </span><span class="decl"><span class="istickedoff">scSimpset sc defs eqIdents convs = do</span>
<span class="lineno">  610 </span><span class="spaces">  </span><span class="istickedoff">defRules &lt;- concat &lt;$&gt; traverse (scDefRewriteRules sc) defs</span>
<span class="lineno">  611 </span><span class="spaces">  </span><span class="istickedoff">eqRules &lt;- mapM <span class="nottickedoff">(scEqRewriteRule sc)</span> eqIdents</span>
<span class="lineno">  612 </span><span class="spaces">  </span><span class="istickedoff">return $ addRules defRules $ addRules eqRules $ addConvs convs $ emptySimpset</span></span>
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>listRules :: Simpset a -&gt; [RewriteRule a]
<span class="lineno">  615 </span><span class="decl"><span class="nottickedoff">listRules ss = [ r | Left r &lt;- Net.content ss ]</span></span>
<span class="lineno">  616 </span>
<span class="lineno">  617 </span>----------------------------------------------------------------------
<span class="lineno">  618 </span>-- Destructors for terms
<span class="lineno">  619 </span>
<span class="lineno">  620 </span>asBetaRedex :: R.Recognizer Term (VarName, Term, Term, Term)
<span class="lineno">  621 </span><span class="decl"><span class="istickedoff">asBetaRedex t =</span>
<span class="lineno">  622 </span><span class="spaces">    </span><span class="istickedoff">do (f, arg) &lt;- R.asApp t</span>
<span class="lineno">  623 </span><span class="spaces">       </span><span class="istickedoff">(s, ty, body) &lt;- R.asLambda f</span>
<span class="lineno">  624 </span><span class="spaces">       </span><span class="istickedoff">return (s, <span class="nottickedoff">ty</span>, body, arg)</span></span>
<span class="lineno">  625 </span>
<span class="lineno">  626 </span>asPairRedex :: R.Recognizer Term Term
<span class="lineno">  627 </span><span class="decl"><span class="istickedoff">asPairRedex t =</span>
<span class="lineno">  628 </span><span class="spaces">    </span><span class="istickedoff">do (u, b) &lt;- R.asPairSelector t</span>
<span class="lineno">  629 </span><span class="spaces">       </span><span class="istickedoff">(x, y) &lt;- R.asPairValue u</span>
<span class="lineno">  630 </span><span class="spaces">       </span><span class="istickedoff">return (if b then y else x)</span></span>
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>asRecordRedex :: R.Recognizer Term Term
<span class="lineno">  633 </span><span class="decl"><span class="istickedoff">asRecordRedex t =</span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="istickedoff">do (x, i) &lt;- R.asRecordSelector t</span>
<span class="lineno">  635 </span><span class="spaces">       </span><span class="istickedoff">ts &lt;- R.asRecordValue x</span>
<span class="lineno">  636 </span><span class="spaces">       </span><span class="istickedoff">case Map.lookup i ts of</span>
<span class="lineno">  637 </span><span class="spaces">         </span><span class="istickedoff">Just t' -&gt; return t'</span>
<span class="lineno">  638 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail &quot;Record field not found&quot;</span></span></span>
<span class="lineno">  639 </span>
<span class="lineno">  640 </span>-- | An iota redex whose argument is a concrete nautral number; specifically,
<span class="lineno">  641 </span>--   this function recognizes
<span class="lineno">  642 </span>--
<span class="lineno">  643 </span>--   &gt; RecursorApp rec _ n
<span class="lineno">  644 </span>asNatIotaRedex :: R.Recognizer Term (Term, Term, Natural)
<span class="lineno">  645 </span><span class="decl"><span class="istickedoff">asNatIotaRedex t =</span>
<span class="lineno">  646 </span><span class="spaces">  </span><span class="istickedoff">do (r_m_f1_f2, arg) &lt;- R.asApp t</span>
<span class="lineno">  647 </span><span class="spaces">     </span><span class="istickedoff">(r_m_f1, f2) &lt;- R.asApp r_m_f1_f2</span>
<span class="lineno">  648 </span><span class="spaces">     </span><span class="istickedoff">(r_m, f1) &lt;- R.asApp r_m_f1</span>
<span class="lineno">  649 </span><span class="spaces">     </span><span class="istickedoff">(r, _m) &lt;- R.asApp r_m</span>
<span class="lineno">  650 </span><span class="spaces">     </span><span class="istickedoff">_ &lt;- R.asRecursorApp r</span>
<span class="lineno">  651 </span><span class="spaces">     </span><span class="istickedoff">n &lt;- R.asNat arg</span>
<span class="lineno">  652 </span><span class="spaces">     </span><span class="istickedoff">Just (f1, f2, n)</span></span>
<span class="lineno">  653 </span>
<span class="lineno">  654 </span>----------------------------------------------------------------------
<span class="lineno">  655 </span>-- Bottom-up rewriting
<span class="lineno">  656 </span>
<span class="lineno">  657 </span>-- | Term ordering
<span class="lineno">  658 </span>-- The existing &quot;&lt;&quot; on terms is not adequate for deciding how to handle permutative rules,
<span class="lineno">  659 </span>-- as then associativity and commutativity can loop.
<span class="lineno">  660 </span>-- The following rather unsophisticated functions *might* prevent looping.
<span class="lineno">  661 </span>-- More analysis is needed!
<span class="lineno">  662 </span>--
<span class="lineno">  663 </span>-- here we get the &quot;fringe&quot; of arguments in an application, looking at either curried or
<span class="lineno">  664 </span>-- tupled arguments.  That is
<span class="lineno">  665 </span>--   for `f x y z`, return [x,y,z]
<span class="lineno">  666 </span>--   for `f (x,y)` return [x,y]
<span class="lineno">  667 </span>--   for `f (f x y) z`, return [x,y,z]
<span class="lineno">  668 </span>--   for `f (x, f (y,z))`, return [x,y,z]
<span class="lineno">  669 </span>appCollectedArgs :: Term -&gt; [Term]
<span class="lineno">  670 </span><span class="decl"><span class="nottickedoff">appCollectedArgs t = step0 (unshared t) []</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  672 </span><span class="spaces">    </span><span class="nottickedoff">unshared (STApp{stAppIndex = _, stAppTermF = tf1}) = tf1</span>
<span class="lineno">  673 </span><span class="spaces">    </span><span class="nottickedoff">unshared (Unshared tf1) = tf1</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="nottickedoff">-- step 0: accumulate curried args, find the function</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="nottickedoff">step0 ::  TermF Term -&gt; [Term] -&gt; [Term]</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="nottickedoff">step0 (App f a) args = step0 (unshared f) (a:args)</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="nottickedoff">step0 other args = step1 other args</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="nottickedoff">-- step 1: analyse each arg, knowing the called function, append together</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="nottickedoff">step1 :: TermF Term -&gt; [Term] -&gt; [Term]</span>
<span class="lineno">  680 </span><span class="spaces">    </span><span class="nottickedoff">step1 f args = foldl (++) [] (map (\ x -&gt; step2 f $ unshared x) args)</span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="nottickedoff">-- step2: analyse an arg.  look inside tuples, sequences (TBD), more calls to f</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="nottickedoff">step2 :: TermF Term -&gt; TermF Term -&gt; [Term]</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="nottickedoff">step2 f (FTermF (PairValue x y)) = (step2 f $ unshared x) ++ (step2 f $ unshared y)</span>
<span class="lineno">  684 </span><span class="spaces">    </span><span class="nottickedoff">step2 f (s@(App g a)) = possibly_curried_args s f (unshared g) (step2 f $ unshared a)</span>
<span class="lineno">  685 </span><span class="spaces">    </span><span class="nottickedoff">step2 _ a = [Unshared a]</span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="nottickedoff">possibly_curried_args :: TermF Term -&gt; TermF Term -&gt; TermF Term -&gt; [Term] -&gt; [Term]</span>
<span class="lineno">  688 </span><span class="spaces">    </span><span class="nottickedoff">possibly_curried_args s f (App g a) args = possibly_curried_args s f (unshared g) ((step2 f $ unshared a) ++ args)</span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="nottickedoff">possibly_curried_args s f h args = if f == h then args else [Unshared s]</span></span>
<span class="lineno">  690 </span>
<span class="lineno">  691 </span>
<span class="lineno">  692 </span>termWeightLt :: Term -&gt; Term -&gt; Bool
<span class="lineno">  693 </span><span class="decl"><span class="nottickedoff">termWeightLt t t' =</span>
<span class="lineno">  694 </span><span class="spaces">  </span><span class="nottickedoff">(appCollectedArgs t) &lt; (appCollectedArgs t')</span></span>
<span class="lineno">  695 </span>
<span class="lineno">  696 </span>-- | Do a single reduction step (beta, record or tuple selector) at top
<span class="lineno">  697 </span>-- level, if possible.
<span class="lineno">  698 </span>reduceSharedTerm :: SharedContext -&gt; Term -&gt; IO (Maybe Term)
<span class="lineno">  699 </span><span class="decl"><span class="istickedoff">reduceSharedTerm sc (asBetaRedex -&gt; Just (vn, _, body, arg)) =</span>
<span class="lineno">  700 </span><span class="spaces">  </span><span class="istickedoff">Just &lt;$&gt; scInstantiateExt sc (IntMap.singleton (vnIndex vn) arg) body</span>
<span class="lineno">  701 </span><span class="spaces"></span><span class="istickedoff">reduceSharedTerm _ (asPairRedex -&gt; Just t) = <span class="nottickedoff">pure (Just t)</span></span>
<span class="lineno">  702 </span><span class="spaces"></span><span class="istickedoff">reduceSharedTerm _ (asRecordRedex -&gt; Just t) = <span class="nottickedoff">pure (Just t)</span></span>
<span class="lineno">  703 </span><span class="spaces"></span><span class="istickedoff">reduceSharedTerm sc (asNatIotaRedex -&gt; Just (f1, f2, n)) =</span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="istickedoff">Just &lt;$&gt; scReduceNatRecursor sc f1 f2 n</span>
<span class="lineno">  705 </span><span class="spaces"></span><span class="istickedoff">reduceSharedTerm sc</span>
<span class="lineno">  706 </span><span class="spaces">  </span><span class="istickedoff">(R.asApp -&gt; Just (R.asApplyAll -&gt; (R.asRecursorApp -&gt; Just (r, crec),</span>
<span class="lineno">  707 </span><span class="spaces">                                     </span><span class="istickedoff">splitAt (recursorNumParams crec) -&gt; (params, motive : elims_ixs)), arg))</span>
<span class="lineno">  708 </span><span class="spaces">  </span><span class="istickedoff">| length (recursorCtorOrder crec) + recursorNumIxs crec == length elims_ixs =</span>
<span class="lineno">  709 </span><span class="spaces">  </span><span class="istickedoff">do let (f, args) = R.asApplyAll arg</span>
<span class="lineno">  710 </span><span class="spaces">     </span><span class="istickedoff">let elims = take (length (recursorCtorOrder crec)) elims_ixs</span>
<span class="lineno">  711 </span><span class="spaces">     </span><span class="istickedoff">mm &lt;- scGetModuleMap sc</span>
<span class="lineno">  712 </span><span class="spaces">     </span><span class="istickedoff">case R.asConstant f of</span>
<span class="lineno">  713 </span><span class="spaces">       </span><span class="istickedoff">Nothing -&gt; pure Nothing</span>
<span class="lineno">  714 </span><span class="spaces">       </span><span class="istickedoff">Just c -&gt;</span>
<span class="lineno">  715 </span><span class="spaces">         </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex c) mm of</span>
<span class="lineno">  716 </span><span class="spaces">           </span><span class="istickedoff">Just (ResolvedCtor ctor) -&gt;</span>
<span class="lineno">  717 </span><span class="spaces">             </span><span class="istickedoff">Just &lt;$&gt; scReduceRecursor sc r crec params motive elims c (drop (ctorNumParams ctor) args)</span>
<span class="lineno">  718 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; pure Nothing</span>
<span class="lineno">  719 </span><span class="spaces"></span><span class="istickedoff">reduceSharedTerm _ _ = pure Nothing</span></span>
<span class="lineno">  720 </span>
<span class="lineno">  721 </span>-- | Rewriter for shared terms.  The annotations of any used rules are collected
<span class="lineno">  722 </span>--   and returned in the result set.
<span class="lineno">  723 </span>rewriteSharedTerm :: forall a. Ord a =&gt; SharedContext -&gt; Simpset a -&gt; Term -&gt; IO (Set a, Term)
<span class="lineno">  724 </span><span class="decl"><span class="istickedoff">rewriteSharedTerm sc ss t0 =</span>
<span class="lineno">  725 </span><span class="spaces">    </span><span class="istickedoff">do cache &lt;- newCache</span>
<span class="lineno">  726 </span><span class="spaces">       </span><span class="istickedoff">let ?cache = cache</span>
<span class="lineno">  727 </span><span class="spaces">       </span><span class="istickedoff">setRef &lt;- newIORef mempty</span>
<span class="lineno">  728 </span><span class="spaces">       </span><span class="istickedoff">let ?annSet = setRef</span>
<span class="lineno">  729 </span><span class="spaces">       </span><span class="istickedoff">t &lt;- rewriteAll t0</span>
<span class="lineno">  730 </span><span class="spaces">       </span><span class="istickedoff">anns &lt;- readIORef setRef</span>
<span class="lineno">  731 </span><span class="spaces">       </span><span class="istickedoff">pure (<span class="nottickedoff">anns</span>, t)</span>
<span class="lineno">  732 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  733 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  734 </span><span class="spaces">    </span><span class="istickedoff">rewriteAll :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt; Term -&gt; IO Term</span>
<span class="lineno">  735 </span><span class="spaces">    </span><span class="istickedoff">rewriteAll (Unshared tf) =</span>
<span class="lineno">  736 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">traverseTF rewriteAll tf &gt;&gt;= scTermF sc &gt;&gt;= rewriteTop</span></span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="istickedoff">rewriteAll STApp{ stAppIndex = tidx, stAppTermF = tf } =</span>
<span class="lineno">  738 </span><span class="spaces">        </span><span class="istickedoff">useCache ?cache tidx (traverseTF rewriteAll tf &gt;&gt;= scTermF sc &gt;&gt;= rewriteTop)</span>
<span class="lineno">  739 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  740 </span><span class="spaces">    </span><span class="istickedoff">traverseTF :: forall b. (b -&gt; IO b) -&gt; TermF b -&gt; IO (TermF b)</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">traverseTF _ tf@(Constant {}) = pure tf</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">traverseTF f tf = traverse f tf</span>
<span class="lineno">  743 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="istickedoff">rewriteTop :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt; Term -&gt; IO Term</span>
<span class="lineno">  745 </span><span class="spaces">    </span><span class="istickedoff">rewriteTop t =</span>
<span class="lineno">  746 </span><span class="spaces">      </span><span class="istickedoff">do mt &lt;- reduceSharedTerm sc t</span>
<span class="lineno">  747 </span><span class="spaces">         </span><span class="istickedoff">case mt of</span>
<span class="lineno">  748 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; apply (Net.unify_term ss t) t</span>
<span class="lineno">  749 </span><span class="spaces">           </span><span class="istickedoff">Just t' -&gt; rewriteAll t'</span>
<span class="lineno">  750 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  751 </span><span class="spaces">    </span><span class="istickedoff">recordAnn :: (?annSet :: IORef (Set a)) =&gt; Maybe a -&gt; IO ()</span>
<span class="lineno">  752 </span><span class="spaces">    </span><span class="istickedoff">recordAnn Nothing  = return <span class="nottickedoff">()</span></span>
<span class="lineno">  753 </span><span class="spaces">    </span><span class="istickedoff">recordAnn (Just a) = modifyIORef' ?annSet (Set.insert a)</span>
<span class="lineno">  754 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  755 </span><span class="spaces">    </span><span class="istickedoff">apply :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt;</span>
<span class="lineno">  756 </span><span class="spaces">             </span><span class="istickedoff">[Either (RewriteRule a) Conversion] -&gt; Term -&gt; IO Term</span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff">apply [] t = return t</span>
<span class="lineno">  758 </span><span class="spaces">    </span><span class="istickedoff">apply (Left (RewriteRule {ctxt, lhs, rhs, permutative, shallow, annotation}) : rules) t = do</span>
<span class="lineno">  759 </span><span class="spaces">      </span><span class="istickedoff">result &lt;- scMatch sc ctxt lhs t</span>
<span class="lineno">  760 </span><span class="spaces">      </span><span class="istickedoff">case result of</span>
<span class="lineno">  761 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; apply rules t</span>
<span class="lineno">  762 </span><span class="spaces">        </span><span class="istickedoff">Just inst</span>
<span class="lineno">  763 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">lhs == rhs</span> -&gt;</span>
<span class="lineno">  764 </span><span class="spaces">            </span><span class="istickedoff">-- This should never happen because we avoid inserting</span>
<span class="lineno">  765 </span><span class="spaces">            </span><span class="istickedoff">-- reflexive rules into simp sets in the first place.</span>
<span class="lineno">  766 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do putStrLn $ &quot;rewriteSharedTerm: skipping reflexive rule &quot; ++</span></span>
<span class="lineno">  767 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">&quot;(THE IMPOSSIBLE HAPPENED!): &quot; ++ scPrettyTerm PPS.defaultOpts lhs</span></span>
<span class="lineno">  768 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">apply rules t</span></span>
<span class="lineno">  769 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">IntMap.keysSet inst /= IntSet.fromList (map (vnIndex . fst) ctxt)</span> -&gt;</span>
<span class="lineno">  770 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do putStrLn $ &quot;rewriteSharedTerm: invalid lhs does not contain all variables: &quot;</span></span>
<span class="lineno">  771 </span><span class="spaces">                 </span><span class="istickedoff"><span class="nottickedoff">++ scPrettyTerm PPS.defaultOpts lhs</span></span>
<span class="lineno">  772 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">apply rules t</span></span>
<span class="lineno">  773 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">permutative</span> -&gt;</span>
<span class="lineno">  774 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do</span></span>
<span class="lineno">  775 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">t' &lt;- scInstantiateExt sc inst rhs</span></span>
<span class="lineno">  776 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">case termWeightLt t' t of</span></span>
<span class="lineno">  777 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">True -&gt; recordAnn annotation &gt;&gt; rewriteAll t' -- keep the result only if it is &quot;smaller&quot;</span></span>
<span class="lineno">  778 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">False -&gt; apply rules t</span></span>
<span class="lineno">  779 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">shallow</span> -&gt;</span>
<span class="lineno">  780 </span><span class="spaces">            </span><span class="istickedoff">-- do not to further rewriting to the result of a &quot;shallow&quot; rule</span>
<span class="lineno">  781 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do recordAnn annotation</span></span>
<span class="lineno">  782 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">scInstantiateExt sc inst rhs</span></span>
<span class="lineno">  783 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt;</span>
<span class="lineno">  784 </span><span class="spaces">            </span><span class="istickedoff">do -- putStrLn &quot;REWRITING:&quot;</span>
<span class="lineno">  785 </span><span class="spaces">               </span><span class="istickedoff">-- print lhs</span>
<span class="lineno">  786 </span><span class="spaces">               </span><span class="istickedoff">recordAnn annotation</span>
<span class="lineno">  787 </span><span class="spaces">               </span><span class="istickedoff">rewriteAll =&lt;&lt; scInstantiateExt sc inst rhs</span>
<span class="lineno">  788 </span><span class="spaces">    </span><span class="istickedoff">apply (Right conv : rules) t =</span>
<span class="lineno">  789 </span><span class="spaces">        </span><span class="istickedoff">do -- putStrLn &quot;REWRITING:&quot;</span>
<span class="lineno">  790 </span><span class="spaces">           </span><span class="istickedoff">-- print (Net.toPat conv)</span>
<span class="lineno">  791 </span><span class="spaces">           </span><span class="istickedoff">case runConversion conv t of</span>
<span class="lineno">  792 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt; apply rules t</span>
<span class="lineno">  793 </span><span class="spaces">             </span><span class="istickedoff">Just tb -&gt; rewriteAll =&lt;&lt; runTermBuilder tb <span class="nottickedoff">(scGlobalDef sc)</span> (scTermF sc)</span></span>
<span class="lineno">  794 </span>
<span class="lineno">  795 </span>-- | Type-safe rewriter for shared terms
<span class="lineno">  796 </span>rewriteSharedTermTypeSafe :: forall a. Ord a =&gt;
<span class="lineno">  797 </span>  SharedContext -&gt; Simpset a -&gt; Term -&gt; IO (Set a, Term)
<span class="lineno">  798 </span><span class="decl"><span class="nottickedoff">rewriteSharedTermTypeSafe sc ss t0 =</span>
<span class="lineno">  799 </span><span class="spaces">    </span><span class="nottickedoff">do cache &lt;- newCache</span>
<span class="lineno">  800 </span><span class="spaces">       </span><span class="nottickedoff">let ?cache = cache</span>
<span class="lineno">  801 </span><span class="spaces">       </span><span class="nottickedoff">annRef &lt;- newIORef mempty</span>
<span class="lineno">  802 </span><span class="spaces">       </span><span class="nottickedoff">let ?annSet = annRef</span>
<span class="lineno">  803 </span><span class="spaces">       </span><span class="nottickedoff">t &lt;- rewriteAll t0</span>
<span class="lineno">  804 </span><span class="spaces">       </span><span class="nottickedoff">anns &lt;- readIORef annRef</span>
<span class="lineno">  805 </span><span class="spaces">       </span><span class="nottickedoff">return (anns, t)</span>
<span class="lineno">  806 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  807 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="nottickedoff">rewriteAll :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt;</span>
<span class="lineno">  809 </span><span class="spaces">                  </span><span class="nottickedoff">Term -&gt; IO Term</span>
<span class="lineno">  810 </span><span class="spaces">    </span><span class="nottickedoff">rewriteAll (Unshared tf) =</span>
<span class="lineno">  811 </span><span class="spaces">        </span><span class="nottickedoff">rewriteTermF tf &gt;&gt;= scTermF sc &gt;&gt;= rewriteTop</span>
<span class="lineno">  812 </span><span class="spaces">    </span><span class="nottickedoff">rewriteAll STApp{ stAppIndex = tidx, stAppTermF = tf } =</span>
<span class="lineno">  813 </span><span class="spaces">        </span><span class="nottickedoff">-- putStrLn &quot;Rewriting term:&quot; &gt;&gt; print t &gt;&gt;</span>
<span class="lineno">  814 </span><span class="spaces">        </span><span class="nottickedoff">useCache ?cache tidx (rewriteTermF tf &gt;&gt;= scTermF sc &gt;&gt;= rewriteTop)</span>
<span class="lineno">  815 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  816 </span><span class="spaces">    </span><span class="nottickedoff">rewriteTermF :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt;</span>
<span class="lineno">  817 </span><span class="spaces">                    </span><span class="nottickedoff">TermF Term -&gt; IO (TermF Term)</span>
<span class="lineno">  818 </span><span class="spaces">    </span><span class="nottickedoff">rewriteTermF tf =</span>
<span class="lineno">  819 </span><span class="spaces">        </span><span class="nottickedoff">case tf of</span>
<span class="lineno">  820 </span><span class="spaces">          </span><span class="nottickedoff">FTermF ftf -&gt; FTermF &lt;$&gt; rewriteFTermF ftf</span>
<span class="lineno">  821 </span><span class="spaces">          </span><span class="nottickedoff">App e1 e2 -&gt;</span>
<span class="lineno">  822 </span><span class="spaces">              </span><span class="nottickedoff">do t1 &lt;- scTypeOf sc e1</span>
<span class="lineno">  823 </span><span class="spaces">                 </span><span class="nottickedoff">case unwrapTermF t1 of</span>
<span class="lineno">  824 </span><span class="spaces">                   </span><span class="nottickedoff">-- We only rewrite e2 if type of e1 is not a dependent type.</span>
<span class="lineno">  825 </span><span class="spaces">                   </span><span class="nottickedoff">-- This prevents rewriting e2 from changing type of @App e1 e2@.</span>
<span class="lineno">  826 </span><span class="spaces">                   </span><span class="nottickedoff">Pi x _ t</span>
<span class="lineno">  827 </span><span class="spaces">                     </span><span class="nottickedoff">| IntSet.notMember (vnIndex x) (freeVars t) -&gt;</span>
<span class="lineno">  828 </span><span class="spaces">                         </span><span class="nottickedoff">App &lt;$&gt; rewriteAll e1 &lt;*&gt; rewriteAll e2</span>
<span class="lineno">  829 </span><span class="spaces">                   </span><span class="nottickedoff">_ -&gt; App &lt;$&gt; rewriteAll e1 &lt;*&gt; pure e2</span>
<span class="lineno">  830 </span><span class="spaces">          </span><span class="nottickedoff">Lambda pat t e -&gt; Lambda pat t &lt;$&gt; rewriteAll e</span>
<span class="lineno">  831 </span><span class="spaces">          </span><span class="nottickedoff">Constant{}     -&gt; return tf</span>
<span class="lineno">  832 </span><span class="spaces">          </span><span class="nottickedoff">Variable{}     -&gt; return tf</span>
<span class="lineno">  833 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; return tf -- traverse rewriteAll tf</span>
<span class="lineno">  834 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  835 </span><span class="spaces">    </span><span class="nottickedoff">rewriteFTermF :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt;</span>
<span class="lineno">  836 </span><span class="spaces">                     </span><span class="nottickedoff">FlatTermF Term -&gt; IO (FlatTermF Term)</span>
<span class="lineno">  837 </span><span class="spaces">    </span><span class="nottickedoff">rewriteFTermF ftf =</span>
<span class="lineno">  838 </span><span class="spaces">        </span><span class="nottickedoff">case ftf of</span>
<span class="lineno">  839 </span><span class="spaces">          </span><span class="nottickedoff">UnitValue        -&gt; return ftf</span>
<span class="lineno">  840 </span><span class="spaces">          </span><span class="nottickedoff">UnitType         -&gt; return ftf</span>
<span class="lineno">  841 </span><span class="spaces">          </span><span class="nottickedoff">PairValue{}      -&gt; traverse rewriteAll ftf</span>
<span class="lineno">  842 </span><span class="spaces">          </span><span class="nottickedoff">PairType{}       -&gt; return ftf -- doesn't matter</span>
<span class="lineno">  843 </span><span class="spaces">          </span><span class="nottickedoff">PairLeft{}       -&gt; traverse rewriteAll ftf</span>
<span class="lineno">  844 </span><span class="spaces">          </span><span class="nottickedoff">PairRight{}      -&gt; traverse rewriteAll ftf</span>
<span class="lineno">  845 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  846 </span><span class="spaces">          </span><span class="nottickedoff">-- NOTE: we don't rewrite arguments of constructors, datatypes, or</span>
<span class="lineno">  847 </span><span class="spaces">          </span><span class="nottickedoff">-- recursors because of dependent types, as we could potentially cause</span>
<span class="lineno">  848 </span><span class="spaces">          </span><span class="nottickedoff">-- a term to become ill-typed</span>
<span class="lineno">  849 </span><span class="spaces">          </span><span class="nottickedoff">Recursor{}       -&gt; return ftf</span>
<span class="lineno">  850 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  851 </span><span class="spaces">          </span><span class="nottickedoff">RecordType{}     -&gt; traverse rewriteAll ftf</span>
<span class="lineno">  852 </span><span class="spaces">          </span><span class="nottickedoff">RecordValue{}    -&gt; traverse rewriteAll ftf</span>
<span class="lineno">  853 </span><span class="spaces">          </span><span class="nottickedoff">RecordProj{}     -&gt; traverse rewriteAll ftf</span>
<span class="lineno">  854 </span><span class="spaces">          </span><span class="nottickedoff">Sort{}           -&gt; return ftf -- doesn't matter</span>
<span class="lineno">  855 </span><span class="spaces">          </span><span class="nottickedoff">NatLit{}         -&gt; return ftf -- doesn't matter</span>
<span class="lineno">  856 </span><span class="spaces">          </span><span class="nottickedoff">ArrayValue t es  -&gt; ArrayValue t &lt;$&gt; traverse rewriteAll es</span>
<span class="lineno">  857 </span><span class="spaces">          </span><span class="nottickedoff">StringLit{}      -&gt; return ftf</span>
<span class="lineno">  858 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  859 </span><span class="spaces">    </span><span class="nottickedoff">rewriteTop :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt;</span>
<span class="lineno">  860 </span><span class="spaces">                  </span><span class="nottickedoff">Term -&gt; IO Term</span>
<span class="lineno">  861 </span><span class="spaces">    </span><span class="nottickedoff">rewriteTop t = apply (Net.match_term ss t) t</span>
<span class="lineno">  862 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  863 </span><span class="spaces">    </span><span class="nottickedoff">recordAnn :: (?annSet :: IORef (Set a)) =&gt; Maybe a -&gt; IO ()</span>
<span class="lineno">  864 </span><span class="spaces">    </span><span class="nottickedoff">recordAnn Nothing  = return ()</span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="nottickedoff">recordAnn (Just a) = modifyIORef' ?annSet (Set.insert a)</span>
<span class="lineno">  866 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  867 </span><span class="spaces">    </span><span class="nottickedoff">apply :: (?cache :: Cache IO TermIndex Term, ?annSet :: IORef (Set a)) =&gt;</span>
<span class="lineno">  868 </span><span class="spaces">             </span><span class="nottickedoff">[Either (RewriteRule a) Conversion] -&gt;</span>
<span class="lineno">  869 </span><span class="spaces">             </span><span class="nottickedoff">Term -&gt; IO Term</span>
<span class="lineno">  870 </span><span class="spaces">    </span><span class="nottickedoff">apply [] t = return t</span>
<span class="lineno">  871 </span><span class="spaces">    </span><span class="nottickedoff">apply (Left rule : rules) t =</span>
<span class="lineno">  872 </span><span class="spaces">      </span><span class="nottickedoff">case firstOrderMatch (ctxt rule) (lhs rule) t of</span>
<span class="lineno">  873 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; apply rules t</span>
<span class="lineno">  874 </span><span class="spaces">        </span><span class="nottickedoff">Just inst -&gt;</span>
<span class="lineno">  875 </span><span class="spaces">          </span><span class="nottickedoff">do recordAnn (annotation rule)</span>
<span class="lineno">  876 </span><span class="spaces">             </span><span class="nottickedoff">rewriteAll =&lt;&lt; scInstantiateExt sc inst (rhs rule)</span>
<span class="lineno">  877 </span><span class="spaces">    </span><span class="nottickedoff">apply (Right conv : rules) t =</span>
<span class="lineno">  878 </span><span class="spaces">      </span><span class="nottickedoff">case runConversion conv t of</span>
<span class="lineno">  879 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; apply rules t</span>
<span class="lineno">  880 </span><span class="spaces">        </span><span class="nottickedoff">Just tb -&gt; rewriteAll =&lt;&lt; runTermBuilder tb (scGlobalDef sc) (scTermF sc)</span></span>
<span class="lineno">  881 </span>
<span class="lineno">  882 </span>-- | Generate a new SharedContext that normalizes terms as it builds them.
<span class="lineno">  883 </span>--   Rule annotations are ignored.
<span class="lineno">  884 </span>rewritingSharedContext :: SharedContext -&gt; Simpset a -&gt; SharedContext
<span class="lineno">  885 </span><span class="decl"><span class="istickedoff">rewritingSharedContext sc ss = sc'</span>
<span class="lineno">  886 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="istickedoff">sc' = sc { scTermF = rewriteTop }</span>
<span class="lineno">  888 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  889 </span><span class="spaces">    </span><span class="istickedoff">rewriteTop :: TermF Term -&gt; IO Term</span>
<span class="lineno">  890 </span><span class="spaces">    </span><span class="istickedoff">rewriteTop tf =</span>
<span class="lineno">  891 </span><span class="spaces">      </span><span class="istickedoff">case asPairRedex t of</span>
<span class="lineno">  892 </span><span class="spaces">        </span><span class="istickedoff">Just t' -&gt; return t'</span>
<span class="lineno">  893 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  894 </span><span class="spaces">          </span><span class="istickedoff">case asRecordRedex t of</span>
<span class="lineno">  895 </span><span class="spaces">            </span><span class="istickedoff">Just t' -&gt; return t'</span>
<span class="lineno">  896 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; apply (Net.match_term ss t) t</span>
<span class="lineno">  897 </span><span class="spaces">      </span><span class="istickedoff">where t = Unshared tf</span>
<span class="lineno">  898 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  899 </span><span class="spaces">    </span><span class="istickedoff">apply :: [Either (RewriteRule a) Conversion] -&gt;</span>
<span class="lineno">  900 </span><span class="spaces">             </span><span class="istickedoff">Term -&gt; IO Term</span>
<span class="lineno">  901 </span><span class="spaces">    </span><span class="istickedoff">apply [] (Unshared tf) = scTermF sc tf</span>
<span class="lineno">  902 </span><span class="spaces">    </span><span class="istickedoff">apply [] STApp{ stAppTermF = tf } = <span class="nottickedoff">scTermF sc tf</span></span>
<span class="lineno">  903 </span><span class="spaces">    </span><span class="istickedoff">apply (Left (RewriteRule c l r _ _shallow _ann) : rules) t =</span>
<span class="lineno">  904 </span><span class="spaces">      </span><span class="istickedoff">case firstOrderMatch c l t of</span>
<span class="lineno">  905 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">apply rules t</span></span>
<span class="lineno">  906 </span><span class="spaces">        </span><span class="istickedoff">Just inst</span>
<span class="lineno">  907 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlyfalse">l == r</span> -&gt;</span>
<span class="lineno">  908 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">do putStrLn $ &quot;rewritingSharedContext: skipping reflexive rule: &quot; ++ scPrettyTerm PPS.defaultOpts l</span></span>
<span class="lineno">  909 </span><span class="spaces">               </span><span class="istickedoff"><span class="nottickedoff">apply rules t</span></span>
<span class="lineno">  910 </span><span class="spaces">          </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> -&gt; scInstantiateExt sc' inst r</span>
<span class="lineno">  911 </span><span class="spaces">    </span><span class="istickedoff">apply (Right conv : rules) t =</span>
<span class="lineno">  912 </span><span class="spaces">      </span><span class="istickedoff">case runConversion conv t of</span>
<span class="lineno">  913 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; apply rules t</span>
<span class="lineno">  914 </span><span class="spaces">        </span><span class="istickedoff">Just tb -&gt; runTermBuilder tb (scGlobalDef sc) (scTermF sc')</span></span>
<span class="lineno">  915 </span>
<span class="lineno">  916 </span>
<span class="lineno">  917 </span>-- FIXME: is there some way to have sensable term replacement in the presence of loose variables
<span class="lineno">  918 </span>--  and/or under binders?
<span class="lineno">  919 </span>replaceTerm :: Ord a =&gt;
<span class="lineno">  920 </span>  SharedContext -&gt;
<span class="lineno">  921 </span>  Simpset a    {- ^ A simpset of rewrite rules to apply along with the replacement -} -&gt;
<span class="lineno">  922 </span>  (Term, Term) {- ^ (pat,repl) is a tuple of a pattern term to replace and a replacement term -} -&gt;
<span class="lineno">  923 </span>  Term         {- ^ the term in which to perform the replacement -} -&gt;
<span class="lineno">  924 </span>  IO (Set a, Term)
<span class="lineno">  925 </span><span class="decl"><span class="istickedoff">replaceTerm sc ss (pat, repl) t = do</span>
<span class="lineno">  926 </span><span class="spaces">    </span><span class="istickedoff">let rule = ruleOfTerms pat repl</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="istickedoff">let ss' = addRule rule ss</span>
<span class="lineno">  928 </span><span class="spaces">    </span><span class="istickedoff">rewriteSharedTerm sc ss' t</span></span>
<span class="lineno">  929 </span>
<span class="lineno">  930 </span>
<span class="lineno">  931 </span>-------------------------------------------------------------------------------
<span class="lineno">  932 </span>-- If/then/else hoisting
<span class="lineno">  933 </span>
<span class="lineno">  934 </span>-- | Find all instances of Prelude.ite in the given term and hoist them
<span class="lineno">  935 </span>--   higher.  An if-then-else floats upward until it hits a binder that
<span class="lineno">  936 </span>--   binds one of its free variables, or until it bubbles to the top of
<span class="lineno">  937 </span>--   the term.  When multiple if-then-else branches bubble to the same
<span class="lineno">  938 </span>--   place, they will be nested via a canonical term ordering.  This transformation
<span class="lineno">  939 </span>--   also does rewrites by basic boolean identities.
<span class="lineno">  940 </span>hoistIfs :: SharedContext
<span class="lineno">  941 </span>         -&gt; Term
<span class="lineno">  942 </span>         -&gt; IO Term
<span class="lineno">  943 </span><span class="decl"><span class="istickedoff">hoistIfs sc t = do</span>
<span class="lineno">  944 </span><span class="spaces">   </span><span class="istickedoff">cache &lt;- newCache</span>
<span class="lineno">  945 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  946 </span><span class="spaces">   </span><span class="istickedoff">rules &lt;- map (\rt -&gt; ruleOfTerm rt Nothing) &lt;$&gt; mapM (scTypeOfIdent sc)</span>
<span class="lineno">  947 </span><span class="spaces">              </span><span class="istickedoff">[ &quot;Prelude.ite_true&quot;</span>
<span class="lineno">  948 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_false&quot;</span>
<span class="lineno">  949 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_not&quot;</span>
<span class="lineno">  950 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_nest1&quot;</span>
<span class="lineno">  951 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_nest2&quot;</span>
<span class="lineno">  952 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_eq&quot;</span>
<span class="lineno">  953 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_bit_false_1&quot;</span>
<span class="lineno">  954 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_bit_true_1&quot;</span>
<span class="lineno">  955 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.ite_bit&quot;</span>
<span class="lineno">  956 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.not_not&quot;</span>
<span class="lineno">  957 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.and_True1&quot;</span>
<span class="lineno">  958 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.and_False1&quot;</span>
<span class="lineno">  959 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.and_True2&quot;</span>
<span class="lineno">  960 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.and_False2&quot;</span>
<span class="lineno">  961 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.and_idem&quot;</span>
<span class="lineno">  962 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.or_True1&quot;</span>
<span class="lineno">  963 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.or_False1&quot;</span>
<span class="lineno">  964 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.or_True2&quot;</span>
<span class="lineno">  965 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.or_False2&quot;</span>
<span class="lineno">  966 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.or_idem&quot;</span>
<span class="lineno">  967 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.not_or&quot;</span>
<span class="lineno">  968 </span><span class="spaces">              </span><span class="istickedoff">, &quot;Prelude.not_and&quot;</span>
<span class="lineno">  969 </span><span class="spaces">              </span><span class="istickedoff">]</span>
<span class="lineno">  970 </span><span class="spaces">   </span><span class="istickedoff">let ss :: Simpset () = addRules rules emptySimpset</span>
<span class="lineno">  971 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  972 </span><span class="spaces">   </span><span class="istickedoff">(t', conds) &lt;- doHoistIfs sc <span class="nottickedoff">ss</span> cache . snd =&lt;&lt; rewriteSharedTerm sc ss t</span>
<span class="lineno">  973 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  974 </span><span class="spaces">   </span><span class="istickedoff">-- remove duplicate conditions from the list, as muxing in SAW can result in</span>
<span class="lineno">  975 </span><span class="spaces">   </span><span class="istickedoff">-- many copies of the same condition, which cause a performance issue</span>
<span class="lineno">  976 </span><span class="spaces">   </span><span class="istickedoff">splitConds sc ss (nubOrd $ map fst conds) t'</span></span>
<span class="lineno">  977 </span>
<span class="lineno">  978 </span>
<span class="lineno">  979 </span>splitConds :: Ord a =&gt; SharedContext -&gt; Simpset a -&gt; [Term] -&gt; Term -&gt; IO Term
<span class="lineno">  980 </span><span class="decl"><span class="istickedoff">splitConds sc ss = go</span>
<span class="lineno">  981 </span><span class="spaces"> </span><span class="istickedoff">where</span>
<span class="lineno">  982 </span><span class="spaces">   </span><span class="istickedoff">go [] t = return t</span>
<span class="lineno">  983 </span><span class="spaces">   </span><span class="istickedoff">go (c:cs) t = go cs =&lt;&lt; splitCond sc ss c t</span></span>
<span class="lineno">  984 </span>
<span class="lineno">  985 </span>splitCond :: Ord a =&gt; SharedContext -&gt; Simpset a -&gt; Term -&gt; Term -&gt; IO Term
<span class="lineno">  986 </span><span class="decl"><span class="istickedoff">splitCond sc ss c t = do</span>
<span class="lineno">  987 </span><span class="spaces">   </span><span class="istickedoff">ty &lt;- scTypeOf sc t</span>
<span class="lineno">  988 </span><span class="spaces">   </span><span class="istickedoff">trueTerm  &lt;- scBool sc True</span>
<span class="lineno">  989 </span><span class="spaces">   </span><span class="istickedoff">falseTerm &lt;- scBool sc False</span>
<span class="lineno">  990 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  991 </span><span class="spaces">   </span><span class="istickedoff">(_,then_branch) &lt;- replaceTerm sc ss (c, trueTerm) t</span>
<span class="lineno">  992 </span><span class="spaces">   </span><span class="istickedoff">(_,else_branch) &lt;- replaceTerm sc ss (c, falseTerm) t</span>
<span class="lineno">  993 </span><span class="spaces">   </span><span class="istickedoff">scGlobalApply sc &quot;Prelude.ite&quot; [ty, c, then_branch, else_branch]</span></span>
<span class="lineno">  994 </span>
<span class="lineno">  995 </span>
<span class="lineno">  996 </span>type HoistIfs s = (Term, [(Term, Map VarName Term)])
<span class="lineno">  997 </span>
<span class="lineno">  998 </span>
<span class="lineno">  999 </span>orderTerms :: SharedContext -&gt; [Term] -&gt; IO [Term]
<span class="lineno"> 1000 </span><span class="decl"><span class="nottickedoff">orderTerms _sc xs = return $ List.sort xs</span></span>
<span class="lineno"> 1001 </span>
<span class="lineno"> 1002 </span>doHoistIfs :: Ord a =&gt;
<span class="lineno"> 1003 </span>  SharedContext -&gt;
<span class="lineno"> 1004 </span>  Simpset a -&gt;
<span class="lineno"> 1005 </span>  Cache IO TermIndex (HoistIfs s) -&gt;
<span class="lineno"> 1006 </span>  Term -&gt;
<span class="lineno"> 1007 </span>  IO (HoistIfs s)
<span class="lineno"> 1008 </span><span class="decl"><span class="istickedoff">doHoistIfs sc ss hoistCache = go</span>
<span class="lineno"> 1009 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1010 </span><span class="spaces"> </span><span class="istickedoff">where go :: Term -&gt; IO (HoistIfs s)</span>
<span class="lineno"> 1011 </span><span class="spaces">       </span><span class="istickedoff">go t@(STApp{ stAppIndex = idx, stAppTermF = tf}) = useCache hoistCache idx $ top t tf</span>
<span class="lineno"> 1012 </span><span class="spaces">       </span><span class="istickedoff">go t@(Unshared tf)  = <span class="nottickedoff">top t tf</span></span>
<span class="lineno"> 1013 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1014 </span><span class="spaces">       </span><span class="istickedoff">top :: Term -&gt; TermF Term -&gt; IO (HoistIfs s)</span>
<span class="lineno"> 1015 </span><span class="spaces">       </span><span class="istickedoff">top t tf =</span>
<span class="lineno"> 1016 </span><span class="spaces">         </span><span class="istickedoff">case R.asGlobalApply &quot;Prelude.ite&quot; t of</span>
<span class="lineno"> 1017 </span><span class="spaces">           </span><span class="istickedoff">Just [branch_tp, cond, then_branch, else_branch] -&gt;</span>
<span class="lineno"> 1018 </span><span class="spaces">             </span><span class="istickedoff">do (then_branch',conds1) &lt;- go then_branch</span>
<span class="lineno"> 1019 </span><span class="spaces">                </span><span class="istickedoff">(else_branch',conds2) &lt;- go else_branch</span>
<span class="lineno"> 1020 </span><span class="spaces">                </span><span class="istickedoff">t' &lt;- scGlobalApply sc &quot;Prelude.ite&quot; [branch_tp, cond, then_branch', else_branch']</span>
<span class="lineno"> 1021 </span><span class="spaces">                </span><span class="istickedoff">let <span class="nottickedoff">vars = getAllVarsMap cond</span></span>
<span class="lineno"> 1022 </span><span class="spaces">                </span><span class="istickedoff">return (t', (cond, <span class="nottickedoff">vars</span>) : conds1 ++ conds2)</span>
<span class="lineno"> 1023 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno"> 1024 </span><span class="spaces">             </span><span class="istickedoff">goF t tf</span>
<span class="lineno"> 1025 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1026 </span><span class="spaces">       </span><span class="istickedoff">goF :: Term -&gt; TermF Term -&gt; IO (HoistIfs s)</span>
<span class="lineno"> 1027 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1028 </span><span class="spaces">       </span><span class="istickedoff">goF t (Constant {}) = return (t, [])</span>
<span class="lineno"> 1029 </span><span class="spaces">       </span><span class="istickedoff">goF t (Variable {}) = return (t, [])</span>
<span class="lineno"> 1030 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1031 </span><span class="spaces">       </span><span class="istickedoff">goF _ (FTermF ftf) = <span class="nottickedoff">do</span></span>
<span class="lineno"> 1032 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">(ftf', conds) &lt;- runWriterT $ traverse WriterT $ (fmap go ftf)</span></span>
<span class="lineno"> 1033 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">t' &lt;- scFlatTermF sc ftf'</span></span>
<span class="lineno"> 1034 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">return (t', conds)</span></span>
<span class="lineno"> 1035 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1036 </span><span class="spaces">       </span><span class="istickedoff">goF _ (App f x) = do</span>
<span class="lineno"> 1037 </span><span class="spaces">           </span><span class="istickedoff">(f', conds1) &lt;- go f</span>
<span class="lineno"> 1038 </span><span class="spaces">           </span><span class="istickedoff">(x', conds2) &lt;- go x</span>
<span class="lineno"> 1039 </span><span class="spaces">           </span><span class="istickedoff">t' &lt;- scApply sc f' x'</span>
<span class="lineno"> 1040 </span><span class="spaces">           </span><span class="istickedoff">return (t', conds1 ++ conds2)</span>
<span class="lineno"> 1041 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1042 </span><span class="spaces">       </span><span class="istickedoff">goF _ (Lambda nm tp body) = <span class="nottickedoff">goBinder scLambda nm tp body</span></span>
<span class="lineno"> 1043 </span><span class="spaces">       </span><span class="istickedoff">goF _ (Pi nm tp body) = <span class="nottickedoff">goBinder scPi nm tp body</span></span>
<span class="lineno"> 1044 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1045 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">goBinder close nm tp body =</span></span>
<span class="lineno"> 1046 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">do (body'', conds) &lt;- go body</span></span>
<span class="lineno"> 1047 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">let (stuck, float) = List.partition (Map.member nm . snd) conds</span></span>
<span class="lineno"> 1048 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 1049 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">stuck' &lt;- orderTerms sc (map fst stuck)</span></span>
<span class="lineno"> 1050 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">body''' &lt;- splitConds sc ss stuck' body''</span></span>
<span class="lineno"> 1051 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno"> 1052 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">t' &lt;- close sc nm tp body'''</span></span>
<span class="lineno"> 1053 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">return (t', float)</span></span></span>

</pre>
</body>
</html>
