<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>module SAWScript.AutoMatch.Util where
<span class="lineno">    4 </span>
<span class="lineno">    5 </span>import qualified Data.Set as Set
<span class="lineno">    6 </span>import           Data.Set   (Set)
<span class="lineno">    7 </span>import qualified Data.Map as Map
<span class="lineno">    8 </span>import           Data.Map   (Map)
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>import Data.Maybe
<span class="lineno">   11 </span>import Data.List
<span class="lineno">   12 </span>import Control.Monad (mfilter)
<span class="lineno">   13 </span>import Control.Arrow ( (&amp;&amp;&amp;) )
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   16 </span>import Control.Applicative
<span class="lineno">   17 </span>#endif
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>import SAWScript.AutoMatch.Declaration
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>-- Some project-specific utilities...
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>-- | Cryptol type for a bit sequence of a given length
<span class="lineno">   24 </span>bitSeqType :: Integer -&gt; Type
<span class="lineno">   25 </span><span class="decl"><span class="nottickedoff">bitSeqType i = TCon (TC TCSeq) [TCon (TC (TCNum i)) [],TCon (TC TCBit) []]</span></span>
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>-- | How to print out a single argument of a given type which occurs at a particular index
<span class="lineno">   28 </span>formatIndexedArg :: Bool -&gt; Name -&gt; Type -&gt; Int -&gt; String
<span class="lineno">   29 </span><span class="decl"><span class="nottickedoff">formatIndexedArg paren name typ index =</span>
<span class="lineno">   30 </span><span class="spaces">   </span><span class="nottickedoff">lparen ++ show (Arg name typ) ++ rparen ++ &quot; &quot; ++ formatIndex index</span>
<span class="lineno">   31 </span><span class="spaces">   </span><span class="nottickedoff">where</span>
<span class="lineno">   32 </span><span class="spaces">      </span><span class="nottickedoff">lparen = if paren then &quot;(&quot; else &quot;&quot;</span>
<span class="lineno">   33 </span><span class="spaces">      </span><span class="nottickedoff">rparen = if paren then &quot;)&quot; else &quot;&quot;</span></span>
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>-- | How to print out an index for an argument
<span class="lineno">   36 </span>formatIndex :: Int -&gt; String
<span class="lineno">   37 </span><span class="decl"><span class="nottickedoff">formatIndex index = &quot;arg. #&quot; ++ show index ++ &quot;&quot;</span></span>
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>-- | The symbol we use for saying things correspond to each other between modules
<span class="lineno">   40 </span>corresponds :: String
<span class="lineno">   41 </span><span class="decl"><span class="nottickedoff">corresponds = &quot; &lt;-&gt; &quot;</span></span>
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>-- Some general utilities...
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>-- | Like fromJust, but with an error message which makes you feel worse about yourself
<span class="lineno">   46 </span>assertJust :: Maybe a -&gt; a
<span class="lineno">   47 </span><span class="decl"><span class="nottickedoff">assertJust = fromMaybe (error &quot;assertJust: Impossible! A call to assertJust was made when it was not, in fact, *just*ified!&quot;)</span></span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>-- | Apply a function to both sides of a homogeneous pair
<span class="lineno">   50 </span>both :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
<span class="lineno">   51 </span><span class="decl"><span class="nottickedoff">both f (x, y) = (f x, f y)</span></span>
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>-- | Like forM, but without the M @(flip map)@
<span class="lineno">   54 </span>for :: [a] -&gt; (a -&gt; b) -&gt; [b]
<span class="lineno">   55 </span><span class="decl"><span class="nottickedoff">for = flip map</span></span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>-- | Intersperse the given monadic action between each element of the list processed
<span class="lineno">   58 </span>interspersingForM :: Monad m =&gt; m b -&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]
<span class="lineno">   59 </span><span class="decl"><span class="nottickedoff">interspersingForM between each = sequence . intersperse between . for each</span></span>
<span class="lineno">   60 </span>
<span class="lineno">   61 </span>-- | Like interspersingForM, but throws away result
<span class="lineno">   62 </span>interspersingForM_ :: Monad m =&gt; m b -&gt; [a] -&gt; (a -&gt; m b) -&gt; m ()
<span class="lineno">   63 </span><span class="decl"><span class="nottickedoff">interspersingForM_ between each = sequence_ . intersperse between . for each</span></span>
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>-- | Non-operator version of @(&gt;&gt;)@
<span class="lineno">   66 </span>before :: Monad m =&gt; m b -&gt; m a -&gt; m a
<span class="lineno">   67 </span><span class="decl"><span class="nottickedoff">before = (&gt;&gt;)</span></span>
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>-- | Execute second argument first, then first argument, returning second argument's result
<span class="lineno">   70 </span>after :: Monad m =&gt; m b -&gt; m a -&gt; m a
<span class="lineno">   71 </span><span class="decl"><span class="nottickedoff">after mb ma = ma &gt;&gt;= \x -&gt; mb &gt;&gt; return x</span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>-- | Do the first action before and after the second action, returning the second action's result
<span class="lineno">   74 </span>frame :: Monad m =&gt; m b -&gt; m a -&gt; m a
<span class="lineno">   75 </span><span class="decl"><span class="nottickedoff">frame mb = before mb . after mb</span></span>
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>-- | Like interspersingForM, but also does the interspersed action before and after
<span class="lineno">   78 </span>fencepostForM :: Monad m =&gt; m b -&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]
<span class="lineno">   79 </span><span class="decl"><span class="nottickedoff">fencepostForM between each = frame between . interspersingForM between each</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-- | Like fencepostForM, but throws away the result
<span class="lineno">   82 </span>fencepostForM_ :: Monad m =&gt; m b -&gt; [a] -&gt; (a -&gt; m b) -&gt; m ()
<span class="lineno">   83 </span><span class="decl"><span class="nottickedoff">fencepostForM_ between each = frame between . interspersingForM_ between each</span></span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>-- | Do the monadic action, returning a particular other value
<span class="lineno">   86 </span>returning :: (Monad m) =&gt; a -&gt; m b -&gt; m a
<span class="lineno">   87 </span><span class="decl"><span class="nottickedoff">returning a mb = mb &gt;&gt; return a</span></span>
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>-- | Use a Set to intersect two lists quickly
<span class="lineno">   90 </span>fastIntersect :: (Ord a) =&gt; [a] -&gt; [a] -&gt; [a]
<span class="lineno">   91 </span><span class="decl"><span class="nottickedoff">fastIntersect xs ys = Set.toList $ Set.fromList xs `Set.intersection` Set.fromList ys</span></span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-- | Calculate the symmetric difference between two sets
<span class="lineno">   94 </span>symmetricDifference :: (Ord a) =&gt; Set a -&gt; Set a -&gt; Set a
<span class="lineno">   95 </span><span class="decl"><span class="nottickedoff">symmetricDifference s t =</span>
<span class="lineno">   96 </span><span class="spaces">   </span><span class="nottickedoff">Set.difference (Set.union s t) (Set.intersection s t)</span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>-- | Delete a value from a map of sets, pruning the key if it was the last item in that set
<span class="lineno">   99 </span>deleteFromSetMap :: (Ord k, Ord v) =&gt; k -&gt; v -&gt; Map k (Set v) -&gt; Map k (Set v)
<span class="lineno">  100 </span><span class="decl"><span class="nottickedoff">deleteFromSetMap k v =</span>
<span class="lineno">  101 </span><span class="spaces">  </span><span class="nottickedoff">Map.update (mfilter (not . Set.null) . Just . Set.delete v) k</span></span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>-- | Given a mapping from values to keys, transform a list of values
<span class="lineno">  104 </span>--   into a mapping from keys to sets of values mapped to that key
<span class="lineno">  105 </span>tabulateBy :: (Ord k, Ord v) =&gt; (v -&gt; k) -&gt; [v] -&gt; Map k (Set v)
<span class="lineno">  106 </span><span class="decl"><span class="nottickedoff">tabulateBy f = Map.fromListWith Set.union . map (f &amp;&amp;&amp; Set.singleton)</span></span>
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- | Calculate the list of keys shared between two maps
<span class="lineno">  109 </span>sharedKeys :: (Ord k) =&gt; Map k v -&gt; Map k v -&gt; [k]
<span class="lineno">  110 </span><span class="decl"><span class="nottickedoff">sharedKeys = curry $ Set.toList . uncurry Set.intersection . both Map.keysSet</span></span>
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>-- | Given a Set and a function from its elements to some other thing, turn it into a map
<span class="lineno">  113 </span>--   In other words: calculate the image of the function over the set
<span class="lineno">  114 </span>associateSetWith :: (Ord k) =&gt; (k -&gt; v) -&gt; Set k -&gt; Map k v
<span class="lineno">  115 </span><span class="decl"><span class="nottickedoff">associateSetWith f = Map.fromAscList . map (id &amp;&amp;&amp; f) . Set.toAscList</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- | Squish two applicative actions into one which returns a tuple
<span class="lineno">  118 </span>pairA :: (Applicative f) =&gt; f a -&gt; f b -&gt; f (a,b)
<span class="lineno">  119 </span><span class="decl"><span class="nottickedoff">pairA = (&lt;*&gt;) . fmap (,)</span></span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>-- | All the different ways of saying yes and no
<span class="lineno">  122 </span>--   Lists must be disjoint or there are runtime errors in your future...
<span class="lineno">  123 </span>yes, no :: [String]
<span class="lineno">  124 </span>(yes, no) =
<span class="lineno">  125 </span>   <span class="nottickedoff">let yes' = [&quot;y&quot;,&quot;yes&quot;,&quot;yep&quot;,&quot;yeah&quot;,&quot;okay&quot;,&quot;ok&quot;,&quot;mkay&quot;,&quot;ay&quot;,&quot;positive&quot;]</span>
<span class="lineno">  126 </span><span class="spaces">       </span><span class="nottickedoff">no'  = [&quot;n&quot;,&quot;no&quot;,&quot;nope&quot;,&quot;nah&quot;,&quot;nay&quot;,&quot;negative&quot;]</span>
<span class="lineno">  127 </span><span class="spaces">   </span><span class="nottickedoff">in case fastIntersect yes' no' of</span>
<span class="lineno">  128 </span><span class="spaces">         </span><span class="nottickedoff">[] -&gt; (yes', no')</span>
<span class="lineno">  129 </span><span class="spaces">         </span><span class="nottickedoff">_  -&gt; error &quot;Internal error: English synonyms for 'yes' and 'no' cannot overlap.&quot;</span>

</pre>
</body>
</html>
