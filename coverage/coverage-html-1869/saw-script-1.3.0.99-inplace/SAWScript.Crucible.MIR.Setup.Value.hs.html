<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWScript.Crucible.MIR.Setup.Value
<span class="lineno">    3 </span>Description : Data types and type family instances for MIR-specific code
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : Ryan Scott &lt;rscott@galois.com&gt;
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>The module exists separately from &quot;SAWScript.Crucible.MIR.MethodSpecIR&quot;
<span class="lineno">    9 </span>primarily to avoid import cycles. You probably want to import
<span class="lineno">   10 </span>&quot;SAWScript.Crucible.MIR.MethodSpecIR&quot; (which re-exports everything from this
<span class="lineno">   11 </span>module, plus additional functionality) instead.
<span class="lineno">   12 </span>-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>{-# Language DataKinds #-}
<span class="lineno">   15 </span>{-# Language GADTs #-}
<span class="lineno">   16 </span>{-# Language OverloadedStrings #-}
<span class="lineno">   17 </span>{-# Language RankNTypes #-}
<span class="lineno">   18 </span>{-# Language StandaloneDeriving #-}
<span class="lineno">   19 </span>{-# Language TemplateHaskell #-}
<span class="lineno">   20 </span>{-# Language TypeFamilies #-}
<span class="lineno">   21 </span>{-# Language TypeOperators #-}
<span class="lineno">   22 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>module SAWScript.Crucible.MIR.Setup.Value
<span class="lineno">   25 </span>  ( -- * @MIRCrucibleContext@
<span class="lineno">   26 </span>    MIRCrucibleContext(..)
<span class="lineno">   27 </span>  , mccRustModule
<span class="lineno">   28 </span>  , mccBackend
<span class="lineno">   29 </span>  , mccSimContext
<span class="lineno">   30 </span>  , mccSymGlobalState
<span class="lineno">   31 </span>  , mccStaticInitializerMap
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>    -- * @MirStaticInitializerMap@
<span class="lineno">   34 </span>  , MirStaticInitializerMap
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>    -- * @MirPointsTo@
<span class="lineno">   37 </span>  , MirPointsTo(..)
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>    -- * @MirAllocSpec@
<span class="lineno">   40 </span>  , MirAllocSpec(..)
<span class="lineno">   41 </span>  , maConditionMetadata
<span class="lineno">   42 </span>  , maType
<span class="lineno">   43 </span>  , maMutbl
<span class="lineno">   44 </span>  , maMirType
<span class="lineno">   45 </span>  , maLen
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>    -- * @MirPointer@
<span class="lineno">   48 </span>  , MirPointer(..)
<span class="lineno">   49 </span>  , mpType
<span class="lineno">   50 </span>  , mpMutbl
<span class="lineno">   51 </span>  , mpMirType
<span class="lineno">   52 </span>  , mpRef
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>    -- * @MirSetupEnum@
<span class="lineno">   55 </span>  , MirSetupEnum(..)
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>    -- * @MirSetupSlice@
<span class="lineno">   58 </span>  , MirSetupSlice(..)
<span class="lineno">   59 </span>  , MirSliceInfo(..)
<span class="lineno">   60 </span>  ) where
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>import Control.Lens (makeLenses)
<span class="lineno">   63 </span>import Data.Parameterized.Classes
<span class="lineno">   64 </span>import Data.Parameterized.Map (MapF)
<span class="lineno">   65 </span>import Data.Parameterized.Some
<span class="lineno">   66 </span>import Data.Text (Text)
<span class="lineno">   67 </span>import Data.Void (Void)
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>import Lang.Crucible.Simulator (GlobalVar, RegValue', SimContext, SymGlobalState)
<span class="lineno">   70 </span>import Lang.Crucible.Types
<span class="lineno">   71 </span>import Mir.DefId
<span class="lineno">   72 </span>import Mir.Generator
<span class="lineno">   73 </span>import Mir.Intrinsics
<span class="lineno">   74 </span>import qualified Mir.Mir as M
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>import           SAWScript.Crucible.Common
<span class="lineno">   77 </span>import qualified SAWScript.Crucible.Common.Setup.Value as MS
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>type instance MS.XSetupNull MIR = Void
<span class="lineno">   80 </span>type instance MS.XSetupGlobal MIR = ()
<span class="lineno">   81 </span>type instance MS.XSetupStruct MIR = M.Adt
<span class="lineno">   82 </span>type instance MS.XSetupEnum MIR = MirSetupEnum
<span class="lineno">   83 </span>type instance MS.XSetupTuple MIR = ()
<span class="lineno">   84 </span>type instance MS.XSetupSlice MIR = MirSetupSlice
<span class="lineno">   85 </span>-- The 'M.Ty' represents the type of array elements.
<span class="lineno">   86 </span>type instance MS.XSetupArray MIR = M.Ty
<span class="lineno">   87 </span>type instance MS.XSetupElem MIR = ()
<span class="lineno">   88 </span>type instance MS.XSetupField MIR = ()
<span class="lineno">   89 </span>type instance MS.XSetupCast MIR = Void
<span class="lineno">   90 </span>type instance MS.XSetupUnion MIR = Void
<span class="lineno">   91 </span>type instance MS.XSetupGlobalInitializer MIR = ()
<span class="lineno">   92 </span>type instance MS.XSetupMux MIR = ()
<span class="lineno">   93 </span>
<span class="lineno">   94 </span>type instance MS.TypeName MIR = Text
<span class="lineno">   95 </span>type instance MS.ExtType MIR = M.Ty
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>type instance MS.MethodId MIR = DefId
<span class="lineno">   98 </span>type instance MS.AllocSpec MIR = Some MirAllocSpec
<span class="lineno">   99 </span>type instance MS.PointsTo MIR = MirPointsTo
<span class="lineno">  100 </span>type instance MS.ResolvedState MIR = ()
<span class="lineno">  101 </span>
<span class="lineno">  102 </span>type instance MS.Codebase MIR = CollectionState
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>data MIRCrucibleContext =
<span class="lineno">  105 </span>  MIRCrucibleContext
<span class="lineno">  106 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccRustModule</span></span></span>           :: RustModule
<span class="lineno">  107 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">_mccBackend</span></span></span>              :: SomeOnlineBackend
<span class="lineno">  108 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccSimContext</span></span></span>           :: SimContext (SAWCruciblePersonality Sym) Sym MIR
<span class="lineno">  109 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccSymGlobalState</span></span></span>       :: SymGlobalState Sym
<span class="lineno">  110 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mccStaticInitializerMap</span></span></span> :: MirStaticInitializerMap
<span class="lineno">  111 </span>  }
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>type instance MS.CrucibleContext MIR = MIRCrucibleContext
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>type instance MS.Pointer' MIR sym = Some (MirPointer sym)
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>-- | A 'MirStaticInitializerMap' maps the 'GlobalVar's of each top-level static
<span class="lineno">  118 </span>-- value in a 'Mir.RustModule' to its initializer value (post-Crucible
<span class="lineno">  119 </span>-- translation). See @Note [Translating MIR statics in SAW]@ in
<span class="lineno">  120 </span>-- &quot;SAWScript.Crucible.MIR.Builtins&quot; for more details on how this map is
<span class="lineno">  121 </span>-- created.
<span class="lineno">  122 </span>type MirStaticInitializerMap = MapF GlobalVar (RegValue' Sym)
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>-- | Unlike @LLVMPointsTo@ and @JVMPointsTo@, 'MirPointsTo' contains a /list/ of
<span class="lineno">  125 </span>-- 'MS.SetupValue's on the right-hand side. This is due to how slices are
<span class="lineno">  126 </span>-- represented in @crucible-mir-comp@, which stores the list of values
<span class="lineno">  127 </span>-- referenced by the slice. The @mir_points_to@ command, on the other hand,
<span class="lineno">  128 </span>-- always creates 'MirPointsTo' values with exactly one value in the list (see
<span class="lineno">  129 </span>-- the @firstPointsToReferent@ function in &quot;SAWScript.Crucible.MIR.Override&quot;).
<span class="lineno">  130 </span>data MirPointsTo = MirPointsTo MS.ConditionMetadata (MS.SetupValue MIR) [MS.SetupValue MIR]
<span class="lineno">  131 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>data MirAllocSpec tp = MirAllocSpec
<span class="lineno">  134 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maConditionMetadata</span></span></span> :: MS.ConditionMetadata
<span class="lineno">  135 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maType</span></span></span> :: TypeRepr tp
<span class="lineno">  136 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maMutbl</span></span></span> :: M.Mutability
<span class="lineno">  137 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maMirType</span></span></span> :: M.Ty
<span class="lineno">  138 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_maLen</span></span></span> :: Int
<span class="lineno">  139 </span>    }
<span class="lineno">  140 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF MirAllocSpec</span></span></span></span></span></span> where
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>data MirPointer sym tp = MirPointer
<span class="lineno">  145 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpType</span></span></span> :: TypeRepr tp
<span class="lineno">  146 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpMutbl</span></span></span> :: M.Mutability
<span class="lineno">  147 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpMirType</span></span></span> :: M.Ty
<span class="lineno">  148 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_mpRef</span></span></span> :: MirReferenceMux sym tp
<span class="lineno">  149 </span>    }
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- | A enum-related MIR 'SetupValue'.
<span class="lineno">  152 </span>data MirSetupEnum where
<span class="lineno">  153 </span>  -- | A specific variant of an enum.
<span class="lineno">  154 </span>  MirSetupEnumVariant ::
<span class="lineno">  155 </span>       M.Adt
<span class="lineno">  156 </span>       -- ^ The enum type.
<span class="lineno">  157 </span>    -&gt; M.Variant
<span class="lineno">  158 </span>       -- ^ The variant to use.
<span class="lineno">  159 </span>    -&gt; Int
<span class="lineno">  160 </span>       -- ^ The index of the variant within the list of all the enum's variants.
<span class="lineno">  161 </span>       -- In most circumstances, this index will be the same as the discriminant
<span class="lineno">  162 </span>       -- value, but the index can be different if a variant uses an explicit
<span class="lineno">  163 </span>       -- value. For instance, in this example:
<span class="lineno">  164 </span>       --
<span class="lineno">  165 </span>       -- @
<span class="lineno">  166 </span>       -- enum A {
<span class="lineno">  167 </span>       --     A0,
<span class="lineno">  168 </span>       --     A1,
<span class="lineno">  169 </span>       -- }
<span class="lineno">  170 </span>       --
<span class="lineno">  171 </span>       -- enum B {
<span class="lineno">  172 </span>       --     B0 = 42,
<span class="lineno">  173 </span>       --     B1,
<span class="lineno">  174 </span>       -- }
<span class="lineno">  175 </span>       -- @
<span class="lineno">  176 </span>       --
<span class="lineno">  177 </span>       -- The indexes for @A0@ and @B0@ are both @0@, and the indexes for @A1@
<span class="lineno">  178 </span>       -- and @B1@ are both @1@. The discriminant values are different, however.
<span class="lineno">  179 </span>       -- The discriminants for @A0@ and @A1@ are @0@ and @1@, respectively,
<span class="lineno">  180 </span>       -- while the discriminants for @B0@ and @B1@ are @42@ and @43@,
<span class="lineno">  181 </span>       -- respectively.
<span class="lineno">  182 </span>       --
<span class="lineno">  183 </span>       -- Note that the index is accessible within the 'M.Variant' argument, but
<span class="lineno">  184 </span>       -- retrieving the information is somewhat involved. (See the
<span class="lineno">  185 </span>       -- implementation of @mir_enum_value@.) For this reason, we store this
<span class="lineno">  186 </span>       -- information separately in 'MirSetupEnumVariant' to make it easier to
<span class="lineno">  187 </span>       -- look up later.
<span class="lineno">  188 </span>    -&gt; [MS.SetupValue MIR]
<span class="lineno">  189 </span>       -- ^ The values of the variant's fields.
<span class="lineno">  190 </span>    -&gt; MirSetupEnum
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>  -- | A symbolic enum value, where the 'M.Adt' represents the enum type.
<span class="lineno">  193 </span>  -- This is only used in the implementation of @mir_fresh_expanded_value@.
<span class="lineno">  194 </span>  -- See @Note [Symbolic enums]@ for a more detailed explanation.
<span class="lineno">  195 </span>  --
<span class="lineno">  196 </span>  -- Note that @repr(transparent)@ enums never use 'MirSetupEnumSymbolic'.
<span class="lineno">  197 </span>  -- Instead, they are represented as a 'MirSetupEnumVariant' where the
<span class="lineno">  198 </span>  -- underlying variant field is symbolic. This makes it simpler to ensure that
<span class="lineno">  199 </span>  -- resolving a @repr(transparent@ enum value will yield a 'MIRVal' whose
<span class="lineno">  200 </span>  -- 'TypeShape' is 'TransparentShape'.
<span class="lineno">  201 </span>  MirSetupEnumSymbolic ::
<span class="lineno">  202 </span>       M.Adt
<span class="lineno">  203 </span>       -- ^ The enum type.
<span class="lineno">  204 </span>    -&gt; MS.SetupValue MIR
<span class="lineno">  205 </span>       -- ^ The symbolic discriminant value.
<span class="lineno">  206 </span>    -&gt; [[MS.SetupValue MIR]]
<span class="lineno">  207 </span>       -- ^ The symbolic values that are used for the fields in each variant.
<span class="lineno">  208 </span>       -- For instance, if one created a symbolic value of this type:
<span class="lineno">  209 </span>       --
<span class="lineno">  210 </span>       -- @
<span class="lineno">  211 </span>       -- enum E {
<span class="lineno">  212 </span>       --     E1(u16),
<span class="lineno">  213 </span>       --     E2(u32, u32),
<span class="lineno">  214 </span>       -- @
<span class="lineno">  215 </span>       --
<span class="lineno">  216 </span>       -- Then the list of fields would be @[[x], [y, z]]@, where @x: u16@
<span class="lineno">  217 </span>       -- are the fields of @E1@, and @y: u32@ and @z: u32@ are the fields of
<span class="lineno">  218 </span>       -- @E2@.
<span class="lineno">  219 </span>    -&gt; MirSetupEnum
<span class="lineno">  220 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>-- | A slice-related MIR 'SetupValue'. This is used to power the @mir_slice_*@
<span class="lineno">  223 </span>-- and @mir_str_slice_*@ family of SAWScript functions.
<span class="lineno">  224 </span>data MirSetupSlice
<span class="lineno">  225 </span>  = MirSetupSliceRaw (MS.SetupValue MIR) (MS.SetupValue MIR)
<span class="lineno">  226 </span>    -- ^ A \&quot;raw\&quot; slice constructed directly from a pointer and a length.
<span class="lineno">  227 </span>    -- Currently, this is only used by @crucible-mir-comp@. SAWScript offers no
<span class="lineno">  228 </span>    -- way to use this, although we may consider doing so in the future.
<span class="lineno">  229 </span>  | MirSetupSlice MirSliceInfo (MS.SetupValue MIR)
<span class="lineno">  230 </span>    -- ^ A slice of a reference to a contiguous sequence 'SetupValue'.
<span class="lineno">  231 </span>  | MirSetupSliceRange MirSliceInfo (MS.SetupValue MIR) Int Int
<span class="lineno">  232 </span>    -- ^ A slice of a reference to a contiguous sequence 'SetupValue', where the
<span class="lineno">  233 </span>    -- slice only covers the range specified by the given start and end values
<span class="lineno">  234 </span>    -- (the first and second 'Int', respectively). Currently, this only supports
<span class="lineno">  235 </span>    -- concrete ranges.
<span class="lineno">  236 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>-- | Are we dealing with an array slice (@[T]@) or a string slice (@str@)?
<span class="lineno">  239 </span>data MirSliceInfo
<span class="lineno">  240 </span>  = -- | @[T]@ (for some type @T@)
<span class="lineno">  241 </span>    MirArraySlice
<span class="lineno">  242 </span>  | -- | @str@
<span class="lineno">  243 </span>    MirStrSlice
<span class="lineno">  244 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  245 </span>
<span class="lineno">  246 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''MIRCrucibleContext</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  247 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''MirAllocSpec</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  248 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''MirPointer</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>{-
<span class="lineno">  251 </span>Note [Symbolic enums]
<span class="lineno">  252 </span>~~~~~~~~~~~~~~~~~~~~~
<span class="lineno">  253 </span>Creating a symbolic MIR enum value is not quite as straightforward as creating
<span class="lineno">  254 </span>symbolic versions of other compound types, mostly due to the atypical Crucible
<span class="lineno">  255 </span>representation that enums use. To recap, if we have an enum like this:
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>  enum E {
<span class="lineno">  258 </span>    E1(u16),
<span class="lineno">  259 </span>    E2(u32, u32),
<span class="lineno">  260 </span>  }
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>Then this will be implemented using (roughly) the following Crucible `Type`
<span class="lineno">  263 </span>under the hood:
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>  (BVType 64, VariantType [StructType [BVType 16], StructType [BVType 32, BVType 32]])
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>Where:
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>* The `BVType 64` is a /discriminant/, whose value indicates which variant is
<span class="lineno">  270 </span>  in use. For instance, a discriminant value of `0` indicates that the `E1`
<span class="lineno">  271 </span>  variant is in use, and a discriminant value of `1` indicates that the `E2`
<span class="lineno">  272 </span>  variant is in use.
<span class="lineno">  273 </span>* The `VariantType ...` indicates that there are two variants in this enum,
<span class="lineno">  274 </span>  where each variant is represented as a struct with the corresponding fields
<span class="lineno">  275 </span>  in that variant.
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>At simulation time, VariantTypes are represented as a sequence of
<span class="lineno">  278 </span>VariantBranches, where a VariantBranch is (roughly) a pair of:
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>* A (possibly symbolic) predicate indicating if that variant is being used, and
<span class="lineno">  281 </span>* A payload representing the fields of the enum. If the predicate does not
<span class="lineno">  282 </span>  hold, then the payload will likely be symbolic, since it does not matter what
<span class="lineno">  283 </span>  the payload value is in that case.
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>OK, recap over. Let's get back to the original question: how do we make a
<span class="lineno">  286 </span>symbolic value of this type? A naïve first attempt is to generate fresh
<span class="lineno">  287 </span>symbolic values for everything. That is, a symbolic discriminant, as well as a
<span class="lineno">  288 </span>symbolic predicate and payload for each VariantBranch. While tempting, this
<span class="lineno">  289 </span>approach won't work. To see why, consider what happens when one pattern matches
<span class="lineno">  290 </span>on a symbolic enum value. For example, the `match` expression in this function:
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>  fn foo(x: E) -&gt; u32 {
<span class="lineno">  293 </span>      match x {
<span class="lineno">  294 </span>          E::E1(a) =&gt; bar(y),
<span class="lineno">  295 </span>          E::E2(b, c) =&gt; baz(b, c),
<span class="lineno">  296 </span>      }
<span class="lineno">  297 </span>  }
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>Would turn into the (roughly) following MIR:
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>  fn foo(x : E) -&gt; u32 {
<span class="lineno">  302 </span>      start_block: {
<span class="lineno">  303 </span>          discr = Discriminant(x, isize);
<span class="lineno">  304 </span>          switchint discr :isize [0, 1] -&gt; [e1_block, e2_block, fallthrough_block]
<span class="lineno">  305 </span>      }
<span class="lineno">  306 </span>      e1_block: {
<span class="lineno">  307 </span>          ... call bar() ...
<span class="lineno">  308 </span>      }
<span class="lineno">  309 </span>      e2_block: {
<span class="lineno">  310 </span>          ... call baz() ...
<span class="lineno">  311 </span>      }
<span class="lineno">  312 </span>      fallthrough_block: {
<span class="lineno">  313 </span>          unreachable;
<span class="lineno">  314 </span>      }
<span class="lineno">  315 </span>      ...
<span class="lineno">  316 </span>  }
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>Here, the `switchint discr` statement will check the value of `discr` (the
<span class="lineno">  319 </span>discriminant), and if it equals `0`, go to `e1_block`; if it equals `1`, go to
<span class="lineno">  320 </span>`e2_block`; and if it equals something else, go to `fallthrough_block`. In
<span class="lineno">  321 </span>normal circumstances, `discr` should only ever be equal to `0` or `1`, which
<span class="lineno">  322 </span>implies that `fallthrough_block` should never be accessible (as indicated by
<span class="lineno">  323 </span>its `unreachable` instruction).
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>Now consider what would happen if the discriminant were an unconstrained,
<span class="lineno">  326 </span>symbolic value. While a symbolic discriminant could be equal to `0` or `1`, it
<span class="lineno">  327 </span>could also be equal to any other value! This would spell disaster if Crucible
<span class="lineno">  328 </span>tried to perform a symbolic branch on, say, `discr == 2`, since that would
<span class="lineno">  329 </span>cause execution to reach `fallthrough_block` and crash. We want a symbolic
<span class="lineno">  330 </span>discriminant, but we don't want it to be /that/ symbolic!
<span class="lineno">  331 </span>
<span class="lineno">  332 </span>For this reason, after we create a symbolic discriminant value, we also add a
<span class="lineno">  333 </span>Crucible assumption that the discriminant must be equal to one of the possible
<span class="lineno">  334 </span>enum variants' discriminants. In the example above, this means that we would
<span class="lineno">  335 </span>assume assume the following:
<span class="lineno">  336 </span>
<span class="lineno">  337 </span>  (discr == 0) \/ (discr == 1)
<span class="lineno">  338 </span>
<span class="lineno">  339 </span>This way, symbolic execution will never reach `fallthrough_block`. This
<span class="lineno">  340 </span>Crucible assumption is created in
<span class="lineno">  341 </span>SAWScript.Crucible.MIR.Builtins.constructExpandedSetupValue.goEnum`.
<span class="lineno">  342 </span>
<span class="lineno">  343 </span>Similarly, we cannot make the VariantBranch predicates completely symbolic, as
<span class="lineno">  344 </span>whether a predicate holds or not depends on the value of the discriminant. For
<span class="lineno">  345 </span>this reason, we do not create fresh variables for each predicate, but instead
<span class="lineno">  346 </span>make each predicate the result of checking the discriminant against particular
<span class="lineno">  347 </span>values. For instance, the predicate for the `E1` VariantBranch is defined to be
<span class="lineno">  348 </span>`discr == 0`, and the predicate for the `E2` VariantBranch is defined to be
<span class="lineno">  349 </span>`discr == 1`. These predicates are defined in
<span class="lineno">  350 </span>`SAWScript.Crucible.MIR.ResolveSetupValue.resolveSetupValue`, along with the
<span class="lineno">  351 </span>fields in the associated payloads.
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>Lastly, there are the payloads (i.e., the fields of each variant) in each
<span class="lineno">  354 </span>VariantBranch. These are created as completely symbolic values—the trick is to
<span class="lineno">  355 </span>only access the fields when the corresponding predicate holds. For example,
<span class="lineno">  356 </span>`SAWScript.Crucible.MIR.Override.matchArg` (in the `MirSetupEnumSymbolic` case)
<span class="lineno">  357 </span>must be able to match two possibly symbolic enum values together, but it must
<span class="lineno">  358 </span>be careful to only match the fields in a variant if that VariantBranch's
<span class="lineno">  359 </span>predicate holds.
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>To make this a bit more specific, suppose we have two symbolic enum values
<span class="lineno">  362 </span>`enumA` and `enumA`, where:
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>* `enumA` has the discriminant value `discrA`, and
<span class="lineno">  365 </span>  `enumB` has the discriminant value `discrB`.
<span class="lineno">  366 </span>* `enumA` has the VariantBranches [(e1_pred_a, [e1_fld1_a]), (e2_pred_a, [e2_fld1_a, e2_fld2_a])], and
<span class="lineno">  367 </span>  `enumB` has the VariantBranches [(e1_pred_b, [e1_fld1_b]), (e2_pred_b, [e2_fld1_b, e2_fld2_b])].
<span class="lineno">  368 </span>
<span class="lineno">  369 </span>We only want to match `e1_fld1_a` against `e1_fld1_b` if both enums are using
<span class="lineno">  370 </span>the `E1` variant, that is, if `e1_pred_a` and `e_pred_b` hold. To this end, the
<span class="lineno">  371 </span>`matchArg` function checks this by generating (roughly) the following
<span class="lineno">  372 </span>assertion:
<span class="lineno">  373 </span>
<span class="lineno">  374 </span>  (discrA == discrB) /\
<span class="lineno">  375 </span>  (e1_pred_a ==&gt; (e1_fld1_a == e1_fld1_b))
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>(Note that instead of `e1_pred_a ==&gt; ...`, we could have alternatively used
<span class="lineno">  378 </span>`e1_pred_b ==&gt; ...`, `(discrA == 0) ==&gt; ...`, or `(discrB == 0) ==&gt; ...`. All
<span class="lineno">  379 </span>formulations are equivalent.)
<span class="lineno">  380 </span>
<span class="lineno">  381 </span>Phew! Enums are surprisingly tricky.
<span class="lineno">  382 </span>-}

</pre>
</body>
</html>
