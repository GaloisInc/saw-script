<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">    2 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    4 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    5 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    6 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    7 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">    8 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">    9 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   10 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>{- |
<span class="lineno">   13 </span>Module      : SAWCoreRocq.Term
<span class="lineno">   14 </span>Copyright   : Galois, Inc. 2018
<span class="lineno">   15 </span>License     : BSD3
<span class="lineno">   16 </span>Maintainer  : atomb@galois.com
<span class="lineno">   17 </span>Stability   : experimental
<span class="lineno">   18 </span>Portability : portable
<span class="lineno">   19 </span>-}
<span class="lineno">   20 </span>
<span class="lineno">   21 </span>module SAWCoreRocq.Term where
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>import           Control.Lens                 (makeLenses, over, set, to, view)
<span class="lineno">   24 </span>import           Control.Monad                (forM)
<span class="lineno">   25 </span>import qualified Control.Monad.Except         as Except
<span class="lineno">   26 </span>import qualified Control.Monad.Fail           as Fail
<span class="lineno">   27 </span>import           Control.Monad.Reader         (MonadReader(ask, local), asks)
<span class="lineno">   28 </span>import           Control.Monad.State          (MonadState(get), modify)
<span class="lineno">   29 </span>import           Data.Char                    (isDigit)
<span class="lineno">   30 </span>import           Data.IntMap.Strict           (IntMap)
<span class="lineno">   31 </span>import qualified Data.IntMap.Strict           as IntMap
<span class="lineno">   32 </span>import           Data.List                    (intersperse)
<span class="lineno">   33 </span>import           Data.Maybe                   (fromMaybe)
<span class="lineno">   34 </span>import qualified Data.Map                     as Map
<span class="lineno">   35 </span>import           Data.Map                     (Map)
<span class="lineno">   36 </span>import qualified Data.Set                     as Set
<span class="lineno">   37 </span>import           Data.Set                     (Set)
<span class="lineno">   38 </span>import qualified Data.Text                    as Text
<span class="lineno">   39 </span>import           Prelude                      hiding (fail)
<span class="lineno">   40 </span>import           Prettyprinter
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>import           Data.Parameterized.Pair
<span class="lineno">   43 </span>import           Data.Parameterized.NatRepr
<span class="lineno">   44 </span>import qualified Data.BitVector.Sized         as BV
<span class="lineno">   45 </span>import qualified Data.Vector                  as Vector (toList)
<span class="lineno">   46 </span>import qualified Language.Rocq.AST            as Rocq
<span class="lineno">   47 </span>import qualified Language.Rocq.Pretty         as Rocq
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>import           SAWCore.Module               (Def(..), ModuleMap, ResolvedName(..), requireNameInMap, resolvedNameType)
<span class="lineno">   50 </span>import           SAWCore.Name
<span class="lineno">   51 </span>import           SAWCore.Recognizer
<span class="lineno">   52 </span>import           SAWCore.SharedTerm
<span class="lineno">   53 </span>import           SAWCore.Term.Pretty
<span class="lineno">   54 </span>import           SAWCore.Term.Functor
<span class="lineno">   55 </span>import           SAWCore.Term.Raw
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>import           SAWCoreRocq.Monad
<span class="lineno">   58 </span>import           SAWCoreRocq.SpecialTreatment
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>{-
<span class="lineno">   61 </span>import Debug.Trace
<span class="lineno">   62 </span>traceTerm :: String -&gt; Term -&gt; a -&gt; a
<span class="lineno">   63 </span>traceTerm ctx t a = trace (ctx ++ &quot;: &quot; ++ showTerm t) a
<span class="lineno">   64 </span>-}
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>-- | A Rocq identifier used for sharing subterms through let-bindings, annotated
<span class="lineno">   67 </span>-- with a 'Bool' flag indicating whether the shared subterm is closed, i.e., has
<span class="lineno">   68 </span>-- no free variables
<span class="lineno">   69 </span>data SharedName = SharedName { <span class="istickedoff"><span class="decl"><span class="istickedoff">sharedNameIdent</span></span></span> :: Rocq.Ident,
<span class="lineno">   70 </span>                               <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sharedNameIsClosed</span></span></span> :: Bool }
<span class="lineno">   71 </span>                deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>-- | The read-only state for translating terms
<span class="lineno">   74 </span>data TranslationReader = TranslationReader
<span class="lineno">   75 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_currentModule</span></span></span>  :: Maybe ModuleName
<span class="lineno">   76 </span>    -- ^ The current Rocq module for the translation
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_namedEnvironment</span></span></span>  :: Map VarName Rocq.Ident
<span class="lineno">   79 </span>    -- ^ The map of Rocq identifiers associated with the SAW core named
<span class="lineno">   80 </span>    -- variables in scope
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_unavailableIdents</span></span></span> :: Set Rocq.Ident
<span class="lineno">   83 </span>    -- ^ The set of Rocq identifiers that are either reserved or already in use.
<span class="lineno">   84 </span>    -- To avoid shadowing, fresh identifiers should be chosen to be disjoint
<span class="lineno">   85 </span>    -- from this set.
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_sharedNames</span></span></span> :: IntMap SharedName
<span class="lineno">   88 </span>    -- ^ Index of identifiers for repeated subterms that have been lifted out
<span class="lineno">   89 </span>    -- into a let expression
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_nextSharedName</span></span></span> :: Rocq.Ident
<span class="lineno">   92 </span>    -- ^ The next available name to be used for a let-bound shared
<span class="lineno">   93 </span>    -- sub-expression
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_sawModuleMap</span></span></span> :: ModuleMap
<span class="lineno">   96 </span>    -- ^ The environment of SAW global definitions
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_useImplicitBinders</span></span></span> :: Bool
<span class="lineno">   99 </span>    -- ^ This is False when in a term context where using implicit binders
<span class="lineno">  100 </span>    -- doesn't make sense and are ignored by Rocq, such as inside lambda
<span class="lineno">  101 </span>    -- bodies, function arguments, etc.
<span class="lineno">  102 </span>  }
<span class="lineno">  103 </span>  -- deriving (Show)
<span class="lineno">  104 </span>
<span class="lineno">  105 </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff">makeLenses ''TranslationReader</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>data TranslationState = TranslationState
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_globalDeclarations</span></span></span> :: [Rocq.Ident]
<span class="lineno">  110 </span>    -- ^ Some Cryptol terms seem to capture the name and body of some functions
<span class="lineno">  111 </span>    -- they use (whether from the Cryptol prelude, or previously defined in the
<span class="lineno">  112 </span>    -- same file). We want to translate those exactly once, so we need to keep
<span class="lineno">  113 </span>    -- track of which ones have already been translated.
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_topLevelDeclarations</span></span></span> :: [Rocq.Decl]
<span class="lineno">  116 </span>    -- ^ Because some terms capture their dependencies, translating one term may
<span class="lineno">  117 </span>    -- result in multiple declarations: one for the term itself, but also zero
<span class="lineno">  118 </span>    -- or many for its dependencies. We store all of those in this, so that a
<span class="lineno">  119 </span>    -- caller of the translation may retrieve all the declarations needed to
<span class="lineno">  120 </span>    -- translate the term. The translation function itself will return only the
<span class="lineno">  121 </span>    -- declaration for the term being translated.
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>  }
<span class="lineno">  124 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  125 </span>
<span class="lineno">  126 </span><span class="nottickedoff"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''TranslationState</span></span></span></span></span></span></span>
<span class="lineno">  127 </span>
<span class="lineno">  128 </span>-- | The constraint stating that 'm' can be used for term translation. This
<span class="lineno">  129 </span>-- requires that it have reader effects for 'TranslationReader' and state
<span class="lineno">  130 </span>-- effects for 'TranslationState'.
<span class="lineno">  131 </span>type TermTranslationMonad m =
<span class="lineno">  132 </span>  TranslationMonad TranslationReader TranslationState m
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- | Get just the 'TranslationReader' component of the reader value
<span class="lineno">  135 </span>askTR :: TermTranslationMonad m =&gt; m TranslationReader
<span class="lineno">  136 </span><span class="decl"><span class="istickedoff">askTR = otherConfiguration &lt;$&gt; ask</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | Modify just the 'TranslationReader' component of the reader value
<span class="lineno">  139 </span>localTR :: TermTranslationMonad m =&gt;
<span class="lineno">  140 </span>            (TranslationReader -&gt; TranslationReader) -&gt; m a -&gt; m a
<span class="lineno">  141 </span><span class="decl"><span class="istickedoff">localTR f =</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="istickedoff">local (\r -&gt; r { otherConfiguration = f (otherConfiguration r) })</span></span>
<span class="lineno">  143 </span>
<span class="lineno">  144 </span>-- | Take a Rocq identifier that ends in a number (i.e., a sequence of digits)
<span class="lineno">  145 </span>-- and add 1 to that number, viewing an identifier with no trailing number as
<span class="lineno">  146 </span>-- ending in 0
<span class="lineno">  147 </span>nextVariant :: Rocq.Ident -&gt; Rocq.Ident
<span class="lineno">  148 </span><span class="decl"><span class="nottickedoff">nextVariant (Rocq.Ident s) = Rocq.Ident (reverse (go (reverse s)))</span>
<span class="lineno">  149 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="nottickedoff">go :: String -&gt; String</span>
<span class="lineno">  151 </span><span class="spaces">    </span><span class="nottickedoff">go (c : cs)</span>
<span class="lineno">  152 </span><span class="spaces">      </span><span class="nottickedoff">| c == '9'  = '0' : go cs</span>
<span class="lineno">  153 </span><span class="spaces">      </span><span class="nottickedoff">| isDigit c = succ c : cs</span>
<span class="lineno">  154 </span><span class="spaces">    </span><span class="nottickedoff">go cs = '1' : cs</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>-- | Find an fresh, as-yet-unused variant of the given Rocq identifier
<span class="lineno">  157 </span>freshVariant :: TermTranslationMonad m =&gt; Rocq.Ident -&gt; m Rocq.Ident
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">freshVariant x =</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">do used &lt;- view unavailableIdents &lt;$&gt; askTR</span>
<span class="lineno">  160 </span><span class="spaces">     </span><span class="istickedoff">let ident0 = x</span>
<span class="lineno">  161 </span><span class="spaces">     </span><span class="istickedoff">let findVariant i = if <span class="tickonlyfalse">Set.member i used</span> then <span class="nottickedoff">findVariant (nextVariant i)</span> else i</span>
<span class="lineno">  162 </span><span class="spaces">     </span><span class="istickedoff">return $ findVariant ident0</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>-- | Locally mark a Rocq identifier as being used in the translation during a
<span class="lineno">  165 </span>-- translation computation, so that computation does not shadow it
<span class="lineno">  166 </span>withUsedRocqIdent :: TermTranslationMonad m =&gt; Rocq.Ident -&gt; m a -&gt; m a
<span class="lineno">  167 </span><span class="decl"><span class="istickedoff">withUsedRocqIdent ident m =</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="istickedoff">localTR (over unavailableIdents (Set.insert ident)) m</span></span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>-- | Translate a local name from a saw-core binder into a fresh Rocq identifier
<span class="lineno">  171 </span>translateLocalIdent :: TermTranslationMonad m =&gt; LocalName -&gt; m Rocq.Ident
<span class="lineno">  172 </span><span class="decl"><span class="istickedoff">translateLocalIdent x = freshVariant (escapeIdent (Rocq.Ident (Text.unpack x)))</span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- | Generate a fresh, unused Rocq identifier from a SAW core name and mark it as
<span class="lineno">  175 </span>-- unavailable in the supplied translation computation
<span class="lineno">  176 </span>withFreshIdent :: TermTranslationMonad m =&gt; LocalName -&gt; (Rocq.Ident -&gt; m a) -&gt;
<span class="lineno">  177 </span>                  m a
<span class="lineno">  178 </span><span class="decl"><span class="istickedoff">withFreshIdent n f =</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">do n_rocq &lt;- translateLocalIdent n</span>
<span class="lineno">  180 </span><span class="spaces">     </span><span class="istickedoff">withUsedRocqIdent n_rocq $ f n_rocq</span></span>
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>-- | Invalidate all shared subterms that are not closed in a translation
<span class="lineno">  183 </span>invalidateOpenSharing :: TermTranslationMonad m =&gt; m a -&gt; m a
<span class="lineno">  184 </span><span class="decl"><span class="nottickedoff">invalidateOpenSharing =</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="nottickedoff">localTR (over sharedNames $ IntMap.filter sharedNameIsClosed)</span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>-- | Run a translation in a context with one more SAW core variable with the
<span class="lineno">  188 </span>-- given name. Pass the corresponding Rocq identifier used for this SAW core
<span class="lineno">  189 </span>-- variable to the computation in which it is bound.
<span class="lineno">  190 </span>withSAWVar :: TermTranslationMonad m =&gt; VarName -&gt; (Rocq.Ident -&gt; m a) -&gt; m a
<span class="lineno">  191 </span><span class="decl"><span class="istickedoff">withSAWVar n m =</span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="istickedoff">withFreshIdent (vnName n) $ \n_rocq -&gt;</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">localTR (over namedEnvironment (Map.insert n n_rocq)) $ m n_rocq</span></span>
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>-- | Find a fresh name generated from 'nextSharedName' to use in place of the
<span class="lineno">  196 </span>-- supplied 'Term' with the supplied index, and associate that index with the
<span class="lineno">  197 </span>-- fresh name in the 'sharedNames' sharing map. Pass the name that was generated
<span class="lineno">  198 </span>-- to the computation.
<span class="lineno">  199 </span>withSharedTerm :: TermTranslationMonad m =&gt; TermIndex -&gt; Term -&gt;
<span class="lineno">  200 </span>                  (Rocq.Ident -&gt; m a) -&gt; m a
<span class="lineno">  201 </span><span class="decl"><span class="istickedoff">withSharedTerm idx t f =</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">do ident &lt;- (view nextSharedName &lt;$&gt; askTR) &gt;&gt;= freshVariant</span>
<span class="lineno">  203 </span><span class="spaces">     </span><span class="istickedoff">let sh_nm = SharedName ident $ <span class="nottickedoff">closedTerm t</span></span>
<span class="lineno">  204 </span><span class="spaces">     </span><span class="istickedoff">localTR (set nextSharedName <span class="nottickedoff">(nextVariant ident)</span> .</span>
<span class="lineno">  205 </span><span class="spaces">              </span><span class="istickedoff">over sharedNames (IntMap.insert idx sh_nm)) $</span>
<span class="lineno">  206 </span><span class="spaces">       </span><span class="istickedoff">withUsedRocqIdent <span class="nottickedoff">ident</span> $ f ident</span></span>
<span class="lineno">  207 </span>
<span class="lineno">  208 </span>-- | Use 'withSharedTerm' to mark a list of terms as being shared
<span class="lineno">  209 </span>withSharedTerms :: TermTranslationMonad m =&gt; [(TermIndex,Term)] -&gt;
<span class="lineno">  210 </span>                   ([Rocq.Ident] -&gt; m a) -&gt; m a
<span class="lineno">  211 </span><span class="decl"><span class="istickedoff">withSharedTerms [] f = f []</span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff">withSharedTerms ((idx,t):ts) f =</span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="istickedoff">withSharedTerm idx <span class="nottickedoff">t</span> $ \n -&gt; withSharedTerms ts $ \ns -&gt; f (n:ns)</span></span>
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>-- | The set of reserved identifiers in Rocq, obtained from section
<span class="lineno">  217 </span>-- \&quot;Core language\&quot; of the Rocq reference manual.
<span class="lineno">  218 </span>-- &lt;https://rocq-prover.org/refman/language/core/basic.html&gt;
<span class="lineno">  219 </span>reservedIdents :: Set Rocq.Ident
<span class="lineno">  220 </span><span class="decl"><span class="istickedoff">reservedIdents =</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="istickedoff">Set.fromList $</span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="istickedoff">map Rocq.Ident $</span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff">concatMap words $</span>
<span class="lineno">  224 </span><span class="spaces">  </span><span class="istickedoff">[ &quot;_ Axiom CoFixpoint Definition Fixpoint Hypothesis IF Parameter Prop&quot;</span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="istickedoff">, &quot;SProp Set Theorem Type Variable as at by cofix discriminated else&quot;</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">, &quot;end exists exists2 fix for forall fun if in lazymatch let match&quot;</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="istickedoff">, &quot;multimatch return then using where with&quot;</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="istickedoff">]</span></span>
<span class="lineno">  229 </span>
<span class="lineno">  230 </span>-- | Extract the list of names from a list of Rocq declarations.  Not all
<span class="lineno">  231 </span>-- declarations have names, e.g. comments and code snippets come without names.
<span class="lineno">  232 </span>namedDecls :: [Rocq.Decl] -&gt; [Rocq.Ident]
<span class="lineno">  233 </span><span class="decl"><span class="nottickedoff">namedDecls = concatMap filterNamed</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed :: Rocq.Decl -&gt; [Rocq.Ident]</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Axiom n _)                                = [n]</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Parameter n _)                            = [n]</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Variable n _)                             = [n]</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Comment _)                                = []</span>
<span class="lineno">  240 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Definition n _ _ _)                       = [n]</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.InductiveDecl (Rocq.Inductive n _ _ _ _)) = [n]</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Snippet _)                                = []</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="nottickedoff">filterNamed (Rocq.Section _ ds)                             = namedDecls ds</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>-- | Retrieve the names of all local and global declarations from the
<span class="lineno">  246 </span>-- translation state.
<span class="lineno">  247 </span>getNamesOfAllDeclarations ::
<span class="lineno">  248 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  249 </span>  m [Rocq.Ident]
<span class="lineno">  250 </span><span class="decl"><span class="nottickedoff">getNamesOfAllDeclarations = view allDeclarations &lt;$&gt; get</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="nottickedoff">allDeclarations =</span>
<span class="lineno">  253 </span><span class="spaces">      </span><span class="nottickedoff">to (\ (TranslationState {..}) -&gt; namedDecls _topLevelDeclarations ++ _globalDeclarations)</span></span>
<span class="lineno">  254 </span>
<span class="lineno">  255 </span>-- | Run a term translation computation
<span class="lineno">  256 </span>runTermTranslationMonad ::
<span class="lineno">  257 </span>  TranslationConfiguration -&gt;
<span class="lineno">  258 </span>  Maybe ModuleName -&gt;
<span class="lineno">  259 </span>  ModuleMap -&gt;
<span class="lineno">  260 </span>  [Rocq.Ident] -&gt;
<span class="lineno">  261 </span>  [Rocq.Ident] -&gt;
<span class="lineno">  262 </span>  (forall m. TermTranslationMonad m =&gt; m a) -&gt;
<span class="lineno">  263 </span>  Either (TranslationError Term) (a, TranslationState)
<span class="lineno">  264 </span><span class="decl"><span class="istickedoff">runTermTranslationMonad configuration mname mm globalDecls localEnv =</span>
<span class="lineno">  265 </span><span class="spaces">  </span><span class="istickedoff">runTranslationMonad <span class="nottickedoff">configuration</span></span>
<span class="lineno">  266 </span><span class="spaces">  </span><span class="istickedoff">(TranslationReader {</span>
<span class="lineno">  267 </span><span class="spaces">      </span><span class="istickedoff">_currentModule = mname</span>
<span class="lineno">  268 </span><span class="spaces">      </span><span class="istickedoff">, _namedEnvironment = Map.empty</span>
<span class="lineno">  269 </span><span class="spaces">      </span><span class="istickedoff">, _unavailableIdents  = Set.union reservedIdents (Set.fromList localEnv)</span>
<span class="lineno">  270 </span><span class="spaces">      </span><span class="istickedoff">, _sharedNames        = IntMap.empty</span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff">, _nextSharedName     = &quot;var__0&quot;</span>
<span class="lineno">  272 </span><span class="spaces">      </span><span class="istickedoff">, _sawModuleMap       = <span class="nottickedoff">mm</span></span>
<span class="lineno">  273 </span><span class="spaces">      </span><span class="istickedoff">, _useImplicitBinders = <span class="nottickedoff">True</span> })</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="istickedoff">(TranslationState { _globalDeclarations = <span class="nottickedoff">globalDecls</span></span>
<span class="lineno">  275 </span><span class="spaces">                    </span><span class="istickedoff">, _topLevelDeclarations  = []</span>
<span class="lineno">  276 </span><span class="spaces">                    </span><span class="istickedoff">})</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>-- | Return a Rocq term for an error computation with the given string message
<span class="lineno">  279 </span>errorTermM :: TermTranslationMonad m =&gt; String -&gt; m Rocq.Term
<span class="lineno">  280 </span><span class="decl"><span class="nottickedoff">errorTermM str = return $ Rocq.App (Rocq.Var &quot;error&quot;) [Rocq.StringLit str]</span></span>
<span class="lineno">  281 </span>
<span class="lineno">  282 </span>qualify :: ModuleName -&gt; Rocq.Ident -&gt; Rocq.Ident
<span class="lineno">  283 </span><span class="decl"><span class="istickedoff">qualify m (Rocq.Ident i) = Rocq.Ident (Text.unpack (moduleNameText m) ++ &quot;.&quot; ++ i)</span></span>
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- | Translate an 'Ident' with a given list of arguments to a Rocq term, using
<span class="lineno">  286 </span>-- any special treatment for that identifier and qualifying it if necessary
<span class="lineno">  287 </span>translateIdentWithArgs :: TermTranslationMonad m =&gt; Ident -&gt; [Term] -&gt; m Rocq.Term
<span class="lineno">  288 </span><span class="decl"><span class="istickedoff">translateIdentWithArgs i args = do</span>
<span class="lineno">  289 </span><span class="spaces">  </span><span class="istickedoff">currentModuleName &lt;- asks (view currentModule . otherConfiguration)</span>
<span class="lineno">  290 </span><span class="spaces">  </span><span class="istickedoff">let identToRocq ident =</span>
<span class="lineno">  291 </span><span class="spaces">        </span><span class="istickedoff">if <span class="tickonlyfalse">Just <span class="nottickedoff">(identModule ident)</span> == currentModuleName</span></span>
<span class="lineno">  292 </span><span class="spaces">          </span><span class="istickedoff">then <span class="nottickedoff">base</span> else qualify (translateModuleName (identModule ident)) base</span>
<span class="lineno">  293 </span><span class="spaces">        </span><span class="istickedoff">where</span>
<span class="lineno">  294 </span><span class="spaces">          </span><span class="istickedoff">base = escapeIdent (Rocq.Ident (identName ident))</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="istickedoff">specialTreatment &lt;- findSpecialTreatment i</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="istickedoff">applySpecialTreatment identToRocq (atUseSite specialTreatment)</span>
<span class="lineno">  297 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  298 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  299 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">applySpecialTreatment identToRocq UsePreserve =</span>
<span class="lineno">  301 </span><span class="spaces">      </span><span class="istickedoff">Rocq.App (Rocq.Var $ identToRocq i) &lt;$&gt; mapM translateTerm args</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">applySpecialTreatment _identToRocq (UseRename targetModule targetName expl) =</span>
<span class="lineno">  303 </span><span class="spaces">      </span><span class="istickedoff">Rocq.App</span>
<span class="lineno">  304 </span><span class="spaces">        </span><span class="istickedoff">((if <span class="tickonlyfalse">expl</span> then <span class="nottickedoff">Rocq.ExplVar</span> else Rocq.Var) $</span>
<span class="lineno">  305 </span><span class="spaces">          </span><span class="istickedoff">qualify (fromMaybe <span class="nottickedoff">(translateModuleName $ identModule i)</span> targetModule)</span>
<span class="lineno">  306 </span><span class="spaces">          </span><span class="istickedoff">targetName)</span>
<span class="lineno">  307 </span><span class="spaces">          </span><span class="istickedoff">&lt;$&gt; mapM translateTerm args</span>
<span class="lineno">  308 </span><span class="spaces">    </span><span class="istickedoff">applySpecialTreatment _identToRocq (UseMacro n macroFun)</span>
<span class="lineno">  309 </span><span class="spaces">      </span><span class="istickedoff">| <span class="nottickedoff">length args &gt;= n</span></span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">, (m_args, args') &lt;- <span class="nottickedoff">splitAt n args</span> =</span>
<span class="lineno">  311 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">do f &lt;- macroFun &lt;$&gt; mapM translateTerm m_args</span></span>
<span class="lineno">  312 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">Rocq.App f &lt;$&gt; mapM translateTerm args'</span></span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">applySpecialTreatment _identToRocq (UseMacro n _) =</span>
<span class="lineno">  314 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">errorTermM (unwords</span></span>
<span class="lineno">  315 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Identifier&quot;</span></span>
<span class="lineno">  316 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">, show i</span></span>
<span class="lineno">  317 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">, &quot;not applied to required number of args, which is&quot;</span></span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">, show n</span></span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  320 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">)</span></span></span>
<span class="lineno">  321 </span>
<span class="lineno">  322 </span>-- | Helper for 'translateIdentWithArgs' with no arguments
<span class="lineno">  323 </span>translateIdent :: TermTranslationMonad m =&gt; Ident -&gt; m Rocq.Term
<span class="lineno">  324 </span><span class="decl"><span class="istickedoff">translateIdent i = translateIdentWithArgs i []</span></span>
<span class="lineno">  325 </span>
<span class="lineno">  326 </span>-- | Translate a constant to a Rocq term. If the constant is named with
<span class="lineno">  327 </span>-- an 'Ident', then it already has a top-level translation from
<span class="lineno">  328 </span>-- translating the SAW core module containing that 'Ident'. If the
<span class="lineno">  329 </span>-- constant is an 'ImportedName', however, then it might not have a
<span class="lineno">  330 </span>-- Rocq definition already, so add a definition of it to the top-level
<span class="lineno">  331 </span>-- translation state.
<span class="lineno">  332 </span>translateConstant :: TermTranslationMonad m =&gt; Name -&gt; m Rocq.Term
<span class="lineno">  333 </span><span class="decl"><span class="istickedoff">translateConstant nm</span>
<span class="lineno">  334 </span><span class="spaces">  </span><span class="istickedoff">| ModuleIdentifier ident &lt;- nameInfo nm = translateIdent ident</span>
<span class="lineno">  335 </span><span class="spaces"></span><span class="istickedoff">translateConstant nm =</span>
<span class="lineno">  336 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">do -- First, apply the constant renaming to get the name for this constant</span></span>
<span class="lineno">  337 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">configuration &lt;- asks translationConfiguration</span></span>
<span class="lineno">  338 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">-- TODO short name seems wrong</span></span>
<span class="lineno">  339 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">let nm_str = Text.unpack $ toShortName $ nameInfo nm</span></span>
<span class="lineno">  340 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">let renamed =</span></span>
<span class="lineno">  341 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">escapeIdent $ Rocq.Ident $ fromMaybe nm_str $</span></span>
<span class="lineno">  342 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">lookup nm_str $ constantRenaming configuration</span></span>
<span class="lineno">  343 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  344 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">-- Next, test if we should add a definition of this constant</span></span>
<span class="lineno">  345 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">alreadyTranslatedDecls &lt;- getNamesOfAllDeclarations</span></span>
<span class="lineno">  346 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">let skip_def =</span></span>
<span class="lineno">  347 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">elem renamed alreadyTranslatedDecls ||</span></span>
<span class="lineno">  348 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">elem nm_str (constantSkips configuration)</span></span>
<span class="lineno">  349 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  350 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">-- Add the definition if we aren't skipping it</span></span>
<span class="lineno">  351 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">mm &lt;- asks (view sawModuleMap . otherConfiguration)</span></span>
<span class="lineno">  352 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">let resolved = requireNameInMap nm mm</span></span>
<span class="lineno">  353 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">let maybe_body =</span></span>
<span class="lineno">  354 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">case resolved of</span></span>
<span class="lineno">  355 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">ResolvedDef d -&gt; defBody d</span></span>
<span class="lineno">  356 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; Nothing</span></span>
<span class="lineno">  357 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">case maybe_body of</span></span>
<span class="lineno">  358 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">_ | skip_def -&gt; return ()</span></span>
<span class="lineno">  359 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">Just body -&gt;</span></span>
<span class="lineno">  360 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">-- If the definition has a body, add it as a definition</span></span>
<span class="lineno">  361 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">do b &lt;- withTopTranslationState $ translateTermLet body</span></span>
<span class="lineno">  362 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">tp &lt;- withTopTranslationState $ translateTermLet (resolvedNameType resolved)</span></span>
<span class="lineno">  363 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">modify $ over topLevelDeclarations $ (mkDefinition renamed b tp :)</span></span>
<span class="lineno">  364 </span><span class="spaces">       </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno">  365 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">-- If not, add it as a Rocq Variable declaration</span></span>
<span class="lineno">  366 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">do tp &lt;- withTopTranslationState $ translateTermLet (resolvedNameType resolved)</span></span>
<span class="lineno">  367 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">modify (over topLevelDeclarations (Rocq.Variable renamed tp :))</span></span>
<span class="lineno">  368 </span><span class="spaces"></span><span class="istickedoff"><span class="nottickedoff"></span></span>
<span class="lineno">  369 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">-- Finally, return the constant as a Rocq variable</span></span>
<span class="lineno">  370 </span><span class="spaces">     </span><span class="istickedoff"><span class="nottickedoff">pure (Rocq.Var renamed)</span></span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | Translate an 'Ident' and see if the result maps to a special 'Rocq.Ident',
<span class="lineno">  374 </span>-- returning the latter 'Rocq.Ident' if so
<span class="lineno">  375 </span>translateIdentToIdent :: TermTranslationMonad m =&gt; Ident -&gt; m (Maybe Rocq.Ident)
<span class="lineno">  376 </span><span class="decl"><span class="nottickedoff">translateIdentToIdent i =</span>
<span class="lineno">  377 </span><span class="spaces">  </span><span class="nottickedoff">(atUseSite &lt;$&gt; findSpecialTreatment i) &gt;&gt;= \case</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="nottickedoff">UsePreserve -&gt; return $ Just (qualify translatedModuleName (Rocq.Ident (Text.unpack (identBaseName i))))</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="nottickedoff">UseRename   targetModule targetName _ -&gt;</span>
<span class="lineno">  380 </span><span class="spaces">      </span><span class="nottickedoff">return $ Just $ qualify (fromMaybe translatedModuleName targetModule) targetName</span>
<span class="lineno">  381 </span><span class="spaces">    </span><span class="nottickedoff">UseMacro _ _ -&gt; return Nothing</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  383 </span><span class="spaces">    </span><span class="nottickedoff">translatedModuleName = translateModuleName (identModule i)</span></span>
<span class="lineno">  384 </span>
<span class="lineno">  385 </span>translateSort :: Sort -&gt; Rocq.Sort
<span class="lineno">  386 </span><span class="decl"><span class="nottickedoff">translateSort s = if s == propSort then Rocq.Prop else Rocq.Type</span></span>
<span class="lineno">  387 </span>
<span class="lineno">  388 </span>flatTermFToExpr ::
<span class="lineno">  389 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  390 </span>  FlatTermF Term -&gt;
<span class="lineno">  391 </span>  m Rocq.Term
<span class="lineno">  392 </span><span class="decl"><span class="nottickedoff">flatTermFToExpr tf = -- traceFTermF &quot;flatTermFToExpr&quot; tf $</span>
<span class="lineno">  393 </span><span class="spaces">  </span><span class="nottickedoff">case tf of</span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="nottickedoff">UnitValue     -&gt; pure (Rocq.Var &quot;tt&quot;)</span>
<span class="lineno">  395 </span><span class="spaces">    </span><span class="nottickedoff">UnitType      -&gt;</span>
<span class="lineno">  396 </span><span class="spaces">      </span><span class="nottickedoff">-- We need to explicitly tell Rocq that we want unit to be a Type, since</span>
<span class="lineno">  397 </span><span class="spaces">      </span><span class="nottickedoff">-- all SAW core sorts are translated to Types</span>
<span class="lineno">  398 </span><span class="spaces">      </span><span class="nottickedoff">pure (Rocq.Ascription (Rocq.Var &quot;unit&quot;) (Rocq.Sort Rocq.Type))</span>
<span class="lineno">  399 </span><span class="spaces">    </span><span class="nottickedoff">PairValue x y -&gt; Rocq.App (Rocq.Var &quot;pair&quot;) &lt;$&gt; traverse translateTerm [x, y]</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="nottickedoff">PairType x y  -&gt; Rocq.App (Rocq.Var &quot;prod&quot;) &lt;$&gt; traverse translateTerm [x, y]</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="nottickedoff">PairLeft t    -&gt;</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="nottickedoff">Rocq.App &lt;$&gt; pure (Rocq.Var &quot;fst&quot;) &lt;*&gt; traverse translateTerm [t]</span>
<span class="lineno">  403 </span><span class="spaces">    </span><span class="nottickedoff">PairRight t   -&gt;</span>
<span class="lineno">  404 </span><span class="spaces">      </span><span class="nottickedoff">Rocq.App &lt;$&gt; pure (Rocq.Var &quot;snd&quot;) &lt;*&gt; traverse translateTerm [t]</span>
<span class="lineno">  405 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="nottickedoff">Recursor crec -&gt;</span>
<span class="lineno">  407 </span><span class="spaces">      </span><span class="nottickedoff">do let d = recursorDataType crec</span>
<span class="lineno">  408 </span><span class="spaces">         </span><span class="nottickedoff">maybe_d_trans &lt;-</span>
<span class="lineno">  409 </span><span class="spaces">           </span><span class="nottickedoff">case nameInfo d of</span>
<span class="lineno">  410 </span><span class="spaces">             </span><span class="nottickedoff">ModuleIdentifier ident -&gt; translateIdentToIdent ident</span>
<span class="lineno">  411 </span><span class="spaces">             </span><span class="nottickedoff">ImportedName{} -&gt; pure Nothing</span>
<span class="lineno">  412 </span><span class="spaces">         </span><span class="nottickedoff">case maybe_d_trans of</span>
<span class="lineno">  413 </span><span class="spaces">           </span><span class="nottickedoff">Just (Rocq.Ident i) -&gt; return $ Rocq.ExplVar (Rocq.Ident (i ++ &quot;_rect&quot;))</span>
<span class="lineno">  414 </span><span class="spaces">           </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno">  415 </span><span class="spaces">             </span><span class="nottickedoff">errorTermM (&quot;Recursor for &quot; ++ show d ++</span>
<span class="lineno">  416 </span><span class="spaces">                         </span><span class="nottickedoff">&quot; cannot be translated because the datatype &quot; ++</span>
<span class="lineno">  417 </span><span class="spaces">                         </span><span class="nottickedoff">&quot;is mapped to an arbitrary Rocq term&quot;)</span>
<span class="lineno">  418 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  419 </span><span class="spaces">    </span><span class="nottickedoff">Sort s _h -&gt; pure (Rocq.Sort (translateSort s))</span>
<span class="lineno">  420 </span><span class="spaces">    </span><span class="nottickedoff">ArrayValue (asBoolType -&gt; Just ()) (traverse asBool -&gt; Just bits)</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="nottickedoff">| Pair w bv &lt;- BV.bitsBE (Vector.toList bits)</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) w -&gt; do</span>
<span class="lineno">  423 </span><span class="spaces">          </span><span class="nottickedoff">return (Rocq.App (Rocq.Var &quot;intToBv&quot;)</span>
<span class="lineno">  424 </span><span class="spaces">                  </span><span class="nottickedoff">[Rocq.NatLit (intValue w), Rocq.ZLit (BV.asSigned w bv)])</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="nottickedoff">ArrayValue _ vec -&gt; do</span>
<span class="lineno">  426 </span><span class="spaces">      </span><span class="nottickedoff">elems &lt;- Vector.toList &lt;$&gt; mapM translateTerm vec</span>
<span class="lineno">  427 </span><span class="spaces">      </span><span class="nottickedoff">-- NOTE: with VectorNotations, this is actually a Rocq vector literal</span>
<span class="lineno">  428 </span><span class="spaces">      </span><span class="nottickedoff">return $ Rocq.List elems</span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="nottickedoff">StringLit s -&gt; pure (Rocq.Scope (Rocq.StringLit (Text.unpack s)) &quot;string&quot;)</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>-- | Recognizes an @App (App &quot;Cryptol.seq&quot; n) x@ and returns @(n, x)@.
<span class="lineno">  433 </span>asSeq :: Recognizer Term (Term, Term)
<span class="lineno">  434 </span><span class="decl"><span class="nottickedoff">asSeq t = do (f, args) &lt;- asApplyAllRecognizer t</span>
<span class="lineno">  435 </span><span class="spaces">             </span><span class="nottickedoff">fid &lt;- asGlobalDef f</span>
<span class="lineno">  436 </span><span class="spaces">             </span><span class="nottickedoff">case (fid, args) of</span>
<span class="lineno">  437 </span><span class="spaces">               </span><span class="nottickedoff">(&quot;Cryptol.seq&quot;, [n, x]) -&gt; return (n,x)</span>
<span class="lineno">  438 </span><span class="spaces">               </span><span class="nottickedoff">_ -&gt; Fail.fail &quot;not a seq&quot;</span></span>
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>asApplyAllRecognizer :: Recognizer Term (Term, [Term])
<span class="lineno">  441 </span><span class="decl"><span class="nottickedoff">asApplyAllRecognizer t = do _ &lt;- asApp t</span>
<span class="lineno">  442 </span><span class="spaces">                            </span><span class="nottickedoff">return $ asApplyAll t</span></span>
<span class="lineno">  443 </span>
<span class="lineno">  444 </span>-- | Run a translation in the top-level translation state with no free SAW
<span class="lineno">  445 </span>-- variables and no bound Rocq identifiers
<span class="lineno">  446 </span>withTopTranslationState :: TermTranslationMonad m =&gt; m a -&gt; m a
<span class="lineno">  447 </span><span class="decl"><span class="nottickedoff">withTopTranslationState m =</span>
<span class="lineno">  448 </span><span class="spaces">  </span><span class="nottickedoff">localTR (\r -&gt;</span>
<span class="lineno">  449 </span><span class="spaces">            </span><span class="nottickedoff">TranslationReader {</span>
<span class="lineno">  450 </span><span class="spaces">              </span><span class="nottickedoff">_currentModule      = view currentModule r,</span>
<span class="lineno">  451 </span><span class="spaces">              </span><span class="nottickedoff">_namedEnvironment   = Map.empty,</span>
<span class="lineno">  452 </span><span class="spaces">              </span><span class="nottickedoff">_unavailableIdents  = reservedIdents,</span>
<span class="lineno">  453 </span><span class="spaces">              </span><span class="nottickedoff">_sharedNames        = IntMap.empty,</span>
<span class="lineno">  454 </span><span class="spaces">              </span><span class="nottickedoff">_nextSharedName     = &quot;var__0&quot; ,</span>
<span class="lineno">  455 </span><span class="spaces">              </span><span class="nottickedoff">_sawModuleMap       = view sawModuleMap r,</span>
<span class="lineno">  456 </span><span class="spaces">              </span><span class="nottickedoff">_useImplicitBinders = True }) m</span></span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>-- | Generate a Rocq @Definition@ with a given name, body, and type, using the
<span class="lineno">  459 </span>-- lambda-bound variable names for the variables if they are available
<span class="lineno">  460 </span>mkDefinition :: Rocq.Ident -&gt; Rocq.Term -&gt; Rocq.Term -&gt; Rocq.Decl
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">mkDefinition name (Rocq.Lambda bs t) (Rocq.Pi bs' tp)</span>
<span class="lineno">  462 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">length bs' == length bs</span> =</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">-- NOTE: there are a number of cases where length bs /= length bs', such as</span>
<span class="lineno">  464 </span><span class="spaces">    </span><span class="istickedoff">-- where the type of a definition is computed from some input (so might not</span>
<span class="lineno">  465 </span><span class="spaces">    </span><span class="istickedoff">-- have any explicit pi-abstractions), or where the body of a definition is</span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">-- a partially applied function (so might not have any lambdas). We could in</span>
<span class="lineno">  467 </span><span class="spaces">    </span><span class="istickedoff">-- theory try to handle these more complex cases by assigning names to some</span>
<span class="lineno">  468 </span><span class="spaces">    </span><span class="istickedoff">-- of the arguments, but it's not really necessary for the translation to be</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">-- correct, so we just do the simple thing here.</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">Rocq.Definition name (zipWith combineBinders bs bs') (Just tp) t</span>
<span class="lineno">  471 </span><span class="spaces"></span><span class="istickedoff">mkDefinition name t tp = <span class="nottickedoff">Rocq.Definition name [] (Just tp) t</span></span></span>
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>-- | Combine a term-level Binder with a type-level PiBinder, taking the name
<span class="lineno">  474 </span>-- and type from the Binder but the implicit/explicit status from the PiBinder.
<span class="lineno">  475 </span>combineBinders :: Rocq.Binder -&gt; Rocq.PiBinder -&gt; Rocq.Binder
<span class="lineno">  476 </span><span class="decl"><span class="istickedoff">combineBinders (Rocq.Binder _ n mty) (Rocq.PiBinder impl _ _) = Rocq.Binder impl n mty</span></span>
<span class="lineno">  477 </span>
<span class="lineno">  478 </span>mkLet :: (Rocq.Ident, Rocq.Term) -&gt; Rocq.Term -&gt; Rocq.Term
<span class="lineno">  479 </span><span class="decl"><span class="istickedoff">mkLet (name, rhs) body = Rocq.Let name [] Nothing rhs body</span></span>
<span class="lineno">  480 </span>
<span class="lineno">  481 </span>implicit :: Bool -&gt; Rocq.BinderImplicity
<span class="lineno">  482 </span><span class="decl"><span class="nottickedoff">implicit useImplicits = if useImplicits then Rocq.Implicit else Rocq.Explicit</span></span>
<span class="lineno">  483 </span>
<span class="lineno">  484 </span>-- | The result of translating a SAW core variable binding to Rocq, including the
<span class="lineno">  485 </span>-- Rocq identifier for the variable, the Rocq translation of its type, and 0 or
<span class="lineno">  486 </span>-- more implicit Rocq arguments that apply to the variable
<span class="lineno">  487 </span>data BindTrans = BindTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindTransIdent</span></span></span> :: Rocq.Ident,
<span class="lineno">  488 </span>                             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindTransType</span></span></span> :: Rocq.Type,
<span class="lineno">  489 </span>                             <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindTransImps</span></span></span> :: [(Rocq.Ident,Rocq.Type)] }
<span class="lineno">  490 </span>
<span class="lineno">  491 </span>-- | Convert a 'BindTrans' to a list of Rocq term-level binders
<span class="lineno">  492 </span>bindTransToBinder :: Bool -&gt; BindTrans -&gt; [Rocq.Binder]
<span class="lineno">  493 </span><span class="decl"><span class="istickedoff">bindTransToBinder useImplicits (BindTrans {..}) =</span>
<span class="lineno">  494 </span><span class="spaces">  </span><span class="istickedoff">Rocq.Binder <span class="nottickedoff">Rocq.Explicit</span> bindTransIdent (Just bindTransType) :</span>
<span class="lineno">  495 </span><span class="spaces">  </span><span class="istickedoff">map <span class="nottickedoff">(\(n,ty) -&gt; Rocq.Binder (implicit useImplicits) n (Just ty))</span> bindTransImps</span></span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>-- | Convert a 'BindTrans' to a list of Rocq type-level pi-abstraction binders.
<span class="lineno">  498 </span>bindTransToPiBinder :: Bool -&gt; BindTrans -&gt; [Rocq.PiBinder]
<span class="lineno">  499 </span><span class="decl"><span class="istickedoff">bindTransToPiBinder useImplicits (BindTrans { .. }) =</span>
<span class="lineno">  500 </span><span class="spaces">  </span><span class="istickedoff">case bindTransImps of</span>
<span class="lineno">  501 </span><span class="spaces">    </span><span class="istickedoff">[] | <span class="tickonlyfalse">bindTransIdent == &quot;_&quot;</span> -&gt; <span class="nottickedoff">[Rocq.PiBinder Rocq.Explicit Nothing bindTransType]</span></span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; [Rocq.PiBinder Rocq.Explicit <span class="nottickedoff">(Just bindTransIdent)</span> <span class="nottickedoff">bindTransType</span>]</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt;</span>
<span class="lineno">  504 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">Rocq.PiBinder Rocq.Explicit (Just bindTransIdent) bindTransType :</span></span>
<span class="lineno">  505 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">map (\(n,ty) -&gt; Rocq.PiBinder (implicit useImplicits) (Just n) ty) bindTransImps</span></span></span>
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>-- | Given a 'VarName' and its type (as a 'Term'), translate the 'VarName'
<span class="lineno">  508 </span>-- to a Rocq identifier, translate the type to a Rocq term, and generate zero or
<span class="lineno">  509 </span>-- more additional 'Ident's and 'Type's representing additonal implicit
<span class="lineno">  510 </span>-- typeclass arguments, added if the given type is @isort@, etc. Pass all of
<span class="lineno">  511 </span>-- this information to the supplied computation, in which the SAW core variable
<span class="lineno">  512 </span>-- is bound to its Rocq identifier.
<span class="lineno">  513 </span>translateBinder :: TermTranslationMonad m =&gt; VarName -&gt; Term -&gt;
<span class="lineno">  514 </span>                   (BindTrans -&gt; m a) -&gt; m a
<span class="lineno">  515 </span><span class="decl"><span class="istickedoff">translateBinder vn ty@(asPiList -&gt; (args, pi_body)) f =</span>
<span class="lineno">  516 </span><span class="spaces">  </span><span class="istickedoff">do ty' &lt;- translateTerm ty</span>
<span class="lineno">  517 </span><span class="spaces">     </span><span class="istickedoff">let mb_sort = asSortWithFlags pi_body</span>
<span class="lineno">  518 </span><span class="spaces">         </span><span class="istickedoff">flagValues = sortFlagsToList $ maybe noFlags <span class="nottickedoff">snd</span> mb_sort</span>
<span class="lineno">  519 </span><span class="spaces">         </span><span class="istickedoff">flagLocalNames = [<span class="nottickedoff">(&quot;Inh&quot;, &quot;SAWCoreScaffolding.Inhabited&quot;)</span>,</span>
<span class="lineno">  520 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">(&quot;QT&quot;, &quot;QuantType&quot;)</span>]</span>
<span class="lineno">  521 </span><span class="spaces">     </span><span class="istickedoff">withSAWVar vn $ \n' -&gt;</span>
<span class="lineno">  522 </span><span class="spaces">       </span><span class="istickedoff">helper <span class="nottickedoff">n'</span> (zip flagValues flagLocalNames) (\imps -&gt;</span>
<span class="lineno">  523 </span><span class="spaces">                                                   </span><span class="istickedoff">f $ BindTrans n' ty' imps)</span>
<span class="lineno">  524 </span><span class="spaces">       </span><span class="istickedoff">where</span>
<span class="lineno">  525 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">n = vnName vn</span></span>
<span class="lineno">  526 </span><span class="spaces">         </span><span class="istickedoff">helper _ [] g = g []</span>
<span class="lineno">  527 </span><span class="spaces">         </span><span class="istickedoff">helper n' ((True,(prefix,tc)):rest) g =</span>
<span class="lineno">  528 </span><span class="spaces">           </span><span class="istickedoff"><span class="nottickedoff">do nhty &lt;- translateImplicitHyp (Rocq.Var tc) args (Rocq.Var n')</span></span>
<span class="lineno">  529 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">withFreshIdent (prefix &lt;&gt; &quot;_&quot; &lt;&gt; n) $ \nh -&gt;</span></span>
<span class="lineno">  530 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">helper n' rest (g . ((nh,nhty) :))</span></span>
<span class="lineno">  531 </span><span class="spaces">         </span><span class="istickedoff">helper n' ((False,_):rest) g = helper <span class="nottickedoff">n'</span> rest g</span></span>
<span class="lineno">  532 </span>
<span class="lineno">  533 </span>-- | Call 'translateBinder' on a list of SAW core bindings
<span class="lineno">  534 </span>translateBinders :: TermTranslationMonad m =&gt; [(VarName,Term)] -&gt;
<span class="lineno">  535 </span>                    ([BindTrans] -&gt; m a) -&gt; m a
<span class="lineno">  536 </span><span class="decl"><span class="istickedoff">translateBinders [] f = f []</span>
<span class="lineno">  537 </span><span class="spaces"></span><span class="istickedoff">translateBinders ((n,ty):ns_tys) f =</span>
<span class="lineno">  538 </span><span class="spaces">  </span><span class="istickedoff">translateBinder n ty $ \bnd -&gt;</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="istickedoff">translateBinders ns_tys $ \bnds -&gt; f (bnd : bnds)</span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>-- | Given a typeclass (as a Rocq term), a list of 'LocalName's and their
<span class="lineno">  542 </span>-- corresponding types (as 'Term's), and a type-level function with argument
<span class="lineno">  543 </span>-- types given by the prior list, return a 'Pi' of the given arguments, inside
<span class="lineno">  544 </span>-- of which is an 'App' of the typeclass to the fully-applied type-level
<span class="lineno">  545 </span>-- function
<span class="lineno">  546 </span>translateImplicitHyp ::
<span class="lineno">  547 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  548 </span>  Rocq.Term -&gt; [(VarName, Term)] -&gt; Rocq.Term -&gt; m Rocq.Term
<span class="lineno">  549 </span><span class="decl"><span class="nottickedoff">translateImplicitHyp tc [] tm = return (Rocq.App tc [tm])</span>
<span class="lineno">  550 </span><span class="spaces"></span><span class="nottickedoff">translateImplicitHyp tc args tm = do</span>
<span class="lineno">  551 </span><span class="spaces">  </span><span class="nottickedoff">useImplicits &lt;- view useImplicitBinders &lt;$&gt; askTR</span>
<span class="lineno">  552 </span><span class="spaces">  </span><span class="nottickedoff">translateBinders args $ \args' -&gt;</span>
<span class="lineno">  553 </span><span class="spaces">    </span><span class="nottickedoff">return $ Rocq.Pi (concatMap (mkPi useImplicits) args') (Rocq.App tc [Rocq.App tm (map mkArg args')])</span>
<span class="lineno">  554 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  555 </span><span class="spaces">    </span><span class="nottickedoff">mkPi useImplicits (BindTrans nm ty nhs) =</span>
<span class="lineno">  556 </span><span class="spaces">      </span><span class="nottickedoff">Rocq.PiBinder Rocq.Explicit (Just nm) ty :</span>
<span class="lineno">  557 </span><span class="spaces">      </span><span class="nottickedoff">map (\(nh,nhty) -&gt; Rocq.PiBinder (implicit useImplicits) (Just nh) nhty) nhs</span>
<span class="lineno">  558 </span><span class="spaces">    </span><span class="nottickedoff">mkArg b = Rocq.Var $ bindTransIdent b</span></span>
<span class="lineno">  559 </span>
<span class="lineno">  560 </span>-- | Given a list of 'LocalName's and their corresponding types (as 'Term's),
<span class="lineno">  561 </span>-- return a list of 'Binder's, for use representing the bound variables
<span class="lineno">  562 </span>-- in 'Lambda's, 'Let's, etc.
<span class="lineno">  563 </span>translateParams :: TermTranslationMonad m =&gt; [(VarName, Term)] -&gt;
<span class="lineno">  564 </span>                   ([Rocq.Binder] -&gt; m a) -&gt; m a
<span class="lineno">  565 </span><span class="decl"><span class="istickedoff">translateParams bs m = do</span>
<span class="lineno">  566 </span><span class="spaces">  </span><span class="istickedoff">useImplicits &lt;- <span class="nottickedoff">view useImplicitBinders</span> &lt;$&gt; askTR</span>
<span class="lineno">  567 </span><span class="spaces">  </span><span class="istickedoff">translateBinders bs (m . concat . map (bindTransToBinder <span class="nottickedoff">useImplicits</span>))</span></span>
<span class="lineno">  568 </span>
<span class="lineno">  569 </span>-- | Given a list of 'VarName's and their corresponding types (as 'Term's)
<span class="lineno">  570 </span>-- representing argument types and a 'Term' representing the return type,
<span class="lineno">  571 </span>-- return the resulting 'Pi', with additional implicit arguments added after
<span class="lineno">  572 </span>-- each instance of @isort@, @qsort@, etc.
<span class="lineno">  573 </span>translatePi :: TermTranslationMonad m =&gt; [(VarName, Term)] -&gt; Term -&gt; m Rocq.Term
<span class="lineno">  574 </span><span class="decl"><span class="istickedoff">translatePi binders body =</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">translatePiBinders binders $ \bindersT -&gt;</span>
<span class="lineno">  576 </span><span class="spaces">  </span><span class="istickedoff">do bodyT &lt;- translateTermLet body</span>
<span class="lineno">  577 </span><span class="spaces">     </span><span class="istickedoff">return $ Rocq.Pi bindersT bodyT</span></span>
<span class="lineno">  578 </span>
<span class="lineno">  579 </span>-- | Given a 'LocalName' and its type (as a 'Term'), return an explicit
<span class="lineno">  580 </span>-- 'PiBinder' followed by zero or more implicit 'PiBinder's representing
<span class="lineno">  581 </span>-- additonal implicit typeclass arguments, added if the given type is @isort@,
<span class="lineno">  582 </span>-- @qsort@, etc.
<span class="lineno">  583 </span>translatePiBinders :: TermTranslationMonad m =&gt; [(VarName, Term)] -&gt;
<span class="lineno">  584 </span>                      ([Rocq.PiBinder] -&gt; m a) -&gt; m a
<span class="lineno">  585 </span><span class="decl"><span class="istickedoff">translatePiBinders bs m = do</span>
<span class="lineno">  586 </span><span class="spaces">  </span><span class="istickedoff">useImplicits &lt;- <span class="nottickedoff">view useImplicitBinders</span> &lt;$&gt; askTR</span>
<span class="lineno">  587 </span><span class="spaces">  </span><span class="istickedoff">translateBinders bs (m . concat . map (bindTransToPiBinder <span class="nottickedoff">useImplicits</span>))</span></span>
<span class="lineno">  588 </span>
<span class="lineno">  589 </span>-- | Find all subterms of a SAW core term that should be shared, and generate
<span class="lineno">  590 </span>-- let-bindings in Rocq to bind them to local variables. Translate SAW core term
<span class="lineno">  591 </span>-- using those let-bindings for the shared subterms.
<span class="lineno">  592 </span>translateTermLet :: TermTranslationMonad m =&gt; Term -&gt; m Rocq.Term
<span class="lineno">  593 </span><span class="decl"><span class="istickedoff">translateTermLet t =</span>
<span class="lineno">  594 </span><span class="spaces">  </span><span class="istickedoff">let occ_map = scTermCount False t</span>
<span class="lineno">  595 </span><span class="spaces">      </span><span class="istickedoff">shares = IntMap.assocs $ fmap fst $ IntMap.filter keep occ_map</span>
<span class="lineno">  596 </span><span class="spaces">      </span><span class="istickedoff">share_tms = map snd shares in</span>
<span class="lineno">  597 </span><span class="spaces">  </span><span class="istickedoff">-- NOTE: larger terms always have later stAppIndices than their subterms, so</span>
<span class="lineno">  598 </span><span class="spaces">  </span><span class="istickedoff">-- IntMap.assocs above is guaranteed to return subterms before superterms;</span>
<span class="lineno">  599 </span><span class="spaces">  </span><span class="istickedoff">-- this ensures that the right-hand sides in our nested let-bindings below</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="istickedoff">-- only refer to variables bound earlier, not later</span>
<span class="lineno">  601 </span><span class="spaces">  </span><span class="istickedoff">withSharedTerms shares $ \names -&gt;</span>
<span class="lineno">  602 </span><span class="spaces">  </span><span class="istickedoff">do defs &lt;- traverse translateTermUnshared share_tms</span>
<span class="lineno">  603 </span><span class="spaces">     </span><span class="istickedoff">body &lt;- translateTerm t</span>
<span class="lineno">  604 </span><span class="spaces">     </span><span class="istickedoff">pure (foldr mkLet body $ zip names defs)</span>
<span class="lineno">  605 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="istickedoff">keep (t', n) = n &gt; 1 &amp;&amp; shouldMemoizeTerm t'</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>-- | Translate a SAW core 'Term' to Rocq, using let-bound Rocq names when they are
<span class="lineno">  609 </span>-- associated with the given term for sharing
<span class="lineno">  610 </span>translateTerm :: TermTranslationMonad m =&gt; Term -&gt; m Rocq.Term
<span class="lineno">  611 </span><span class="decl"><span class="istickedoff">translateTerm t =</span>
<span class="lineno">  612 </span><span class="spaces">  </span><span class="istickedoff">case t of</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="istickedoff">STApp { stAppIndex = i } -&gt;</span>
<span class="lineno">  614 </span><span class="spaces">      </span><span class="istickedoff">do shared &lt;- view sharedNames &lt;$&gt; askTR</span>
<span class="lineno">  615 </span><span class="spaces">         </span><span class="istickedoff">case IntMap.lookup i shared of</span>
<span class="lineno">  616 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; translateTermUnshared t</span>
<span class="lineno">  617 </span><span class="spaces">           </span><span class="istickedoff">Just sh -&gt; pure (Rocq.Var $ sharedNameIdent sh)</span></span>
<span class="lineno">  618 </span>
<span class="lineno">  619 </span>-- | Translate a SAW core 'Term' to Rocq without using sharing
<span class="lineno">  620 </span>translateTermUnshared :: TermTranslationMonad m =&gt; Term -&gt; m Rocq.Term
<span class="lineno">  621 </span><span class="decl"><span class="istickedoff">translateTermUnshared t =</span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="istickedoff">-- traceTerm &quot;translateTerm&quot; t $</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">case unwrapTermF t of</span>
<span class="lineno">  624 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  625 </span><span class="spaces">    </span><span class="istickedoff">FTermF ftf -&gt; <span class="nottickedoff">flatTermFToExpr ftf</span></span>
<span class="lineno">  626 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="istickedoff">Pi {} -&gt;</span>
<span class="lineno">  628 </span><span class="spaces">      </span><span class="istickedoff">let (params, e) = asPiList t in</span>
<span class="lineno">  629 </span><span class="spaces">      </span><span class="istickedoff">translatePi params e</span>
<span class="lineno">  630 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="istickedoff">Lambda {} -&gt;</span>
<span class="lineno">  632 </span><span class="spaces">      </span><span class="istickedoff">let (params, e) = asLambdaList t in</span>
<span class="lineno">  633 </span><span class="spaces">      </span><span class="istickedoff">localTR (set useImplicitBinders <span class="nottickedoff">False</span>) $</span>
<span class="lineno">  634 </span><span class="spaces">        </span><span class="istickedoff">translateParams params $ \paramTerms -&gt;</span>
<span class="lineno">  635 </span><span class="spaces">        </span><span class="istickedoff">do e' &lt;- translateTermLet e</span>
<span class="lineno">  636 </span><span class="spaces">           </span><span class="istickedoff">return (Rocq.Lambda paramTerms e')</span>
<span class="lineno">  637 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  638 </span><span class="spaces">    </span><span class="istickedoff">App {} -&gt;</span>
<span class="lineno">  639 </span><span class="spaces">      </span><span class="istickedoff">-- asApplyAll: innermost argument first</span>
<span class="lineno">  640 </span><span class="spaces">      </span><span class="istickedoff">let (f, args) = asApplyAll t</span>
<span class="lineno">  641 </span><span class="spaces">      </span><span class="istickedoff">in</span>
<span class="lineno">  642 </span><span class="spaces">      </span><span class="istickedoff">case f of</span>
<span class="lineno">  643 </span><span class="spaces">      </span><span class="istickedoff">(asGlobalDef -&gt; Just i) -&gt;</span>
<span class="lineno">  644 </span><span class="spaces">        </span><span class="istickedoff">case i of</span>
<span class="lineno">  645 </span><span class="spaces">        </span><span class="istickedoff">&quot;Prelude.natToInt&quot; -&gt;</span>
<span class="lineno">  646 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case args of</span></span>
<span class="lineno">  647 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[n] -&gt; translateTerm n &gt;&gt;= \case</span></span>
<span class="lineno">  648 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Rocq.NatLit n' -&gt; pure $ Rocq.ZLit n'</span></span>
<span class="lineno">  649 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; translateIdentWithArgs &quot;Prelude.natToInt&quot; [n]</span></span>
<span class="lineno">  650 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; badTerm</span></span>
<span class="lineno">  651 </span><span class="spaces">        </span><span class="istickedoff">&quot;Prelude.intNeg&quot; -&gt;</span>
<span class="lineno">  652 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case args of</span></span>
<span class="lineno">  653 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[z] -&gt; translateTerm z &gt;&gt;= \case</span></span>
<span class="lineno">  654 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">Rocq.ZLit z' -&gt; pure $ Rocq.ZLit (-z')</span></span>
<span class="lineno">  655 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; translateIdentWithArgs &quot;Prelude.intNeg&quot; [z]</span></span>
<span class="lineno">  656 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; badTerm</span></span>
<span class="lineno">  657 </span><span class="spaces">        </span><span class="istickedoff">&quot;Prelude.ite&quot; -&gt;</span>
<span class="lineno">  658 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">case args of</span></span>
<span class="lineno">  659 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">-- `rest` can be non-empty in examples like:</span></span>
<span class="lineno">  660 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">-- (if b then f else g) arg1 arg2</span></span>
<span class="lineno">  661 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ty : c : tt : ft : rest -&gt; do</span></span>
<span class="lineno">  662 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">ite &lt;- Rocq.If &lt;$&gt; translateTerm c &lt;*&gt; translateTerm tt &lt;*&gt; translateTerm ft</span></span>
<span class="lineno">  663 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">case rest of</span></span>
<span class="lineno">  664 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">[] -&gt; return ite</span></span>
<span class="lineno">  665 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">_  -&gt; Rocq.App ite &lt;$&gt; mapM translateTerm rest</span></span>
<span class="lineno">  666 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">_ -&gt; badTerm</span></span>
<span class="lineno">  667 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  668 </span><span class="spaces">        </span><span class="istickedoff">-- Refuse to translate any recursive value defined using Prelude.fix</span>
<span class="lineno">  669 </span><span class="spaces">        </span><span class="istickedoff">&quot;Prelude.fix&quot; -&gt; <span class="nottickedoff">badTerm</span></span>
<span class="lineno">  670 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  671 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; translateIdentWithArgs i args</span>
<span class="lineno">  672 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Rocq.App &lt;$&gt; translateTerm f &lt;*&gt; traverse translateTerm args</span></span>
<span class="lineno">  673 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">-- Constants</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">Constant n -&gt; translateConstant n</span>
<span class="lineno">  676 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="istickedoff">Variable nm _tp -&gt;</span>
<span class="lineno">  678 </span><span class="spaces">      </span><span class="istickedoff">do nenv &lt;- view namedEnvironment &lt;$&gt; askTR</span>
<span class="lineno">  679 </span><span class="spaces">         </span><span class="istickedoff">case Map.lookup nm nenv of</span>
<span class="lineno">  680 </span><span class="spaces">           </span><span class="istickedoff">Just ident -&gt; pure (Rocq.Var ident)</span>
<span class="lineno">  681 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  682 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">do let nm_str = Text.unpack $ vnName nm</span></span>
<span class="lineno">  683 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">let ident = escapeIdent $ Rocq.Ident $ nm_str</span></span>
<span class="lineno">  684 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">pure (Rocq.Var ident)</span></span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  686 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">badTerm          = Except.throwError $ BadTerm t</span></span></span>
<span class="lineno">  688 </span>
<span class="lineno">  689 </span>-- | In order to turn fixpoint computations into iterative computations, we need
<span class="lineno">  690 </span>-- to be able to create \&quot;dummy\&quot; values at the type of the computation.
<span class="lineno">  691 </span>defaultTermForType ::
<span class="lineno">  692 </span>  TermTranslationMonad m =&gt;
<span class="lineno">  693 </span>  Term -&gt; m Rocq.Term
<span class="lineno">  694 </span><span class="decl"><span class="nottickedoff">defaultTermForType typ = do</span>
<span class="lineno">  695 </span><span class="spaces">  </span><span class="nottickedoff">case typ of</span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="nottickedoff">(asBoolType -&gt; Just ()) -&gt; translateIdent (mkIdent preludeName &quot;False&quot;)</span>
<span class="lineno">  697 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="nottickedoff">(isGlobalDef &quot;Prelude.Nat&quot; -&gt; Just ()) -&gt; return $ Rocq.NatLit 0</span>
<span class="lineno">  699 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  700 </span><span class="spaces">    </span><span class="nottickedoff">(asIntegerType -&gt; Just ()) -&gt; return $ Rocq.ZLit 0</span>
<span class="lineno">  701 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  702 </span><span class="spaces">    </span><span class="nottickedoff">(asSeq -&gt; Just (n, typ')) -&gt; do</span>
<span class="lineno">  703 </span><span class="spaces">      </span><span class="nottickedoff">seqConst &lt;- translateIdent (mkIdent (mkModuleName [&quot;Cryptol&quot;]) &quot;seqConst&quot;)</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="nottickedoff">nT       &lt;- translateTerm n</span>
<span class="lineno">  705 </span><span class="spaces">      </span><span class="nottickedoff">typ'T    &lt;- translateTerm typ'</span>
<span class="lineno">  706 </span><span class="spaces">      </span><span class="nottickedoff">defaultT &lt;- defaultTermForType typ'</span>
<span class="lineno">  707 </span><span class="spaces">      </span><span class="nottickedoff">return $ Rocq.App seqConst [ nT, typ'T, defaultT ]</span>
<span class="lineno">  708 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  709 </span><span class="spaces">    </span><span class="nottickedoff">(asPairType -&gt; Just (x,y)) -&gt; do</span>
<span class="lineno">  710 </span><span class="spaces">      </span><span class="nottickedoff">x' &lt;- defaultTermForType x</span>
<span class="lineno">  711 </span><span class="spaces">      </span><span class="nottickedoff">y' &lt;- defaultTermForType y</span>
<span class="lineno">  712 </span><span class="spaces">      </span><span class="nottickedoff">return $ Rocq.App (Rocq.Var &quot;pair&quot;) [x',y']</span>
<span class="lineno">  713 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  714 </span><span class="spaces">    </span><span class="nottickedoff">(asPiList -&gt; (bs,body))</span>
<span class="lineno">  715 </span><span class="spaces">      </span><span class="nottickedoff">| not (null bs)</span>
<span class="lineno">  716 </span><span class="spaces">      </span><span class="nottickedoff">, closedTerm body -&gt;</span>
<span class="lineno">  717 </span><span class="spaces">      </span><span class="nottickedoff">do bs'   &lt;- forM bs $ \ (_nm, ty) -&gt; Rocq.Binder Rocq.Explicit &quot;_&quot; . Just &lt;$&gt; translateTerm ty</span>
<span class="lineno">  718 </span><span class="spaces">         </span><span class="nottickedoff">body' &lt;- defaultTermForType body</span>
<span class="lineno">  719 </span><span class="spaces">         </span><span class="nottickedoff">return $ Rocq.Lambda bs' body'</span>
<span class="lineno">  720 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; Except.throwError $ CannotCreateDefaultValue typ</span></span>
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>-- | Translate a SAW core term along with its type to a Rocq term and its Rocq
<span class="lineno">  724 </span>-- type, and pass the results to the supplied function
<span class="lineno">  725 </span>translateTermToDocWith ::
<span class="lineno">  726 </span>  TranslationConfiguration -&gt;
<span class="lineno">  727 </span>  Maybe ModuleName -&gt;
<span class="lineno">  728 </span>  ModuleMap -&gt;
<span class="lineno">  729 </span>  [Rocq.Ident] -&gt; -- ^ globals that have already been translated
<span class="lineno">  730 </span>  [Rocq.Ident] -&gt; -- ^ names of local variables in scope
<span class="lineno">  731 </span>  (Rocq.Term -&gt; Rocq.Term -&gt; Doc ann) -&gt;
<span class="lineno">  732 </span>  Term -&gt; Term -&gt;
<span class="lineno">  733 </span>  Either (TranslationError Term) (Doc ann)
<span class="lineno">  734 </span><span class="decl"><span class="istickedoff">translateTermToDocWith configuration r mm globalDecls localEnv f t tp_trm = do</span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="istickedoff">((term, tp), state) &lt;-</span>
<span class="lineno">  736 </span><span class="spaces">    </span><span class="istickedoff">runTermTranslationMonad <span class="nottickedoff">configuration</span> r <span class="nottickedoff">mm</span> <span class="nottickedoff">globalDecls</span> localEnv</span>
<span class="lineno">  737 </span><span class="spaces">    </span><span class="istickedoff">((,) &lt;$&gt; translateTermLet t &lt;*&gt; translateTermLet tp_trm)</span>
<span class="lineno">  738 </span><span class="spaces">  </span><span class="istickedoff">let decls = view topLevelDeclarations state</span>
<span class="lineno">  739 </span><span class="spaces">  </span><span class="istickedoff">return $</span>
<span class="lineno">  740 </span><span class="spaces">    </span><span class="istickedoff">vcat $</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">[ (vcat . intersperse <span class="nottickedoff">hardline</span> . map <span class="nottickedoff">Rocq.prettyDecl</span> . reverse) decls</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">, if <span class="tickonlytrue">null decls</span> then mempty else <span class="nottickedoff">hardline</span></span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="istickedoff">, f term tp</span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  745 </span>
<span class="lineno">  746 </span>-- | Translate a SAW core 'Term' and its type (given as a 'Term') to a Rocq
<span class="lineno">  747 </span>-- definition with the supplied name
<span class="lineno">  748 </span>translateDefDoc ::
<span class="lineno">  749 </span>  TranslationConfiguration -&gt;
<span class="lineno">  750 </span>  Maybe ModuleName -&gt;
<span class="lineno">  751 </span>  ModuleMap -&gt;
<span class="lineno">  752 </span>  [Rocq.Ident] -&gt;
<span class="lineno">  753 </span>  Rocq.Ident -&gt; Term -&gt; Term -&gt;
<span class="lineno">  754 </span>  Either (TranslationError Term) (Doc ann)
<span class="lineno">  755 </span><span class="decl"><span class="istickedoff">translateDefDoc configuration r mm globalDecls name =</span>
<span class="lineno">  756 </span><span class="spaces">  </span><span class="istickedoff">translateTermToDocWith <span class="nottickedoff">configuration</span> r <span class="nottickedoff">mm</span> <span class="nottickedoff">globalDecls</span> [name]</span>
<span class="lineno">  757 </span><span class="spaces">  </span><span class="istickedoff">(\ t tp -&gt; Rocq.prettyDecl $ mkDefinition name t tp)</span></span>

</pre>
</body>
</html>
