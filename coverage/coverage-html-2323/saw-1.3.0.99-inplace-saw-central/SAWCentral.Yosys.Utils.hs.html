<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : SAWCentral.Yosys.Utils
<span class="lineno">    3 </span>Description : Miscellaneous utilities used when working with HDL
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : sbreese
<span class="lineno">    6 </span>Stability   : experimental
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>
<span class="lineno">    9 </span>{-# Language CPP #-}
<span class="lineno">   10 </span>{-# Language TemplateHaskell #-}
<span class="lineno">   11 </span>{-# Language OverloadedStrings #-}
<span class="lineno">   12 </span>{-# Language LambdaCase #-}
<span class="lineno">   13 </span>{-# Language ViewPatterns #-}
<span class="lineno">   14 </span>{-# Language ScopedTypeVariables #-}
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>module SAWCentral.Yosys.Utils where
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>import Control.Monad (forM, foldM)
<span class="lineno">   19 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   20 </span>import Control.Exception (Exception, throw)
<span class="lineno">   21 </span>import Control.Monad.Catch (MonadThrow)
<span class="lineno">   22 </span>
<span class="lineno">   23 </span>import Data.Bifunctor (bimap)
<span class="lineno">   24 </span>import qualified Data.List as List
<span class="lineno">   25 </span>import Data.Text (Text)
<span class="lineno">   26 </span>import qualified Data.Text as Text
<span class="lineno">   27 </span>import Data.Map (Map)
<span class="lineno">   28 </span>import qualified Data.Map as Map
<span class="lineno">   29 </span>import qualified Data.Graph as Graph
<span class="lineno">   30 </span>
<span class="lineno">   31 </span>import Numeric.Natural (Natural)
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>import Text.Encoding.Z (zEncodeString)
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>import qualified SAWCore.SharedTerm as SC
<span class="lineno">   36 </span>import qualified CryptolSAWCore.TypedTerm as SC
<span class="lineno">   37 </span>import qualified SAWCore.SCTypeCheck as SC.TC
<span class="lineno">   38 </span>
<span class="lineno">   39 </span>import qualified Cryptol.TypeCheck.Type as C
<span class="lineno">   40 </span>import qualified Cryptol.Utils.Ident as C
<span class="lineno">   41 </span>import qualified Cryptol.Utils.RecordMap as C
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>reportBugText :: Text
<span class="lineno">   44 </span><span class="decl"><span class="nottickedoff">reportBugText = &quot;You should report this issue at: https://github.com/GaloisInc/saw-script/issues&quot;</span></span>
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>consultYosysManual :: Text
<span class="lineno">   47 </span><span class="decl"><span class="nottickedoff">consultYosysManual = &quot;More information is available in the Yosys manual, at: https://yosyshq.net/yosys/documentation.html&quot;</span></span>
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>data YosysBitvecConsumer
<span class="lineno">   50 </span>  = YosysBitvecConsumerOutputPort Text
<span class="lineno">   51 </span>  | YosysBitvecConsumerCell Text Text
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>data YosysError
<span class="lineno">   54 </span>  = YosysError Text
<span class="lineno">   55 </span>  | YosysErrorTypeError Text Text
<span class="lineno">   56 </span>  | YosysErrorNoSuchOutputBitvec Text YosysBitvecConsumer
<span class="lineno">   57 </span>  | YosysErrorNoSuchSubmodule Text Text
<span class="lineno">   58 </span>  | YosysErrorUnsupportedFF Text
<span class="lineno">   59 </span>  | YosysErrorInvalidOverrideTarget
<span class="lineno">   60 </span>  | YosysErrorOverrideNameNotFound Text
<span class="lineno">   61 </span>  | YosysErrorInvalidStateFieldWidth Text
<span class="lineno">   62 </span>  | YosysErrorTransitionSystemMissingField Text
<span class="lineno">   63 </span>  | YosysErrorTransitionSystemBadType
<span class="lineno">   64 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Exception YosysError</span></span></span></span></span></span>
<span class="lineno">   65 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show YosysError</span></span></span></span> where
<span class="lineno">   66 </span>  <span class="decl"><span class="nottickedoff">show (YosysError msg) = Text.unpack $ &quot;Error: &quot; &lt;&gt; msg &lt;&gt; &quot;\n&quot; &lt;&gt; reportBugText</span>
<span class="lineno">   67 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorTypeError msg err) = Text.unpack $ mconcat</span>
<span class="lineno">   68 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: An internal term failed to type-check.\n&quot;</span>
<span class="lineno">   69 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This occured while &quot;, msg, &quot;.\n&quot;</span>
<span class="lineno">   70 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;The type error was:\n&quot;, err</span>
<span class="lineno">   71 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">   72 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">   73 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">   74 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorNoSuchOutputBitvec bvec (YosysBitvecConsumerOutputPort onm)) = Text.unpack $ mconcat</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: Could not find the output bitvector &quot;, bvec</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;, which is connected to a module output port \&quot;&quot;, onm</span>
<span class="lineno">   77 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;\&quot;.\n&quot;</span>
<span class="lineno">   78 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">   81 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorNoSuchOutputBitvec bvec (YosysBitvecConsumerCell cnm inm)) = Text.unpack $ mconcat</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: Could not find the output bitvector &quot;, bvec</span>
<span class="lineno">   83 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;, which is connected to the input \&quot;&quot;, inm</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;\&quot; of the cell with name \&quot;&quot;, cnm</span>
<span class="lineno">   85 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;\&quot;.\n&quot;</span>
<span class="lineno">   86 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;It is possible that this represents an undetected cycle in the netgraph.\n&quot;</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">   89 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorNoSuchSubmodule submoduleName cellName) =</span>
<span class="lineno">   90 </span><span class="spaces">    </span><span class="nottickedoff">Text.unpack $ mconcat</span>
<span class="lineno">   91 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;Error: Encountered a cell \&quot;&quot;</span>
<span class="lineno">   92 </span><span class="spaces">      </span><span class="nottickedoff">, cellName</span>
<span class="lineno">   93 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\&quot; with type \&quot;&quot;</span>
<span class="lineno">   94 </span><span class="spaces">      </span><span class="nottickedoff">, submoduleName</span>
<span class="lineno">   95 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\&quot;, but could not find a submodule named \&quot;&quot;</span>
<span class="lineno">   96 </span><span class="spaces">      </span><span class="nottickedoff">, submoduleName</span>
<span class="lineno">   97 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\&quot;.&quot;</span>
<span class="lineno">   98 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno">   99 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorUnsupportedFF mnm) = Text.unpack $ mconcat</span>
<span class="lineno">  100 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The circuit contains cells with type \&quot;&quot;, mnm, &quot;\&quot;.\n&quot;</span>
<span class="lineno">  101 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;These cells are not currently supported by SAW.\n&quot;</span>
<span class="lineno">  102 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;It may be helpful to replace certain stateful cells using the \&quot;memory\&quot;, \&quot;dffunmap\&quot;, and \&quot;async2sync\&quot; tactics within Yosys.\n&quot;</span>
<span class="lineno">  103 </span><span class="spaces">    </span><span class="nottickedoff">, consultYosysManual</span>
<span class="lineno">  104 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  105 </span><span class="spaces">  </span><span class="nottickedoff">show YosysErrorInvalidOverrideTarget = Text.unpack $ mconcat</span>
<span class="lineno">  106 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The first argument to \&quot;yosys_verify\&quot; could not be identified as a Yosys module.\n&quot;</span>
<span class="lineno">  107 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This argument should typically take the form {{ m.module_name }}, where \&quot;m\&quot; is a record term returned by \&quot;yosys_import\&quot;&quot;</span>
<span class="lineno">  108 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  109 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorOverrideNameNotFound nm) = Text.unpack $ mconcat</span>
<span class="lineno">  110 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The name \&quot;&quot;, nm, &quot;\&quot; could not be found while applying overrides.\n&quot;</span>
<span class="lineno">  111 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  112 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  113 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  114 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorInvalidStateFieldWidth nm) = Text.unpack $ mconcat</span>
<span class="lineno">  115 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: The state field \&quot;&quot;, nm, &quot;\&quot; has an invalid width.\n&quot;</span>
<span class="lineno">  116 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  117 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  118 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  119 </span><span class="spaces">  </span><span class="nottickedoff">show (YosysErrorTransitionSystemMissingField nm) = Text.unpack $ mconcat</span>
<span class="lineno">  120 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: While translating a sequential circuit to a Sally transition system, could not find the field \&quot;&quot;, nm, &quot;\&quot;.\n&quot;</span>
<span class="lineno">  121 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  122 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="nottickedoff">]</span>
<span class="lineno">  124 </span><span class="spaces">  </span><span class="nottickedoff">show YosysErrorTransitionSystemBadType = Text.unpack $ mconcat</span>
<span class="lineno">  125 </span><span class="spaces">    </span><span class="nottickedoff">[ &quot;Error: While translating a sequential circuit to a Sally transition system, an intermediate What4 predicate was not a boolean.\n&quot;</span>
<span class="lineno">  126 </span><span class="spaces">    </span><span class="nottickedoff">, &quot;This may represent a bug in SAW.\n&quot;</span>
<span class="lineno">  127 </span><span class="spaces">    </span><span class="nottickedoff">, reportBugText</span>
<span class="lineno">  128 </span><span class="spaces">    </span><span class="nottickedoff">]</span></span>
<span class="lineno">  129 </span>
<span class="lineno">  130 </span>mapForWithKeyM :: Monad m =&gt; Map k a -&gt; (k -&gt; a -&gt; m b) -&gt; m (Map k b)
<span class="lineno">  131 </span><span class="decl"><span class="istickedoff">mapForWithKeyM m f = sequence $ Map.mapWithKey f m</span></span>
<span class="lineno">  132 </span>
<span class="lineno">  133 </span>reverseTopSort :: Graph.Graph -&gt; [Graph.Vertex]
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">reverseTopSort =</span>
<span class="lineno">  135 </span><span class="spaces"></span><span class="istickedoff">#if MIN_VERSION_containers(6,4,1)</span>
<span class="lineno">  136 </span><span class="spaces">  </span><span class="istickedoff">Graph.reverseTopSort</span>
<span class="lineno">  137 </span><span class="spaces"></span><span class="istickedoff">#else</span>
<span class="lineno">  138 </span><span class="spaces">  </span><span class="istickedoff">reverse . Graph.topSort</span></span>
<span class="lineno">  139 </span>#endif
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- | Check that a SAWCore term is well-typed, throwing an exception otherwise.
<span class="lineno">  142 </span>validateTerm :: MonadIO m =&gt; SC.SharedContext -&gt; Text -&gt; SC.Term -&gt; m SC.Term
<span class="lineno">  143 </span><span class="decl"><span class="istickedoff">validateTerm sc msg t = liftIO (SC.TC.scTypeCheck sc <span class="nottickedoff">Nothing</span> t) &gt;&gt;= \case</span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="istickedoff">Right _ -&gt; pure t</span>
<span class="lineno">  145 </span><span class="spaces">  </span><span class="istickedoff">Left err -&gt;</span>
<span class="lineno">  146 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">throw</span></span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">. YosysErrorTypeError msg</span></span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">. Text.pack</span></span>
<span class="lineno">  149 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">. unlines</span></span>
<span class="lineno">  150 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">$ SC.TC.prettyTCError err</span></span></span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- | Check that a SAWCore term is well-typed and has a specific type
<span class="lineno">  153 </span>validateTermAtType :: MonadIO m =&gt; SC.SharedContext -&gt; Text -&gt;
<span class="lineno">  154 </span>                      SC.Term -&gt; SC.Term -&gt; m ()
<span class="lineno">  155 </span><span class="decl"><span class="nottickedoff">validateTermAtType sc msg trm tp =</span>
<span class="lineno">  156 </span><span class="spaces">  </span><span class="nottickedoff">liftIO (SC.TC.runTCM (SC.TC.typeInferComplete trm &gt;&gt;= \tp_trm -&gt;</span>
<span class="lineno">  157 </span><span class="spaces">                         </span><span class="nottickedoff">SC.TC.checkSubtype tp_trm tp) sc Nothing []) &gt;&gt;= \case</span>
<span class="lineno">  158 </span><span class="spaces">  </span><span class="nottickedoff">Right _ -&gt; return ()</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="nottickedoff">Left err -&gt;</span>
<span class="lineno">  160 </span><span class="spaces">    </span><span class="nottickedoff">throw</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="nottickedoff">. YosysErrorTypeError msg</span>
<span class="lineno">  162 </span><span class="spaces">    </span><span class="nottickedoff">. Text.pack</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="nottickedoff">. unlines</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="nottickedoff">$ SC.TC.prettyTCError err</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | Produce a SAWCore tuple type corresponding to a Cryptol record type with the given fields.
<span class="lineno">  167 </span>cryptolRecordType ::
<span class="lineno">  168 </span>  MonadIO m =&gt;
<span class="lineno">  169 </span>  SC.SharedContext -&gt;
<span class="lineno">  170 </span>  Map Text SC.Term -&gt;
<span class="lineno">  171 </span>  m SC.Term
<span class="lineno">  172 </span><span class="decl"><span class="istickedoff">cryptolRecordType sc fields =</span>
<span class="lineno">  173 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ SC.scTupleType sc (fmap snd . C.canonicalFields . C.recordFromFields $ Map.assocs fields)</span></span>
<span class="lineno">  174 </span>
<span class="lineno">  175 </span>-- | Produce a SAWCore tuple corresponding to a Cryptol record with the given fields.
<span class="lineno">  176 </span>cryptolRecord ::
<span class="lineno">  177 </span>  MonadIO m =&gt;
<span class="lineno">  178 </span>  SC.SharedContext -&gt;
<span class="lineno">  179 </span>  Map Text SC.Term -&gt;
<span class="lineno">  180 </span>  m SC.Term
<span class="lineno">  181 </span><span class="decl"><span class="istickedoff">cryptolRecord sc fields =</span>
<span class="lineno">  182 </span><span class="spaces">  </span><span class="istickedoff">liftIO $ SC.scTuple sc (fmap snd . C.canonicalFields . C.recordFromFields $ Map.assocs fields)</span></span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span>-- | Produce a SAWCore tuple index corresponding to a lookup in a Cryptol record with the given fields.
<span class="lineno">  185 </span>cryptolRecordSelect ::
<span class="lineno">  186 </span>  MonadIO m =&gt;
<span class="lineno">  187 </span>  SC.SharedContext -&gt;
<span class="lineno">  188 </span>  Map Text a -&gt;
<span class="lineno">  189 </span>  SC.Term -&gt;
<span class="lineno">  190 </span>  Text -&gt;
<span class="lineno">  191 </span>  m SC.Term
<span class="lineno">  192 </span><span class="decl"><span class="istickedoff">cryptolRecordSelect sc fields r nm =</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">case List.elemIndex nm ord of</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">Just i -&gt; liftIO $ SC.scTupleSelector sc r (i + 1) (length ord)</span>
<span class="lineno">  195 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throw . YosysError $ mconcat</span></span>
<span class="lineno">  196 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Could not build record selector term for field name \&quot;&quot;</span></span>
<span class="lineno">  197 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, nm</span></span>
<span class="lineno">  198 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;\&quot; on record term: &quot;</span></span>
<span class="lineno">  199 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ SC.showTerm r</span></span>
<span class="lineno">  200 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nFields are: &quot;</span></span>
<span class="lineno">  201 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, Text.pack . show $ Map.keys fields</span></span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">where ord = fmap fst . C.canonicalFields . C.recordFromFields $ Map.assocs fields</span></span>
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>-- | Produce a SAWCore tuple index corresponding to a lookup in a Cryptol record.
<span class="lineno">  206 </span>-- The record fields are inferred from the Cryptol type attached to the `TypedTerm`.
<span class="lineno">  207 </span>cryptolRecordSelectTyped ::
<span class="lineno">  208 </span>  MonadIO m =&gt;
<span class="lineno">  209 </span>  SC.SharedContext -&gt;
<span class="lineno">  210 </span>  SC.TypedTerm -&gt;
<span class="lineno">  211 </span>  Text -&gt;
<span class="lineno">  212 </span>  m SC.TypedTerm
<span class="lineno">  213 </span><span class="decl"><span class="nottickedoff">cryptolRecordSelectTyped sc r nm = do</span>
<span class="lineno">  214 </span><span class="spaces">  </span><span class="nottickedoff">fields &lt;- Map.mapKeys C.identText . Map.fromList . C.canonicalFields &lt;$&gt; case SC.ttType r of</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="nottickedoff">SC.TypedTermSchema (C.Forall [] [] (C.TRec fs)) -&gt; pure fs</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; throw . YosysError $ mconcat</span>
<span class="lineno">  217 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;Type\n&quot;</span>
<span class="lineno">  218 </span><span class="spaces">      </span><span class="nottickedoff">, Text.pack . show $ SC.ttType r</span>
<span class="lineno">  219 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\nis not a record type&quot;</span>
<span class="lineno">  220 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="nottickedoff">cty &lt;- case Map.lookup nm fields of</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="nottickedoff">Just cty -&gt; pure cty</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; throw . YosysError $ mconcat</span>
<span class="lineno">  224 </span><span class="spaces">      </span><span class="nottickedoff">[ &quot;Record type\n&quot;</span>
<span class="lineno">  225 </span><span class="spaces">      </span><span class="nottickedoff">, Text.pack . show $ SC.ttType r</span>
<span class="lineno">  226 </span><span class="spaces">      </span><span class="nottickedoff">, &quot;\ndoes not have field &quot;</span>
<span class="lineno">  227 </span><span class="spaces">      </span><span class="nottickedoff">, nm</span>
<span class="lineno">  228 </span><span class="spaces">      </span><span class="nottickedoff">]</span>
<span class="lineno">  229 </span><span class="spaces">  </span><span class="nottickedoff">t &lt;- cryptolRecordSelect sc fields (SC.ttTerm r) nm</span>
<span class="lineno">  230 </span><span class="spaces">  </span><span class="nottickedoff">pure $ SC.TypedTerm (SC.TypedTermSchema $ C.tMono cty) t</span></span>
<span class="lineno">  231 </span>
<span class="lineno">  232 </span>-- | Construct a SAWCore expression asserting equality between each field of two records.
<span class="lineno">  233 </span>-- Both records should be tuples corresponding to the specified Cryptol record type.
<span class="lineno">  234 </span>eqBvRecords ::
<span class="lineno">  235 </span>  (MonadIO m, MonadThrow m) =&gt;
<span class="lineno">  236 </span>  SC.SharedContext -&gt;
<span class="lineno">  237 </span>  C.Type -&gt;
<span class="lineno">  238 </span>  SC.Term -&gt;
<span class="lineno">  239 </span>  SC.Term -&gt;
<span class="lineno">  240 </span>  m SC.Term
<span class="lineno">  241 </span><span class="decl"><span class="istickedoff">eqBvRecords sc cty a b = do</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">fields &lt;- Map.mapKeys C.identText . Map.fromList . C.canonicalFields &lt;$&gt; case cty of</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">C.TRec fs -&gt; pure fs</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throw . YosysError $ mconcat</span></span>
<span class="lineno">  245 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type\n&quot;</span></span>
<span class="lineno">  246 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ show cty</span></span>
<span class="lineno">  247 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nis not a record type&quot;</span></span>
<span class="lineno">  248 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">eqs &lt;- forM (Map.assocs fields) $ \(nm, fcty) -&gt; do</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff">w &lt;- case fcty of</span>
<span class="lineno">  251 </span><span class="spaces">      </span><span class="istickedoff">C.TCon (C.TC C.TCSeq) [C.TCon (C.TC (C.TCNum wint)) [], C.TCon (C.TC C.TCBit) []] -&gt;</span>
<span class="lineno">  252 </span><span class="spaces">        </span><span class="istickedoff">liftIO . SC.scNat sc $ fromIntegral wint</span>
<span class="lineno">  253 </span><span class="spaces">      </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throw . YosysError $ mconcat</span></span>
<span class="lineno">  254 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Type\n&quot;</span></span>
<span class="lineno">  255 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ show fcty</span></span>
<span class="lineno">  256 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nis not a bitvector type&quot;</span></span>
<span class="lineno">  257 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">fa &lt;- cryptolRecordSelect sc fields a nm</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">fb &lt;- cryptolRecordSelect sc fields b nm</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="istickedoff">liftIO $ SC.scBvEq sc w fa fb</span>
<span class="lineno">  261 </span><span class="spaces">  </span><span class="istickedoff">case eqs of</span>
<span class="lineno">  262 </span><span class="spaces">    </span><span class="istickedoff">[] -&gt; <span class="nottickedoff">throw . YosysError $ mconcat</span></span>
<span class="lineno">  263 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[ &quot;Record type\n&quot;</span></span>
<span class="lineno">  264 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, Text.pack $ show cty</span></span>
<span class="lineno">  265 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">, &quot;\nhas no fields&quot;</span></span>
<span class="lineno">  266 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  267 </span><span class="spaces">    </span><span class="istickedoff">(e:es) -&gt; foldM (\x y -&gt; liftIO $ SC.scAnd sc x y) e es</span></span>
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>-- | Encode the given string such that is a valid Cryptol identifier. 
<span class="lineno">  270 </span>-- Since Yosys cell names often look like &quot;\42&quot;, this makes it much easier to manipulate state records,
<span class="lineno">  271 </span>-- which are keyed by cell name.
<span class="lineno">  272 </span>cellIdentifier :: Text -&gt; Text
<span class="lineno">  273 </span><span class="decl"><span class="istickedoff">cellIdentifier = Text.pack . zEncodeString . Text.unpack</span></span>
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | Build a SAWCore type corresponding to the Cryptol record type with the given field types
<span class="lineno">  276 </span>fieldsToType ::
<span class="lineno">  277 </span>  MonadIO m =&gt;
<span class="lineno">  278 </span>  SC.SharedContext -&gt;
<span class="lineno">  279 </span>  Map Text (SC.Term, C.Type) -&gt;
<span class="lineno">  280 </span>  m SC.Term
<span class="lineno">  281 </span><span class="decl"><span class="istickedoff">fieldsToType sc = cryptolRecordType sc . fmap fst</span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>-- | Build a Cryptol record type with the given field types
<span class="lineno">  284 </span>fieldsToCryptolType ::
<span class="lineno">  285 </span>  MonadIO m =&gt;
<span class="lineno">  286 </span>  Map Text (SC.Term, C.Type) -&gt;
<span class="lineno">  287 </span>  m C.Type
<span class="lineno">  288 </span><span class="decl"><span class="istickedoff">fieldsToCryptolType fields = pure . C.tRec . C.recordFromFields $ bimap C.mkIdent snd &lt;$&gt; Map.assocs fields</span></span>
<span class="lineno">  289 </span>
<span class="lineno">  290 </span>-- | Given a bit pattern ([b]) and a term, construct a map associating that output pattern with
<span class="lineno">  291 </span>-- the term, and each bit of that pattern with the corresponding bit of the term.
<span class="lineno">  292 </span>deriveTermsByIndices :: (MonadIO m, Ord b) =&gt; SC.SharedContext -&gt; [b] -&gt; SC.Term -&gt; m (Map [b] Preterm)
<span class="lineno">  293 </span><span class="decl"><span class="istickedoff">deriveTermsByIndices _sc rep t = do</span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="istickedoff">let len = length rep</span>
<span class="lineno">  295 </span><span class="spaces">  </span><span class="istickedoff">let bit i = PretermSlice (fromIntegral (len - 1 - i)) 1 (fromIntegral i) t</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="istickedoff">let telems = map bit [0..len-1]</span>
<span class="lineno">  297 </span><span class="spaces">  </span><span class="istickedoff">pure . Map.fromList $ mconcat</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">[ [(rep, PretermSlice 0 <span class="nottickedoff">(fromIntegral len)</span> 0 t)]</span>
<span class="lineno">  299 </span><span class="spaces">    </span><span class="istickedoff">, zip ((:[]) &lt;$&gt; rep) telems</span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  301 </span>
<span class="lineno">  302 </span>--------------------------------------------------------------------------------
<span class="lineno">  303 </span>-- ** Pre-terms
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>data Preterm
<span class="lineno">  306 </span>  = PretermSlice Natural Natural Natural SC.Term
<span class="lineno">  307 </span>    -- ^ @PretermSlice i j k t@ selects bits @k..k+j-1@ from @t@.
<span class="lineno">  308 </span>  | PretermBvNat Natural Natural
<span class="lineno">  309 </span>    -- ^ @PretermBvNat n x@ is @x@ as an @n@-bit binary number.
<span class="lineno">  310 </span>
<span class="lineno">  311 </span>widthPreterm :: Preterm -&gt; Natural
<span class="lineno">  312 </span><span class="decl"><span class="istickedoff">widthPreterm p =</span>
<span class="lineno">  313 </span><span class="spaces">  </span><span class="istickedoff">case p of</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice _ j _ _ -&gt; j</span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="istickedoff">PretermBvNat n _ -&gt; n</span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- | Rewrite the concatenation of two @Preterm@ expressions into a
<span class="lineno">  318 </span>-- single @Preterm@, if possible.
<span class="lineno">  319 </span>fusePreterm :: Preterm -&gt; Preterm -&gt; Maybe Preterm
<span class="lineno">  320 </span><span class="decl"><span class="istickedoff">fusePreterm (PretermSlice a b c t) (PretermSlice i j k t')</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="istickedoff">| t == t' &amp;&amp; a + b == i &amp;&amp; c == j + k =</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff">Just (PretermSlice a (b + j) k t)</span>
<span class="lineno">  323 </span><span class="spaces"></span><span class="istickedoff">fusePreterm (PretermBvNat m x) (PretermBvNat n y) =</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="istickedoff">Just (PretermBvNat (m + n) (x * 2^n + y))</span>
<span class="lineno">  325 </span><span class="spaces"></span><span class="istickedoff">fusePreterm _ _ = Nothing</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | Concatenate a @Preterm@ expression onto a list of @Preterm@s,
<span class="lineno">  328 </span>-- fusing expressions if possible.
<span class="lineno">  329 </span>consPreterm :: Preterm -&gt; [Preterm] -&gt; [Preterm]
<span class="lineno">  330 </span><span class="decl"><span class="istickedoff">consPreterm x [] = [x]</span>
<span class="lineno">  331 </span><span class="spaces"></span><span class="istickedoff">consPreterm x (y : ys) =</span>
<span class="lineno">  332 </span><span class="spaces">  </span><span class="istickedoff">case fusePreterm x y of</span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; x : y : ys</span>
<span class="lineno">  334 </span><span class="spaces">    </span><span class="istickedoff">Just xy -&gt; xy : ys</span></span>
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>-- | Rewrite a sequence of @Preterm@ expressions, combining adjacent
<span class="lineno">  337 </span>-- expressions wherever possible.
<span class="lineno">  338 </span>fusePreterms :: [Preterm] -&gt; [Preterm]
<span class="lineno">  339 </span><span class="decl"><span class="istickedoff">fusePreterms = foldr consPreterm []</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>-- | Build a @SC.Term@ from a @Preterm@.
<span class="lineno">  342 </span>scPreterm :: SC.SharedContext -&gt; Preterm -&gt; IO SC.Term
<span class="lineno">  343 </span><span class="decl"><span class="istickedoff">scPreterm sc p =</span>
<span class="lineno">  344 </span><span class="spaces">  </span><span class="istickedoff">case p of</span>
<span class="lineno">  345 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice 0 _ 0 t -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">      </span><span class="istickedoff">pure t</span>
<span class="lineno">  347 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice 0 j k t -&gt;</span>
<span class="lineno">  348 </span><span class="spaces">      </span><span class="istickedoff">do boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  349 </span><span class="spaces">         </span><span class="istickedoff">j' &lt;- SC.scNat sc j</span>
<span class="lineno">  350 </span><span class="spaces">         </span><span class="istickedoff">k' &lt;- SC.scNat sc k</span>
<span class="lineno">  351 </span><span class="spaces">         </span><span class="istickedoff">SC.scGlobalApply sc &quot;Prelude.take&quot; [boolty, j', k', t]</span>
<span class="lineno">  352 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice i j 0 t -&gt;</span>
<span class="lineno">  353 </span><span class="spaces">      </span><span class="istickedoff">do boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  354 </span><span class="spaces">         </span><span class="istickedoff">i' &lt;- SC.scNat sc i</span>
<span class="lineno">  355 </span><span class="spaces">         </span><span class="istickedoff">j' &lt;- SC.scNat sc j</span>
<span class="lineno">  356 </span><span class="spaces">         </span><span class="istickedoff">SC.scGlobalApply sc &quot;Prelude.drop&quot; [boolty, i', j', t]</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice i 1 k t -&gt;</span>
<span class="lineno">  358 </span><span class="spaces">      </span><span class="istickedoff">do boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  359 </span><span class="spaces">         </span><span class="istickedoff">n' &lt;- SC.scNat sc (i + 1 + k)</span>
<span class="lineno">  360 </span><span class="spaces">         </span><span class="istickedoff">i' &lt;- SC.scNat sc i</span>
<span class="lineno">  361 </span><span class="spaces">         </span><span class="istickedoff">SC.scSingle sc boolty =&lt;&lt; SC.scAt sc n' boolty t i'</span>
<span class="lineno">  362 </span><span class="spaces">    </span><span class="istickedoff">PretermSlice i j k t -&gt;</span>
<span class="lineno">  363 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do boolty &lt;- liftIO $ SC.scBoolType sc</span></span>
<span class="lineno">  364 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">i' &lt;- SC.scNat sc i</span></span>
<span class="lineno">  365 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">j' &lt;- SC.scNat sc j</span></span>
<span class="lineno">  366 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">k' &lt;- SC.scNat sc k</span></span>
<span class="lineno">  367 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">SC.scSlice sc boolty i' j' k' t</span></span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">PretermBvNat i x -&gt;</span>
<span class="lineno">  369 </span><span class="spaces">      </span><span class="istickedoff">do i' &lt;- SC.scNat sc i</span>
<span class="lineno">  370 </span><span class="spaces">         </span><span class="istickedoff">x' &lt;- SC.scNat sc x</span>
<span class="lineno">  371 </span><span class="spaces">         </span><span class="istickedoff">SC.scBvNat sc i' x'</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | Build a @SC.Term@ from a concatenated sequence of @Preterm@s.
<span class="lineno">  374 </span>scPreterms :: SC.SharedContext -&gt; [Preterm] -&gt; IO SC.Term
<span class="lineno">  375 </span><span class="decl"><span class="istickedoff">scPreterms sc preterms = snd &lt;$&gt; go preterms</span>
<span class="lineno">  376 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">append :: (Natural, SC.Term) -&gt; (Natural, SC.Term) -&gt; IO (Natural, SC.Term)</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="istickedoff">append (i, x) (j, y)</span>
<span class="lineno">  379 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">i == 0</span> = <span class="nottickedoff">pure (j, y)</span></span>
<span class="lineno">  380 </span><span class="spaces">      </span><span class="istickedoff">| j == 0 = pure (i, x)</span>
<span class="lineno">  381 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  382 </span><span class="spaces">        </span><span class="istickedoff">do i' &lt;- SC.scNat sc i</span>
<span class="lineno">  383 </span><span class="spaces">           </span><span class="istickedoff">j' &lt;- SC.scNat sc j</span>
<span class="lineno">  384 </span><span class="spaces">           </span><span class="istickedoff">boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  385 </span><span class="spaces">           </span><span class="istickedoff">t &lt;- SC.scAppend sc i' j' boolty x y</span>
<span class="lineno">  386 </span><span class="spaces">           </span><span class="istickedoff">pure (<span class="nottickedoff">i + j</span>, t)</span>
<span class="lineno">  387 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  388 </span><span class="spaces">    </span><span class="istickedoff">go :: [Preterm] -&gt; IO (Natural, SC.Term)</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="istickedoff">go [] =</span>
<span class="lineno">  390 </span><span class="spaces">      </span><span class="istickedoff">do z &lt;- SC.scNat sc 0</span>
<span class="lineno">  391 </span><span class="spaces">         </span><span class="istickedoff">t &lt;- SC.scBvNat sc z z</span>
<span class="lineno">  392 </span><span class="spaces">         </span><span class="istickedoff">pure (0, <span class="nottickedoff">t</span>)</span>
<span class="lineno">  393 </span><span class="spaces">    </span><span class="istickedoff">go (p : ps) =</span>
<span class="lineno">  394 </span><span class="spaces">      </span><span class="istickedoff">do let i = widthPreterm p</span>
<span class="lineno">  395 </span><span class="spaces">         </span><span class="istickedoff">p' &lt;- scPreterm sc p</span>
<span class="lineno">  396 </span><span class="spaces">         </span><span class="istickedoff">let (ps1, ps2) = span ((==i) . widthPreterm) ps</span>
<span class="lineno">  397 </span><span class="spaces">         </span><span class="istickedoff">if length ps1 &gt; 1 then</span>
<span class="lineno">  398 </span><span class="spaces">           </span><span class="istickedoff">-- Use `join` to concatenate same-length preterms</span>
<span class="lineno">  399 </span><span class="spaces">           </span><span class="istickedoff">do i' &lt;- SC.scNat sc i</span>
<span class="lineno">  400 </span><span class="spaces">              </span><span class="istickedoff">boolty &lt;- SC.scBoolType sc</span>
<span class="lineno">  401 </span><span class="spaces">              </span><span class="istickedoff">ety &lt;- SC.scVecType sc i' boolty</span>
<span class="lineno">  402 </span><span class="spaces">              </span><span class="istickedoff">ps1' &lt;- traverse (scPreterm <span class="nottickedoff">sc</span>) ps1</span>
<span class="lineno">  403 </span><span class="spaces">              </span><span class="istickedoff">v &lt;- SC.scVector sc ety (p' : ps1')</span>
<span class="lineno">  404 </span><span class="spaces">              </span><span class="istickedoff">let len = List.genericLength ps1 + 1 :: Natural</span>
<span class="lineno">  405 </span><span class="spaces">              </span><span class="istickedoff">len' &lt;- SC.scNat sc len</span>
<span class="lineno">  406 </span><span class="spaces">              </span><span class="istickedoff">x &lt;- SC.scJoin sc len' i' boolty v</span>
<span class="lineno">  407 </span><span class="spaces">              </span><span class="istickedoff">(j, y) &lt;- go ps2</span>
<span class="lineno">  408 </span><span class="spaces">              </span><span class="istickedoff">append (len * i, x) (j, <span class="nottickedoff">y</span>)</span>
<span class="lineno">  409 </span><span class="spaces">           </span><span class="istickedoff">else</span>
<span class="lineno">  410 </span><span class="spaces">           </span><span class="istickedoff">do x &lt;- scPreterm sc p</span>
<span class="lineno">  411 </span><span class="spaces">              </span><span class="istickedoff">(j, y) &lt;- go ps</span>
<span class="lineno">  412 </span><span class="spaces">              </span><span class="istickedoff">append (i, x) (j, y)</span></span>

</pre>
</body>
</html>
