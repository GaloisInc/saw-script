<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{- |
<span class="lineno">    2 </span>Module      : CryptolSAWCore.CryptolEnv
<span class="lineno">    3 </span>Description : Context for interpreting Cryptol within SAW-Script.
<span class="lineno">    4 </span>License     : BSD3
<span class="lineno">    5 </span>Maintainer  : huffman
<span class="lineno">    6 </span>Stability   : provisional
<span class="lineno">    7 </span>-}
<span class="lineno">    8 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    9 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   10 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   11 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   12 </span>
<span class="lineno">   13 </span>module CryptolSAWCore.CryptolEnv
<span class="lineno">   14 </span>  ( ImportVisibility(..)
<span class="lineno">   15 </span>  , CryptolEnv(..)
<span class="lineno">   16 </span>  , initCryptolEnv
<span class="lineno">   17 </span>  , loadCryptolModule
<span class="lineno">   18 </span>  , bindCryptolModule
<span class="lineno">   19 </span>  , lookupCryptolModule
<span class="lineno">   20 </span>  , combineCryptolEnv
<span class="lineno">   21 </span>  , importModule
<span class="lineno">   22 </span>  , bindTypedTerm
<span class="lineno">   23 </span>  , bindType
<span class="lineno">   24 </span>  , bindInteger
<span class="lineno">   25 </span>  , parseTypedTerm
<span class="lineno">   26 </span>  , parseDecls
<span class="lineno">   27 </span>  , parseSchema
<span class="lineno">   28 </span>  , declareName
<span class="lineno">   29 </span>  , typeNoUser
<span class="lineno">   30 </span>  , schemaNoUser
<span class="lineno">   31 </span>  , translateExpr
<span class="lineno">   32 </span>  , getNamingEnv
<span class="lineno">   33 </span>  , getAllIfaceDecls
<span class="lineno">   34 </span>  , InputText(..)
<span class="lineno">   35 </span>  , lookupIn
<span class="lineno">   36 </span>  , resolveIdentifier
<span class="lineno">   37 </span>  , meSolverConfig
<span class="lineno">   38 </span>  , mkCryEnv
<span class="lineno">   39 </span>  , C.ImportPrimitiveOptions(..)
<span class="lineno">   40 </span>  , C.defaultPrimitiveOptions
<span class="lineno">   41 </span>  )
<span class="lineno">   42 </span>  where
<span class="lineno">   43 </span>
<span class="lineno">   44 </span>--import qualified Control.Exception as X
<span class="lineno">   45 </span>import Data.ByteString (ByteString)
<span class="lineno">   46 </span>import qualified Data.Text as Text
<span class="lineno">   47 </span>import Data.Map (Map)
<span class="lineno">   48 </span>import qualified Data.Map as Map
<span class="lineno">   49 </span>import qualified Data.Set as Set
<span class="lineno">   50 </span>import Data.Maybe (fromMaybe)
<span class="lineno">   51 </span>import Data.Text (Text, pack, splitOn)
<span class="lineno">   52 </span>import Control.Monad(when)
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>#if !MIN_VERSION_base(4,8,0)
<span class="lineno">   55 </span>import Data.Monoid
<span class="lineno">   56 </span>import Data.Traversable
<span class="lineno">   57 </span>#endif
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import System.Environment (lookupEnv)
<span class="lineno">   60 </span>import System.Environment.Executable (splitExecutablePath)
<span class="lineno">   61 </span>import System.FilePath ((&lt;/&gt;), normalise, joinPath, splitPath, splitSearchPath)
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>import CryptolSAWCore.Panic
<span class="lineno">   64 </span>import SAWCore.Name (nameInfo)
<span class="lineno">   65 </span>import SAWCore.Recognizer (asConstant)
<span class="lineno">   66 </span>import SAWCore.SharedTerm (NameInfo, SharedContext, Term, incVars)
<span class="lineno">   67 </span>import SAWCore.Term.Pretty (showTerm)
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>import qualified CryptolSAWCore.Cryptol as C
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>import qualified Cryptol.Eval as E
<span class="lineno">   72 </span>import qualified Cryptol.Parser as P
<span class="lineno">   73 </span>import qualified Cryptol.Parser.AST as P
<span class="lineno">   74 </span>import qualified Cryptol.Parser.Position as P
<span class="lineno">   75 </span>import qualified Cryptol.TypeCheck as T
<span class="lineno">   76 </span>import qualified Cryptol.TypeCheck.AST as T
<span class="lineno">   77 </span>import qualified Cryptol.TypeCheck.FFI.FFIType as T
<span class="lineno">   78 </span>import qualified Cryptol.TypeCheck.Error as TE
<span class="lineno">   79 </span>import qualified Cryptol.TypeCheck.Infer as TI
<span class="lineno">   80 </span>import qualified Cryptol.TypeCheck.Kind as TK
<span class="lineno">   81 </span>import qualified Cryptol.TypeCheck.Monad as TM
<span class="lineno">   82 </span>import qualified Cryptol.TypeCheck.Interface as TIface
<span class="lineno">   83 </span>import qualified Cryptol.TypeCheck.Solver.SMT as SMT
<span class="lineno">   84 </span>--import qualified Cryptol.TypeCheck.PP as TP
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>import qualified Cryptol.ModuleSystem as M
<span class="lineno">   87 </span>import qualified Cryptol.ModuleSystem.Base as MB
<span class="lineno">   88 </span>import qualified Cryptol.ModuleSystem.Env as ME
<span class="lineno">   89 </span>import qualified Cryptol.ModuleSystem.Exports as MEx
<span class="lineno">   90 </span>import qualified Cryptol.ModuleSystem.Interface as MI
<span class="lineno">   91 </span>import qualified Cryptol.ModuleSystem.Monad as MM
<span class="lineno">   92 </span>import qualified Cryptol.ModuleSystem.NamingEnv as MN
<span class="lineno">   93 </span>import qualified Cryptol.ModuleSystem.Name as MN
<span class="lineno">   94 </span>import qualified Cryptol.ModuleSystem.Renamer as MR
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>import qualified Cryptol.Utils.Ident as C
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>import Cryptol.Utils.PP hiding ((&lt;/&gt;))
<span class="lineno">   99 </span>import Cryptol.Utils.Ident (Ident, preludeName, arrayName, preludeReferenceName
<span class="lineno">  100 </span>                           , mkIdent, interactiveName, identText
<span class="lineno">  101 </span>                           , textToModName
<span class="lineno">  102 </span>                           , prelPrim)
<span class="lineno">  103 </span>import Cryptol.Utils.Logger (quietLogger)
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>--import SAWScript.REPL.Monad (REPLException(..))
<span class="lineno">  106 </span>import CryptolSAWCore.TypedTerm
<span class="lineno">  107 </span>import Cryptol.ModuleSystem.Env (ModContextParams(NoParams))
<span class="lineno">  108 </span>-- import SAWCentral.AST (Located(getVal, locatedPos), Import(..))
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- | Parse input, together with information about where it came from.
<span class="lineno">  112 </span>data InputText = InputText
<span class="lineno">  113 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">inpText</span></span></span> :: Text   -- ^ Parse this
<span class="lineno">  114 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">inpFile</span></span></span> :: String -- ^ It came from this file (or thing)
<span class="lineno">  115 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">inpLine</span></span></span> :: Int    -- ^ On this line number
<span class="lineno">  116 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">inpCol</span></span></span>  :: Int    -- ^ On this column number
<span class="lineno">  117 </span>  }
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>--------------------------------------------------------------------------------
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>-- | Should a given import result in all symbols being visible (as they
<span class="lineno">  124 </span>-- are for focused modules in the Cryptol REPL) or only public symbols?
<span class="lineno">  125 </span>-- Making all symbols visible is useful for verification and code
<span class="lineno">  126 </span>-- generation.
<span class="lineno">  127 </span>data ImportVisibility
<span class="lineno">  128 </span>  = OnlyPublic
<span class="lineno">  129 </span>  | PublicAndPrivate
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>-- | The environment for capturing the Cryptol interpreter state as well as the
<span class="lineno">  132 </span>--   SAWCore translations and associated state.
<span class="lineno">  133 </span>--
<span class="lineno">  134 </span>--  FIXME[D]: The differences in function between this and the similar
<span class="lineno">  135 </span>--   C.Env?
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>data CryptolEnv = CryptolEnv
<span class="lineno">  138 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">eImports</span></span></span>    :: [(ImportVisibility, P.Import)]
<span class="lineno">  139 </span>                                        -- ^ Declarations of imported Cryptol modules
<span class="lineno">  140 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eModuleEnv</span></span></span>  :: ME.ModuleEnv         -- ^ Imported modules, and state for the ModuleM monad
<span class="lineno">  141 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eExtraNames</span></span></span> :: MR.NamingEnv         -- ^ Context for the Cryptol renamer
<span class="lineno">  142 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eExtraTypes</span></span></span> :: Map T.Name T.Schema  -- ^ Cryptol types for extra names in scope
<span class="lineno">  143 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eExtraTSyns</span></span></span> :: Map T.Name T.TySyn   -- ^ Extra Cryptol type synonyms in scope
<span class="lineno">  144 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eTermEnv</span></span></span>    :: Map T.Name Term      -- ^ SAWCore terms for *all* names in scope
<span class="lineno">  145 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ePrims</span></span></span>      :: Map C.PrimIdent Term -- ^ SAWCore terms for primitives
<span class="lineno">  146 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">ePrimTypes</span></span></span>  :: Map C.PrimIdent Term -- ^ SAWCore terms for primitive type names
<span class="lineno">  147 </span>  , <span class="istickedoff"><span class="decl"><span class="istickedoff">eFFITypes</span></span></span>   :: Map NameInfo T.FFIFunType
<span class="lineno">  148 </span>    -- ^ FFI info for SAWCore names of Cryptol foreign functions
<span class="lineno">  149 </span>  }
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>-- Finding things --------------------------------------------------------------
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>
<span class="lineno">  155 </span>-- | Lookup a name in a map containg Cryptol names.
<span class="lineno">  156 </span>-- The string corresponds to the Cryptol name we are looking for.
<span class="lineno">  157 </span>-- If it is unqualifed, then we return any entry associated with the given
<span class="lineno">  158 </span>-- name.  If the string is qualified (i.e., has @::@), then we only consider
<span class="lineno">  159 </span>-- entries from the module in the qualified.
<span class="lineno">  160 </span>-- The result is either the corresponding value, or a list of the
<span class="lineno">  161 </span>lookupIn :: Text -&gt; Map T.Name b -&gt; Either [T.Name] b
<span class="lineno">  162 </span><span class="decl"><span class="nottickedoff">lookupIn nm mp =</span>
<span class="lineno">  163 </span><span class="spaces">  </span><span class="nottickedoff">case [ x | x &lt;- Map.toList mp, matches (fst x) ] of</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="nottickedoff">[ (_,v) ] -&gt; Right v</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="nottickedoff">opts      -&gt; Left (map fst opts)</span>
<span class="lineno">  166 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="nottickedoff">matches = nameMatcher nm</span></span>
<span class="lineno">  168 </span>
<span class="lineno">  169 </span>
<span class="lineno">  170 </span>-- | Parse a string into a function that will match names.
<span class="lineno">  171 </span>-- If the string is unqualified (i.e., no `::`), then we match all
<span class="lineno">  172 </span>-- names with the given identifier.  Otherwise, we only match the
<span class="lineno">  173 </span>-- ones in the module specified by the qualifier.
<span class="lineno">  174 </span>nameMatcher :: Text -&gt; T.Name -&gt; Bool
<span class="lineno">  175 </span><span class="decl"><span class="nottickedoff">nameMatcher xs =</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="nottickedoff">case C.modNameChunksText (textToModName xs) of</span>
<span class="lineno">  177 </span><span class="spaces">      </span><span class="nottickedoff">[]  -&gt; const False</span>
<span class="lineno">  178 </span><span class="spaces">      </span><span class="nottickedoff">[x] -&gt; (x ==) . C.identText . MN.nameIdent</span>
<span class="lineno">  179 </span><span class="spaces">      </span><span class="nottickedoff">cs  -&gt; \n -&gt;</span>
<span class="lineno">  180 </span><span class="spaces">                </span><span class="nottickedoff">case MN.nameInfo n of</span>
<span class="lineno">  181 </span><span class="spaces">                  </span><span class="nottickedoff">MN.LocalName {} -&gt; False</span>
<span class="lineno">  182 </span><span class="spaces">                  </span><span class="nottickedoff">MN.GlobalName _ og -&gt;</span>
<span class="lineno">  183 </span><span class="spaces">                    </span><span class="nottickedoff">let (top,ns) = C.modPathSplit (C.ogModule og)</span>
<span class="lineno">  184 </span><span class="spaces">                    </span><span class="nottickedoff">in last cs == identText (C.ogName og) &amp;&amp;</span>
<span class="lineno">  185 </span><span class="spaces">                       </span><span class="nottickedoff">init cs == C.modNameChunksText top ++ map identText ns</span></span>
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>-- Initialize ------------------------------------------------------------------
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>-- FIXME: Code duplication, these three functions are relatively similar (and last 2 are 85% similar):
<span class="lineno">  190 </span>--  - initCryptolEnv
<span class="lineno">  191 </span>--  - loadCryptolModule
<span class="lineno">  192 </span>--  - importModule
<span class="lineno">  193 </span>--- TODO: common up the common code.
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>initCryptolEnv ::
<span class="lineno">  196 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  197 </span>  SharedContext -&gt; IO CryptolEnv
<span class="lineno">  198 </span><span class="decl"><span class="istickedoff">initCryptolEnv sc = do</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">modEnv0 &lt;- M.initialModuleEnv</span>
<span class="lineno">  200 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  201 </span><span class="spaces">  </span><span class="istickedoff">-- Set the Cryptol include path (TODO: we may want to do this differently)</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">(binDir, _) &lt;- splitExecutablePath</span>
<span class="lineno">  203 </span><span class="spaces">  </span><span class="istickedoff">let instDir = normalise . joinPath . init . splitPath $ binDir</span>
<span class="lineno">  204 </span><span class="spaces">  </span><span class="istickedoff">mCryptolPath &lt;- lookupEnv &quot;CRYPTOLPATH&quot;</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">let cryptolPaths =</span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="istickedoff">case mCryptolPath of</span>
<span class="lineno">  207 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt; []</span>
<span class="lineno">  208 </span><span class="spaces">          </span><span class="istickedoff">Just path -&gt;</span>
<span class="lineno">  209 </span><span class="spaces"></span><span class="istickedoff">#if defined(mingw32_HOST_OS) || defined(__MINGW32__)</span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff">-- Windows paths search from end to beginning</span>
<span class="lineno">  211 </span><span class="spaces">            </span><span class="istickedoff">reverse (splitSearchPath path)</span>
<span class="lineno">  212 </span><span class="spaces"></span><span class="istickedoff">#else</span>
<span class="lineno">  213 </span><span class="spaces">            </span><span class="istickedoff">splitSearchPath path</span>
<span class="lineno">  214 </span><span class="spaces"></span><span class="istickedoff">#endif</span>
<span class="lineno">  215 </span><span class="spaces">  </span><span class="istickedoff">let modEnv1 = modEnv0 { ME.meSearchPath = cryptolPaths ++</span>
<span class="lineno">  216 </span><span class="spaces">                           </span><span class="istickedoff">(instDir &lt;/&gt; &quot;lib&quot;) : ME.meSearchPath modEnv0 }</span>
<span class="lineno">  217 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">-- Load Cryptol prelude and magic Array module</span>
<span class="lineno">  219 </span><span class="spaces">  </span><span class="istickedoff">(_, modEnv2) &lt;-</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">liftModuleM modEnv1 $</span>
<span class="lineno">  221 </span><span class="spaces">      </span><span class="istickedoff">do _ &lt;- MB.loadModuleFrom False (MM.FromModule preludeName)</span>
<span class="lineno">  222 </span><span class="spaces">         </span><span class="istickedoff">_ &lt;- MB.loadModuleFrom False (MM.FromModule arrayName)</span>
<span class="lineno">  223 </span><span class="spaces">         </span><span class="istickedoff">return <span class="nottickedoff">()</span></span>
<span class="lineno">  224 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  225 </span><span class="spaces">  </span><span class="istickedoff">-- Load Cryptol reference implementations</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">((_,refTop), modEnv) &lt;-</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff">liftModuleM modEnv2 $</span>
<span class="lineno">  228 </span><span class="spaces">      </span><span class="istickedoff">MB.loadModuleFrom False (MM.FromModule preludeReferenceName)</span>
<span class="lineno">  229 </span><span class="spaces">  </span><span class="istickedoff">let refMod = T.tcTopEntityToModule refTop</span>
<span class="lineno">  230 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  231 </span><span class="spaces">  </span><span class="istickedoff">-- Set up reference implementation redirections</span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="istickedoff">let refDecls = T.mDecls refMod</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="istickedoff">let nms = Set.toList (MI.ifsPublic (TIface.genIfaceNames refMod))</span>
<span class="lineno">  234 </span><span class="spaces">  </span><span class="istickedoff">let refPrims = Map.fromList</span>
<span class="lineno">  235 </span><span class="spaces">                  </span><span class="istickedoff">[ (prelPrim (identText (MN.nameIdent nm)), T.EWhere (T.EVar nm) refDecls)</span>
<span class="lineno">  236 </span><span class="spaces">                  </span><span class="istickedoff">| nm &lt;- nms ]</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">let cryEnv0 = C.emptyEnv{ C.envRefPrims = refPrims }</span>
<span class="lineno">  238 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  239 </span><span class="spaces">  </span><span class="istickedoff">-- Generate SAWCore translations for all values in scope</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">termEnv &lt;- genTermEnv sc modEnv cryEnv0</span>
<span class="lineno">  241 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">return CryptolEnv</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">{ eImports    = [ (OnlyPublic, P.Import preludeName Nothing Nothing Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  244 </span><span class="spaces">                    </span><span class="istickedoff">, (OnlyPublic, P.Import preludeReferenceName (Just preludeReferenceName) Nothing Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  245 </span><span class="spaces">                    </span><span class="istickedoff">, (OnlyPublic, P.Import arrayName Nothing Nothing Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  246 </span><span class="spaces">                    </span><span class="istickedoff">]</span>
<span class="lineno">  247 </span><span class="spaces">    </span><span class="istickedoff">, eModuleEnv  = modEnv</span>
<span class="lineno">  248 </span><span class="spaces">    </span><span class="istickedoff">, eExtraNames = mempty</span>
<span class="lineno">  249 </span><span class="spaces">    </span><span class="istickedoff">, eExtraTypes = Map.empty</span>
<span class="lineno">  250 </span><span class="spaces">    </span><span class="istickedoff">, eExtraTSyns = Map.empty</span>
<span class="lineno">  251 </span><span class="spaces">    </span><span class="istickedoff">, eTermEnv    = termEnv</span>
<span class="lineno">  252 </span><span class="spaces">    </span><span class="istickedoff">, ePrims      = <span class="nottickedoff">Map.empty</span></span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">, ePrimTypes  = <span class="nottickedoff">Map.empty</span></span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">, eFFITypes   = Map.empty</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">}</span></span>
<span class="lineno">  256 </span>
<span class="lineno">  257 </span>-- Parse -----------------------------------------------------------------------
<span class="lineno">  258 </span>
<span class="lineno">  259 </span>ioParseExpr :: InputText -&gt; IO (P.Expr P.PName)
<span class="lineno">  260 </span><span class="decl"><span class="istickedoff">ioParseExpr = ioParseGeneric P.parseExprWith</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>ioParseDecls :: InputText -&gt; IO [P.Decl P.PName]
<span class="lineno">  263 </span><span class="decl"><span class="istickedoff">ioParseDecls = ioParseGeneric P.parseDeclsWith</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>ioParseSchema :: InputText -&gt; IO (P.Schema P.PName)
<span class="lineno">  266 </span><span class="decl"><span class="istickedoff">ioParseSchema = ioParseGeneric P.parseSchemaWith</span></span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>ioParseGeneric ::
<span class="lineno">  269 </span>  (P.Config -&gt; Text -&gt; Either P.ParseError a) -&gt; InputText -&gt; IO a
<span class="lineno">  270 </span><span class="decl"><span class="istickedoff">ioParseGeneric parse inp = ioParseResult (parse cfg str)</span>
<span class="lineno">  271 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  272 </span><span class="spaces">  </span><span class="istickedoff">cfg = P.defaultConfig { P.cfgSource = inpFile inp }</span>
<span class="lineno">  273 </span><span class="spaces">  </span><span class="istickedoff">-- XXX this is kind of gross; maybe sometime we get a second parser</span>
<span class="lineno">  274 </span><span class="spaces">  </span><span class="istickedoff">-- entry point that takes a start position... (this is saw-script #2175)</span>
<span class="lineno">  275 </span><span class="spaces">  </span><span class="istickedoff">str = Text.concat [ Text.replicate (inpLine inp - 1) &quot;\n&quot;</span>
<span class="lineno">  276 </span><span class="spaces">                    </span><span class="istickedoff">, Text.replicate (inpCol inp - 1) &quot; &quot;</span>
<span class="lineno">  277 </span><span class="spaces">                    </span><span class="istickedoff">, inpText inp ]</span></span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>ioParseResult :: Either P.ParseError a -&gt; IO a
<span class="lineno">  280 </span><span class="decl"><span class="istickedoff">ioParseResult res = case res of</span>
<span class="lineno">  281 </span><span class="spaces">  </span><span class="istickedoff">Right a -&gt; return a</span>
<span class="lineno">  282 </span><span class="spaces">  </span><span class="istickedoff">Left e  -&gt; <span class="nottickedoff">fail $ &quot;Cryptol parse error:\n&quot; ++ show (P.ppError e)</span></span></span> -- X.throwIO (ParseError e)
<span class="lineno">  283 </span>
<span class="lineno">  284 </span>-- Rename ----------------------------------------------------------------------
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>getNamingEnv :: CryptolEnv -&gt; MR.NamingEnv
<span class="lineno">  287 </span><span class="decl"><span class="istickedoff">getNamingEnv env = eExtraNames env `MR.shadowing` nameEnv</span>
<span class="lineno">  288 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  289 </span><span class="spaces">    </span><span class="istickedoff">nameEnv = mconcat $ fromMaybe <span class="nottickedoff">[]</span> $ traverse loadImport (eImports env)</span>
<span class="lineno">  290 </span><span class="spaces">    </span><span class="istickedoff">loadImport (vis, i) = do</span>
<span class="lineno">  291 </span><span class="spaces">      </span><span class="istickedoff">lm &lt;- ME.lookupModule (T.iModule i) (eModuleEnv env)</span>
<span class="lineno">  292 </span><span class="spaces">      </span><span class="istickedoff">let ifc = MI.ifNames (ME.lmInterface lm)</span>
<span class="lineno">  293 </span><span class="spaces">          </span><span class="istickedoff">syms = MN.namingEnvFromNames $</span>
<span class="lineno">  294 </span><span class="spaces">                 </span><span class="istickedoff">case vis of</span>
<span class="lineno">  295 </span><span class="spaces">                   </span><span class="istickedoff">OnlyPublic       -&gt; MI.ifsPublic ifc</span>
<span class="lineno">  296 </span><span class="spaces">                   </span><span class="istickedoff">PublicAndPrivate -&gt; MI.ifsDefines ifc</span>
<span class="lineno">  297 </span><span class="spaces">      </span><span class="istickedoff">return $ MN.interpImportEnv i syms</span></span>
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>getAllIfaceDecls :: ME.ModuleEnv -&gt; M.IfaceDecls
<span class="lineno">  300 </span><span class="decl"><span class="istickedoff">getAllIfaceDecls me = mconcat (map (both . ME.lmInterface) (ME.getLoadedModules (ME.meLoadedModules me)))</span>
<span class="lineno">  301 </span><span class="spaces">  </span><span class="istickedoff">where both = MI.ifDefines</span></span>
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>-- Typecheck -------------------------------------------------------------------
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>runInferOutput :: TM.InferOutput a -&gt; MM.ModuleM a
<span class="lineno">  306 </span><span class="decl"><span class="istickedoff">runInferOutput out =</span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="istickedoff">case out of</span>
<span class="lineno">  308 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="istickedoff">TM.InferOK nm warns seeds supply o -&gt;</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">do MM.setNameSeeds seeds</span>
<span class="lineno">  311 </span><span class="spaces">         </span><span class="istickedoff">MM.setSupply supply</span>
<span class="lineno">  312 </span><span class="spaces">         </span><span class="istickedoff">MM.typeCheckWarnings <span class="nottickedoff">nm</span> warns</span>
<span class="lineno">  313 </span><span class="spaces">         </span><span class="istickedoff">return o</span>
<span class="lineno">  314 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  315 </span><span class="spaces">    </span><span class="istickedoff">TM.InferFailed nm warns errs -&gt;</span>
<span class="lineno">  316 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do MM.typeCheckWarnings nm warns</span></span>
<span class="lineno">  317 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">MM.typeCheckingFailed nm errs</span></span></span>
<span class="lineno">  318 </span>
<span class="lineno">  319 </span>-- Translate -------------------------------------------------------------------
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>mkCryEnv ::
<span class="lineno">  322 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  323 </span>  CryptolEnv -&gt; IO C.Env
<span class="lineno">  324 </span><span class="decl"><span class="istickedoff">mkCryEnv env =</span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="istickedoff">do let modEnv = eModuleEnv env</span>
<span class="lineno">  326 </span><span class="spaces">     </span><span class="istickedoff">let ifaceDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  327 </span><span class="spaces">     </span><span class="istickedoff">(types, _) &lt;-</span>
<span class="lineno">  328 </span><span class="spaces">       </span><span class="istickedoff">liftModuleM modEnv $</span>
<span class="lineno">  329 </span><span class="spaces">       </span><span class="istickedoff">do prims &lt;- MB.getPrimMap</span>
<span class="lineno">  330 </span><span class="spaces">          </span><span class="istickedoff">-- noIfaceParams because we don't support translating functors yet</span>
<span class="lineno">  331 </span><span class="spaces">          </span><span class="istickedoff">infInp &lt;- MB.genInferInput <span class="nottickedoff">P.emptyRange</span> prims NoParams ifaceDecls</span>
<span class="lineno">  332 </span><span class="spaces">          </span><span class="istickedoff">let newtypeCons = Map.fromList</span>
<span class="lineno">  333 </span><span class="spaces">                              </span><span class="istickedoff">[ con</span>
<span class="lineno">  334 </span><span class="spaces">                              </span><span class="istickedoff">| nt &lt;- Map.elems (TM.inpNominalTypes infInp)</span>
<span class="lineno">  335 </span><span class="spaces">                              </span><span class="istickedoff">, con &lt;- T.nominalTypeConTypes nt</span>
<span class="lineno">  336 </span><span class="spaces">                              </span><span class="istickedoff">]</span>
<span class="lineno">  337 </span><span class="spaces">          </span><span class="istickedoff">pure (newtypeCons `Map.union` TM.inpVars infInp)</span>
<span class="lineno">  338 </span><span class="spaces">     </span><span class="istickedoff">let types' = Map.union (eExtraTypes env) types</span>
<span class="lineno">  339 </span><span class="spaces">     </span><span class="istickedoff">let terms = eTermEnv env</span>
<span class="lineno">  340 </span><span class="spaces">     </span><span class="istickedoff">let cryEnv = C.emptyEnv</span>
<span class="lineno">  341 </span><span class="spaces">           </span><span class="istickedoff">{ C.envE = fmap (\t -&gt; (t, 0)) terms</span>
<span class="lineno">  342 </span><span class="spaces">           </span><span class="istickedoff">, C.envC = types'</span>
<span class="lineno">  343 </span><span class="spaces">           </span><span class="istickedoff">, C.envPrims = <span class="nottickedoff">ePrims env</span></span>
<span class="lineno">  344 </span><span class="spaces">           </span><span class="istickedoff">, C.envPrimTypes = <span class="nottickedoff">ePrimTypes env</span></span>
<span class="lineno">  345 </span><span class="spaces">           </span><span class="istickedoff">}</span>
<span class="lineno">  346 </span><span class="spaces">     </span><span class="istickedoff">return cryEnv</span></span>
<span class="lineno">  347 </span>
<span class="lineno">  348 </span>translateExpr ::
<span class="lineno">  349 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  350 </span>  SharedContext -&gt; CryptolEnv -&gt; T.Expr -&gt; IO Term
<span class="lineno">  351 </span><span class="decl"><span class="istickedoff">translateExpr sc env expr =</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="istickedoff">do cryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  353 </span><span class="spaces">     </span><span class="istickedoff">C.importExpr sc cryEnv expr</span></span>
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>translateDeclGroups ::
<span class="lineno">  356 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  357 </span>  SharedContext -&gt; CryptolEnv -&gt; [T.DeclGroup] -&gt; IO CryptolEnv
<span class="lineno">  358 </span><span class="decl"><span class="istickedoff">translateDeclGroups sc env dgs =</span>
<span class="lineno">  359 </span><span class="spaces">  </span><span class="istickedoff">do cryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  360 </span><span class="spaces">     </span><span class="istickedoff">cryEnv' &lt;- C.importTopLevelDeclGroups sc <span class="nottickedoff">C.defaultPrimitiveOptions</span> cryEnv dgs</span>
<span class="lineno">  361 </span><span class="spaces">     </span><span class="istickedoff">termEnv' &lt;- traverse (\(t, j) -&gt; incVars <span class="nottickedoff">sc</span> <span class="nottickedoff">0</span> j t) (C.envE cryEnv')</span>
<span class="lineno">  362 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  363 </span><span class="spaces">     </span><span class="istickedoff">let decls = concatMap T.groupDecls dgs</span>
<span class="lineno">  364 </span><span class="spaces">     </span><span class="istickedoff">let names = map T.dName decls</span>
<span class="lineno">  365 </span><span class="spaces">     </span><span class="istickedoff">let newTypes = Map.fromList [ (T.dName d, T.dSignature d) | d &lt;- decls ]</span>
<span class="lineno">  366 </span><span class="spaces">     </span><span class="istickedoff">let addName name = MR.shadowing (MN.singletonNS C.NSValue (P.mkUnqual (MN.nameIdent name)) name)</span>
<span class="lineno">  367 </span><span class="spaces">     </span><span class="istickedoff">return env</span>
<span class="lineno">  368 </span><span class="spaces">           </span><span class="istickedoff">{ eExtraNames = foldr addName (eExtraNames env) names</span>
<span class="lineno">  369 </span><span class="spaces">           </span><span class="istickedoff">, eExtraTypes = Map.union (eExtraTypes env) newTypes</span>
<span class="lineno">  370 </span><span class="spaces">           </span><span class="istickedoff">, eTermEnv = termEnv'</span>
<span class="lineno">  371 </span><span class="spaces">           </span><span class="istickedoff">}</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- | Translate all declarations in all loaded modules to SAWCore terms
<span class="lineno">  374 </span>genTermEnv :: SharedContext -&gt; ME.ModuleEnv -&gt; C.Env -&gt; IO (Map T.Name Term)
<span class="lineno">  375 </span><span class="decl"><span class="istickedoff">genTermEnv sc modEnv cryEnv0 = do</span>
<span class="lineno">  376 </span><span class="spaces">  </span><span class="istickedoff">let declGroups = concatMap T.mDecls</span>
<span class="lineno">  377 </span><span class="spaces">                 </span><span class="istickedoff">$ filter (not . T.isParametrizedModule)</span>
<span class="lineno">  378 </span><span class="spaces">                 </span><span class="istickedoff">$ ME.loadedModules modEnv</span>
<span class="lineno">  379 </span><span class="spaces">      </span><span class="istickedoff">nominals   = ME.loadedNominalTypes modEnv</span>
<span class="lineno">  380 </span><span class="spaces">  </span><span class="istickedoff">cryEnv1 &lt;- C.genCodeForNominalTypes sc nominals cryEnv0</span>
<span class="lineno">  381 </span><span class="spaces">  </span><span class="istickedoff">cryEnv2 &lt;- C.importTopLevelDeclGroups sc <span class="nottickedoff">C.defaultPrimitiveOptions</span> cryEnv1 declGroups</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="istickedoff">traverse (\(t, j) -&gt; incVars <span class="nottickedoff">sc</span> <span class="nottickedoff">0</span> j t) (C.envE cryEnv2)</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>--------------------------------------------------------------------------------
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>combineCryptolEnv :: CryptolEnv -&gt; CryptolEnv -&gt; IO CryptolEnv
<span class="lineno">  388 </span><span class="decl"><span class="istickedoff">combineCryptolEnv chkEnv newEnv =</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="istickedoff">do let <span class="nottickedoff">newMEnv = eModuleEnv newEnv</span></span>
<span class="lineno">  390 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">chkMEnv = eModuleEnv chkEnv</span></span>
<span class="lineno">  391 </span><span class="spaces">     </span><span class="istickedoff">let <span class="nottickedoff">menv' = chkMEnv{ ME.meNameSeeds = ME.meNameSeeds newMEnv }</span></span>
<span class="lineno">  392 </span><span class="spaces">     </span><span class="istickedoff">return <span class="nottickedoff">chkEnv{ eModuleEnv = menv' }</span></span></span>
<span class="lineno">  393 </span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>checkNotParameterized :: T.Module -&gt; IO ()
<span class="lineno">  396 </span><span class="decl"><span class="istickedoff">checkNotParameterized m =</span>
<span class="lineno">  397 </span><span class="spaces">  </span><span class="istickedoff">when (T.isParametrizedModule m) $</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">fail $ unlines [ &quot;Cannot load parameterized modules directly.&quot;</span></span>
<span class="lineno">  399 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">, &quot;Either use a ` import, or make a module instantiation.&quot;</span></span>
<span class="lineno">  400 </span><span class="spaces">                   </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>loadCryptolModule ::
<span class="lineno">  404 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  405 </span>  SharedContext -&gt;
<span class="lineno">  406 </span>  C.ImportPrimitiveOptions -&gt;
<span class="lineno">  407 </span>  CryptolEnv -&gt;
<span class="lineno">  408 </span>  FilePath -&gt;
<span class="lineno">  409 </span>  IO (CryptolModule, CryptolEnv)
<span class="lineno">  410 </span><span class="decl"><span class="nottickedoff">loadCryptolModule sc primOpts env path = do</span>
<span class="lineno">  411 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  412 </span><span class="spaces">  </span><span class="nottickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">(mtop, modEnv') &lt;- liftModuleM modEnv (MB.loadModuleByPath True path)</span>
<span class="lineno">  414 </span><span class="spaces">  </span><span class="nottickedoff">m &lt;- case mtop of</span>
<span class="lineno">  415 </span><span class="spaces">         </span><span class="nottickedoff">T.TCTopModule mo -&gt; pure mo</span>
<span class="lineno">  416 </span><span class="spaces">         </span><span class="nottickedoff">T.TCTopSignature {} -&gt;</span>
<span class="lineno">  417 </span><span class="spaces">            </span><span class="nottickedoff">fail $ &quot;Expected a module, but &quot; ++ show path ++ &quot; is an interface.&quot;</span>
<span class="lineno">  418 </span><span class="spaces">  </span><span class="nottickedoff">checkNotParameterized m</span>
<span class="lineno">  419 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  420 </span><span class="spaces">  </span><span class="nottickedoff">let ifaceDecls = getAllIfaceDecls modEnv'</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">(types, modEnv'') &lt;- liftModuleM modEnv' $ do</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="nottickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="nottickedoff">TM.inpVars `fmap` MB.genInferInput P.emptyRange prims NoParams ifaceDecls</span>
<span class="lineno">  424 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  425 </span><span class="spaces">  </span><span class="nottickedoff">-- Regenerate SharedTerm environment.</span>
<span class="lineno">  426 </span><span class="spaces">  </span><span class="nottickedoff">oldCryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  427 </span><span class="spaces">  </span><span class="nottickedoff">let oldModNames = map ME.lmName</span>
<span class="lineno">  428 </span><span class="spaces">                  </span><span class="nottickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  429 </span><span class="spaces">                  </span><span class="nottickedoff">$ ME.meLoadedModules modEnv</span>
<span class="lineno">  430 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  431 </span><span class="spaces">  </span><span class="nottickedoff">let isNew m'    = T.mName m' `notElem` oldModNames</span>
<span class="lineno">  432 </span><span class="spaces">  </span><span class="nottickedoff">let newModules  = filter isNew</span>
<span class="lineno">  433 </span><span class="spaces">                  </span><span class="nottickedoff">$ map ME.lmModule</span>
<span class="lineno">  434 </span><span class="spaces">                  </span><span class="nottickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  435 </span><span class="spaces">                  </span><span class="nottickedoff">$ ME.meLoadedModules modEnv''</span>
<span class="lineno">  436 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  437 </span><span class="spaces">  </span><span class="nottickedoff">let newDeclGroups = concatMap T.mDecls newModules</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="nottickedoff">let newNominal    = Map.difference (ME.loadedNominalTypes modEnv')</span>
<span class="lineno">  439 </span><span class="spaces">                                     </span><span class="nottickedoff">(ME.loadedNominalTypes modEnv)</span>
<span class="lineno">  440 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="nottickedoff">newTermEnv &lt;-</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="nottickedoff">do cEnv &lt;- C.genCodeForNominalTypes sc newNominal oldCryEnv</span>
<span class="lineno">  443 </span><span class="spaces">       </span><span class="nottickedoff">newCryEnv &lt;- C.importTopLevelDeclGroups sc primOpts cEnv newDeclGroups</span>
<span class="lineno">  444 </span><span class="spaces">       </span><span class="nottickedoff">traverse (\(t, j) -&gt; incVars sc 0 j t) (C.envE newCryEnv)</span>
<span class="lineno">  445 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  446 </span><span class="spaces">  </span><span class="nottickedoff">let names = MEx.exported C.NSValue (T.mExports m) -- :: Set T.Name</span>
<span class="lineno">  447 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  448 </span><span class="spaces">  </span><span class="nottickedoff">let tm'   = Map.filterWithKey (\k _ -&gt; Set.member k names) $</span>
<span class="lineno">  449 </span><span class="spaces">              </span><span class="nottickedoff">Map.intersectionWith</span>
<span class="lineno">  450 </span><span class="spaces">                </span><span class="nottickedoff">(\t x -&gt; TypedTerm (TypedTermSchema t) x)</span>
<span class="lineno">  451 </span><span class="spaces">                </span><span class="nottickedoff">types</span>
<span class="lineno">  452 </span><span class="spaces">                </span><span class="nottickedoff">newTermEnv</span>
<span class="lineno">  453 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="nottickedoff">let env' = updateFFITypes m</span>
<span class="lineno">  455 </span><span class="spaces">               </span><span class="nottickedoff">env { eModuleEnv = modEnv''</span>
<span class="lineno">  456 </span><span class="spaces">                   </span><span class="nottickedoff">, eTermEnv = newTermEnv</span>
<span class="lineno">  457 </span><span class="spaces">                   </span><span class="nottickedoff">}</span>
<span class="lineno">  458 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  459 </span><span class="spaces">  </span><span class="nottickedoff">let sm' = Map.filterWithKey</span>
<span class="lineno">  460 </span><span class="spaces">              </span><span class="nottickedoff">(\k _ -&gt; Set.member k (MEx.exported C.NSType (T.mExports m)))</span>
<span class="lineno">  461 </span><span class="spaces">              </span><span class="nottickedoff">(T.mTySyns m)</span>
<span class="lineno">  462 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  463 </span><span class="spaces">  </span><span class="nottickedoff">return (CryptolModule sm' tm', env')</span></span>
<span class="lineno">  464 </span>
<span class="lineno">  465 </span>updateFFITypes :: T.Module -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  466 </span><span class="decl"><span class="istickedoff">updateFFITypes m env = env { eFFITypes = eFFITypes' }</span>
<span class="lineno">  467 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  468 </span><span class="spaces">  </span><span class="istickedoff">eFFITypes' = foldr</span>
<span class="lineno">  469 </span><span class="spaces">    </span><span class="istickedoff">(\(nm, ty) -&gt; Map.insert (getNameInfo nm) ty)</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="istickedoff">(eFFITypes env)</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="istickedoff">(T.findForeignDecls m)</span>
<span class="lineno">  472 </span><span class="spaces">  </span><span class="istickedoff">getNameInfo nm =</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">case Map.lookup nm (eTermEnv env) of</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff">Just tm -&gt;</span>
<span class="lineno">  475 </span><span class="spaces">        </span><span class="istickedoff">case asConstant tm of</span>
<span class="lineno">  476 </span><span class="spaces">          </span><span class="istickedoff">Just n -&gt; nameInfo n</span>
<span class="lineno">  477 </span><span class="spaces">          </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  478 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">panic &quot;updateFFITypes&quot; [</span></span>
<span class="lineno">  479 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;SAWCore term of Cryptol name is not Constant&quot;,</span></span>
<span class="lineno">  480 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Name: &quot; &lt;&gt; Text.pack (show nm),</span></span>
<span class="lineno">  481 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">&quot;Term: &quot; &lt;&gt; Text.pack (showTerm tm)</span></span>
<span class="lineno">  482 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">]</span></span>
<span class="lineno">  483 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  484 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">panic &quot;updateFFITypes&quot; [</span></span>
<span class="lineno">  485 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot;Cannot find foreign function in term environment: &quot; &lt;&gt; Text.pack (show nm)</span></span>
<span class="lineno">  486 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">]</span></span></span>
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>bindCryptolModule :: (P.ModName, CryptolModule) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  489 </span><span class="decl"><span class="nottickedoff">bindCryptolModule (modName, CryptolModule sm tm) env =</span>
<span class="lineno">  490 </span><span class="spaces">  </span><span class="nottickedoff">env { eExtraNames = flip (foldr addName) (Map.keys tm') $</span>
<span class="lineno">  491 </span><span class="spaces">                      </span><span class="nottickedoff">flip (foldr addTSyn) (Map.keys sm) $ eExtraNames env</span>
<span class="lineno">  492 </span><span class="spaces">      </span><span class="nottickedoff">, eExtraTSyns = Map.union sm (eExtraTSyns env)</span>
<span class="lineno">  493 </span><span class="spaces">      </span><span class="nottickedoff">, eExtraTypes = Map.union (fmap fst tm') (eExtraTypes env)</span>
<span class="lineno">  494 </span><span class="spaces">      </span><span class="nottickedoff">, eTermEnv    = Map.union (fmap snd tm') (eTermEnv env)</span>
<span class="lineno">  495 </span><span class="spaces">      </span><span class="nottickedoff">}</span>
<span class="lineno">  496 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  497 </span><span class="spaces">    </span><span class="nottickedoff">-- select out those typed terms that have Cryptol schemas</span>
<span class="lineno">  498 </span><span class="spaces">    </span><span class="nottickedoff">tm' = Map.mapMaybe f tm</span>
<span class="lineno">  499 </span><span class="spaces">    </span><span class="nottickedoff">f (TypedTerm (TypedTermSchema s) x) = Just (s,x)</span>
<span class="lineno">  500 </span><span class="spaces">    </span><span class="nottickedoff">f _ = Nothing</span>
<span class="lineno">  501 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  502 </span><span class="spaces">    </span><span class="nottickedoff">addName name = MN.shadowing (MN.singletonNS C.NSValue (P.mkQual modName (MN.nameIdent name)) name)</span>
<span class="lineno">  503 </span><span class="spaces">    </span><span class="nottickedoff">addTSyn name = MN.shadowing (MN.singletonNS C.NSType (P.mkQual modName (MN.nameIdent name)) name)</span></span>
<span class="lineno">  504 </span>
<span class="lineno">  505 </span>lookupCryptolModule :: CryptolModule -&gt; Text -&gt; IO TypedTerm
<span class="lineno">  506 </span><span class="decl"><span class="nottickedoff">lookupCryptolModule (CryptolModule _ tm) name =</span>
<span class="lineno">  507 </span><span class="spaces">  </span><span class="nottickedoff">case Map.lookup (mkIdent name) (Map.mapKeys MN.nameIdent tm) of</span>
<span class="lineno">  508 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; fail $ Text.unpack $ &quot;Binding not found: &quot; &lt;&gt; name</span>
<span class="lineno">  509 </span><span class="spaces">    </span><span class="nottickedoff">Just t -&gt; return t</span></span>
<span class="lineno">  510 </span>
<span class="lineno">  511 </span>--------------------------------------------------------------------------------
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>importModule ::
<span class="lineno">  514 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  515 </span>  SharedContext             {- ^ Shared context for creating terms -} -&gt;
<span class="lineno">  516 </span>  CryptolEnv                {- ^ Extend this environment -} -&gt;
<span class="lineno">  517 </span>  Either FilePath P.ModName {- ^ Where to find the module -} -&gt;
<span class="lineno">  518 </span>  Maybe P.ModName           {- ^ Name qualifier -} -&gt;
<span class="lineno">  519 </span>  ImportVisibility          {- ^ What visibility to give symbols from this module -} -&gt;
<span class="lineno">  520 </span>  Maybe P.ImportSpec        {- ^ What to import -} -&gt;
<span class="lineno">  521 </span>  IO CryptolEnv
<span class="lineno">  522 </span><span class="decl"><span class="istickedoff">importModule sc env src as vis imps = do</span>
<span class="lineno">  523 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="istickedoff">(mtop, modEnv') &lt;-</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="istickedoff">liftModuleM modEnv $</span>
<span class="lineno">  526 </span><span class="spaces">    </span><span class="istickedoff">case src of</span>
<span class="lineno">  527 </span><span class="spaces">      </span><span class="istickedoff">Left path -&gt; MB.loadModuleByPath True path</span>
<span class="lineno">  528 </span><span class="spaces">      </span><span class="istickedoff">Right mn -&gt; <span class="nottickedoff">snd &lt;$&gt; MB.loadModuleFrom True (MM.FromModule mn)</span></span>
<span class="lineno">  529 </span><span class="spaces">  </span><span class="istickedoff">m &lt;- case mtop of</span>
<span class="lineno">  530 </span><span class="spaces">         </span><span class="istickedoff">T.TCTopModule m -&gt; pure m</span>
<span class="lineno">  531 </span><span class="spaces">         </span><span class="istickedoff">T.TCTopSignature {} -&gt;</span>
<span class="lineno">  532 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Expected a module but found an interface.&quot;</span></span>
<span class="lineno">  533 </span><span class="spaces">  </span><span class="istickedoff">checkNotParameterized m</span>
<span class="lineno">  534 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  535 </span><span class="spaces">  </span><span class="istickedoff">-- Regenerate SharedTerm environment.</span>
<span class="lineno">  536 </span><span class="spaces">  </span><span class="istickedoff">oldCryEnv &lt;- mkCryEnv env</span>
<span class="lineno">  537 </span><span class="spaces">  </span><span class="istickedoff">let oldModNames   = map ME.lmName</span>
<span class="lineno">  538 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  539 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.meLoadedModules modEnv</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="istickedoff">let isNew m'      = T.mName m' `notElem` oldModNames</span>
<span class="lineno">  541 </span><span class="spaces">  </span><span class="istickedoff">let newModules    = filter isNew</span>
<span class="lineno">  542 </span><span class="spaces">                    </span><span class="istickedoff">$ map ME.lmModule</span>
<span class="lineno">  543 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.lmLoadedModules</span>
<span class="lineno">  544 </span><span class="spaces">                    </span><span class="istickedoff">$ ME.meLoadedModules modEnv'</span>
<span class="lineno">  545 </span><span class="spaces">  </span><span class="istickedoff">let newDeclGroups = concatMap T.mDecls newModules</span>
<span class="lineno">  546 </span><span class="spaces">  </span><span class="istickedoff">let newNominal    = Map.difference (ME.loadedNominalTypes modEnv')</span>
<span class="lineno">  547 </span><span class="spaces">                                     </span><span class="istickedoff">(ME.loadedNominalTypes modEnv)</span>
<span class="lineno">  548 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  549 </span><span class="spaces">  </span><span class="istickedoff">newTermEnv &lt;-</span>
<span class="lineno">  550 </span><span class="spaces">    </span><span class="istickedoff">do cEnv      &lt;- C.genCodeForNominalTypes sc newNominal oldCryEnv</span>
<span class="lineno">  551 </span><span class="spaces">       </span><span class="istickedoff">newCryEnv &lt;- C.importTopLevelDeclGroups sc <span class="nottickedoff">C.defaultPrimitiveOptions</span></span>
<span class="lineno">  552 </span><span class="spaces">                                                            </span><span class="istickedoff">cEnv newDeclGroups</span>
<span class="lineno">  553 </span><span class="spaces">       </span><span class="istickedoff">traverse (\(t, j) -&gt; incVars <span class="nottickedoff">sc</span> <span class="nottickedoff">0</span> j t) (C.envE newCryEnv)</span>
<span class="lineno">  554 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  555 </span><span class="spaces">  </span><span class="istickedoff">return $</span>
<span class="lineno">  556 </span><span class="spaces">    </span><span class="istickedoff">updateFFITypes m</span>
<span class="lineno">  557 </span><span class="spaces">      </span><span class="istickedoff">env { eImports   = (vis, P.Import (T.mName m) as imps Nothing <span class="nottickedoff">Nothing</span>)</span>
<span class="lineno">  558 </span><span class="spaces">                       </span><span class="istickedoff">: eImports env</span>
<span class="lineno">  559 </span><span class="spaces">          </span><span class="istickedoff">, eModuleEnv = modEnv'</span>
<span class="lineno">  560 </span><span class="spaces">          </span><span class="istickedoff">, eTermEnv   = newTermEnv</span>
<span class="lineno">  561 </span><span class="spaces">          </span><span class="istickedoff">}</span></span>
<span class="lineno">  562 </span>
<span class="lineno">  563 </span>bindIdent :: Ident -&gt; CryptolEnv -&gt; (T.Name, CryptolEnv)
<span class="lineno">  564 </span><span class="decl"><span class="istickedoff">bindIdent ident env = (name, env')</span>
<span class="lineno">  565 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  566 </span><span class="spaces">    </span><span class="istickedoff">modEnv = eModuleEnv env</span>
<span class="lineno">  567 </span><span class="spaces">    </span><span class="istickedoff">supply = ME.meSupply modEnv</span>
<span class="lineno">  568 </span><span class="spaces">    </span><span class="istickedoff">fixity = Nothing</span>
<span class="lineno">  569 </span><span class="spaces">    </span><span class="istickedoff">(name, supply') = MN.mkDeclared <span class="nottickedoff">C.NSValue</span> (C.TopModule interactiveName) MN.UserName ident fixity P.emptyRange supply</span>
<span class="lineno">  570 </span><span class="spaces">    </span><span class="istickedoff">modEnv' = modEnv { ME.meSupply = supply' }</span>
<span class="lineno">  571 </span><span class="spaces">    </span><span class="istickedoff">env' = env { eModuleEnv = modEnv' }</span></span>
<span class="lineno">  572 </span>
<span class="lineno">  573 </span>bindTypedTerm :: (Ident, TypedTerm) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  574 </span><span class="decl"><span class="istickedoff">bindTypedTerm (ident, TypedTerm (TypedTermSchema schema) trm) env =</span>
<span class="lineno">  575 </span><span class="spaces">  </span><span class="istickedoff">env' { eExtraNames = MR.shadowing (MN.singletonNS C.NSValue pname name) (eExtraNames env)</span>
<span class="lineno">  576 </span><span class="spaces">       </span><span class="istickedoff">, eExtraTypes = Map.insert name schema (eExtraTypes env)</span>
<span class="lineno">  577 </span><span class="spaces">       </span><span class="istickedoff">, eTermEnv    = Map.insert name trm (eTermEnv env)</span>
<span class="lineno">  578 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  580 </span><span class="spaces">    </span><span class="istickedoff">pname = P.mkUnqual ident</span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">(name, env') = bindIdent ident env</span>
<span class="lineno">  582 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  583 </span><span class="spaces"></span><span class="istickedoff">-- Only bind terms that have Cryptol schemas</span>
<span class="lineno">  584 </span><span class="spaces"></span><span class="istickedoff">bindTypedTerm _ env = env</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>
<span class="lineno">  587 </span>bindType :: (Ident, T.Schema) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  588 </span><span class="decl"><span class="nottickedoff">bindType (ident, T.Forall [] [] ty) env =</span>
<span class="lineno">  589 </span><span class="spaces">  </span><span class="nottickedoff">env' { eExtraNames = MR.shadowing (MN.singletonNS C.NSType pname name) (eExtraNames env)</span>
<span class="lineno">  590 </span><span class="spaces">       </span><span class="nottickedoff">, eExtraTSyns = Map.insert name tysyn (eExtraTSyns env)</span>
<span class="lineno">  591 </span><span class="spaces">       </span><span class="nottickedoff">}</span>
<span class="lineno">  592 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="nottickedoff">pname = P.mkUnqual ident</span>
<span class="lineno">  594 </span><span class="spaces">    </span><span class="nottickedoff">(name, env') = bindIdent ident env</span>
<span class="lineno">  595 </span><span class="spaces">    </span><span class="nottickedoff">tysyn = T.TySyn name [] [] ty Nothing</span>
<span class="lineno">  596 </span><span class="spaces"></span><span class="nottickedoff">bindType _ env = env</span></span> -- only monomorphic types may be bound
<span class="lineno">  597 </span>
<span class="lineno">  598 </span>bindInteger :: (Ident, Integer) -&gt; CryptolEnv -&gt; CryptolEnv
<span class="lineno">  599 </span><span class="decl"><span class="istickedoff">bindInteger (ident, n) env =</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="istickedoff">env' { eExtraNames = MR.shadowing (MN.singletonNS C.NSType pname name) (eExtraNames env)</span>
<span class="lineno">  601 </span><span class="spaces">       </span><span class="istickedoff">, eExtraTSyns = Map.insert name tysyn (eExtraTSyns env)</span>
<span class="lineno">  602 </span><span class="spaces">       </span><span class="istickedoff">}</span>
<span class="lineno">  603 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="istickedoff">pname = P.mkUnqual ident</span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="istickedoff">(name, env') = bindIdent <span class="nottickedoff">ident</span> env</span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="istickedoff">tysyn = T.TySyn <span class="nottickedoff">name</span> [] [] (T.tNum n) Nothing</span></span>
<span class="lineno">  607 </span>
<span class="lineno">  608 </span>--------------------------------------------------------------------------------
<span class="lineno">  609 </span>
<span class="lineno">  610 </span>meSolverConfig :: ME.ModuleEnv -&gt; TM.SolverConfig
<span class="lineno">  611 </span><span class="decl"><span class="istickedoff">meSolverConfig env = TM.defaultSolverConfig (ME.meSearchPath env)</span></span>
<span class="lineno">  612 </span>
<span class="lineno">  613 </span>resolveIdentifier ::
<span class="lineno">  614 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  615 </span>  CryptolEnv -&gt; Text -&gt; IO (Maybe T.Name)
<span class="lineno">  616 </span><span class="decl"><span class="istickedoff">resolveIdentifier env nm =</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="istickedoff">case splitOn (pack &quot;::&quot;) nm of</span>
<span class="lineno">  618 </span><span class="spaces">    </span><span class="istickedoff">[]  -&gt; <span class="nottickedoff">pure Nothing</span></span>
<span class="lineno">  619 </span><span class="spaces">    </span><span class="istickedoff">[i] -&gt; doResolve (P.UnQual (C.mkIdent i))</span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="istickedoff">xs  -&gt; <span class="nottickedoff">let (qs,i) = (init xs, last xs)</span></span>
<span class="lineno">  621 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">in doResolve (P.Qual (C.packModName qs) (C.mkIdent i))</span></span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="istickedoff">modEnv = eModuleEnv env</span>
<span class="lineno">  624 </span><span class="spaces">  </span><span class="istickedoff">nameEnv = getNamingEnv env</span>
<span class="lineno">  625 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="istickedoff">doResolve pnm =</span>
<span class="lineno">  627 </span><span class="spaces">    </span><span class="istickedoff">SMT.withSolver (return <span class="nottickedoff">()</span>) (meSolverConfig modEnv) $ \s -&gt;</span>
<span class="lineno">  628 </span><span class="spaces">    </span><span class="istickedoff">do let minp = MM.ModuleInput <span class="nottickedoff">True</span> <span class="nottickedoff">(pure defaultEvalOpts)</span> <span class="nottickedoff">?fileReader</span> modEnv</span>
<span class="lineno">  629 </span><span class="spaces">       </span><span class="istickedoff">(res, _ws) &lt;- MM.runModuleM (minp <span class="nottickedoff">s</span>) $</span>
<span class="lineno">  630 </span><span class="spaces">          </span><span class="istickedoff">MM.interactive (MB.rename interactiveName nameEnv (MR.renameVar MR.NameUse pnm))</span>
<span class="lineno">  631 </span><span class="spaces">       </span><span class="istickedoff">case res of</span>
<span class="lineno">  632 </span><span class="spaces">         </span><span class="istickedoff">Left _ -&gt; pure Nothing</span>
<span class="lineno">  633 </span><span class="spaces">         </span><span class="istickedoff">Right (x,_) -&gt; pure (Just x)</span></span>
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>
<span class="lineno">  636 </span>parseTypedTerm ::
<span class="lineno">  637 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  638 </span>  SharedContext -&gt; CryptolEnv -&gt; InputText -&gt; IO TypedTerm
<span class="lineno">  639 </span><span class="decl"><span class="istickedoff">parseTypedTerm sc env input = do</span>
<span class="lineno">  640 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  641 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  642 </span><span class="spaces">  </span><span class="istickedoff">-- Parse</span>
<span class="lineno">  643 </span><span class="spaces">  </span><span class="istickedoff">pexpr &lt;- ioParseExpr input</span>
<span class="lineno">  644 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  645 </span><span class="spaces">  </span><span class="istickedoff">((expr, schema), modEnv') &lt;- liftModuleM modEnv $ do</span>
<span class="lineno">  646 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="istickedoff">-- Eliminate patterns</span>
<span class="lineno">  648 </span><span class="spaces">    </span><span class="istickedoff">npe &lt;- MM.interactive (MB.noPat pexpr)</span>
<span class="lineno">  649 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  650 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve names</span>
<span class="lineno">  651 </span><span class="spaces">    </span><span class="istickedoff">let nameEnv = getNamingEnv env</span>
<span class="lineno">  652 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  653 </span><span class="spaces">    </span><span class="istickedoff">re &lt;- MM.interactive (MB.rename interactiveName nameEnv (MR.rename npe))</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  655 </span><span class="spaces">    </span><span class="istickedoff">-- Infer types</span>
<span class="lineno">  656 </span><span class="spaces">    </span><span class="istickedoff">let ifDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  657 </span><span class="spaces">    </span><span class="istickedoff">let range = fromMaybe <span class="nottickedoff">P.emptyRange</span> (P.getLoc re)</span>
<span class="lineno">  658 </span><span class="spaces">    </span><span class="istickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  659 </span><span class="spaces">    </span><span class="istickedoff">-- noIfaceParams because we don't support functors yet</span>
<span class="lineno">  660 </span><span class="spaces">    </span><span class="istickedoff">tcEnv &lt;- MB.genInferInput range prims NoParams ifDecls</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="istickedoff">let tcEnv' = tcEnv { TM.inpVars = Map.union (eExtraTypes env) (TM.inpVars tcEnv)</span>
<span class="lineno">  662 </span><span class="spaces">                       </span><span class="istickedoff">, TM.inpTSyns = Map.union (eExtraTSyns env) (TM.inpTSyns tcEnv)</span>
<span class="lineno">  663 </span><span class="spaces">                       </span><span class="istickedoff">}</span>
<span class="lineno">  664 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  665 </span><span class="spaces">    </span><span class="istickedoff">out &lt;- MM.io (T.tcExpr re tcEnv')</span>
<span class="lineno">  666 </span><span class="spaces">    </span><span class="istickedoff">MM.interactive (runInferOutput out)</span>
<span class="lineno">  667 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  668 </span><span class="spaces">  </span><span class="istickedoff">let env' = env { eModuleEnv = modEnv' }</span>
<span class="lineno">  669 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  670 </span><span class="spaces">  </span><span class="istickedoff">-- Translate</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="istickedoff">trm &lt;- translateExpr sc env' expr</span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="istickedoff">return (TypedTerm (TypedTermSchema schema) trm)</span></span>
<span class="lineno">  673 </span>
<span class="lineno">  674 </span>parseDecls ::
<span class="lineno">  675 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  676 </span>  SharedContext -&gt; CryptolEnv -&gt; InputText -&gt; IO CryptolEnv
<span class="lineno">  677 </span><span class="decl"><span class="istickedoff">parseDecls sc env input = do</span>
<span class="lineno">  678 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  679 </span><span class="spaces">  </span><span class="istickedoff">let ifaceDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  680 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="istickedoff">-- Parse</span>
<span class="lineno">  682 </span><span class="spaces">  </span><span class="istickedoff">(decls :: [P.Decl P.PName]) &lt;- ioParseDecls input</span>
<span class="lineno">  683 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  684 </span><span class="spaces">  </span><span class="istickedoff">(tmodule, modEnv') &lt;- liftModuleM modEnv $ do</span>
<span class="lineno">  685 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  686 </span><span class="spaces">    </span><span class="istickedoff">-- Eliminate patterns</span>
<span class="lineno">  687 </span><span class="spaces">    </span><span class="istickedoff">(npdecls :: [P.Decl P.PName]) &lt;- MM.interactive (MB.noPat decls)</span>
<span class="lineno">  688 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="istickedoff">-- Convert from 'Decl' to 'TopDecl' so that types will be generalized</span>
<span class="lineno">  690 </span><span class="spaces">    </span><span class="istickedoff">let topdecls = [ P.Decl (P.TopLevel P.Public Nothing d) | d &lt;- npdecls ]</span>
<span class="lineno">  691 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  692 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve names</span>
<span class="lineno">  693 </span><span class="spaces">    </span><span class="istickedoff">(_nenv, rdecls) &lt;- MM.interactive (MB.rename interactiveName (getNamingEnv env) (MR.renameTopDecls interactiveName topdecls))</span>
<span class="lineno">  694 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  695 </span><span class="spaces">    </span><span class="istickedoff">-- Create a Module to contain the declarations</span>
<span class="lineno">  696 </span><span class="spaces">    </span><span class="istickedoff">let rmodule = P.Module { P.mName = P.Located P.emptyRange interactiveName</span>
<span class="lineno">  697 </span><span class="spaces">                           </span><span class="istickedoff">, P.mDef  = P.NormalModule rdecls</span>
<span class="lineno">  698 </span><span class="spaces">                           </span><span class="istickedoff">, P.mInScope = <span class="nottickedoff">mempty</span></span>
<span class="lineno">  699 </span><span class="spaces">                           </span><span class="istickedoff">, P.mDocTop = Nothing</span>
<span class="lineno">  700 </span><span class="spaces">                           </span><span class="istickedoff">}</span>
<span class="lineno">  701 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  702 </span><span class="spaces">    </span><span class="istickedoff">-- Infer types</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">range = fromMaybe P.emptyRange (P.getLoc rdecls)</span></span>
<span class="lineno">  704 </span><span class="spaces">    </span><span class="istickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">-- noIfaceParams because we don't support functors yet</span>
<span class="lineno">  706 </span><span class="spaces">    </span><span class="istickedoff">tcEnv &lt;- MB.genInferInput <span class="nottickedoff">range</span> prims NoParams ifaceDecls</span>
<span class="lineno">  707 </span><span class="spaces">    </span><span class="istickedoff">let tcEnv' = tcEnv { TM.inpVars = Map.union (eExtraTypes env) (TM.inpVars tcEnv)</span>
<span class="lineno">  708 </span><span class="spaces">                       </span><span class="istickedoff">, TM.inpTSyns = Map.union (eExtraTSyns env) (TM.inpTSyns tcEnv)</span>
<span class="lineno">  709 </span><span class="spaces">                       </span><span class="istickedoff">}</span>
<span class="lineno">  710 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  711 </span><span class="spaces">    </span><span class="istickedoff">out &lt;- MM.io (TM.runInferM tcEnv' (TI.inferTopModule rmodule))</span>
<span class="lineno">  712 </span><span class="spaces">    </span><span class="istickedoff">tmodule &lt;- MM.interactive (runInferOutput out)</span>
<span class="lineno">  713 </span><span class="spaces">    </span><span class="istickedoff">m &lt;- case tmodule of</span>
<span class="lineno">  714 </span><span class="spaces">           </span><span class="istickedoff">T.TCTopModule m -&gt; pure m</span>
<span class="lineno">  715 </span><span class="spaces">           </span><span class="istickedoff">T.TCTopSignature {} -&gt;</span>
<span class="lineno">  716 </span><span class="spaces">              </span><span class="istickedoff"><span class="nottickedoff">fail &quot;Expected a module, but found an interface.&quot;</span></span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">return m</span>
<span class="lineno">  718 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="istickedoff">-- Add new type synonyms and their name bindings to the environment</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">let syns' = Map.union (eExtraTSyns env) (T.mTySyns tmodule)</span>
<span class="lineno">  721 </span><span class="spaces">  </span><span class="istickedoff">let addName name = MR.shadowing (MN.singletonNS C.NSType (P.mkUnqual (MN.nameIdent name)) <span class="nottickedoff">name</span>)</span>
<span class="lineno">  722 </span><span class="spaces">  </span><span class="istickedoff">let names' = foldr addName (eExtraNames env) (Map.keys (T.mTySyns tmodule))</span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="istickedoff">let env' = env { eModuleEnv = modEnv', eExtraNames = names', eExtraTSyns = syns' }</span>
<span class="lineno">  724 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="istickedoff">-- Translate</span>
<span class="lineno">  726 </span><span class="spaces">  </span><span class="istickedoff">let dgs = T.mDecls tmodule</span>
<span class="lineno">  727 </span><span class="spaces">  </span><span class="istickedoff">translateDeclGroups sc env' dgs</span></span>
<span class="lineno">  728 </span>
<span class="lineno">  729 </span>parseSchema ::
<span class="lineno">  730 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  731 </span>  CryptolEnv -&gt; InputText -&gt; IO T.Schema
<span class="lineno">  732 </span><span class="decl"><span class="istickedoff">parseSchema env input = do</span>
<span class="lineno">  733 </span><span class="spaces">  </span><span class="istickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  734 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="istickedoff">-- Parse</span>
<span class="lineno">  736 </span><span class="spaces">  </span><span class="istickedoff">pschema &lt;- ioParseSchema input</span>
<span class="lineno">  737 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  738 </span><span class="spaces">  </span><span class="istickedoff">fmap fst $ liftModuleM modEnv $ do</span>
<span class="lineno">  739 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  740 </span><span class="spaces">    </span><span class="istickedoff">-- Resolve names</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">let nameEnv = getNamingEnv env</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">rschema &lt;- MM.interactive (MB.rename interactiveName nameEnv (MR.rename pschema))</span>
<span class="lineno">  743 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="istickedoff">let ifDecls = getAllIfaceDecls modEnv</span>
<span class="lineno">  745 </span><span class="spaces">    </span><span class="istickedoff">let <span class="nottickedoff">range = fromMaybe P.emptyRange (P.getLoc rschema)</span></span>
<span class="lineno">  746 </span><span class="spaces">    </span><span class="istickedoff">prims &lt;- MB.getPrimMap</span>
<span class="lineno">  747 </span><span class="spaces">    </span><span class="istickedoff">-- noIfaceParams because we don't support functors yet</span>
<span class="lineno">  748 </span><span class="spaces">    </span><span class="istickedoff">tcEnv &lt;- MB.genInferInput <span class="nottickedoff">range</span> prims NoParams ifDecls</span>
<span class="lineno">  749 </span><span class="spaces">    </span><span class="istickedoff">let tcEnv' = tcEnv { TM.inpTSyns = Map.union (eExtraTSyns env) (TM.inpTSyns tcEnv) }</span>
<span class="lineno">  750 </span><span class="spaces">    </span><span class="istickedoff">let infer =</span>
<span class="lineno">  751 </span><span class="spaces">          </span><span class="istickedoff">case rschema of</span>
<span class="lineno">  752 </span><span class="spaces">            </span><span class="istickedoff">P.Forall [] [] t _ -&gt; do</span>
<span class="lineno">  753 </span><span class="spaces">              </span><span class="istickedoff">let k = Nothing -- allow either kind KNum or KType</span>
<span class="lineno">  754 </span><span class="spaces">              </span><span class="istickedoff">(t', goals) &lt;- TM.collectGoals $ TK.checkType t k</span>
<span class="lineno">  755 </span><span class="spaces">              </span><span class="istickedoff">return (T.Forall [] [] t', goals)</span>
<span class="lineno">  756 </span><span class="spaces">            </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">TK.checkSchema TM.AllowWildCards rschema</span></span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff">out &lt;- MM.io (TM.runInferM tcEnv' infer)</span>
<span class="lineno">  758 </span><span class="spaces">    </span><span class="istickedoff">(schema, _goals) &lt;- MM.interactive (runInferOutput out)</span>
<span class="lineno">  759 </span><span class="spaces">    </span><span class="istickedoff">--mapM_ (MM.io . print . TP.ppWithNames TP.emptyNameMap) goals</span>
<span class="lineno">  760 </span><span class="spaces">    </span><span class="istickedoff">return (schemaNoUser schema)</span></span>
<span class="lineno">  761 </span>
<span class="lineno">  762 </span>declareName ::
<span class="lineno">  763 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  764 </span>  CryptolEnv -&gt; P.ModName -&gt; Text -&gt; IO (T.Name, CryptolEnv)
<span class="lineno">  765 </span><span class="decl"><span class="nottickedoff">declareName env mname input = do</span>
<span class="lineno">  766 </span><span class="spaces">  </span><span class="nottickedoff">let pname = P.mkUnqual (mkIdent input)</span>
<span class="lineno">  767 </span><span class="spaces">  </span><span class="nottickedoff">let modEnv = eModuleEnv env</span>
<span class="lineno">  768 </span><span class="spaces">  </span><span class="nottickedoff">(cname, modEnv') &lt;-</span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="nottickedoff">liftModuleM modEnv $ MM.interactive $</span>
<span class="lineno">  770 </span><span class="spaces">    </span><span class="nottickedoff">MN.liftSupply (MN.mkDeclared C.NSValue (C.TopModule mname) MN.UserName (P.getIdent pname) Nothing P.emptyRange)</span>
<span class="lineno">  771 </span><span class="spaces">  </span><span class="nottickedoff">let env' = env { eModuleEnv = modEnv' }</span>
<span class="lineno">  772 </span><span class="spaces">  </span><span class="nottickedoff">return (cname, env')</span></span>
<span class="lineno">  773 </span>
<span class="lineno">  774 </span>typeNoUser :: T.Type -&gt; T.Type
<span class="lineno">  775 </span><span class="decl"><span class="istickedoff">typeNoUser t =</span>
<span class="lineno">  776 </span><span class="spaces">  </span><span class="istickedoff">case t of</span>
<span class="lineno">  777 </span><span class="spaces">    </span><span class="istickedoff">T.TCon tc ts   -&gt; T.TCon tc (map typeNoUser ts)</span>
<span class="lineno">  778 </span><span class="spaces">    </span><span class="istickedoff">T.TVar {}      -&gt; <span class="nottickedoff">t</span></span>
<span class="lineno">  779 </span><span class="spaces">    </span><span class="istickedoff">T.TUser _ _ ty -&gt; typeNoUser ty</span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="istickedoff">T.TRec fields  -&gt; <span class="nottickedoff">T.TRec (fmap typeNoUser fields)</span></span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="istickedoff">T.TNominal nt ts -&gt; <span class="nottickedoff">T.TNominal nt (fmap typeNoUser ts)</span></span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>schemaNoUser :: T.Schema -&gt; T.Schema
<span class="lineno">  784 </span><span class="decl"><span class="istickedoff">schemaNoUser (T.Forall params props ty) = T.Forall params props (typeNoUser ty)</span></span>
<span class="lineno">  785 </span>
<span class="lineno">  786 </span>------------------------------------------------------------
<span class="lineno">  787 </span>
<span class="lineno">  788 </span>liftModuleM ::
<span class="lineno">  789 </span>  (?fileReader :: FilePath -&gt; IO ByteString) =&gt;
<span class="lineno">  790 </span>  ME.ModuleEnv -&gt; MM.ModuleM a -&gt; IO (a, ME.ModuleEnv)
<span class="lineno">  791 </span><span class="decl"><span class="istickedoff">liftModuleM env m =</span>
<span class="lineno">  792 </span><span class="spaces">  </span><span class="istickedoff">do let minp = MM.ModuleInput True (pure defaultEvalOpts) ?fileReader env</span>
<span class="lineno">  793 </span><span class="spaces">     </span><span class="istickedoff">SMT.withSolver (return <span class="nottickedoff">()</span>) (meSolverConfig env) $ \s -&gt;</span>
<span class="lineno">  794 </span><span class="spaces">       </span><span class="istickedoff">MM.runModuleM (minp s) m &gt;&gt;= moduleCmdResult</span></span>
<span class="lineno">  795 </span>
<span class="lineno">  796 </span>defaultEvalOpts :: E.EvalOpts
<span class="lineno">  797 </span><span class="decl"><span class="istickedoff">defaultEvalOpts = E.EvalOpts quietLogger <span class="nottickedoff">E.defaultPPOpts</span></span></span>
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>moduleCmdResult :: M.ModuleRes a -&gt; IO (a, ME.ModuleEnv)
<span class="lineno">  800 </span><span class="decl"><span class="istickedoff">moduleCmdResult (res, ws) = do</span>
<span class="lineno">  801 </span><span class="spaces">  </span><span class="istickedoff">mapM_ (print . pp) (concatMap suppressDefaulting ws)</span>
<span class="lineno">  802 </span><span class="spaces">  </span><span class="istickedoff">case res of</span>
<span class="lineno">  803 </span><span class="spaces">    </span><span class="istickedoff">Right (a, me) -&gt; return (a, me)</span>
<span class="lineno">  804 </span><span class="spaces">    </span><span class="istickedoff">Left err      -&gt; <span class="nottickedoff">fail $ &quot;Cryptol error:\n&quot; ++ show (pp err)</span> -- X.throwIO (ModuleSystemError err)</span>
<span class="lineno">  805 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  806 </span><span class="spaces">    </span><span class="istickedoff">-- If all warnings are about type defaults, pretend there are no warnings at</span>
<span class="lineno">  807 </span><span class="spaces">    </span><span class="istickedoff">-- all to avoid displaying an empty warning container.</span>
<span class="lineno">  808 </span><span class="spaces">    </span><span class="istickedoff">suppressDefaulting :: MM.ModuleWarning -&gt; [MM.ModuleWarning]</span>
<span class="lineno">  809 </span><span class="spaces">    </span><span class="istickedoff">suppressDefaulting w =</span>
<span class="lineno">  810 </span><span class="spaces">      </span><span class="istickedoff">case w of</span>
<span class="lineno">  811 </span><span class="spaces">        </span><span class="istickedoff">MM.RenamerWarnings xs -&gt; [MM.RenamerWarnings xs]</span>
<span class="lineno">  812 </span><span class="spaces">        </span><span class="istickedoff">MM.TypeCheckWarnings nm xs -&gt;</span>
<span class="lineno">  813 </span><span class="spaces">          </span><span class="istickedoff">case filter (notDefaulting . snd) xs of</span>
<span class="lineno">  814 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; []</span>
<span class="lineno">  815 </span><span class="spaces">            </span><span class="istickedoff">xs' -&gt; [MM.TypeCheckWarnings <span class="nottickedoff">nm</span> xs']</span>
<span class="lineno">  816 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  817 </span><span class="spaces">    </span><span class="istickedoff">notDefaulting :: TE.Warning -&gt; Bool</span>
<span class="lineno">  818 </span><span class="spaces">    </span><span class="istickedoff">notDefaulting (TE.DefaultingTo {}) = False</span>
<span class="lineno">  819 </span><span class="spaces">    </span><span class="istickedoff">notDefaulting _ = True</span></span>

</pre>
</body>
</html>
