<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# Language BlockArguments #-}
<span class="lineno">    2 </span>{-# Language DeriveFunctor #-}
<span class="lineno">    3 </span>{-# Language FlexibleInstances, MultiParamTypeClasses #-} -- MonadState
<span class="lineno">    4 </span>{-# Language PolyKinds #-} -- gopenBinding
<span class="lineno">    5 </span>{-# Language TypeFamilies #-} -- Equality constraints
<span class="lineno">    6 </span>{-# Language TypeOperators #-} -- Equality constraints
<span class="lineno">    7 </span>{-# Language RankNTypes #-}
<span class="lineno">    8 </span>module Heapster.GenMonad (
<span class="lineno">    9 </span>  -- * Core definitions
<span class="lineno">   10 </span>  GenStateContT(..), (&gt;&gt;&gt;=), (&gt;&gt;&gt;),
<span class="lineno">   11 </span>  -- * Continuation operations
<span class="lineno">   12 </span>  gcaptureCC, gmapRet, gabortM, gparallel, startBinding,
<span class="lineno">   13 </span>  startNamedBinding, gopenBinding, gopenNamedBinding,
<span class="lineno">   14 </span>  -- * State operations
<span class="lineno">   15 </span>  gmodify, gput,
<span class="lineno">   16 </span>  -- * Transformations
<span class="lineno">   17 </span>  addReader,
<span class="lineno">   18 </span>  ) where
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>import Data.Binding.Hobbits ( nuMulti, nuMultiWithElim1, Mb, Name, RAssign )
<span class="lineno">   21 </span>import Control.Monad ( ap )
<span class="lineno">   22 </span>import Control.Monad.State ( MonadState(get, put) )
<span class="lineno">   23 </span>import Control.Monad.Trans.Class ( MonadTrans(lift) )
<span class="lineno">   24 </span>import Control.Monad.Trans.Reader
<span class="lineno">   25 </span>import Data.Proxy
<span class="lineno">   26 </span>import Heapster.NamedMb
<span class="lineno">   27 </span>
<span class="lineno">   28 </span>-- | The generalized state-continuation monad
<span class="lineno">   29 </span>newtype GenStateContT s1 r1 s2 r2 m a = GenStateContT {
<span class="lineno">   30 </span>  <span class="nottickedoff"><span class="decl"><span class="nottickedoff">runGenStateContT</span></span></span> :: s2 -&gt; (s1 -&gt; a -&gt; m r1) -&gt; m r2
<span class="lineno">   31 </span>  } deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>-- | Sequence two 'GenStateCont' values. Type-changing analogue of '&gt;&gt;='
<span class="lineno">   34 </span>(&gt;&gt;&gt;=) :: GenStateContT s2 r2 s1 r1 m a -&gt; (a -&gt; GenStateContT s3 r3 s2 r2 m b) -&gt; GenStateContT s3 r3 s1 r1 m b
<span class="lineno">   35 </span><span class="decl"><span class="nottickedoff">x &gt;&gt;&gt;= y = GenStateContT \s1 z -&gt; runGenStateContT x s1 \s2 a -&gt; runGenStateContT (y a) s2 z</span></span>
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>-- | Sequence two 'GenStateCont' values ignoring the return value. Type-changing analogue of '&gt;&gt;'
<span class="lineno">   38 </span>(&gt;&gt;&gt;) :: GenStateContT s2 r2 s1 r1 m a -&gt; GenStateContT s3 r3 s2 r2 m b -&gt; GenStateContT s3 r3 s1 r1 m b
<span class="lineno">   39 </span><span class="decl"><span class="nottickedoff">m1 &gt;&gt;&gt; m2 = m1 &gt;&gt;&gt;= \_ -&gt; m2</span></span>
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>infixl 1 &gt;&gt;&gt;=, &gt;&gt;&gt;
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>-- NB. These instance must be specified as
<span class="lineno">   44 </span>-- instance (s1 ~ s2, r1 ~ r2) =&gt; Applicative (GenStateContT s1 r1 s2 r2) where
<span class="lineno">   45 </span>-- instead of
<span class="lineno">   46 </span>-- instance Applicative (GenStateContT s r s r) where
<span class="lineno">   47 </span>-- in order to ensure they are quickly selected by GHC even when it's not
<span class="lineno">   48 </span>-- immediately obvious that the types are equal.
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(s1 ~ s2, r1 ~ r2) =&gt; Applicative (GenStateContT s1 r1 s2 r2 m)</span></span></span></span></span></span> where
<span class="lineno">   51 </span>  <span class="decl"><span class="nottickedoff">pure x = GenStateContT \s k -&gt; k s x</span></span>
<span class="lineno">   52 </span>  <span class="decl"><span class="nottickedoff">(&lt;*&gt;) = ap</span></span>
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">(s1 ~ s2, r1 ~ r2) =&gt; Monad (GenStateContT s1 r1 s2 r2 m)</span></span></span></span> where
<span class="lineno">   55 </span>  <span class="decl"><span class="nottickedoff">(&gt;&gt;=) = (&gt;&gt;&gt;=)</span></span>
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>instance (s1 ~ s2, r1 ~ r2) =&gt; MonadTrans (GenStateContT s1 r1 s2 r2) where
<span class="lineno">   58 </span>  <span class="decl"><span class="nottickedoff">lift m = gcaptureCC (m &gt;&gt;=)</span></span>
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>-----------------------------------------------------------------------
<span class="lineno">   61 </span>-- Continuation operations
<span class="lineno">   62 </span>-----------------------------------------------------------------------
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>-- | Capture the current continuation while preserving the state.
<span class="lineno">   65 </span>gcaptureCC :: ((a -&gt; m r1) -&gt; m r2) -&gt; GenStateContT s r1 s r2 m a
<span class="lineno">   66 </span><span class="decl"><span class="nottickedoff">gcaptureCC f = GenStateContT \s k -&gt; f (k s)</span></span>
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>-- | Run two generalized monad computations \&quot;in parallel\&quot; and combine their
<span class="lineno">   69 </span>-- results
<span class="lineno">   70 </span>gparallel ::
<span class="lineno">   71 </span>  (m r1 -&gt; m r2 -&gt; m r3) -&gt;
<span class="lineno">   72 </span>  GenStateContT s1 r s2 r1 m a -&gt;
<span class="lineno">   73 </span>  GenStateContT s1 r s2 r2 m a -&gt;
<span class="lineno">   74 </span>  GenStateContT s1 r s2 r3 m a
<span class="lineno">   75 </span><span class="decl"><span class="nottickedoff">gparallel f (GenStateContT m1) (GenStateContT m2) = GenStateContT \s k -&gt; f (m1 s k) (m2 s k)</span></span>
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>-- | Abort the current state-continuation computation and just return an @r2@
<span class="lineno">   78 </span>gabortM :: m r2 -&gt; GenStateContT s1 r1 s2 r2 m a
<span class="lineno">   79 </span><span class="decl"><span class="nottickedoff">gabortM ret = GenStateContT \_ _ -&gt; ret</span></span>
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>-----------------------------------------------------------------------
<span class="lineno">   82 </span>-- State operations
<span class="lineno">   83 </span>-----------------------------------------------------------------------
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>instance <span class="decl"><span class="nottickedoff">(s1 ~ s2, r1 ~ r2) =&gt; MonadState s1 (GenStateContT s1 r1 s2 r2 m)</span></span> where
<span class="lineno">   86 </span>  <span class="decl"><span class="nottickedoff">get = GenStateContT \s k -&gt; k s s</span></span>
<span class="lineno">   87 </span>  <span class="decl"><span class="nottickedoff">put = gput</span></span>
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>-- | Overwrite the previous state value (with the ability to change its type)
<span class="lineno">   90 </span>gput :: s -&gt; GenStateContT s r s_ r m ()
<span class="lineno">   91 </span><span class="decl"><span class="nottickedoff">gput s = GenStateContT \_ k -&gt; k s ()</span></span>
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-----------------------------------------------------------------------
<span class="lineno">   94 </span>-- Derived operations
<span class="lineno">   95 </span>-----------------------------------------------------------------------
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>-- | Apply a function to the state to update it.
<span class="lineno">   98 </span>gmodify :: (s -&gt; t) -&gt; GenStateContT t r s r m ()
<span class="lineno">   99 </span><span class="decl"><span class="nottickedoff">gmodify f = get &gt;&gt;&gt;= gput . f</span></span>
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>-- | Map a function over the final return value.
<span class="lineno">  102 </span>gmapRet :: (m r1 -&gt; m r2) -&gt; GenStateContT s r1 s r2 m ()
<span class="lineno">  103 </span><span class="decl"><span class="nottickedoff">gmapRet f_ret = gcaptureCC \k -&gt; f_ret (k ())</span></span>
<span class="lineno">  104 </span>
<span class="lineno">  105 </span>-- | Name-binding in the generalized continuation monad (FIXME: explain)
<span class="lineno">  106 </span>gopenBinding ::
<span class="lineno">  107 </span>  (Mb ctx (m b1) -&gt; m r2) -&gt;
<span class="lineno">  108 </span>  Mb ctx b2 -&gt;
<span class="lineno">  109 </span>  GenStateContT s b1 s r2 m (RAssign Name ctx, b2)
<span class="lineno">  110 </span><span class="decl"><span class="nottickedoff">gopenBinding f_ret mb_a =</span>
<span class="lineno">  111 </span><span class="spaces">  </span><span class="nottickedoff">gcaptureCC \k -&gt;</span>
<span class="lineno">  112 </span><span class="spaces">  </span><span class="nottickedoff">f_ret $ flip nuMultiWithElim1 mb_a $ \names a -&gt;</span>
<span class="lineno">  113 </span><span class="spaces">  </span><span class="nottickedoff">k (names, a)</span></span>
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>-- | Name-binding in the generalized continuation monad (FIXME: explain)
<span class="lineno">  116 </span>gopenNamedBinding ::
<span class="lineno">  117 </span>  (NamedMb ctx (m b1) -&gt; m r2) -&gt;
<span class="lineno">  118 </span>  NamedMb ctx b2 -&gt;
<span class="lineno">  119 </span>  GenStateContT s b1 s r2 m (RAssign Name ctx, b2)
<span class="lineno">  120 </span><span class="decl"><span class="nottickedoff">gopenNamedBinding f_ret mb_a =</span>
<span class="lineno">  121 </span><span class="spaces">  </span><span class="nottickedoff">gcaptureCC \k -&gt;</span>
<span class="lineno">  122 </span><span class="spaces">  </span><span class="nottickedoff">f_ret $ flip nuMultiWithElim1Named mb_a $ \names a -&gt;</span>
<span class="lineno">  123 </span><span class="spaces">  </span><span class="nottickedoff">k (names, a)</span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>-- | Name-binding in the generalized continuation monad (FIXME: explain)
<span class="lineno">  126 </span>startBinding ::
<span class="lineno">  127 </span>  RAssign Proxy ctx -&gt;
<span class="lineno">  128 </span>  (Mb ctx (m r1) -&gt; m r2) -&gt;
<span class="lineno">  129 </span>  GenStateContT s r1 s r2 m (RAssign Name ctx)
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">startBinding tps f_ret = gcaptureCC (f_ret . nuMulti tps)</span></span>
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>-- | Name-binding in the generalized continuation monad (FIXME: explain)
<span class="lineno">  133 </span>startNamedBinding ::
<span class="lineno">  134 </span>  RAssign StringF ctx -&gt;
<span class="lineno">  135 </span>  (NamedMb ctx (m r1) -&gt; m r2) -&gt;
<span class="lineno">  136 </span>  GenStateContT s r1 s r2 m (RAssign Name ctx)
<span class="lineno">  137 </span><span class="decl"><span class="nottickedoff">startNamedBinding tps f_ret = gcaptureCC (f_ret . nuMultiNamed tps)</span></span>
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>addReader :: GenStateContT s1 r1 s2 r2 m a -&gt; GenStateContT s1 r1 s2 r2 (ReaderT e m) a
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">addReader (GenStateContT m) =</span>
<span class="lineno">  141 </span><span class="spaces">  </span><span class="nottickedoff">GenStateContT \s2 k -&gt;</span>
<span class="lineno">  142 </span><span class="spaces">  </span><span class="nottickedoff">ReaderT \e -&gt;</span>
<span class="lineno">  143 </span><span class="spaces">  </span><span class="nottickedoff">m s2 \s1 a -&gt;</span>
<span class="lineno">  144 </span><span class="spaces">  </span><span class="nottickedoff">runReaderT (k s1 a) e</span></span>

</pre>
</body>
</html>
