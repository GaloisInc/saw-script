<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    2 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    3 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    4 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>{- |
<span class="lineno">    7 </span>Module      : SAWCore.SCTypeCheck
<span class="lineno">    8 </span>Copyright   : Galois, Inc. 2012-2015
<span class="lineno">    9 </span>License     : BSD3
<span class="lineno">   10 </span>Maintainer  : jhendrix@galois.com
<span class="lineno">   11 </span>Stability   : experimental
<span class="lineno">   12 </span>Portability : non-portable (language extensions)
<span class="lineno">   13 </span>-}
<span class="lineno">   14 </span>
<span class="lineno">   15 </span>module SAWCore.SCTypeCheck
<span class="lineno">   16 </span>  ( scTypeCheck
<span class="lineno">   17 </span>  , scTypeCheckError
<span class="lineno">   18 </span>  , scTypeCheckComplete
<span class="lineno">   19 </span>  , scTypeCheckCompleteError
<span class="lineno">   20 </span>  , SC.scTypeCheckWHNF
<span class="lineno">   21 </span>  , scConvertible
<span class="lineno">   22 </span>  , scCheckSubtype
<span class="lineno">   23 </span>  , TCError(..)
<span class="lineno">   24 </span>  , prettyTCError
<span class="lineno">   25 </span>  , throwTCError
<span class="lineno">   26 </span>  , TCM
<span class="lineno">   27 </span>  , runTCM
<span class="lineno">   28 </span>  , rethrowTCError
<span class="lineno">   29 </span>  , withEmptyTCState
<span class="lineno">   30 </span>  , atPos
<span class="lineno">   31 </span>  , LiftTCM(..)
<span class="lineno">   32 </span>  , TypeInfer(..)
<span class="lineno">   33 </span>  , typeCheckWHNF
<span class="lineno">   34 </span>  , typeInferCompleteWHNF
<span class="lineno">   35 </span>  , checkSubtype
<span class="lineno">   36 </span>  , ensureSort
<span class="lineno">   37 </span>  , applyPiTyped
<span class="lineno">   38 </span>  , compileRecursor
<span class="lineno">   39 </span>  ) where
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>import Control.Applicative
<span class="lineno">   42 </span>import Control.Monad (forM_, mapM, unless, void)
<span class="lineno">   43 </span>import Control.Monad.Except (MonadError(..), ExceptT, runExceptT)
<span class="lineno">   44 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   45 </span>import Control.Monad.Reader (MonadReader(..), Reader, ReaderT(..), runReader)
<span class="lineno">   46 </span>import Control.Monad.State.Strict (MonadState(..), StateT, evalStateT, modify)
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>import Data.IntMap (IntMap)
<span class="lineno">   49 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   50 </span>import Data.Map (Map)
<span class="lineno">   51 </span>import qualified Data.Map as Map
<span class="lineno">   52 </span>import Data.Text (Text)
<span class="lineno">   53 </span>import qualified Data.Text as Text
<span class="lineno">   54 </span>import qualified Data.Vector as V
<span class="lineno">   55 </span>import Prelude hiding (mapM, maximum)
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>import qualified SAWSupport.Pretty as PPS (defaultOpts)
<span class="lineno">   58 </span>
<span class="lineno">   59 </span>import SAWCore.Module
<span class="lineno">   60 </span>  ( ctorName
<span class="lineno">   61 </span>  , dtName
<span class="lineno">   62 </span>  , lookupVarIndexInMap
<span class="lineno">   63 </span>  , Ctor(..)
<span class="lineno">   64 </span>  , DataType(..)
<span class="lineno">   65 </span>  , ResolvedName(..)
<span class="lineno">   66 </span>  )
<span class="lineno">   67 </span>import SAWCore.Name
<span class="lineno">   68 </span>import SAWCore.Parser.Position
<span class="lineno">   69 </span>import SAWCore.Recognizer
<span class="lineno">   70 </span>import qualified SAWCore.Term.Certified as SC
<span class="lineno">   71 </span>import SAWCore.SharedTerm
<span class="lineno">   72 </span>import SAWCore.Term.Functor
<span class="lineno">   73 </span>import SAWCore.Term.Pretty (scPrettyTermInCtx)
<span class="lineno">   74 </span>import SAWCore.Term.Raw
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>-- | The state for a type-checking computation = a memoization table
<span class="lineno">   77 </span>type TCState = IntMap SC.Term
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>-- | The 'ReaderT' environment for a type-checking computation.
<span class="lineno">   80 </span>type TCEnv = SharedContext
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>-- | The monad for type checking and inference, which:
<span class="lineno">   83 </span>--
<span class="lineno">   84 </span>-- * Maintains a 'SharedContext';
<span class="lineno">   85 </span>--
<span class="lineno">   86 </span>-- * Memoizes the most general type inferred for each expression; AND
<span class="lineno">   87 </span>--
<span class="lineno">   88 </span>-- * Can throw 'TCError's
<span class="lineno">   89 </span>newtype TCM a = TCM (ReaderT TCEnv (StateT TCState (ExceptT TCError IO)) a)
<span class="lineno">   90 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">MonadFail</span></span>, <span class="decl"><span class="istickedoff">MonadIO</span></span>,
<span class="lineno">   91 </span>            <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadReader TCEnv</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff">MonadState TCState</span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">MonadError TCError</span></span></span></span>)
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>-- | Run a type-checking computation in a given context, starting from the empty
<span class="lineno">   94 </span>-- memoization table
<span class="lineno">   95 </span>runTCM ::
<span class="lineno">   96 </span>  TCM a -&gt; SharedContext -&gt; IO (Either TCError a)
<span class="lineno">   97 </span><span class="decl"><span class="istickedoff">runTCM (TCM m) sc =</span>
<span class="lineno">   98 </span><span class="spaces">  </span><span class="istickedoff">runExceptT $ evalStateT (runReaderT m sc) IntMap.empty</span></span>
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>-- | Augment and rethrow any 'TCError' thrown by the given computation.
<span class="lineno">  101 </span>rethrowTCError :: (MonadError TCError m) =&gt; (TCError -&gt; TCError) -&gt; m a -&gt; m a
<span class="lineno">  102 </span><span class="decl"><span class="istickedoff">rethrowTCError f m = catchError m (throwError . f)</span></span>
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- | Clear the memoization table before running the sub-computation,
<span class="lineno">  105 </span>-- and restore it afterward.
<span class="lineno">  106 </span>withEmptyTCState :: (MonadState TCState m) =&gt; m a -&gt; m a
<span class="lineno">  107 </span><span class="decl"><span class="nottickedoff">withEmptyTCState m =</span>
<span class="lineno">  108 </span><span class="spaces">  </span><span class="nottickedoff">do saved_table &lt;- get</span>
<span class="lineno">  109 </span><span class="spaces">     </span><span class="nottickedoff">put IntMap.empty</span>
<span class="lineno">  110 </span><span class="spaces">     </span><span class="nottickedoff">a &lt;- m</span>
<span class="lineno">  111 </span><span class="spaces">     </span><span class="nottickedoff">put saved_table</span>
<span class="lineno">  112 </span><span class="spaces">     </span><span class="nottickedoff">pure a</span></span>
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>-- | Run a type-checking computation @m@ and tag any error it throws with the
<span class="lineno">  115 </span>-- 'ErrorTerm' constructor
<span class="lineno">  116 </span>withErrorTerm :: Term -&gt; TCM a -&gt; TCM a
<span class="lineno">  117 </span><span class="decl"><span class="istickedoff">withErrorTerm tm m = catchError m (throwError . ErrorTerm tm)</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>-- | Lift @withErrorTerm@ to `TermF Term`
<span class="lineno">  120 </span>withErrorTermF :: TermF Term -&gt; TCM a -&gt; TCM a
<span class="lineno">  121 </span><span class="decl"><span class="istickedoff">withErrorTermF tf tcm =</span>
<span class="lineno">  122 </span><span class="spaces">  </span><span class="istickedoff">do t &lt;- liftTCM scTermF tf</span>
<span class="lineno">  123 </span><span class="spaces">     </span><span class="istickedoff">withErrorTerm t tcm</span></span>
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>-- | Lift @withErrorTerm@ to `TermF SC.Term`
<span class="lineno">  126 </span>withErrorCTermF :: TermF SC.Term -&gt; TCM a -&gt; TCM a
<span class="lineno">  127 </span><span class="decl"><span class="istickedoff">withErrorCTermF tm = withErrorTermF (fmap SC.rawTerm tm)</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>-- | Run a type-checking computation @m@ and tag any error it throws with the
<span class="lineno">  130 </span>-- given position, using the 'ErrorPos' constructor, unless that error is
<span class="lineno">  131 </span>-- already tagged with a position
<span class="lineno">  132 </span>atPos :: (MonadError TCError m) =&gt; Pos -&gt; m a -&gt; m a
<span class="lineno">  133 </span><span class="decl"><span class="istickedoff">atPos p = rethrowTCError (ErrorPos p)</span></span>
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>-- | Typeclass for lifting 'IO' computations that take a 'SharedContext' to
<span class="lineno">  136 </span>-- 'TCM' computations
<span class="lineno">  137 </span>class LiftTCM a where
<span class="lineno">  138 </span>  type TCMLifted a
<span class="lineno">  139 </span>  liftTCM :: (SharedContext -&gt; a) -&gt; TCMLifted a
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>instance LiftTCM (IO a) where
<span class="lineno">  142 </span>  type TCMLifted (IO a) = TCM a
<span class="lineno">  143 </span>  <span class="decl"><span class="istickedoff">liftTCM f =</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">do sc &lt;- ask</span>
<span class="lineno">  145 </span><span class="spaces">       </span><span class="istickedoff">liftIO (f sc)</span></span>
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>instance LiftTCM b =&gt; LiftTCM (a -&gt; b) where
<span class="lineno">  148 </span>  type TCMLifted (a -&gt; b) = a -&gt; TCMLifted b
<span class="lineno">  149 </span>  <span class="decl"><span class="istickedoff">liftTCM f a = liftTCM (\sc -&gt; f sc a)</span></span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>-- | Errors that can occur during type-checking
<span class="lineno">  152 </span>data TCError
<span class="lineno">  153 </span>  = NotSort Term
<span class="lineno">  154 </span>  | NotFuncTypeInApp SC.Term SC.Term
<span class="lineno">  155 </span>  | NotTupleType Term
<span class="lineno">  156 </span>  | BadTupleIndex Int Term
<span class="lineno">  157 </span>  | NotRecordType SC.Term
<span class="lineno">  158 </span>  | BadRecordField FieldName Term
<span class="lineno">  159 </span>  | DanglingVar Int
<span class="lineno">  160 </span>  | UnboundName Text
<span class="lineno">  161 </span>  | SubtypeFailure SC.Term Term
<span class="lineno">  162 </span>  | EmptyVectorLit
<span class="lineno">  163 </span>  | NoSuchDataType NameInfo
<span class="lineno">  164 </span>  | NoSuchCtor NameInfo
<span class="lineno">  165 </span>  | NoSuchConstant NameInfo
<span class="lineno">  166 </span>  | NotFullyAppliedRec NameInfo
<span class="lineno">  167 </span>  | MalformedRecursor NameInfo Sort String
<span class="lineno">  168 </span>  | DeclError Text String
<span class="lineno">  169 </span>  | ErrorPos Pos TCError
<span class="lineno">  170 </span>  | ErrorTerm Term TCError
<span class="lineno">  171 </span>  | ExpectedRecursor SC.Term
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- | Throw a type-checking error
<span class="lineno">  175 </span>throwTCError :: (MonadError TCError m) =&gt; TCError -&gt; m a
<span class="lineno">  176 </span><span class="decl"><span class="istickedoff">throwTCError e = throwError e</span></span>
<span class="lineno">  177 </span>
<span class="lineno">  178 </span>type PPErrM = Reader (Maybe Pos)
<span class="lineno">  179 </span>
<span class="lineno">  180 </span>-- | Pretty-print a type-checking error
<span class="lineno">  181 </span>prettyTCError :: TCError -&gt; [String]
<span class="lineno">  182 </span><span class="decl"><span class="istickedoff">prettyTCError e = runReader (helper e) <span class="nottickedoff">Nothing</span> where</span>
<span class="lineno">  183 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  184 </span><span class="spaces">  </span><span class="istickedoff">ppWithPos :: [PPErrM String] -&gt; PPErrM [String]</span>
<span class="lineno">  185 </span><span class="spaces">  </span><span class="istickedoff">ppWithPos str_ms =</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">do strs &lt;- mapM id str_ms</span>
<span class="lineno">  187 </span><span class="spaces">       </span><span class="istickedoff">maybe_p &lt;- ask</span>
<span class="lineno">  188 </span><span class="spaces">       </span><span class="istickedoff">case maybe_p of</span>
<span class="lineno">  189 </span><span class="spaces">         </span><span class="istickedoff">Just p -&gt; return (ppPos p : strs)</span>
<span class="lineno">  190 </span><span class="spaces">         </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return strs</span></span>
<span class="lineno">  191 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="istickedoff">helper :: TCError -&gt; PPErrM [String]</span>
<span class="lineno">  193 </span><span class="spaces">  </span><span class="istickedoff">helper (NotSort ty) = ppWithPos [ return &quot;Not a sort&quot; , ishow ty ]</span>
<span class="lineno">  194 </span><span class="spaces">  </span><span class="istickedoff">helper (NotFuncTypeInApp f arg) =</span>
<span class="lineno">  195 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Function application with non-function type&quot;</span>
<span class="lineno">  196 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;For term:&quot;</span>
<span class="lineno">  197 </span><span class="spaces">                </span><span class="istickedoff">, ishow (SC.rawTerm f)</span>
<span class="lineno">  198 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;With type:&quot;</span>
<span class="lineno">  199 </span><span class="spaces">                </span><span class="istickedoff">, ishow (SC.rawType f)</span>
<span class="lineno">  200 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;To argument:&quot;</span>
<span class="lineno">  201 </span><span class="spaces">                </span><span class="istickedoff">, ishow (SC.rawTerm arg) ]</span>
<span class="lineno">  202 </span><span class="spaces">  </span><span class="istickedoff">helper (NotTupleType ty) =</span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Tuple field projection with non-tuple type&quot; ,</span>
<span class="lineno">  204 </span><span class="spaces">                  </span><span class="istickedoff">ishow ty ]</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">helper (BadTupleIndex n ty) =</span>
<span class="lineno">  206 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;Bad tuple index (&quot; ++ show n ++ &quot;) for type&quot;)</span></span>
<span class="lineno">  207 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff">, ishow ty ]</span></span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="istickedoff">helper (NotRecordType t) =</span>
<span class="lineno">  209 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Record field projection with non-record type&quot;</span>
<span class="lineno">  210 </span><span class="spaces">                </span><span class="istickedoff">, ishow (SC.rawType t)</span>
<span class="lineno">  211 </span><span class="spaces">                </span><span class="istickedoff">, return &quot;In term:&quot;</span>
<span class="lineno">  212 </span><span class="spaces">                </span><span class="istickedoff">, ishow (SC.rawTerm t) ]</span>
<span class="lineno">  213 </span><span class="spaces">  </span><span class="istickedoff">helper (BadRecordField n ty) =</span>
<span class="lineno">  214 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return (&quot;Bad record field (&quot; ++ show n ++ &quot;) for type&quot;)</span>
<span class="lineno">  215 </span><span class="spaces">                </span><span class="istickedoff">, ishow ty ]</span>
<span class="lineno">  216 </span><span class="spaces">  </span><span class="istickedoff">helper (DanglingVar n) =</span>
<span class="lineno">  217 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;Dangling bound variable index: &quot; ++ show n)]</span></span>
<span class="lineno">  218 </span><span class="spaces">  </span><span class="istickedoff">helper (UnboundName str) = ppWithPos [ return (&quot;Unbound name: &quot; ++ show str)]</span>
<span class="lineno">  219 </span><span class="spaces">  </span><span class="istickedoff">helper (SubtypeFailure trm tp2) =</span>
<span class="lineno">  220 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Inferred type&quot;, ishow (SC.rawType trm),</span>
<span class="lineno">  221 </span><span class="spaces">                  </span><span class="istickedoff">return &quot;Not a subtype of expected type&quot;, ishow tp2,</span>
<span class="lineno">  222 </span><span class="spaces">                  </span><span class="istickedoff">return &quot;For term&quot;, ishow (SC.rawTerm trm) ]</span>
<span class="lineno">  223 </span><span class="spaces">  </span><span class="istickedoff">helper EmptyVectorLit = ppWithPos [ return &quot;Empty vector literal&quot;]</span>
<span class="lineno">  224 </span><span class="spaces">  </span><span class="istickedoff">helper (NoSuchDataType d) =</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">ppWithPos [ return (&quot;No such data type: &quot; ++ show d)]</span>
<span class="lineno">  226 </span><span class="spaces">  </span><span class="istickedoff">helper (NoSuchCtor c) =</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;No such constructor: &quot; ++ show c) ]</span></span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="istickedoff">helper (NoSuchConstant c) =</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;No such constant: &quot; ++ show c) ]</span></span>
<span class="lineno">  230 </span><span class="spaces">  </span><span class="istickedoff">helper (NotFullyAppliedRec i) =</span>
<span class="lineno">  231 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return (&quot;Recursor not fully applied: &quot; ++ show i) ]</span></span>
<span class="lineno">  232 </span><span class="spaces">  </span><span class="istickedoff">helper (MalformedRecursor d s reason) =</span>
<span class="lineno">  233 </span><span class="spaces">      </span><span class="istickedoff">ppWithPos [ return &quot;Malformed recursor&quot;,</span>
<span class="lineno">  234 </span><span class="spaces">                  </span><span class="istickedoff">pure (indent &quot;  &quot; (Text.unpack (toAbsoluteName d) ++ sortSuffix s)),</span>
<span class="lineno">  235 </span><span class="spaces">                  </span><span class="istickedoff">pure reason ]</span>
<span class="lineno">  236 </span><span class="spaces">  </span><span class="istickedoff">helper (DeclError nm reason) =</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">ppWithPos [ return (&quot;Malformed declaration for &quot; ++ show nm), return reason ]</span>
<span class="lineno">  238 </span><span class="spaces">  </span><span class="istickedoff">helper (ErrorPos p err) =</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">local (\_ -&gt; Just p) $ helper err</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">helper (ErrorTerm tm err) = do</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">info &lt;- ppWithPos [ return (&quot;While typechecking term:&quot;)</span>
<span class="lineno">  242 </span><span class="spaces">                      </span><span class="istickedoff">, ishow tm ]</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">cont &lt;- helper err</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">return (info ++ cont)</span>
<span class="lineno">  245 </span><span class="spaces">  </span><span class="istickedoff">helper (ExpectedRecursor ttm) =</span>
<span class="lineno">  246 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">ppWithPos [ return &quot;Expected recursor value&quot;, ishow (SC.rawTerm ttm), ishow (SC.rawType ttm)]</span></span>
<span class="lineno">  247 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  248 </span><span class="spaces">  </span><span class="istickedoff">-- | Add prefix to every line, but remove final trailing newline</span>
<span class="lineno">  249 </span><span class="spaces">  </span><span class="istickedoff">indent :: String -&gt; String -&gt; String</span>
<span class="lineno">  250 </span><span class="spaces">  </span><span class="istickedoff">indent prefix s = init (unlines (map (prefix ++) (lines s)))</span>
<span class="lineno">  251 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="istickedoff">ishow :: Term -&gt; PPErrM String</span>
<span class="lineno">  253 </span><span class="spaces">  </span><span class="istickedoff">ishow tm =</span>
<span class="lineno">  254 </span><span class="spaces">    </span><span class="istickedoff">-- return $ show tm</span>
<span class="lineno">  255 </span><span class="spaces">    </span><span class="istickedoff">pure $ indent &quot;  &quot; $ scPrettyTermInCtx PPS.defaultOpts [] tm</span>
<span class="lineno">  256 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  257 </span><span class="spaces">  </span><span class="istickedoff">sortSuffix :: Sort -&gt; String</span>
<span class="lineno">  258 </span><span class="spaces">  </span><span class="istickedoff">sortSuffix s =</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="istickedoff">case s of</span>
<span class="lineno">  260 </span><span class="spaces">      </span><span class="istickedoff">TypeSort 0 -&gt; &quot;#rec&quot;</span>
<span class="lineno">  261 </span><span class="spaces">      </span><span class="istickedoff">TypeSort n -&gt; <span class="nottickedoff">&quot;#rec&quot; ++ show n</span></span>
<span class="lineno">  262 </span><span class="spaces">      </span><span class="istickedoff">PropSort -&gt; <span class="nottickedoff">&quot;#ind&quot;</span></span></span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show TCError</span></span></span></span> where
<span class="lineno">  265 </span>  <span class="decl"><span class="nottickedoff">show = unlines . prettyTCError</span></span>
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>-- | Infer the type of a term using 'scTypeCheck', calling 'fail' on failure
<span class="lineno">  268 </span>scTypeCheckError :: TypeInfer a =&gt; SharedContext -&gt; a -&gt; IO Term
<span class="lineno">  269 </span><span class="decl"><span class="istickedoff">scTypeCheckError sc t0 =</span>
<span class="lineno">  270 </span><span class="spaces">  </span><span class="istickedoff">either <span class="nottickedoff">(fail . unlines . prettyTCError)</span> return =&lt;&lt; scTypeCheck sc t0</span></span>
<span class="lineno">  271 </span>
<span class="lineno">  272 </span>-- | Infer the type of a 'Term', ensuring in the process that the entire term is
<span class="lineno">  273 </span>-- well-formed and that all internal type annotations are correct. Types are
<span class="lineno">  274 </span>-- evaluated to WHNF as necessary, and the returned type is in WHNF.
<span class="lineno">  275 </span>scTypeCheck :: TypeInfer a =&gt; SharedContext -&gt; a -&gt; IO (Either TCError Term)
<span class="lineno">  276 </span><span class="decl"><span class="istickedoff">scTypeCheck sc t0 = runTCM (typeInfer t0) sc</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>-- | Infer the type of an @a@ and complete it to a term using
<span class="lineno">  279 </span>-- 'scTypeCheckComplete', calling 'fail' on failure
<span class="lineno">  280 </span>scTypeCheckCompleteError ::
<span class="lineno">  281 </span>  TypeInfer a =&gt; SharedContext -&gt; a -&gt; IO SC.Term
<span class="lineno">  282 </span><span class="decl"><span class="nottickedoff">scTypeCheckCompleteError sc t0 =</span>
<span class="lineno">  283 </span><span class="spaces">  </span><span class="nottickedoff">either (fail . unlines . prettyTCError) return =&lt;&lt;</span>
<span class="lineno">  284 </span><span class="spaces">  </span><span class="nottickedoff">scTypeCheckComplete sc t0</span></span>
<span class="lineno">  285 </span>
<span class="lineno">  286 </span>-- | Infer the type of an @a@ and complete it to a term, ensuring in the
<span class="lineno">  287 </span>-- process that the entire term is well-formed and that all internal type
<span class="lineno">  288 </span>-- annotations are correct. Types are evaluated to WHNF as necessary, and the
<span class="lineno">  289 </span>-- returned type is in WHNF, though the returned term may not be.
<span class="lineno">  290 </span>scTypeCheckComplete ::
<span class="lineno">  291 </span>  TypeInfer a =&gt; SharedContext -&gt; a -&gt; IO (Either TCError SC.Term)
<span class="lineno">  292 </span><span class="decl"><span class="nottickedoff">scTypeCheckComplete sc t0 = runTCM (typeInferComplete t0) sc</span></span>
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>-- | Check that one type is a subtype of another using 'checkSubtype', calling
<span class="lineno">  295 </span>-- 'fail' on failure
<span class="lineno">  296 </span>scCheckSubtype :: SharedContext -&gt; SC.Term -&gt; Term -&gt; IO ()
<span class="lineno">  297 </span><span class="decl"><span class="nottickedoff">scCheckSubtype sc arg req_tp =</span>
<span class="lineno">  298 </span><span class="spaces">  </span><span class="nottickedoff">either (fail . unlines . prettyTCError) return =&lt;&lt;</span>
<span class="lineno">  299 </span><span class="spaces">  </span><span class="nottickedoff">runTCM (checkSubtype arg req_tp) sc</span></span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>-- | The class of things that we can infer types of. The 'typeInfer' method
<span class="lineno">  302 </span>-- returns the most general (with respect to subtyping) type of its input.
<span class="lineno">  303 </span>class TypeInfer a where
<span class="lineno">  304 </span>  -- | Infer the type of an @a@
<span class="lineno">  305 </span>  typeInfer :: a -&gt; TCM Term
<span class="lineno">  306 </span>  -- | Infer the type of an @a@ and complete it to a 'Term'
<span class="lineno">  307 </span>  typeInferComplete :: a -&gt; TCM SC.Term
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>-- | Infer the type of an @a@ and complete it to a 'Term', and then evaluate the
<span class="lineno">  310 </span>-- resulting term to WHNF
<span class="lineno">  311 </span>typeInferCompleteWHNF :: TypeInfer a =&gt; a -&gt; TCM SC.Term
<span class="lineno">  312 </span><span class="decl"><span class="nottickedoff">typeInferCompleteWHNF a =</span>
<span class="lineno">  313 </span><span class="spaces">  </span><span class="nottickedoff">do t &lt;- typeInferComplete a</span>
<span class="lineno">  314 </span><span class="spaces">     </span><span class="nottickedoff">liftTCM SC.scWHNF t</span></span>
<span class="lineno">  315 </span>
<span class="lineno">  316 </span>-- Type inference for Term dispatches to type inference on TermF Term, but uses
<span class="lineno">  317 </span>-- memoization to avoid repeated work
<span class="lineno">  318 </span>instance TypeInfer Term where
<span class="lineno">  319 </span>  <span class="decl"><span class="istickedoff">typeInfer t = SC.rawType &lt;$&gt; typeInferComplete t</span></span>
<span class="lineno">  320 </span>  <span class="decl"><span class="istickedoff">typeInferComplete t =</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">case t of</span>
<span class="lineno">  322 </span><span class="spaces">      </span><span class="istickedoff">STApp{stAppIndex = i, stAppTermF = tf} -&gt;</span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="istickedoff">do table &lt;- get</span>
<span class="lineno">  324 </span><span class="spaces">           </span><span class="istickedoff">case IntMap.lookup i table of</span>
<span class="lineno">  325 </span><span class="spaces">             </span><span class="istickedoff">Just x -&gt; pure x</span>
<span class="lineno">  326 </span><span class="spaces">             </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  327 </span><span class="spaces">               </span><span class="istickedoff">do x &lt;- withErrorTerm <span class="nottickedoff">t</span> $ typeInferComplete tf</span>
<span class="lineno">  328 </span><span class="spaces">                  </span><span class="istickedoff">modify (IntMap.insert i x)</span>
<span class="lineno">  329 </span><span class="spaces">                  </span><span class="istickedoff">pure x</span></span>
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>-- Type inference for TermF Term dispatches to that for TermF SC.Term by
<span class="lineno">  332 </span>-- calling inference on all the sub-components and extending the context inside
<span class="lineno">  333 </span>-- of the binding forms
<span class="lineno">  334 </span>instance TypeInfer (TermF Term) where
<span class="lineno">  335 </span>  <span class="decl"><span class="nottickedoff">typeInfer tf = SC.rawType &lt;$&gt; typeInferComplete tf</span></span>
<span class="lineno">  336 </span>  <span class="decl"><span class="istickedoff">typeInferComplete tf =</span>
<span class="lineno">  337 </span><span class="spaces">    </span><span class="istickedoff">case tf of</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno">  339 </span><span class="spaces">        </span><span class="istickedoff">-- Dispatch to the TypeInfer instance for FlatTermF Term</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="istickedoff">do typeInferComplete ftf</span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="istickedoff">do t1t &lt;- typeInferComplete t1</span>
<span class="lineno">  343 </span><span class="spaces">           </span><span class="istickedoff">t2t &lt;- typeInferComplete t2</span>
<span class="lineno">  344 </span><span class="spaces">           </span><span class="istickedoff">inferTermF (App t1t t2t)</span>
<span class="lineno">  345 </span><span class="spaces">      </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno">  346 </span><span class="spaces">        </span><span class="istickedoff">do t1t &lt;- typeInferComplete t1</span>
<span class="lineno">  347 </span><span class="spaces">           </span><span class="istickedoff">t2t &lt;- typeInferComplete t2</span>
<span class="lineno">  348 </span><span class="spaces">           </span><span class="istickedoff">inferTermF (Lambda x t1t t2t)</span>
<span class="lineno">  349 </span><span class="spaces">      </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno">  350 </span><span class="spaces">        </span><span class="istickedoff">do t1t &lt;- typeInferComplete t1</span>
<span class="lineno">  351 </span><span class="spaces">           </span><span class="istickedoff">t2t &lt;- typeInferComplete t2</span>
<span class="lineno">  352 </span><span class="spaces">           </span><span class="istickedoff">inferTermF (Pi x t1t t2t)</span>
<span class="lineno">  353 </span><span class="spaces">      </span><span class="istickedoff">Constant nm -&gt;</span>
<span class="lineno">  354 </span><span class="spaces">        </span><span class="istickedoff">do inferTermF (Constant nm)</span>
<span class="lineno">  355 </span><span class="spaces">      </span><span class="istickedoff">Variable x t1 -&gt;</span>
<span class="lineno">  356 </span><span class="spaces">        </span><span class="istickedoff">do t1t &lt;- typeInferComplete t1</span>
<span class="lineno">  357 </span><span class="spaces">           </span><span class="istickedoff">inferTermF (Variable x t1t)</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>-- Type inference for FlatTermF Term dispatches to that for FlatTermF SC.Term.
<span class="lineno">  360 </span>instance TypeInfer (FlatTermF Term) where
<span class="lineno">  361 </span>  <span class="decl"><span class="nottickedoff">typeInfer ftf = SC.rawType &lt;$&gt; typeInferComplete ftf</span></span>
<span class="lineno">  362 </span>  <span class="decl"><span class="istickedoff">typeInferComplete ftf =</span>
<span class="lineno">  363 </span><span class="spaces">    </span><span class="istickedoff">typeInferComplete =&lt;&lt; mapM typeInferComplete ftf</span></span>
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>-- Type inference for TermF SC.Term is the main workhorse. Intuitively, this
<span class="lineno">  366 </span>-- represents the case where each immediate subterm of a term is labeled with
<span class="lineno">  367 </span>-- its (most general) type.
<span class="lineno">  368 </span>instance TypeInfer (TermF SC.Term) where
<span class="lineno">  369 </span>  <span class="decl"><span class="nottickedoff">typeInfer tf = SC.rawType &lt;$&gt; typeInferComplete tf</span></span>
<span class="lineno">  370 </span>  <span class="decl"><span class="istickedoff">typeInferComplete tf =</span>
<span class="lineno">  371 </span><span class="spaces">    </span><span class="istickedoff">withErrorCTermF tf (inferTermF tf)</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>-- Type inference for FlatTermF SC.Term is the main workhorse for flat
<span class="lineno">  374 </span>-- terms. Intuitively, this represents the case where each immediate subterm of
<span class="lineno">  375 </span>-- a term has already been labeled with its (most general) type.
<span class="lineno">  376 </span>instance TypeInfer (FlatTermF SC.Term) where
<span class="lineno">  377 </span>  <span class="decl"><span class="nottickedoff">typeInfer ftf =</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="nottickedoff">SC.rawType &lt;$&gt; inferFlatTermF ftf</span></span>
<span class="lineno">  379 </span>  <span class="decl"><span class="istickedoff">typeInferComplete ftf =</span>
<span class="lineno">  380 </span><span class="spaces">    </span><span class="istickedoff">withErrorCTermF (FTermF ftf) (inferFlatTermF ftf)</span></span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>-- | Construct a typed term from a 'TermF' where each subterm has
<span class="lineno">  383 </span>-- already been labeled with its type.
<span class="lineno">  384 </span>inferTermF :: TermF SC.Term -&gt; TCM SC.Term
<span class="lineno">  385 </span><span class="decl"><span class="istickedoff">inferTermF tf =</span>
<span class="lineno">  386 </span><span class="spaces">  </span><span class="istickedoff">case tf of</span>
<span class="lineno">  387 </span><span class="spaces">    </span><span class="istickedoff">FTermF ftf -&gt;</span>
<span class="lineno">  388 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">inferFlatTermF ftf</span></span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="istickedoff">App t1 t2 -&gt;</span>
<span class="lineno">  390 </span><span class="spaces">      </span><span class="istickedoff">do let err = NotFuncTypeInApp t1 t2</span>
<span class="lineno">  391 </span><span class="spaces">         </span><span class="istickedoff">(_nm, arg_tp, _ret_tp) &lt;- ensurePiType err (SC.rawType t1)</span>
<span class="lineno">  392 </span><span class="spaces">         </span><span class="istickedoff">checkSubtype t2 arg_tp</span>
<span class="lineno">  393 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scApply t1 t2</span>
<span class="lineno">  394 </span><span class="spaces">    </span><span class="istickedoff">Lambda x t1 t2 -&gt;</span>
<span class="lineno">  395 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSort (SC.rawType t1)</span>
<span class="lineno">  396 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scLambda x t1 t2</span>
<span class="lineno">  397 </span><span class="spaces">    </span><span class="istickedoff">Pi x t1 t2 -&gt;</span>
<span class="lineno">  398 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSort (SC.rawType t1)</span>
<span class="lineno">  399 </span><span class="spaces">         </span><span class="istickedoff">void $ ensureSort (SC.rawType t2)</span>
<span class="lineno">  400 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scPi x t1 t2</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff">Constant nm -&gt;</span>
<span class="lineno">  402 </span><span class="spaces">      </span><span class="istickedoff">do mm &lt;- liftTCM scGetModuleMap</span>
<span class="lineno">  403 </span><span class="spaces">         </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex nm) mm of</span>
<span class="lineno">  404 </span><span class="spaces">           </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwTCError $ NoSuchConstant (nameInfo nm)</span></span>
<span class="lineno">  405 </span><span class="spaces">           </span><span class="istickedoff">Just _ -&gt; liftTCM SC.scConstant nm</span>
<span class="lineno">  406 </span><span class="spaces">    </span><span class="istickedoff">Variable vn tp -&gt;</span>
<span class="lineno">  407 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scVariable vn tp</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>-- | Construct a typed term from a 'FlatTermF' where each subterm has
<span class="lineno">  410 </span>-- already been labeled with its type.
<span class="lineno">  411 </span>inferFlatTermF :: FlatTermF SC.Term -&gt; TCM SC.Term
<span class="lineno">  412 </span><span class="decl"><span class="istickedoff">inferFlatTermF ftf =</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="istickedoff">case ftf of</span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="istickedoff">UnitValue -&gt;</span>
<span class="lineno">  415 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scUnitValue</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="istickedoff">UnitType -&gt;</span>
<span class="lineno">  417 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scUnitType</span>
<span class="lineno">  418 </span><span class="spaces">    </span><span class="istickedoff">PairValue t1 t2 -&gt;</span>
<span class="lineno">  419 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scPairValue t1 t2</span>
<span class="lineno">  420 </span><span class="spaces">    </span><span class="istickedoff">PairType t1 t2 -&gt;</span>
<span class="lineno">  421 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSort (SC.rawType t1)</span>
<span class="lineno">  422 </span><span class="spaces">         </span><span class="istickedoff">void $ ensureSort (SC.rawType t2)</span>
<span class="lineno">  423 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scPairType t1 t2</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">PairLeft t -&gt;</span>
<span class="lineno">  425 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensurePairType (SC.rawType t)</span>
<span class="lineno">  426 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scPairLeft t</span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="istickedoff">PairRight t -&gt;</span>
<span class="lineno">  428 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensurePairType (SC.rawType t)</span>
<span class="lineno">  429 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scPairRight t</span>
<span class="lineno">  430 </span><span class="spaces">    </span><span class="istickedoff">Recursor r -&gt;</span>
<span class="lineno">  431 </span><span class="spaces">      </span><span class="istickedoff">do mm &lt;- liftTCM scGetModuleMap</span>
<span class="lineno">  432 </span><span class="spaces">         </span><span class="istickedoff">let d = recursorDataType r</span>
<span class="lineno">  433 </span><span class="spaces">         </span><span class="istickedoff">let s = recursorSort r</span>
<span class="lineno">  434 </span><span class="spaces">         </span><span class="istickedoff">case lookupVarIndexInMap (nameIndex d) mm of</span>
<span class="lineno">  435 </span><span class="spaces">           </span><span class="istickedoff">Just (ResolvedDataType _dt) -&gt; liftTCM SC.scRecursor d s</span>
<span class="lineno">  436 </span><span class="spaces">           </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">throwTCError $ NoSuchDataType (nameInfo d)</span></span>
<span class="lineno">  437 </span><span class="spaces">    </span><span class="istickedoff">RecordType elems -&gt;</span>
<span class="lineno">  438 </span><span class="spaces">      </span><span class="istickedoff">do void $ mapM (ensureSort . SC.rawType . snd) elems</span>
<span class="lineno">  439 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scRecordType elems</span>
<span class="lineno">  440 </span><span class="spaces">    </span><span class="istickedoff">RecordValue elems -&gt;</span>
<span class="lineno">  441 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scRecordValue elems</span>
<span class="lineno">  442 </span><span class="spaces">    </span><span class="istickedoff">RecordProj t fld -&gt;</span>
<span class="lineno">  443 </span><span class="spaces">      </span><span class="istickedoff">do ts &lt;- ensureRecordType (NotRecordType t) (SC.rawType t)</span>
<span class="lineno">  444 </span><span class="spaces">         </span><span class="istickedoff">unless (Map.member fld ts) $</span>
<span class="lineno">  445 </span><span class="spaces">           </span><span class="istickedoff">throwTCError $ BadRecordField fld (SC.rawType t)</span>
<span class="lineno">  446 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scRecordProj t fld</span>
<span class="lineno">  447 </span><span class="spaces">    </span><span class="istickedoff">Sort s flags -&gt;</span>
<span class="lineno">  448 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scSortWithFlags s flags</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">NatLit n -&gt;</span>
<span class="lineno">  450 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scNat n</span>
<span class="lineno">  451 </span><span class="spaces">    </span><span class="istickedoff">ArrayValue tp vs -&gt;</span>
<span class="lineno">  452 </span><span class="spaces">      </span><span class="istickedoff">do void $ ensureSort (SC.rawType tp)</span>
<span class="lineno">  453 </span><span class="spaces">         </span><span class="istickedoff">tp' &lt;- typeCheckWHNF (SC.rawTerm tp)</span>
<span class="lineno">  454 </span><span class="spaces">         </span><span class="istickedoff">forM_ vs $ \v_elem -&gt; checkSubtype v_elem tp'</span>
<span class="lineno">  455 </span><span class="spaces">         </span><span class="istickedoff">liftTCM SC.scVector tp (V.toList vs)</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">StringLit s -&gt;</span>
<span class="lineno">  457 </span><span class="spaces">      </span><span class="istickedoff">liftTCM SC.scString s</span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>-- | Check that @fun_tp=Pi x a b@ and that @arg@ has type @a@, and return the
<span class="lineno">  460 </span>-- result of substituting @arg@ for @x@ in the result type @b@, i.e.,
<span class="lineno">  461 </span>-- @[arg/x]b@.
<span class="lineno">  462 </span>-- If @fun_tp@ is not a pi type, raise the supplied error.
<span class="lineno">  463 </span>applyPiTyped :: TCError -&gt; Term -&gt; SC.Term -&gt; TCM Term
<span class="lineno">  464 </span><span class="decl"><span class="istickedoff">applyPiTyped err fun_tp arg =</span>
<span class="lineno">  465 </span><span class="spaces">  </span><span class="istickedoff">ensurePiType <span class="nottickedoff">err</span> fun_tp &gt;&gt;= \(nm, arg_tp, ret_tp) -&gt;</span>
<span class="lineno">  466 </span><span class="spaces">  </span><span class="istickedoff">do checkSubtype arg arg_tp</span>
<span class="lineno">  467 </span><span class="spaces">     </span><span class="istickedoff">let sub = IntMap.singleton (vnIndex nm) (SC.rawTerm arg)</span>
<span class="lineno">  468 </span><span class="spaces">     </span><span class="istickedoff">liftTCM scInstantiate sub ret_tp</span></span>
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>-- | Ensure that a 'Term' matches a recognizer function, normalizing if
<span class="lineno">  471 </span>-- necessary; otherwise throw the supplied 'TCError'
<span class="lineno">  472 </span>ensureRecognizer :: Recognizer Term a -&gt; TCError -&gt; Term -&gt; TCM a
<span class="lineno">  473 </span><span class="decl"><span class="istickedoff">ensureRecognizer f _ (f -&gt; Just a) = return a</span>
<span class="lineno">  474 </span><span class="spaces"></span><span class="istickedoff">ensureRecognizer f err trm =</span>
<span class="lineno">  475 </span><span class="spaces">  </span><span class="istickedoff">typeCheckWHNF trm &gt;&gt;= \case</span>
<span class="lineno">  476 </span><span class="spaces">  </span><span class="istickedoff">(f -&gt; Just a) -&gt; return a</span>
<span class="lineno">  477 </span><span class="spaces">  </span><span class="istickedoff">_ -&gt; throwTCError err</span></span>
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>-- | Ensure a 'Term' is a sort, normalizing if necessary, and return that sort
<span class="lineno">  480 </span>ensureSort :: Term -&gt; TCM Sort
<span class="lineno">  481 </span><span class="decl"><span class="istickedoff">ensureSort tp = ensureRecognizer asSort (NotSort tp) tp</span></span>
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>-- | Ensure a 'Term' is a pair type, normalizing if necessary, and return the
<span class="lineno">  484 </span>-- two components of that pair type
<span class="lineno">  485 </span>ensurePairType :: Term -&gt; TCM (Term, Term)
<span class="lineno">  486 </span><span class="decl"><span class="istickedoff">ensurePairType tp = ensureRecognizer asPairType (NotTupleType tp) tp</span></span>
<span class="lineno">  487 </span>
<span class="lineno">  488 </span>-- | Ensure a 'Term' is a record type, normalizing if necessary, and return the
<span class="lineno">  489 </span>-- components of that record type
<span class="lineno">  490 </span>ensureRecordType :: TCError -&gt; Term -&gt; TCM (Map FieldName Term)
<span class="lineno">  491 </span><span class="decl"><span class="istickedoff">ensureRecordType err tp = ensureRecognizer asRecordType err tp</span></span>
<span class="lineno">  492 </span>
<span class="lineno">  493 </span>-- | Ensure a 'Term' is a pi type, normalizing if necessary. Return the
<span class="lineno">  494 </span>-- components of that pi type on success; otherwise throw the supplied error.
<span class="lineno">  495 </span>ensurePiType :: TCError -&gt; Term -&gt; TCM (VarName, Term, Term)
<span class="lineno">  496 </span><span class="decl"><span class="istickedoff">ensurePiType err tp = ensureRecognizer asPi err tp</span></span>
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | Reduce a type to WHNF (using 'scWhnf'), also adding in some conversions for
<span class="lineno">  499 </span>-- operations on Nat literals that are useful in type-checking
<span class="lineno">  500 </span>typeCheckWHNF :: Term -&gt; TCM Term
<span class="lineno">  501 </span><span class="decl"><span class="istickedoff">typeCheckWHNF = liftTCM SC.scTypeCheckWHNF</span></span>
<span class="lineno">  502 </span>
<span class="lineno">  503 </span>-- | Check that one type is a subtype of another, assuming both arguments are
<span class="lineno">  504 </span>-- types, i.e., that both have type Sort s for some s.
<span class="lineno">  505 </span>checkSubtype :: SC.Term -&gt; Term -&gt; TCM ()
<span class="lineno">  506 </span><span class="decl"><span class="istickedoff">checkSubtype arg req_tp =</span>
<span class="lineno">  507 </span><span class="spaces">  </span><span class="istickedoff">do arg_tp' &lt;- liftTCM scWhnf (SC.rawType arg)</span>
<span class="lineno">  508 </span><span class="spaces">     </span><span class="istickedoff">req_tp' &lt;- liftTCM scWhnf req_tp</span>
<span class="lineno">  509 </span><span class="spaces">     </span><span class="istickedoff">ok &lt;- isSubtype arg_tp' req_tp'</span>
<span class="lineno">  510 </span><span class="spaces">     </span><span class="istickedoff">if ok then return <span class="nottickedoff">()</span> else throwTCError $ SubtypeFailure arg req_tp</span></span>
<span class="lineno">  511 </span>
<span class="lineno">  512 </span>-- | Check if one type is a subtype of another, assuming both arguments are
<span class="lineno">  513 </span>-- types, i.e., that both have type Sort s for some s, and that they are both
<span class="lineno">  514 </span>-- already in WHNF
<span class="lineno">  515 </span>isSubtype :: Term -&gt; Term -&gt; TCM Bool
<span class="lineno">  516 </span><span class="decl"><span class="istickedoff">isSubtype (unwrapTermF -&gt; Pi x1 a1 b1) (unwrapTermF -&gt; Pi x2 a2 b2)</span>
<span class="lineno">  517 </span><span class="spaces">  </span><span class="istickedoff">| x1 == x2 =</span>
<span class="lineno">  518 </span><span class="spaces">    </span><span class="istickedoff">(&amp;&amp;) &lt;$&gt; areConvertible a1 a2 &lt;*&gt; isSubtype b1 b2</span>
<span class="lineno">  519 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> =</span>
<span class="lineno">  520 </span><span class="spaces">    </span><span class="istickedoff">do conv1 &lt;- areConvertible a1 a2</span>
<span class="lineno">  521 </span><span class="spaces">       </span><span class="istickedoff">var1 &lt;- liftTCM scVariable x1 a1</span>
<span class="lineno">  522 </span><span class="spaces">       </span><span class="istickedoff">let sub = IntMap.singleton (vnIndex x2) var1</span>
<span class="lineno">  523 </span><span class="spaces">       </span><span class="istickedoff">b2' &lt;- liftTCM scInstantiate sub b2</span>
<span class="lineno">  524 </span><span class="spaces">       </span><span class="istickedoff">conv2 &lt;- isSubtype b1 b2'</span>
<span class="lineno">  525 </span><span class="spaces">       </span><span class="istickedoff">pure (conv1 &amp;&amp; conv2)</span>
<span class="lineno">  526 </span><span class="spaces"></span><span class="istickedoff">isSubtype (asSort -&gt; Just s1) (asSort -&gt; Just s2) | <span class="tickonlytrue">s1 &lt;= s2</span> = return True</span>
<span class="lineno">  527 </span><span class="spaces"></span><span class="istickedoff">isSubtype t1' t2' = areConvertible t1' t2'</span></span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>-- | Check if two terms are &quot;convertible for type-checking&quot;, meaning that they
<span class="lineno">  530 </span>-- are convertible up to 'natConversions'
<span class="lineno">  531 </span>areConvertible :: Term -&gt; Term -&gt; TCM Bool
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">areConvertible t1 t2 = liftTCM scConvertibleEval SC.scTypeCheckWHNF True t1 t2</span></span>
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>
<span class="lineno">  535 </span>compileRecursor ::
<span class="lineno">  536 </span>  DataType -&gt;
<span class="lineno">  537 </span>  Sort          {- ^ elimination sort -} -&gt;
<span class="lineno">  538 </span>  TCM CompiledRecursor
<span class="lineno">  539 </span><span class="decl"><span class="istickedoff">compileRecursor dt s =</span>
<span class="lineno">  540 </span><span class="spaces">  </span><span class="istickedoff">do let d = dtName dt</span>
<span class="lineno">  541 </span><span class="spaces">     </span><span class="istickedoff">let nparams = length (dtParams dt)</span>
<span class="lineno">  542 </span><span class="spaces">     </span><span class="istickedoff">let nixs = length (dtIndices dt)</span>
<span class="lineno">  543 </span><span class="spaces">     </span><span class="istickedoff">let ctorOrder = map ctorName (dtCtors dt)</span>
<span class="lineno">  544 </span><span class="spaces">     </span><span class="istickedoff">let crec = CompiledRecursor d s nparams nixs ctorOrder</span>
<span class="lineno">  545 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  546 </span><span class="spaces">     </span><span class="istickedoff">-- Check that the parameters are correct for the given datatype</span>
<span class="lineno">  547 </span><span class="spaces">     </span><span class="istickedoff">let err =</span>
<span class="lineno">  548 </span><span class="spaces">           </span><span class="istickedoff">MalformedRecursor (nameInfo d) s</span>
<span class="lineno">  549 </span><span class="spaces">           </span><span class="istickedoff">&quot;Disallowed propositional elimination&quot;</span>
<span class="lineno">  550 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  551 </span><span class="spaces">     </span><span class="istickedoff">unless (allowedElimSort dt s) $ throwTCError err</span>
<span class="lineno">  552 </span><span class="spaces">     </span><span class="istickedoff">return crec</span></span>

</pre>
</body>
</html>
