<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    2 </span>{-# LANGUAGE DeriveTraversable #-}
<span class="lineno">    3 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    4 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">    5 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    6 </span>{-# LANGUAGE PatternSynonyms #-}
<span class="lineno">    7 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    8 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">    9 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   10 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   11 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   12 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>-- | The 'TypeShape' data type and related utilities.
<span class="lineno">   15 </span>module SAWCentral.Crucible.MIR.TypeShape
<span class="lineno">   16 </span>  ( TypeShape(..)
<span class="lineno">   17 </span>  , FieldShape(..)
<span class="lineno">   18 </span>  , VariantShape(..)
<span class="lineno">   19 </span>  , AgElemShape(..)
<span class="lineno">   20 </span>  , CryTermAdaptor(..)
<span class="lineno">   21 </span>  , isCryNoAdapt
<span class="lineno">   22 </span>  , adaptTuple
<span class="lineno">   23 </span>  , adaptArray
<span class="lineno">   24 </span>  , tyToShape
<span class="lineno">   25 </span>  , tyToShapeEq
<span class="lineno">   26 </span>  , shapeType
<span class="lineno">   27 </span>  , fieldShapeType
<span class="lineno">   28 </span>  , variantShapeType
<span class="lineno">   29 </span>  , shapeMirTy
<span class="lineno">   30 </span>  , fieldShapeMirTy
<span class="lineno">   31 </span>  , shapeToTerm
<span class="lineno">   32 </span>  , shapeToTerm'
<span class="lineno">   33 </span>  , IsBVShape(..)
<span class="lineno">   34 </span>  , testBVShape
<span class="lineno">   35 </span>  , IsRefShape(..)
<span class="lineno">   36 </span>  , testRefShape
<span class="lineno">   37 </span>  , sliceShapeParts
<span class="lineno">   38 </span>  -- `MirAggregate` / `AgElemShape` helpers
<span class="lineno">   39 </span>  , buildMirAggregate
<span class="lineno">   40 </span>  , traverseMirAggregate
<span class="lineno">   41 </span>  , accessMirAggregate
<span class="lineno">   42 </span>  , accessMirAggregate'
<span class="lineno">   43 </span>  , zipMirAggregates
<span class="lineno">   44 </span>  , arrayAgElemShapes
<span class="lineno">   45 </span>  , buildMirAggregateArray
<span class="lineno">   46 </span>  , generateMirAggregateArray
<span class="lineno">   47 </span>  , traverseMirAggregateArray
<span class="lineno">   48 </span>  , accessMirAggregateArray
<span class="lineno">   49 </span>  , accessMirAggregateArray'
<span class="lineno">   50 </span>  -- Misc helpers
<span class="lineno">   51 </span>  , checkCompatibleTys
<span class="lineno">   52 </span>  , readMaybeType
<span class="lineno">   53 </span>  , readPartExprMaybe
<span class="lineno">   54 </span>  ) where
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import Control.Lens ((^.), (^..), each)
<span class="lineno">   57 </span>import Control.Monad (when, forM, zipWithM)
<span class="lineno">   58 </span>import Control.Monad.IO.Class (MonadIO(..))
<span class="lineno">   59 </span>import Data.IntMap (IntMap)
<span class="lineno">   60 </span>import qualified Data.IntMap as IntMap
<span class="lineno">   61 </span>import qualified Data.IntSet as IntSet
<span class="lineno">   62 </span>import Data.Map (Map)
<span class="lineno">   63 </span>import qualified Data.Map as Map
<span class="lineno">   64 </span>import Data.Maybe (isJust)
<span class="lineno">   65 </span>import Data.Text (Text)
<span class="lineno">   66 </span>import qualified Data.Text as Text
<span class="lineno">   67 </span>import Data.Parameterized.Classes (ShowF)
<span class="lineno">   68 </span>import Data.Parameterized.Context (pattern Empty, pattern (:&gt;), Assignment)
<span class="lineno">   69 </span>import Data.Parameterized.Some
<span class="lineno">   70 </span>import Data.Parameterized.TH.GADT
<span class="lineno">   71 </span>import Data.Parameterized.TraversableFC
<span class="lineno">   72 </span>import GHC.Stack (HasCallStack)
<span class="lineno">   73 </span>import Numeric.Natural (Natural)
<span class="lineno">   74 </span>import qualified Prettyprinter as PP
<span class="lineno">   75 </span>
<span class="lineno">   76 </span>import qualified What4.Interface as W4
<span class="lineno">   77 </span>import qualified What4.Partial as W4
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>import Lang.Crucible.Backend (IsSymInterface)
<span class="lineno">   80 </span>import Lang.Crucible.Simulator.RegValue (RegValue)
<span class="lineno">   81 </span>import Lang.Crucible.Types
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>import qualified Mir.DefId as M
<span class="lineno">   84 </span>import Mir.Intrinsics
<span class="lineno">   85 </span>import qualified Mir.Mir as M
<span class="lineno">   86 </span>import Mir.TransTy ( tyListToCtx, tyToRepr, tyToReprCont, canInitialize
<span class="lineno">   87 </span>                   , isUnsized, reprTransparentFieldTy )
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>import SAWCentral.Panic (panic)
<span class="lineno">   90 </span>import qualified SAWCore.SharedTerm as SAW
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>-- | TypeShape is used to classify MIR `Ty`s and their corresponding
<span class="lineno">   93 </span>-- CrucibleTypes into a few common cases.  We don't use `Ty` directly because
<span class="lineno">   94 </span>-- there are some `Ty`s that have identical structure (such as TyRef vs.
<span class="lineno">   95 </span>-- TyRawPtr) or similar enough structure that we'd rather write only one case
<span class="lineno">   96 </span>-- (such as `u8` vs `i8` vs `i32`, all primitives/BaseTypes).  And we don't use
<span class="lineno">   97 </span>-- TypeRepr directly because it's lacking information in some cases.
<span class="lineno">   98 </span>--
<span class="lineno">   99 </span>-- In each constructor, the first `M.Ty` is the overall MIR type (e.g., for
<span class="lineno">  100 </span>-- ArrayShape, this is the TyArray type).  The overall `TypeRepr tp` isn't
<span class="lineno">  101 </span>-- stored directly, but can be computed with `shapeType`.
<span class="lineno">  102 </span>data TypeShape (tp :: CrucibleType) where
<span class="lineno">  103 </span>    PrimShape :: M.Ty -&gt; BaseTypeRepr btp -&gt; TypeShape (BaseToType btp)
<span class="lineno">  104 </span>    -- | A shape for tuples, as well as for tuple-like types (e.g.,
<span class="lineno">  105 </span>    -- 'M.TyFnDef', which is treated like an empty tuple).
<span class="lineno">  106 </span>    TupleShape :: M.Ty -&gt; [AgElemShape] -&gt; TypeShape MirAggregateType
<span class="lineno">  107 </span>    ArrayShape :: M.Ty
<span class="lineno">  108 </span>               -- ^ The array type
<span class="lineno">  109 </span>               -&gt; M.Ty
<span class="lineno">  110 </span>               -- ^ The array element type
<span class="lineno">  111 </span>               -&gt; Word
<span class="lineno">  112 </span>               -- ^ Size of the array element type, in bytes
<span class="lineno">  113 </span>               -&gt; TypeShape tp
<span class="lineno">  114 </span>               -- ^ `TypeShape` of the array element type
<span class="lineno">  115 </span>               -&gt; Word
<span class="lineno">  116 </span>               -- ^ Length of the array
<span class="lineno">  117 </span>               -&gt; TypeShape MirAggregateType
<span class="lineno">  118 </span>    StructShape :: M.Ty -&gt; [M.Ty] -&gt; Assignment FieldShape ctx -&gt; TypeShape (StructType ctx)
<span class="lineno">  119 </span>    TransparentShape :: M.Ty -&gt; TypeShape tp -&gt; TypeShape tp
<span class="lineno">  120 </span>    -- | Note that RefShape contains only a TypeRepr for the pointee type, not
<span class="lineno">  121 </span>    -- a TypeShape.  None of our operations need to recurse inside pointers,
<span class="lineno">  122 </span>    -- and also this saves us from some infinite recursion.
<span class="lineno">  123 </span>    --
<span class="lineno">  124 </span>    -- If there are raw pointer casts involved, the pointee type, the pointee
<span class="lineno">  125 </span>    -- type contained in the reference type, and the pointee 'TypeRepr' might
<span class="lineno">  126 </span>    -- not reflect the actual pointee type of any Crucible reference that is
<span class="lineno">  127 </span>    -- paired with this 'TypeShape'. See @Note [Raw pointer casts]@ in
<span class="lineno">  128 </span>    -- &quot;SAWCentral.Crucible.MIR.Setup.Value&quot; for more info.
<span class="lineno">  129 </span>    RefShape :: M.Ty
<span class="lineno">  130 </span>             -- ^ The reference type
<span class="lineno">  131 </span>             -&gt; M.Ty
<span class="lineno">  132 </span>             -- ^ The pointee type
<span class="lineno">  133 </span>             -&gt; M.Mutability
<span class="lineno">  134 </span>             -- ^ Is the reference mutable or immutable?
<span class="lineno">  135 </span>             -&gt; TypeRepr tp
<span class="lineno">  136 </span>             -- ^ The Crucible representation of the pointee type
<span class="lineno">  137 </span>             -&gt; TypeShape MirReferenceType
<span class="lineno">  138 </span>    -- | A shape for a slice reference of type @&amp;[T]@ or @&amp;str@, which is
<span class="lineno">  139 </span>    -- represented in @crucible-mir@ as a 'MirSlice', i.e., a 'StructType'
<span class="lineno">  140 </span>    -- where:
<span class="lineno">  141 </span>    --
<span class="lineno">  142 </span>    -- * The first type in the struct is a reference to the element type.
<span class="lineno">  143 </span>    --   If the slice reference has type @&amp;[T]@, then the element type is @T@.
<span class="lineno">  144 </span>    --   If the slice reference has type @&amp;str@, then the element type is @u8@.
<span class="lineno">  145 </span>    --
<span class="lineno">  146 </span>    -- * The second type in the struct is the length of the slice.
<span class="lineno">  147 </span>    --
<span class="lineno">  148 </span>    -- The @crucible-mir@ representations for tuples and slices are almost, but
<span class="lineno">  149 </span>    -- not quite, the same, as tuples can wrap their fields in 'MaybeType's (see
<span class="lineno">  150 </span>    -- 'FieldShape') but slices never do this. Nevertheless, many places in the
<span class="lineno">  151 </span>    -- code effectively treat tuples and slices identically (modulo 'MaybeType's).
<span class="lineno">  152 </span>    --
<span class="lineno">  153 </span>    -- To make it easier to recurse on the 'TypeShape's for the slice's
<span class="lineno">  154 </span>    -- reference and length types, we provide the 'sliceShapeParts' function.
<span class="lineno">  155 </span>    SliceShape :: M.Ty
<span class="lineno">  156 </span>               -- ^ The type of the slice reference (either @&amp;[T]@ or @&amp;str@).
<span class="lineno">  157 </span>               -&gt; M.Ty
<span class="lineno">  158 </span>               -- ^ The element type (either @T@ or @u8@).
<span class="lineno">  159 </span>               -&gt; M.Mutability
<span class="lineno">  160 </span>               -- ^ Is the reference mutable or immutable?
<span class="lineno">  161 </span>               -&gt; TypeRepr tp
<span class="lineno">  162 </span>               -- ^ The Crucible representation of the element type.
<span class="lineno">  163 </span>               -&gt; TypeShape MirSlice
<span class="lineno">  164 </span>    -- | A shape for an enum type.
<span class="lineno">  165 </span>    EnumShape :: M.Ty
<span class="lineno">  166 </span>              -- ^ The overall enum type.
<span class="lineno">  167 </span>              -&gt; [[M.Ty]]
<span class="lineno">  168 </span>              -- ^ The field types in each of the enum's variants.
<span class="lineno">  169 </span>              -&gt; Assignment VariantShape variantsCtx
<span class="lineno">  170 </span>              -- ^ The shapes of the enum type's variants.
<span class="lineno">  171 </span>              -&gt; M.Ty
<span class="lineno">  172 </span>              -- ^ The discriminant type.
<span class="lineno">  173 </span>              -&gt; TypeShape discrTp
<span class="lineno">  174 </span>              -- ^ The shape of the discriminant type.
<span class="lineno">  175 </span>              -&gt; TypeShape (RustEnumType discrTp variantsCtx)
<span class="lineno">  176 </span>    -- | Note that 'FnPtrShape' contains only 'TypeRepr's for the argument and
<span class="lineno">  177 </span>    -- result types, not 'TypeShape's, as none of our operations need to recurse
<span class="lineno">  178 </span>    -- inside them.
<span class="lineno">  179 </span>    FnPtrShape :: M.Ty -&gt; CtxRepr args -&gt; TypeRepr ret
<span class="lineno">  180 </span>               -&gt; TypeShape (FunctionHandleType args ret)
<span class="lineno">  181 </span>
<span class="lineno">  182 </span>-- TODO: Improve?
<span class="lineno">  183 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (TypeShape tp)</span></span> where
<span class="lineno">  184 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  185 </span>
<span class="lineno">  186 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show (TypeShape tp)</span></span></span></span></span></span>
<span class="lineno">  187 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF TypeShape</span></span></span></span></span></span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>-- | The TypeShape of a struct field, which might have a MaybeType wrapper to
<span class="lineno">  190 </span>-- allow for partial initialization.
<span class="lineno">  191 </span>data FieldShape (tp :: CrucibleType) where
<span class="lineno">  192 </span>    OptField :: TypeShape tp -&gt; FieldShape (MaybeType tp)
<span class="lineno">  193 </span>    ReqField :: TypeShape tp -&gt; FieldShape tp
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>-- TODO: Improve?
<span class="lineno">  196 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (FieldShape tp)</span></span> where
<span class="lineno">  197 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  198 </span>
<span class="lineno">  199 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show (FieldShape tp)</span></span></span></span></span></span>
<span class="lineno">  200 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF FieldShape</span></span></span></span></span></span>
<span class="lineno">  201 </span>
<span class="lineno">  202 </span>data AgElemShape where
<span class="lineno">  203 </span>    AgElemShape :: Word -&gt; Word -&gt; TypeShape tp -&gt; AgElemShape
<span class="lineno">  204 </span>
<span class="lineno">  205 </span>-- TODO: Improve?
<span class="lineno">  206 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty AgElemShape</span></span> where
<span class="lineno">  207 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  208 </span>
<span class="lineno">  209 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show AgElemShape</span></span></span></span></span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>
<span class="lineno">  212 </span>-- | The 'TypeShape' of an enum variant, which consists of some number of field
<span class="lineno">  213 </span>-- types.
<span class="lineno">  214 </span>--
<span class="lineno">  215 </span>-- This is indexed by a 'StructType', but that is simply an artifact of the
<span class="lineno">  216 </span>-- particular way that @crucible-mir@ encodes enum types. Despite the use of
<span class="lineno">  217 </span>-- 'StructType' as a type index, we only use 'VariantShape' for enums, not
<span class="lineno">  218 </span>-- structs.
<span class="lineno">  219 </span>data VariantShape (tp :: CrucibleType) where
<span class="lineno">  220 </span>    VariantShape :: Assignment FieldShape ctx
<span class="lineno">  221 </span>                 -- ^ The shapes of the variant's field types.
<span class="lineno">  222 </span>                 -&gt; VariantShape (StructType ctx)
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- TODO: Improve?
<span class="lineno">  225 </span>instance <span class="decl"><span class="nottickedoff">PP.Pretty (VariantShape tp)</span></span> where
<span class="lineno">  226 </span>  <span class="decl"><span class="nottickedoff">pretty = PP.viaShow</span></span>
<span class="lineno">  227 </span>
<span class="lineno">  228 </span><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">deriving instance Show (VariantShape tp)</span></span></span></span></span></span>
<span class="lineno">  229 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">ShowF VariantShape</span></span></span></span></span></span>
<span class="lineno">  230 </span>
<span class="lineno">  231 </span>-- | Return the `TypeShape` of `ty`.
<span class="lineno">  232 </span>--
<span class="lineno">  233 </span>-- It is guaranteed that the `tp :: CrucibleType` index of the resulting
<span class="lineno">  234 </span>-- `TypeShape` matches that returned by `tyToRepr`.
<span class="lineno">  235 </span>tyToShape :: M.Collection -&gt; M.Ty -&gt; Some TypeShape
<span class="lineno">  236 </span><span class="decl"><span class="istickedoff">tyToShape col = go</span>
<span class="lineno">  237 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">go :: M.Ty -&gt; Some TypeShape</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">go ty = case ty of</span>
<span class="lineno">  240 </span><span class="spaces">        </span><span class="istickedoff">M.TyBool -&gt; goPrim ty</span>
<span class="lineno">  241 </span><span class="spaces">        </span><span class="istickedoff">M.TyChar -&gt; goPrim ty</span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="istickedoff">M.TyInt _ -&gt; goPrim ty</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">M.TyUint _ -&gt; goPrim ty</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">M.TyTuple tys -&gt; goTuple ty tys</span>
<span class="lineno">  245 </span><span class="spaces">        </span><span class="istickedoff">M.TyClosure tys -&gt; <span class="nottickedoff">goTuple ty tys</span></span>
<span class="lineno">  246 </span><span class="spaces">        </span><span class="istickedoff">M.TyFnDef _ -&gt; <span class="nottickedoff">goTuple ty []</span></span>
<span class="lineno">  247 </span><span class="spaces">        </span><span class="istickedoff">M.TyArray ty' len | Some shp &lt;- go ty' -&gt;</span>
<span class="lineno">  248 </span><span class="spaces">          </span><span class="istickedoff">let elemSz = 1 in   -- TODO: hardcoded size=1</span>
<span class="lineno">  249 </span><span class="spaces">          </span><span class="istickedoff">Some $ ArrayShape ty ty' elemSz shp (fromIntegral len)</span>
<span class="lineno">  250 </span><span class="spaces">        </span><span class="istickedoff">M.TyAdt nm _ _ -&gt; case Map.lookup nm (col ^. M.adts) of</span>
<span class="lineno">  251 </span><span class="spaces">            </span><span class="istickedoff">Just adt | Just ty' &lt;- reprTransparentFieldTy col adt -&gt;</span>
<span class="lineno">  252 </span><span class="spaces">                </span><span class="istickedoff">mapSome (TransparentShape ty) $ go ty'</span>
<span class="lineno">  253 </span><span class="spaces">            </span><span class="istickedoff">Just (M.Adt _ kind vs _ _ _ _) -&gt;</span>
<span class="lineno">  254 </span><span class="spaces">              </span><span class="istickedoff">case kind of</span>
<span class="lineno">  255 </span><span class="spaces">                </span><span class="istickedoff">M.Struct</span>
<span class="lineno">  256 </span><span class="spaces">                  </span><span class="istickedoff">|  [v] &lt;- vs</span>
<span class="lineno">  257 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; goStruct ty (variantFieldTys v)</span>
<span class="lineno">  258 </span><span class="spaces">                  </span><span class="istickedoff">|  <span class="nottickedoff">otherwise</span></span>
<span class="lineno">  259 </span><span class="spaces">                  </span><span class="istickedoff">-&gt; <span class="nottickedoff">error $ &quot;tyToShape: Unexpected struct with multiple variants: &quot;</span></span>
<span class="lineno">  260 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">++ show (PP.pretty vs)</span></span>
<span class="lineno">  261 </span><span class="spaces">                </span><span class="istickedoff">M.Enum discrTy -&gt; goEnum ty discrTy vs</span>
<span class="lineno">  262 </span><span class="spaces">                </span><span class="istickedoff">M.Union -&gt; <span class="nottickedoff">error &quot;tyToShape: Union types NYI&quot;</span></span>
<span class="lineno">  263 </span><span class="spaces">            </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;tyToShape: bad adt: &quot; ++ show ty</span></span>
<span class="lineno">  264 </span><span class="spaces">        </span><span class="istickedoff">M.TyRef ty' mutbl -&gt; goRef ty ty' mutbl</span>
<span class="lineno">  265 </span><span class="spaces">        </span><span class="istickedoff">M.TyRawPtr ty' mutbl -&gt; goRef ty ty' mutbl</span>
<span class="lineno">  266 </span><span class="spaces">        </span><span class="istickedoff">M.TyFnPtr sig -&gt; <span class="nottickedoff">goFnPtr ty sig</span></span>
<span class="lineno">  267 </span><span class="spaces">        </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">error $ &quot;tyToShape: &quot; ++ show ty ++ &quot; NYI&quot;</span></span>
<span class="lineno">  268 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  269 </span><span class="spaces">    </span><span class="istickedoff">goPrim :: M.Ty -&gt; Some TypeShape</span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="istickedoff">goPrim ty =</span>
<span class="lineno">  271 </span><span class="spaces">      </span><span class="istickedoff">case tyToRepr <span class="nottickedoff">col</span> ty of</span>
<span class="lineno">  272 </span><span class="spaces">        </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">error (&quot;goPrim: type &quot; ++ show ty ++ &quot; not supported: &quot; ++ err)</span></span>
<span class="lineno">  273 </span><span class="spaces">        </span><span class="istickedoff">Right (Some tpr)</span>
<span class="lineno">  274 </span><span class="spaces">          </span><span class="istickedoff">| AsBaseType btpr &lt;- asBaseType tpr -&gt; Some (PrimShape ty btpr)</span>
<span class="lineno">  275 </span><span class="spaces">          </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> -&gt; <span class="nottickedoff">error (&quot;goPrim: type &quot; ++ show ty ++ &quot; produced non-primitive type &quot; ++ show tpr)</span></span>
<span class="lineno">  276 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  277 </span><span class="spaces">    </span><span class="istickedoff">goTuple :: M.Ty -&gt; [M.Ty] -&gt; Some TypeShape</span>
<span class="lineno">  278 </span><span class="spaces">    </span><span class="istickedoff">goTuple ty tys = Some $ TupleShape ty (zipWith mkElem [0..] tys)</span>
<span class="lineno">  279 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  280 </span><span class="spaces">        </span><span class="istickedoff">mkElem i ty' | Some shp &lt;- go ty' = AgElemShape i 1 shp</span>
<span class="lineno">  281 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  282 </span><span class="spaces">    </span><span class="istickedoff">goStruct :: M.Ty -&gt; [M.Ty] -&gt; Some TypeShape</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">goStruct ty tys | Some flds &lt;- goFields tys = Some $ StructShape ty <span class="nottickedoff">tys</span> flds</span>
<span class="lineno">  284 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  285 </span><span class="spaces">    </span><span class="istickedoff">-- The first Ty is the overall enum type, and the second Ty is the</span>
<span class="lineno">  286 </span><span class="spaces">    </span><span class="istickedoff">-- discriminant type.</span>
<span class="lineno">  287 </span><span class="spaces">    </span><span class="istickedoff">goEnum :: M.Ty -&gt; M.Ty -&gt; [M.Variant] -&gt; Some TypeShape</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="istickedoff">goEnum ty discrTy vs</span>
<span class="lineno">  289 </span><span class="spaces">        </span><span class="istickedoff">| Some discrShp &lt;- go discrTy</span>
<span class="lineno">  290 </span><span class="spaces">        </span><span class="istickedoff">, Some variants &lt;- loop vs Empty</span>
<span class="lineno">  291 </span><span class="spaces">        </span><span class="istickedoff">= Some $ EnumShape ty variantTys variants discrTy discrShp</span>
<span class="lineno">  292 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  293 </span><span class="spaces">        </span><span class="istickedoff">variantTys = map variantFieldTys vs</span>
<span class="lineno">  294 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  295 </span><span class="spaces">        </span><span class="istickedoff">loop ::</span>
<span class="lineno">  296 </span><span class="spaces">          </span><span class="istickedoff">forall ctx.</span>
<span class="lineno">  297 </span><span class="spaces">          </span><span class="istickedoff">[M.Variant] -&gt;</span>
<span class="lineno">  298 </span><span class="spaces">          </span><span class="istickedoff">Assignment VariantShape ctx -&gt;</span>
<span class="lineno">  299 </span><span class="spaces">          </span><span class="istickedoff">Some (Assignment VariantShape)</span>
<span class="lineno">  300 </span><span class="spaces">        </span><span class="istickedoff">loop [] variants = Some variants</span>
<span class="lineno">  301 </span><span class="spaces">        </span><span class="istickedoff">loop (v':vs') variants</span>
<span class="lineno">  302 </span><span class="spaces">          </span><span class="istickedoff">| Some variant &lt;- goVariant v'</span>
<span class="lineno">  303 </span><span class="spaces">          </span><span class="istickedoff">= loop vs' (variants :&gt; variant)</span>
<span class="lineno">  304 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  305 </span><span class="spaces">    </span><span class="istickedoff">-- Process a single Variant in an enum type.</span>
<span class="lineno">  306 </span><span class="spaces">    </span><span class="istickedoff">goVariant :: M.Variant -&gt; Some VariantShape</span>
<span class="lineno">  307 </span><span class="spaces">    </span><span class="istickedoff">goVariant v</span>
<span class="lineno">  308 </span><span class="spaces">        </span><span class="istickedoff">| Some flds &lt;- goFields tys</span>
<span class="lineno">  309 </span><span class="spaces">        </span><span class="istickedoff">= Some $ VariantShape flds</span>
<span class="lineno">  310 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  311 </span><span class="spaces">        </span><span class="istickedoff">tys = variantFieldTys v</span>
<span class="lineno">  312 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  313 </span><span class="spaces">    </span><span class="istickedoff">goFields :: [M.Ty] -&gt; Some (Assignment FieldShape)</span>
<span class="lineno">  314 </span><span class="spaces">    </span><span class="istickedoff">goFields tys = loop tys Empty</span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  316 </span><span class="spaces">        </span><span class="istickedoff">loop :: forall ctx. [M.Ty] -&gt; Assignment FieldShape ctx -&gt; Some (Assignment FieldShape)</span>
<span class="lineno">  317 </span><span class="spaces">        </span><span class="istickedoff">loop [] flds = Some flds</span>
<span class="lineno">  318 </span><span class="spaces">        </span><span class="istickedoff">loop (ty':tys') flds | Some fld &lt;- goField ty' = loop tys' (flds :&gt; fld)</span>
<span class="lineno">  319 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  320 </span><span class="spaces">    </span><span class="istickedoff">goField :: M.Ty -&gt; Some FieldShape</span>
<span class="lineno">  321 </span><span class="spaces">    </span><span class="istickedoff">goField ty | Some shp &lt;- go ty = case canInitialize col ty of</span>
<span class="lineno">  322 </span><span class="spaces">        </span><span class="istickedoff">True -&gt; Some $ ReqField shp</span>
<span class="lineno">  323 </span><span class="spaces">        </span><span class="istickedoff">False -&gt; Some $ OptField shp</span>
<span class="lineno">  324 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  325 </span><span class="spaces">    </span><span class="istickedoff">goRef :: M.Ty -&gt; M.Ty -&gt; M.Mutability -&gt; Some TypeShape</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">goRef ty ty' mutbl</span>
<span class="lineno">  327 </span><span class="spaces">      </span><span class="istickedoff">| M.TySlice slicedTy &lt;- ty' =</span>
<span class="lineno">  328 </span><span class="spaces">        </span><span class="istickedoff">case tyToRepr <span class="nottickedoff">col</span> slicedTy of</span>
<span class="lineno">  329 </span><span class="spaces">          </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">error (&quot;goRef: &quot; ++ err)</span></span>
<span class="lineno">  330 </span><span class="spaces">          </span><span class="istickedoff">Right (Some tpr) -&gt; Some (SliceShape ty slicedTy <span class="nottickedoff">mutbl</span> <span class="nottickedoff">tpr</span>)</span>
<span class="lineno">  331 </span><span class="spaces">      </span><span class="istickedoff">| M.TyStr &lt;- ty'</span>
<span class="lineno">  332 </span><span class="spaces">      </span><span class="istickedoff">= Some $ SliceShape ty (M.TyUint M.B8) <span class="nottickedoff">mutbl</span> <span class="nottickedoff">(BVRepr (knownNat @8))</span></span>
<span class="lineno">  333 </span><span class="spaces">    </span><span class="istickedoff">goRef ty ty' _ | <span class="tickonlyfalse">isUnsized ty'</span> = <span class="nottickedoff">error $</span></span>
<span class="lineno">  334 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot;tyToShape: fat pointer &quot; ++ show ty ++ &quot; NYI&quot;</span></span>
<span class="lineno">  335 </span><span class="spaces">    </span><span class="istickedoff">goRef ty ty' mutbl =</span>
<span class="lineno">  336 </span><span class="spaces">      </span><span class="istickedoff">case tyToRepr col ty' of</span>
<span class="lineno">  337 </span><span class="spaces">        </span><span class="istickedoff">Left err -&gt; <span class="nottickedoff">error (&quot;goRef: &quot; ++ err)</span></span>
<span class="lineno">  338 </span><span class="spaces">        </span><span class="istickedoff">Right (Some tpr) -&gt; Some (RefShape ty ty' mutbl tpr)</span>
<span class="lineno">  339 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  340 </span><span class="spaces">    </span><span class="istickedoff">goFnPtr :: M.Ty -&gt; M.FnSig -&gt; Some TypeShape</span>
<span class="lineno">  341 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">goFnPtr ty (M.FnSig args ret _abi) =</span></span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">case tyListToCtx col args $ \argsr  -&gt;</span></span>
<span class="lineno">  343 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">tyToReprCont col ret $ \retr -&gt;</span></span>
<span class="lineno">  344 </span><span class="spaces">             </span><span class="istickedoff"><span class="nottickedoff">Right (Some (FnPtrShape ty argsr retr)) of</span></span>
<span class="lineno">  345 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Left err -&gt; error (&quot;goFnPtr: &quot; ++ err)</span></span>
<span class="lineno">  346 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">Right x -&gt; x</span></span>
<span class="lineno">  347 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  348 </span><span class="spaces">    </span><span class="istickedoff">-- Retrieve the field types in a variant. This used for both struct and enum</span>
<span class="lineno">  349 </span><span class="spaces">    </span><span class="istickedoff">-- variants.</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="istickedoff">variantFieldTys :: M.Variant -&gt; [M.Ty]</span>
<span class="lineno">  351 </span><span class="spaces">    </span><span class="istickedoff">variantFieldTys v = v ^.. M.vfields . each . M.fty</span></span>
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>-- | Given a `Ty` and the result of `tyToRepr ty`, produce a `TypeShape` with
<span class="lineno">  354 </span>-- the same index `tp`.  Raises an `error` if the `TypeRepr` doesn't match
<span class="lineno">  355 </span>-- `tyToRepr ty`.
<span class="lineno">  356 </span>tyToShapeEq :: HasCallStack =&gt; M.Collection -&gt; M.Ty -&gt; TypeRepr tp -&gt; TypeShape tp
<span class="lineno">  357 </span><span class="decl"><span class="istickedoff">tyToShapeEq col ty tpr | Some shp &lt;- tyToShape col ty =</span>
<span class="lineno">  358 </span><span class="spaces">    </span><span class="istickedoff">case testEquality (shapeType shp) tpr of</span>
<span class="lineno">  359 </span><span class="spaces">        </span><span class="istickedoff">Just Refl -&gt; shp</span>
<span class="lineno">  360 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;tyToShapeEq: type &quot; ++ show ty ++</span></span>
<span class="lineno">  361 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot; does not have representation &quot; ++ show tpr ++</span></span>
<span class="lineno">  362 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">&quot; (got &quot; ++ show (shapeType shp) ++ &quot; instead)&quot;</span></span></span>
<span class="lineno">  363 </span>
<span class="lineno">  364 </span>shapeType :: TypeShape tp -&gt; TypeRepr tp
<span class="lineno">  365 </span><span class="decl"><span class="istickedoff">shapeType = go</span>
<span class="lineno">  366 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="istickedoff">go :: forall tp. TypeShape tp -&gt; TypeRepr tp</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">go (PrimShape _ btpr) = baseToType btpr</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">go (TupleShape _ _) = MirAggregateRepr</span>
<span class="lineno">  370 </span><span class="spaces">    </span><span class="istickedoff">go (ArrayShape _ _ _ _ _) = MirAggregateRepr</span>
<span class="lineno">  371 </span><span class="spaces">    </span><span class="istickedoff">go (StructShape _ _ flds) = StructRepr $ fmapFC fieldShapeType flds</span>
<span class="lineno">  372 </span><span class="spaces">    </span><span class="istickedoff">go (EnumShape _ _ variantTys _ discrShp) =</span>
<span class="lineno">  373 </span><span class="spaces">      </span><span class="istickedoff">RustEnumRepr (shapeType discrShp) (fmapFC variantShapeType variantTys)</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="istickedoff">go (TransparentShape _ shp) = go shp</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="istickedoff">go (RefShape _ _ _ _) = MirReferenceRepr</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="istickedoff">go (SliceShape _ _ _ _) = MirSliceRepr</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">go (FnPtrShape _ args ret) = <span class="nottickedoff">FunctionHandleRepr args ret</span></span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>fieldShapeType :: FieldShape tp -&gt; TypeRepr tp
<span class="lineno">  380 </span><span class="decl"><span class="istickedoff">fieldShapeType (ReqField shp) = shapeType shp</span>
<span class="lineno">  381 </span><span class="spaces"></span><span class="istickedoff">fieldShapeType (OptField shp) = MaybeRepr $ shapeType shp</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>variantShapeType :: VariantShape tp -&gt; TypeRepr tp
<span class="lineno">  384 </span><span class="decl"><span class="istickedoff">variantShapeType (VariantShape flds) =</span>
<span class="lineno">  385 </span><span class="spaces">  </span><span class="istickedoff">StructRepr $ fmapFC fieldShapeType flds</span></span>
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>shapeMirTy :: TypeShape tp -&gt; M.Ty
<span class="lineno">  388 </span><span class="decl"><span class="istickedoff">shapeMirTy (PrimShape ty _) = ty</span>
<span class="lineno">  389 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (TupleShape ty _) = <span class="nottickedoff">ty</span></span>
<span class="lineno">  390 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (ArrayShape ty _ _ _ _) = ty</span>
<span class="lineno">  391 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (StructShape ty _ _) = ty</span>
<span class="lineno">  392 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (EnumShape ty _ _ _ _) = ty</span>
<span class="lineno">  393 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (TransparentShape ty _) = ty</span>
<span class="lineno">  394 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (RefShape ty _ _ _) = ty</span>
<span class="lineno">  395 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (SliceShape ty _ _ _) = ty</span>
<span class="lineno">  396 </span><span class="spaces"></span><span class="istickedoff">shapeMirTy (FnPtrShape ty _ _) = <span class="nottickedoff">ty</span></span></span>
<span class="lineno">  397 </span>
<span class="lineno">  398 </span>fieldShapeMirTy :: FieldShape tp -&gt; M.Ty
<span class="lineno">  399 </span><span class="decl"><span class="nottickedoff">fieldShapeMirTy (ReqField shp) = shapeMirTy shp</span>
<span class="lineno">  400 </span><span class="spaces"></span><span class="nottickedoff">fieldShapeMirTy (OptField shp) = shapeMirTy shp</span></span>
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>-- | This is to accomodate multiple Rust types mapping to the same Cryptol
<span class="lineno">  403 </span>-- type.  For example, if a Cryptol function expects [3][8], we could map
<span class="lineno">  404 </span>-- it to a Rust function that either expects `[u8;3]`, or `&amp;[u8]` with a
<span class="lineno">  405 </span>-- dynamic check that it has 3 elements.  The type parameter `a` is for the
<span class="lineno">  406 </span>-- the lengths of the slices---it will be either Cryptol's `Type` during
<span class="lineno">  407 </span>-- type checking, or `Integer`, once we instantiate a schema at a concrete
<span class="lineno">  408 </span>-- type.
<span class="lineno">  409 </span>data CryTermAdaptor a =
<span class="lineno">  410 </span>    NoAdapt                               -- ^ Use default translation
<span class="lineno">  411 </span>  | AdaptTuple [CryTermAdaptor a]         -- ^ Adapt a tuple
<span class="lineno">  412 </span>  | AdaptArray (CryTermAdaptor a)         -- ^ Adapt an array
<span class="lineno">  413 </span>  | AdaptDerefSlice M.Collection a (CryTermAdaptor a)
<span class="lineno">  414 </span>    -- ^ A reference to a slice.
<span class="lineno">  415 </span>    -- We also store the 'M.Collection' here so that we can convert the
<span class="lineno">  416 </span>    -- element type's 'TypeRepr' to a 'TypeShape' when we need to (see,
<span class="lineno">  417 </span>    -- for instance, the implementation of `shapeToTerm'`).
<span class="lineno">  418 </span>  | AdaptDerefRef M.Collection (CryTermAdaptor a) -- ^ Transparently adapt a reference
<span class="lineno">  419 </span>    deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Traversable</span></span></span></span></span></span></span></span>)
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>isCryNoAdapt :: CryTermAdaptor a -&gt; Bool
<span class="lineno">  422 </span><span class="decl"><span class="nottickedoff">isCryNoAdapt ada =</span>
<span class="lineno">  423 </span><span class="spaces">  </span><span class="nottickedoff">case ada of</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="nottickedoff">NoAdapt -&gt; True</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="nottickedoff">_       -&gt; False</span></span>
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>adaptTuple :: [CryTermAdaptor a] -&gt; CryTermAdaptor a
<span class="lineno">  428 </span><span class="decl"><span class="nottickedoff">adaptTuple as</span>
<span class="lineno">  429 </span><span class="spaces">  </span><span class="nottickedoff">| all isCryNoAdapt as = NoAdapt</span>
<span class="lineno">  430 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = AdaptTuple as</span></span>
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>adaptArray :: CryTermAdaptor a -&gt; CryTermAdaptor a
<span class="lineno">  433 </span><span class="decl"><span class="nottickedoff">adaptArray a</span>
<span class="lineno">  434 </span><span class="spaces">  </span><span class="nottickedoff">| isCryNoAdapt a = NoAdapt</span>
<span class="lineno">  435 </span><span class="spaces">  </span><span class="nottickedoff">| otherwise = AdaptArray a</span></span>
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>shapeToTerm :: forall tp m.
<span class="lineno">  438 </span>    (MonadIO m, MonadFail m) =&gt;
<span class="lineno">  439 </span>    SAW.SharedContext -&gt;
<span class="lineno">  440 </span>    TypeShape tp -&gt;
<span class="lineno">  441 </span>    m SAW.Term
<span class="lineno">  442 </span><span class="decl"><span class="istickedoff">shapeToTerm sc = shapeToTerm' sc NoAdapt</span></span>
<span class="lineno">  443 </span>
<span class="lineno">  444 </span>-- | Convert a type shape to a `Term` representing the type of values we'd
<span class="lineno">  445 </span>-- get for the type shape.  References to slices are mapped to vectors (the values
<span class="lineno">  446 </span>-- pointed to by the reference), and the `CryTermAnnot`, if any,
<span class="lineno">  447 </span>-- contains the information about the length of the vector.
<span class="lineno">  448 </span>shapeToTerm' :: forall tp m.
<span class="lineno">  449 </span>    (MonadIO m, MonadFail m) =&gt;
<span class="lineno">  450 </span>    SAW.SharedContext -&gt;
<span class="lineno">  451 </span>    CryTermAdaptor Integer -&gt;
<span class="lineno">  452 </span>    TypeShape tp -&gt;
<span class="lineno">  453 </span>    m SAW.Term
<span class="lineno">  454 </span><span class="decl"><span class="istickedoff">shapeToTerm' sc = go</span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  456 </span><span class="spaces">    </span><span class="istickedoff">go :: forall tp'. CryTermAdaptor Integer -&gt; TypeShape tp' -&gt; m SAW.Term</span>
<span class="lineno">  457 </span><span class="spaces">    </span><span class="istickedoff">go NoAdapt (PrimShape _ BaseBoolRepr) = <span class="nottickedoff">liftIO $ SAW.scBoolType sc</span></span>
<span class="lineno">  458 </span><span class="spaces">    </span><span class="istickedoff">go NoAdapt (PrimShape _ (BaseBVRepr w)) = liftIO $ SAW.scBitvector sc (natValue w)</span>
<span class="lineno">  459 </span><span class="spaces">    </span><span class="istickedoff">go ada (TupleShape _ elems) = do</span>
<span class="lineno">  460 </span><span class="spaces">        </span><span class="istickedoff">subAda &lt;- case ada of</span>
<span class="lineno">  461 </span><span class="spaces">                    </span><span class="istickedoff">NoAdapt -&gt; pure (repeat NoAdapt)</span>
<span class="lineno">  462 </span><span class="spaces">                    </span><span class="istickedoff">AdaptTuple as -&gt; <span class="nottickedoff">pure as</span></span>
<span class="lineno">  463 </span><span class="spaces">                    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;Expected a tuple Cryptol adaptor&quot;</span></span>
<span class="lineno">  464 </span><span class="spaces">        </span><span class="istickedoff">tys &lt;- zipWithM goAgElem subAda elems</span>
<span class="lineno">  465 </span><span class="spaces">        </span><span class="istickedoff">liftIO $ SAW.scTupleType sc tys</span>
<span class="lineno">  466 </span><span class="spaces">    </span><span class="istickedoff">go ada (ArrayShape _ _ _ shp len) = do</span>
<span class="lineno">  467 </span><span class="spaces">        </span><span class="istickedoff">sub &lt;- case ada of</span>
<span class="lineno">  468 </span><span class="spaces">                 </span><span class="istickedoff">NoAdapt -&gt; pure NoAdapt</span>
<span class="lineno">  469 </span><span class="spaces">                 </span><span class="istickedoff">AdaptArray a -&gt; <span class="nottickedoff">pure a</span></span>
<span class="lineno">  470 </span><span class="spaces">                 </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">fail &quot;Expected an array Cryptol adaptor&quot;</span></span>
<span class="lineno">  471 </span><span class="spaces">        </span><span class="istickedoff">ty &lt;- go sub shp</span>
<span class="lineno">  472 </span><span class="spaces">        </span><span class="istickedoff">liftIO (mkVec len ty)</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">go (AdaptDerefSlice col n ada) (SliceShape _ elT M.Immut tpr) =</span>
<span class="lineno">  474 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">do et &lt;- go ada (tyToShapeEq col elT tpr)</span></span>
<span class="lineno">  475 </span><span class="spaces">         </span><span class="istickedoff"><span class="nottickedoff">liftIO (mkVec n et)</span></span>
<span class="lineno">  476 </span><span class="spaces">    </span><span class="istickedoff">go (AdaptDerefRef col ada) (RefShape _ elT M.Immut tpr) =</span>
<span class="lineno">  477 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">go ada (tyToShapeEq col elT tpr)</span></span>
<span class="lineno">  478 </span><span class="spaces">    </span><span class="istickedoff">go _ada shp = <span class="nottickedoff">fail $ &quot;shapeToTerm: unsupported type &quot; ++ show (shapeType shp)</span></span>
<span class="lineno">  479 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  480 </span><span class="spaces">    </span><span class="istickedoff">mkVec :: Integral a =&gt; a -&gt; SAW.Term -&gt; IO SAW.Term</span>
<span class="lineno">  481 </span><span class="spaces">    </span><span class="istickedoff">mkVec n ty =</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">do</span>
<span class="lineno">  483 </span><span class="spaces">        </span><span class="istickedoff">n' &lt;- SAW.scNat sc (fromIntegral n)</span>
<span class="lineno">  484 </span><span class="spaces">        </span><span class="istickedoff">SAW.scVecType sc n' ty</span>
<span class="lineno">  485 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  486 </span><span class="spaces">    </span><span class="istickedoff">goAgElem :: CryTermAdaptor Integer -&gt; AgElemShape -&gt; m SAW.Term</span>
<span class="lineno">  487 </span><span class="spaces">    </span><span class="istickedoff">goAgElem ada (AgElemShape _ _ shp) = go ada shp</span></span>
<span class="lineno">  488 </span>
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>-- | A witness that a 'TypeShape' is equal to a 'PrimShape' that characterizes
<span class="lineno">  491 </span>-- a bitvector.
<span class="lineno">  492 </span>data IsBVShape (tp :: CrucibleType) where
<span class="lineno">  493 </span>  IsBVShape :: (1 &lt;= w)
<span class="lineno">  494 </span>            =&gt; M.Ty
<span class="lineno">  495 </span>            -&gt; NatRepr w
<span class="lineno">  496 </span>            -&gt; IsBVShape (BVType w)
<span class="lineno">  497 </span>
<span class="lineno">  498 </span>-- | Check that a 'TypeShape' is equal to a 'PrimShape' that characterizes a
<span class="lineno">  499 </span>-- bitvector. If so, return 'Just' a witness of that equality. Otherwise, return
<span class="lineno">  500 </span>-- 'Nothing'.
<span class="lineno">  501 </span>testBVShape :: TypeShape tp -&gt; Maybe (IsBVShape tp)
<span class="lineno">  502 </span><span class="decl"><span class="istickedoff">testBVShape shp =</span>
<span class="lineno">  503 </span><span class="spaces">  </span><span class="istickedoff">case shp of</span>
<span class="lineno">  504 </span><span class="spaces">    </span><span class="istickedoff">PrimShape ty (BaseBVRepr w)</span>
<span class="lineno">  505 </span><span class="spaces">      </span><span class="istickedoff">-&gt; Just $ IsBVShape ty w</span>
<span class="lineno">  506 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>-- | A witness that a 'TypeShape' is equal to a 'RefShape'.
<span class="lineno">  509 </span>data IsRefShape (tp :: CrucibleType) where
<span class="lineno">  510 </span>  IsRefShape :: M.Ty
<span class="lineno">  511 </span>             -- ^ The reference type
<span class="lineno">  512 </span>             -&gt; M.Ty
<span class="lineno">  513 </span>             -- ^ The pointee type
<span class="lineno">  514 </span>             -&gt; M.Mutability
<span class="lineno">  515 </span>             -- ^ Is the reference mutable or immutable?
<span class="lineno">  516 </span>             -&gt; TypeRepr tp
<span class="lineno">  517 </span>             -- ^ The Crucible representation of the pointee type
<span class="lineno">  518 </span>             -&gt; IsRefShape MirReferenceType
<span class="lineno">  519 </span>
<span class="lineno">  520 </span>-- | Check that a 'TypeShape' is equal to a 'RefShape'. If so, return 'Just' a
<span class="lineno">  521 </span>-- witness of that equality. Otherwise, return 'Nothing'.
<span class="lineno">  522 </span>testRefShape :: TypeShape tp -&gt; Maybe (IsRefShape tp)
<span class="lineno">  523 </span><span class="decl"><span class="istickedoff">testRefShape shp =</span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="istickedoff">case shp of</span>
<span class="lineno">  525 </span><span class="spaces">    </span><span class="istickedoff">RefShape ty ty' mut shp'</span>
<span class="lineno">  526 </span><span class="spaces">      </span><span class="istickedoff">-&gt; Just $ IsRefShape <span class="nottickedoff">ty</span> ty' <span class="nottickedoff">mut</span> shp'</span>
<span class="lineno">  527 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>-- | Construct the 'TypeShape's for a slice's reference and length types.
<span class="lineno">  530 </span>sliceShapeParts ::
<span class="lineno">  531 </span>    M.Ty -&gt;
<span class="lineno">  532 </span>    M.Mutability -&gt;
<span class="lineno">  533 </span>    TypeRepr tp -&gt;
<span class="lineno">  534 </span>    (TypeShape MirReferenceType, TypeShape UsizeType)
<span class="lineno">  535 </span><span class="decl"><span class="nottickedoff">sliceShapeParts referentTy refMutbl referentTpr =</span>
<span class="lineno">  536 </span><span class="spaces">    </span><span class="nottickedoff">( RefShape refTy referentTy refMutbl referentTpr</span>
<span class="lineno">  537 </span><span class="spaces">    </span><span class="nottickedoff">, PrimShape usizeTy BaseUsizeRepr</span>
<span class="lineno">  538 </span><span class="spaces">    </span><span class="nottickedoff">)</span>
<span class="lineno">  539 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  540 </span><span class="spaces">    </span><span class="nottickedoff">-- We use a ref (of the same mutability as `ty`) when possible, to</span>
<span class="lineno">  541 </span><span class="spaces">    </span><span class="nottickedoff">-- avoid unnecessary clobbering.</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="nottickedoff">refTy = M.TyRef referentTy refMutbl</span>
<span class="lineno">  543 </span><span class="spaces">    </span><span class="nottickedoff">usizeTy = M.TyUint M.USize</span></span>
<span class="lineno">  544 </span>
<span class="lineno">  545 </span>
<span class="lineno">  546 </span>-- Helpers for manipulating `MirAggregate` with matching `AgElemShape`s.
<span class="lineno">  547 </span>
<span class="lineno">  548 </span>agCheckLengthsEq :: Monad m =&gt; Text -&gt; [AgElemShape] -&gt; [a] -&gt; m ()
<span class="lineno">  549 </span><span class="decl"><span class="istickedoff">agCheckLengthsEq loc elems xs =</span>
<span class="lineno">  550 </span><span class="spaces">  </span><span class="istickedoff">when (length elems /= length xs) $</span>
<span class="lineno">  551 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">panic loc</span></span>
<span class="lineno">  552 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;got &quot; ++ show (length elems) ++ &quot; elems, but &quot; ++ show (length xs) ++ &quot; xs&quot;]</span></span></span>
<span class="lineno">  553 </span>
<span class="lineno">  554 </span>agCheckKeysEq :: MonadFail m =&gt; String -&gt; [AgElemShape] -&gt; IntMap (MirAggregateEntry sym) -&gt; m ()
<span class="lineno">  555 </span><span class="decl"><span class="istickedoff">agCheckKeysEq loc elems m = do</span>
<span class="lineno">  556 </span><span class="spaces">  </span><span class="istickedoff">let mKeys = IntMap.keysSet m</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff">let elemsKeys = IntSet.fromList [fromIntegral off | AgElemShape off _ _ &lt;- elems]</span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="istickedoff">when (mKeys /= elemsKeys) $</span>
<span class="lineno">  559 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">if mKeys `IntSet.isSubsetOf` elemsKeys</span></span>
<span class="lineno">  560 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">then fail $ loc ++ &quot;: missing or uninitialized fields at offsets &quot;</span></span>
<span class="lineno">  561 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show (elemsKeys IntSet.\\ mKeys)</span></span>
<span class="lineno">  562 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">else fail $ loc ++ &quot;: expected aggregate to have fields at offsets &quot;</span></span>
<span class="lineno">  563 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show elemsKeys ++ &quot;, but got fields at offsets &quot; ++ show mKeys</span></span></span>
<span class="lineno">  564 </span>
<span class="lineno">  565 </span>-- | Build a `MirAggregate` with one entry for each provided `AgElemShape`.
<span class="lineno">  566 </span>-- The callback receives the offset, size, and type of the entry, along with
<span class="lineno">  567 </span>-- the corresponding value from @xs@ (which must have as many items as there
<span class="lineno">  568 </span>-- are `AgElemShape`s), and the result of the callback is used as the value for
<span class="lineno">  569 </span>-- the entry.
<span class="lineno">  570 </span>buildMirAggregate ::
<span class="lineno">  571 </span>  (IsSymInterface sym, Monad m, MonadFail m) =&gt;
<span class="lineno">  572 </span>  sym -&gt;
<span class="lineno">  573 </span>  [AgElemShape] -&gt;
<span class="lineno">  574 </span>  [a] -&gt;
<span class="lineno">  575 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; a -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  576 </span>  m (MirAggregate sym)
<span class="lineno">  577 </span><span class="decl"><span class="istickedoff">buildMirAggregate sym elems xs f = do</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="istickedoff">agCheckLengthsEq <span class="nottickedoff">&quot;buildMirAggregate&quot;</span> elems xs</span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="istickedoff">let totalSize = maximum (0 : [off + sz | AgElemShape off sz _ &lt;- elems])</span>
<span class="lineno">  580 </span><span class="spaces">  </span><span class="istickedoff">entries &lt;- forM (zip elems xs) $ \(AgElemShape off sz shp, x) -&gt; do</span>
<span class="lineno">  581 </span><span class="spaces">    </span><span class="istickedoff">rv &lt;- f <span class="nottickedoff">off</span> <span class="nottickedoff">sz</span> shp x</span>
<span class="lineno">  582 </span><span class="spaces">    </span><span class="istickedoff">let rvPart = W4.justPartExpr sym rv</span>
<span class="lineno">  583 </span><span class="spaces">    </span><span class="istickedoff">return (fromIntegral off, MirAggregateEntry sz (shapeType shp) rvPart)</span>
<span class="lineno">  584 </span><span class="spaces">  </span><span class="istickedoff">return $ MirAggregate totalSize (IntMap.fromList entries)</span></span>
<span class="lineno">  585 </span>
<span class="lineno">  586 </span>-- | Modify the value of each entry in a `MirAggregate`.  The callback gets the
<span class="lineno">  587 </span>-- offset, size, type, and value of the entry, and its result is stored as the
<span class="lineno">  588 </span>-- new value in the output.
<span class="lineno">  589 </span>traverseMirAggregate ::
<span class="lineno">  590 </span>  forall sym m.
<span class="lineno">  591 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  592 </span>  sym -&gt;
<span class="lineno">  593 </span>  [AgElemShape] -&gt;
<span class="lineno">  594 </span>  MirAggregate sym -&gt;
<span class="lineno">  595 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  596 </span>  m (MirAggregate sym)
<span class="lineno">  597 </span><span class="decl"><span class="nottickedoff">traverseMirAggregate sym elems (MirAggregate totalSize m) f = do</span>
<span class="lineno">  598 </span><span class="spaces">  </span><span class="nottickedoff">agCheckKeysEq &quot;traverseMirAggregate&quot; elems m</span>
<span class="lineno">  599 </span><span class="spaces">  </span><span class="nottickedoff">m' &lt;-</span>
<span class="lineno">  600 </span><span class="spaces">    </span><span class="nottickedoff">-- Hack: we include a special case for when the list of AgElemShapes and</span>
<span class="lineno">  601 </span><span class="spaces">    </span><span class="nottickedoff">-- the MirAggregate are both empty, skipping the call to mergeEntries</span>
<span class="lineno">  602 </span><span class="spaces">    </span><span class="nottickedoff">-- entirely if this is the case. This is because mergeEntries calls</span>
<span class="lineno">  603 </span><span class="spaces">    </span><span class="nottickedoff">-- IntMap.mergeWithKey under the hood, and prior to containers-0.8, the</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="nottickedoff">-- implementation of IntMap.mergeWithKey had a bug where merging two empty</span>
<span class="lineno">  605 </span><span class="spaces">    </span><span class="nottickedoff">-- IntMaps would invoke the third callback argument instead of just</span>
<span class="lineno">  606 </span><span class="spaces">    </span><span class="nottickedoff">-- returning an empty map. (See</span>
<span class="lineno">  607 </span><span class="spaces">    </span><span class="nottickedoff">-- https://github.com/haskell/containers/issues/979.) Note that</span>
<span class="lineno">  608 </span><span class="spaces">    </span><span class="nottickedoff">-- mergeEntries uses the third callback argument to panic, however, and we</span>
<span class="lineno">  609 </span><span class="spaces">    </span><span class="nottickedoff">-- definitely don't want to panic if the IntMaps are both empty!</span>
<span class="lineno">  610 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno">  611 </span><span class="spaces">    </span><span class="nottickedoff">-- Because SAW still supports GHC versions that bundle versions of</span>
<span class="lineno">  612 </span><span class="spaces">    </span><span class="nottickedoff">-- containers that are older than 0.8 (and therefore do not contain a fix</span>
<span class="lineno">  613 </span><span class="spaces">    </span><span class="nottickedoff">-- for the issue above), we include this special case as a workaround. Once</span>
<span class="lineno">  614 </span><span class="spaces">    </span><span class="nottickedoff">-- SAW drops support for pre-0.8 versions of containers, we can remove this</span>
<span class="lineno">  615 </span><span class="spaces">    </span><span class="nottickedoff">-- special case.</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="nottickedoff">if null elems &amp;&amp; IntMap.null m</span>
<span class="lineno">  617 </span><span class="spaces">      </span><span class="nottickedoff">then pure IntMap.empty</span>
<span class="lineno">  618 </span><span class="spaces">      </span><span class="nottickedoff">else mergeEntries</span>
<span class="lineno">  619 </span><span class="spaces">  </span><span class="nottickedoff">return $ MirAggregate totalSize m'</span>
<span class="lineno">  620 </span><span class="spaces"> </span><span class="nottickedoff">where</span>
<span class="lineno">  621 </span><span class="spaces">  </span><span class="nottickedoff">-- Merge the existing MirAggregate's entries together with the new entries</span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="nottickedoff">-- from the list of AgElemShapes.</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="nottickedoff">--</span>
<span class="lineno">  624 </span><span class="spaces">  </span><span class="nottickedoff">-- Precondition: both the list of AgElemShapes and the MirAggregate are</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="nottickedoff">-- non-empty (see the comments above near mergeEntries' call site).</span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="nottickedoff">mergeEntries :: m (IntMap (MirAggregateEntry sym))</span>
<span class="lineno">  627 </span><span class="spaces">  </span><span class="nottickedoff">mergeEntries = sequence $ IntMap.mergeWithKey</span>
<span class="lineno">  628 </span><span class="spaces">    </span><span class="nottickedoff">(\_off' (AgElemShape off _sz' shp) (MirAggregateEntry sz tpr rvPart) -&gt; Just $ do</span>
<span class="lineno">  629 </span><span class="spaces">        </span><span class="nottickedoff">Refl &lt;- case testEquality tpr (shapeType shp) of</span>
<span class="lineno">  630 </span><span class="spaces">            </span><span class="nottickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  631 </span><span class="spaces">            </span><span class="nottickedoff">Nothing -&gt; fail $ &quot;traverseMirAggregate: ill-typed field value at offset &quot;</span>
<span class="lineno">  632 </span><span class="spaces">              </span><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr</span>
<span class="lineno">  633 </span><span class="spaces">        </span><span class="nottickedoff">let rv = readMaybeType sym &quot;elem&quot; tpr rvPart</span>
<span class="lineno">  634 </span><span class="spaces">        </span><span class="nottickedoff">rv' &lt;- f off sz shp rv</span>
<span class="lineno">  635 </span><span class="spaces">        </span><span class="nottickedoff">let rvPart' = W4.justPartExpr sym rv'</span>
<span class="lineno">  636 </span><span class="spaces">        </span><span class="nottickedoff">return $ MirAggregateEntry sz tpr rvPart')</span>
<span class="lineno">  637 </span><span class="spaces">    </span><span class="nottickedoff">(\_ -&gt; panic &quot;traverseMirAggregate&quot; [&quot;mismatched keys in aggregate&quot;])</span>
<span class="lineno">  638 </span><span class="spaces">    </span><span class="nottickedoff">(\_ -&gt; panic &quot;traverseMirAggregate&quot; [&quot;mismatched keys in aggregate&quot;])</span>
<span class="lineno">  639 </span><span class="spaces">    </span><span class="nottickedoff">(IntMap.fromList [(fromIntegral off, e) | e@(AgElemShape off _ _) &lt;- elems])</span>
<span class="lineno">  640 </span><span class="spaces">    </span><span class="nottickedoff">m</span></span>
<span class="lineno">  641 </span>
<span class="lineno">  642 </span>-- | Extract values from a `MirAggregate`, one for each entry.  The callback
<span class="lineno">  643 </span>-- gets the offset, size, type, and value of the entry.  Callback results are
<span class="lineno">  644 </span>-- returned in a list in the same order as @elems@.
<span class="lineno">  645 </span>accessMirAggregate ::
<span class="lineno">  646 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  647 </span>  sym -&gt;
<span class="lineno">  648 </span>  [AgElemShape] -&gt;
<span class="lineno">  649 </span>  MirAggregate sym -&gt;
<span class="lineno">  650 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; m b) -&gt;
<span class="lineno">  651 </span>  m [b]
<span class="lineno">  652 </span><span class="decl"><span class="nottickedoff">accessMirAggregate sym elems ag f =</span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="nottickedoff">accessMirAggregate' sym elems [() | _ &lt;- elems] ag $</span>
<span class="lineno">  654 </span><span class="spaces">    </span><span class="nottickedoff">\off sz shp val () -&gt; f off sz shp val</span></span>
<span class="lineno">  655 </span>
<span class="lineno">  656 </span>
<span class="lineno">  657 </span>-- | Extract values from a `MirAggregate`, one for each entry.  This is like
<span class="lineno">  658 </span>-- `accessMirAggregate`, but the callback also gets the value from the input
<span class="lineno">  659 </span>-- list @xs@ that corresponds to the current entry.
<span class="lineno">  660 </span>accessMirAggregate' ::
<span class="lineno">  661 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  662 </span>  sym -&gt;
<span class="lineno">  663 </span>  [AgElemShape] -&gt;
<span class="lineno">  664 </span>  [a] -&gt;
<span class="lineno">  665 </span>  MirAggregate sym -&gt;
<span class="lineno">  666 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; a -&gt; m b) -&gt;
<span class="lineno">  667 </span>  m [b]
<span class="lineno">  668 </span><span class="decl"><span class="istickedoff">accessMirAggregate' sym elems xs (MirAggregate _totalSize m) f = do</span>
<span class="lineno">  669 </span><span class="spaces">  </span><span class="istickedoff">agCheckLengthsEq <span class="nottickedoff">&quot;accessMirAggregate'&quot;</span> elems xs</span>
<span class="lineno">  670 </span><span class="spaces">  </span><span class="istickedoff">agCheckKeysEq <span class="nottickedoff">&quot;accessMirAggregate'&quot;</span> elems m</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="istickedoff">forM (zip elems xs) $ \(AgElemShape off sz shp, x) -&gt; do</span>
<span class="lineno">  672 </span><span class="spaces">    </span><span class="istickedoff">MirAggregateEntry _sz' tpr rvPart &lt;-</span>
<span class="lineno">  673 </span><span class="spaces">      </span><span class="istickedoff">case IntMap.lookup (fromIntegral off) m of</span>
<span class="lineno">  674 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; return e</span>
<span class="lineno">  675 </span><span class="spaces">        </span><span class="istickedoff">-- Should be impossible, since we checked above that the key sets</span>
<span class="lineno">  676 </span><span class="spaces">        </span><span class="istickedoff">-- match.</span>
<span class="lineno">  677 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;accessMirAggregate&quot;</span></span>
<span class="lineno">  678 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;missing MirAggregateEntry at offset &quot; ++ show off]</span></span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="istickedoff">Refl &lt;- case testEquality tpr (shapeType shp) of</span>
<span class="lineno">  680 </span><span class="spaces">      </span><span class="istickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  681 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;accessMirAggregate: ill-typed field value at offset &quot;</span></span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr</span></span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff">let rv = readMaybeType <span class="nottickedoff">sym</span> <span class="nottickedoff">&quot;elem&quot;</span> <span class="nottickedoff">tpr</span> rvPart</span>
<span class="lineno">  684 </span><span class="spaces">    </span><span class="istickedoff">f <span class="nottickedoff">off</span> <span class="nottickedoff">sz</span> shp rv x</span></span>
<span class="lineno">  685 </span>
<span class="lineno">  686 </span>-- | Zip together two `MirAggregate`s and extract values from them.  The callback
<span class="lineno">  687 </span>-- gets the offset, size, type, and the value at that offset in each aggregate.
<span class="lineno">  688 </span>-- Callback results are returned in a list in the same order as @elems@.
<span class="lineno">  689 </span>zipMirAggregates ::
<span class="lineno">  690 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  691 </span>  sym -&gt;
<span class="lineno">  692 </span>  [AgElemShape] -&gt;
<span class="lineno">  693 </span>  MirAggregate sym -&gt;
<span class="lineno">  694 </span>  MirAggregate sym -&gt;
<span class="lineno">  695 </span>  (forall tp. Word -&gt; Word -&gt; TypeShape tp -&gt; RegValue sym tp -&gt; RegValue sym tp -&gt; m b) -&gt;
<span class="lineno">  696 </span>  m [b]
<span class="lineno">  697 </span><span class="decl"><span class="istickedoff">zipMirAggregates sym elems (MirAggregate _totalSize1 m1) (MirAggregate _totalSize2 m2) f = do</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="istickedoff">agCheckKeysEq <span class="nottickedoff">&quot;zipMirAggregates&quot;</span> elems m1</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="istickedoff">agCheckKeysEq <span class="nottickedoff">&quot;zipMirAggregates&quot;</span> elems m2</span>
<span class="lineno">  700 </span><span class="spaces">  </span><span class="istickedoff">-- We don't require the `totalSize`s of the two aggregates to match.</span>
<span class="lineno">  701 </span><span class="spaces">  </span><span class="istickedoff">-- `buildMirAggregate` sets the `totalSize` to the end of the last field, but</span>
<span class="lineno">  702 </span><span class="spaces">  </span><span class="istickedoff">-- other methods of building aggregates use the actual layout from rustc,</span>
<span class="lineno">  703 </span><span class="spaces">  </span><span class="istickedoff">-- which may have extra padding at the end.</span>
<span class="lineno">  704 </span><span class="spaces">  </span><span class="istickedoff">forM elems $ \(AgElemShape off sz shp) -&gt; do</span>
<span class="lineno">  705 </span><span class="spaces">    </span><span class="istickedoff">MirAggregateEntry _sz1 tpr1 rvPart1 &lt;-</span>
<span class="lineno">  706 </span><span class="spaces">      </span><span class="istickedoff">case IntMap.lookup (fromIntegral off) m1 of</span>
<span class="lineno">  707 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; return e</span>
<span class="lineno">  708 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;zipMirAggregates&quot;</span></span>
<span class="lineno">  709 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;missing MirAggregateEntry at offset &quot; ++ show off</span></span>
<span class="lineno">  710 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">++ &quot; (in first input)&quot;]</span></span>
<span class="lineno">  711 </span><span class="spaces">    </span><span class="istickedoff">MirAggregateEntry _sz2 tpr2 rvPart2 &lt;-</span>
<span class="lineno">  712 </span><span class="spaces">      </span><span class="istickedoff">case IntMap.lookup (fromIntegral off) m2 of</span>
<span class="lineno">  713 </span><span class="spaces">        </span><span class="istickedoff">Just e -&gt; return e</span>
<span class="lineno">  714 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;zipMirAggregates&quot;</span></span>
<span class="lineno">  715 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;missing MirAggregateEntry at offset &quot; ++ show off</span></span>
<span class="lineno">  716 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">++ &quot; (in second input)&quot;]</span></span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="istickedoff">Refl &lt;- case testEquality tpr1 (shapeType shp) of</span>
<span class="lineno">  718 </span><span class="spaces">      </span><span class="istickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  719 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;zipMirAggregates: ill-typed field value at offset &quot;</span></span>
<span class="lineno">  720 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr1</span></span>
<span class="lineno">  721 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ &quot; (in first aggregate)&quot;</span></span>
<span class="lineno">  722 </span><span class="spaces">    </span><span class="istickedoff">Refl &lt;- case testEquality tpr2 (shapeType shp) of</span>
<span class="lineno">  723 </span><span class="spaces">      </span><span class="istickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  724 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">fail $ &quot;zipMirAggregates: ill-typed field value at offset &quot;</span></span>
<span class="lineno">  725 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ show off ++ &quot;: expected &quot; ++ show (shapeType shp) ++ &quot;, but got &quot; ++ show tpr2</span></span>
<span class="lineno">  726 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">++ &quot; (in second aggregate)&quot;</span></span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="istickedoff">let rv1 = readMaybeType <span class="nottickedoff">sym</span> <span class="nottickedoff">&quot;elem&quot;</span> <span class="nottickedoff">tpr1</span> rvPart1</span>
<span class="lineno">  728 </span><span class="spaces">    </span><span class="istickedoff">let rv2 = readMaybeType <span class="nottickedoff">sym</span> <span class="nottickedoff">&quot;elem&quot;</span> <span class="nottickedoff">tpr2</span> rvPart2</span>
<span class="lineno">  729 </span><span class="spaces">    </span><span class="istickedoff">f <span class="nottickedoff">off</span> <span class="nottickedoff">sz</span> shp rv1 rv2</span></span>
<span class="lineno">  730 </span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>-- | Generate a list of `AgElemShape`s corresponding to positions within an
<span class="lineno">  733 </span>-- array.  The resulting list can then be used with `buildMirAggregate` and
<span class="lineno">  734 </span>-- similar functions to manipulate array aggregates.
<span class="lineno">  735 </span>arrayAgElemShapes ::
<span class="lineno">  736 </span>  -- | Size of array element type
<span class="lineno">  737 </span>  Word -&gt;
<span class="lineno">  738 </span>  -- | `TypeShape` of array element type
<span class="lineno">  739 </span>  TypeShape tp -&gt;
<span class="lineno">  740 </span>  -- | Array length
<span class="lineno">  741 </span>  Word -&gt;
<span class="lineno">  742 </span>  [AgElemShape]
<span class="lineno">  743 </span><span class="decl"><span class="istickedoff">arrayAgElemShapes elemSz elemShp len</span>
<span class="lineno">  744 </span><span class="spaces">  </span><span class="istickedoff">| len == 0 = []</span>
<span class="lineno">  745 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = [AgElemShape (i * elemSz) elemSz elemShp | i &lt;- [0 .. len - 1]]</span></span>
<span class="lineno">  746 </span>
<span class="lineno">  747 </span>agArrayCheckLengthsEq :: Monad m =&gt; Text -&gt; Word -&gt; [a] -&gt; m ()
<span class="lineno">  748 </span><span class="decl"><span class="istickedoff">agArrayCheckLengthsEq loc len xs =</span>
<span class="lineno">  749 </span><span class="spaces">  </span><span class="istickedoff">when (fromIntegral len /= length xs) $</span>
<span class="lineno">  750 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">panic loc</span></span>
<span class="lineno">  751 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">[Text.pack $ &quot;got len = &quot; ++ show len ++ &quot;, but &quot; ++ show (length xs) ++ &quot; xs&quot;]</span></span></span>
<span class="lineno">  752 </span>
<span class="lineno">  753 </span>buildMirAggregateArray ::
<span class="lineno">  754 </span>  (IsSymInterface sym, Monad m, MonadFail m) =&gt;
<span class="lineno">  755 </span>  sym -&gt;
<span class="lineno">  756 </span>  -- | Size of array element type
<span class="lineno">  757 </span>  Word -&gt;
<span class="lineno">  758 </span>  -- | `TypeShape` of array element type
<span class="lineno">  759 </span>  TypeShape tp -&gt;
<span class="lineno">  760 </span>  -- | Array length
<span class="lineno">  761 </span>  Word -&gt;
<span class="lineno">  762 </span>  [a] -&gt;
<span class="lineno">  763 </span>  (Word -&gt; a -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  764 </span>  m (MirAggregate sym)
<span class="lineno">  765 </span><span class="decl"><span class="istickedoff">buildMirAggregateArray sym elemSz elemShp len xs f = do</span>
<span class="lineno">  766 </span><span class="spaces">  </span><span class="istickedoff">agArrayCheckLengthsEq <span class="nottickedoff">&quot;buildMirAggregateArray&quot;</span> len xs</span>
<span class="lineno">  767 </span><span class="spaces">  </span><span class="istickedoff">let elems = arrayAgElemShapes elemSz elemShp len</span>
<span class="lineno">  768 </span><span class="spaces">  </span><span class="istickedoff">buildMirAggregate sym elems xs $</span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="istickedoff">\off _sz shp x -&gt; do</span>
<span class="lineno">  770 </span><span class="spaces">      </span><span class="istickedoff">Refl &lt;- case testEquality (shapeType shp) (shapeType elemShp) of</span>
<span class="lineno">  771 </span><span class="spaces">        </span><span class="istickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  772 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;buildMirAggregateArray&quot;</span></span>
<span class="lineno">  773 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;impossible: arrayAgElemShapes always uses the input TypeShape&quot;]</span></span>
<span class="lineno">  774 </span><span class="spaces">      </span><span class="istickedoff">f <span class="nottickedoff">off</span> x</span></span>
<span class="lineno">  775 </span>
<span class="lineno">  776 </span>generateMirAggregateArray ::
<span class="lineno">  777 </span>  (IsSymInterface sym, Monad m, MonadFail m) =&gt;
<span class="lineno">  778 </span>  sym -&gt;
<span class="lineno">  779 </span>  -- | Size of array element type
<span class="lineno">  780 </span>  Word -&gt;
<span class="lineno">  781 </span>  -- | `TypeShape` of array element type
<span class="lineno">  782 </span>  TypeShape tp -&gt;
<span class="lineno">  783 </span>  -- | Array length
<span class="lineno">  784 </span>  Word -&gt;
<span class="lineno">  785 </span>  (Word -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  786 </span>  m (MirAggregate sym)
<span class="lineno">  787 </span><span class="decl"><span class="istickedoff">generateMirAggregateArray sym elemSz elemShp len f = do</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="istickedoff">buildMirAggregateArray sym elemSz elemShp len (init [0 .. len]) $ \_off i -&gt; f i</span></span>
<span class="lineno">  789 </span>
<span class="lineno">  790 </span>traverseMirAggregateArray ::
<span class="lineno">  791 </span>  forall sym m tp.
<span class="lineno">  792 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  793 </span>  sym -&gt;
<span class="lineno">  794 </span>  -- | Size of array element type
<span class="lineno">  795 </span>  Word -&gt;
<span class="lineno">  796 </span>  -- | `TypeShape` of array element type
<span class="lineno">  797 </span>  TypeShape tp -&gt;
<span class="lineno">  798 </span>  -- | Array length
<span class="lineno">  799 </span>  Word -&gt;
<span class="lineno">  800 </span>  MirAggregate sym -&gt;
<span class="lineno">  801 </span>  (Word -&gt; RegValue sym tp -&gt; m (RegValue sym tp)) -&gt;
<span class="lineno">  802 </span>  m (MirAggregate sym)
<span class="lineno">  803 </span><span class="decl"><span class="nottickedoff">traverseMirAggregateArray sym elemSz elemShp len ag f = do</span>
<span class="lineno">  804 </span><span class="spaces">  </span><span class="nottickedoff">let elems = arrayAgElemShapes elemSz elemShp len</span>
<span class="lineno">  805 </span><span class="spaces">  </span><span class="nottickedoff">traverseMirAggregate sym elems ag $</span>
<span class="lineno">  806 </span><span class="spaces">    </span><span class="nottickedoff">\off _sz shp rv -&gt; do</span>
<span class="lineno">  807 </span><span class="spaces">      </span><span class="nottickedoff">Refl &lt;- case testEquality (shapeType shp) (shapeType elemShp) of</span>
<span class="lineno">  808 </span><span class="spaces">        </span><span class="nottickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  809 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt; panic &quot;traverseMirAggregateArray&quot;</span>
<span class="lineno">  810 </span><span class="spaces">          </span><span class="nottickedoff">[&quot;impossible: arrayAgElemShapes always uses the input TypeShape&quot;]</span>
<span class="lineno">  811 </span><span class="spaces">      </span><span class="nottickedoff">f off rv</span></span>
<span class="lineno">  812 </span>
<span class="lineno">  813 </span>accessMirAggregateArray ::
<span class="lineno">  814 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  815 </span>  sym -&gt;
<span class="lineno">  816 </span>  -- | Size of array element type
<span class="lineno">  817 </span>  Word -&gt;
<span class="lineno">  818 </span>  -- | `TypeShape` of array element type
<span class="lineno">  819 </span>  TypeShape tp -&gt;
<span class="lineno">  820 </span>  -- | Array length
<span class="lineno">  821 </span>  Word -&gt;
<span class="lineno">  822 </span>  MirAggregate sym -&gt;
<span class="lineno">  823 </span>  (Word -&gt; RegValue sym tp -&gt; m b) -&gt;
<span class="lineno">  824 </span>  m [b]
<span class="lineno">  825 </span><span class="decl"><span class="istickedoff">accessMirAggregateArray sym elemSz elemShp len ag f = do</span>
<span class="lineno">  826 </span><span class="spaces">  </span><span class="istickedoff">let xs = replicate (fromIntegral len) ()</span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff">accessMirAggregateArray' <span class="nottickedoff">sym</span> elemSz elemShp len xs ag $</span>
<span class="lineno">  828 </span><span class="spaces">    </span><span class="istickedoff">\off val () -&gt; f <span class="nottickedoff">off</span> val</span></span>
<span class="lineno">  829 </span>
<span class="lineno">  830 </span>accessMirAggregateArray' ::
<span class="lineno">  831 </span>  (IsSymInterface sym, Monad m, MonadFail m, MonadIO m) =&gt;
<span class="lineno">  832 </span>  sym -&gt;
<span class="lineno">  833 </span>  -- | Size of array element type
<span class="lineno">  834 </span>  Word -&gt;
<span class="lineno">  835 </span>  -- | `TypeShape` of array element type
<span class="lineno">  836 </span>  TypeShape tp -&gt;
<span class="lineno">  837 </span>  -- | Array length
<span class="lineno">  838 </span>  Word -&gt;
<span class="lineno">  839 </span>  [a] -&gt;
<span class="lineno">  840 </span>  MirAggregate sym -&gt;
<span class="lineno">  841 </span>  (Word -&gt; RegValue sym tp -&gt; a -&gt; m b) -&gt;
<span class="lineno">  842 </span>  m [b]
<span class="lineno">  843 </span><span class="decl"><span class="istickedoff">accessMirAggregateArray' sym elemSz elemShp len xs ag f = do</span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="istickedoff">agArrayCheckLengthsEq <span class="nottickedoff">&quot;accessMirAggregateArray'&quot;</span> len xs</span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff">let elems = arrayAgElemShapes elemSz elemShp (fromIntegral $ length xs)</span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff">accessMirAggregate' <span class="nottickedoff">sym</span> elems xs ag $</span>
<span class="lineno">  847 </span><span class="spaces">    </span><span class="istickedoff">\off _sz shp rv x -&gt; do</span>
<span class="lineno">  848 </span><span class="spaces">      </span><span class="istickedoff">Refl &lt;- case testEquality (shapeType shp) (shapeType elemShp) of</span>
<span class="lineno">  849 </span><span class="spaces">        </span><span class="istickedoff">Just pf -&gt; return pf</span>
<span class="lineno">  850 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">panic &quot;accessMirAggregateArray'&quot;</span></span>
<span class="lineno">  851 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">[&quot;impossible: arrayAgElemShapes always uses the input TypeShape&quot;]</span></span>
<span class="lineno">  852 </span><span class="spaces">      </span><span class="istickedoff">f <span class="nottickedoff">off</span> rv x</span></span>
<span class="lineno">  853 </span>
<span class="lineno">  854 </span>
<span class="lineno">  855 </span>-- Misc helpers
<span class="lineno">  856 </span>
<span class="lineno">  857 </span>-- | Read the value out of a 'MaybeType' expression that is assumed to be
<span class="lineno">  858 </span>-- assigned to a value. If this assumption does not hold (i.e., if the value is
<span class="lineno">  859 </span>-- unassigned), then this function will raise an error.
<span class="lineno">  860 </span>readMaybeType ::
<span class="lineno">  861 </span>  IsSymInterface sym =&gt;
<span class="lineno">  862 </span>  sym -&gt;
<span class="lineno">  863 </span>  String -&gt;
<span class="lineno">  864 </span>  TypeRepr tp -&gt;
<span class="lineno">  865 </span>  RegValue sym (MaybeType tp) -&gt;
<span class="lineno">  866 </span>  RegValue sym tp
<span class="lineno">  867 </span><span class="decl"><span class="istickedoff">readMaybeType sym desc tpr rv =</span>
<span class="lineno">  868 </span><span class="spaces">  </span><span class="istickedoff">case readPartExprMaybe <span class="nottickedoff">sym</span> rv of</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="istickedoff">Just x -&gt; x</span>
<span class="lineno">  870 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">error $ &quot;readMaybeType: accessed possibly-uninitialized &quot; ++ desc ++</span></span>
<span class="lineno">  871 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">&quot; of type &quot; ++ show tpr</span></span></span>
<span class="lineno">  872 </span>
<span class="lineno">  873 </span>readPartExprMaybe ::
<span class="lineno">  874 </span>  IsSymInterface sym =&gt;
<span class="lineno">  875 </span>  sym -&gt;
<span class="lineno">  876 </span>  W4.PartExpr (W4.Pred sym) a -&gt;
<span class="lineno">  877 </span>  Maybe a
<span class="lineno">  878 </span><span class="decl"><span class="istickedoff">readPartExprMaybe _sym W4.Unassigned = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  879 </span><span class="spaces"></span><span class="istickedoff">readPartExprMaybe _sym (W4.PE p v)</span>
<span class="lineno">  880 </span><span class="spaces">  </span><span class="istickedoff">| Just True &lt;- W4.asConstantPred p = Just v</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Nothing</span></span></span>
<span class="lineno">  882 </span>
<span class="lineno">  883 </span>
<span class="lineno">  884 </span>$(pure [])
<span class="lineno">  885 </span>
<span class="lineno">  886 </span>-- | Check if two 'M.Ty's are compatible in SAW. This is a slightly coarser
<span class="lineno">  887 </span>-- notion of equality to reflect the fact that MIR's type system is richer than
<span class="lineno">  888 </span>-- Cryptol's type system, and some types which would be distinct in MIR are in
<span class="lineno">  889 </span>-- fact equal when converted to the equivalent Cryptol types. In particular:
<span class="lineno">  890 </span>--
<span class="lineno">  891 </span>-- 1. A @u&lt;N&gt;@ type is always compatible with an @i&lt;N&gt;@ type. For instance, @u8@
<span class="lineno">  892 </span>--    is compatible with @i8@, and @u16@ is compatible with @i16@. Note that the
<span class="lineno">  893 </span>--    bit sizes of both types must be the same. For instance, @u8@ is /not/
<span class="lineno">  894 </span>--    compatible with @i16@.
<span class="lineno">  895 </span>--
<span class="lineno">  896 </span>-- 2. The @usize@/@isize@ types are always compatible with @u&lt;N&gt;@/@i&lt;N&gt;@, where
<span class="lineno">  897 </span>--    @N@ is the number of bits corresponding to the 'SizeBits' type in
<span class="lineno">  898 </span>--    &quot;M.Intrinsics&quot;. (This is a bit unsavory, as the actual size of
<span class="lineno">  899 </span>--    @usize@/@isize@ is platform-dependent, but this is the current approach.)
<span class="lineno">  900 </span>--
<span class="lineno">  901 </span>-- 3. Compatibility applies recursively. For instance, @[ty_1; N]@ is compatible
<span class="lineno">  902 </span>--    with @[ty_2; N]@ iff @ty_1@ and @ty_2@ are compatibile. Similarly, a tuple
<span class="lineno">  903 </span>--    typle @(ty_1_a, ..., ty_n_a)@ is compatible with @(ty_1_b, ..., ty_n_b)@
<span class="lineno">  904 </span>--    iff @ty_1_a@ is compatible with @ty_1_b@, ..., and @ty_n_a@ is compatible
<span class="lineno">  905 </span>--    with @ty_n_b@.
<span class="lineno">  906 </span>--
<span class="lineno">  907 </span>-- See also @checkRegisterCompatibility@ in &quot;SAWCentral.Crucible.LLVM.Builtins&quot;
<span class="lineno">  908 </span>-- and @registerCompatible@ in &quot;SAWCentral.Crucible.JVM.Builtins&quot;, which fill a
<span class="lineno">  909 </span>-- similar niche in the LLVM and JVM backends, respectively.
<span class="lineno">  910 </span>checkCompatibleTys :: M.Ty -&gt; M.Ty -&gt; Bool
<span class="lineno">  911 </span><span class="decl"><span class="istickedoff">checkCompatibleTys ty1 ty2 = tyView ty1 == tyView ty2</span></span>
<span class="lineno">  912 </span>
<span class="lineno">  913 </span>-- | Like 'M.Ty', but where:
<span class="lineno">  914 </span>--
<span class="lineno">  915 </span>-- * The 'TyInt' and 'TyUint' constructors have been collapsed into a single
<span class="lineno">  916 </span>--   'TyViewInt' constructor.
<span class="lineno">  917 </span>--
<span class="lineno">  918 </span>-- * 'TyViewInt' uses 'BaseSizeView' instead of 'M.BaseSize'.
<span class="lineno">  919 </span>--
<span class="lineno">  920 </span>-- * Recursive occurrences of 'M.Ty' use 'TyView' instead. This also applies
<span class="lineno">  921 </span>--   to fields of type 'SubstsView' and 'FnSigView', which also replace 'M.Ty'
<span class="lineno">  922 </span>--   with 'TyView' in their definitions.
<span class="lineno">  923 </span>--
<span class="lineno">  924 </span>-- This provides a coarser notion of equality than what the 'Eq' instance for
<span class="lineno">  925 </span>-- 'M.Ty' provides, which distinguishes the two sorts of integer types.
<span class="lineno">  926 </span>--
<span class="lineno">  927 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno">  928 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno">  929 </span>-- this is needed.
<span class="lineno">  930 </span>data TyView
<span class="lineno">  931 </span>  = TyViewBool
<span class="lineno">  932 </span>  | TyViewChar
<span class="lineno">  933 </span>    -- | The sole integer type. Both 'TyInt' and 'TyUint' are mapped to
<span class="lineno">  934 </span>    -- 'TyViewInt', and 'BaseSizeView' is used instead of 'M.BaseSize'.
<span class="lineno">  935 </span>  | TyViewInt !BaseSizeView
<span class="lineno">  936 </span>  | TyViewTuple ![TyView]
<span class="lineno">  937 </span>  | TyViewSlice !TyView
<span class="lineno">  938 </span>  | TyViewArray !TyView !Int
<span class="lineno">  939 </span>  | TyViewRef !TyView !M.Mutability
<span class="lineno">  940 </span>  | TyViewAdt !M.DefId !M.DefId !SubstsView
<span class="lineno">  941 </span>  | TyViewFnDef !M.DefId
<span class="lineno">  942 </span>  | TyViewClosure [TyView]
<span class="lineno">  943 </span>  | TyViewStr
<span class="lineno">  944 </span>  | TyViewFnPtr !FnSigView
<span class="lineno">  945 </span>  | TyViewDynamic !M.TraitName
<span class="lineno">  946 </span>  | TyViewRawPtr !TyView !M.Mutability
<span class="lineno">  947 </span>  | TyViewFloat !M.FloatKind
<span class="lineno">  948 </span>  | TyViewDowncast !TyView !Integer
<span class="lineno">  949 </span>  | TyViewNever
<span class="lineno">  950 </span>  | TyViewForeign
<span class="lineno">  951 </span>  | TyViewLifetime
<span class="lineno">  952 </span>  | TyViewConst !M.ConstVal
<span class="lineno">  953 </span>  | TyViewCoroutine !CoroutineArgsView
<span class="lineno">  954 </span>  | TyViewCoroutineClosure [TyView]
<span class="lineno">  955 </span>  | TyViewErased
<span class="lineno">  956 </span>  | TyViewInterned M.TyName
<span class="lineno">  957 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  958 </span>
<span class="lineno">  959 </span>-- | Like 'M.BaseSize', but without a special case for @usize@/@isize@.
<span class="lineno">  960 </span>-- Instead, these are mapped to their actual size, which is determined by the
<span class="lineno">  961 </span>-- number of bits in the 'SizeBits' type in &quot;M.Intrinsics&quot;. (This is a bit
<span class="lineno">  962 </span>-- unsavory, as the actual size of @usize@/@isize@ is platform-dependent, but
<span class="lineno">  963 </span>-- this is the current approach.)
<span class="lineno">  964 </span>data BaseSizeView
<span class="lineno">  965 </span>  = B8View
<span class="lineno">  966 </span>  | B16View
<span class="lineno">  967 </span>  | B32View
<span class="lineno">  968 </span>  | B64View
<span class="lineno">  969 </span>  | B128View
<span class="lineno">  970 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  971 </span>
<span class="lineno">  972 </span>-- | Like 'M.Substs', but using 'TyView's instead of 'M.Ty'.
<span class="lineno">  973 </span>--
<span class="lineno">  974 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno">  975 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno">  976 </span>-- this is needed.
<span class="lineno">  977 </span>newtype SubstsView = SubstsView [TyView]
<span class="lineno">  978 </span>  deriving <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  979 </span>
<span class="lineno">  980 </span>-- | Like 'M.FnSig', but using 'TyView's instead of 'M.Ty'.
<span class="lineno">  981 </span>--
<span class="lineno">  982 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno">  983 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno">  984 </span>-- this is needed.
<span class="lineno">  985 </span>data FnSigView = FnSigView {
<span class="lineno">  986 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvarg_tys</span></span></span>    :: ![TyView]
<span class="lineno">  987 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvreturn_ty</span></span></span>  :: !TyView
<span class="lineno">  988 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_fsvabi</span></span></span>        :: M.Abi
<span class="lineno">  989 </span>  }
<span class="lineno">  990 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  991 </span>
<span class="lineno">  992 </span>-- | Like 'M.CoroutineArgs', but using 'TyView's instead of 'M.Ty'.
<span class="lineno">  993 </span>--
<span class="lineno">  994 </span>-- This is an internal data type that is used to power the 'checkCompatibleTys'
<span class="lineno">  995 </span>-- function. Refer to the Haddocks for that function for more information on why
<span class="lineno">  996 </span>-- this is needed.
<span class="lineno">  997 </span>data CoroutineArgsView = CoroutineArgsView
<span class="lineno">  998 </span>  { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_cavDiscrTy</span></span></span> :: !TyView
<span class="lineno">  999 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_cavUpvarTys</span></span></span> :: ![TyView]
<span class="lineno"> 1000 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_cavSavedTys</span></span></span> :: ![TyView]
<span class="lineno"> 1001 </span>  , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_cavFieldMap</span></span></span> :: !(Map (Int, Int) Int)
<span class="lineno"> 1002 </span>  } deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno"> 1003 </span>
<span class="lineno"> 1004 </span>-- | Convert a 'M.Ty' value to a 'TyView' value.
<span class="lineno"> 1005 </span>tyView :: M.Ty -&gt; TyView
<span class="lineno"> 1006 </span>-- The two most important cases. Both sorts of integers are mapped to TyViewInt.
<span class="lineno"> 1007 </span><span class="decl"><span class="istickedoff">tyView (M.TyInt  bs) = TyViewInt (baseSizeView bs)</span>
<span class="lineno"> 1008 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyUint bs) = TyViewInt (baseSizeView bs)</span>
<span class="lineno"> 1009 </span><span class="spaces"></span><span class="istickedoff">-- All other cases are straightforward.</span>
<span class="lineno"> 1010 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyBool = TyViewBool</span>
<span class="lineno"> 1011 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyChar = <span class="nottickedoff">TyViewChar</span></span>
<span class="lineno"> 1012 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyTuple tys) = TyViewTuple (map tyView tys)</span>
<span class="lineno"> 1013 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TySlice ty) = TyViewSlice (tyView ty)</span>
<span class="lineno"> 1014 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyArray ty n) = TyViewArray (tyView ty) n</span>
<span class="lineno"> 1015 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyRef ty mut) = TyViewRef (tyView ty) mut</span>
<span class="lineno"> 1016 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyAdt monoDid origDid substs) =</span>
<span class="lineno"> 1017 </span><span class="spaces">  </span><span class="istickedoff">TyViewAdt monoDid origDid (substsView substs)</span>
<span class="lineno"> 1018 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyFnDef did) = <span class="nottickedoff">TyViewFnDef did</span></span>
<span class="lineno"> 1019 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyClosure tys) = <span class="nottickedoff">TyViewClosure (map tyView tys)</span></span>
<span class="lineno"> 1020 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyStr = TyViewStr</span>
<span class="lineno"> 1021 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyFnPtr sig) = <span class="nottickedoff">TyViewFnPtr (fnSigView sig)</span></span>
<span class="lineno"> 1022 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyDynamic trait) = <span class="nottickedoff">TyViewDynamic trait</span></span>
<span class="lineno"> 1023 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyRawPtr ty mut) = TyViewRawPtr (tyView ty) mut</span>
<span class="lineno"> 1024 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyFloat fk) = <span class="nottickedoff">TyViewFloat fk</span></span>
<span class="lineno"> 1025 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyDowncast ty n) = <span class="nottickedoff">TyViewDowncast (tyView ty) n</span></span>
<span class="lineno"> 1026 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyNever = <span class="nottickedoff">TyViewNever</span></span>
<span class="lineno"> 1027 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyForeign = <span class="nottickedoff">TyViewForeign</span></span>
<span class="lineno"> 1028 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyLifetime = TyViewLifetime</span>
<span class="lineno"> 1029 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyConst c) = TyViewConst c</span>
<span class="lineno"> 1030 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyCoroutine ca) = <span class="nottickedoff">TyViewCoroutine (coroutineArgsView ca)</span></span>
<span class="lineno"> 1031 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyCoroutineClosure tys) = <span class="nottickedoff">TyViewCoroutineClosure (map tyView tys)</span></span>
<span class="lineno"> 1032 </span><span class="spaces"></span><span class="istickedoff">tyView M.TyErased = <span class="nottickedoff">TyViewErased</span></span>
<span class="lineno"> 1033 </span><span class="spaces"></span><span class="istickedoff">tyView (M.TyInterned nm) = <span class="nottickedoff">TyViewInterned nm</span></span></span>
<span class="lineno"> 1034 </span>
<span class="lineno"> 1035 </span>-- | Convert a 'M.BaseSize' value to a 'BaseSizeView' value.
<span class="lineno"> 1036 </span>baseSizeView :: M.BaseSize -&gt; BaseSizeView
<span class="lineno"> 1037 </span><span class="decl"><span class="istickedoff">baseSizeView M.B8    = B8View</span>
<span class="lineno"> 1038 </span><span class="spaces"></span><span class="istickedoff">baseSizeView M.B16   = B16View</span>
<span class="lineno"> 1039 </span><span class="spaces"></span><span class="istickedoff">baseSizeView M.B32   = B32View</span>
<span class="lineno"> 1040 </span><span class="spaces"></span><span class="istickedoff">baseSizeView M.B64   = B64View</span>
<span class="lineno"> 1041 </span><span class="spaces"></span><span class="istickedoff">baseSizeView M.B128  = B128View</span>
<span class="lineno"> 1042 </span><span class="spaces"></span><span class="istickedoff">baseSizeView M.USize =</span>
<span class="lineno"> 1043 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup (W4.natValue sizeBitsRepr) bitSizesMap of</span>
<span class="lineno"> 1044 </span><span class="spaces">    </span><span class="istickedoff">Just bsv -&gt; bsv</span>
<span class="lineno"> 1045 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno"> 1046 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">error $ &quot;M.Intrinsics.BaseSize bit size not supported: &quot; ++ show sizeBitsRepr</span></span>
<span class="lineno"> 1047 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno"> 1048 </span><span class="spaces">    </span><span class="istickedoff">sizeBitsRepr = W4.knownNat @SizeBits</span>
<span class="lineno"> 1049 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno"> 1050 </span><span class="spaces">    </span><span class="istickedoff">bitSizesMap :: Map Natural BaseSizeView</span>
<span class="lineno"> 1051 </span><span class="spaces">    </span><span class="istickedoff">bitSizesMap = Map.fromList</span>
<span class="lineno"> 1052 </span><span class="spaces">      </span><span class="istickedoff">[ (W4.natValue (W4.knownNat @8),   <span class="nottickedoff">B8View</span>)</span>
<span class="lineno"> 1053 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @16),  <span class="nottickedoff">B16View</span>)</span>
<span class="lineno"> 1054 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @32),  <span class="nottickedoff">B32View</span>)</span>
<span class="lineno"> 1055 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @64),  B64View)</span>
<span class="lineno"> 1056 </span><span class="spaces">      </span><span class="istickedoff">, (W4.natValue (W4.knownNat @128), <span class="nottickedoff">B128View</span>)</span>
<span class="lineno"> 1057 </span><span class="spaces">      </span><span class="istickedoff">]</span></span>
<span class="lineno"> 1058 </span>
<span class="lineno"> 1059 </span>-- | Convert a 'M.Substs' value to a 'SubstsView' value.
<span class="lineno"> 1060 </span>substsView :: M.Substs -&gt; SubstsView
<span class="lineno"> 1061 </span><span class="decl"><span class="istickedoff">substsView (M.Substs tys) = SubstsView (map tyView tys)</span></span>
<span class="lineno"> 1062 </span>
<span class="lineno"> 1063 </span>-- | Convert a 'M.FnSig' value to a 'FnSigView' value.
<span class="lineno"> 1064 </span>fnSigView :: M.FnSig -&gt; FnSigView
<span class="lineno"> 1065 </span><span class="decl"><span class="nottickedoff">fnSigView (M.FnSig argTys retTy abi) =</span>
<span class="lineno"> 1066 </span><span class="spaces">  </span><span class="nottickedoff">FnSigView (map tyView argTys) (tyView retTy) abi</span></span>
<span class="lineno"> 1067 </span>
<span class="lineno"> 1068 </span>-- | Convert a 'M.CoroutineArgs' value to a 'CoroutineArgsView' value.
<span class="lineno"> 1069 </span>coroutineArgsView :: M.CoroutineArgs -&gt; CoroutineArgsView
<span class="lineno"> 1070 </span><span class="decl"><span class="nottickedoff">coroutineArgsView (M.CoroutineArgs discrTy upvarTys savedTys fieldMap) =</span>
<span class="lineno"> 1071 </span><span class="spaces">  </span><span class="nottickedoff">CoroutineArgsView</span>
<span class="lineno"> 1072 </span><span class="spaces">    </span><span class="nottickedoff">(tyView discrTy)</span>
<span class="lineno"> 1073 </span><span class="spaces">    </span><span class="nottickedoff">(map tyView upvarTys)</span>
<span class="lineno"> 1074 </span><span class="spaces">    </span><span class="nottickedoff">(map tyView savedTys)</span>
<span class="lineno"> 1075 </span><span class="spaces">    </span><span class="nottickedoff">fieldMap</span></span>
<span class="lineno"> 1076 </span>
<span class="lineno"> 1077 </span>instance TestEquality TypeShape where
<span class="lineno"> 1078 </span>  <span class="decl"><span class="istickedoff">testEquality =</span>
<span class="lineno"> 1079 </span><span class="spaces">    </span><span class="istickedoff">$<span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">(structuralTypeEquality</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1080 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[t|TypeShape|]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1081 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[ (TypeApp (ConType [t|TypeShape|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1082 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (ConType [t|BaseTypeRepr|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1083 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (TypeApp (ConType [t|Assignment|]) AnyType) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1084 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (ConType [t|TypeRepr|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1085 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (TypeApp (ConType [t|CtxRepr|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1086 </span><span class="spaces">          </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">-- See #1976 for why we use checkCompatibleTys to compare MIR types</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1087 </span><span class="spaces">          </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">-- instead of (==).</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1088 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, (ConType [t|M.Ty|], [| \x y -&gt; if checkCompatibleTys x y then Just Refl else Nothing |])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1089 </span><span class="spaces">        </span><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="tickonlytrue"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<span class="lineno"> 1090 </span>
<span class="lineno"> 1091 </span>instance TestEquality VariantShape where
<span class="lineno"> 1092 </span>  <span class="decl"><span class="istickedoff">testEquality =</span>
<span class="lineno"> 1093 </span><span class="spaces">    </span><span class="istickedoff">$<span class="nottickedoff"><span class="istickedoff">(structuralTypeEquality</span></span></span>
<span class="lineno"> 1094 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[t|VariantShape|]</span></span></span>
<span class="lineno"> 1095 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[ (TypeApp (TypeApp (ConType [t|Assignment|]) AnyType) AnyType, [|testEquality|])</span></span></span>
<span class="lineno"> 1096 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">])</span></span></span></span>
<span class="lineno"> 1097 </span>
<span class="lineno"> 1098 </span>instance TestEquality FieldShape where
<span class="lineno"> 1099 </span>  <span class="decl"><span class="istickedoff">testEquality =</span>
<span class="lineno"> 1100 </span><span class="spaces">    </span><span class="istickedoff">$<span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">(structuralTypeEquality</span></span></span></span></span></span></span>
<span class="lineno"> 1101 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[t|FieldShape|]</span></span></span></span></span></span></span>
<span class="lineno"> 1102 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">[ (TypeApp (ConType [t|TypeShape|]) AnyType, [|testEquality|])</span></span></span></span></span></span></span>
<span class="lineno"> 1103 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">])</span></span></span></span></span></span></span></span>
<span class="lineno"> 1104 </span>
<span class="lineno"> 1105 </span>instance <span class="decl"><span class="nottickedoff">Eq AgElemShape</span></span> where
<span class="lineno"> 1106 </span>    <span class="decl"><span class="istickedoff">AgElemShape off1 sz1 shp1 == AgElemShape off2 sz2 shp2 =</span>
<span class="lineno"> 1107 </span><span class="spaces">        </span><span class="istickedoff">off1 == off2</span>
<span class="lineno"> 1108 </span><span class="spaces">            </span><span class="istickedoff">&amp;&amp; sz1 == sz2</span>
<span class="lineno"> 1109 </span><span class="spaces">            </span><span class="istickedoff">&amp;&amp; isJust (testEquality shp1 shp2)</span></span>

</pre>
</body>
</html>
