<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE CPP #-}
<span class="lineno">    2 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    3 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    5 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    6 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">    7 </span>{-# LANGUAGE KindSignatures #-}
<span class="lineno">    8 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">    9 </span>{-# LANGUAGE PolyKinds #-}
<span class="lineno">   10 </span>{-# LANGUAGE TypeOperators #-}
<span class="lineno">   11 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">   12 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   13 </span>{-# LANGUAGE TypeApplications #-}
<span class="lineno">   14 </span>{-# LANGUAGE FunctionalDependencies #-}
<span class="lineno">   15 </span>{-# LANGUAGE ViewPatterns #-}
<span class="lineno">   16 </span>{-# LANGUAGE PartialTypeSignatures #-}
<span class="lineno">   17 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   18 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   19 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">   20 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   21 </span>{-# LANGUAGE TemplateHaskell #-}
<span class="lineno">   22 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   23 </span>{-# LANGUAGE PatternGuards #-}
<span class="lineno">   24 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">   25 </span>{-# LANGUAGE BangPatterns #-}
<span class="lineno">   26 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">   27 </span>{-# LANGUAGE ImplicitParams #-}
<span class="lineno">   28 </span>{-# LANGUAGE QuantifiedConstraints #-}
<span class="lineno">   29 </span>{-# OPTIONS_GHC -Wno-orphans #-}
<span class="lineno">   30 </span>module Heapster.TypedCrucible where
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>import Data.Maybe
<span class="lineno">   33 </span>import qualified Data.Text as Text
<span class="lineno">   34 </span>import Data.List (find, findIndex, foldl1', nub)
<span class="lineno">   35 </span>import Data.Functor.Constant
<span class="lineno">   36 </span>import Data.Functor.Product
<span class="lineno">   37 </span>import Data.Type.Equality
<span class="lineno">   38 </span>import Data.Kind
<span class="lineno">   39 </span>import Data.Reflection
<span class="lineno">   40 </span>import qualified Data.BitVector.Sized as BV
<span class="lineno">   41 </span>import GHC.TypeLits (KnownNat)
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>import What4.ProgramLoc
<span class="lineno">   44 </span>import What4.FunctionName
<span class="lineno">   45 </span>import What4.Interface (StringLiteral(..))
<span class="lineno">   46 </span>
<span class="lineno">   47 </span>import Control.Lens hiding ((:&gt;), Index, ix)
<span class="lineno">   48 </span>import Control.Monad ((&gt;=&gt;), foldM, forM, forM_)
<span class="lineno">   49 </span>import Control.Monad.Reader (MonadReader(..), ReaderT(..))
<span class="lineno">   50 </span>import Control.Monad.State.Strict (MonadState(..), State, evalState, execState,
<span class="lineno">   51 </span>                                   gets, modify, runState)
<span class="lineno">   52 </span>import Control.Monad.Trans.Class (MonadTrans(..))
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>import Prettyprinter as PP
<span class="lineno">   55 </span>
<span class="lineno">   56 </span>import qualified Data.Type.RList as RL
<span class="lineno">   57 </span>import Data.Binding.Hobbits
<span class="lineno">   58 </span>import Data.Binding.Hobbits.NameSet (NameSet, SomeName(..), SomeRAssign(..),
<span class="lineno">   59 </span>                                     namesListToNames, namesToNamesList,
<span class="lineno">   60 </span>                                     nameSetIsSubsetOf)
<span class="lineno">   61 </span>import qualified Data.Binding.Hobbits.NameSet as NameSet
<span class="lineno">   62 </span>import Data.Binding.Hobbits.NameMap (NameMap)
<span class="lineno">   63 </span>import qualified Data.Binding.Hobbits.NameMap as NameMap
<span class="lineno">   64 </span>
<span class="lineno">   65 </span>import Data.Parameterized.Context hiding ((:&gt;), empty, take, view, last, drop)
<span class="lineno">   66 </span>import qualified Data.Parameterized.Context as Ctx
<span class="lineno">   67 </span>import Data.Parameterized.TraversableF
<span class="lineno">   68 </span>import Data.Parameterized.TraversableFC
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>import Lang.Crucible.FunctionHandle
<span class="lineno">   71 </span>import Lang.Crucible.Types
<span class="lineno">   72 </span>import Lang.Crucible.LLVM.Bytes
<span class="lineno">   73 </span>import Lang.Crucible.LLVM.Extension
<span class="lineno">   74 </span>import Lang.Crucible.LLVM.MemModel
<span class="lineno">   75 </span>import Lang.Crucible.CFG.Expr
<span class="lineno">   76 </span>import Lang.Crucible.CFG.Core
<span class="lineno">   77 </span>import Lang.Crucible.Analysis.Fixpoint.Components
<span class="lineno">   78 </span>import Lang.Crucible.LLVM.DataLayout
<span class="lineno">   79 </span>import Lang.Crucible.LLVM.Errors.UndefinedBehavior as UB
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>import Heapster.CruUtil
<span class="lineno">   82 </span>import Heapster.GenMonad
<span class="lineno">   83 </span>import Heapster.Implication
<span class="lineno">   84 </span>import Heapster.NamePropagation
<span class="lineno">   85 </span>import Heapster.Permissions
<span class="lineno">   86 </span>import Heapster.Widening
<span class="lineno">   87 </span>import Heapster.NamedMb
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>import GHC.Stack (HasCallStack)
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>
<span class="lineno">   92 </span>----------------------------------------------------------------------
<span class="lineno">   93 </span>-- * Handling Crucible Extensions
<span class="lineno">   94 </span>----------------------------------------------------------------------
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>-- | A Crucible extension that satisfies 'NuMatching'
<span class="lineno">   97 </span>type NuMatchingExtC ext exprExt =
<span class="lineno">   98 </span>  (
<span class="lineno">   99 </span>#if __GLASGOW_HASKELL__ &gt;= 902
<span class="lineno">  100 </span>    NuMatchingAny1 (ExprExtension ext RegWithVal)
<span class="lineno">  101 </span>#else
<span class="lineno">  102 </span>    -- See Note [QuantifiedConstraints + TypeFamilies trick] in
<span class="lineno">  103 </span>    -- Heapster.CruUtil
<span class="lineno">  104 </span>    exprExt ~ ExprExtension ext RegWithVal
<span class="lineno">  105 </span>  , NuMatchingAny1 exprExt
<span class="lineno">  106 </span>#endif
<span class="lineno">  107 </span>  -- (NuMatchingAny1 (ExprExtension ext TypedReg)
<span class="lineno">  108 </span>   -- , NuMatchingAny1 (StmtExtension ext TypedReg))
<span class="lineno">  109 </span>  )
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>-- | GADT telling us that @ext@ is a syntax extension we can handle
<span class="lineno">  112 </span>data ExtRepr ext where
<span class="lineno">  113 </span>  ExtRepr_Unit :: ExtRepr ()
<span class="lineno">  114 </span>  ExtRepr_LLVM :: ExtRepr LLVM
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>instance KnownRepr ExtRepr () where
<span class="lineno">  117 </span>  <span class="decl"><span class="nottickedoff">knownRepr = ExtRepr_Unit</span></span>
<span class="lineno">  118 </span>
<span class="lineno">  119 </span>instance KnownRepr ExtRepr LLVM where
<span class="lineno">  120 </span>  <span class="decl"><span class="nottickedoff">knownRepr = ExtRepr_LLVM</span></span>
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>-- | The constraints for a Crucible syntax extension that supports permission
<span class="lineno">  123 </span>-- checking
<span class="lineno">  124 </span>type PermCheckExtC ext exprExt =
<span class="lineno">  125 </span>  (NuMatchingExtC ext exprExt, IsSyntaxExtension ext, KnownRepr ExtRepr ext)
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>-- | Extension-specific state
<span class="lineno">  128 </span>data PermCheckExtState ext where
<span class="lineno">  129 </span>  -- | No extension-specific state for the empty extension
<span class="lineno">  130 </span>  PermCheckExtState_Unit :: PermCheckExtState ()
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>  -- | The extension-specific state for LLVM is the current frame pointer, if it
<span class="lineno">  133 </span>  -- exists
<span class="lineno">  134 </span>  PermCheckExtState_LLVM ::
<span class="lineno">  135 </span>    Maybe SomeFrameReg -&gt;
<span class="lineno">  136 </span>    PermCheckExtState LLVM
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>-- | Create a default empty extension-specific state object
<span class="lineno">  139 </span>emptyPermCheckExtState :: ExtRepr ext -&gt; PermCheckExtState ext
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">emptyPermCheckExtState ExtRepr_Unit = PermCheckExtState_Unit</span>
<span class="lineno">  141 </span><span class="spaces"></span><span class="nottickedoff">emptyPermCheckExtState ExtRepr_LLVM = PermCheckExtState_LLVM Nothing</span></span>
<span class="lineno">  142 </span>
<span class="lineno">  143 </span>-- | Get all the names contained in a 'PermCheckExtState'
<span class="lineno">  144 </span>permCheckExtStateNames :: PermCheckExtState ext -&gt; Some (RAssign ExprVar)
<span class="lineno">  145 </span><span class="decl"><span class="nottickedoff">permCheckExtStateNames (PermCheckExtState_LLVM (Just (SomeFrameReg _ treg))) =</span>
<span class="lineno">  146 </span><span class="spaces">  </span><span class="nottickedoff">Some (MNil :&gt;: typedRegVar treg)</span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="nottickedoff">permCheckExtStateNames (PermCheckExtState_LLVM Nothing) = Some MNil</span>
<span class="lineno">  148 </span><span class="spaces"></span><span class="nottickedoff">permCheckExtStateNames (PermCheckExtState_Unit) = Some MNil</span></span>
<span class="lineno">  149 </span>
<span class="lineno">  150 </span>data SomeFrameReg where
<span class="lineno">  151 </span>  SomeFrameReg ::
<span class="lineno">  152 </span>    NatRepr w -&gt;
<span class="lineno">  153 </span>    TypedReg (LLVMFrameType w) -&gt;
<span class="lineno">  154 </span>    SomeFrameReg
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>----------------------------------------------------------------------
<span class="lineno">  157 </span>-- * Typed Jump Targets and Function Handles
<span class="lineno">  158 </span>----------------------------------------------------------------------
<span class="lineno">  159 </span>
<span class="lineno">  160 </span>-- | During type-checking, we convert Crucible registers to variables
<span class="lineno">  161 </span>newtype TypedReg tp = TypedReg { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedRegVar</span></span></span> :: ExprVar tp }
<span class="lineno">  162 </span>
<span class="lineno">  163 </span>instance PermPretty (TypedReg tp) where
<span class="lineno">  164 </span>  <span class="decl"><span class="nottickedoff">permPrettyM = permPrettyM . typedRegVar</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>-- | A sequence of typed registers
<span class="lineno">  167 </span>data TypedRegs ctx where
<span class="lineno">  168 </span>  TypedRegsNil :: TypedRegs RNil
<span class="lineno">  169 </span>  TypedRegsCons :: !(TypedRegs ctx) -&gt; !(TypedReg a) -&gt; TypedRegs (ctx :&gt; a)
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>-- | Extract out a sequence of variables from a 'TypedRegs'
<span class="lineno">  172 </span>typedRegsToVars :: TypedRegs ctx -&gt; RAssign Name ctx
<span class="lineno">  173 </span><span class="decl"><span class="nottickedoff">typedRegsToVars TypedRegsNil = MNil</span>
<span class="lineno">  174 </span><span class="spaces"></span><span class="nottickedoff">typedRegsToVars (TypedRegsCons regs (TypedReg x)) = typedRegsToVars regs :&gt;: x</span></span>
<span class="lineno">  175 </span>
<span class="lineno">  176 </span>-- | Convert a sequence of variables to a 'TypedRegs'
<span class="lineno">  177 </span>varsToTypedRegs :: RAssign Name ctx -&gt; TypedRegs ctx
<span class="lineno">  178 </span><span class="decl"><span class="nottickedoff">varsToTypedRegs MNil = TypedRegsNil</span>
<span class="lineno">  179 </span><span class="spaces"></span><span class="nottickedoff">varsToTypedRegs (xs :&gt;: x) = TypedRegsCons (varsToTypedRegs xs) (TypedReg x)</span></span>
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>-- | Turn a sequence of typed registers into a variable substitution
<span class="lineno">  182 </span>typedRegsToVarSubst :: TypedRegs ctx -&gt; PermVarSubst ctx
<span class="lineno">  183 </span><span class="decl"><span class="nottickedoff">typedRegsToVarSubst = permVarSubstOfNames . typedRegsToVars</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>-- | A typed register along with its value if that is known statically
<span class="lineno">  186 </span>data RegWithVal a
<span class="lineno">  187 </span>  = RegWithVal (TypedReg a) (PermExpr a)
<span class="lineno">  188 </span>  | RegNoVal (TypedReg a)
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>-- | Get the 'TypedReg' from a 'RegWithVal'
<span class="lineno">  191 </span>regWithValReg :: RegWithVal a -&gt; TypedReg a
<span class="lineno">  192 </span><span class="decl"><span class="nottickedoff">regWithValReg (RegWithVal r _) = r</span>
<span class="lineno">  193 </span><span class="spaces"></span><span class="nottickedoff">regWithValReg (RegNoVal r) = r</span></span>
<span class="lineno">  194 </span>
<span class="lineno">  195 </span>-- | Get the expression for a 'RegWithVal', even if it is only the variable for
<span class="lineno">  196 </span>-- its register value when it has no statically-known value
<span class="lineno">  197 </span>regWithValExpr :: RegWithVal a -&gt; PermExpr a
<span class="lineno">  198 </span><span class="decl"><span class="nottickedoff">regWithValExpr (RegWithVal _ e) = e</span>
<span class="lineno">  199 </span><span class="spaces"></span><span class="nottickedoff">regWithValExpr (RegNoVal (TypedReg x)) = PExpr_Var x</span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>-- | A type-checked Crucible expression is a Crucible 'Expr' that uses
<span class="lineno">  202 </span>-- 'TypedReg's for variables. As part of type-checking, these typed registers
<span class="lineno">  203 </span>-- (which are the inputs to the expression) as well as the final output value of
<span class="lineno">  204 </span>-- the expression are annotated with equality permissions @eq(e)@ if their
<span class="lineno">  205 </span>-- values can be statically represented as permission expressions @e@.
<span class="lineno">  206 </span>data TypedExpr ext tp =
<span class="lineno">  207 </span>  TypedExpr !(App ext RegWithVal tp) !(Maybe (PermExpr tp))
<span class="lineno">  208 </span>
<span class="lineno">  209 </span>-- | A \&quot;typed\&quot; function handle is a normal function handle along with contexts
<span class="lineno">  210 </span>-- of ghost input and output variables
<span class="lineno">  211 </span>data TypedFnHandle ghosts args gouts ret where
<span class="lineno">  212 </span>  TypedFnHandle :: !(CruCtx ghosts) -&gt; !(CruCtx gouts) -&gt;
<span class="lineno">  213 </span>                   !(FnHandle cargs ret) -&gt;
<span class="lineno">  214 </span>                   TypedFnHandle ghosts (CtxToRList cargs) gouts ret
<span class="lineno">  215 </span>
<span class="lineno">  216 </span>-- | Extract out the context of ghost arguments from a 'TypedFnHandle'
<span class="lineno">  217 </span>typedFnHandleGhosts :: TypedFnHandle ghosts args gouts ret -&gt; CruCtx ghosts
<span class="lineno">  218 </span><span class="decl"><span class="nottickedoff">typedFnHandleGhosts (TypedFnHandle ghosts _ _) = ghosts</span></span>
<span class="lineno">  219 </span>
<span class="lineno">  220 </span>-- | Extract out the context of output ghost arguments from a 'TypedFnHandle'
<span class="lineno">  221 </span>typedFnHandleGouts :: TypedFnHandle ghosts args gouts ret -&gt; CruCtx gouts
<span class="lineno">  222 </span><span class="decl"><span class="nottickedoff">typedFnHandleGouts (TypedFnHandle _ gouts _) = gouts</span></span>
<span class="lineno">  223 </span>
<span class="lineno">  224 </span>-- | Extract out the context of regular arguments from a 'TypedFnHandle'
<span class="lineno">  225 </span>typedFnHandleArgs :: TypedFnHandle ghosts args gouts ret -&gt; CruCtx args
<span class="lineno">  226 </span><span class="decl"><span class="nottickedoff">typedFnHandleArgs (TypedFnHandle _ _ h) = mkCruCtx $ handleArgTypes h</span></span>
<span class="lineno">  227 </span>
<span class="lineno">  228 </span>-- | Extract out the context of all arguments of a 'TypedFnHandle', including
<span class="lineno">  229 </span>-- the lifetime argument
<span class="lineno">  230 </span>typedFnHandleAllArgs :: TypedFnHandle ghosts args gouts ret -&gt;
<span class="lineno">  231 </span>                        CruCtx (ghosts :++: args)
<span class="lineno">  232 </span><span class="decl"><span class="nottickedoff">typedFnHandleAllArgs h =</span>
<span class="lineno">  233 </span><span class="spaces">  </span><span class="nottickedoff">appendCruCtx (typedFnHandleGhosts h) (typedFnHandleArgs h)</span></span>
<span class="lineno">  234 </span>
<span class="lineno">  235 </span>
<span class="lineno">  236 </span>-- | Extract out the return type of a 'TypedFnHandle'
<span class="lineno">  237 </span>typedFnHandleRetType :: TypedFnHandle ghosts args gouts ret -&gt; TypeRepr ret
<span class="lineno">  238 </span><span class="decl"><span class="nottickedoff">typedFnHandleRetType (TypedFnHandle _ _ h) = handleReturnType h</span></span>
<span class="lineno">  239 </span>
<span class="lineno">  240 </span>-- | Extract out all the return types of a 'TypedFnHandle'
<span class="lineno">  241 </span>typedFnHandleRetTypes :: TypedFnHandle ghosts args gouts ret -&gt;
<span class="lineno">  242 </span>                         CruCtx (gouts :&gt; ret)
<span class="lineno">  243 </span><span class="decl"><span class="nottickedoff">typedFnHandleRetTypes (TypedFnHandle _ gouts h) =</span>
<span class="lineno">  244 </span><span class="spaces">  </span><span class="nottickedoff">CruCtxCons gouts $ handleReturnType h</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span>-- | As in standard Crucible, blocks are identified by membership proofs that
<span class="lineno">  248 </span>-- their input arguments are in the @blocks@ list. We also track an 'Int' that
<span class="lineno">  249 </span>-- gives the 'indexVal' of the original Crucible block ID, so that typed block
<span class="lineno">  250 </span>-- IDs can be printed the same way as standard Crucible block IDs. The issue
<span class="lineno">  251 </span>-- here is that 'Member' proofs count from the right of an 'RList', while
<span class="lineno">  252 </span>-- Crucible uses membership proofs that count from the left, and so the sizes
<span class="lineno">  253 </span>-- are not the same.
<span class="lineno">  254 </span>data TypedBlockID (ctx :: RList (RList CrucibleType)) args =
<span class="lineno">  255 </span>  TypedBlockID { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedBlockIDMember</span></span></span> :: Member ctx args, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedBlockIDIx</span></span></span> :: Int }
<span class="lineno">  256 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  257 </span>
<span class="lineno">  258 </span>instance TestEquality (TypedBlockID ctx) where
<span class="lineno">  259 </span>  <span class="decl"><span class="nottickedoff">testEquality (TypedBlockID memb1 _) (TypedBlockID memb2 _) =</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="nottickedoff">testEquality memb1 memb2</span></span>
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (TypedBlockID ctx args)</span></span></span></span> where
<span class="lineno">  263 </span>  <span class="decl"><span class="nottickedoff">show tblkID = &quot;%&quot; ++ show (typedBlockIDIx tblkID)</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>-- | Convert a Crucible 'Index' to a 'TypedBlockID'
<span class="lineno">  266 </span>indexToTypedBlockID :: Size ctx -&gt; Index ctx args -&gt;
<span class="lineno">  267 </span>                       TypedBlockID (CtxCtxToRList ctx) (CtxToRList args)
<span class="lineno">  268 </span><span class="decl"><span class="nottickedoff">indexToTypedBlockID sz ix =</span>
<span class="lineno">  269 </span><span class="spaces">  </span><span class="nottickedoff">TypedBlockID (indexCtxToMember sz ix) (Ctx.indexVal ix)</span></span>
<span class="lineno">  270 </span>
<span class="lineno">  271 </span>-- | All of our blocks have multiple entry points, for different inferred types,
<span class="lineno">  272 </span>-- so a \&quot;typed\&quot; 'BlockID' is a normal Crucible 'BlockID' (which is just an index
<span class="lineno">  273 </span>-- into the @blocks@ context of contexts) plus an 'Int' specifying which entry
<span class="lineno">  274 </span>-- point to that block
<span class="lineno">  275 </span>data TypedEntryID (blocks :: RList (RList CrucibleType)) (args :: RList CrucibleType) =
<span class="lineno">  276 </span>  TypedEntryID { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">entryBlockID</span></span></span> :: TypedBlockID blocks args, <span class="nottickedoff"><span class="decl"><span class="nottickedoff">entryIndex</span></span></span> :: Int }
<span class="lineno">  277 </span>  deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>
<span class="lineno">  278 </span>
<span class="lineno">  279 </span>-- | Get the 'Member' proof of the 'TypedBlockID' of a 'TypedEntryID'
<span class="lineno">  280 </span>entryBlockMember :: TypedEntryID blocks args -&gt; Member blocks args
<span class="lineno">  281 </span><span class="decl"><span class="nottickedoff">entryBlockMember = typedBlockIDMember . entryBlockID</span></span>
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>-- | Compute the indices corresponding to the 'BlockID' and 'entryIndex' of a
<span class="lineno">  284 </span>-- 'TypedEntryID', for printing purposes
<span class="lineno">  285 </span>entryIDIndices :: TypedEntryID blocks args -&gt; (Int, Int)
<span class="lineno">  286 </span><span class="decl"><span class="nottickedoff">entryIDIndices (TypedEntryID tblkID ix) = (typedBlockIDIx tblkID, ix)</span></span>
<span class="lineno">  287 </span>
<span class="lineno">  288 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (TypedEntryID blocks args)</span></span></span></span> where
<span class="lineno">  289 </span>  <span class="decl"><span class="nottickedoff">show (TypedEntryID {..}) = show entryBlockID ++ &quot;(&quot; ++ show entryIndex ++ &quot;)&quot;</span></span>
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>instance TestEquality (TypedEntryID blocks) where
<span class="lineno">  292 </span>  <span class="decl"><span class="nottickedoff">testEquality (TypedEntryID memb1 i1) (TypedEntryID memb2 i2)</span>
<span class="lineno">  293 </span><span class="spaces">    </span><span class="nottickedoff">| i1 == i2 = testEquality memb1 memb2</span>
<span class="lineno">  294 </span><span class="spaces">  </span><span class="nottickedoff">testEquality _ _ = Nothing</span></span>
<span class="lineno">  295 </span>
<span class="lineno">  296 </span>-- | Each call site, that jumps or branches to another block, is identified by
<span class="lineno">  297 </span>-- the entrypoint it occurs in and the entrypoint it calls, and is associated
<span class="lineno">  298 </span>-- with the free variables at that call site, each of which could have
<span class="lineno">  299 </span>-- permissions being passed by the call. Call sites also have an integer index
<span class="lineno">  300 </span>-- to handle the case when one entrypoint calls another multiple times, which
<span class="lineno">  301 </span>-- can happen if a disjunctive permission is eliminated in the former.
<span class="lineno">  302 </span>data TypedCallSiteID blocks args vars =
<span class="lineno">  303 </span>  forall args_src.
<span class="lineno">  304 </span>  TypedCallSiteID { <span class="decl"><span class="nottickedoff">callSiteSrc</span></span> :: TypedEntryID blocks args_src,
<span class="lineno">  305 </span>                    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">callSiteIx</span></span></span> :: Int,
<span class="lineno">  306 </span>                    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">callSiteDest</span></span></span> :: TypedEntryID blocks args,
<span class="lineno">  307 </span>                    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">callSiteVars</span></span></span> :: CruCtx vars }
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>-- | Get the 'TypedBlockID' of the callee of a call site
<span class="lineno">  310 </span>callSiteDestBlock :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno">  311 </span>                     TypedBlockID blocks args
<span class="lineno">  312 </span><span class="decl"><span class="nottickedoff">callSiteDestBlock = entryBlockID . callSiteDest</span></span>
<span class="lineno">  313 </span>
<span class="lineno">  314 </span>instance TestEquality (TypedCallSiteID blocks args) where
<span class="lineno">  315 </span>  <span class="decl"><span class="nottickedoff">testEquality (TypedCallSiteID</span>
<span class="lineno">  316 </span><span class="spaces">                </span><span class="nottickedoff">src1 ix1 dest1 vars1) (TypedCallSiteID src2 ix2 dest2 vars2)</span>
<span class="lineno">  317 </span><span class="spaces">    </span><span class="nottickedoff">| Just Refl &lt;- testEquality src1 src2</span>
<span class="lineno">  318 </span><span class="spaces">    </span><span class="nottickedoff">, ix1 == ix2, dest1 == dest2 = testEquality vars1 vars2</span>
<span class="lineno">  319 </span><span class="spaces">  </span><span class="nottickedoff">testEquality _ _ = Nothing</span></span>
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (TypedCallSiteID blocks args vars)</span></span></span></span> where
<span class="lineno">  322 </span>  <span class="decl"><span class="nottickedoff">show (TypedCallSiteID {..}) =</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="nottickedoff">&quot;&lt;siteID: src = &quot; ++ show callSiteSrc ++</span>
<span class="lineno">  324 </span><span class="spaces">    </span><span class="nottickedoff">&quot;, ix = &quot; ++ show callSiteIx ++</span>
<span class="lineno">  325 </span><span class="spaces">    </span><span class="nottickedoff">&quot;, dest = &quot; ++ show callSiteDest ++</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="nottickedoff">&quot;, vars =&quot; ++ renderDoc (permPretty emptyPPInfo callSiteVars) ++ &quot;&gt;&quot;</span></span>
<span class="lineno">  327 </span>
<span class="lineno">  328 </span>-- | Test if the caller of a 'TypedCallSiteID' equals a given entrypoint
<span class="lineno">  329 </span>callSiteIDCallerEq :: TypedEntryID blocks args_src -&gt;
<span class="lineno">  330 </span>                      TypedCallSiteID blocks args vars -&gt; Bool
<span class="lineno">  331 </span><span class="decl"><span class="nottickedoff">callSiteIDCallerEq entryID (TypedCallSiteID {..}) =</span>
<span class="lineno">  332 </span><span class="spaces">  </span><span class="nottickedoff">isJust $ testEquality entryID callSiteSrc</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>-- | A typed target for jump and branch statements, where the argument registers
<span class="lineno">  335 </span>-- (including top-level function arguments and free variables) are given with
<span class="lineno">  336 </span>-- their permissions as a 'DistPerms'
<span class="lineno">  337 </span>data TypedJumpTarget blocks tops ps where
<span class="lineno">  338 </span>     TypedJumpTarget ::
<span class="lineno">  339 </span>       !(TypedCallSiteID blocks args vars) -&gt;
<span class="lineno">  340 </span>       !(Proxy tops) -&gt; !(CruCtx args) -&gt;
<span class="lineno">  341 </span>       !(DistPerms ((tops :++: args) :++: vars)) -&gt;
<span class="lineno">  342 </span>       TypedJumpTarget blocks tops ((tops :++: args) :++: vars)
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>
<span class="lineno">  345 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall tp. TypedReg tp |])</span></span></span>
<span class="lineno">  346 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall tp. RegWithVal tp |])</span></span></span>
<span class="lineno">  347 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ctx. TypedRegs ctx |])</span></span></span>
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ext tp exprExt. NuMatchingExtC ext exprExt =&gt; TypedExpr ext tp |])</span></span></span>
<span class="lineno">  350 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ghosts args gouts ret.</span>
<span class="lineno">  351 </span><span class="spaces">                </span><span class="nottickedoff">TypedFnHandle ghosts args gouts ret |])</span></span></span>
<span class="lineno">  352 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks args. TypedBlockID blocks args |])</span></span></span>
<span class="lineno">  353 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks args. TypedEntryID blocks args |])</span></span></span>
<span class="lineno">  354 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks args ghosts. TypedCallSiteID blocks args ghosts |])</span></span></span>
<span class="lineno">  355 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks tops ps_in. TypedJumpTarget blocks tops ps_in |])</span></span></span>
<span class="lineno">  356 </span>
<span class="lineno">  357 </span>instance Closable (TypedBlockID blocks args) where
<span class="lineno">  358 </span>  <span class="decl"><span class="nottickedoff">toClosed (TypedBlockID memb ix) =</span>
<span class="lineno">  359 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| TypedBlockID |])</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="nottickedoff">`clApply` toClosed memb `clApply` toClosed ix</span></span>
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>instance Liftable (TypedBlockID blocks args) where
<span class="lineno">  363 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>instance Closable (TypedEntryID blocks args) where
<span class="lineno">  366 </span>  <span class="decl"><span class="nottickedoff">toClosed (TypedEntryID entryBlockID entryIndex) =</span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| TypedEntryID |])</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="nottickedoff">`clApply` toClosed entryBlockID `clApply` toClosed entryIndex</span></span>
<span class="lineno">  369 </span>
<span class="lineno">  370 </span>instance Liftable (TypedEntryID blocks args) where
<span class="lineno">  371 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  372 </span>
<span class="lineno">  373 </span>instance Closable (TypedCallSiteID blocks args vars) where
<span class="lineno">  374 </span>  <span class="decl"><span class="nottickedoff">toClosed (TypedCallSiteID src ix dest vars) =</span>
<span class="lineno">  375 </span><span class="spaces">    </span><span class="nottickedoff">$(mkClosed [| TypedCallSiteID |])</span>
<span class="lineno">  376 </span><span class="spaces">    </span><span class="nottickedoff">`clApply` toClosed src `clApply` toClosed ix</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="nottickedoff">`clApply` toClosed dest `clApply` toClosed vars</span></span>
<span class="lineno">  378 </span>
<span class="lineno">  379 </span>instance Liftable (TypedCallSiteID blocks args vars) where
<span class="lineno">  380 </span>  <span class="decl"><span class="nottickedoff">mbLift = unClosed . mbLift . fmap toClosed</span></span>
<span class="lineno">  381 </span>
<span class="lineno">  382 </span>----------------------------------------------------------------------
<span class="lineno">  383 </span>-- * Typed Crucible Statements
<span class="lineno">  384 </span>----------------------------------------------------------------------
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>-- | Typed Crucible statements with the given Crucible syntax extension and the
<span class="lineno">  387 </span>-- given set of return values
<span class="lineno">  388 </span>data TypedStmt ext (stmt_rets :: RList CrucibleType) ps_in ps_out where
<span class="lineno">  389 </span>
<span class="lineno">  390 </span>  -- | Assign a pure Crucible expressions to a register, where pure here means
<span class="lineno">  391 </span>  -- that its translation to SAW will be pure (i.e., no LLVM pointer operations)
<span class="lineno">  392 </span>  TypedSetReg :: !(TypeRepr tp) -&gt; !(TypedExpr ext tp) -&gt;
<span class="lineno">  393 </span>                 TypedStmt ext (RNil :&gt; tp) RNil (RNil :&gt; tp)
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>  -- | Assign a pure permissions expression to a register
<span class="lineno">  396 </span>  TypedSetRegPermExpr :: !(TypeRepr tp) -&gt; !(PermExpr tp) -&gt;
<span class="lineno">  397 </span>                         TypedStmt ext (RNil :&gt; tp) RNil (RNil :&gt; tp)
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>  -- | A function call to the function in register @f@, which must have function
<span class="lineno">  400 </span>  -- permission @(ghosts). ps_in -o ps_out@, passing the supplied registers for
<span class="lineno">  401 </span>  -- the @ghosts@ and @args@, where the former must be equal to the supplied
<span class="lineno">  402 </span>  -- expressions @gexprs@. A call has permissions
<span class="lineno">  403 </span>  --
<span class="lineno">  404 </span>  -- &gt; [gexprs/ghosts]ps_in, ghosts1:eq(gexprs1), ..., ghostsn:eq(gexprsn),
<span class="lineno">  405 </span>  -- &gt; f:((ghosts). ps_in -o ps_out)
<span class="lineno">  406 </span>  -- &gt; -o
<span class="lineno">  407 </span>  -- &gt; [gexprs/ghosts]ps_out
<span class="lineno">  408 </span>  TypedCall :: args ~ CtxToRList cargs =&gt;
<span class="lineno">  409 </span>               !(TypedReg (FunctionHandleType cargs ret)) -&gt;
<span class="lineno">  410 </span>               !(FunPerm ghosts args gouts ret) -&gt;
<span class="lineno">  411 </span>               !(TypedRegs ghosts) -&gt; !(PermExprs ghosts) -&gt; !(TypedRegs args) -&gt;
<span class="lineno">  412 </span>               TypedStmt ext (gouts :&gt; ret)
<span class="lineno">  413 </span>               ((ghosts :++: args) :++: ghosts :&gt; FunctionHandleType cargs ret)
<span class="lineno">  414 </span>               ((ghosts :++: args) :++: gouts :&gt; ret)
<span class="lineno">  415 </span>
<span class="lineno">  416 </span>  -- | Assert a boolean condition, printing the given string on failure
<span class="lineno">  417 </span>  TypedAssert :: !(TypedReg BoolType) -&gt; !(TypedReg (StringType Unicode)) -&gt;
<span class="lineno">  418 </span>                 TypedStmt ext RNil RNil RNil
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>  -- | LLVM-specific statement
<span class="lineno">  421 </span>  TypedLLVMStmt :: !(TypedLLVMStmt ret ps_in ps_out) -&gt;
<span class="lineno">  422 </span>                   TypedStmt LLVM (RNil :&gt; ret) ps_in ps_out
<span class="lineno">  423 </span>
<span class="lineno">  424 </span>
<span class="lineno">  425 </span>data TypedLLVMStmt ret ps_in ps_out where
<span class="lineno">  426 </span>  -- | Assign an LLVM word (i.e., a pointer with block 0) to a register
<span class="lineno">  427 </span>  --
<span class="lineno">  428 </span>  -- Type: @. -o ret:eq(word(x))@
<span class="lineno">  429 </span>  ConstructLLVMWord :: (1 &lt;= w2, KnownNat w2) =&gt;
<span class="lineno">  430 </span>                       !(TypedReg (BVType w2)) -&gt;
<span class="lineno">  431 </span>                       TypedLLVMStmt (LLVMPointerType w2)
<span class="lineno">  432 </span>                       RNil
<span class="lineno">  433 </span>                       (RNil :&gt; LLVMPointerType w2)
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>  -- | Assert that an LLVM pointer is a word, and return 0. This is the typed
<span class="lineno">  436 </span>  -- version of 'LLVM_PointerBlock' when we know the input is a word, i.e., has
<span class="lineno">  437 </span>  -- a pointer block value of 0.
<span class="lineno">  438 </span>  --
<span class="lineno">  439 </span>  -- Type: @x:eq(word(y)) -o ret:eq(0)@
<span class="lineno">  440 </span>  AssertLLVMWord :: (1 &lt;= w2, KnownNat w2) =&gt;
<span class="lineno">  441 </span>                    !(TypedReg (LLVMPointerType w2)) -&gt;
<span class="lineno">  442 </span>                    !(PermExpr (BVType w2)) -&gt;
<span class="lineno">  443 </span>                    TypedLLVMStmt NatType
<span class="lineno">  444 </span>                    (RNil :&gt; LLVMPointerType w2)
<span class="lineno">  445 </span>                    (RNil :&gt; NatType)
<span class="lineno">  446 </span>
<span class="lineno">  447 </span>
<span class="lineno">  448 </span>  -- | Assert that an LLVM pointer is a pointer
<span class="lineno">  449 </span>  --
<span class="lineno">  450 </span>  -- Type: @x:is_llvmptr -o .@
<span class="lineno">  451 </span>  AssertLLVMPtr :: (1 &lt;= w2, KnownNat w2) =&gt;
<span class="lineno">  452 </span>                   !(TypedReg (LLVMPointerType w2)) -&gt;
<span class="lineno">  453 </span>                   TypedLLVMStmt UnitType (RNil :&gt; LLVMPointerType w2) RNil
<span class="lineno">  454 </span>
<span class="lineno">  455 </span>  -- | Destruct an LLVM word into its bitvector value, which should equal the
<span class="lineno">  456 </span>  -- given expression
<span class="lineno">  457 </span>  --
<span class="lineno">  458 </span>  -- Type: @x:eq(word(e)) -o ret:eq(e)@
<span class="lineno">  459 </span>  DestructLLVMWord :: (1 &lt;= w2, KnownNat w2) =&gt;
<span class="lineno">  460 </span>                      !(TypedReg (LLVMPointerType w2)) -&gt;
<span class="lineno">  461 </span>                      !(PermExpr (BVType w2)) -&gt;
<span class="lineno">  462 </span>                      TypedLLVMStmt (BVType w2)
<span class="lineno">  463 </span>                      (RNil :&gt; LLVMPointerType w2)
<span class="lineno">  464 </span>                      (RNil :&gt; BVType w2)
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>  -- | Add an offset to an LLVM value
<span class="lineno">  467 </span>  --
<span class="lineno">  468 </span>  -- Type: @. -o ret:eq(x &amp;+ off)@
<span class="lineno">  469 </span>  OffsetLLVMValue :: (1 &lt;= w2, KnownNat w2) =&gt;
<span class="lineno">  470 </span>                     !(TypedReg (LLVMPointerType w2)) -&gt;
<span class="lineno">  471 </span>                     !(PermExpr (BVType w2)) -&gt;
<span class="lineno">  472 </span>                     TypedLLVMStmt (LLVMPointerType w2)
<span class="lineno">  473 </span>                     RNil
<span class="lineno">  474 </span>                     (RNil :&gt; LLVMPointerType w2)
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>  -- | Load a machine value from the address pointed to by the given pointer
<span class="lineno">  477 </span>  -- using the supplied field permission. Some set of permissions @ps@ can be on
<span class="lineno">  478 </span>  -- the stack below the field permission, and these are preserved. The lifetime
<span class="lineno">  479 </span>  -- of the field permission must also be proved to be current; the permissions
<span class="lineno">  480 </span>  -- for this are on the top of the stack and are also preserved.
<span class="lineno">  481 </span>  --
<span class="lineno">  482 </span>  -- Type:
<span class="lineno">  483 </span>  -- &gt; ps, x:ptr((rw,0) |-&gt; p), cur_ps
<span class="lineno">  484 </span>  -- &gt; -o ps, x:ptr((rw,0) |-&gt; eq(ret)), ret:p, cur_ps
<span class="lineno">  485 </span>  TypedLLVMLoad ::
<span class="lineno">  486 </span>    (HasPtrWidth w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  487 </span>    !(TypedReg (LLVMPointerType w)) -&gt;
<span class="lineno">  488 </span>    !(LLVMFieldPerm w sz) -&gt;
<span class="lineno">  489 </span>    !(DistPerms ps) -&gt;
<span class="lineno">  490 </span>    !(LifetimeCurrentPerms ps_l) -&gt;
<span class="lineno">  491 </span>    TypedLLVMStmt (LLVMPointerType sz)
<span class="lineno">  492 </span>      (ps :&gt; LLVMPointerType w :++: ps_l)
<span class="lineno">  493 </span>      (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType sz :++: ps_l)
<span class="lineno">  494 </span>
<span class="lineno">  495 </span>  -- | Store a machine value to the address pointed to by the given pointer
<span class="lineno">  496 </span>  -- using the supplied field permission, which also specifies the offset from
<span class="lineno">  497 </span>  -- the pointer where the store occurs. Some set of permissions @ps@ can be on
<span class="lineno">  498 </span>  -- the stack below the field permission, and these are preserved. The lifetime
<span class="lineno">  499 </span>  -- of the field permission must also be proved to be current; the permissions
<span class="lineno">  500 </span>  -- for this are on the top of the stack and are also preserved.
<span class="lineno">  501 </span>  --
<span class="lineno">  502 </span>  -- Type:
<span class="lineno">  503 </span>  -- &gt; ps, x:ptr((rw,0) |-&gt; p), cur_ps
<span class="lineno">  504 </span>  -- &gt; -o ps, x:ptr((rw,0) |-&gt; eq(e)), cur_ps
<span class="lineno">  505 </span>  TypedLLVMStore ::
<span class="lineno">  506 </span>    (HasPtrWidth w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno">  507 </span>    !(TypedReg (LLVMPointerType w)) -&gt;
<span class="lineno">  508 </span>    !(LLVMFieldPerm w sz) -&gt;
<span class="lineno">  509 </span>    !(PermExpr (LLVMPointerType sz)) -&gt;
<span class="lineno">  510 </span>    !(DistPerms ps) -&gt;
<span class="lineno">  511 </span>    !(LifetimeCurrentPerms ps_l) -&gt;
<span class="lineno">  512 </span>    TypedLLVMStmt UnitType
<span class="lineno">  513 </span>      (ps :&gt; LLVMPointerType w :++: ps_l)
<span class="lineno">  514 </span>      (ps :&gt; LLVMPointerType w :++: ps_l)
<span class="lineno">  515 </span>
<span class="lineno">  516 </span>  -- | Allocate an object of the given size on the given LLVM frame, described
<span class="lineno">  517 </span>  -- as a memory block with empty shape:
<span class="lineno">  518 </span>  --
<span class="lineno">  519 </span>  -- Type:
<span class="lineno">  520 </span>  -- &gt; fp:frame(ps) -o fp:frame(ps,(ret,i)),
<span class="lineno">  521 </span>  -- &gt;                 ret:memblock(W,0,sz,emptysh)
<span class="lineno">  522 </span>  --
<span class="lineno">  523 </span>  -- where @sz@ is the number of bytes allocated
<span class="lineno">  524 </span>  TypedLLVMAlloca ::
<span class="lineno">  525 </span>    HasPtrWidth w =&gt;
<span class="lineno">  526 </span>    !(TypedReg (LLVMFrameType w)) -&gt;
<span class="lineno">  527 </span>    !(LLVMFramePerm w) -&gt;
<span class="lineno">  528 </span>    !Integer -&gt;
<span class="lineno">  529 </span>    TypedLLVMStmt (LLVMPointerType w)
<span class="lineno">  530 </span>      (RNil :&gt; LLVMFrameType w)
<span class="lineno">  531 </span>      (RNil :&gt; LLVMFrameType w :&gt; LLVMPointerType w)
<span class="lineno">  532 </span>
<span class="lineno">  533 </span>  -- | Create a new LLVM frame
<span class="lineno">  534 </span>  --
<span class="lineno">  535 </span>  -- Type: @. -o ret:frame()@
<span class="lineno">  536 </span>  TypedLLVMCreateFrame ::
<span class="lineno">  537 </span>    HasPtrWidth w =&gt;
<span class="lineno">  538 </span>    TypedLLVMStmt (LLVMFrameType w) RNil (RNil :&gt; LLVMFrameType w)
<span class="lineno">  539 </span>
<span class="lineno">  540 </span>  -- | Delete an LLVM frame and deallocate all memory objects allocated in it,
<span class="lineno">  541 </span>  -- assuming that the current distinguished permissions @ps@ correspond to the
<span class="lineno">  542 </span>  -- write permissions to all those objects allocated on the frame
<span class="lineno">  543 </span>  --
<span class="lineno">  544 </span>  -- Type: @ps, fp:frame(ps) -o .@
<span class="lineno">  545 </span>  TypedLLVMDeleteFrame ::
<span class="lineno">  546 </span>    HasPtrWidth w =&gt;
<span class="lineno">  547 </span>    !(TypedReg (LLVMFrameType w)) -&gt;
<span class="lineno">  548 </span>    !(LLVMFramePerm w) -&gt; !(DistPerms ps) -&gt;
<span class="lineno">  549 </span>    TypedLLVMStmt UnitType (ps :&gt; LLVMFrameType w) RNil
<span class="lineno">  550 </span>
<span class="lineno">  551 </span>  -- | Typed version of 'LLVM_LoadHandle', that loads the function handle
<span class="lineno">  552 </span>  -- referred to by a function pointer, assuming we know it has one:
<span class="lineno">  553 </span>  --
<span class="lineno">  554 </span>  -- Type: @x:llvm_funptr(p) -o ret:p@
<span class="lineno">  555 </span>  TypedLLVMLoadHandle ::
<span class="lineno">  556 </span>    HasPtrWidth w =&gt;
<span class="lineno">  557 </span>    !(TypedReg (LLVMPointerType w)) -&gt;
<span class="lineno">  558 </span>    !(TypeRepr (FunctionHandleType cargs ret)) -&gt;
<span class="lineno">  559 </span>    !(ValuePerm (FunctionHandleType cargs ret)) -&gt;
<span class="lineno">  560 </span>    TypedLLVMStmt (FunctionHandleType cargs ret)
<span class="lineno">  561 </span>      (RNil :&gt; LLVMPointerType w)
<span class="lineno">  562 </span>      (RNil :&gt; FunctionHandleType cargs ret)
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>  -- | Typed version of 'LLVM_ResolveGlobal', that resolves a 'GlobalSymbol' to
<span class="lineno">  565 </span>  -- an LLVM value, assuming it has the given permission in the environment:
<span class="lineno">  566 </span>  --
<span class="lineno">  567 </span>  -- Type: @. -o ret:p@
<span class="lineno">  568 </span>  TypedLLVMResolveGlobal ::
<span class="lineno">  569 </span>    HasPtrWidth w =&gt;
<span class="lineno">  570 </span>    !GlobalSymbol -&gt;
<span class="lineno">  571 </span>    !(ValuePerm (LLVMPointerType w)) -&gt;
<span class="lineno">  572 </span>    TypedLLVMStmt (LLVMPointerType w) RNil (RNil :&gt; LLVMPointerType w)
<span class="lineno">  573 </span>
<span class="lineno">  574 </span>  -- | An if-then-else statement over LLVM values
<span class="lineno">  575 </span>  TypedLLVMIte ::
<span class="lineno">  576 </span>    1 &lt;= w =&gt;
<span class="lineno">  577 </span>    !(NatRepr w) -&gt;
<span class="lineno">  578 </span>    !(TypedReg BoolType) -&gt;
<span class="lineno">  579 </span>    !(TypedReg (LLVMPointerType w)) -&gt;
<span class="lineno">  580 </span>    !(TypedReg (LLVMPointerType w)) -&gt;
<span class="lineno">  581 </span>    TypedLLVMStmt (LLVMPointerType w) RNil (RNil :&gt; LLVMPointerType w)
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>-- | Return the input permissions for a 'TypedStmt'
<span class="lineno">  584 </span>typedStmtIn :: TypedStmt ext stmt_rets ps_in ps_out -&gt; DistPerms ps_in
<span class="lineno">  585 </span><span class="decl"><span class="nottickedoff">typedStmtIn (TypedSetReg _ _) = DistPermsNil</span>
<span class="lineno">  586 </span><span class="spaces"></span><span class="nottickedoff">typedStmtIn (TypedSetRegPermExpr _ _) = DistPermsNil</span>
<span class="lineno">  587 </span><span class="spaces"></span><span class="nottickedoff">typedStmtIn (TypedCall (TypedReg f) fun_perm ghosts gexprs args) =</span>
<span class="lineno">  588 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsCons</span>
<span class="lineno">  589 </span><span class="spaces">  </span><span class="nottickedoff">(funPermDistIns fun_perm (typedRegsToVars ghosts) gexprs (typedRegsToVars args))</span>
<span class="lineno">  590 </span><span class="spaces">  </span><span class="nottickedoff">f (ValPerm_Conj1 $ Perm_Fun fun_perm)</span>
<span class="lineno">  591 </span><span class="spaces"></span><span class="nottickedoff">typedStmtIn (TypedAssert _ _) = DistPermsNil</span>
<span class="lineno">  592 </span><span class="spaces"></span><span class="nottickedoff">typedStmtIn (TypedLLVMStmt llvmStmt) = typedLLVMStmtIn llvmStmt</span></span>
<span class="lineno">  593 </span>
<span class="lineno">  594 </span>-- | Return the input permissions for a 'TypedLLVMStmt'
<span class="lineno">  595 </span>typedLLVMStmtIn :: TypedLLVMStmt ret ps_in ps_out -&gt; DistPerms ps_in
<span class="lineno">  596 </span><span class="decl"><span class="nottickedoff">typedLLVMStmtIn (ConstructLLVMWord _) = DistPermsNil</span>
<span class="lineno">  597 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (AssertLLVMWord (TypedReg x) e) =</span>
<span class="lineno">  598 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_LLVMWord e)</span>
<span class="lineno">  599 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (AssertLLVMPtr (TypedReg x)) =</span>
<span class="lineno">  600 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Conj1 Perm_IsLLVMPtr)</span>
<span class="lineno">  601 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (DestructLLVMWord (TypedReg x) e) =</span>
<span class="lineno">  602 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 x (ValPerm_Eq $ PExpr_LLVMWord e)</span>
<span class="lineno">  603 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (OffsetLLVMValue _ _) =</span>
<span class="lineno">  604 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsNil</span>
<span class="lineno">  605 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMLoad (TypedReg x) fp ps ps_l) =</span>
<span class="lineno">  606 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  607 </span><span class="spaces">  </span><span class="nottickedoff">permAssert</span>
<span class="lineno">  608 </span><span class="spaces">  </span><span class="nottickedoff">(lifetimeCurrentPermsLifetime ps_l == llvmFieldLifetime fp)</span>
<span class="lineno">  609 </span><span class="spaces">  </span><span class="nottickedoff">&quot;typedLLVMStmtIn: TypedLLVMLoad: mismatch for field lifetime&quot; $</span>
<span class="lineno">  610 </span><span class="spaces">  </span><span class="nottickedoff">permAssert (bvEq (llvmFieldOffset fp) (bvInt 0))</span>
<span class="lineno">  611 </span><span class="spaces">  </span><span class="nottickedoff">&quot;typedLLVMStmtIn: TypedLLVMLoad: mismatch for field offset&quot; $</span>
<span class="lineno">  612 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms</span>
<span class="lineno">  613 </span><span class="spaces">  </span><span class="nottickedoff">(DistPermsCons ps x (ValPerm_Conj1 $ Perm_LLVMField fp))</span>
<span class="lineno">  614 </span><span class="spaces">  </span><span class="nottickedoff">(lifetimeCurrentPermsPerms ps_l)</span>
<span class="lineno">  615 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMStore (TypedReg x) fp _ ps cur_ps) =</span>
<span class="lineno">  616 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  617 </span><span class="spaces">  </span><span class="nottickedoff">permAssert (llvmFieldRW fp == PExpr_Write &amp;&amp;</span>
<span class="lineno">  618 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmFieldOffset fp) (bvInt 0) &amp;&amp;</span>
<span class="lineno">  619 </span><span class="spaces">              </span><span class="nottickedoff">llvmFieldLifetime fp == lifetimeCurrentPermsLifetime cur_ps)</span>
<span class="lineno">  620 </span><span class="spaces">  </span><span class="nottickedoff">&quot;typedLLVMStmtIn: TypedLLVMStore: mismatch for field permission&quot; $</span>
<span class="lineno">  621 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms</span>
<span class="lineno">  622 </span><span class="spaces">  </span><span class="nottickedoff">(DistPermsCons ps x (ValPerm_Conj1 $ Perm_LLVMField fp))</span>
<span class="lineno">  623 </span><span class="spaces">  </span><span class="nottickedoff">(lifetimeCurrentPermsPerms cur_ps)</span>
<span class="lineno">  624 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMAlloca (TypedReg f) fperms _) =</span>
<span class="lineno">  625 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  626 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 f (ValPerm_Conj [Perm_LLVMFrame fperms])</span>
<span class="lineno">  627 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn TypedLLVMCreateFrame = DistPermsNil</span>
<span class="lineno">  628 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMDeleteFrame (TypedReg f) fperms perms) =</span>
<span class="lineno">  629 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="nottickedoff">case llvmFrameDeletionPerms fperms of</span>
<span class="lineno">  631 </span><span class="spaces">    </span><span class="nottickedoff">Some perms'</span>
<span class="lineno">  632 </span><span class="spaces">      </span><span class="nottickedoff">| Just Refl &lt;- testEquality perms perms' -&gt;</span>
<span class="lineno">  633 </span><span class="spaces">        </span><span class="nottickedoff">DistPermsCons perms f (ValPerm_Conj1 $ Perm_LLVMFrame fperms)</span>
<span class="lineno">  634 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;typedLLVMStmtIn: incorrect perms in rule&quot;</span>
<span class="lineno">  635 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMLoadHandle (TypedReg f) tp p) =</span>
<span class="lineno">  636 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  637 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 f (ValPerm_Conj1 $ Perm_LLVMFunPtr tp p)</span>
<span class="lineno">  638 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMResolveGlobal _ _) =</span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="nottickedoff">DistPermsNil</span>
<span class="lineno">  640 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtIn (TypedLLVMIte _ _ _ _) = DistPermsNil</span></span>
<span class="lineno">  641 </span>
<span class="lineno">  642 </span>-- | Return the output permissions for a 'TypedStmt'
<span class="lineno">  643 </span>typedStmtOut :: TypedStmt ext stmt_rets ps_in ps_out -&gt;
<span class="lineno">  644 </span>                RAssign Name stmt_rets -&gt; DistPerms ps_out
<span class="lineno">  645 </span><span class="decl"><span class="nottickedoff">typedStmtOut (TypedSetReg _ (TypedExpr _ (Just e))) (_ :&gt;: ret) =</span>
<span class="lineno">  646 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Eq e)</span>
<span class="lineno">  647 </span><span class="spaces"></span><span class="nottickedoff">typedStmtOut (TypedSetReg _ (TypedExpr _ Nothing)) (_ :&gt;: ret) =</span>
<span class="lineno">  648 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret ValPerm_True</span>
<span class="lineno">  649 </span><span class="spaces"></span><span class="nottickedoff">typedStmtOut (TypedSetRegPermExpr _ e) (_ :&gt;: ret) =</span>
<span class="lineno">  650 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Eq e)</span>
<span class="lineno">  651 </span><span class="spaces"></span><span class="nottickedoff">typedStmtOut (TypedCall _ fun_perm ghosts gexprs args) rets =</span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="nottickedoff">funPermDistOuts fun_perm (typedRegsToVars ghosts) gexprs</span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="nottickedoff">(typedRegsToVars args) rets</span>
<span class="lineno">  654 </span><span class="spaces"></span><span class="nottickedoff">typedStmtOut (TypedAssert _ _) _ = DistPermsNil</span>
<span class="lineno">  655 </span><span class="spaces"></span><span class="nottickedoff">typedStmtOut (TypedLLVMStmt llvmStmt) (_ :&gt;: ret) =</span>
<span class="lineno">  656 </span><span class="spaces">  </span><span class="nottickedoff">typedLLVMStmtOut llvmStmt ret</span></span>
<span class="lineno">  657 </span>
<span class="lineno">  658 </span>-- | Return the output permissions for a 'TypedStmt'
<span class="lineno">  659 </span>typedLLVMStmtOut :: TypedLLVMStmt ret ps_in ps_out -&gt; Name ret -&gt;
<span class="lineno">  660 </span>                    DistPerms ps_out
<span class="lineno">  661 </span><span class="decl"><span class="nottickedoff">typedLLVMStmtOut (ConstructLLVMWord (TypedReg x)) ret =</span>
<span class="lineno">  662 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Eq $ PExpr_LLVMWord $ PExpr_Var x)</span>
<span class="lineno">  663 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (AssertLLVMWord (TypedReg _) _) ret =</span>
<span class="lineno">  664 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Eq $ PExpr_Nat 0)</span>
<span class="lineno">  665 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (AssertLLVMPtr _) _ = DistPermsNil</span>
<span class="lineno">  666 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (DestructLLVMWord (TypedReg _) e) ret =</span>
<span class="lineno">  667 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Eq e)</span>
<span class="lineno">  668 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (OffsetLLVMValue (TypedReg x) off) ret =</span>
<span class="lineno">  669 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Eq $ PExpr_LLVMOffset x off)</span>
<span class="lineno">  670 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMLoad (TypedReg x) fp ps ps_l) ret =</span>
<span class="lineno">  671 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  672 </span><span class="spaces">  </span><span class="nottickedoff">if lifetimeCurrentPermsLifetime ps_l == llvmFieldLifetime fp then</span>
<span class="lineno">  673 </span><span class="spaces">    </span><span class="nottickedoff">appendDistPerms</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="nottickedoff">(DistPermsCons</span>
<span class="lineno">  675 </span><span class="spaces">     </span><span class="nottickedoff">(DistPermsCons ps</span>
<span class="lineno">  676 </span><span class="spaces">      </span><span class="nottickedoff">x (ValPerm_Conj1 $ Perm_LLVMField $</span>
<span class="lineno">  677 </span><span class="spaces">         </span><span class="nottickedoff">fp { llvmFieldContents = ValPerm_Eq (PExpr_Var ret) }))</span>
<span class="lineno">  678 </span><span class="spaces">     </span><span class="nottickedoff">ret (llvmFieldContents fp))</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="nottickedoff">(lifetimeCurrentPermsPerms ps_l)</span>
<span class="lineno">  680 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno">  681 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;typedLLVMStmtOut: TypedLLVMLoad: mismatch for field lifetime&quot;</span>
<span class="lineno">  682 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMStore (TypedReg x) fp e ps cur_ps) _ =</span>
<span class="lineno">  683 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  684 </span><span class="spaces">  </span><span class="nottickedoff">permAssert (llvmFieldRW fp == PExpr_Write &amp;&amp;</span>
<span class="lineno">  685 </span><span class="spaces">              </span><span class="nottickedoff">bvEq (llvmFieldOffset fp) (bvInt 0) &amp;&amp;</span>
<span class="lineno">  686 </span><span class="spaces">              </span><span class="nottickedoff">llvmFieldLifetime fp == lifetimeCurrentPermsLifetime cur_ps)</span>
<span class="lineno">  687 </span><span class="spaces">  </span><span class="nottickedoff">&quot;typedLLVMStmtOut: TypedLLVMStore: mismatch for field permission&quot; $</span>
<span class="lineno">  688 </span><span class="spaces">  </span><span class="nottickedoff">appendDistPerms</span>
<span class="lineno">  689 </span><span class="spaces">  </span><span class="nottickedoff">(DistPermsCons ps x (ValPerm_Conj1 $ Perm_LLVMField $</span>
<span class="lineno">  690 </span><span class="spaces">                       </span><span class="nottickedoff">fp { llvmFieldContents = ValPerm_Eq e }))</span>
<span class="lineno">  691 </span><span class="spaces">  </span><span class="nottickedoff">(lifetimeCurrentPermsPerms cur_ps)</span>
<span class="lineno">  692 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMAlloca</span>
<span class="lineno">  693 </span><span class="spaces">                  </span><span class="nottickedoff">(TypedReg f) (fperms :: LLVMFramePerm w) len) ret =</span>
<span class="lineno">  694 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  695 </span><span class="spaces">  </span><span class="nottickedoff">distPerms2 f (ValPerm_Conj [Perm_LLVMFrame ((PExpr_Var ret, len):fperms)])</span>
<span class="lineno">  696 </span><span class="spaces">  </span><span class="nottickedoff">ret (llvmEmptyBlockPermOfSize Proxy len)</span>
<span class="lineno">  697 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut TypedLLVMCreateFrame ret =</span>
<span class="lineno">  698 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno">  699 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret $ ValPerm_Conj [Perm_LLVMFrame []]</span>
<span class="lineno">  700 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMDeleteFrame _ _ _) _ = DistPermsNil</span>
<span class="lineno">  701 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMLoadHandle _ _ p) ret = distPerms1 ret p</span>
<span class="lineno">  702 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMResolveGlobal _ p) ret =</span>
<span class="lineno">  703 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret p</span>
<span class="lineno">  704 </span><span class="spaces"></span><span class="nottickedoff">typedLLVMStmtOut (TypedLLVMIte _ _ (TypedReg x1) (TypedReg x2)) ret =</span>
<span class="lineno">  705 </span><span class="spaces">  </span><span class="nottickedoff">distPerms1 ret (ValPerm_Or (ValPerm_Eq $ PExpr_Var x1)</span>
<span class="lineno">  706 </span><span class="spaces">                  </span><span class="nottickedoff">(ValPerm_Eq $ PExpr_Var x2))</span></span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>
<span class="lineno">  709 </span>-- | Check that the permission stack of the given permission set matches the
<span class="lineno">  710 </span>-- input permissions of the given statement, and replace them with the output
<span class="lineno">  711 </span>-- permissions of the statement
<span class="lineno">  712 </span>applyTypedStmt :: TypedStmt ext stmt_rets ps_in ps_out -&gt;
<span class="lineno">  713 </span>                  RAssign Name stmt_rets -&gt; PermSet ps_in -&gt; PermSet ps_out
<span class="lineno">  714 </span><span class="decl"><span class="nottickedoff">applyTypedStmt stmt stmt_rets =</span>
<span class="lineno">  715 </span><span class="spaces">  </span><span class="nottickedoff">modifyDistPerms $ \perms -&gt;</span>
<span class="lineno">  716 </span><span class="spaces">  </span><span class="nottickedoff">if perms == typedStmtIn stmt then</span>
<span class="lineno">  717 </span><span class="spaces">    </span><span class="nottickedoff">typedStmtOut stmt stmt_rets</span>
<span class="lineno">  718 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;applyTypedStmt: unexpected input permissions!&quot;</span></span>
<span class="lineno">  720 </span>
<span class="lineno">  721 </span>
<span class="lineno">  722 </span>----------------------------------------------------------------------
<span class="lineno">  723 </span>-- * Typed Sequences of Crucible Statements
<span class="lineno">  724 </span>----------------------------------------------------------------------
<span class="lineno">  725 </span>
<span class="lineno">  726 </span>-- | A permission implication annotated a top-level error message to be printed
<span class="lineno">  727 </span>-- on failure
<span class="lineno">  728 </span>data AnnotPermImpl r ps = AnnotPermImpl !String !(PermImpl r ps)
<span class="lineno">  729 </span>
<span class="lineno">  730 </span>-- | Typed return argument
<span class="lineno">  731 </span>data TypedRet tops rets ps =
<span class="lineno">  732 </span>  TypedRet
<span class="lineno">  733 </span>  !(ps :~: tops :++: rets) !(CruCtx rets) !(RAssign ExprVar rets)
<span class="lineno">  734 </span>  !(Mb rets (DistPerms ps))
<span class="lineno">  735 </span>
<span class="lineno">  736 </span>
<span class="lineno">  737 </span>-- | Typed Crucible block termination statements
<span class="lineno">  738 </span>data TypedTermStmt blocks tops rets ps_in where
<span class="lineno">  739 </span>  -- | Jump to the given jump target
<span class="lineno">  740 </span>  TypedJump :: !(AnnotPermImpl (TypedJumpTarget blocks tops) ps_in) -&gt;
<span class="lineno">  741 </span>               TypedTermStmt blocks tops rets ps_in
<span class="lineno">  742 </span>
<span class="lineno">  743 </span>  -- | Branch on condition: if true, jump to the first jump target, and
<span class="lineno">  744 </span>  -- otherwise jump to the second jump target
<span class="lineno">  745 </span>  TypedBr :: !(TypedReg BoolType) -&gt;
<span class="lineno">  746 </span>             !(AnnotPermImpl (TypedJumpTarget blocks tops) ps_in) -&gt;
<span class="lineno">  747 </span>             !(AnnotPermImpl (TypedJumpTarget blocks tops) ps_in) -&gt;
<span class="lineno">  748 </span>             TypedTermStmt blocks tops rets ps_in
<span class="lineno">  749 </span>
<span class="lineno">  750 </span>  -- | Return from function, providing the return value and also proof that the
<span class="lineno">  751 </span>  -- current permissions imply the required return permissions
<span class="lineno">  752 </span>  TypedReturn :: !(AnnotPermImpl (TypedRet tops rets) ps_in) -&gt;
<span class="lineno">  753 </span>                 TypedTermStmt blocks tops rets ps_in
<span class="lineno">  754 </span>
<span class="lineno">  755 </span>  -- | Block ends with an error
<span class="lineno">  756 </span>  TypedErrorStmt :: !(Maybe String) -&gt; !(TypedReg (StringType Unicode)) -&gt;
<span class="lineno">  757 </span>                    TypedTermStmt blocks tops rets ps_in
<span class="lineno">  758 </span>
<span class="lineno">  759 </span>
<span class="lineno">  760 </span>-- | A typed sequence of Crucible statements
<span class="lineno">  761 </span>data TypedStmtSeq ext blocks tops rets ps_in where
<span class="lineno">  762 </span>  -- | A permission implication step, which modifies the current permission
<span class="lineno">  763 </span>  -- set. This can include pattern-matches and/or assertion failures.
<span class="lineno">  764 </span>  TypedImplStmt :: !(AnnotPermImpl (TypedStmtSeq ext blocks tops rets) ps_in) -&gt;
<span class="lineno">  765 </span>                   TypedStmtSeq ext blocks tops rets ps_in
<span class="lineno">  766 </span>
<span class="lineno">  767 </span>  -- | Typed version of 'ConsStmt', which binds new variables for the return
<span class="lineno">  768 </span>  -- value(s) of each statement
<span class="lineno">  769 </span>  TypedConsStmt :: !ProgramLoc -&gt;
<span class="lineno">  770 </span>                   !(TypedStmt ext stmt_rets ps_in ps_next) -&gt;
<span class="lineno">  771 </span>                   !(RAssign Proxy stmt_rets) -&gt;
<span class="lineno">  772 </span>                   !(NamedMb stmt_rets (TypedStmtSeq ext blocks tops rets ps_next)) -&gt;
<span class="lineno">  773 </span>                   TypedStmtSeq ext blocks tops rets ps_in
<span class="lineno">  774 </span>
<span class="lineno">  775 </span>  -- | Typed version of 'TermStmt', which terminates the current block
<span class="lineno">  776 </span>  TypedTermStmt :: !ProgramLoc -&gt;
<span class="lineno">  777 </span>                   !(TypedTermStmt blocks tops rets ps_in) -&gt;
<span class="lineno">  778 </span>                   TypedStmtSeq ext blocks tops rets ps_in
<span class="lineno">  779 </span>
<span class="lineno">  780 </span>
<span class="lineno">  781 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall r ps. NuMatchingAny1 r =&gt; AnnotPermImpl r ps |])</span></span></span>
<span class="lineno">  782 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall tp ps_out ps_in.</span>
<span class="lineno">  783 </span><span class="spaces">                </span><span class="nottickedoff">TypedLLVMStmt tp ps_out ps_in |])</span></span></span>
<span class="lineno">  784 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ext stmt_rets ps_in ps_out exprExt. NuMatchingExtC ext exprExt =&gt;</span>
<span class="lineno">  785 </span><span class="spaces">                </span><span class="nottickedoff">TypedStmt ext stmt_rets ps_in ps_out |])</span></span></span>
<span class="lineno">  786 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall tops rets ps. TypedRet tops rets ps |])</span></span></span>
<span class="lineno">  787 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks tops rets ps_in.</span>
<span class="lineno">  788 </span><span class="spaces">                </span><span class="nottickedoff">TypedTermStmt blocks tops rets ps_in |])</span></span></span>
<span class="lineno">  789 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall ext blocks tops rets ps_in exprExt.</span>
<span class="lineno">  790 </span><span class="spaces">                </span><span class="nottickedoff">NuMatchingExtC ext exprExt =&gt; TypedStmtSeq ext blocks tops rets ps_in |])</span></span></span>
<span class="lineno">  791 </span>
<span class="lineno">  792 </span>
<span class="lineno">  793 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  794 </span>         Substable PermVarSubst (TypedReg tp) m where
<span class="lineno">  795 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| TypedReg x |]) = TypedReg &lt;$&gt; genSubst s x</span></span>
<span class="lineno">  796 </span>
<span class="lineno">  797 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  798 </span>         Substable PermVarSubst (RegWithVal tp) m where
<span class="lineno">  799 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno">  800 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| RegWithVal r e |] -&gt;</span>
<span class="lineno">  801 </span><span class="spaces">      </span><span class="nottickedoff">RegWithVal &lt;$&gt; genSubst s r &lt;*&gt; genSubst s e</span>
<span class="lineno">  802 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| RegNoVal r |] -&gt; RegNoVal &lt;$&gt; genSubst s r</span></span>
<span class="lineno">  803 </span>
<span class="lineno">  804 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  805 </span>         Substable1 PermVarSubst RegWithVal m where
<span class="lineno">  806 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno">  807 </span>
<span class="lineno">  808 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  809 </span>         Substable PermVarSubst (TypedRegs tp) m where
<span class="lineno">  810 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno">  811 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedRegsNil |] -&gt; return TypedRegsNil</span>
<span class="lineno">  812 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedRegsCons rs r |] -&gt;</span>
<span class="lineno">  813 </span><span class="spaces">      </span><span class="nottickedoff">TypedRegsCons &lt;$&gt; genSubst s rs &lt;*&gt; genSubst s r</span></span>
<span class="lineno">  814 </span>
<span class="lineno">  815 </span>instance (NuMatchingAny1 r, m ~ Identity,
<span class="lineno">  816 </span>          Substable1 PermVarSubst r m) =&gt;
<span class="lineno">  817 </span>         Substable PermVarSubst (AnnotPermImpl r ps) m where
<span class="lineno">  818 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| AnnotPermImpl err impl |]) =</span>
<span class="lineno">  819 </span><span class="spaces">    </span><span class="nottickedoff">AnnotPermImpl (mbLift err) &lt;$&gt; genSubst s impl</span></span>
<span class="lineno">  820 </span>
<span class="lineno">  821 </span>instance (PermCheckExtC ext exprExt, NuMatchingAny1 f,
<span class="lineno">  822 </span>          SubstVar PermVarSubst m, Substable1 PermVarSubst f m,
<span class="lineno">  823 </span>          Substable PermVarSubst (f BoolType) m) =&gt;
<span class="lineno">  824 </span>         Substable PermVarSubst (App ext f a) m where
<span class="lineno">  825 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_expr = case mbMatch mb_expr of</span>
<span class="lineno">  826 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ExtensionApp _ |] -&gt;</span>
<span class="lineno">  827 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;genSubst: unexpected ExtensionApp&quot;</span>
<span class="lineno">  828 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BaseIsEq tp e1 e2 |] -&gt;</span>
<span class="lineno">  829 </span><span class="spaces">      </span><span class="nottickedoff">BaseIsEq (mbLift tp) &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  830 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| EmptyApp |] -&gt; return EmptyApp</span>
<span class="lineno">  831 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolLit b |] -&gt; return $ BoolLit $ mbLift b</span>
<span class="lineno">  832 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Not e |] -&gt;</span>
<span class="lineno">  833 </span><span class="spaces">      </span><span class="nottickedoff">Not &lt;$&gt; genSubst1 s e</span>
<span class="lineno">  834 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| And e1 e2 |] -&gt;</span>
<span class="lineno">  835 </span><span class="spaces">      </span><span class="nottickedoff">And &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  836 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| Or e1 e2 |] -&gt;</span>
<span class="lineno">  837 </span><span class="spaces">      </span><span class="nottickedoff">Or &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  838 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolXor e1 e2 |] -&gt;</span>
<span class="lineno">  839 </span><span class="spaces">      </span><span class="nottickedoff">BoolXor &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  840 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatLit n |] -&gt;</span>
<span class="lineno">  841 </span><span class="spaces">      </span><span class="nottickedoff">return $ NatLit $ mbLift n</span>
<span class="lineno">  842 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatLt e1 e2 |] -&gt;</span>
<span class="lineno">  843 </span><span class="spaces">      </span><span class="nottickedoff">NatLt &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  844 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatLe e1 e2 |] -&gt;</span>
<span class="lineno">  845 </span><span class="spaces">      </span><span class="nottickedoff">NatLe &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  846 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatEq e1 e2 |] -&gt;</span>
<span class="lineno">  847 </span><span class="spaces">      </span><span class="nottickedoff">NatEq &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatAdd e1 e2 |] -&gt;</span>
<span class="lineno">  849 </span><span class="spaces">      </span><span class="nottickedoff">NatAdd &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  850 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatSub e1 e2 |] -&gt;</span>
<span class="lineno">  851 </span><span class="spaces">      </span><span class="nottickedoff">NatSub &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  852 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatMul e1 e2 |] -&gt;</span>
<span class="lineno">  853 </span><span class="spaces">      </span><span class="nottickedoff">NatMul &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  854 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatDiv e1 e2 |] -&gt;</span>
<span class="lineno">  855 </span><span class="spaces">      </span><span class="nottickedoff">NatDiv &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  856 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| NatMod e1 e2 |] -&gt;</span>
<span class="lineno">  857 </span><span class="spaces">      </span><span class="nottickedoff">NatMod &lt;$&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| HandleLit h |] -&gt;</span>
<span class="lineno">  859 </span><span class="spaces">      </span><span class="nottickedoff">return $ HandleLit $ mbLift h</span>
<span class="lineno">  860 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUndef w |] -&gt;</span>
<span class="lineno">  861 </span><span class="spaces">      </span><span class="nottickedoff">BVUndef &lt;$&gt; genSubst s w</span>
<span class="lineno">  862 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVLit w i |] -&gt;</span>
<span class="lineno">  863 </span><span class="spaces">      </span><span class="nottickedoff">BVLit &lt;$&gt; genSubst s w &lt;*&gt; return (mbLift i)</span>
<span class="lineno">  864 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVConcat w1 w2 e1 e2 |] -&gt;</span>
<span class="lineno">  865 </span><span class="spaces">      </span><span class="nottickedoff">BVConcat &lt;$&gt; genSubst s w1 &lt;*&gt; genSubst s w2 &lt;*&gt;</span>
<span class="lineno">  866 </span><span class="spaces">                   </span><span class="nottickedoff">genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  867 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVTrunc w1 w2 e |] -&gt;</span>
<span class="lineno">  868 </span><span class="spaces">      </span><span class="nottickedoff">BVTrunc &lt;$&gt; genSubst s w1 &lt;*&gt; genSubst s w2 &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  869 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVZext w1 w2 e |] -&gt;</span>
<span class="lineno">  870 </span><span class="spaces">      </span><span class="nottickedoff">BVZext &lt;$&gt; genSubst s w1 &lt;*&gt; genSubst s w2 &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  871 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSext w1 w2 e |] -&gt;</span>
<span class="lineno">  872 </span><span class="spaces">      </span><span class="nottickedoff">BVSext &lt;$&gt; genSubst s w1 &lt;*&gt; genSubst s w2 &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  873 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVNot w e |] -&gt;</span>
<span class="lineno">  874 </span><span class="spaces">      </span><span class="nottickedoff">BVNot &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  875 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVAnd w e1 e2 |] -&gt;</span>
<span class="lineno">  876 </span><span class="spaces">      </span><span class="nottickedoff">BVAnd &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  877 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVOr w e1 e2 |] -&gt;</span>
<span class="lineno">  878 </span><span class="spaces">      </span><span class="nottickedoff">BVOr &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  879 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVXor w e1 e2 |] -&gt;</span>
<span class="lineno">  880 </span><span class="spaces">      </span><span class="nottickedoff">BVXor &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  881 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVNeg w e |] -&gt;</span>
<span class="lineno">  882 </span><span class="spaces">      </span><span class="nottickedoff">BVNeg &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  883 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVAdd w e1 e2 |] -&gt;</span>
<span class="lineno">  884 </span><span class="spaces">      </span><span class="nottickedoff">BVAdd &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  885 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSub w e1 e2 |] -&gt;</span>
<span class="lineno">  886 </span><span class="spaces">      </span><span class="nottickedoff">BVSub &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVMul w e1 e2 |] -&gt;</span>
<span class="lineno">  888 </span><span class="spaces">      </span><span class="nottickedoff">BVMul &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  889 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUdiv w e1 e2 |] -&gt;</span>
<span class="lineno">  890 </span><span class="spaces">      </span><span class="nottickedoff">BVUdiv &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  891 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSdiv w e1 e2 |] -&gt;</span>
<span class="lineno">  892 </span><span class="spaces">      </span><span class="nottickedoff">BVSdiv &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  893 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUrem w e1 e2 |] -&gt;</span>
<span class="lineno">  894 </span><span class="spaces">      </span><span class="nottickedoff">BVUrem &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  895 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSrem w e1 e2 |] -&gt;</span>
<span class="lineno">  896 </span><span class="spaces">      </span><span class="nottickedoff">BVSrem &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  897 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUle w e1 e2 |] -&gt;</span>
<span class="lineno">  898 </span><span class="spaces">      </span><span class="nottickedoff">BVUle &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  899 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVUlt w e1 e2 |] -&gt;</span>
<span class="lineno">  900 </span><span class="spaces">      </span><span class="nottickedoff">BVUlt &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  901 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSle w e1 e2 |] -&gt;</span>
<span class="lineno">  902 </span><span class="spaces">      </span><span class="nottickedoff">BVSle &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  903 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSlt w e1 e2 |] -&gt;</span>
<span class="lineno">  904 </span><span class="spaces">      </span><span class="nottickedoff">BVSlt &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  905 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVCarry w e1 e2 |] -&gt;</span>
<span class="lineno">  906 </span><span class="spaces">      </span><span class="nottickedoff">BVCarry &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  907 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSCarry w e1 e2 |] -&gt;</span>
<span class="lineno">  908 </span><span class="spaces">      </span><span class="nottickedoff">BVSCarry &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  909 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVSBorrow w e1 e2 |] -&gt;</span>
<span class="lineno">  910 </span><span class="spaces">      </span><span class="nottickedoff">BVSBorrow &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  911 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVShl w e1 e2 |] -&gt;</span>
<span class="lineno">  912 </span><span class="spaces">      </span><span class="nottickedoff">BVShl &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  913 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVLshr w e1 e2 |] -&gt;</span>
<span class="lineno">  914 </span><span class="spaces">      </span><span class="nottickedoff">BVLshr &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  915 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVAshr w e1 e2 |] -&gt;</span>
<span class="lineno">  916 </span><span class="spaces">      </span><span class="nottickedoff">BVAshr &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e1 &lt;*&gt; genSubst1 s e2</span>
<span class="lineno">  917 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BoolToBV w e |] -&gt;</span>
<span class="lineno">  918 </span><span class="spaces">      </span><span class="nottickedoff">BoolToBV &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  919 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| BVNonzero w e |] -&gt;</span>
<span class="lineno">  920 </span><span class="spaces">      </span><span class="nottickedoff">BVNonzero &lt;$&gt; genSubst s w &lt;*&gt; genSubst1 s e</span>
<span class="lineno">  921 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| StringLit str_lit |] -&gt;</span>
<span class="lineno">  922 </span><span class="spaces">      </span><span class="nottickedoff">return $ StringLit $ mbLift str_lit</span>
<span class="lineno">  923 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| MkStruct tps flds |] -&gt;</span>
<span class="lineno">  924 </span><span class="spaces">      </span><span class="nottickedoff">MkStruct (mbLift tps) &lt;$&gt; genSubst s flds</span>
<span class="lineno">  925 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| GetStruct str ix tp |] -&gt;</span>
<span class="lineno">  926 </span><span class="spaces">      </span><span class="nottickedoff">GetStruct &lt;$&gt; genSubst1 s str &lt;*&gt; return (mbLift ix) &lt;*&gt; return (mbLift tp)</span>
<span class="lineno">  927 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| SetStruct tps str ix x |] -&gt;</span>
<span class="lineno">  928 </span><span class="spaces">      </span><span class="nottickedoff">SetStruct (mbLift tps) &lt;$&gt; genSubst1 s str &lt;*&gt; return (mbLift ix)</span>
<span class="lineno">  929 </span><span class="spaces">                             </span><span class="nottickedoff">&lt;*&gt; genSubst1 s x</span>
<span class="lineno">  930 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno">  931 </span><span class="spaces">      </span><span class="nottickedoff">error (&quot;genSubst: unhandled Crucible expression construct: &quot;</span>
<span class="lineno">  932 </span><span class="spaces">             </span><span class="nottickedoff">++ mbLift (fmap (show . ppApp (const (pretty &quot;_&quot;))) mb_expr))</span></span>
<span class="lineno">  933 </span>
<span class="lineno">  934 </span>
<span class="lineno">  935 </span>instance (PermCheckExtC ext exprExt, SubstVar PermVarSubst m) =&gt;
<span class="lineno">  936 </span>         Substable PermVarSubst (TypedExpr ext tp) m where
<span class="lineno">  937 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| TypedExpr app maybe_val |]) =</span>
<span class="lineno">  938 </span><span class="spaces">    </span><span class="nottickedoff">TypedExpr &lt;$&gt; genSubst s app &lt;*&gt; genSubst s maybe_val</span></span>
<span class="lineno">  939 </span>
<span class="lineno">  940 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  941 </span>         Substable PermVarSubst (TypedLLVMStmt tp ps_out ps_in) m where
<span class="lineno">  942 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno">  943 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| ConstructLLVMWord r |] -&gt; ConstructLLVMWord &lt;$&gt; genSubst s r</span>
<span class="lineno">  944 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| AssertLLVMWord r e |] -&gt;</span>
<span class="lineno">  945 </span><span class="spaces">      </span><span class="nottickedoff">AssertLLVMWord &lt;$&gt; genSubst s r &lt;*&gt; genSubst s e</span>
<span class="lineno">  946 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| AssertLLVMPtr r |] -&gt;</span>
<span class="lineno">  947 </span><span class="spaces">      </span><span class="nottickedoff">AssertLLVMPtr &lt;$&gt; genSubst s r</span>
<span class="lineno">  948 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| DestructLLVMWord r e |] -&gt;</span>
<span class="lineno">  949 </span><span class="spaces">      </span><span class="nottickedoff">DestructLLVMWord &lt;$&gt; genSubst s r &lt;*&gt; genSubst s e</span>
<span class="lineno">  950 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| OffsetLLVMValue r off |] -&gt;</span>
<span class="lineno">  951 </span><span class="spaces">      </span><span class="nottickedoff">OffsetLLVMValue &lt;$&gt; genSubst s r &lt;*&gt; genSubst s off</span>
<span class="lineno">  952 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMLoad r fp ps ps_l |] -&gt;</span>
<span class="lineno">  953 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMLoad &lt;$&gt; genSubst s r &lt;*&gt; genSubst s fp &lt;*&gt; genSubst s ps &lt;*&gt;</span>
<span class="lineno">  954 </span><span class="spaces">                        </span><span class="nottickedoff">genSubst s ps_l</span>
<span class="lineno">  955 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMStore r fp e ps cur_ps |] -&gt;</span>
<span class="lineno">  956 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMStore &lt;$&gt; genSubst s r &lt;*&gt; genSubst s fp &lt;*&gt; genSubst s e &lt;*&gt;</span>
<span class="lineno">  957 </span><span class="spaces">                         </span><span class="nottickedoff">genSubst s ps &lt;*&gt; genSubst s cur_ps</span>
<span class="lineno">  958 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMAlloca r fperms i |] -&gt;</span>
<span class="lineno">  959 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMAlloca &lt;$&gt; genSubst s r &lt;*&gt; genSubst s fperms &lt;*&gt;</span>
<span class="lineno">  960 </span><span class="spaces">                          </span><span class="nottickedoff">return (mbLift i)</span>
<span class="lineno">  961 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMCreateFrame |] -&gt; return TypedLLVMCreateFrame</span>
<span class="lineno">  962 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMDeleteFrame r fperms perms |] -&gt;</span>
<span class="lineno">  963 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMDeleteFrame &lt;$&gt; genSubst s r &lt;*&gt; genSubst s fperms &lt;*&gt;</span>
<span class="lineno">  964 </span><span class="spaces">                               </span><span class="nottickedoff">genSubst s perms</span>
<span class="lineno">  965 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMLoadHandle r tp p |] -&gt;</span>
<span class="lineno">  966 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMLoadHandle &lt;$&gt; genSubst s r &lt;*&gt; return (mbLift tp) &lt;*&gt; genSubst s p</span>
<span class="lineno">  967 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMResolveGlobal gsym p |] -&gt;</span>
<span class="lineno">  968 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMResolveGlobal (mbLift gsym) &lt;$&gt; genSubst s p</span>
<span class="lineno">  969 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMIte w r1 r2 r3 |] -&gt;</span>
<span class="lineno">  970 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMIte (mbLift w) &lt;$&gt; genSubst s r1 &lt;*&gt; genSubst s r2 &lt;*&gt; genSubst s r3</span></span>
<span class="lineno">  971 </span>
<span class="lineno">  972 </span>instance (PermCheckExtC ext exprExt, SubstVar PermVarSubst m) =&gt;
<span class="lineno">  973 </span>         Substable PermVarSubst (TypedStmt ext rets ps_in ps_out) m where
<span class="lineno">  974 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno">  975 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedSetReg tp expr |] -&gt;</span>
<span class="lineno">  976 </span><span class="spaces">      </span><span class="nottickedoff">TypedSetReg (mbLift tp) &lt;$&gt; genSubst s expr</span>
<span class="lineno">  977 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedSetRegPermExpr tp expr |] -&gt;</span>
<span class="lineno">  978 </span><span class="spaces">      </span><span class="nottickedoff">TypedSetRegPermExpr (mbLift tp) &lt;$&gt; genSubst s expr</span>
<span class="lineno">  979 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedCall f fun_perm ghosts gexprs args |] -&gt;</span>
<span class="lineno">  980 </span><span class="spaces">      </span><span class="nottickedoff">TypedCall &lt;$&gt; genSubst s f &lt;*&gt; genSubst s fun_perm &lt;*&gt;</span>
<span class="lineno">  981 </span><span class="spaces">                    </span><span class="nottickedoff">genSubst s ghosts &lt;*&gt; genSubst s gexprs &lt;*&gt; genSubst s args</span>
<span class="lineno">  982 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedAssert r1 r2 |] -&gt;</span>
<span class="lineno">  983 </span><span class="spaces">      </span><span class="nottickedoff">TypedAssert &lt;$&gt; genSubst s r1 &lt;*&gt; genSubst s r2</span>
<span class="lineno">  984 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedLLVMStmt llvmStmt |] -&gt;</span>
<span class="lineno">  985 </span><span class="spaces">      </span><span class="nottickedoff">TypedLLVMStmt &lt;$&gt; genSubst s llvmStmt</span></span>
<span class="lineno">  986 </span>
<span class="lineno">  987 </span>
<span class="lineno">  988 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  989 </span>         Substable PermVarSubst (TypedRet tops rets ps) m where
<span class="lineno">  990 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| TypedRet e rets ret_vars mb_perms |]) =</span>
<span class="lineno">  991 </span><span class="spaces">    </span><span class="nottickedoff">give (cruCtxProxies $ mbLift rets)</span>
<span class="lineno">  992 </span><span class="spaces">    </span><span class="nottickedoff">(TypedRet (mbLift e) (mbLift rets) &lt;$&gt; genSubst s ret_vars</span>
<span class="lineno">  993 </span><span class="spaces">     </span><span class="nottickedoff">&lt;*&gt; genSubst s mb_perms)</span></span>
<span class="lineno">  994 </span>
<span class="lineno">  995 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno">  996 </span>         Substable1 PermVarSubst (TypedRet tops rets) m where
<span class="lineno">  997 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno">  998 </span>
<span class="lineno">  999 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 1000 </span>         Substable PermVarSubst (TypedJumpTarget blocks tops ps) m where
<span class="lineno"> 1001 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt; [nuMP| TypedJumpTarget siteID prx ctx perms |]) =</span>
<span class="lineno"> 1002 </span><span class="spaces">    </span><span class="nottickedoff">TypedJumpTarget (mbLift siteID) (mbLift prx) (mbLift ctx) &lt;$&gt;</span>
<span class="lineno"> 1003 </span><span class="spaces">    </span><span class="nottickedoff">genSubst s perms</span></span>
<span class="lineno"> 1004 </span>
<span class="lineno"> 1005 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 1006 </span>         Substable1 PermVarSubst (TypedJumpTarget blocks tops) m where
<span class="lineno"> 1007 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 1008 </span>
<span class="lineno"> 1009 </span>instance m ~ Identity =&gt;
<span class="lineno"> 1010 </span>         Substable PermVarSubst (TypedTermStmt blocks tops rets ps_in) m where
<span class="lineno"> 1011 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 1012 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedJump impl_tgt |] -&gt; TypedJump &lt;$&gt; genSubst s impl_tgt</span>
<span class="lineno"> 1013 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedBr reg impl_tgt1 impl_tgt2 |] -&gt;</span>
<span class="lineno"> 1014 </span><span class="spaces">      </span><span class="nottickedoff">TypedBr &lt;$&gt; genSubst s reg &lt;*&gt; genSubst s impl_tgt1 &lt;*&gt;</span>
<span class="lineno"> 1015 </span><span class="spaces">                  </span><span class="nottickedoff">genSubst s impl_tgt2</span>
<span class="lineno"> 1016 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedReturn impl_ret |] -&gt;</span>
<span class="lineno"> 1017 </span><span class="spaces">      </span><span class="nottickedoff">TypedReturn &lt;$&gt; genSubst s impl_ret</span>
<span class="lineno"> 1018 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedErrorStmt str r |] -&gt;</span>
<span class="lineno"> 1019 </span><span class="spaces">      </span><span class="nottickedoff">TypedErrorStmt (mbLift str) &lt;$&gt; genSubst s r</span></span>
<span class="lineno"> 1020 </span>
<span class="lineno"> 1021 </span>instance (PermCheckExtC ext exprExt, m ~ Identity) =&gt;
<span class="lineno"> 1022 </span>         Substable PermVarSubst (TypedStmtSeq ext blocks tops rets ps_in) m where
<span class="lineno"> 1023 </span>  <span class="decl"><span class="nottickedoff">genSubst s mb_x = case mbMatch mb_x of</span>
<span class="lineno"> 1024 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedImplStmt impl_seq |] -&gt;</span>
<span class="lineno"> 1025 </span><span class="spaces">      </span><span class="nottickedoff">TypedImplStmt &lt;$&gt; genSubst s impl_seq</span>
<span class="lineno"> 1026 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedConsStmt loc stmt pxys mb_seq |] -&gt;</span>
<span class="lineno"> 1027 </span><span class="spaces">      </span><span class="nottickedoff">TypedConsStmt (mbLift loc) &lt;$&gt; genSubst s stmt &lt;*&gt; pure (mbLift pxys)</span>
<span class="lineno"> 1028 </span><span class="spaces">      </span><span class="nottickedoff">&lt;*&gt; give (mbLift pxys) (genSubst s mb_seq)</span>
<span class="lineno"> 1029 </span><span class="spaces">    </span><span class="nottickedoff">[nuMP| TypedTermStmt loc term_stmt |] -&gt;</span>
<span class="lineno"> 1030 </span><span class="spaces">      </span><span class="nottickedoff">TypedTermStmt (mbLift loc) &lt;$&gt; genSubst s term_stmt</span></span>
<span class="lineno"> 1031 </span>
<span class="lineno"> 1032 </span>
<span class="lineno"> 1033 </span>instance (PermCheckExtC ext exprExt, m ~ Identity) =&gt;
<span class="lineno"> 1034 </span>         Substable1 PermVarSubst (TypedStmtSeq ext blocks tops rets) m where
<span class="lineno"> 1035 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 1036 </span>
<span class="lineno"> 1037 </span>
<span class="lineno"> 1038 </span>----------------------------------------------------------------------
<span class="lineno"> 1039 </span>-- * Typed Control-Flow Graphs
<span class="lineno"> 1040 </span>----------------------------------------------------------------------
<span class="lineno"> 1041 </span>
<span class="lineno"> 1042 </span>-- FIXME: remove in-degree stuff
<span class="lineno"> 1043 </span>
<span class="lineno"> 1044 </span>-- | This type characterizes the number and sort of jumps to a 'TypedEntry'
<span class="lineno"> 1045 </span>data TypedEntryInDegree
<span class="lineno"> 1046 </span>     -- | There are no jumps to the entrypoint
<span class="lineno"> 1047 </span>  = EntryInDegree_None
<span class="lineno"> 1048 </span>    -- | There is one jump to the entrypoint
<span class="lineno"> 1049 </span>  | EntryInDegree_One
<span class="lineno"> 1050 </span>    -- | There is more than one jump to the entrypoint
<span class="lineno"> 1051 </span>  | EntryInDegree_Many
<span class="lineno"> 1052 </span>    -- | The entrypoint is the head of a loop, so has more than one jump to it,
<span class="lineno"> 1053 </span>    -- one of which is a back edge
<span class="lineno"> 1054 </span>  | EntryInDegree_Loop
<span class="lineno"> 1055 </span>
<span class="lineno"> 1056 </span>-- | \&quot;Add\&quot; two in-degrees
<span class="lineno"> 1057 </span>addInDegrees :: TypedEntryInDegree -&gt; TypedEntryInDegree -&gt; TypedEntryInDegree
<span class="lineno"> 1058 </span><span class="decl"><span class="nottickedoff">addInDegrees EntryInDegree_Loop _ = EntryInDegree_Loop</span>
<span class="lineno"> 1059 </span><span class="spaces"></span><span class="nottickedoff">addInDegrees _ EntryInDegree_Loop = EntryInDegree_Loop</span>
<span class="lineno"> 1060 </span><span class="spaces"></span><span class="nottickedoff">addInDegrees EntryInDegree_None in_deg = in_deg</span>
<span class="lineno"> 1061 </span><span class="spaces"></span><span class="nottickedoff">addInDegrees in_deg EntryInDegree_None = in_deg</span>
<span class="lineno"> 1062 </span><span class="spaces"></span><span class="nottickedoff">addInDegrees _ _ =</span>
<span class="lineno"> 1063 </span><span class="spaces">  </span><span class="nottickedoff">-- The last case is adding 1 or many + 1 or many = many</span>
<span class="lineno"> 1064 </span><span class="spaces">  </span><span class="nottickedoff">EntryInDegree_Many</span></span>
<span class="lineno"> 1065 </span>
<span class="lineno"> 1066 </span>-- | Add one to an in-degree
<span class="lineno"> 1067 </span>incrInDegree :: TypedEntryInDegree -&gt; TypedEntryInDegree
<span class="lineno"> 1068 </span><span class="decl"><span class="nottickedoff">incrInDegree = addInDegrees EntryInDegree_One</span></span>
<span class="lineno"> 1069 </span>
<span class="lineno"> 1070 </span>-- | Test if an in-degree is at least many
<span class="lineno"> 1071 </span>inDegreeIsMulti :: TypedEntryInDegree -&gt; Bool
<span class="lineno"> 1072 </span><span class="decl"><span class="nottickedoff">inDegreeIsMulti EntryInDegree_None = False</span>
<span class="lineno"> 1073 </span><span class="spaces"></span><span class="nottickedoff">inDegreeIsMulti EntryInDegree_One = False</span>
<span class="lineno"> 1074 </span><span class="spaces"></span><span class="nottickedoff">inDegreeIsMulti EntryInDegree_Many = True</span>
<span class="lineno"> 1075 </span><span class="spaces"></span><span class="nottickedoff">inDegreeIsMulti EntryInDegree_Loop = True</span></span>
<span class="lineno"> 1076 </span>
<span class="lineno"> 1077 </span>-- | Type-level data-kind to indicate a phase of Heapster, which could be
<span class="lineno"> 1078 </span>-- type-checking or translation
<span class="lineno"> 1079 </span>data HeapsterPhase = TCPhase | TransPhase
<span class="lineno"> 1080 </span>
<span class="lineno"> 1081 </span>type TCPhase = 'TCPhase
<span class="lineno"> 1082 </span>type TransPhase = 'TransPhase
<span class="lineno"> 1083 </span>
<span class="lineno"> 1084 </span>-- | A piece of data of type @a@ needed in the translation phase but that could
<span class="lineno"> 1085 </span>-- still be being computed in the type-checking phase
<span class="lineno"> 1086 </span>type family TransData phase a where
<span class="lineno"> 1087 </span>  TransData TCPhase a = Maybe a
<span class="lineno"> 1088 </span>  TransData TransPhase a = a
<span class="lineno"> 1089 </span>
<span class="lineno"> 1090 </span>-- | The body of an implication in a call site, which ensures that the
<span class="lineno"> 1091 </span>-- permissions are as expected and gives expressions for the ghost variables. It
<span class="lineno"> 1092 </span>-- also includes a 'TypedEntryID' for the callee, to make translation easier.
<span class="lineno"> 1093 </span>data CallSiteImplRet blocks tops args ghosts ps_out =
<span class="lineno"> 1094 </span>  CallSiteImplRet (TypedEntryID blocks args) (CruCtx ghosts)
<span class="lineno"> 1095 </span>  ((tops :++: args) :++: ghosts :~: ps_out)
<span class="lineno"> 1096 </span>  (RAssign ExprVar tops) (RAssign ExprVar args) (RAssign ExprVar ghosts)
<span class="lineno"> 1097 </span>
<span class="lineno"> 1098 </span>$<span class="nottickedoff"><span class="decl"><span class="nottickedoff">(mkNuMatching [t| forall blocks tops args ghosts ps_out.</span>
<span class="lineno"> 1099 </span><span class="spaces">                </span><span class="nottickedoff">CallSiteImplRet blocks tops args ghosts ps_out |])</span></span></span>
<span class="lineno"> 1100 </span>
<span class="lineno"> 1101 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 1102 </span>         Substable PermVarSubst (CallSiteImplRet
<span class="lineno"> 1103 </span>                                 blocks tops args ghosts ps) m where
<span class="lineno"> 1104 </span>  <span class="decl"><span class="nottickedoff">genSubst s (mbMatch -&gt;</span>
<span class="lineno"> 1105 </span><span class="spaces">              </span><span class="nottickedoff">[nuMP| CallSiteImplRet entryID ghosts Refl tvars avars gvars |]) =</span>
<span class="lineno"> 1106 </span><span class="spaces">    </span><span class="nottickedoff">CallSiteImplRet (mbLift entryID) (mbLift ghosts) Refl &lt;$&gt;</span>
<span class="lineno"> 1107 </span><span class="spaces">    </span><span class="nottickedoff">genSubst s tvars &lt;*&gt; genSubst s avars &lt;*&gt; genSubst s gvars</span></span>
<span class="lineno"> 1108 </span>
<span class="lineno"> 1109 </span>instance SubstVar PermVarSubst m =&gt;
<span class="lineno"> 1110 </span>         Substable1 PermVarSubst (CallSiteImplRet
<span class="lineno"> 1111 </span>                                  blocks tops args ghosts) m where
<span class="lineno"> 1112 </span>  <span class="decl"><span class="nottickedoff">genSubst1 = genSubst</span></span>
<span class="lineno"> 1113 </span>
<span class="lineno"> 1114 </span>
<span class="lineno"> 1115 </span>-- | An implication used in a call site, which binds the input variables in an
<span class="lineno"> 1116 </span>-- implication of the output variables
<span class="lineno"> 1117 </span>newtype CallSiteImpl blocks ps_in tops args ghosts =
<span class="lineno"> 1118 </span>  CallSiteImpl (Mb ps_in (AnnotPermImpl
<span class="lineno"> 1119 </span>                          (CallSiteImplRet blocks tops args ghosts) ps_in))
<span class="lineno"> 1120 </span>
<span class="lineno"> 1121 </span>-- | The identity implication
<span class="lineno"> 1122 </span>idCallSiteImpl :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1123 </span>                  CruCtx tops -&gt; CruCtx args -&gt; CruCtx vars -&gt;
<span class="lineno"> 1124 </span>                  CallSiteImpl blocks ((tops :++: args) :++: vars) tops args vars
<span class="lineno"> 1125 </span><span class="decl"><span class="nottickedoff">idCallSiteImpl entryID tops args vars =</span>
<span class="lineno"> 1126 </span><span class="spaces">  </span><span class="nottickedoff">let tops_args_prxs = cruCtxProxies (appendCruCtx tops args)</span>
<span class="lineno"> 1127 </span><span class="spaces">      </span><span class="nottickedoff">vars_prxs = cruCtxProxies vars in</span>
<span class="lineno"> 1128 </span><span class="spaces">  </span><span class="nottickedoff">CallSiteImpl $ mbCombine vars_prxs $ nuMulti tops_args_prxs $ \tops_args_ns -&gt;</span>
<span class="lineno"> 1129 </span><span class="spaces">  </span><span class="nottickedoff">let (tops_ns, args_ns) = RL.split tops (cruCtxProxies args) tops_args_ns in</span>
<span class="lineno"> 1130 </span><span class="spaces">  </span><span class="nottickedoff">nuMulti vars_prxs $ \vars_ns -&gt;</span>
<span class="lineno"> 1131 </span><span class="spaces">  </span><span class="nottickedoff">AnnotPermImpl &quot;&quot; $ PermImpl_Done $</span>
<span class="lineno"> 1132 </span><span class="spaces">  </span><span class="nottickedoff">CallSiteImplRet entryID vars Refl tops_ns args_ns vars_ns</span></span>
<span class="lineno"> 1133 </span>
<span class="lineno"> 1134 </span>-- | A jump / branch to a particular entrypoint
<span class="lineno"> 1135 </span>data TypedCallSite phase blocks tops args ghosts vars =
<span class="lineno"> 1136 </span>  TypedCallSite
<span class="lineno"> 1137 </span>  {
<span class="lineno"> 1138 </span>    -- | The ID of this call site
<span class="lineno"> 1139 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedCallSiteID</span></span></span> :: TypedCallSiteID blocks args vars,
<span class="lineno"> 1140 </span>    -- | The permissions held at the call site
<span class="lineno"> 1141 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedCallSitePerms</span></span></span> :: MbValuePerms ((tops :++: args) :++: vars),
<span class="lineno"> 1142 </span>    -- | An implication from the call site perms to the input perms of the
<span class="lineno"> 1143 </span>    -- entrypoint we are jumping to
<span class="lineno"> 1144 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedCallSiteImpl</span></span></span> :: TransData phase (CallSiteImpl
<span class="lineno"> 1145 </span>                                          blocks
<span class="lineno"> 1146 </span>                                          ((tops :++: args) :++: vars)
<span class="lineno"> 1147 </span>                                          tops args ghosts)
<span class="lineno"> 1148 </span>  }
<span class="lineno"> 1149 </span>
<span class="lineno"> 1150 </span>-- | Transition a 'TypedEntry' from type-checking to translation phase if its
<span class="lineno"> 1151 </span>-- implication has been proved
<span class="lineno"> 1152 </span>completeTypedCallSite ::
<span class="lineno"> 1153 </span>  TypedCallSite TCPhase blocks tops args ghosts vars -&gt;
<span class="lineno"> 1154 </span>  Maybe (TypedCallSite TransPhase blocks tops args ghosts vars)
<span class="lineno"> 1155 </span><span class="decl"><span class="nottickedoff">completeTypedCallSite call_site</span>
<span class="lineno"> 1156 </span><span class="spaces">  </span><span class="nottickedoff">| Just impl &lt;- typedCallSiteImpl call_site</span>
<span class="lineno"> 1157 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ call_site { typedCallSiteImpl = impl }</span>
<span class="lineno"> 1158 </span><span class="spaces"></span><span class="nottickedoff">completeTypedCallSite _ = Nothing</span></span>
<span class="lineno"> 1159 </span>
<span class="lineno"> 1160 </span>-- | Build a 'TypedCallSite' with no implication
<span class="lineno"> 1161 </span>emptyTypedCallSite :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1162 </span>                      MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 1163 </span>                      TypedCallSite TCPhase blocks tops args ghosts vars
<span class="lineno"> 1164 </span><span class="decl"><span class="nottickedoff">emptyTypedCallSite siteID perms = TypedCallSite siteID perms Nothing</span></span>
<span class="lineno"> 1165 </span>
<span class="lineno"> 1166 </span>-- | Build a 'TypedCallSite' that uses the identity implication, meaning its
<span class="lineno"> 1167 </span>-- @vars@ will equal the @ghosts@ of its entrypoint
<span class="lineno"> 1168 </span>idTypedCallSite :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1169 </span>                   CruCtx tops -&gt; CruCtx args -&gt;
<span class="lineno"> 1170 </span>                   MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 1171 </span>                   TypedCallSite TCPhase blocks tops args vars vars
<span class="lineno"> 1172 </span><span class="decl"><span class="nottickedoff">idTypedCallSite siteID tops args perms =</span>
<span class="lineno"> 1173 </span><span class="spaces">  </span><span class="nottickedoff">TypedCallSite siteID perms $ Just $</span>
<span class="lineno"> 1174 </span><span class="spaces">  </span><span class="nottickedoff">idCallSiteImpl (callSiteDest siteID) tops args (callSiteVars siteID)</span></span>
<span class="lineno"> 1175 </span>
<span class="lineno"> 1176 </span>-- | Test if the implication of a call site fails or is not present
<span class="lineno"> 1177 </span>typedCallSiteImplFails :: TypedCallSite TCPhase blocks tops args ghosts vars -&gt;
<span class="lineno"> 1178 </span>                          Bool
<span class="lineno"> 1179 </span><span class="decl"><span class="nottickedoff">typedCallSiteImplFails (TypedCallSite { typedCallSiteImpl =</span>
<span class="lineno"> 1180 </span><span class="spaces">                                          </span><span class="nottickedoff">Just (CallSiteImpl mb_annot_impl) }) =</span>
<span class="lineno"> 1181 </span><span class="spaces">  </span><span class="nottickedoff">mbLift $ fmap (\(AnnotPermImpl _ impl) -&gt; permImplFails impl) mb_annot_impl</span>
<span class="lineno"> 1182 </span><span class="spaces"></span><span class="nottickedoff">typedCallSiteImplFails _ = True</span></span>
<span class="lineno"> 1183 </span>
<span class="lineno"> 1184 </span>-- | Extract the caller permissions of a call site as an 'ArgVarPerms'
<span class="lineno"> 1185 </span>typedCallSiteArgVarPerms :: TypedCallSite phase blocks tops args ghsots vars -&gt;
<span class="lineno"> 1186 </span>                            ArgVarPerms (tops :++: args) vars
<span class="lineno"> 1187 </span><span class="decl"><span class="nottickedoff">typedCallSiteArgVarPerms (TypedCallSite {..}) =</span>
<span class="lineno"> 1188 </span><span class="spaces">  </span><span class="nottickedoff">ArgVarPerms (callSiteVars typedCallSiteID) typedCallSitePerms</span></span>
<span class="lineno"> 1189 </span>
<span class="lineno"> 1190 </span>-- | A single, typed entrypoint to a Crucible block. Note that our blocks
<span class="lineno"> 1191 </span>-- implicitly take extra \&quot;ghost\&quot; arguments, that are needed to express the
<span class="lineno"> 1192 </span>-- input and output permissions. The first of these ghost arguments are the
<span class="lineno"> 1193 </span>-- top-level inputs to the entire function.
<span class="lineno"> 1194 </span>data TypedEntry phase ext blocks tops rets args ghosts =
<span class="lineno"> 1195 </span>  TypedEntry
<span class="lineno"> 1196 </span>  {
<span class="lineno"> 1197 </span>    -- | The identifier for this particular entrypoing
<span class="lineno"> 1198 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryID</span></span></span> :: !(TypedEntryID blocks args),
<span class="lineno"> 1199 </span>    -- | The top-level arguments to the entire function
<span class="lineno"> 1200 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryTops</span></span></span> :: !(CruCtx tops),
<span class="lineno"> 1201 </span>    -- | The real arguments to this block
<span class="lineno"> 1202 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryArgs</span></span></span> :: !(CruCtx args),
<span class="lineno"> 1203 </span>    -- | The return values (including ghosts) from the entire function
<span class="lineno"> 1204 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryRets</span></span></span> :: !(CruCtx rets),
<span class="lineno"> 1205 </span>    -- | The call sites that jump to this particular entrypoint
<span class="lineno"> 1206 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryCallers</span></span></span> :: ![Some (TypedCallSite phase blocks tops args ghosts)],
<span class="lineno"> 1207 </span>    -- | The ghost variables for this entrypoint
<span class="lineno"> 1208 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryGhosts</span></span></span> :: !(CruCtx ghosts),
<span class="lineno"> 1209 </span>    -- | The input permissions for this entrypoint
<span class="lineno"> 1210 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryPermsIn</span></span></span> :: !(MbValuePerms ((tops :++: args) :++: ghosts)),
<span class="lineno"> 1211 </span>    -- | The output permissions for the function (cached locally)
<span class="lineno"> 1212 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryPermsOut</span></span></span> :: !(MbValuePerms (tops :++: rets)),
<span class="lineno"> 1213 </span>    -- | The type-checked body of the entrypoint
<span class="lineno"> 1214 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedEntryBody</span></span></span> :: !(TransData phase
<span class="lineno"> 1215 </span>                        (NamedMb ((tops :++: args) :++: ghosts)
<span class="lineno"> 1216 </span>                         (TypedStmtSeq ext blocks tops rets
<span class="lineno"> 1217 </span>                          ((tops :++: args) :++: ghosts))))
<span class="lineno"> 1218 </span>  }
<span class="lineno"> 1219 </span>
<span class="lineno"> 1220 </span>
<span class="lineno"> 1221 </span>-- | Test if an entrypoint has in-degree greater than 1
<span class="lineno"> 1222 </span>typedEntryHasMultiInDegree :: TypedEntry phase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1223 </span>                              Bool
<span class="lineno"> 1224 </span><span class="decl"><span class="nottickedoff">typedEntryHasMultiInDegree entry = length (typedEntryCallers entry) &gt; 1</span></span>
<span class="lineno"> 1225 </span>
<span class="lineno"> 1226 </span>-- | Get the types of all the inputs of an entrypoint
<span class="lineno"> 1227 </span>typedEntryAllArgs :: TypedEntry phase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1228 </span>                     CruCtx ((tops :++: args) :++: ghosts)
<span class="lineno"> 1229 </span><span class="decl"><span class="nottickedoff">typedEntryAllArgs (TypedEntry {..}) =</span>
<span class="lineno"> 1230 </span><span class="spaces">  </span><span class="nottickedoff">appendCruCtx (appendCruCtx typedEntryTops typedEntryArgs) typedEntryGhosts</span></span>
<span class="lineno"> 1231 </span>
<span class="lineno"> 1232 </span>-- | Transition a 'TypedEntry' from type-checking to translation phase if its
<span class="lineno"> 1233 </span>-- body is present and all call site implications have been proved
<span class="lineno"> 1234 </span>completeTypedEntry ::
<span class="lineno"> 1235 </span>  TypedEntry TCPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1236 </span>  Maybe (TypedEntry TransPhase ext blocks tops rets args ghosts)
<span class="lineno"> 1237 </span><span class="decl"><span class="nottickedoff">completeTypedEntry (TypedEntry { .. })</span>
<span class="lineno"> 1238 </span><span class="spaces">  </span><span class="nottickedoff">| Just body &lt;- typedEntryBody</span>
<span class="lineno"> 1239 </span><span class="spaces">  </span><span class="nottickedoff">, Just callers &lt;- mapM (traverseF completeTypedCallSite) typedEntryCallers</span>
<span class="lineno"> 1240 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ TypedEntry { typedEntryBody = body, typedEntryCallers = callers, .. }</span>
<span class="lineno"> 1241 </span><span class="spaces"></span><span class="nottickedoff">completeTypedEntry _ = Nothing</span></span>
<span class="lineno"> 1242 </span>
<span class="lineno"> 1243 </span>-- | Build an entrypoint from a call site, using that call site's permissions as
<span class="lineno"> 1244 </span>-- the entyrpoint input permissions
<span class="lineno"> 1245 </span>singleCallSiteEntry :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1246 </span>                       CruCtx tops -&gt; CruCtx args -&gt; CruCtx rets -&gt;
<span class="lineno"> 1247 </span>                       MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 1248 </span>                       MbValuePerms (tops :++: rets) -&gt;
<span class="lineno"> 1249 </span>                       TypedEntry TCPhase ext blocks tops rets args vars
<span class="lineno"> 1250 </span><span class="decl"><span class="nottickedoff">singleCallSiteEntry siteID tops args rets perms_in perms_out =</span>
<span class="lineno"> 1251 </span><span class="spaces">  </span><span class="nottickedoff">TypedEntry</span>
<span class="lineno"> 1252 </span><span class="spaces">  </span><span class="nottickedoff">{</span>
<span class="lineno"> 1253 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryID = callSiteDest siteID, typedEntryTops = tops,</span>
<span class="lineno"> 1254 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryArgs = args, typedEntryRets = rets,</span>
<span class="lineno"> 1255 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryCallers = [Some $ idTypedCallSite siteID tops args perms_in],</span>
<span class="lineno"> 1256 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryGhosts = callSiteVars siteID,</span>
<span class="lineno"> 1257 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryPermsIn = perms_in, typedEntryPermsOut = perms_out,</span>
<span class="lineno"> 1258 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryBody = Nothing</span>
<span class="lineno"> 1259 </span><span class="spaces">  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 1260 </span>
<span class="lineno"> 1261 </span>-- | Test if an entrypoint contains a call site with the given caller
<span class="lineno"> 1262 </span>typedEntryHasCaller :: TypedEntryID blocks args_src -&gt;
<span class="lineno"> 1263 </span>                       TypedEntry phase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1264 </span>                       Bool
<span class="lineno"> 1265 </span><span class="decl"><span class="nottickedoff">typedEntryHasCaller callerID (typedEntryCallers -&gt; callers) =</span>
<span class="lineno"> 1266 </span><span class="spaces">  </span><span class="nottickedoff">any (\(Some site) -&gt;</span>
<span class="lineno"> 1267 </span><span class="spaces">        </span><span class="nottickedoff">callSiteIDCallerEq callerID $ typedCallSiteID site) callers</span></span>
<span class="lineno"> 1268 </span>
<span class="lineno"> 1269 </span>-- | Return the 'TypedCallSite' structure in an entrypoint for a particular call
<span class="lineno"> 1270 </span>-- site id, if it exists. Unlike 'typedEntryHasCaller', this requires the site
<span class="lineno"> 1271 </span>-- id to have the same variables.
<span class="lineno"> 1272 </span>typedEntryCallerSite ::
<span class="lineno"> 1273 </span>  TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1274 </span>  TypedEntry phase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1275 </span>  Maybe (TypedCallSite phase blocks tops args ghosts vars)
<span class="lineno"> 1276 </span><span class="decl"><span class="nottickedoff">typedEntryCallerSite siteID (typedEntryCallers -&gt; callers) =</span>
<span class="lineno"> 1277 </span><span class="spaces">  </span><span class="nottickedoff">listToMaybe $ flip mapMaybe callers $ \(Some site) -&gt;</span>
<span class="lineno"> 1278 </span><span class="spaces">  </span><span class="nottickedoff">case testEquality (typedCallSiteID site) siteID of</span>
<span class="lineno"> 1279 </span><span class="spaces">    </span><span class="nottickedoff">Just Refl -&gt; Just site</span>
<span class="lineno"> 1280 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; Nothing</span></span>
<span class="lineno"> 1281 </span>
<span class="lineno"> 1282 </span>
<span class="lineno"> 1283 </span>-- | A typed Crucible block is either a join block, meaning that all jumps to it
<span class="lineno"> 1284 </span>-- get joined into the same entrypoint, or is a multi-entry block, meaning that
<span class="lineno"> 1285 </span>-- each jump to it gets type-checked separately with a different entrypoint
<span class="lineno"> 1286 </span>data TypedBlockSort = JoinSort | MultiEntrySort
<span class="lineno"> 1287 </span>
<span class="lineno"> 1288 </span>-- | A typed Crucible block is a list of typed entrypoints to that block
<span class="lineno"> 1289 </span>data TypedBlock phase ext (blocks :: RList (RList CrucibleType)) tops rets args =
<span class="lineno"> 1290 </span>  forall gouts ret cargs. (CtxToRList cargs ~ args, rets ~ (gouts :&gt; ret)) =&gt;
<span class="lineno"> 1291 </span>  TypedBlock
<span class="lineno"> 1292 </span>  {
<span class="lineno"> 1293 </span>    -- | An identifier for this block
<span class="lineno"> 1294 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedBlockID</span></span></span> :: TypedBlockID blocks args,
<span class="lineno"> 1295 </span>    -- | The original Crucible block
<span class="lineno"> 1296 </span>    <span class="decl"><span class="nottickedoff">typedBlockBlock</span></span> :: Block ext (RListToCtxCtx blocks) ret cargs,
<span class="lineno"> 1297 </span>    -- | What sort of block is this
<span class="lineno"> 1298 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedBlockSort</span></span></span> :: TypedBlockSort,
<span class="lineno"> 1299 </span>    -- | Whether widening is allowed for entrypoints in this block; widening
<span class="lineno"> 1300 </span>    -- disallowed for user-supplied permissions
<span class="lineno"> 1301 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">typedBlockCanWiden</span></span></span> :: Bool,
<span class="lineno"> 1302 </span>    -- | The entrypoints into this block
<span class="lineno"> 1303 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_typedBlockEntries</span></span></span> :: [Some (TypedEntry phase ext blocks tops rets args)],
<span class="lineno"> 1304 </span>    -- | Debug name information for the current block
<span class="lineno"> 1305 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_typedBlockNames</span></span></span> :: [Maybe String]
<span class="lineno"> 1306 </span>  }
<span class="lineno"> 1307 </span>
<span class="lineno"> 1308 </span>-- NOTE: this doesn't work because of the rets ~ (gouts :&gt; ret) constraint
<span class="lineno"> 1309 </span>-- makeLenses ''TypedBlock
<span class="lineno"> 1310 </span>
<span class="lineno"> 1311 </span>-- | The lens for '_typedBlockEntries'
<span class="lineno"> 1312 </span>typedBlockEntries :: Lens' (TypedBlock phase ext blocks tops rets args)
<span class="lineno"> 1313 </span>                     [Some (TypedEntry phase ext blocks tops rets args)]
<span class="lineno"> 1314 </span><span class="decl"><span class="nottickedoff">typedBlockEntries =</span>
<span class="lineno"> 1315 </span><span class="spaces">  </span><span class="nottickedoff">lens _typedBlockEntries (\tblk entries -&gt;</span>
<span class="lineno"> 1316 </span><span class="spaces">                            </span><span class="nottickedoff">tblk { _typedBlockEntries = entries })</span></span>
<span class="lineno"> 1317 </span>
<span class="lineno"> 1318 </span>-- | The lens for '_typedBlockNames'
<span class="lineno"> 1319 </span>typedBlockNames :: Lens' (TypedBlock phase ext blocks tops rets args)
<span class="lineno"> 1320 </span>                   [Maybe String]
<span class="lineno"> 1321 </span><span class="decl"><span class="nottickedoff">typedBlockNames =</span>
<span class="lineno"> 1322 </span><span class="spaces">  </span><span class="nottickedoff">lens _typedBlockNames (\tblk ns -&gt; tblk { _typedBlockNames = ns })</span></span>
<span class="lineno"> 1323 </span>
<span class="lineno"> 1324 </span>-- | The input argument types of a block
<span class="lineno"> 1325 </span>blockArgs :: TypedBlock phase ext blocks tops rets args -&gt; CruCtx args
<span class="lineno"> 1326 </span><span class="decl"><span class="nottickedoff">blockArgs (TypedBlock {..}) = mkCruCtx $ blockInputs typedBlockBlock</span></span>
<span class="lineno"> 1327 </span>
<span class="lineno"> 1328 </span>-- | Get the 'Int' index of the location of entrypoint in the
<span class="lineno"> 1329 </span>-- 'typedBlockEntries' of a block, if it exists
<span class="lineno"> 1330 </span>blockEntryMaybeIx :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1331 </span>                     TypedBlock phase ext blocks tops rets args -&gt;
<span class="lineno"> 1332 </span>                     Maybe Int
<span class="lineno"> 1333 </span><span class="decl"><span class="nottickedoff">blockEntryMaybeIx entryID blk =</span>
<span class="lineno"> 1334 </span><span class="spaces">  </span><span class="nottickedoff">findIndex (\(Some entry) -&gt; entryID == typedEntryID entry)</span>
<span class="lineno"> 1335 </span><span class="spaces">  </span><span class="nottickedoff">(blk ^. typedBlockEntries)</span></span>
<span class="lineno"> 1336 </span>
<span class="lineno"> 1337 </span>-- | Get the 'Int' index of the location of entrypoint in the
<span class="lineno"> 1338 </span>-- 'typedBlockEntries' of a block, or raise an error if it does not exist
<span class="lineno"> 1339 </span>blockEntryIx :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1340 </span>                TypedBlock phase ext blocks tops rets args -&gt;
<span class="lineno"> 1341 </span>                Int
<span class="lineno"> 1342 </span><span class="decl"><span class="nottickedoff">blockEntryIx entryID blk =</span>
<span class="lineno"> 1343 </span><span class="spaces">  </span><span class="nottickedoff">maybe (error &quot;blockEntryIx: no such entrypoint!&quot;) id $</span>
<span class="lineno"> 1344 </span><span class="spaces">  </span><span class="nottickedoff">blockEntryMaybeIx entryID blk</span></span>
<span class="lineno"> 1345 </span>
<span class="lineno"> 1346 </span>-- | Test if an entrypoint ID has a corresponding entrypoint in a block
<span class="lineno"> 1347 </span>entryIDInBlock :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1348 </span>                  TypedBlock phase ext blocks tops rets args -&gt; Bool
<span class="lineno"> 1349 </span><span class="decl"><span class="nottickedoff">entryIDInBlock entryID blk = isJust $ blockEntryMaybeIx entryID blk</span></span>
<span class="lineno"> 1350 </span>
<span class="lineno"> 1351 </span>-- | The 'Lens' for finding a 'TypedEntry' by id in a 'TypedBlock'
<span class="lineno"> 1352 </span>entryByID :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1353 </span>             Lens' (TypedBlock phase ext blocks tops ret args)
<span class="lineno"> 1354 </span>             (Some (TypedEntry phase ext blocks tops ret args))
<span class="lineno"> 1355 </span><span class="decl"><span class="nottickedoff">entryByID entryID =</span>
<span class="lineno"> 1356 </span><span class="spaces">  </span><span class="nottickedoff">lens</span>
<span class="lineno"> 1357 </span><span class="spaces">  </span><span class="nottickedoff">(\blk -&gt; view typedBlockEntries blk !! blockEntryIx entryID blk)</span>
<span class="lineno"> 1358 </span><span class="spaces">  </span><span class="nottickedoff">(\blk e -&gt;</span>
<span class="lineno"> 1359 </span><span class="spaces">    </span><span class="nottickedoff">over typedBlockEntries (replaceNth (blockEntryIx entryID blk) e) blk)</span></span>
<span class="lineno"> 1360 </span>
<span class="lineno"> 1361 </span>
<span class="lineno"> 1362 </span>-- | Build an empty 'TypedBlock'
<span class="lineno"> 1363 </span>emptyBlockOfSort ::
<span class="lineno"> 1364 </span>  [Maybe String] -&gt;
<span class="lineno"> 1365 </span>  Assignment CtxRepr cblocks -&gt;
<span class="lineno"> 1366 </span>  TypedBlockSort -&gt;
<span class="lineno"> 1367 </span>  Block ext cblocks ret cargs -&gt;
<span class="lineno"> 1368 </span>  TypedBlock TCPhase ext (CtxCtxToRList cblocks) tops (gouts :&gt; ret) (CtxToRList
<span class="lineno"> 1369 </span>                                                                      cargs)
<span class="lineno"> 1370 </span><span class="decl"><span class="nottickedoff">emptyBlockOfSort names cblocks sort blk</span>
<span class="lineno"> 1371 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- reprReprToCruCtxCtxEq cblocks</span>
<span class="lineno"> 1372 </span><span class="spaces">  </span><span class="nottickedoff">= TypedBlock (indexToTypedBlockID (size cblocks) $</span>
<span class="lineno"> 1373 </span><span class="spaces">                </span><span class="nottickedoff">blockIDIndex $ blockID blk) blk sort True [] names</span></span>
<span class="lineno"> 1374 </span>
<span class="lineno"> 1375 </span>-- | Build a block with a user-supplied input permission
<span class="lineno"> 1376 </span>emptyBlockForPerms ::
<span class="lineno"> 1377 </span>  [Maybe String] -&gt;
<span class="lineno"> 1378 </span>  Assignment CtxRepr cblocks -&gt;
<span class="lineno"> 1379 </span>  Block ext cblocks ret cargs -&gt; CruCtx tops -&gt;
<span class="lineno"> 1380 </span>  TypeRepr ret -&gt; CruCtx ghosts -&gt; CruCtx gouts -&gt;
<span class="lineno"> 1381 </span>  MbValuePerms ((tops :++: CtxToRList cargs) :++: ghosts) -&gt;
<span class="lineno"> 1382 </span>  MbValuePerms (tops :++: gouts :&gt; ret) -&gt;
<span class="lineno"> 1383 </span>  TypedBlock TCPhase ext (CtxCtxToRList
<span class="lineno"> 1384 </span>                          cblocks) tops (gouts :&gt; ret) (CtxToRList cargs)
<span class="lineno"> 1385 </span><span class="decl"><span class="nottickedoff">emptyBlockForPerms names cblocks blk tops ret ghosts gouts perms_in perms_out</span>
<span class="lineno"> 1386 </span><span class="spaces">  </span><span class="nottickedoff">| Refl &lt;- reprReprToCruCtxCtxEq cblocks</span>
<span class="lineno"> 1387 </span><span class="spaces">  </span><span class="nottickedoff">, blockID &lt;- indexToTypedBlockID (size cblocks) $ blockIDIndex $ blockID blk</span>
<span class="lineno"> 1388 </span><span class="spaces">  </span><span class="nottickedoff">, args &lt;- mkCruCtx (blockInputs blk) =</span>
<span class="lineno"> 1389 </span><span class="spaces">    </span><span class="nottickedoff">TypedBlock blockID blk JoinSort False</span>
<span class="lineno"> 1390 </span><span class="spaces">    </span><span class="nottickedoff">[Some TypedEntry {</span>
<span class="lineno"> 1391 </span><span class="spaces">        </span><span class="nottickedoff">typedEntryID = TypedEntryID blockID 0, typedEntryTops = tops,</span>
<span class="lineno"> 1392 </span><span class="spaces">        </span><span class="nottickedoff">typedEntryArgs = args, typedEntryRets = CruCtxCons gouts ret,</span>
<span class="lineno"> 1393 </span><span class="spaces">        </span><span class="nottickedoff">typedEntryCallers = [], typedEntryGhosts = ghosts,</span>
<span class="lineno"> 1394 </span><span class="spaces">        </span><span class="nottickedoff">typedEntryPermsIn = perms_in, typedEntryPermsOut = perms_out,</span>
<span class="lineno"> 1395 </span><span class="spaces">        </span><span class="nottickedoff">typedEntryBody = Nothing }]</span>
<span class="lineno"> 1396 </span><span class="spaces">    </span><span class="nottickedoff">names</span></span>
<span class="lineno"> 1397 </span>
<span class="lineno"> 1398 </span>-- | Transition a 'TypedBlock' from type-checking to translation phase, by
<span class="lineno"> 1399 </span>-- making sure that all of data needed for the translation phase is present
<span class="lineno"> 1400 </span>completeTypedBlock :: TypedBlock TCPhase ext blocks tops rets args -&gt;
<span class="lineno"> 1401 </span>                      Maybe (TypedBlock TransPhase ext blocks tops rets args)
<span class="lineno"> 1402 </span><span class="decl"><span class="nottickedoff">completeTypedBlock (TypedBlock { .. })</span>
<span class="lineno"> 1403 </span><span class="spaces">  </span><span class="nottickedoff">| Just entries &lt;- mapM (traverseF completeTypedEntry) _typedBlockEntries</span>
<span class="lineno"> 1404 </span><span class="spaces">  </span><span class="nottickedoff">= Just $ TypedBlock { _typedBlockEntries = entries, .. }</span>
<span class="lineno"> 1405 </span><span class="spaces"></span><span class="nottickedoff">completeTypedBlock _ = Nothing</span></span>
<span class="lineno"> 1406 </span>
<span class="lineno"> 1407 </span>-- | Add a new entrypoint to a block, making sure that its entry ID does not
<span class="lineno"> 1408 </span>-- already exist in the block
<span class="lineno"> 1409 </span>addEntryToBlock :: TypedEntry phase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1410 </span>                   TypedBlock phase ext blocks tops rets args -&gt;
<span class="lineno"> 1411 </span>                   TypedBlock phase ext blocks tops rets args
<span class="lineno"> 1412 </span><span class="decl"><span class="nottickedoff">addEntryToBlock entry blk</span>
<span class="lineno"> 1413 </span><span class="spaces">  </span><span class="nottickedoff">| entryIDInBlock (typedEntryID entry) blk =</span>
<span class="lineno"> 1414 </span><span class="spaces">    </span><span class="nottickedoff">error &quot;addEntryToBlock: entry with the same ID already in block!&quot;</span>
<span class="lineno"> 1415 </span><span class="spaces"></span><span class="nottickedoff">addEntryToBlock entry blk = over typedBlockEntries (++ [Some entry]) blk</span></span>
<span class="lineno"> 1416 </span>
<span class="lineno"> 1417 </span>-- | Return a 'Int' not in a list
<span class="lineno"> 1418 </span>freshInt :: [Int] -&gt; Int
<span class="lineno"> 1419 </span><span class="decl"><span class="nottickedoff">freshInt [] = 0</span>
<span class="lineno"> 1420 </span><span class="spaces"></span><span class="nottickedoff">freshInt xs = 1 + maximum xs</span></span>
<span class="lineno"> 1421 </span>
<span class="lineno"> 1422 </span>-- | Build a new 'TypedCallSiteID' for a new call to a block from a given
<span class="lineno"> 1423 </span>-- entrypoint. If the block has 'JoinSort', this will call the one and only
<span class="lineno"> 1424 </span>-- entrypoint for that block, and otherwise, for a 'MultiEntrySort' block, it
<span class="lineno"> 1425 </span>-- will create a new entrypoint id.
<span class="lineno"> 1426 </span>newCallSiteID :: TypedEntryID blocks args_src -&gt; CruCtx vars -&gt;
<span class="lineno"> 1427 </span>                 TypedBlock phase ext blocks tops rets args -&gt;
<span class="lineno"> 1428 </span>                 TypedCallSiteID blocks args vars
<span class="lineno"> 1429 </span>
<span class="lineno"> 1430 </span>-- If blk has JoinSort but has no entrypoints yet, we will create one. It cannot
<span class="lineno"> 1431 </span>-- have any other callers, either, so we use caller index 0.
<span class="lineno"> 1432 </span><span class="decl"><span class="nottickedoff">newCallSiteID callerID vars blk@(typedBlockSort -&gt; JoinSort)</span>
<span class="lineno"> 1433 </span><span class="spaces">  </span><span class="nottickedoff">| [] &lt;- blk ^. typedBlockEntries =</span>
<span class="lineno"> 1434 </span><span class="spaces">    </span><span class="nottickedoff">let entryID = TypedEntryID (typedBlockID blk) 0</span>
<span class="lineno"> 1435 </span><span class="spaces">        </span><span class="nottickedoff">call_ix = 0 in</span>
<span class="lineno"> 1436 </span><span class="spaces">  </span><span class="nottickedoff">TypedCallSiteID callerID call_ix entryID vars</span>
<span class="lineno"> 1437 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1438 </span><span class="spaces"></span><span class="nottickedoff">-- If blk has JoinSort and does have an entrypoint already, choose a caller</span>
<span class="lineno"> 1439 </span><span class="spaces"></span><span class="nottickedoff">-- index that is greater than any already being used</span>
<span class="lineno"> 1440 </span><span class="spaces"></span><span class="nottickedoff">newCallSiteID callerID vars blk@(typedBlockSort -&gt; JoinSort)</span>
<span class="lineno"> 1441 </span><span class="spaces">  </span><span class="nottickedoff">| Some entry:_ &lt;- blk ^. typedBlockEntries =</span>
<span class="lineno"> 1442 </span><span class="spaces">    </span><span class="nottickedoff">let entryID = TypedEntryID (typedBlockID blk) 0</span>
<span class="lineno"> 1443 </span><span class="spaces">        </span><span class="nottickedoff">call_ix = freshInt (map</span>
<span class="lineno"> 1444 </span><span class="spaces">                            </span><span class="nottickedoff">(\(Some site) -&gt; callSiteIx (typedCallSiteID site))</span>
<span class="lineno"> 1445 </span><span class="spaces">                            </span><span class="nottickedoff">(typedEntryCallers entry)) in</span>
<span class="lineno"> 1446 </span><span class="spaces">  </span><span class="nottickedoff">TypedCallSiteID callerID call_ix entryID vars</span>
<span class="lineno"> 1447 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1448 </span><span class="spaces"></span><span class="nottickedoff">-- If blk has MultiEntrySort, make a new entrypoint</span>
<span class="lineno"> 1449 </span><span class="spaces"></span><span class="nottickedoff">newCallSiteID callerID vars blk@(typedBlockSort -&gt; MultiEntrySort) =</span>
<span class="lineno"> 1450 </span><span class="spaces">    </span><span class="nottickedoff">let entry_ix = freshInt (map</span>
<span class="lineno"> 1451 </span><span class="spaces">                             </span><span class="nottickedoff">(\(Some entry) -&gt; entryIndex (typedEntryID entry))</span>
<span class="lineno"> 1452 </span><span class="spaces">                             </span><span class="nottickedoff">(blk ^. typedBlockEntries))</span>
<span class="lineno"> 1453 </span><span class="spaces">        </span><span class="nottickedoff">entryID = TypedEntryID (typedBlockID blk) entry_ix</span>
<span class="lineno"> 1454 </span><span class="spaces">        </span><span class="nottickedoff">call_ix = 0 in</span>
<span class="lineno"> 1455 </span><span class="spaces">  </span><span class="nottickedoff">TypedCallSiteID callerID call_ix entryID vars</span>
<span class="lineno"> 1456 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1457 </span><span class="spaces"></span><span class="nottickedoff">-- Should never happen...</span>
<span class="lineno"> 1458 </span><span class="spaces"></span><span class="nottickedoff">newCallSiteID _ _ _ = error &quot;newCallSiteID: impossible case!&quot;</span></span>
<span class="lineno"> 1459 </span>
<span class="lineno"> 1460 </span>
<span class="lineno"> 1461 </span>-- | Add a call site to an entrypoint. It is an error if the entrypoint already
<span class="lineno"> 1462 </span>-- has a call site with the given call site id.
<span class="lineno"> 1463 </span>entryAddCallSite :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1464 </span>                    MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 1465 </span>                    TypedEntry TCPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 1466 </span>                    TypedEntry TCPhase ext blocks tops rets args ghosts
<span class="lineno"> 1467 </span><span class="decl"><span class="nottickedoff">entryAddCallSite siteID _ entry</span>
<span class="lineno"> 1468 </span><span class="spaces">  </span><span class="nottickedoff">| any (\(Some site) -&gt;</span>
<span class="lineno"> 1469 </span><span class="spaces">          </span><span class="nottickedoff">isJust $ testEquality (typedCallSiteID site) siteID)</span>
<span class="lineno"> 1470 </span><span class="spaces">    </span><span class="nottickedoff">(typedEntryCallers entry)</span>
<span class="lineno"> 1471 </span><span class="spaces">  </span><span class="nottickedoff">= error &quot;entryAddCallSite: call site already exists!&quot;</span>
<span class="lineno"> 1472 </span><span class="spaces"></span><span class="nottickedoff">entryAddCallSite siteID perms_in entry =</span>
<span class="lineno"> 1473 </span><span class="spaces">  </span><span class="nottickedoff">entry { typedEntryCallers =</span>
<span class="lineno"> 1474 </span><span class="spaces">            </span><span class="nottickedoff">typedEntryCallers entry ++ [Some $</span>
<span class="lineno"> 1475 </span><span class="spaces">                                        </span><span class="nottickedoff">emptyTypedCallSite siteID perms_in] }</span></span>
<span class="lineno"> 1476 </span>
<span class="lineno"> 1477 </span>-- | Add a call site to a block for a particular caller to have the supplied
<span class="lineno"> 1478 </span>-- permissions over the supplied variables, adding a new entrypoint if that of
<span class="lineno"> 1479 </span>-- the given call site ID does not yet exist. It is an error if the block
<span class="lineno"> 1480 </span>-- already has a call site with the given call site id.
<span class="lineno"> 1481 </span>blockAddCallSite :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1482 </span>                    CruCtx tops -&gt; CruCtx rets -&gt;
<span class="lineno"> 1483 </span>                    MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 1484 </span>                    MbValuePerms (tops :++: rets) -&gt;
<span class="lineno"> 1485 </span>                    TypedBlock TCPhase ext blocks tops rets args -&gt;
<span class="lineno"> 1486 </span>                    TypedBlock TCPhase ext blocks tops rets args
<span class="lineno"> 1487 </span>-- If the entrypoint for the site ID exists, update it with entrySetCallSite
<span class="lineno"> 1488 </span><span class="decl"><span class="nottickedoff">blockAddCallSite siteID _ _ perms_in _ blk</span>
<span class="lineno"> 1489 </span><span class="spaces">  </span><span class="nottickedoff">| Just _ &lt;- blockEntryMaybeIx (callSiteDest siteID) blk =</span>
<span class="lineno"> 1490 </span><span class="spaces">    </span><span class="nottickedoff">over</span>
<span class="lineno"> 1491 </span><span class="spaces">    </span><span class="nottickedoff">(entryByID $ callSiteDest siteID)</span>
<span class="lineno"> 1492 </span><span class="spaces">    </span><span class="nottickedoff">(\(Some entry) -&gt; Some $ entryAddCallSite siteID perms_in entry)</span>
<span class="lineno"> 1493 </span><span class="spaces">    </span><span class="nottickedoff">blk</span>
<span class="lineno"> 1494 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1495 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise, make a new entrypoint</span>
<span class="lineno"> 1496 </span><span class="spaces"></span><span class="nottickedoff">blockAddCallSite siteID tops rets perms_in perms_out blk =</span>
<span class="lineno"> 1497 </span><span class="spaces">  </span><span class="nottickedoff">addEntryToBlock (singleCallSiteEntry</span>
<span class="lineno"> 1498 </span><span class="spaces">                   </span><span class="nottickedoff">siteID tops (blockArgs blk) rets perms_in perms_out) blk</span></span>
<span class="lineno"> 1499 </span>
<span class="lineno"> 1500 </span>-- | A map assigning a 'TypedBlock' to each 'BlockID'
<span class="lineno"> 1501 </span>type TypedBlockMap phase ext blocks tops rets =
<span class="lineno"> 1502 </span>  RAssign (TypedBlock phase ext blocks tops rets) blocks
<span class="lineno"> 1503 </span>
<span class="lineno"> 1504 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (TypedEntry phase ext blocks tops rets args ghosts)</span></span></span></span> where
<span class="lineno"> 1505 </span>  <span class="decl"><span class="nottickedoff">show (TypedEntry { .. }) =</span>
<span class="lineno"> 1506 </span><span class="spaces">    </span><span class="nottickedoff">&quot;&lt;entry &quot; ++ show typedEntryID ++ &quot;&gt;&quot;</span></span>
<span class="lineno"> 1507 </span>
<span class="lineno"> 1508 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (TypedBlock phase ext blocks tops rets args)</span></span></span></span> where
<span class="lineno"> 1509 </span>  <span class="decl"><span class="nottickedoff">show = concatMap (\(Some entry) -&gt; show entry) . (^. typedBlockEntries)</span></span>
<span class="lineno"> 1510 </span>
<span class="lineno"> 1511 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show (TypedBlockMap phase ext blocks tops rets)</span></span></span></span> where
<span class="lineno"> 1512 </span>  <span class="decl"><span class="nottickedoff">show blkMap = show $ RL.mapToList show blkMap</span></span>
<span class="lineno"> 1513 </span>
<span class="lineno"> 1514 </span>-- | Transition a 'TypedBlockMap' from type-checking to translation phase, by
<span class="lineno"> 1515 </span>-- making sure that all of data needed for the translation phase is present
<span class="lineno"> 1516 </span>completeTypedBlockMap :: TypedBlockMap TCPhase ext blocks tops rets -&gt;
<span class="lineno"> 1517 </span>                         Maybe (TypedBlockMap TransPhase ext blocks tops rets)
<span class="lineno"> 1518 </span><span class="decl"><span class="nottickedoff">completeTypedBlockMap = traverseRAssign completeTypedBlock</span></span>
<span class="lineno"> 1519 </span>
<span class="lineno"> 1520 </span>-- | The 'Lens' for finding a 'TypedBlock' by id in a 'TypedBlockMap'
<span class="lineno"> 1521 </span>blockByID :: TypedBlockID blocks args -&gt;
<span class="lineno"> 1522 </span>             Lens'
<span class="lineno"> 1523 </span>             (TypedBlockMap phase ext blocks tops rets)
<span class="lineno"> 1524 </span>             (TypedBlock phase ext blocks tops rets args)
<span class="lineno"> 1525 </span><span class="decl"><span class="nottickedoff">blockByID blkID =</span>
<span class="lineno"> 1526 </span><span class="spaces">  </span><span class="nottickedoff">let memb = typedBlockIDMember blkID in</span>
<span class="lineno"> 1527 </span><span class="spaces">  </span><span class="nottickedoff">lens (RL.get memb) (flip $ RL.set memb)</span></span>
<span class="lineno"> 1528 </span>
<span class="lineno"> 1529 </span>-- | Look up a 'TypedEntry' by its 'TypedEntryID'
<span class="lineno"> 1530 </span>lookupEntry :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1531 </span>               TypedBlockMap phase ext blocks tops rets -&gt;
<span class="lineno"> 1532 </span>               Some (TypedEntry phase ext blocks tops rets args)
<span class="lineno"> 1533 </span><span class="decl"><span class="nottickedoff">lookupEntry entryID =</span>
<span class="lineno"> 1534 </span><span class="spaces">  </span><span class="nottickedoff">view (blockByID (entryBlockID entryID) . entryByID entryID)</span></span>
<span class="lineno"> 1535 </span>
<span class="lineno"> 1536 </span>-- | Find all call sites called by an entrypoint
<span class="lineno"> 1537 </span>entryCallees :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1538 </span>                TypedBlockMap phase ext blocks tops rets -&gt;
<span class="lineno"> 1539 </span>                [Some (TypedEntryID blocks)]
<span class="lineno"> 1540 </span><span class="decl"><span class="nottickedoff">entryCallees entryID =</span>
<span class="lineno"> 1541 </span><span class="spaces">  </span><span class="nottickedoff">concat . RL.mapToList</span>
<span class="lineno"> 1542 </span><span class="spaces">  </span><span class="nottickedoff">(\blk -&gt;</span>
<span class="lineno"> 1543 </span><span class="spaces">    </span><span class="nottickedoff">flip mapMaybe (blk ^. typedBlockEntries) $ \(Some entry) -&gt;</span>
<span class="lineno"> 1544 </span><span class="spaces">    </span><span class="nottickedoff">if typedEntryHasCaller entryID entry</span>
<span class="lineno"> 1545 </span><span class="spaces">    </span><span class="nottickedoff">then Just (Some $ typedEntryID entry)</span>
<span class="lineno"> 1546 </span><span class="spaces">    </span><span class="nottickedoff">else Nothing)</span></span>
<span class="lineno"> 1547 </span>
<span class="lineno"> 1548 </span>-- | Delete any call sites whose source is a given entrypoint. For any call
<span class="lineno"> 1549 </span>-- sites to entrypoints in multi-entry blocks, delete those entrypoints as well,
<span class="lineno"> 1550 </span>-- etc.
<span class="lineno"> 1551 </span>deleteEntryCallees :: TypedEntryID blocks args -&gt;
<span class="lineno"> 1552 </span>                      TypedBlockMap phase ext blocks tops rets -&gt;
<span class="lineno"> 1553 </span>                      TypedBlockMap phase ext blocks tops rets
<span class="lineno"> 1554 </span><span class="decl"><span class="nottickedoff">deleteEntryCallees topEntryID = execState (deleteCallees topEntryID) where</span>
<span class="lineno"> 1555 </span><span class="spaces">  </span><span class="nottickedoff">-- Delete call sites of a caller from all of its callees</span>
<span class="lineno"> 1556 </span><span class="spaces">  </span><span class="nottickedoff">deleteCallees :: TypedEntryID blocks args' -&gt;</span>
<span class="lineno"> 1557 </span><span class="spaces">                   </span><span class="nottickedoff">State (TypedBlockMap phase ext blocks tops rets) ()</span>
<span class="lineno"> 1558 </span><span class="spaces">  </span><span class="nottickedoff">deleteCallees callerID =</span>
<span class="lineno"> 1559 </span><span class="spaces">    </span><span class="nottickedoff">get &gt;&gt;= \blkMap -&gt;</span>
<span class="lineno"> 1560 </span><span class="spaces">    </span><span class="nottickedoff">mapM_ (\(Some calleeID) -&gt;</span>
<span class="lineno"> 1561 </span><span class="spaces">            </span><span class="nottickedoff">deleteCall callerID calleeID) (entryCallees callerID blkMap)</span>
<span class="lineno"> 1562 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 1563 </span><span class="spaces">  </span><span class="nottickedoff">-- Delete call sites of a caller to a particular callee</span>
<span class="lineno"> 1564 </span><span class="spaces">  </span><span class="nottickedoff">deleteCall :: TypedEntryID blocks args1 -&gt; TypedEntryID blocks args2 -&gt;</span>
<span class="lineno"> 1565 </span><span class="spaces">                </span><span class="nottickedoff">State (TypedBlockMap phase ext blocks tops rets) ()</span>
<span class="lineno"> 1566 </span><span class="spaces">  </span><span class="nottickedoff">deleteCall callerID calleeID =</span>
<span class="lineno"> 1567 </span><span class="spaces">    </span><span class="nottickedoff">(typedBlockSort &lt;$&gt; use (blockByID $ entryBlockID calleeID)) &gt;&gt;= \case</span>
<span class="lineno"> 1568 </span><span class="spaces">    </span><span class="nottickedoff">JoinSort -&gt;</span>
<span class="lineno"> 1569 </span><span class="spaces">      </span><span class="nottickedoff">-- The target has JoinSort, so we want to keep the callee entrypoint. Thus</span>
<span class="lineno"> 1570 </span><span class="spaces">      </span><span class="nottickedoff">-- we just delete all call sites whose caller equals callerID.</span>
<span class="lineno"> 1571 </span><span class="spaces">      </span><span class="nottickedoff">modifying (blockByID (entryBlockID calleeID)</span>
<span class="lineno"> 1572 </span><span class="spaces">                 </span><span class="nottickedoff">. entryByID calleeID) $ \(Some callee) -&gt;</span>
<span class="lineno"> 1573 </span><span class="spaces">      </span><span class="nottickedoff">let callers' =</span>
<span class="lineno"> 1574 </span><span class="spaces">            </span><span class="nottickedoff">flip filter (typedEntryCallers callee) $ \(Some site) -&gt;</span>
<span class="lineno"> 1575 </span><span class="spaces">            </span><span class="nottickedoff">not $ callSiteIDCallerEq callerID $ typedCallSiteID site in</span>
<span class="lineno"> 1576 </span><span class="spaces">      </span><span class="nottickedoff">Some $ callee { typedEntryCallers = callers' }</span>
<span class="lineno"> 1577 </span><span class="spaces">    </span><span class="nottickedoff">MultiEntrySort -&gt;</span>
<span class="lineno"> 1578 </span><span class="spaces">      </span><span class="nottickedoff">-- The target has MultiEntrySort, so callerID is the only caller to this</span>
<span class="lineno"> 1579 </span><span class="spaces">      </span><span class="nottickedoff">-- entrypoint, and thus we recursively delete the entrypoint</span>
<span class="lineno"> 1580 </span><span class="spaces">      </span><span class="nottickedoff">modifying (blockByID (entryBlockID calleeID) . typedBlockEntries)</span>
<span class="lineno"> 1581 </span><span class="spaces">      </span><span class="nottickedoff">(filter (\(Some entry) -&gt; typedEntryID entry /= calleeID))</span>
<span class="lineno"> 1582 </span><span class="spaces">      </span><span class="nottickedoff">&gt;&gt;</span>
<span class="lineno"> 1583 </span><span class="spaces">      </span><span class="nottickedoff">deleteCallees calleeID</span></span>
<span class="lineno"> 1584 </span>
<span class="lineno"> 1585 </span>-- | Build the input permissions for the initial block of a CFG, where the
<span class="lineno"> 1586 </span>-- top-level variables (which in this case are the ghosts plus the normal
<span class="lineno"> 1587 </span>-- arguments of the function permission) get the function input permissions and
<span class="lineno"> 1588 </span>-- the normal arguments get equality permissions to their respective top-level
<span class="lineno"> 1589 </span>-- variables.
<span class="lineno"> 1590 </span>funPermToBlockInputs :: FunPerm ghosts args gouts ret -&gt;
<span class="lineno"> 1591 </span>                        MbValuePerms ((ghosts :++: args) :++: args)
<span class="lineno"> 1592 </span><span class="decl"><span class="nottickedoff">funPermToBlockInputs fun_perm =</span>
<span class="lineno"> 1593 </span><span class="spaces">  </span><span class="nottickedoff">let args_prxs = cruCtxProxies $ funPermArgs fun_perm in</span>
<span class="lineno"> 1594 </span><span class="spaces">  </span><span class="nottickedoff">extMbMulti args_prxs $</span>
<span class="lineno"> 1595 </span><span class="spaces">  </span><span class="nottickedoff">flip nuMultiWithElim1 (funPermIns fun_perm) $ \ghosts_args_ns perms_in -&gt;</span>
<span class="lineno"> 1596 </span><span class="spaces">  </span><span class="nottickedoff">let (_, args_ns) =</span>
<span class="lineno"> 1597 </span><span class="spaces">        </span><span class="nottickedoff">RL.split (funPermGhosts fun_perm) args_prxs ghosts_args_ns in</span>
<span class="lineno"> 1598 </span><span class="spaces">  </span><span class="nottickedoff">appendValuePerms perms_in (eqValuePerms args_ns)</span></span>
<span class="lineno"> 1599 </span>
<span class="lineno"> 1600 </span>-- | Build an initial 'TypedBlockMap' from a 'BlockMap'. Determine the sort, and
<span class="lineno"> 1601 </span>-- possibly entrypoint permissions, for each block by using hints in the
<span class="lineno"> 1602 </span>-- supplied 'PermEnv' along with a list of 'Bool' flags indicating which blocks
<span class="lineno"> 1603 </span>-- are at the head of a loop (or other strongly-connected component)
<span class="lineno"> 1604 </span>initTypedBlockMap ::
<span class="lineno"> 1605 </span>  KnownRepr ExtRepr ext =&gt;
<span class="lineno"> 1606 </span>  PermEnv -&gt;
<span class="lineno"> 1607 </span>  FunPerm ghosts (CtxToRList init) gouts ret -&gt;
<span class="lineno"> 1608 </span>  CFG ext cblocks init ret -&gt;
<span class="lineno"> 1609 </span>  Assignment (Constant Bool) cblocks -&gt;
<span class="lineno"> 1610 </span>  TypedBlockMap TCPhase ext (CtxCtxToRList cblocks)
<span class="lineno"> 1611 </span>    (ghosts :++: CtxToRList init) (gouts :&gt; ret)
<span class="lineno"> 1612 </span><span class="decl"><span class="nottickedoff">initTypedBlockMap env fun_perm cfg sccs =</span>
<span class="lineno"> 1613 </span><span class="spaces">  </span><span class="nottickedoff">let block_map = cfgBlockMap cfg</span>
<span class="lineno"> 1614 </span><span class="spaces">      </span><span class="nottickedoff">cblocks = fmapFC blockInputs block_map</span>
<span class="lineno"> 1615 </span><span class="spaces">      </span><span class="nottickedoff">namess = computeCfgNames knownRepr (size sccs) cfg</span>
<span class="lineno"> 1616 </span><span class="spaces">      </span><span class="nottickedoff">gouts = funPermGouts fun_perm</span>
<span class="lineno"> 1617 </span><span class="spaces">      </span><span class="nottickedoff">ret = funPermRet fun_perm</span>
<span class="lineno"> 1618 </span><span class="spaces">      </span><span class="nottickedoff">tops = funPermTops fun_perm</span>
<span class="lineno"> 1619 </span><span class="spaces">      </span><span class="nottickedoff">top_perms_in = funPermToBlockInputs fun_perm</span>
<span class="lineno"> 1620 </span><span class="spaces">      </span><span class="nottickedoff">perms_out = funPermOuts fun_perm in</span>
<span class="lineno"> 1621 </span><span class="spaces">  </span><span class="nottickedoff">assignToRListRList</span>
<span class="lineno"> 1622 </span><span class="spaces">  </span><span class="nottickedoff">(\(Pair blk (Pair (Constant is_scc) (Constant names))) -&gt;</span>
<span class="lineno"> 1623 </span><span class="spaces">    </span><span class="nottickedoff">let blkID = blockID blk</span>
<span class="lineno"> 1624 </span><span class="spaces">        </span><span class="nottickedoff">hints = lookupBlockHints env (cfgHandle cfg) cblocks blkID in</span>
<span class="lineno"> 1625 </span><span class="spaces">    </span><span class="nottickedoff">case hints of</span>
<span class="lineno"> 1626 </span><span class="spaces">      </span><span class="nottickedoff">_ | Just Refl &lt;- testEquality (cfgEntryBlockID cfg) blkID -&gt;</span>
<span class="lineno"> 1627 </span><span class="spaces">          </span><span class="nottickedoff">emptyBlockForPerms names cblocks blk tops ret</span>
<span class="lineno"> 1628 </span><span class="spaces">            </span><span class="nottickedoff">CruCtxNil gouts top_perms_in perms_out</span>
<span class="lineno"> 1629 </span><span class="spaces">      </span><span class="nottickedoff">(find isBlockEntryHint -&gt;</span>
<span class="lineno"> 1630 </span><span class="spaces">       </span><span class="nottickedoff">Just (BlockEntryHintSort tops' ghosts perms_in))</span>
<span class="lineno"> 1631 </span><span class="spaces">        </span><span class="nottickedoff">| Just Refl &lt;- testEquality tops tops' -&gt;</span>
<span class="lineno"> 1632 </span><span class="spaces">          </span><span class="nottickedoff">emptyBlockForPerms names cblocks blk tops ret</span>
<span class="lineno"> 1633 </span><span class="spaces">            </span><span class="nottickedoff">ghosts gouts perms_in perms_out</span>
<span class="lineno"> 1634 </span><span class="spaces">      </span><span class="nottickedoff">_ | is_scc || any isJoinPointHint hints -&gt;</span>
<span class="lineno"> 1635 </span><span class="spaces">          </span><span class="nottickedoff">emptyBlockOfSort names cblocks JoinSort blk</span>
<span class="lineno"> 1636 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; emptyBlockOfSort names cblocks MultiEntrySort blk) $</span>
<span class="lineno"> 1637 </span><span class="spaces">  </span><span class="nottickedoff">Ctx.zipWith Pair block_map (Ctx.zipWith Pair sccs namess)</span></span>
<span class="lineno"> 1638 </span>
<span class="lineno"> 1639 </span>computeCfgNames ::
<span class="lineno"> 1640 </span>  ExtRepr ext -&gt;
<span class="lineno"> 1641 </span>  Size cblocks -&gt;
<span class="lineno"> 1642 </span>  CFG ext cblocks init ret -&gt;
<span class="lineno"> 1643 </span>  Ctx.Assignment (Constant [Maybe String]) cblocks
<span class="lineno"> 1644 </span><span class="decl"><span class="nottickedoff">computeCfgNames ExtRepr_LLVM _ cfg = computeNames cfg</span>
<span class="lineno"> 1645 </span><span class="spaces"></span><span class="nottickedoff">computeCfgNames ExtRepr_Unit s _   = Ctx.replicate s (Constant [])</span></span>
<span class="lineno"> 1646 </span>
<span class="lineno"> 1647 </span>-- | A typed Crucible CFG
<span class="lineno"> 1648 </span>data TypedCFG
<span class="lineno"> 1649 </span>     (ext :: Type)
<span class="lineno"> 1650 </span>     (blocks :: RList (RList CrucibleType))
<span class="lineno"> 1651 </span>     (ghosts :: RList CrucibleType)
<span class="lineno"> 1652 </span>     (inits :: RList CrucibleType)
<span class="lineno"> 1653 </span>     (gouts :: RList CrucibleType)
<span class="lineno"> 1654 </span>     (ret :: CrucibleType)
<span class="lineno"> 1655 </span>  = TypedCFG { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">tpcfgHandle</span></span></span> :: !(TypedFnHandle ghosts inits gouts ret)
<span class="lineno"> 1656 </span>             , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">tpcfgFunPerm</span></span></span> :: !(FunPerm ghosts inits gouts ret)
<span class="lineno"> 1657 </span>             , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">tpcfgBlockMap</span></span></span> :: !(TypedBlockMap TransPhase ext blocks
<span class="lineno"> 1658 </span>                                  (ghosts :++: inits) (gouts :&gt; ret))
<span class="lineno"> 1659 </span>             , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">tpcfgEntryID</span></span></span> :: !(TypedEntryID blocks inits)
<span class="lineno"> 1660 </span>             }
<span class="lineno"> 1661 </span>
<span class="lineno"> 1662 </span>-- | Get the input permissions for a 'CFG'
<span class="lineno"> 1663 </span>tpcfgInputPerms :: TypedCFG ext blocks ghosts inits gouts ret -&gt;
<span class="lineno"> 1664 </span>                   MbValuePerms (ghosts :++: inits)
<span class="lineno"> 1665 </span><span class="decl"><span class="nottickedoff">tpcfgInputPerms = funPermIns . tpcfgFunPerm</span></span>
<span class="lineno"> 1666 </span>
<span class="lineno"> 1667 </span>-- | Get the output permissions for a 'CFG'
<span class="lineno"> 1668 </span>tpcfgOutputPerms :: TypedCFG ext blocks ghosts inits gouts ret -&gt;
<span class="lineno"> 1669 </span>                    MbValuePerms ((ghosts :++: inits) :++: gouts :&gt; ret)
<span class="lineno"> 1670 </span><span class="decl"><span class="nottickedoff">tpcfgOutputPerms = funPermOuts . tpcfgFunPerm</span></span>
<span class="lineno"> 1671 </span>
<span class="lineno"> 1672 </span>
<span class="lineno"> 1673 </span>----------------------------------------------------------------------
<span class="lineno"> 1674 </span>-- * Monad(s) for Permission Checking
<span class="lineno"> 1675 </span>----------------------------------------------------------------------
<span class="lineno"> 1676 </span>
<span class="lineno"> 1677 </span>-- | A translation of a Crucible context to 'TypedReg's that exist in the local
<span class="lineno"> 1678 </span>-- Hobbits context
<span class="lineno"> 1679 </span>type CtxTrans ctx = Assignment TypedReg ctx
<span class="lineno"> 1680 </span>
<span class="lineno"> 1681 </span>-- | Build a Crucible context translation from a set of variables
<span class="lineno"> 1682 </span>mkCtxTrans :: Assignment f ctx -&gt; RAssign Name (CtxToRList ctx) -&gt; CtxTrans ctx
<span class="lineno"> 1683 </span><span class="decl"><span class="nottickedoff">mkCtxTrans (viewAssign -&gt; AssignEmpty) _ = Ctx.empty</span>
<span class="lineno"> 1684 </span><span class="spaces"></span><span class="nottickedoff">mkCtxTrans (viewAssign -&gt; AssignExtend ctx' _) (ns :&gt;: n) =</span>
<span class="lineno"> 1685 </span><span class="spaces">  </span><span class="nottickedoff">extend (mkCtxTrans ctx' ns) (TypedReg n)</span></span>
<span class="lineno"> 1686 </span>
<span class="lineno"> 1687 </span>-- | Add a variable to the current Crucible context translation
<span class="lineno"> 1688 </span>addCtxName :: CtxTrans ctx -&gt; ExprVar tp -&gt; CtxTrans (ctx ::&gt; tp)
<span class="lineno"> 1689 </span><span class="decl"><span class="nottickedoff">addCtxName ctx x = extend ctx (TypedReg x)</span></span>
<span class="lineno"> 1690 </span>
<span class="lineno"> 1691 </span>
<span class="lineno"> 1692 </span>-- | The translation of a Crucible block id
<span class="lineno"> 1693 </span>newtype BlockIDTrans blocks args =
<span class="lineno"> 1694 </span>  BlockIDTrans { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unBlockIDTrans</span></span></span> :: TypedBlockID blocks (CtxToRList args) }
<span class="lineno"> 1695 </span>
<span class="lineno"> 1696 </span>-- | Build a map from Crucible block IDs to 'Member' proofs
<span class="lineno"> 1697 </span>buildBlockIDMap :: Size cblocks -&gt;
<span class="lineno"> 1698 </span>                   Assignment (BlockIDTrans (CtxCtxToRList cblocks)) cblocks
<span class="lineno"> 1699 </span><span class="decl"><span class="nottickedoff">buildBlockIDMap sz =</span>
<span class="lineno"> 1700 </span><span class="spaces">  </span><span class="nottickedoff">Ctx.generate sz $ \ix -&gt; BlockIDTrans (indexToTypedBlockID sz ix)</span></span>
<span class="lineno"> 1701 </span>
<span class="lineno"> 1702 </span>data SomePtrWidth where SomePtrWidth :: HasPtrWidth w =&gt; SomePtrWidth
<span class="lineno"> 1703 </span>
<span class="lineno"> 1704 </span>-- | Top-level state, maintained outside of permission-checking single blocks
<span class="lineno"> 1705 </span>data TopPermCheckState ext cblocks blocks tops rets =
<span class="lineno"> 1706 </span>  TopPermCheckState
<span class="lineno"> 1707 </span>  {
<span class="lineno"> 1708 </span>    -- | The top-level inputs of the function being type-checked
<span class="lineno"> 1709 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stTopCtx</span></span></span> :: !(CruCtx tops),
<span class="lineno"> 1710 </span>    -- | The return types including ghosts of the function being type-checked
<span class="lineno"> 1711 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stRetTypes</span></span></span> :: !(CruCtx rets),
<span class="lineno"> 1712 </span>    -- | The return permission of the function being type-checked
<span class="lineno"> 1713 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stRetPerms</span></span></span> :: !(MbValuePerms (tops :++: rets)),
<span class="lineno"> 1714 </span>    -- | A mapping from 'BlockID's to 'TypedBlockID's
<span class="lineno"> 1715 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stBlockTrans</span></span></span> :: !(Assignment (BlockIDTrans blocks) cblocks),
<span class="lineno"> 1716 </span>    -- | The current set of type-checked blocks
<span class="lineno"> 1717 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_stBlockMap</span></span></span> :: !(TypedBlockMap TCPhase ext blocks tops rets),
<span class="lineno"> 1718 </span>    -- | The permissions environment
<span class="lineno"> 1719 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stPermEnv</span></span></span> :: !PermEnv,
<span class="lineno"> 1720 </span>    -- | The un-translated input types of all of the Crucible blocks
<span class="lineno"> 1721 </span>    --
<span class="lineno"> 1722 </span>    -- FIXME: this is only needed to look up hints, to prove that the @blocks@
<span class="lineno"> 1723 </span>    -- type argument of the hints are equal to that of the function being
<span class="lineno"> 1724 </span>    -- type-checked; if we translated @blocks@ to @'CtxCtxToRList' blocks@ when
<span class="lineno"> 1725 </span>    -- creating the hints, this field would go away
<span class="lineno"> 1726 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stBlockTypes</span></span></span> :: !(Assignment CtxRepr cblocks),
<span class="lineno"> 1727 </span>    -- | Equality constraint between @cblocks@ and @blocks@
<span class="lineno"> 1728 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stCBlocksEq</span></span></span> :: RListToCtxCtx blocks :~: cblocks,
<span class="lineno"> 1729 </span>    -- | The endianness of the current architecture
<span class="lineno"> 1730 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stEndianness</span></span></span> :: !EndianForm,
<span class="lineno"> 1731 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stArchWidth</span></span></span> :: SomePtrWidth,
<span class="lineno"> 1732 </span>    -- | The debugging level
<span class="lineno"> 1733 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stDebugLevel</span></span></span> :: DebugLevel
<span class="lineno"> 1734 </span>  }
<span class="lineno"> 1735 </span>
<span class="lineno"> 1736 </span><span class="nottickedoff"><span class="decl"><span class="nottickedoff">makeLenses ''TopPermCheckState</span></span></span>
<span class="lineno"> 1737 </span>
<span class="lineno"> 1738 </span>-- | Build an empty 'TopPermCheckState' from a Crucible 'BlockMap'
<span class="lineno"> 1739 </span>emptyTopPermCheckState ::
<span class="lineno"> 1740 </span>  HasPtrWidth w =&gt;
<span class="lineno"> 1741 </span>  KnownRepr ExtRepr ext =&gt;
<span class="lineno"> 1742 </span>  PermEnv -&gt;
<span class="lineno"> 1743 </span>  FunPerm ghosts (CtxToRList init) gouts ret -&gt;
<span class="lineno"> 1744 </span>  EndianForm -&gt;
<span class="lineno"> 1745 </span>  DebugLevel -&gt;
<span class="lineno"> 1746 </span>  CFG ext cblocks init ret -&gt;
<span class="lineno"> 1747 </span>  Assignment (Constant Bool) cblocks -&gt;
<span class="lineno"> 1748 </span>  TopPermCheckState ext cblocks
<span class="lineno"> 1749 </span>    (CtxCtxToRList cblocks)
<span class="lineno"> 1750 </span>    (ghosts :++: CtxToRList init) (gouts :&gt; ret)
<span class="lineno"> 1751 </span><span class="decl"><span class="nottickedoff">emptyTopPermCheckState env fun_perm endianness dlevel cfg sccs =</span>
<span class="lineno"> 1752 </span><span class="spaces">  </span><span class="nottickedoff">let blkMap = cfgBlockMap cfg in</span>
<span class="lineno"> 1753 </span><span class="spaces">  </span><span class="nottickedoff">TopPermCheckState</span>
<span class="lineno"> 1754 </span><span class="spaces">  </span><span class="nottickedoff">{ stTopCtx = funPermTops fun_perm</span>
<span class="lineno"> 1755 </span><span class="spaces">  </span><span class="nottickedoff">, stRetTypes = funPermRets fun_perm</span>
<span class="lineno"> 1756 </span><span class="spaces">  </span><span class="nottickedoff">, stRetPerms = funPermOuts fun_perm</span>
<span class="lineno"> 1757 </span><span class="spaces">  </span><span class="nottickedoff">, stBlockTrans = buildBlockIDMap (Ctx.size blkMap)</span>
<span class="lineno"> 1758 </span><span class="spaces">  </span><span class="nottickedoff">, _stBlockMap = initTypedBlockMap env fun_perm cfg sccs</span>
<span class="lineno"> 1759 </span><span class="spaces">  </span><span class="nottickedoff">, stPermEnv = env</span>
<span class="lineno"> 1760 </span><span class="spaces">  </span><span class="nottickedoff">, stBlockTypes = fmapFC blockInputs blkMap</span>
<span class="lineno"> 1761 </span><span class="spaces">  </span><span class="nottickedoff">, stCBlocksEq = reprReprToCruCtxCtxEq (fmapFC blockInputs blkMap)</span>
<span class="lineno"> 1762 </span><span class="spaces">  </span><span class="nottickedoff">, stEndianness = endianness</span>
<span class="lineno"> 1763 </span><span class="spaces">  </span><span class="nottickedoff">, stArchWidth = SomePtrWidth</span>
<span class="lineno"> 1764 </span><span class="spaces">  </span><span class="nottickedoff">, stDebugLevel = dlevel</span>
<span class="lineno"> 1765 </span><span class="spaces">  </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 1766 </span>
<span class="lineno"> 1767 </span>
<span class="lineno"> 1768 </span>-- | Look up a Crucible block id in a top-level perm-checking state
<span class="lineno"> 1769 </span>stLookupBlockID :: BlockID cblocks args -&gt;
<span class="lineno"> 1770 </span>                   TopPermCheckState ext cblocks blocks tops rets -&gt;
<span class="lineno"> 1771 </span>                   TypedBlockID blocks (CtxToRList args)
<span class="lineno"> 1772 </span><span class="decl"><span class="nottickedoff">stLookupBlockID (BlockID ix) st =</span>
<span class="lineno"> 1773 </span><span class="spaces">  </span><span class="nottickedoff">unBlockIDTrans $ stBlockTrans st Ctx.! ix</span></span>
<span class="lineno"> 1774 </span>
<span class="lineno"> 1775 </span>-- | The top-level monad for permission-checking CFGs
<span class="lineno"> 1776 </span>type TopPermCheckM ext cblocks blocks tops rets =
<span class="lineno"> 1777 </span>  State (TopPermCheckState ext cblocks blocks tops rets)
<span class="lineno"> 1778 </span>
<span class="lineno"> 1779 </span>{-
<span class="lineno"> 1780 </span>-- | A datakind for the type-level parameters needed to define blocks, including
<span class="lineno"> 1781 </span>-- the @ext@, @blocks@, @ret@ and @args@ arguments
<span class="lineno"> 1782 </span>data BlkParams =
<span class="lineno"> 1783 </span>  BlkParams Type (RList (RList CrucibleType)) CrucibleType (RList CrucibleType)
<span class="lineno"> 1784 </span>
<span class="lineno"> 1785 </span>type family BlkExt (args :: BlkParams) :: Type where
<span class="lineno"> 1786 </span>  BlkExt ('BlkParams ext _ _ _) = ext
<span class="lineno"> 1787 </span>
<span class="lineno"> 1788 </span>type family BlkBlocks (args :: BlkParams) :: (RList (RList CrucibleType)) where
<span class="lineno"> 1789 </span>  BlkBlocks ('BlkParams _ blocks _ _) = blocks
<span class="lineno"> 1790 </span>
<span class="lineno"> 1791 </span>type family BlkRet (args :: BlkParams) :: CrucibleType where
<span class="lineno"> 1792 </span>  BlkRet ('BlkParams _ _ ret _) = ret
<span class="lineno"> 1793 </span>
<span class="lineno"> 1794 </span>type family BlkArgs (args :: BlkParams) :: RList CrucibleType where
<span class="lineno"> 1795 </span>  BlkArgs ('BlkParams _ _ _ args) = args
<span class="lineno"> 1796 </span>-}
<span class="lineno"> 1797 </span>
<span class="lineno"> 1798 </span>
<span class="lineno"> 1799 </span>
<span class="lineno"> 1800 </span>-- | A change to a 'TypedBlockMap'
<span class="lineno"> 1801 </span>data TypedBlockMapDelta blocks tops rets where
<span class="lineno"> 1802 </span>  -- | Add a call site to a block for a particular caller to have the supplied
<span class="lineno"> 1803 </span>  -- permissions over the supplied variables
<span class="lineno"> 1804 </span>  TypedBlockMapAddCallSite :: TypedCallSiteID blocks args vars -&gt;
<span class="lineno"> 1805 </span>                              MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 1806 </span>                              TypedBlockMapDelta blocks tops rets
<span class="lineno"> 1807 </span>
<span class="lineno"> 1808 </span>-- | Apply a 'TypedBlockMapDelta' to a 'TypedBlockMap'
<span class="lineno"> 1809 </span>applyTypedBlockMapDelta :: TypedBlockMapDelta blocks tops rets -&gt;
<span class="lineno"> 1810 </span>                           TopPermCheckState ext cblocks blocks tops rets -&gt;
<span class="lineno"> 1811 </span>                           TopPermCheckState ext cblocks blocks tops rets
<span class="lineno"> 1812 </span><span class="decl"><span class="nottickedoff">applyTypedBlockMapDelta (TypedBlockMapAddCallSite siteID perms_in) top_st =</span>
<span class="lineno"> 1813 </span><span class="spaces">  </span><span class="nottickedoff">over (stBlockMap . member (entryBlockMember $ callSiteDest siteID))</span>
<span class="lineno"> 1814 </span><span class="spaces">  </span><span class="nottickedoff">(blockAddCallSite siteID (stTopCtx top_st) (stRetTypes top_st)</span>
<span class="lineno"> 1815 </span><span class="spaces">   </span><span class="nottickedoff">perms_in (stRetPerms top_st))</span>
<span class="lineno"> 1816 </span><span class="spaces">  </span><span class="nottickedoff">top_st</span></span>
<span class="lineno"> 1817 </span>
<span class="lineno"> 1818 </span>-- | Apply a list of 'TypedBlockMapDelta's to a 'TopPermCheckState'
<span class="lineno"> 1819 </span>applyDeltasToTopState :: [TypedBlockMapDelta blocks tops rets] -&gt;
<span class="lineno"> 1820 </span>                         TopPermCheckState ext cblocks blocks tops rets -&gt;
<span class="lineno"> 1821 </span>                         TopPermCheckState ext cblocks blocks tops rets
<span class="lineno"> 1822 </span><span class="decl"><span class="nottickedoff">applyDeltasToTopState deltas top_st =</span>
<span class="lineno"> 1823 </span><span class="spaces">  </span><span class="nottickedoff">foldl (flip applyTypedBlockMapDelta) top_st deltas</span></span>
<span class="lineno"> 1824 </span>
<span class="lineno"> 1825 </span>-- | The state that can be modified by \&quot;inner\&quot; computations = a list of
<span class="lineno"> 1826 </span>-- changes / \&quot;deltas\&quot; to the current 'TypedBlockMap'
<span class="lineno"> 1827 </span>data InnerPermCheckState blocks tops rets =
<span class="lineno"> 1828 </span>  InnerPermCheckState
<span class="lineno"> 1829 </span>  {
<span class="lineno"> 1830 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">innerStateDeltas</span></span></span> :: [TypedBlockMapDelta blocks tops rets]
<span class="lineno"> 1831 </span>  }
<span class="lineno"> 1832 </span>
<span class="lineno"> 1833 </span>-- | Build an empty, closed 'InnerPermCheckState'
<span class="lineno"> 1834 </span>clEmptyInnerPermCheckState :: Closed (InnerPermCheckState blocks tops rets)
<span class="lineno"> 1835 </span><span class="decl"><span class="nottickedoff">clEmptyInnerPermCheckState = $(mkClosed [| InnerPermCheckState [] |])</span></span>
<span class="lineno"> 1836 </span>
<span class="lineno"> 1837 </span>
<span class="lineno"> 1838 </span>-- | The \&quot;inner\&quot; monad that runs inside 'PermCheckM' continuations. It can see
<span class="lineno"> 1839 </span>-- but not modify the top-level state, but it can add 'TypedBlockMapDelta's to
<span class="lineno"> 1840 </span>-- be applied later to the top-level state.
<span class="lineno"> 1841 </span>type InnerPermCheckM ext cblocks blocks tops rets =
<span class="lineno"> 1842 </span>  ReaderT (TopPermCheckState ext cblocks blocks tops rets)
<span class="lineno"> 1843 </span>  (State (Closed (InnerPermCheckState blocks tops rets)))
<span class="lineno"> 1844 </span>
<span class="lineno"> 1845 </span>
<span class="lineno"> 1846 </span>-- | The local state maintained while type-checking is the current permission
<span class="lineno"> 1847 </span>-- set and the permissions required on return from the entire function.
<span class="lineno"> 1848 </span>data PermCheckState ext blocks tops rets ps =
<span class="lineno"> 1849 </span>  PermCheckState
<span class="lineno"> 1850 </span>  {
<span class="lineno"> 1851 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stCurPerms</span></span></span>  :: !(PermSet ps),
<span class="lineno"> 1852 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stExtState</span></span></span>  :: !(PermCheckExtState ext),
<span class="lineno"> 1853 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stTopVars</span></span></span>   :: !(RAssign Name tops),
<span class="lineno"> 1854 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stCurEntry</span></span></span>  :: !(Some (TypedEntryID blocks)),
<span class="lineno"> 1855 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stVarTypes</span></span></span>  :: !(NameMap TypeRepr),
<span class="lineno"> 1856 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stUnitVar</span></span></span>   :: !(Maybe (ExprVar UnitType)),
<span class="lineno"> 1857 </span>    -- ^ An optional global unit variable that all other unit variables will be
<span class="lineno"> 1858 </span>    -- equal to
<span class="lineno"> 1859 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stPPInfo</span></span></span>    :: !PPInfo,
<span class="lineno"> 1860 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stErrPrefix</span></span></span> :: !(Maybe (Doc ())),
<span class="lineno"> 1861 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">stDebug</span></span></span>     :: ![Maybe String]
<span class="lineno"> 1862 </span>  }
<span class="lineno"> 1863 </span>
<span class="lineno"> 1864 </span>-- | Build a default, empty 'PermCheckState'
<span class="lineno"> 1865 </span>emptyPermCheckState ::
<span class="lineno"> 1866 </span>  KnownRepr ExtRepr ext =&gt;
<span class="lineno"> 1867 </span>  PermSet ps -&gt;
<span class="lineno"> 1868 </span>  RAssign ExprVar tops -&gt;
<span class="lineno"> 1869 </span>  TypedEntryID blocks args -&gt;
<span class="lineno"> 1870 </span>  [Maybe String] -&gt;
<span class="lineno"> 1871 </span>  PermCheckState ext blocks tops rets ps
<span class="lineno"> 1872 </span><span class="decl"><span class="nottickedoff">emptyPermCheckState perms tops entryID names =</span>
<span class="lineno"> 1873 </span><span class="spaces">  </span><span class="nottickedoff">PermCheckState { stCurPerms  = perms,</span>
<span class="lineno"> 1874 </span><span class="spaces">                   </span><span class="nottickedoff">stExtState  = emptyPermCheckExtState knownRepr,</span>
<span class="lineno"> 1875 </span><span class="spaces">                   </span><span class="nottickedoff">stTopVars   = tops,</span>
<span class="lineno"> 1876 </span><span class="spaces">                   </span><span class="nottickedoff">stCurEntry  = Some entryID,</span>
<span class="lineno"> 1877 </span><span class="spaces">                   </span><span class="nottickedoff">stVarTypes  = NameMap.empty,</span>
<span class="lineno"> 1878 </span><span class="spaces">                   </span><span class="nottickedoff">stUnitVar   = Nothing,</span>
<span class="lineno"> 1879 </span><span class="spaces">                   </span><span class="nottickedoff">stPPInfo    = emptyPPInfo,</span>
<span class="lineno"> 1880 </span><span class="spaces">                   </span><span class="nottickedoff">stErrPrefix = Nothing,</span>
<span class="lineno"> 1881 </span><span class="spaces">                   </span><span class="nottickedoff">stDebug     = names }</span></span>
<span class="lineno"> 1882 </span>
<span class="lineno"> 1883 </span>-- | Like the 'set' method of a lens, but allows the @ps@ argument to change
<span class="lineno"> 1884 </span>setSTCurPerms :: PermSet ps2 -&gt; PermCheckState ext blocks tops rets ps1 -&gt;
<span class="lineno"> 1885 </span>                 PermCheckState ext blocks tops rets ps2
<span class="lineno"> 1886 </span><span class="decl"><span class="nottickedoff">setSTCurPerms perms (PermCheckState {..}) =</span>
<span class="lineno"> 1887 </span><span class="spaces">  </span><span class="nottickedoff">PermCheckState { stCurPerms = perms, .. }</span></span>
<span class="lineno"> 1888 </span>
<span class="lineno"> 1889 </span>modifySTCurPerms :: (PermSet ps1 -&gt; PermSet ps2) -&gt;
<span class="lineno"> 1890 </span>                    PermCheckState ext blocks tops rets ps1 -&gt;
<span class="lineno"> 1891 </span>                    PermCheckState ext blocks tops rets ps2
<span class="lineno"> 1892 </span><span class="decl"><span class="nottickedoff">modifySTCurPerms f_perms st = setSTCurPerms (f_perms $ stCurPerms st) st</span></span>
<span class="lineno"> 1893 </span>
<span class="lineno"> 1894 </span>nextDebugName :: PermCheckM ext cblocks blocks tops rets a ps a ps (Maybe String)
<span class="lineno"> 1895 </span><span class="decl"><span class="nottickedoff">nextDebugName =</span>
<span class="lineno"> 1896 </span><span class="spaces">  </span><span class="nottickedoff">do st &lt;- get</span>
<span class="lineno"> 1897 </span><span class="spaces">     </span><span class="nottickedoff">put st { stDebug = drop 1 (stDebug st)}</span>
<span class="lineno"> 1898 </span><span class="spaces">     </span><span class="nottickedoff">pure (foldr (\x _ -&gt; x) Nothing (stDebug st))</span></span>
<span class="lineno"> 1899 </span>
<span class="lineno"> 1900 </span>-- | The generalized monad for permission-checking
<span class="lineno"> 1901 </span>type PermCheckM ext cblocks blocks tops rets r1 ps1 r2 ps2 =
<span class="lineno"> 1902 </span>  GenStateContT
<span class="lineno"> 1903 </span>    (PermCheckState ext blocks tops rets ps1) r1
<span class="lineno"> 1904 </span>    (PermCheckState ext blocks tops rets ps2) r2
<span class="lineno"> 1905 </span>    (InnerPermCheckM ext cblocks blocks tops rets)
<span class="lineno"> 1906 </span>
<span class="lineno"> 1907 </span>-- | The generalized monad for permission-checking statements
<span class="lineno"> 1908 </span>type StmtPermCheckM ext cblocks blocks tops rets ps1 ps2 =
<span class="lineno"> 1909 </span>  PermCheckM ext cblocks blocks tops rets
<span class="lineno"> 1910 </span>   (TypedStmtSeq ext blocks tops rets ps1) ps1
<span class="lineno"> 1911 </span>   (TypedStmtSeq ext blocks tops rets ps2) ps2
<span class="lineno"> 1912 </span>
<span class="lineno"> 1913 </span>-- | Lift an 'InnerPermCheckM' computation to a 'PermCheckM' computation
<span class="lineno"> 1914 </span>liftPermCheckM :: InnerPermCheckM ext cblocks blocks tops rets a -&gt;
<span class="lineno"> 1915 </span>                  PermCheckM ext cblocks blocks tops rets r ps r ps a
<span class="lineno"> 1916 </span><span class="decl"><span class="nottickedoff">liftPermCheckM = lift</span></span>
<span class="lineno"> 1917 </span>
<span class="lineno"> 1918 </span>-- | Lift an 'InnerPermCheckM' to a 'TopPermCheckM'
<span class="lineno"> 1919 </span>liftInnerToTopM :: InnerPermCheckM ext cblocks blocks tops rets a -&gt;
<span class="lineno"> 1920 </span>                   TopPermCheckM ext cblocks blocks tops rets a
<span class="lineno"> 1921 </span><span class="decl"><span class="nottickedoff">liftInnerToTopM m =</span>
<span class="lineno"> 1922 </span><span class="spaces">  </span><span class="nottickedoff">do st &lt;- get</span>
<span class="lineno"> 1923 </span><span class="spaces">     </span><span class="nottickedoff">let (a, cl_inner_st) =</span>
<span class="lineno"> 1924 </span><span class="spaces">           </span><span class="nottickedoff">runState (runReaderT m st) clEmptyInnerPermCheckState</span>
<span class="lineno"> 1925 </span><span class="spaces">     </span><span class="nottickedoff">let deltas = innerStateDeltas $ unClosed cl_inner_st</span>
<span class="lineno"> 1926 </span><span class="spaces">     </span><span class="nottickedoff">modify (applyDeltasToTopState deltas)</span>
<span class="lineno"> 1927 </span><span class="spaces">     </span><span class="nottickedoff">return a</span></span>
<span class="lineno"> 1928 </span>
<span class="lineno"> 1929 </span>-- | Get the current top-level state modulo the modifications to the current
<span class="lineno"> 1930 </span>-- block info map
<span class="lineno"> 1931 </span>top_get :: PermCheckM ext cblocks blocks tops rets r ps r ps
<span class="lineno"> 1932 </span>           (TopPermCheckState ext cblocks blocks tops rets)
<span class="lineno"> 1933 </span><span class="decl"><span class="nottickedoff">top_get = gcaptureCC $ \k -&gt;</span>
<span class="lineno"> 1934 </span><span class="spaces">  </span><span class="nottickedoff">do top_st &lt;- ask</span>
<span class="lineno"> 1935 </span><span class="spaces">     </span><span class="nottickedoff">deltas &lt;- innerStateDeltas &lt;$&gt; unClosed &lt;$&gt; get</span>
<span class="lineno"> 1936 </span><span class="spaces">     </span><span class="nottickedoff">k $ applyDeltasToTopState deltas top_st</span></span>
<span class="lineno"> 1937 </span>
<span class="lineno"> 1938 </span>-- | Get the current top-level state modulo the modifications to the current
<span class="lineno"> 1939 </span>-- block info map in an 'InnerPermCheckM' computation
<span class="lineno"> 1940 </span>inner_top_get :: InnerPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 1941 </span>                 (TopPermCheckState ext cblocks blocks tops rets)
<span class="lineno"> 1942 </span><span class="decl"><span class="nottickedoff">inner_top_get =</span>
<span class="lineno"> 1943 </span><span class="spaces">  </span><span class="nottickedoff">do top_st &lt;- ask</span>
<span class="lineno"> 1944 </span><span class="spaces">     </span><span class="nottickedoff">deltas &lt;- innerStateDeltas &lt;$&gt; unClosed &lt;$&gt; get</span>
<span class="lineno"> 1945 </span><span class="spaces">     </span><span class="nottickedoff">return $ applyDeltasToTopState deltas top_st</span></span>
<span class="lineno"> 1946 </span>
<span class="lineno"> 1947 </span>-- | Set the extension-specific state
<span class="lineno"> 1948 </span>setInputExtState :: ExtRepr ext -&gt; CruCtx as -&gt; RAssign Name as -&gt;
<span class="lineno"> 1949 </span>                    PermCheckM ext cblocks blocks tops rets r ps r ps ()
<span class="lineno"> 1950 </span><span class="decl"><span class="nottickedoff">setInputExtState ExtRepr_Unit _ _ = pure ()</span>
<span class="lineno"> 1951 </span><span class="spaces"></span><span class="nottickedoff">setInputExtState ExtRepr_LLVM tps ns</span>
<span class="lineno"> 1952 </span><span class="spaces">  </span><span class="nottickedoff">| [SomeExprVarFrame rep n] &lt;- findLLVMFrameVars tps ns</span>
<span class="lineno"> 1953 </span><span class="spaces">  </span><span class="nottickedoff">= setFramePtr rep (TypedReg n)</span>
<span class="lineno"> 1954 </span><span class="spaces"></span><span class="nottickedoff">setInputExtState ExtRepr_LLVM _ _ =</span>
<span class="lineno"> 1955 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: make sure there are not more than one frame var and/or a frame var</span>
<span class="lineno"> 1956 </span><span class="spaces">  </span><span class="nottickedoff">-- of the wrong type</span>
<span class="lineno"> 1957 </span><span class="spaces">  </span><span class="nottickedoff">pure ()</span></span>
<span class="lineno"> 1958 </span>
<span class="lineno"> 1959 </span>-- | Run a 'PermCheckM' computation for a particular entrypoint with a given set
<span class="lineno"> 1960 </span>-- of top-level arguments, local arguments, ghost variables, and permissions on
<span class="lineno"> 1961 </span>-- all three, and return a result inside a binding for these variables
<span class="lineno"> 1962 </span>--
<span class="lineno"> 1963 </span>-- Note that calls to @runPermCheckM@ should be accompanied by calls to
<span class="lineno"> 1964 </span>-- @handleUnitVars@ or @stmtHandleUnitVars@ to ensure that all unit-typed
<span class="lineno"> 1965 </span>-- variables are unified during type-checking. These functions are not currently
<span class="lineno"> 1966 </span>-- combined because @handleUnitVars@ embeds an @ImplM@ computation and someties
<span class="lineno"> 1967 </span>-- it is more convenient to combine multiple @ImplM@ computations into one.
<span class="lineno"> 1968 </span>runPermCheckM ::
<span class="lineno"> 1969 </span>  KnownRepr ExtRepr ext =&gt;
<span class="lineno"> 1970 </span>  [Maybe String] -&gt;
<span class="lineno"> 1971 </span>  TypedEntryID blocks some_args -&gt;
<span class="lineno"> 1972 </span>  CruCtx args -&gt; CruCtx ghosts -&gt; MbValuePerms ((tops :++: args) :++: ghosts) -&gt;
<span class="lineno"> 1973 </span>  (RAssign ExprVar tops -&gt; RAssign ExprVar args -&gt; RAssign ExprVar ghosts -&gt;
<span class="lineno"> 1974 </span>   DistPerms ((tops :++: args) :++: ghosts) -&gt;
<span class="lineno"> 1975 </span>   PermCheckM ext cblocks blocks tops rets
<span class="lineno"> 1976 </span>              () ps_out
<span class="lineno"> 1977 </span>              r ((tops :++: args) :++: ghosts)
<span class="lineno"> 1978 </span>              ()) -&gt;
<span class="lineno"> 1979 </span>  TopPermCheckM ext cblocks blocks tops rets (NamedMb ((tops :++: args) :++: ghosts) r)
<span class="lineno"> 1980 </span><span class="decl"><span class="nottickedoff">runPermCheckM names entryID args ghosts mb_perms_in m =</span>
<span class="lineno"> 1981 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \(TopPermCheckState {..}) -&gt;</span>
<span class="lineno"> 1982 </span><span class="spaces">  </span><span class="nottickedoff">let args_prxs = cruCtxProxies args</span>
<span class="lineno"> 1983 </span><span class="spaces">      </span><span class="nottickedoff">ghosts_prxs = cruCtxProxies ghosts</span>
<span class="lineno"> 1984 </span><span class="spaces">      </span><span class="nottickedoff">(arg_names, local_names) = initialNames args names</span>
<span class="lineno"> 1985 </span><span class="spaces">      </span><span class="nottickedoff">(dbgs, ppi) = flip runState emptyPPInfo $</span>
<span class="lineno"> 1986 </span><span class="spaces">          </span><span class="nottickedoff">do x &lt;- state (allocateDebugNames (Just &quot;top&quot;) (noNames' stTopCtx) stTopCtx)</span>
<span class="lineno"> 1987 </span><span class="spaces">             </span><span class="nottickedoff">y &lt;- state (allocateDebugNames (Just &quot;local&quot;) arg_names args)</span>
<span class="lineno"> 1988 </span><span class="spaces">             </span><span class="nottickedoff">z &lt;- state (allocateDebugNames (Just &quot;ghost&quot;) (noNames' ghosts) ghosts)</span>
<span class="lineno"> 1989 </span><span class="spaces">             </span><span class="nottickedoff">pure (x `rappend` y `rappend` z)</span>
<span class="lineno"> 1990 </span><span class="spaces">    </span><span class="nottickedoff">in</span>
<span class="lineno"> 1991 </span><span class="spaces">  </span><span class="nottickedoff">liftInnerToTopM $ strongMbMNamed $</span>
<span class="lineno"> 1992 </span><span class="spaces">  </span><span class="nottickedoff">flip nuMultiWithElim1Named (NamedMb dbgs</span>
<span class="lineno"> 1993 </span><span class="spaces">                              </span><span class="nottickedoff">(mbValuePermsToDistPerms mb_perms_in)) $ \ns perms_in -&gt;</span>
<span class="lineno"> 1994 </span><span class="spaces">  </span><span class="nottickedoff">let (tops_args, ghosts_ns) = RL.split Proxy ghosts_prxs ns</span>
<span class="lineno"> 1995 </span><span class="spaces">      </span><span class="nottickedoff">(tops_ns, args_ns) = RL.split Proxy args_prxs tops_args</span>
<span class="lineno"> 1996 </span><span class="spaces">      </span><span class="nottickedoff">st1 = emptyPermCheckState (distPermSet perms_in) tops_ns entryID local_names</span>
<span class="lineno"> 1997 </span><span class="spaces">      </span><span class="nottickedoff">st = st1 { stPPInfo = ppi } in</span>
<span class="lineno"> 1998 </span><span class="spaces">  </span><span class="nottickedoff">let go x = runGenStateContT x st (\_ () -&gt; pure ()) in</span>
<span class="lineno"> 1999 </span><span class="spaces">  </span><span class="nottickedoff">go $</span>
<span class="lineno"> 2000 </span><span class="spaces">  </span><span class="nottickedoff">setVarTypes tops_ns stTopCtx &gt;&gt;&gt;</span>
<span class="lineno"> 2001 </span><span class="spaces">  </span><span class="nottickedoff">setVarTypes args_ns args &gt;&gt;&gt;</span>
<span class="lineno"> 2002 </span><span class="spaces">  </span><span class="nottickedoff">setVarTypes ghosts_ns ghosts &gt;&gt;&gt;</span>
<span class="lineno"> 2003 </span><span class="spaces">  </span><span class="nottickedoff">modify (\s-&gt;s{ stPPInfo = ppInfoApplyAllocation ns dbgs (stPPInfo st)}) &gt;&gt;&gt;</span>
<span class="lineno"> 2004 </span><span class="spaces">  </span><span class="nottickedoff">setInputExtState knownRepr ghosts ghosts_ns &gt;&gt;&gt;</span>
<span class="lineno"> 2005 </span><span class="spaces">  </span><span class="nottickedoff">m tops_ns args_ns ghosts_ns perms_in</span></span>
<span class="lineno"> 2006 </span>
<span class="lineno"> 2007 </span>{-
<span class="lineno"> 2008 </span>explore ::
<span class="lineno"> 2009 </span>  forall tops args ghosts ext blocks cblocks ret ps r1 r2.
<span class="lineno"> 2010 </span>  KnownRepr ExtRepr ext =&gt;
<span class="lineno"> 2011 </span>  [Maybe String] -&gt;
<span class="lineno"> 2012 </span>      TypedEntryID blocks args -&gt;
<span class="lineno"> 2013 </span>      CruCtx tops -&gt;
<span class="lineno"> 2014 </span>      CruCtx args -&gt;
<span class="lineno"> 2015 </span>      CruCtx ghosts -&gt;
<span class="lineno"> 2016 </span>      MbValuePerms ((tops :++: args) :++: ghosts) -&gt;
<span class="lineno"> 2017 </span>
<span class="lineno"> 2018 </span>    (RAssign ExprVar tops -&gt; RAssign ExprVar args -&gt; RAssign ExprVar ghosts -&gt;
<span class="lineno"> 2019 </span>      DistPerms ((tops :++: args) :++: ghosts) -&gt;
<span class="lineno"> 2020 </span>      PermCheckM ext cblocks blocks tops ret r1 ps r2 ((tops :++: args)
<span class="lineno"> 2021 </span>                                                          :++: ghosts) ()) -&gt;
<span class="lineno"> 2022 </span>
<span class="lineno"> 2023 </span>      PermCheckM ext cblocks blocks tops ret r1 ps r2 ps ()
<span class="lineno"> 2024 </span>explore names entryID topCtx argCtx ghostCtx mb_perms_in m =
<span class="lineno"> 2025 </span>  let args_prxs = cruCtxProxies argCtx
<span class="lineno"> 2026 </span>      ghosts_prxs = cruCtxProxies ghostCtx
<span class="lineno"> 2027 </span>      (arg_names, local_names) = initialNames argCtx names in
<span class="lineno"> 2028 </span>
<span class="lineno"> 2029 </span>  allocateDebugNamesM (Just &quot;top&quot;) (noNames' topCtx) topCtx &gt;&gt;&gt;= \topDbgs -&gt;
<span class="lineno"> 2030 </span>  allocateDebugNamesM (Just &quot;local&quot;) arg_names argCtx &gt;&gt;&gt;= \argDbgs -&gt;
<span class="lineno"> 2031 </span>  allocateDebugNamesM (Just &quot;ghost&quot;) (noNames' ghostCtx) ghostCtx &gt;&gt;&gt;= \ghostDbgs -&gt;
<span class="lineno"> 2032 </span>  gopenBinding (fmap _ . strongMbM) (mbValuePermsToDistPerms mb_perms_in) &gt;&gt;&gt;= \(ns, perms_in) -&gt;
<span class="lineno"> 2033 </span>  let (tops_args, ghosts_ns) = RL.split Proxy ghosts_prxs ns
<span class="lineno"> 2034 </span>      (tops_ns, args_ns) = RL.split Proxy args_prxs tops_args
<span class="lineno"> 2035 </span>      st :: PermCheckState ext blocks tops ret ((tops :++: args) :++: ghosts)
<span class="lineno"> 2036 </span>      st = emptyPermCheckState (distPermSet perms_in) tops_ns entryID local_names in
<span class="lineno"> 2037 </span>
<span class="lineno"> 2038 </span>  setVarTypes tops_ns topCtx &gt;&gt;&gt;
<span class="lineno"> 2039 </span>  modify (\s-&gt;s{ stPPInfo = ppInfoApplyAllocation tops_ns topDbgs (stPPInfo st)}) &gt;&gt;&gt;
<span class="lineno"> 2040 </span>  modify (\s-&gt;s{ stPPInfo = ppInfoApplyAllocation args_ns argDbgs (stPPInfo st)}) &gt;&gt;&gt;
<span class="lineno"> 2041 </span>  modify (\s-&gt;s{ stPPInfo = ppInfoApplyAllocation ghosts_ns ghostDbgs (stPPInfo st)}) &gt;&gt;&gt;
<span class="lineno"> 2042 </span>  setInputExtState knownRepr ghostCtx ghosts_ns &gt;&gt;&gt;
<span class="lineno"> 2043 </span>  m tops_ns args_ns ghosts_ns perms_in
<span class="lineno"> 2044 </span>
<span class="lineno"> 2045 </span>  -}
<span class="lineno"> 2046 </span>
<span class="lineno"> 2047 </span>rassignLen :: RAssign f x -&gt; Int
<span class="lineno"> 2048 </span><span class="decl"><span class="nottickedoff">rassignLen = go 0</span>
<span class="lineno"> 2049 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2050 </span><span class="spaces">    </span><span class="nottickedoff">go :: Int -&gt; RAssign f x -&gt; Int</span>
<span class="lineno"> 2051 </span><span class="spaces">    </span><span class="nottickedoff">go acc MNil = acc</span>
<span class="lineno"> 2052 </span><span class="spaces">    </span><span class="nottickedoff">go acc (xs :&gt;: _) = (go $! (acc+1)) xs</span></span>
<span class="lineno"> 2053 </span>
<span class="lineno"> 2054 </span>initialNames ::
<span class="lineno"> 2055 </span>  CruCtx tps -&gt;
<span class="lineno"> 2056 </span>  [Maybe String] -&gt;
<span class="lineno"> 2057 </span>  (RAssign (Constant (Maybe String)) tps, [Maybe String])
<span class="lineno"> 2058 </span><span class="decl"><span class="nottickedoff">initialNames CruCtxNil xs = (MNil, xs)</span>
<span class="lineno"> 2059 </span><span class="spaces"></span><span class="nottickedoff">initialNames (CruCtxCons ts _) xs =</span>
<span class="lineno"> 2060 </span><span class="spaces">  </span><span class="nottickedoff">case initialNames ts xs of</span>
<span class="lineno"> 2061 </span><span class="spaces">    </span><span class="nottickedoff">(ys, z:zs) -&gt; (ys :&gt;: Constant z, zs)</span>
<span class="lineno"> 2062 </span><span class="spaces">    </span><span class="nottickedoff">(ys, []  ) -&gt; (ys :&gt;: Constant Nothing, [])</span></span>
<span class="lineno"> 2063 </span>
<span class="lineno"> 2064 </span>-- | Compute an empty debug name assignment from a known context
<span class="lineno"> 2065 </span>noNames ::
<span class="lineno"> 2066 </span>  KnownRepr CruCtx tps =&gt;
<span class="lineno"> 2067 </span>  RAssign (Constant (Maybe String)) tps
<span class="lineno"> 2068 </span><span class="decl"><span class="nottickedoff">noNames = noNames' knownRepr</span></span>
<span class="lineno"> 2069 </span>
<span class="lineno"> 2070 </span>-- | Compute an empty debug name assignment from a given context
<span class="lineno"> 2071 </span>noNames' ::
<span class="lineno"> 2072 </span>  CruCtx tps -&gt;
<span class="lineno"> 2073 </span>  RAssign (Constant (Maybe String)) tps
<span class="lineno"> 2074 </span><span class="decl"><span class="nottickedoff">noNames' CruCtxNil = MNil</span>
<span class="lineno"> 2075 </span><span class="spaces"></span><span class="nottickedoff">noNames' (CruCtxCons xs _) = noNames' xs :&gt;: Constant Nothing</span></span>
<span class="lineno"> 2076 </span>
<span class="lineno"> 2077 </span>-- | Call 'debugNames'' with a known type list.
<span class="lineno"> 2078 </span>dbgNames ::
<span class="lineno"> 2079 </span>  KnownRepr CruCtx tps =&gt;
<span class="lineno"> 2080 </span>  PermCheckM ext cblocks blocks tops rets a ps a ps
<span class="lineno"> 2081 </span>    (RAssign (Constant (Maybe String)) tps)
<span class="lineno"> 2082 </span><span class="decl"><span class="nottickedoff">dbgNames = dbgNames' knownRepr</span></span>
<span class="lineno"> 2083 </span>
<span class="lineno"> 2084 </span>-- | Pop as many local variable names from the debug information
<span class="lineno"> 2085 </span>-- as needed to populate the given type list.
<span class="lineno"> 2086 </span>dbgNames' ::
<span class="lineno"> 2087 </span>  CruCtx tps -&gt;
<span class="lineno"> 2088 </span>  PermCheckM ext cblocks blocks tops rets a ps a ps
<span class="lineno"> 2089 </span>    (RAssign (Constant (Maybe String)) tps)
<span class="lineno"> 2090 </span><span class="decl"><span class="nottickedoff">dbgNames' CruCtxNil = pure MNil</span>
<span class="lineno"> 2091 </span><span class="spaces"></span><span class="nottickedoff">dbgNames' (CruCtxCons ts _) =</span>
<span class="lineno"> 2092 </span><span class="spaces">  </span><span class="nottickedoff">do ns &lt;- dbgNames' ts</span>
<span class="lineno"> 2093 </span><span class="spaces">     </span><span class="nottickedoff">n &lt;- nextDebugName</span>
<span class="lineno"> 2094 </span><span class="spaces">     </span><span class="nottickedoff">pure (ns :&gt;: Constant n)</span></span>
<span class="lineno"> 2095 </span>
<span class="lineno"> 2096 </span>-- | Emit a 'TypedBlockMapDelta', which must be 'Closed', in an
<span class="lineno"> 2097 </span>-- 'InnerPermCheckM' computation
<span class="lineno"> 2098 </span>innerEmitDelta :: Closed (TypedBlockMapDelta blocks tops rets) -&gt;
<span class="lineno"> 2099 </span>                  InnerPermCheckM ext cblocks blocks tops rets ()
<span class="lineno"> 2100 </span><span class="decl"><span class="nottickedoff">innerEmitDelta cl_delta =</span>
<span class="lineno"> 2101 </span><span class="spaces">  </span><span class="nottickedoff">modify (clApply</span>
<span class="lineno"> 2102 </span><span class="spaces">          </span><span class="nottickedoff">($(mkClosed [| \delta st -&gt;</span>
<span class="lineno"> 2103 </span><span class="spaces">                        </span><span class="nottickedoff">st { innerStateDeltas =</span>
<span class="lineno"> 2104 </span><span class="spaces">                               </span><span class="nottickedoff">innerStateDeltas st ++ [delta] } |])</span>
<span class="lineno"> 2105 </span><span class="spaces">           </span><span class="nottickedoff">`clApply` cl_delta))</span></span>
<span class="lineno"> 2106 </span>
<span class="lineno"> 2107 </span>-- | Create a call from the current entrypoint to the specified block, passing
<span class="lineno"> 2108 </span>-- the supplied permissions, which must be closed, on local variables
<span class="lineno"> 2109 </span>callBlockWithPerms :: TypedEntryID blocks args_src -&gt;
<span class="lineno"> 2110 </span>                      TypedBlockID blocks args -&gt; CruCtx vars -&gt;
<span class="lineno"> 2111 </span>                      Closed (MbValuePerms ((tops :++: args) :++: vars)) -&gt;
<span class="lineno"> 2112 </span>                      InnerPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2113 </span>                      (TypedCallSiteID blocks args vars)
<span class="lineno"> 2114 </span><span class="decl"><span class="nottickedoff">callBlockWithPerms srcEntryID destID vars cl_perms_in =</span>
<span class="lineno"> 2115 </span><span class="spaces">  </span><span class="nottickedoff">do top_st &lt;- inner_top_get</span>
<span class="lineno"> 2116 </span><span class="spaces">     </span><span class="nottickedoff">let blk = view (stBlockMap . member (typedBlockIDMember destID)) top_st</span>
<span class="lineno"> 2117 </span><span class="spaces">     </span><span class="nottickedoff">let siteID = newCallSiteID srcEntryID vars blk</span>
<span class="lineno"> 2118 </span><span class="spaces">     </span><span class="nottickedoff">innerEmitDelta ($(mkClosed [| TypedBlockMapAddCallSite |])</span>
<span class="lineno"> 2119 </span><span class="spaces">                     </span><span class="nottickedoff">`clApply` toClosed siteID `clApply` cl_perms_in)</span>
<span class="lineno"> 2120 </span><span class="spaces">     </span><span class="nottickedoff">return siteID</span></span>
<span class="lineno"> 2121 </span>
<span class="lineno"> 2122 </span>-- | Look up the current primary permission associated with a variable
<span class="lineno"> 2123 </span>getVarPerm :: ExprVar a -&gt;
<span class="lineno"> 2124 </span>              PermCheckM ext cblocks blocks tops rets r ps r ps (ValuePerm a)
<span class="lineno"> 2125 </span><span class="decl"><span class="nottickedoff">getVarPerm x = gets (view (varPerm x) . stCurPerms)</span></span>
<span class="lineno"> 2126 </span>
<span class="lineno"> 2127 </span>-- | Set the current primary permission associated with a variable
<span class="lineno"> 2128 </span>setVarPerm :: ExprVar a -&gt; ValuePerm a -&gt;
<span class="lineno"> 2129 </span>              PermCheckM ext cblocks blocks tops rets r ps r ps ()
<span class="lineno"> 2130 </span><span class="decl"><span class="nottickedoff">setVarPerm x p = modify (modifySTCurPerms (set (varPerm x) p))</span></span>
<span class="lineno"> 2131 </span>
<span class="lineno"> 2132 </span>-- | Look up the current primary permission associated with a register
<span class="lineno"> 2133 </span>getRegPerm :: TypedReg a -&gt;
<span class="lineno"> 2134 </span>              PermCheckM ext cblocks blocks tops rets r ps r ps (ValuePerm a)
<span class="lineno"> 2135 </span><span class="decl"><span class="nottickedoff">getRegPerm (TypedReg x) = getVarPerm x</span></span>
<span class="lineno"> 2136 </span>
<span class="lineno"> 2137 </span>-- | Eliminate any disjunctions, existentials, or recursive permissions for a
<span class="lineno"> 2138 </span>-- register and then return the resulting \&quot;simple\&quot; permission, leaving it on the
<span class="lineno"> 2139 </span>-- top of the stack
<span class="lineno"> 2140 </span>getPushSimpleRegPerm :: PermCheckExtC ext exprExt =&gt; TypedReg a -&gt;
<span class="lineno"> 2141 </span>                        StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2142 </span>                        (ps :&gt; a) ps (ValuePerm a)
<span class="lineno"> 2143 </span><span class="decl"><span class="nottickedoff">getPushSimpleRegPerm r =</span>
<span class="lineno"> 2144 </span><span class="spaces">  </span><span class="nottickedoff">getRegPerm r &gt;&gt;&gt;= \p_init -&gt;</span>
<span class="lineno"> 2145 </span><span class="spaces">  </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx</span>
<span class="lineno"> 2146 </span><span class="spaces">  </span><span class="nottickedoff">(implPushM (typedRegVar r) p_init &gt;&gt;&gt;</span>
<span class="lineno"> 2147 </span><span class="spaces">   </span><span class="nottickedoff">elimOrsExistsNamesM (typedRegVar r)) &gt;&gt;&gt;= \(_, p_ret) -&gt;</span>
<span class="lineno"> 2148 </span><span class="spaces">  </span><span class="nottickedoff">pure p_ret</span></span>
<span class="lineno"> 2149 </span>
<span class="lineno"> 2150 </span>-- | Eliminate any disjunctions, existentials, or recursive permissions for a
<span class="lineno"> 2151 </span>-- register and then return the resulting \&quot;simple\&quot; permission
<span class="lineno"> 2152 </span>getSimpleRegPerm :: PermCheckExtC ext exprExt =&gt; TypedReg a -&gt;
<span class="lineno"> 2153 </span>                    StmtPermCheckM ext cblocks blocks tops rets ps ps
<span class="lineno"> 2154 </span>                    (ValuePerm a)
<span class="lineno"> 2155 </span><span class="decl"><span class="nottickedoff">getSimpleRegPerm r =</span>
<span class="lineno"> 2156 </span><span class="spaces">  </span><span class="nottickedoff">snd &lt;$&gt; pcmEmbedImplM TypedImplStmt emptyCruCtx (getSimpleVarPerm $</span>
<span class="lineno"> 2157 </span><span class="spaces">                                                   </span><span class="nottickedoff">typedRegVar r)</span></span>
<span class="lineno"> 2158 </span>
<span class="lineno"> 2159 </span>-- | A version of 'getEqualsExpr' for 'TypedReg's
<span class="lineno"> 2160 </span>getRegEqualsExpr ::
<span class="lineno"> 2161 </span>  PermCheckExtC ext exprExt =&gt; TypedReg a -&gt;
<span class="lineno"> 2162 </span>  StmtPermCheckM ext cblocks blocks tops rets ps ps (PermExpr a)
<span class="lineno"> 2163 </span><span class="decl"><span class="nottickedoff">getRegEqualsExpr r =</span>
<span class="lineno"> 2164 </span><span class="spaces">  </span><span class="nottickedoff">snd &lt;$&gt; pcmEmbedImplM TypedImplStmt emptyCruCtx (getEqualsExpr $</span>
<span class="lineno"> 2165 </span><span class="spaces">                                                   </span><span class="nottickedoff">PExpr_Var $ typedRegVar r)</span></span>
<span class="lineno"> 2166 </span>
<span class="lineno"> 2167 </span>-- | Eliminate any disjunctions, existentials, recursive permissions, or
<span class="lineno"> 2168 </span>-- equality permissions for an LLVM register until we either get a conjunctive
<span class="lineno"> 2169 </span>-- permission for it or we get that it is equal to a bitvector word. In either
<span class="lineno"> 2170 </span>-- case, leave the resulting permission on the top of the stack and return its
<span class="lineno"> 2171 </span>-- contents as the return value.
<span class="lineno"> 2172 </span>getAtomicOrWordLLVMPerms ::
<span class="lineno"> 2173 </span>  (1 &lt;= w, KnownNat w, PermCheckExtC ext exprExt) =&gt; TypedReg (LLVMPointerType w) -&gt;
<span class="lineno"> 2174 </span>  StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2175 </span>  (ps :&gt; LLVMPointerType w)
<span class="lineno"> 2176 </span>  ps
<span class="lineno"> 2177 </span>  (Either (PermExpr (BVType w)) [AtomicPerm (LLVMPointerType w)])
<span class="lineno"> 2178 </span><span class="decl"><span class="nottickedoff">getAtomicOrWordLLVMPerms r =</span>
<span class="lineno"> 2179 </span><span class="spaces">  </span><span class="nottickedoff">let x = typedRegVar r in</span>
<span class="lineno"> 2180 </span><span class="spaces">  </span><span class="nottickedoff">getPushSimpleRegPerm r &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 2181 </span><span class="spaces">  </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 2182 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Conj ps -&gt;</span>
<span class="lineno"> 2183 </span><span class="spaces">      </span><span class="nottickedoff">pure $ Right ps</span>
<span class="lineno"> 2184 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq (PExpr_Var y) -&gt;</span>
<span class="lineno"> 2185 </span><span class="spaces">      </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx</span>
<span class="lineno"> 2186 </span><span class="spaces">      </span><span class="nottickedoff">(introEqCopyM x (PExpr_Var y) &gt;&gt;&gt; recombinePerm x p) &gt;&gt;&gt;</span>
<span class="lineno"> 2187 </span><span class="spaces">      </span><span class="nottickedoff">getAtomicOrWordLLVMPerms (TypedReg y) &gt;&gt;&gt;= \eith -&gt;</span>
<span class="lineno"> 2188 </span><span class="spaces">      </span><span class="nottickedoff">case eith of</span>
<span class="lineno"> 2189 </span><span class="spaces">        </span><span class="nottickedoff">Left e -&gt;</span>
<span class="lineno"> 2190 </span><span class="spaces">          </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx</span>
<span class="lineno"> 2191 </span><span class="spaces">          </span><span class="nottickedoff">(introCastM x y $ ValPerm_Eq $ PExpr_LLVMWord e) &gt;&gt;&gt;</span>
<span class="lineno"> 2192 </span><span class="spaces">          </span><span class="nottickedoff">pure (Left e)</span>
<span class="lineno"> 2193 </span><span class="spaces">        </span><span class="nottickedoff">Right ps -&gt;</span>
<span class="lineno"> 2194 </span><span class="spaces">          </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx (introCastM x y $</span>
<span class="lineno"> 2195 </span><span class="spaces">                                                   </span><span class="nottickedoff">ValPerm_Conj ps) &gt;&gt;&gt;</span>
<span class="lineno"> 2196 </span><span class="spaces">          </span><span class="nottickedoff">pure (Right ps)</span>
<span class="lineno"> 2197 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq e@(PExpr_LLVMOffset y off) -&gt;</span>
<span class="lineno"> 2198 </span><span class="spaces">      </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx</span>
<span class="lineno"> 2199 </span><span class="spaces">      </span><span class="nottickedoff">(introEqCopyM x e &gt;&gt;&gt; recombinePerm x p) &gt;&gt;&gt;</span>
<span class="lineno"> 2200 </span><span class="spaces">      </span><span class="nottickedoff">getAtomicOrWordLLVMPerms (TypedReg y) &gt;&gt;&gt;= \eith -&gt;</span>
<span class="lineno"> 2201 </span><span class="spaces">      </span><span class="nottickedoff">case eith of</span>
<span class="lineno"> 2202 </span><span class="spaces">        </span><span class="nottickedoff">Left e' -&gt;</span>
<span class="lineno"> 2203 </span><span class="spaces">          </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx (offsetLLVMWordM</span>
<span class="lineno"> 2204 </span><span class="spaces">                                                   </span><span class="nottickedoff">y e' off x) &gt;&gt;&gt;</span>
<span class="lineno"> 2205 </span><span class="spaces">          </span><span class="nottickedoff">pure (Left $ bvAdd e' off)</span>
<span class="lineno"> 2206 </span><span class="spaces">        </span><span class="nottickedoff">Right ps -&gt;</span>
<span class="lineno"> 2207 </span><span class="spaces">          </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx (castLLVMPtrM</span>
<span class="lineno"> 2208 </span><span class="spaces">                                                   </span><span class="nottickedoff">y (ValPerm_Conj ps) off x) &gt;&gt;&gt;</span>
<span class="lineno"> 2209 </span><span class="spaces">          </span><span class="nottickedoff">pure (Right $ mapMaybe (offsetLLVMAtomicPerm $ bvNegate off) ps)</span>
<span class="lineno"> 2210 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq e@(PExpr_LLVMWord e_word) -&gt;</span>
<span class="lineno"> 2211 </span><span class="spaces">      </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx (introEqCopyM x e &gt;&gt;&gt;</span>
<span class="lineno"> 2212 </span><span class="spaces">                                               </span><span class="nottickedoff">recombinePerm x p) &gt;&gt;&gt;</span>
<span class="lineno"> 2213 </span><span class="spaces">      </span><span class="nottickedoff">pure (Left e_word)</span>
<span class="lineno"> 2214 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 2215 </span><span class="spaces">      </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 2216 </span><span class="spaces">        </span><span class="nottickedoff">stmtFailM $ AtomicPermError (permPretty ppinfo r) (permPretty ppinfo p)</span></span>
<span class="lineno"> 2217 </span>
<span class="lineno"> 2218 </span>
<span class="lineno"> 2219 </span>-- | Like 'getAtomicOrWordLLVMPerms', but fail if an equality permission to a
<span class="lineno"> 2220 </span>-- bitvector word is found
<span class="lineno"> 2221 </span>getAtomicLLVMPerms :: (1 &lt;= w, KnownNat w, PermCheckExtC ext exprExt) =&gt;
<span class="lineno"> 2222 </span>                      TypedReg (LLVMPointerType w) -&gt;
<span class="lineno"> 2223 </span>                      StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2224 </span>                      (ps :&gt; LLVMPointerType w)
<span class="lineno"> 2225 </span>                      ps
<span class="lineno"> 2226 </span>                      [AtomicPerm (LLVMPointerType w)]
<span class="lineno"> 2227 </span><span class="decl"><span class="nottickedoff">getAtomicLLVMPerms r =</span>
<span class="lineno"> 2228 </span><span class="spaces">  </span><span class="nottickedoff">getAtomicOrWordLLVMPerms r &gt;&gt;&gt;= \eith -&gt;</span>
<span class="lineno"> 2229 </span><span class="spaces">  </span><span class="nottickedoff">case eith of</span>
<span class="lineno"> 2230 </span><span class="spaces">    </span><span class="nottickedoff">Right ps -&gt; pure ps</span>
<span class="lineno"> 2231 </span><span class="spaces">    </span><span class="nottickedoff">Left e -&gt;</span>
<span class="lineno"> 2232 </span><span class="spaces">      </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 2233 </span><span class="spaces">        </span><span class="nottickedoff">stmtFailM $ AtomicPermError</span>
<span class="lineno"> 2234 </span><span class="spaces">                      </span><span class="nottickedoff">(permPretty ppinfo r)</span>
<span class="lineno"> 2235 </span><span class="spaces">                      </span><span class="nottickedoff">(permPretty ppinfo (ValPerm_Eq $ PExpr_LLVMWord e))</span></span>
<span class="lineno"> 2236 </span>
<span class="lineno"> 2237 </span>
<span class="lineno"> 2238 </span>data SomeExprVarFrame where
<span class="lineno"> 2239 </span>  SomeExprVarFrame ::
<span class="lineno"> 2240 </span>    NatRepr w -&gt;
<span class="lineno"> 2241 </span>    ExprVar (LLVMFrameType w) -&gt;
<span class="lineno"> 2242 </span>    SomeExprVarFrame
<span class="lineno"> 2243 </span>
<span class="lineno"> 2244 </span>-- | Find all the variables of LLVM frame pointer type in a sequence
<span class="lineno"> 2245 </span>-- FIXME: move to Permissions.hs
<span class="lineno"> 2246 </span>findLLVMFrameVars ::
<span class="lineno"> 2247 </span>  CruCtx as -&gt; RAssign Name as -&gt;
<span class="lineno"> 2248 </span>  [SomeExprVarFrame]
<span class="lineno"> 2249 </span><span class="decl"><span class="nottickedoff">findLLVMFrameVars CruCtxNil _ = []</span>
<span class="lineno"> 2250 </span><span class="spaces"></span><span class="nottickedoff">findLLVMFrameVars (CruCtxCons tps (LLVMFrameRepr w')) (ns :&gt;: n) =</span>
<span class="lineno"> 2251 </span><span class="spaces">    </span><span class="nottickedoff">SomeExprVarFrame w' n : findLLVMFrameVars tps ns</span>
<span class="lineno"> 2252 </span><span class="spaces"></span><span class="nottickedoff">findLLVMFrameVars (CruCtxCons tps _) (ns :&gt;: _) = findLLVMFrameVars tps ns</span></span>
<span class="lineno"> 2253 </span>
<span class="lineno"> 2254 </span>
<span class="lineno"> 2255 </span>-- | Get the current frame pointer on LLVM architectures
<span class="lineno"> 2256 </span>getFramePtr ::
<span class="lineno"> 2257 </span>  NatRepr w -&gt;
<span class="lineno"> 2258 </span>  PermCheckM LLVM cblocks blocks tops rets r ps r ps
<span class="lineno"> 2259 </span>    (Maybe (TypedReg (LLVMFrameType w)))
<span class="lineno"> 2260 </span><span class="decl"><span class="nottickedoff">getFramePtr w =</span>
<span class="lineno"> 2261 </span><span class="spaces">  </span><span class="nottickedoff">gets stExtState &gt;&gt;= \case</span>
<span class="lineno"> 2262 </span><span class="spaces">    </span><span class="nottickedoff">PermCheckExtState_LLVM (Just (SomeFrameReg rep fp))</span>
<span class="lineno"> 2263 </span><span class="spaces">      </span><span class="nottickedoff">| Just Refl &lt;- testEquality rep w -&gt; pure (Just fp)</span>
<span class="lineno"> 2264 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; pure Nothing</span></span>
<span class="lineno"> 2265 </span>
<span class="lineno"> 2266 </span>-- | Set the current frame pointer on LLVM architectures
<span class="lineno"> 2267 </span>setFramePtr ::
<span class="lineno"> 2268 </span>  NatRepr w -&gt;
<span class="lineno"> 2269 </span>  TypedReg (LLVMFrameType w) -&gt;
<span class="lineno"> 2270 </span>  PermCheckM LLVM cblocks blocks tops rets r ps r ps ()
<span class="lineno"> 2271 </span><span class="decl"><span class="nottickedoff">setFramePtr rep fp =</span>
<span class="lineno"> 2272 </span><span class="spaces">  </span><span class="nottickedoff">modify (\st -&gt; st { stExtState = PermCheckExtState_LLVM (Just (SomeFrameReg rep fp)) })</span></span>
<span class="lineno"> 2273 </span>
<span class="lineno"> 2274 </span>-- | Look up the type of a free variable, or raise an error if it is unknown
<span class="lineno"> 2275 </span>getVarType :: ExprVar a -&gt;
<span class="lineno"> 2276 </span>              PermCheckM ext cblocks blocks tops rets r ps r ps (TypeRepr a)
<span class="lineno"> 2277 </span><span class="decl"><span class="nottickedoff">getVarType x =</span>
<span class="lineno"> 2278 </span><span class="spaces">  </span><span class="nottickedoff">gets (NameMap.lookup x . stVarTypes) &gt;&gt;= \case</span>
<span class="lineno"> 2279 </span><span class="spaces">    </span><span class="nottickedoff">Just tp -&gt; pure tp</span>
<span class="lineno"> 2280 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 2281 </span><span class="spaces">      </span><span class="nottickedoff">stmtTraceM (\i -&gt; pretty &quot;getVarType: could not find type for variable:&quot;</span>
<span class="lineno"> 2282 </span><span class="spaces">                        </span><span class="nottickedoff">&lt;+&gt; permPretty i x) &gt;&gt;&gt;</span>
<span class="lineno"> 2283 </span><span class="spaces">      </span><span class="nottickedoff">error &quot;getVarType&quot;</span></span>
<span class="lineno"> 2284 </span>
<span class="lineno"> 2285 </span>-- | Look up the types of multiple free variables
<span class="lineno"> 2286 </span>getVarTypes :: RAssign Name tps -&gt;
<span class="lineno"> 2287 </span>               PermCheckM ext cblocks blocks tops rets r ps r ps (CruCtx tps)
<span class="lineno"> 2288 </span><span class="decl"><span class="nottickedoff">getVarTypes MNil = pure CruCtxNil</span>
<span class="lineno"> 2289 </span><span class="spaces"></span><span class="nottickedoff">getVarTypes (xs :&gt;: x) = CruCtxCons &lt;$&gt; getVarTypes xs &lt;*&gt; getVarType x</span></span>
<span class="lineno"> 2290 </span>
<span class="lineno"> 2291 </span>-- | Output a string representing a variable given optional information such as
<span class="lineno"> 2292 </span>-- a base name and a C name
<span class="lineno"> 2293 </span>dbgStringPP ::
<span class="lineno"> 2294 </span>  Maybe String {- ^ The base name of the variable (e.g., &quot;top&quot;, &quot;arg&quot;, etc.) -} -&gt;
<span class="lineno"> 2295 </span>  Maybe String {- ^ The C name of the variable, if applicable -} -&gt;
<span class="lineno"> 2296 </span>  TypeRepr a {- ^ The type of the variable -} -&gt;
<span class="lineno"> 2297 </span>  String
<span class="lineno"> 2298 </span><span class="decl"><span class="nottickedoff">dbgStringPP _          (Just d) _  = &quot;C[&quot; ++ d ++ &quot;]&quot;</span>
<span class="lineno"> 2299 </span><span class="spaces"></span><span class="nottickedoff">dbgStringPP (Just str) _        tp = str ++ &quot;_&quot; ++ typeBaseName tp</span>
<span class="lineno"> 2300 </span><span class="spaces"></span><span class="nottickedoff">dbgStringPP Nothing    Nothing  tp = typeBaseName tp</span></span>
<span class="lineno"> 2301 </span>
<span class="lineno"> 2302 </span>
<span class="lineno"> 2303 </span>-- | After all variables have been added to the context, unify all unit-typed
<span class="lineno"> 2304 </span>-- variables by lifting through the ImplM monad
<span class="lineno"> 2305 </span>stmtHandleUnitVars :: forall (tps :: RList CrucibleType)
<span class="lineno"> 2306 </span>                             ext cblocks blocks tops ret ps exprExt.
<span class="lineno"> 2307 </span>                      PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 2308 </span>                      RAssign Name tps -&gt;
<span class="lineno"> 2309 </span>                      StmtPermCheckM ext cblocks blocks tops ret ps ps ()
<span class="lineno"> 2310 </span><span class="decl"><span class="nottickedoff">stmtHandleUnitVars ns =</span>
<span class="lineno"> 2311 </span><span class="spaces">    </span><span class="nottickedoff">stmtEmbedImplM $ handleUnitVars ns</span></span>
<span class="lineno"> 2312 </span>
<span class="lineno"> 2313 </span>-- | Remember the type of a free variable, and ensure that it has a permission
<span class="lineno"> 2314 </span>setVarType ::
<span class="lineno"> 2315 </span>  ExprVar a -&gt; -- ^ The Hobbits variable itself
<span class="lineno"> 2316 </span>  TypeRepr a -&gt; -- ^ The type of the variable
<span class="lineno"> 2317 </span>  PermCheckM ext cblocks blocks tops ret r ps r ps ()
<span class="lineno"> 2318 </span><span class="decl"><span class="nottickedoff">setVarType x tp =</span>
<span class="lineno"> 2319 </span><span class="spaces">  </span><span class="nottickedoff">modify $ \st -&gt;</span>
<span class="lineno"> 2320 </span><span class="spaces">  </span><span class="nottickedoff">st { stCurPerms = initVarPerm x (stCurPerms st),</span>
<span class="lineno"> 2321 </span><span class="spaces">       </span><span class="nottickedoff">stVarTypes = NameMap.insert x tp (stVarTypes st) }</span></span>
<span class="lineno"> 2322 </span>
<span class="lineno"> 2323 </span>-- | Remember the types of a sequence of free variables
<span class="lineno"> 2324 </span>setVarTypes ::
<span class="lineno"> 2325 </span>  RAssign Name tps -&gt;
<span class="lineno"> 2326 </span>  CruCtx tps -&gt;
<span class="lineno"> 2327 </span>  PermCheckM ext cblocks blocks tops ret r ps r ps ()
<span class="lineno"> 2328 </span><span class="decl"><span class="nottickedoff">setVarTypes MNil CruCtxNil = pure ()</span>
<span class="lineno"> 2329 </span><span class="spaces"></span><span class="nottickedoff">setVarTypes (ns :&gt;: n) (CruCtxCons ts t) =</span>
<span class="lineno"> 2330 </span><span class="spaces">  </span><span class="nottickedoff">do setVarTypes ns ts</span>
<span class="lineno"> 2331 </span><span class="spaces">     </span><span class="nottickedoff">setVarType n t</span></span>
<span class="lineno"> 2332 </span>
<span class="lineno"> 2333 </span>allocateDebugNames ::
<span class="lineno"> 2334 </span>  Maybe String -&gt; -- ^ The base name of the variable (e.g., \&quot;top\&quot;, \&quot;arg\&quot;, etc.)
<span class="lineno"> 2335 </span>  RAssign (Constant (Maybe String)) tps -&gt;
<span class="lineno"> 2336 </span>  CruCtx tps -&gt;
<span class="lineno"> 2337 </span>  PPInfo -&gt;
<span class="lineno"> 2338 </span>  (RAssign StringF tps, PPInfo)
<span class="lineno"> 2339 </span><span class="decl"><span class="nottickedoff">allocateDebugNames _ MNil _ ppi = (MNil, ppi)</span>
<span class="lineno"> 2340 </span><span class="spaces"></span><span class="nottickedoff">allocateDebugNames base (ds :&gt;: Constant dbg) (CruCtxCons ts tp) ppi =</span>
<span class="lineno"> 2341 </span><span class="spaces">  </span><span class="nottickedoff">case allocateDebugNames base ds ts ppi of</span>
<span class="lineno"> 2342 </span><span class="spaces">    </span><span class="nottickedoff">(outs, ppi1) -&gt;</span>
<span class="lineno"> 2343 </span><span class="spaces">      </span><span class="nottickedoff">case ppInfoAllocateName str ppi1 of</span>
<span class="lineno"> 2344 </span><span class="spaces">        </span><span class="nottickedoff">(ppi2, out) -&gt; (outs :&gt;: StringF out, ppi2)</span>
<span class="lineno"> 2345 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 2346 </span><span class="spaces">    </span><span class="nottickedoff">str =</span>
<span class="lineno"> 2347 </span><span class="spaces">      </span><span class="nottickedoff">case (base,dbg) of</span>
<span class="lineno"> 2348 </span><span class="spaces">        </span><span class="nottickedoff">(_,Just d) -&gt; &quot;C[&quot; ++ d ++ &quot;]&quot;</span>
<span class="lineno"> 2349 </span><span class="spaces">        </span><span class="nottickedoff">(Just b,_) -&gt; b ++ &quot;_&quot; ++ typeBaseName tp</span>
<span class="lineno"> 2350 </span><span class="spaces">        </span><span class="nottickedoff">(Nothing,Nothing) -&gt; typeBaseName tp</span></span>
<span class="lineno"> 2351 </span>
<span class="lineno"> 2352 </span>
<span class="lineno"> 2353 </span>allocateDebugNamesM ::
<span class="lineno"> 2354 </span>  Maybe String -&gt; -- ^ The base name of the variable (e.g., \&quot;top\&quot;, \&quot;arg\&quot;, etc.)
<span class="lineno"> 2355 </span>  RAssign (Constant (Maybe String)) tps -&gt;
<span class="lineno"> 2356 </span>  CruCtx tps -&gt;
<span class="lineno"> 2357 </span>  PermCheckM ext cblocks blocks tops ret r ps r ps
<span class="lineno"> 2358 </span>    (RAssign StringF tps)
<span class="lineno"> 2359 </span><span class="decl"><span class="nottickedoff">allocateDebugNamesM base ds tps =</span>
<span class="lineno"> 2360 </span><span class="spaces">  </span><span class="nottickedoff">do ppi &lt;- permGetPPInfo</span>
<span class="lineno"> 2361 </span><span class="spaces">     </span><span class="nottickedoff">let (strs, ppi') = allocateDebugNames base ds tps ppi</span>
<span class="lineno"> 2362 </span><span class="spaces">     </span><span class="nottickedoff">gmodify $ \st -&gt; st { stPPInfo = ppi' }</span>
<span class="lineno"> 2363 </span><span class="spaces">     </span><span class="nottickedoff">return strs</span></span>
<span class="lineno"> 2364 </span>
<span class="lineno"> 2365 </span>-- | Emit debugging output at the given 'DebugLevel'
<span class="lineno"> 2366 </span>stmtDebugM :: DebugLevel -&gt; (PPInfo -&gt; Doc ()) -&gt;
<span class="lineno"> 2367 </span>              PermCheckM ext cblocks blocks tops ret r ps r ps String
<span class="lineno"> 2368 </span><span class="decl"><span class="nottickedoff">stmtDebugM reqlvl f =</span>
<span class="lineno"> 2369 </span><span class="spaces">  </span><span class="nottickedoff">do dlevel &lt;- stDebugLevel &lt;$&gt; top_get</span>
<span class="lineno"> 2370 </span><span class="spaces">     </span><span class="nottickedoff">doc &lt;- f &lt;$&gt; permGetPPInfo</span>
<span class="lineno"> 2371 </span><span class="spaces">     </span><span class="nottickedoff">let str = renderDoc doc</span>
<span class="lineno"> 2372 </span><span class="spaces">     </span><span class="nottickedoff">debugTrace reqlvl dlevel str (return str)</span></span>
<span class="lineno"> 2373 </span>
<span class="lineno"> 2374 </span>-- | Emit debugging output at 'traceDebugLevel'
<span class="lineno"> 2375 </span>stmtTraceM :: (PPInfo -&gt; Doc ()) -&gt;
<span class="lineno"> 2376 </span>              PermCheckM ext cblocks blocks tops ret r ps r ps String
<span class="lineno"> 2377 </span><span class="decl"><span class="nottickedoff">stmtTraceM = stmtDebugM traceDebugLevel</span></span>
<span class="lineno"> 2378 </span>
<span class="lineno"> 2379 </span>-- | Emit debugging output at 'verboseDebugLevel'
<span class="lineno"> 2380 </span>stmtVerbTraceM :: (PPInfo -&gt; Doc ()) -&gt;
<span class="lineno"> 2381 </span>                  PermCheckM ext cblocks blocks tops ret r ps r ps String
<span class="lineno"> 2382 </span><span class="decl"><span class="nottickedoff">stmtVerbTraceM = stmtDebugM verboseDebugLevel</span></span>
<span class="lineno"> 2383 </span>
<span class="lineno"> 2384 </span>-- | FIXME HERE: Make 'ImplM' quantify over any underlying monad, so that we do
<span class="lineno"> 2385 </span>-- not have to use 'traversePermImpl' after we run an 'ImplM'
<span class="lineno"> 2386 </span>data WithImplState vars a ps ps' =
<span class="lineno"> 2387 </span>  WithImplState a (ImplState vars ps) (ps' :~: ps)
<span class="lineno"> 2388 </span>
<span class="lineno"> 2389 </span>-- | Run a 'PermCheckM' computation in a locally-scoped way, where all effects
<span class="lineno"> 2390 </span>-- are restricted to the local computation. This is essentially a form of the
<span class="lineno"> 2391 </span>-- @reset@ operation of delimited continuations.
<span class="lineno"> 2392 </span>--
<span class="lineno"> 2393 </span>-- FIXME: this is not used, but is still here in case we need it later...
<span class="lineno"> 2394 </span>localPermCheckM ::
<span class="lineno"> 2395 </span>  PermCheckM ext cblocks blocks tops rets r_out ps_out r_in ps_in r_out -&gt;
<span class="lineno"> 2396 </span>  PermCheckM ext cblocks blocks tops rets r' ps_in r' ps_in r_in
<span class="lineno"> 2397 </span><span class="decl"><span class="nottickedoff">localPermCheckM m =</span>
<span class="lineno"> 2398 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \st -&gt;</span>
<span class="lineno"> 2399 </span><span class="spaces">  </span><span class="nottickedoff">liftPermCheckM (runGenStateContT m st (\_ -&gt; pure))</span></span>
<span class="lineno"> 2400 </span>
<span class="lineno"> 2401 </span>-- | Call 'runImplM' in the 'PermCheckM' monad
<span class="lineno"> 2402 </span>pcmRunImplM ::
<span class="lineno"> 2403 </span>  HasCallStack =&gt;
<span class="lineno"> 2404 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 2405 </span>  CruCtx vars -&gt; Doc () -&gt; (a -&gt; r ps_out) -&gt;
<span class="lineno"> 2406 </span>  ImplM vars (InnerPermCheckState blocks tops rets) r ps_out ps_in a -&gt;
<span class="lineno"> 2407 </span>  PermCheckM ext cblocks blocks tops rets r' ps_in r' ps_in
<span class="lineno"> 2408 </span>  (AnnotPermImpl r ps_in)
<span class="lineno"> 2409 </span><span class="decl"><span class="nottickedoff">pcmRunImplM vars fail_doc retF impl_m =</span>
<span class="lineno"> 2410 </span><span class="spaces">  </span><span class="nottickedoff">getErrorPrefix &gt;&gt;&gt;= \err_prefix -&gt;</span>
<span class="lineno"> 2411 </span><span class="spaces">  </span><span class="nottickedoff">(stPermEnv &lt;$&gt; top_get) &gt;&gt;&gt;= \env -&gt;</span>
<span class="lineno"> 2412 </span><span class="spaces">  </span><span class="nottickedoff">gets stCurPerms &gt;&gt;&gt;= \perms_in -&gt;</span>
<span class="lineno"> 2413 </span><span class="spaces">  </span><span class="nottickedoff">gets stPPInfo   &gt;&gt;&gt;= \ppInfo   -&gt;</span>
<span class="lineno"> 2414 </span><span class="spaces">  </span><span class="nottickedoff">gets stVarTypes &gt;&gt;&gt;= \varTypes -&gt;</span>
<span class="lineno"> 2415 </span><span class="spaces">  </span><span class="nottickedoff">gets stUnitVar  &gt;&gt;&gt;= \unitVar  -&gt;</span>
<span class="lineno"> 2416 </span><span class="spaces">  </span><span class="nottickedoff">(stEndianness &lt;$&gt; top_get) &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 2417 </span><span class="spaces">  </span><span class="nottickedoff">(stDebugLevel &lt;$&gt; top_get) &gt;&gt;&gt;= \dlevel -&gt;</span>
<span class="lineno"> 2418 </span><span class="spaces">  </span><span class="nottickedoff">liftPermCheckM $ lift $</span>
<span class="lineno"> 2419 </span><span class="spaces">  </span><span class="nottickedoff">fmap (AnnotPermImpl (renderDoc (err_prefix &lt;&gt; line &lt;&gt; fail_doc))) $</span>
<span class="lineno"> 2420 </span><span class="spaces">  </span><span class="nottickedoff">runImplM vars perms_in env ppInfo &quot;&quot; dlevel varTypes unitVar endianness impl_m</span>
<span class="lineno"> 2421 </span><span class="spaces">  </span><span class="nottickedoff">(return . retF . fst)</span></span>
<span class="lineno"> 2422 </span>
<span class="lineno"> 2423 </span>-- | Call 'runImplImplM' in the 'PermCheckM' monad
<span class="lineno"> 2424 </span>pcmRunImplImplM ::
<span class="lineno"> 2425 </span>  HasCallStack =&gt;
<span class="lineno"> 2426 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 2427 </span>  CruCtx vars -&gt; Doc () -&gt;
<span class="lineno"> 2428 </span>  ImplM vars (InnerPermCheckState blocks tops rets) r ps_out ps_in (PermImpl
<span class="lineno"> 2429 </span>                                                                    r ps_out) -&gt;
<span class="lineno"> 2430 </span>  PermCheckM ext cblocks blocks tops rets r' ps_in r' ps_in
<span class="lineno"> 2431 </span>  (AnnotPermImpl r ps_in)
<span class="lineno"> 2432 </span><span class="decl"><span class="nottickedoff">pcmRunImplImplM vars fail_doc impl_m =</span>
<span class="lineno"> 2433 </span><span class="spaces">  </span><span class="nottickedoff">getErrorPrefix &gt;&gt;&gt;= \err_prefix -&gt;</span>
<span class="lineno"> 2434 </span><span class="spaces">  </span><span class="nottickedoff">(stPermEnv &lt;$&gt; top_get) &gt;&gt;&gt;= \env -&gt;</span>
<span class="lineno"> 2435 </span><span class="spaces">  </span><span class="nottickedoff">gets stCurPerms &gt;&gt;&gt;= \perms_in -&gt;</span>
<span class="lineno"> 2436 </span><span class="spaces">  </span><span class="nottickedoff">gets stPPInfo   &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2437 </span><span class="spaces">  </span><span class="nottickedoff">gets stVarTypes &gt;&gt;&gt;= \varTypes -&gt;</span>
<span class="lineno"> 2438 </span><span class="spaces">  </span><span class="nottickedoff">gets stUnitVar  &gt;&gt;&gt;= \unitVar -&gt;</span>
<span class="lineno"> 2439 </span><span class="spaces">  </span><span class="nottickedoff">(stEndianness &lt;$&gt; top_get) &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 2440 </span><span class="spaces">  </span><span class="nottickedoff">(stDebugLevel &lt;$&gt; top_get) &gt;&gt;&gt;= \dlevel -&gt;</span>
<span class="lineno"> 2441 </span><span class="spaces">  </span><span class="nottickedoff">liftPermCheckM $ lift $</span>
<span class="lineno"> 2442 </span><span class="spaces">  </span><span class="nottickedoff">fmap (AnnotPermImpl (renderDoc (err_prefix &lt;&gt; line &lt;&gt; fail_doc))) $</span>
<span class="lineno"> 2443 </span><span class="spaces">  </span><span class="nottickedoff">runImplImplM vars perms_in env ppInfo &quot;&quot; dlevel varTypes unitVar endianness impl_m</span></span>
<span class="lineno"> 2444 </span>
<span class="lineno"> 2445 </span>-- | Embed an implication computation inside a permission-checking computation,
<span class="lineno"> 2446 </span>-- also supplying an overall error message for failures
<span class="lineno"> 2447 </span>pcmEmbedImplWithErrM ::
<span class="lineno"> 2448 </span>  HasCallStack =&gt;
<span class="lineno"> 2449 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 2450 </span>  (forall ps. AnnotPermImpl r ps -&gt; r ps) -&gt; CruCtx vars -&gt; Doc () -&gt;
<span class="lineno"> 2451 </span>  ImplM vars (InnerPermCheckState blocks tops rets) r ps_out ps_in a -&gt;
<span class="lineno"> 2452 </span>  PermCheckM ext cblocks blocks tops rets (r ps_out) ps_out (r ps_in) ps_in
<span class="lineno"> 2453 </span>  (PermSubst vars, a)
<span class="lineno"> 2454 </span><span class="decl"><span class="nottickedoff">pcmEmbedImplWithErrM f_impl vars fail_doc m =</span>
<span class="lineno"> 2455 </span><span class="spaces">  </span><span class="nottickedoff">getErrorPrefix &gt;&gt;&gt;= \err_prefix -&gt;</span>
<span class="lineno"> 2456 </span><span class="spaces">  </span><span class="nottickedoff">gmapRet ((f_impl . AnnotPermImpl (renderDoc</span>
<span class="lineno"> 2457 </span><span class="spaces">                                    </span><span class="nottickedoff">(err_prefix &lt;&gt; line &lt;&gt; fail_doc))) &lt;$&gt;) &gt;&gt;&gt;</span>
<span class="lineno"> 2458 </span><span class="spaces">  </span><span class="nottickedoff">(stPermEnv  &lt;$&gt; top_get) &gt;&gt;&gt;= \env -&gt;</span>
<span class="lineno"> 2459 </span><span class="spaces">  </span><span class="nottickedoff">gets stCurPerms &gt;&gt;&gt;= \perms_in -&gt;</span>
<span class="lineno"> 2460 </span><span class="spaces">  </span><span class="nottickedoff">gets stPPInfo   &gt;&gt;&gt;= \ppInfo   -&gt;</span>
<span class="lineno"> 2461 </span><span class="spaces">  </span><span class="nottickedoff">gets stVarTypes &gt;&gt;&gt;= \varTypes -&gt;</span>
<span class="lineno"> 2462 </span><span class="spaces">  </span><span class="nottickedoff">gets stUnitVar  &gt;&gt;&gt;= \unitVar  -&gt;</span>
<span class="lineno"> 2463 </span><span class="spaces">  </span><span class="nottickedoff">(stEndianness &lt;$&gt; top_get) &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 2464 </span><span class="spaces">  </span><span class="nottickedoff">(stDebugLevel &lt;$&gt; top_get) &gt;&gt;&gt;= \dlevel -&gt;</span>
<span class="lineno"> 2465 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2466 </span><span class="spaces">  </span><span class="nottickedoff">addReader</span>
<span class="lineno"> 2467 </span><span class="spaces">    </span><span class="nottickedoff">(gcaptureCC</span>
<span class="lineno"> 2468 </span><span class="spaces">      </span><span class="nottickedoff">(runImplM vars perms_in env ppInfo &quot;&quot; dlevel varTypes unitVar endianness m))</span>
<span class="lineno"> 2469 </span><span class="spaces">    </span><span class="nottickedoff">&gt;&gt;&gt;= \(a, implSt) -&gt;</span>
<span class="lineno"> 2470 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2471 </span><span class="spaces">  </span><span class="nottickedoff">gmodify ((\st -&gt; st { stPPInfo   = implSt ^. implStatePPInfo,</span>
<span class="lineno"> 2472 </span><span class="spaces">                        </span><span class="nottickedoff">stVarTypes = implSt ^. implStateNameTypes,</span>
<span class="lineno"> 2473 </span><span class="spaces">                        </span><span class="nottickedoff">stUnitVar  = implSt ^. implStateUnitVar })</span>
<span class="lineno"> 2474 </span><span class="spaces">           </span><span class="nottickedoff">. setSTCurPerms (implSt ^. implStatePerms)) &gt;&gt;&gt;</span>
<span class="lineno"> 2475 </span><span class="spaces">  </span><span class="nottickedoff">pure (completePSubst vars (implSt ^. implStatePSubst), a)</span></span>
<span class="lineno"> 2476 </span>
<span class="lineno"> 2477 </span>-- | Embed an implication computation inside a permission-checking computation
<span class="lineno"> 2478 </span>pcmEmbedImplM ::
<span class="lineno"> 2479 </span>  HasCallStack =&gt;
<span class="lineno"> 2480 </span>  NuMatchingAny1 r =&gt;
<span class="lineno"> 2481 </span>  (forall ps. AnnotPermImpl r ps -&gt; r ps) -&gt; CruCtx vars -&gt;
<span class="lineno"> 2482 </span>  ImplM vars (InnerPermCheckState blocks tops rets) r ps_out ps_in a -&gt;
<span class="lineno"> 2483 </span>  PermCheckM ext cblocks blocks tops rets (r ps_out) ps_out (r ps_in) ps_in
<span class="lineno"> 2484 </span>  (PermSubst vars, a)
<span class="lineno"> 2485 </span><span class="decl"><span class="nottickedoff">pcmEmbedImplM f_impl vars m = pcmEmbedImplWithErrM f_impl vars mempty m</span></span>
<span class="lineno"> 2486 </span>
<span class="lineno"> 2487 </span>-- | Special case of 'pcmEmbedImplM' for a statement type-checking context where
<span class="lineno"> 2488 </span>-- @vars@ is empty
<span class="lineno"> 2489 </span>stmtEmbedImplM ::
<span class="lineno"> 2490 </span>  HasCallStack =&gt;
<span class="lineno"> 2491 </span>  NuMatchingExtC ext exprExt =&gt;
<span class="lineno"> 2492 </span>  ImplM RNil (InnerPermCheckState
<span class="lineno"> 2493 </span>              blocks tops rets) (TypedStmtSeq ext blocks tops rets) ps_out ps_in a -&gt;
<span class="lineno"> 2494 </span>  StmtPermCheckM ext cblocks blocks tops rets ps_out ps_in a
<span class="lineno"> 2495 </span><span class="decl"><span class="nottickedoff">stmtEmbedImplM m = snd &lt;$&gt; pcmEmbedImplM TypedImplStmt emptyCruCtx m</span></span>
<span class="lineno"> 2496 </span>
<span class="lineno"> 2497 </span>-- | Recombine any outstanding distinguished permissions back into the main
<span class="lineno"> 2498 </span>-- permission set, in the context of type-checking statements
<span class="lineno"> 2499 </span>stmtRecombinePerms ::
<span class="lineno"> 2500 </span>  HasCallStack =&gt;
<span class="lineno"> 2501 </span>  PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 2502 </span>  StmtPermCheckM ext cblocks blocks tops rets RNil ps_in ()
<span class="lineno"> 2503 </span><span class="decl"><span class="nottickedoff">stmtRecombinePerms =</span>
<span class="lineno"> 2504 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;&gt;= \(!st) -&gt;</span>
<span class="lineno"> 2505 </span><span class="spaces">  </span><span class="nottickedoff">let dist_perms = view distPerms (stCurPerms st) in</span>
<span class="lineno"> 2506 </span><span class="spaces">  </span><span class="nottickedoff">pcmEmbedImplM TypedImplStmt emptyCruCtx (recombinePerms dist_perms) &gt;&gt;&gt;</span>
<span class="lineno"> 2507 </span><span class="spaces">  </span><span class="nottickedoff">pure ()</span></span>
<span class="lineno"> 2508 </span>
<span class="lineno"> 2509 </span>-- | Helper function to pretty print \&quot;Could not prove ps\&quot; for permissions @ps@
<span class="lineno"> 2510 </span>ppProofError :: PermPretty a =&gt; PPInfo -&gt; String -&gt; a -&gt; Doc ()
<span class="lineno"> 2511 </span><span class="decl"><span class="nottickedoff">ppProofError ppInfo f mb_ps =</span>
<span class="lineno"> 2512 </span><span class="spaces">  </span><span class="nottickedoff">nest 2 $ sep [ pretty f &lt;&gt; colon &lt;+&gt; pretty &quot;Could not prove&quot;</span>
<span class="lineno"> 2513 </span><span class="spaces">               </span><span class="nottickedoff">, PP.group (PP.align (permPretty ppInfo mb_ps)) ]</span></span>
<span class="lineno"> 2514 </span>
<span class="lineno"> 2515 </span>-- | Helper function to pretty print \&quot;Could not prove ps1 -o ps2\&quot; for
<span class="lineno"> 2516 </span>-- permissions @ps1@ and @ps2@
<span class="lineno"> 2517 </span>ppImplProofError :: (PermPretty a, PermPretty b) =&gt; 
<span class="lineno"> 2518 </span>                    PPInfo -&gt; String -&gt; a -&gt; b -&gt; Doc ()
<span class="lineno"> 2519 </span><span class="decl"><span class="nottickedoff">ppImplProofError ppInfo f mb_ps1 mb_ps2 =</span>
<span class="lineno"> 2520 </span><span class="spaces">  </span><span class="nottickedoff">nest 2 $ sep [ pretty f &lt;&gt; colon &lt;+&gt; pretty &quot;Could not prove&quot;</span>
<span class="lineno"> 2521 </span><span class="spaces">               </span><span class="nottickedoff">, PP.group (PP.align (permPretty ppInfo mb_ps1))</span>
<span class="lineno"> 2522 </span><span class="spaces">               </span><span class="nottickedoff">, pretty &quot;-o&quot;</span>
<span class="lineno"> 2523 </span><span class="spaces">               </span><span class="nottickedoff">, PP.group (PP.align (permPretty ppInfo mb_ps2)) ]</span></span>
<span class="lineno"> 2524 </span>
<span class="lineno"> 2525 </span>-- | Prove a sequence of permissions over some existential variables and append
<span class="lineno"> 2526 </span>-- them to the top of the stack
<span class="lineno"> 2527 </span>stmtProvePermsAppend :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 2528 </span>                        CruCtx vars -&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 2529 </span>                        StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2530 </span>                        (ps_in :++: ps) ps_in (PermSubst vars)
<span class="lineno"> 2531 </span><span class="decl"><span class="nottickedoff">stmtProvePermsAppend vars ps =</span>
<span class="lineno"> 2532 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2533 </span><span class="spaces">  </span><span class="nottickedoff">let err = ppProofError ppInfo &quot;stmtProvePermsAppend&quot; ps in</span>
<span class="lineno"> 2534 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; pcmEmbedImplWithErrM TypedImplStmt vars err (proveVarsImplAppend ps)</span></span>
<span class="lineno"> 2535 </span>
<span class="lineno"> 2536 </span>-- | Prove a sequence of permissions over some existential variables in the
<span class="lineno"> 2537 </span>-- context of the empty permission stack
<span class="lineno"> 2538 </span>stmtProvePerms :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 2539 </span>                  CruCtx vars -&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 2540 </span>                  StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2541 </span>                  ps RNil (PermSubst vars)
<span class="lineno"> 2542 </span><span class="decl"><span class="nottickedoff">stmtProvePerms vars ps =</span>
<span class="lineno"> 2543 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2544 </span><span class="spaces">  </span><span class="nottickedoff">let err = ppProofError ppInfo &quot;stmtProvePerms&quot; ps in</span>
<span class="lineno"> 2545 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; pcmEmbedImplWithErrM TypedImplStmt vars err (proveVarsImpl ps)</span></span>
<span class="lineno"> 2546 </span>
<span class="lineno"> 2547 </span>-- | Prove a sequence of permissions over some existential variables in the
<span class="lineno"> 2548 </span>-- context of the empty permission stack, but first generate fresh lifetimes for
<span class="lineno"> 2549 </span>-- any existential lifetime variables
<span class="lineno"> 2550 </span>stmtProvePermsFreshLs :: PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 2551 </span>                         CruCtx vars -&gt; ExDistPerms vars ps -&gt;
<span class="lineno"> 2552 </span>                         StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2553 </span>                         ps RNil (PermSubst vars)
<span class="lineno"> 2554 </span><span class="decl"><span class="nottickedoff">stmtProvePermsFreshLs vars ps =</span>
<span class="lineno"> 2555 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2556 </span><span class="spaces">  </span><span class="nottickedoff">let err = ppProofError ppInfo &quot;stmtProvePermsFreshLs&quot; ps in</span>
<span class="lineno"> 2557 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; pcmEmbedImplWithErrM TypedImplStmt vars err</span>
<span class="lineno"> 2558 </span><span class="spaces">            </span><span class="nottickedoff">(instantiateLifetimeVars ps &gt;&gt;&gt; proveVarsImpl ps)</span></span>
<span class="lineno"> 2559 </span>
<span class="lineno"> 2560 </span>-- | Prove a single permission in the context of type-checking statements
<span class="lineno"> 2561 </span>stmtProvePerm :: (PermCheckExtC ext exprExt, KnownRepr CruCtx vars) =&gt;
<span class="lineno"> 2562 </span>                 TypedReg a -&gt; Mb vars (ValuePerm a) -&gt;
<span class="lineno"> 2563 </span>                 StmtPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 2564 </span>                 (ps :&gt; a) ps (PermSubst vars)
<span class="lineno"> 2565 </span><span class="decl"><span class="nottickedoff">stmtProvePerm (TypedReg x) mb_p =</span>
<span class="lineno"> 2566 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2567 </span><span class="spaces">  </span><span class="nottickedoff">let err = ppProofError ppInfo &quot;stmtProvePerm&quot; (fmap (distPerms1 x) mb_p) in</span>
<span class="lineno"> 2568 </span><span class="spaces">  </span><span class="nottickedoff">fst &lt;$&gt; pcmEmbedImplWithErrM TypedImplStmt knownRepr err</span>
<span class="lineno"> 2569 </span><span class="spaces">            </span><span class="nottickedoff">(proveVarImpl x mb_p)</span></span>
<span class="lineno"> 2570 </span>
<span class="lineno"> 2571 </span>
<span class="lineno"> 2572 </span>-- | Try to prove that a register equals a constant integer (of the given input
<span class="lineno"> 2573 </span>-- type) using equality permissions in the context
<span class="lineno"> 2574 </span>resolveConstant :: TypedReg tp -&gt;
<span class="lineno"> 2575 </span>                   StmtPermCheckM ext cblocks blocks tops rets ps ps
<span class="lineno"> 2576 </span>                   (Maybe Integer)
<span class="lineno"> 2577 </span><span class="decl"><span class="nottickedoff">resolveConstant = helper . PExpr_Var . typedRegVar where</span>
<span class="lineno"> 2578 </span><span class="spaces">  </span><span class="nottickedoff">helper :: PermExpr a -&gt;</span>
<span class="lineno"> 2579 </span><span class="spaces">            </span><span class="nottickedoff">StmtPermCheckM ext cblocks blocks tops rets ps ps</span>
<span class="lineno"> 2580 </span><span class="spaces">            </span><span class="nottickedoff">(Maybe Integer)</span>
<span class="lineno"> 2581 </span><span class="spaces">  </span><span class="nottickedoff">helper (PExpr_Var x) =</span>
<span class="lineno"> 2582 </span><span class="spaces">    </span><span class="nottickedoff">getVarPerm x &gt;&gt;= \case</span>
<span class="lineno"> 2583 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Eq e -&gt; helper e</span>
<span class="lineno"> 2584 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; pure Nothing</span>
<span class="lineno"> 2585 </span><span class="spaces">  </span><span class="nottickedoff">helper (PExpr_Nat i) = pure (Just $ toInteger i)</span>
<span class="lineno"> 2586 </span><span class="spaces">  </span><span class="nottickedoff">helper (PExpr_BV factors (BV.BV off)) =</span>
<span class="lineno"> 2587 </span><span class="spaces">    </span><span class="nottickedoff">foldM (\maybe_res (BVFactor (BV.BV i) x) -&gt;</span>
<span class="lineno"> 2588 </span><span class="spaces">            </span><span class="nottickedoff">helper (PExpr_Var x) &gt;&gt;= \maybe_x_val -&gt;</span>
<span class="lineno"> 2589 </span><span class="spaces">            </span><span class="nottickedoff">case (maybe_res, maybe_x_val) of</span>
<span class="lineno"> 2590 </span><span class="spaces">              </span><span class="nottickedoff">(Just res, Just x_val) -&gt;</span>
<span class="lineno"> 2591 </span><span class="spaces">                </span><span class="nottickedoff">return (Just (res + x_val * i))</span>
<span class="lineno"> 2592 </span><span class="spaces">              </span><span class="nottickedoff">_ -&gt; return Nothing)</span>
<span class="lineno"> 2593 </span><span class="spaces">    </span><span class="nottickedoff">(Just off) factors</span>
<span class="lineno"> 2594 </span><span class="spaces">  </span><span class="nottickedoff">helper (PExpr_LLVMWord e) = helper e</span>
<span class="lineno"> 2595 </span><span class="spaces">  </span><span class="nottickedoff">helper (PExpr_LLVMOffset x e) =</span>
<span class="lineno"> 2596 </span><span class="spaces">    </span><span class="nottickedoff">do maybe_x_val &lt;- helper (PExpr_Var x)</span>
<span class="lineno"> 2597 </span><span class="spaces">       </span><span class="nottickedoff">maybe_e_val &lt;- helper e</span>
<span class="lineno"> 2598 </span><span class="spaces">       </span><span class="nottickedoff">case (maybe_x_val, maybe_e_val) of</span>
<span class="lineno"> 2599 </span><span class="spaces">         </span><span class="nottickedoff">(Just x_val, Just e_val) -&gt; return (Just (x_val + e_val))</span>
<span class="lineno"> 2600 </span><span class="spaces">         </span><span class="nottickedoff">_ -&gt; return Nothing</span>
<span class="lineno"> 2601 </span><span class="spaces">  </span><span class="nottickedoff">helper _ = return Nothing</span></span>
<span class="lineno"> 2602 </span>
<span class="lineno"> 2603 </span>
<span class="lineno"> 2604 </span>-- | Convert a register of one type to one of another type, if possible
<span class="lineno"> 2605 </span>convertRegType :: PermCheckExtC ext exprExt =&gt; ExtRepr ext -&gt; ProgramLoc -&gt;
<span class="lineno"> 2606 </span>                  TypedReg tp1 -&gt; TypeRepr tp1 -&gt; TypeRepr tp2 -&gt;
<span class="lineno"> 2607 </span>                  StmtPermCheckM ext cblocks blocks tops rets RNil RNil
<span class="lineno"> 2608 </span>                  (TypedReg tp2)
<span class="lineno"> 2609 </span><span class="decl"><span class="nottickedoff">convertRegType _ _ reg tp1 tp2</span>
<span class="lineno"> 2610 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality tp1 tp2 = pure reg</span>
<span class="lineno"> 2611 </span><span class="spaces"></span><span class="nottickedoff">convertRegType _ loc reg (BVRepr w1) tp2@(BVRepr w2)</span>
<span class="lineno"> 2612 </span><span class="spaces">  </span><span class="nottickedoff">| Left LeqProof &lt;- decideLeq (knownNat :: NatRepr 1) w2</span>
<span class="lineno"> 2613 </span><span class="spaces">  </span><span class="nottickedoff">, NatCaseGT LeqProof &lt;- testNatCases w1 w2 =</span>
<span class="lineno"> 2614 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat w2 $</span>
<span class="lineno"> 2615 </span><span class="spaces">    </span><span class="nottickedoff">emitStmt knownRepr noNames loc</span>
<span class="lineno"> 2616 </span><span class="spaces">      </span><span class="nottickedoff">(TypedSetReg tp2 $</span>
<span class="lineno"> 2617 </span><span class="spaces">        </span><span class="nottickedoff">TypedExpr (BVTrunc w2 w1 $ RegNoVal reg)</span>
<span class="lineno"> 2618 </span><span class="spaces">        </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: x) -&gt;</span>
<span class="lineno"> 2619 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 2620 </span><span class="spaces">    </span><span class="nottickedoff">pure (TypedReg x)</span>
<span class="lineno"> 2621 </span><span class="spaces"></span><span class="nottickedoff">convertRegType _ loc reg (BVRepr w1) tp2@(BVRepr w2)</span>
<span class="lineno"> 2622 </span><span class="spaces">  </span><span class="nottickedoff">| Left LeqProof &lt;- decideLeq (knownNat :: NatRepr 1) w1</span>
<span class="lineno"> 2623 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat :: NatRepr 1) w2</span>
<span class="lineno"> 2624 </span><span class="spaces">  </span><span class="nottickedoff">, NatCaseLT LeqProof &lt;- testNatCases w1 w2 =</span>
<span class="lineno"> 2625 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: should this use endianness?</span>
<span class="lineno"> 2626 </span><span class="spaces">    </span><span class="nottickedoff">-- (stEndianness &lt;$&gt; top_get) &gt;&gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 2627 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat w2 $</span>
<span class="lineno"> 2628 </span><span class="spaces">    </span><span class="nottickedoff">emitStmt knownRepr noNames loc</span>
<span class="lineno"> 2629 </span><span class="spaces">      </span><span class="nottickedoff">(TypedSetReg tp2 $</span>
<span class="lineno"> 2630 </span><span class="spaces">        </span><span class="nottickedoff">TypedExpr (BVSext w2 w1 $ RegNoVal reg)</span>
<span class="lineno"> 2631 </span><span class="spaces">        </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: x) -&gt;</span>
<span class="lineno"> 2632 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 2633 </span><span class="spaces">    </span><span class="nottickedoff">pure (TypedReg x)</span>
<span class="lineno"> 2634 </span><span class="spaces"></span><span class="nottickedoff">convertRegType ExtRepr_LLVM loc reg (LLVMPointerRepr w1) (BVRepr w2)</span>
<span class="lineno"> 2635 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality w1 w2 =</span>
<span class="lineno"> 2636 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat w1 $</span>
<span class="lineno"> 2637 </span><span class="spaces">    </span><span class="nottickedoff">stmtProvePerm reg (llvmExEqWord w1) &gt;&gt;&gt;= \sbst -&gt;</span>
<span class="lineno"> 2638 </span><span class="spaces">    </span><span class="nottickedoff">let e = substLookup sbst Member_Base in</span>
<span class="lineno"> 2639 </span><span class="spaces">    </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (DestructLLVMWord reg e) &gt;&gt;&gt;= \x -&gt;</span>
<span class="lineno"> 2640 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 2641 </span><span class="spaces">    </span><span class="nottickedoff">pure (TypedReg x)</span>
<span class="lineno"> 2642 </span><span class="spaces"></span><span class="nottickedoff">convertRegType ext loc reg (LLVMPointerRepr w1) (BVRepr w2) =</span>
<span class="lineno"> 2643 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg (LLVMPointerRepr w1) (BVRepr w1) &gt;&gt;&gt;= \reg' -&gt;</span>
<span class="lineno"> 2644 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg' (BVRepr w1) (BVRepr w2)</span>
<span class="lineno"> 2645 </span><span class="spaces"></span><span class="nottickedoff">convertRegType ExtRepr_LLVM loc reg (BVRepr w2) (LLVMPointerRepr w1)</span>
<span class="lineno"> 2646 </span><span class="spaces">  </span><span class="nottickedoff">| Just Refl &lt;- testEquality w1 w2 =</span>
<span class="lineno"> 2647 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat w1 $</span>
<span class="lineno"> 2648 </span><span class="spaces">    </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (ConstructLLVMWord reg) &gt;&gt;&gt;= \x -&gt;</span>
<span class="lineno"> 2649 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt; pure (TypedReg x)</span>
<span class="lineno"> 2650 </span><span class="spaces"></span><span class="nottickedoff">convertRegType ext loc reg (BVRepr w1) (LLVMPointerRepr w2) =</span>
<span class="lineno"> 2651 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg (BVRepr w1) (BVRepr w2) &gt;&gt;&gt;= \reg' -&gt;</span>
<span class="lineno"> 2652 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg' (BVRepr w2) (LLVMPointerRepr w2)</span>
<span class="lineno"> 2653 </span><span class="spaces"></span><span class="nottickedoff">convertRegType ext loc reg (LLVMPointerRepr w1) (LLVMPointerRepr w2) =</span>
<span class="lineno"> 2654 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg (LLVMPointerRepr w1) (BVRepr w1) &gt;&gt;&gt;= \reg1 -&gt;</span>
<span class="lineno"> 2655 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg1 (BVRepr w1) (BVRepr w2) &gt;&gt;&gt;= \reg2 -&gt;</span>
<span class="lineno"> 2656 </span><span class="spaces">  </span><span class="nottickedoff">convertRegType ext loc reg2 (BVRepr w2) (LLVMPointerRepr w2)</span>
<span class="lineno"> 2657 </span><span class="spaces"></span><span class="nottickedoff">convertRegType _ _ x tp1 tp2 =</span>
<span class="lineno"> 2658 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 2659 </span><span class="spaces">    </span><span class="nottickedoff">stmtFailM $ RegisterConversionError (permPretty ppinfo x) tp1 tp2</span></span>
<span class="lineno"> 2660 </span>
<span class="lineno"> 2661 </span>
<span class="lineno"> 2662 </span>-- | Extract the bitvector of size @sz@ at offset @off@ from a larger bitvector
<span class="lineno"> 2663 </span>-- @bv@, using the current endianness to determine how this extraction works
<span class="lineno"> 2664 </span>extractBVBytes :: (1 &lt;= w, KnownNat w) =&gt;
<span class="lineno"> 2665 </span>                  ProgramLoc -&gt; NatRepr sz -&gt; Bytes -&gt; TypedReg (BVType w) -&gt;
<span class="lineno"> 2666 </span>                  StmtPermCheckM LLVM cblocks blocks tops rets RNil RNil
<span class="lineno"> 2667 </span>                  (TypedReg (BVType sz))
<span class="lineno"> 2668 </span><span class="decl"><span class="nottickedoff">extractBVBytes loc sz off_bytes (reg :: TypedReg (BVType w)) =</span>
<span class="lineno"> 2669 </span><span class="spaces">  </span><span class="nottickedoff">let w :: NatRepr w = knownNat in</span>
<span class="lineno"> 2670 </span><span class="spaces">  </span><span class="nottickedoff">(stEndianness &lt;$&gt; top_get) &gt;&gt;= \endianness -&gt;</span>
<span class="lineno"> 2671 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat sz $</span>
<span class="lineno"> 2672 </span><span class="spaces">  </span><span class="nottickedoff">case (endianness, decideLeq (knownNat @1) sz) of</span>
<span class="lineno"> 2673 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2674 </span><span class="spaces">    </span><span class="nottickedoff">-- For little endian, we can just call BVSelect</span>
<span class="lineno"> 2675 </span><span class="spaces">    </span><span class="nottickedoff">(LittleEndian, Left sz_pf)</span>
<span class="lineno"> 2676 </span><span class="spaces">      </span><span class="nottickedoff">| Just (Some off) &lt;- someNat (bytesToBits off_bytes)</span>
<span class="lineno"> 2677 </span><span class="spaces">      </span><span class="nottickedoff">, Left off_sz_w_pf &lt;- decideLeq (addNat off sz) w -&gt;</span>
<span class="lineno"> 2678 </span><span class="spaces">        </span><span class="nottickedoff">withLeqProof sz_pf $ withLeqProof off_sz_w_pf $</span>
<span class="lineno"> 2679 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr noNames loc</span>
<span class="lineno"> 2680 </span><span class="spaces">          </span><span class="nottickedoff">(TypedSetReg (BVRepr sz) $</span>
<span class="lineno"> 2681 </span><span class="spaces">            </span><span class="nottickedoff">TypedExpr (BVSelect off sz w $ RegNoVal reg)</span>
<span class="lineno"> 2682 </span><span class="spaces">            </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: x) -&gt;</span>
<span class="lineno"> 2683 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 2684 </span><span class="spaces">        </span><span class="nottickedoff">pure (TypedReg x)</span>
<span class="lineno"> 2685 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2686 </span><span class="spaces">    </span><span class="nottickedoff">-- For big endian, we call BVSelect with idx = w - off - sz</span>
<span class="lineno"> 2687 </span><span class="spaces">    </span><span class="nottickedoff">(BigEndian, Left sz_pf)</span>
<span class="lineno"> 2688 </span><span class="spaces">      </span><span class="nottickedoff">| Just (Some idx) &lt;- someNat (intValue w</span>
<span class="lineno"> 2689 </span><span class="spaces">                                    </span><span class="nottickedoff">- toInteger (bytesToBits off_bytes)</span>
<span class="lineno"> 2690 </span><span class="spaces">                                    </span><span class="nottickedoff">- intValue sz)</span>
<span class="lineno"> 2691 </span><span class="spaces">      </span><span class="nottickedoff">, Left idx_sz_w_pf &lt;- decideLeq (addNat idx sz) w -&gt;</span>
<span class="lineno"> 2692 </span><span class="spaces">        </span><span class="nottickedoff">withLeqProof sz_pf $ withLeqProof idx_sz_w_pf $</span>
<span class="lineno"> 2693 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr noNames loc</span>
<span class="lineno"> 2694 </span><span class="spaces">          </span><span class="nottickedoff">(TypedSetReg (BVRepr sz) $</span>
<span class="lineno"> 2695 </span><span class="spaces">            </span><span class="nottickedoff">TypedExpr (BVSelect idx sz w $ RegNoVal reg)</span>
<span class="lineno"> 2696 </span><span class="spaces">            </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: x) -&gt;</span>
<span class="lineno"> 2697 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 2698 </span><span class="spaces">        </span><span class="nottickedoff">pure (TypedReg x)</span>
<span class="lineno"> 2699 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; error &quot;extractBVBytes: negative offset!&quot;</span></span>
<span class="lineno"> 2700 </span>
<span class="lineno"> 2701 </span>
<span class="lineno"> 2702 </span>-- | Emit a statement in the current statement sequence, where the supplied
<span class="lineno"> 2703 </span>-- function says how that statement modifies the current permissions, given the
<span class="lineno"> 2704 </span>-- freshly-bound names for the return values. Return those freshly-bound names
<span class="lineno"> 2705 </span>-- for the return values.
<span class="lineno"> 2706 </span>emitStmt ::
<span class="lineno"> 2707 </span>  PermCheckExtC ext exprExt =&gt;
<span class="lineno"> 2708 </span>  CruCtx stmt_rets -&gt;
<span class="lineno"> 2709 </span>  RAssign (Constant (Maybe String)) stmt_rets -&gt;
<span class="lineno"> 2710 </span>  ProgramLoc -&gt;
<span class="lineno"> 2711 </span>  TypedStmt ext stmt_rets ps_in ps_out -&gt;
<span class="lineno"> 2712 </span>  StmtPermCheckM ext cblocks blocks tops rets ps_out ps_in
<span class="lineno"> 2713 </span>    (RAssign Name stmt_rets)
<span class="lineno"> 2714 </span><span class="decl"><span class="nottickedoff">emitStmt tps names loc stmt =</span>
<span class="lineno"> 2715 </span><span class="spaces">  </span><span class="nottickedoff">let pxys = cruCtxProxies tps in</span>
<span class="lineno"> 2716 </span><span class="spaces">  </span><span class="nottickedoff">allocateDebugNamesM Nothing names tps &gt;&gt;&gt;= \debugs -&gt;</span>
<span class="lineno"> 2717 </span><span class="spaces">  </span><span class="nottickedoff">startNamedBinding debugs (fmap (TypedConsStmt loc stmt pxys)</span>
<span class="lineno"> 2718 </span><span class="spaces">                            </span><span class="nottickedoff">. strongMbMNamed) &gt;&gt;&gt;= \ns -&gt;</span>
<span class="lineno"> 2719 </span><span class="spaces">  </span><span class="nottickedoff">modify (\st -&gt; st { stPPInfo = ppInfoApplyAllocation ns debugs (stPPInfo st)}) &gt;&gt;&gt;</span>
<span class="lineno"> 2720 </span><span class="spaces">  </span><span class="nottickedoff">setVarTypes ns tps &gt;&gt;&gt;</span>
<span class="lineno"> 2721 </span><span class="spaces">  </span><span class="nottickedoff">gmodify (modifySTCurPerms (applyTypedStmt stmt ns)) &gt;&gt;&gt;</span>
<span class="lineno"> 2722 </span><span class="spaces">  </span><span class="nottickedoff">gets (view distPerms . stCurPerms) &gt;&gt;&gt;= \perms_out -&gt;</span>
<span class="lineno"> 2723 </span><span class="spaces">  </span><span class="nottickedoff">stmtVerbTraceM (\i -&gt;</span>
<span class="lineno"> 2724 </span><span class="spaces">                   </span><span class="nottickedoff">pretty &quot;Created new variables: &quot;</span>
<span class="lineno"> 2725 </span><span class="spaces">                   </span><span class="nottickedoff">&lt;+&gt; permPretty i ns &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 2726 </span><span class="spaces">                   </span><span class="nottickedoff">pretty &quot;Statement output permissions: &quot; &lt;+&gt;</span>
<span class="lineno"> 2727 </span><span class="spaces">                   </span><span class="nottickedoff">permPretty i perms_out) &gt;&gt;&gt;</span>
<span class="lineno"> 2728 </span><span class="spaces">  </span><span class="nottickedoff">-- Note: must come after both setVarTypes and gmodify</span>
<span class="lineno"> 2729 </span><span class="spaces">  </span><span class="nottickedoff">stmtHandleUnitVars ns &gt;&gt;&gt;</span>
<span class="lineno"> 2730 </span><span class="spaces">  </span><span class="nottickedoff">pure ns</span></span>
<span class="lineno"> 2731 </span>
<span class="lineno"> 2732 </span>
<span class="lineno"> 2733 </span>-- | Call emitStmt with a 'TypedLLVMStmt'
<span class="lineno"> 2734 </span>emitLLVMStmt ::
<span class="lineno"> 2735 </span>  TypeRepr tp -&gt;
<span class="lineno"> 2736 </span>  Maybe String -&gt;
<span class="lineno"> 2737 </span>  ProgramLoc -&gt;
<span class="lineno"> 2738 </span>  TypedLLVMStmt tp ps_in ps_out -&gt;
<span class="lineno"> 2739 </span>  StmtPermCheckM LLVM cblocks blocks tops rets ps_out ps_in (Name tp)
<span class="lineno"> 2740 </span><span class="decl"><span class="nottickedoff">emitLLVMStmt tp name loc stmt =</span>
<span class="lineno"> 2741 </span><span class="spaces">  </span><span class="nottickedoff">RL.head &lt;$&gt; emitStmt (singletonCruCtx tp) (RL.singleton (Constant name)) loc (TypedLLVMStmt stmt)</span></span>
<span class="lineno"> 2742 </span>
<span class="lineno"> 2743 </span>-- | A program location for code which was generated by the type-checker
<span class="lineno"> 2744 </span>checkerProgramLoc :: ProgramLoc
<span class="lineno"> 2745 </span><span class="decl"><span class="nottickedoff">checkerProgramLoc =</span>
<span class="lineno"> 2746 </span><span class="spaces">  </span><span class="nottickedoff">mkProgramLoc (functionNameFromText (Text.pack &quot;None&quot;))</span>
<span class="lineno"> 2747 </span><span class="spaces">  </span><span class="nottickedoff">(OtherPos (Text.pack &quot;(Generated by permission type-checker)&quot;))</span></span>
<span class="lineno"> 2748 </span>
<span class="lineno"> 2749 </span>
<span class="lineno"> 2750 </span>----------------------------------------------------------------------
<span class="lineno"> 2751 </span>-- * Permission Checking and Pretty-Printing for Registers
<span class="lineno"> 2752 </span>----------------------------------------------------------------------
<span class="lineno"> 2753 </span>
<span class="lineno"> 2754 </span>-- | Type-check a Crucible register by looking it up in the translated context
<span class="lineno"> 2755 </span>tcReg :: CtxTrans ctx -&gt; Reg ctx tp -&gt; TypedReg tp
<span class="lineno"> 2756 </span><span class="decl"><span class="nottickedoff">tcReg ctx (Reg ix) = ctx ! ix</span></span>
<span class="lineno"> 2757 </span>
<span class="lineno"> 2758 </span>-- | Type-check a Crucible register and also look up its value, if known
<span class="lineno"> 2759 </span>tcRegWithVal :: PermCheckExtC ext exprExt =&gt; CtxTrans ctx -&gt; Reg ctx tp -&gt;
<span class="lineno"> 2760 </span>                StmtPermCheckM ext cblocks blocks tops rets ps ps
<span class="lineno"> 2761 </span>                (RegWithVal tp)
<span class="lineno"> 2762 </span><span class="decl"><span class="nottickedoff">tcRegWithVal ctx r_untyped =</span>
<span class="lineno"> 2763 </span><span class="spaces">  </span><span class="nottickedoff">let r = tcReg ctx r_untyped in</span>
<span class="lineno"> 2764 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr r &gt;&gt;= \case</span>
<span class="lineno"> 2765 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Var x | x == typedRegVar r -&gt; pure $ RegNoVal r</span>
<span class="lineno"> 2766 </span><span class="spaces">    </span><span class="nottickedoff">e -&gt; pure $ RegWithVal r e</span></span>
<span class="lineno"> 2767 </span>
<span class="lineno"> 2768 </span>-- | Type-check a sequence of Crucible registers
<span class="lineno"> 2769 </span>tcRegs :: CtxTrans ctx -&gt; Assignment (Reg ctx) tps -&gt; TypedRegs (CtxToRList tps)
<span class="lineno"> 2770 </span><span class="decl"><span class="nottickedoff">tcRegs _ctx (viewAssign -&gt; AssignEmpty) = TypedRegsNil</span>
<span class="lineno"> 2771 </span><span class="spaces"></span><span class="nottickedoff">tcRegs ctx (viewAssign -&gt; AssignExtend regs reg) =</span>
<span class="lineno"> 2772 </span><span class="spaces">  </span><span class="nottickedoff">TypedRegsCons (tcRegs ctx regs) (tcReg ctx reg)</span></span>
<span class="lineno"> 2773 </span>
<span class="lineno"> 2774 </span>-- | Pretty-print the permissions that are \&quot;relevant\&quot; to a register, which
<span class="lineno"> 2775 </span>-- includes its permissions and all those relevant to any register it is equal
<span class="lineno"> 2776 </span>-- to, possibly plus some offset
<span class="lineno"> 2777 </span>ppRelevantPerms :: TypedReg tp -&gt;
<span class="lineno"> 2778 </span>                   PermCheckM ext cblocks blocks tops rets r ps r ps (Doc ())
<span class="lineno"> 2779 </span><span class="decl"><span class="nottickedoff">ppRelevantPerms r =</span>
<span class="lineno"> 2780 </span><span class="spaces">  </span><span class="nottickedoff">getRegPerm r &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 2781 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2782 </span><span class="spaces">  </span><span class="nottickedoff">let pp_r = permPretty ppInfo r &lt;&gt; colon &lt;&gt; permPretty ppInfo p in</span>
<span class="lineno"> 2783 </span><span class="spaces">  </span><span class="nottickedoff">case p of</span>
<span class="lineno"> 2784 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq (PExpr_Var x) -&gt;</span>
<span class="lineno"> 2785 </span><span class="spaces">      </span><span class="nottickedoff">((pp_r &lt;&gt; comma) &lt;+&gt;) &lt;$&gt; ppRelevantPerms (TypedReg x)</span>
<span class="lineno"> 2786 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMOffset x _) -&gt;</span>
<span class="lineno"> 2787 </span><span class="spaces">      </span><span class="nottickedoff">((pp_r &lt;&gt; comma) &lt;+&gt;) &lt;$&gt; ppRelevantPerms (TypedReg x)</span>
<span class="lineno"> 2788 </span><span class="spaces">    </span><span class="nottickedoff">ValPerm_Eq (PExpr_LLVMWord (PExpr_Var x)) -&gt;</span>
<span class="lineno"> 2789 </span><span class="spaces">      </span><span class="nottickedoff">((pp_r &lt;&gt; comma) &lt;+&gt;) &lt;$&gt; ppRelevantPerms (TypedReg x)</span>
<span class="lineno"> 2790 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; pure pp_r</span></span>
<span class="lineno"> 2791 </span>
<span class="lineno"> 2792 </span>-- | Pretty-print a Crucible 'Reg' and what 'TypedReg' it is equal to, along
<span class="lineno"> 2793 </span>-- with the relevant permissions for that 'TypedReg'
<span class="lineno"> 2794 </span>ppCruRegAndPerms :: CtxTrans ctx -&gt; Reg ctx a -&gt;
<span class="lineno"> 2795 </span>                    PermCheckM ext cblocks blocks tops rets r ps r ps (Doc ())
<span class="lineno"> 2796 </span><span class="decl"><span class="nottickedoff">ppCruRegAndPerms ctx r =</span>
<span class="lineno"> 2797 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2798 </span><span class="spaces">  </span><span class="nottickedoff">ppRelevantPerms (tcReg ctx r) &gt;&gt;&gt;= \doc -&gt;</span>
<span class="lineno"> 2799 </span><span class="spaces">  </span><span class="nottickedoff">pure (PP.group (pretty r &lt;+&gt; pretty '=' &lt;+&gt; permPretty ppInfo (tcReg ctx r)</span>
<span class="lineno"> 2800 </span><span class="spaces">                     </span><span class="nottickedoff">&lt;&gt; comma &lt;+&gt; doc))</span></span>
<span class="lineno"> 2801 </span>
<span class="lineno"> 2802 </span>-- | Get the permissions on the variables in the input set, the variables in
<span class="lineno"> 2803 </span>-- their permissions, the variables in those permissions etc., as in
<span class="lineno"> 2804 </span>-- 'varPermsTransFreeVars'
<span class="lineno"> 2805 </span>getRelevantPerms :: [SomeName CrucibleType] -&gt;
<span class="lineno"> 2806 </span>                    PermCheckM ext cblocks blocks tops rets r ps r ps
<span class="lineno"> 2807 </span>                      (Some DistPerms)
<span class="lineno"> 2808 </span><span class="decl"><span class="nottickedoff">getRelevantPerms (namesListToNames -&gt; SomeRAssign ns) =</span>
<span class="lineno"> 2809 </span><span class="spaces">  </span><span class="nottickedoff">gets stCurPerms &gt;&gt;&gt;= \perms -&gt;</span>
<span class="lineno"> 2810 </span><span class="spaces">  </span><span class="nottickedoff">case varPermsTransFreeVars ns perms of</span>
<span class="lineno"> 2811 </span><span class="spaces">    </span><span class="nottickedoff">Some all_ns -&gt; pure (Some $ varPermsMulti (RL.append ns all_ns) perms)</span></span>
<span class="lineno"> 2812 </span>
<span class="lineno"> 2813 </span>-- | Pretty-print a list of Crucible registers and the variables they translate
<span class="lineno"> 2814 </span>-- to, and then pretty-print the permissions on those variables and all
<span class="lineno"> 2815 </span>-- variables they contain, as well as the top-level input variables and the
<span class="lineno"> 2816 </span>-- extension-specific variables
<span class="lineno"> 2817 </span>ppCruRegsAndTopsPerms ::
<span class="lineno"> 2818 </span>  [Maybe String] -&gt;
<span class="lineno"> 2819 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 2820 </span>  [Some (Reg ctx)] -&gt;
<span class="lineno"> 2821 </span>  PermCheckM ext cblocks blocks tops rets r ps r ps (Doc (), Doc ())
<span class="lineno"> 2822 </span><span class="decl"><span class="nottickedoff">ppCruRegsAndTopsPerms names ctx regs =</span>
<span class="lineno"> 2823 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 2824 </span><span class="spaces">  </span><span class="nottickedoff">gets stTopVars &gt;&gt;&gt;= \tops -&gt;</span>
<span class="lineno"> 2825 </span><span class="spaces">  </span><span class="nottickedoff">gets (permCheckExtStateNames . stExtState) &gt;&gt;&gt;= \(Some ext_ns) -&gt;</span>
<span class="lineno"> 2826 </span><span class="spaces">  </span><span class="nottickedoff">let vars_pp =</span>
<span class="lineno"> 2827 </span><span class="spaces">        </span><span class="nottickedoff">fillSep $ punctuate comma $</span>
<span class="lineno"> 2828 </span><span class="spaces">        </span><span class="nottickedoff">map (\(Some r) -&gt;</span>
<span class="lineno"> 2829 </span><span class="spaces">          </span><span class="nottickedoff">let name = listToMaybe (drop (indexVal (regIndex r)) names) in</span>
<span class="lineno"> 2830 </span><span class="spaces">          </span><span class="nottickedoff">pretty r &lt;+&gt; pretty '=' &lt;+&gt;</span>
<span class="lineno"> 2831 </span><span class="spaces">          </span><span class="nottickedoff">permPretty ppInfo (tcReg ctx r) &lt;&gt;</span>
<span class="lineno"> 2832 </span><span class="spaces">          </span><span class="nottickedoff">foldMap (\n -&gt; pretty &quot; @&quot; &lt;+&gt; pretty n) name)</span>
<span class="lineno"> 2833 </span><span class="spaces">          </span><span class="nottickedoff">(nub regs)</span>
<span class="lineno"> 2834 </span><span class="spaces">      </span><span class="nottickedoff">vars =</span>
<span class="lineno"> 2835 </span><span class="spaces">        </span><span class="nottickedoff">namesToNamesList tops ++ namesToNamesList ext_ns ++</span>
<span class="lineno"> 2836 </span><span class="spaces">        </span><span class="nottickedoff">map (\(Some r) -&gt; SomeName $ typedRegVar $ tcReg ctx r) regs in</span>
<span class="lineno"> 2837 </span><span class="spaces">  </span><span class="nottickedoff">getRelevantPerms vars &gt;&gt;&gt;= \some_perms -&gt;</span>
<span class="lineno"> 2838 </span><span class="spaces">  </span><span class="nottickedoff">case some_perms of</span>
<span class="lineno"> 2839 </span><span class="spaces">    </span><span class="nottickedoff">Some perms -&gt; pure (vars_pp, permPretty ppInfo perms)</span></span>
<span class="lineno"> 2840 </span>
<span class="lineno"> 2841 </span>-- | Set the current prefix string to give context to error messages
<span class="lineno"> 2842 </span>setErrorPrefix ::
<span class="lineno"> 2843 </span>  [Maybe String] -&gt;
<span class="lineno"> 2844 </span>  ProgramLoc -&gt;
<span class="lineno"> 2845 </span>  Doc () -&gt;
<span class="lineno"> 2846 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 2847 </span>  [Some (Reg ctx)] -&gt;
<span class="lineno"> 2848 </span>  PermCheckM ext cblocks blocks tops rets r ps r ps ()
<span class="lineno"> 2849 </span><span class="decl"><span class="nottickedoff">setErrorPrefix names loc stmt_pp ctx regs =</span>
<span class="lineno"> 2850 </span><span class="spaces">  </span><span class="nottickedoff">ppCruRegsAndTopsPerms names ctx regs &gt;&gt;&gt;= \(regs_pp, perms_pp) -&gt;</span>
<span class="lineno"> 2851 </span><span class="spaces">  </span><span class="nottickedoff">let prefix =</span>
<span class="lineno"> 2852 </span><span class="spaces">        </span><span class="nottickedoff">PP.sep</span>
<span class="lineno"> 2853 </span><span class="spaces">        </span><span class="nottickedoff">[PP.group (pretty &quot;At&quot; &lt;+&gt; ppShortFileName (plSourceLoc loc)</span>
<span class="lineno"> 2854 </span><span class="spaces">                  </span><span class="nottickedoff">&lt;+&gt; parens stmt_pp),</span>
<span class="lineno"> 2855 </span><span class="spaces">         </span><span class="nottickedoff">PP.group (pretty &quot;Regs:&quot; &lt;+&gt; regs_pp),</span>
<span class="lineno"> 2856 </span><span class="spaces">         </span><span class="nottickedoff">PP.group (pretty &quot;Input perms:&quot; &lt;+&gt; perms_pp)] in</span>
<span class="lineno"> 2857 </span><span class="spaces">  </span><span class="nottickedoff">gmodify $ \st -&gt; st { stErrPrefix = Just prefix }</span></span>
<span class="lineno"> 2858 </span>
<span class="lineno"> 2859 </span>
<span class="lineno"> 2860 </span>----------------------------------------------------------------------
<span class="lineno"> 2861 </span>-- * Permission Checking for Expressions and Statements
<span class="lineno"> 2862 </span>----------------------------------------------------------------------
<span class="lineno"> 2863 </span>
<span class="lineno"> 2864 </span>-- | Get a dynamic representation of an architecture's width
<span class="lineno"> 2865 </span>archWidth :: KnownNat (ArchWidth arch) =&gt; f arch -&gt; NatRepr (ArchWidth arch)
<span class="lineno"> 2866 </span><span class="decl"><span class="nottickedoff">archWidth _ = knownNat</span></span>
<span class="lineno"> 2867 </span>
<span class="lineno"> 2868 </span>-- | Type-check a Crucibe block id into a 'TypedBlockID'
<span class="lineno"> 2869 </span>tcBlockID :: BlockID cblocks args -&gt;
<span class="lineno"> 2870 </span>             StmtPermCheckM ext cblocks blocks tops rets ps ps
<span class="lineno"> 2871 </span>             (TypedBlockID blocks (CtxToRList args))
<span class="lineno"> 2872 </span><span class="decl"><span class="nottickedoff">tcBlockID blkID = stLookupBlockID blkID &lt;$&gt; top_get</span></span>
<span class="lineno"> 2873 </span>
<span class="lineno"> 2874 </span>-- | Type-check a Crucible expression to test if it has a statically known
<span class="lineno"> 2875 </span>-- 'PermExpr' value that we can use as an @eq(e)@ permission on the output of
<span class="lineno"> 2876 </span>-- the expression
<span class="lineno"> 2877 </span>tcExpr ::
<span class="lineno"> 2878 </span>  forall ext tp cblocks blocks tops rets ps exprExt.
<span class="lineno"> 2879 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 2880 </span>  App ext RegWithVal tp -&gt;
<span class="lineno"> 2881 </span>  StmtPermCheckM ext cblocks blocks tops rets ps ps (Maybe (PermExpr tp))
<span class="lineno"> 2882 </span><span class="decl"><span class="nottickedoff">tcExpr (ExtensionApp _e_ext :: App ext RegWithVal tp)</span>
<span class="lineno"> 2883 </span><span class="spaces">  </span><span class="nottickedoff">| ExtRepr_LLVM &lt;- knownRepr :: ExtRepr ext</span>
<span class="lineno"> 2884 </span><span class="spaces">  </span><span class="nottickedoff">= error &quot;tcExpr: unexpected LLVM expression&quot;</span>
<span class="lineno"> 2885 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2886 </span><span class="spaces"></span><span class="nottickedoff">-- Equality expressions --</span>
<span class="lineno"> 2887 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2888 </span><span class="spaces"></span><span class="nottickedoff">-- For equalities, we can definitely return True if the values of the two</span>
<span class="lineno"> 2889 </span><span class="spaces"></span><span class="nottickedoff">-- expressions being compared are equal, but we can only return False if we know</span>
<span class="lineno"> 2890 </span><span class="spaces"></span><span class="nottickedoff">-- for sure that the two values are unequal. If, e.g., one is a variable with</span>
<span class="lineno"> 2891 </span><span class="spaces"></span><span class="nottickedoff">-- unknown value, it could equal anything, so we know nothing about the result</span>
<span class="lineno"> 2892 </span><span class="spaces"></span><span class="nottickedoff">-- of the equality test.</span>
<span class="lineno"> 2893 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolEq (RegWithVal _ (PExpr_Bool b1))</span>
<span class="lineno"> 2894 </span><span class="spaces">        </span><span class="nottickedoff">(RegWithVal _ (PExpr_Bool b2))) =</span>
<span class="lineno"> 2895 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool (b1 == b2)</span>
<span class="lineno"> 2896 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolEq rwv1 rwv2)</span>
<span class="lineno"> 2897 </span><span class="spaces">  </span><span class="nottickedoff">| regWithValExpr rwv1 == regWithValExpr rwv2 =</span>
<span class="lineno"> 2898 </span><span class="spaces">    </span><span class="nottickedoff">pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2899 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (NatEq (RegWithVal _ (PExpr_Nat i1))</span>
<span class="lineno"> 2900 </span><span class="spaces">        </span><span class="nottickedoff">(RegWithVal _ (PExpr_Nat i2))) =</span>
<span class="lineno"> 2901 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool (i1 == i2)</span>
<span class="lineno"> 2902 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (NatEq rwv1 rwv2)</span>
<span class="lineno"> 2903 </span><span class="spaces">  </span><span class="nottickedoff">| regWithValExpr rwv1 == regWithValExpr rwv2 =</span>
<span class="lineno"> 2904 </span><span class="spaces">    </span><span class="nottickedoff">pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2905 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVEq _ (RegWithVal _ bv1) (RegWithVal _ bv2))</span>
<span class="lineno"> 2906 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq bv1 bv2 = pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2907 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVEq _ (RegWithVal _ bv1) (RegWithVal _ bv2))</span>
<span class="lineno"> 2908 </span><span class="spaces">  </span><span class="nottickedoff">| not (bvCouldEqual bv1 bv2) = pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 2909 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVEq _ rwv1 rwv2)</span>
<span class="lineno"> 2910 </span><span class="spaces">  </span><span class="nottickedoff">| regWithValExpr rwv1 == regWithValExpr rwv2 =</span>
<span class="lineno"> 2911 </span><span class="spaces">    </span><span class="nottickedoff">pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2912 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BaseIsEq _ rwv1 rwv2)</span>
<span class="lineno"> 2913 </span><span class="spaces">  </span><span class="nottickedoff">| regWithValExpr rwv1 == regWithValExpr rwv2 =</span>
<span class="lineno"> 2914 </span><span class="spaces">    </span><span class="nottickedoff">pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2915 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2916 </span><span class="spaces"></span><span class="nottickedoff">-- Boolean expressions --</span>
<span class="lineno"> 2917 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2918 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolLit b) = pure $ Just $ PExpr_Bool b</span>
<span class="lineno"> 2919 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2920 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (Not (RegWithVal _ (PExpr_Bool b))) =</span>
<span class="lineno"> 2921 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool $ not b</span>
<span class="lineno"> 2922 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2923 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (And (RegWithVal _ (PExpr_Bool False)) _) =</span>
<span class="lineno"> 2924 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 2925 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (And _ (RegWithVal _ (PExpr_Bool False))) =</span>
<span class="lineno"> 2926 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 2927 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (And (RegWithVal _ (PExpr_Bool True)) rwv) =</span>
<span class="lineno"> 2928 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ regWithValExpr rwv</span>
<span class="lineno"> 2929 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (And rwv (RegWithVal _ (PExpr_Bool True))) =</span>
<span class="lineno"> 2930 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ regWithValExpr rwv</span>
<span class="lineno"> 2931 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2932 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (Or (RegWithVal _ (PExpr_Bool True)) _) =</span>
<span class="lineno"> 2933 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2934 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (Or _ (RegWithVal _ (PExpr_Bool True))) =</span>
<span class="lineno"> 2935 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2936 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (Or (RegWithVal _ (PExpr_Bool False)) rwv) =</span>
<span class="lineno"> 2937 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ regWithValExpr rwv</span>
<span class="lineno"> 2938 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (Or rwv (RegWithVal _ (PExpr_Bool False))) =</span>
<span class="lineno"> 2939 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ regWithValExpr rwv</span>
<span class="lineno"> 2940 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2941 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolXor (RegWithVal _ (PExpr_Bool False)) rwv) =</span>
<span class="lineno"> 2942 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ regWithValExpr rwv</span>
<span class="lineno"> 2943 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolXor rwv (RegWithVal _ (PExpr_Bool False))) =</span>
<span class="lineno"> 2944 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ regWithValExpr rwv</span>
<span class="lineno"> 2945 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolXor (RegWithVal _ (PExpr_Bool True))</span>
<span class="lineno"> 2946 </span><span class="spaces">        </span><span class="nottickedoff">(RegWithVal _ (PExpr_Bool True))) =</span>
<span class="lineno"> 2947 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 2948 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2949 </span><span class="spaces"></span><span class="nottickedoff">-- Nat expressions --</span>
<span class="lineno"> 2950 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2951 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (NatLit i) = pure $ Just $ PExpr_Nat i</span>
<span class="lineno"> 2952 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2953 </span><span class="spaces"></span><span class="nottickedoff">-- Bitvector expressions --</span>
<span class="lineno"> 2954 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2955 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVUndef _w) =</span>
<span class="lineno"> 2956 </span><span class="spaces">  </span><span class="nottickedoff">-- &quot;Undefined&quot; bitvectors are translated to 0 as a stand-in but we don't</span>
<span class="lineno"> 2957 </span><span class="spaces">  </span><span class="nottickedoff">-- return any equality permissions about them</span>
<span class="lineno"> 2958 </span><span class="spaces">  </span><span class="nottickedoff">pure Nothing</span>
<span class="lineno"> 2959 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2960 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVLit w (BV.BV i)) = withKnownNat w $ pure $ Just $ bvInt i</span>
<span class="lineno"> 2961 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2962 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVTrunc w2 _ (RegWithVal _ (bvMatchConst -&gt; Just bv))) =</span>
<span class="lineno"> 2963 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w2 $ pure $ Just $ bvBV $ BV.trunc w2 bv</span>
<span class="lineno"> 2964 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVZext w2 _ (RegWithVal _ (bvMatchConst -&gt; Just bv))) =</span>
<span class="lineno"> 2965 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w2 $ pure $ Just $ bvBV $ BV.zext w2 bv</span>
<span class="lineno"> 2966 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVSext w2 w (RegWithVal _ (bvMatchConst -&gt; Just bv))) =</span>
<span class="lineno"> 2967 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w2 $ pure $ Just $ bvBV $ BV.sext w w2 bv</span>
<span class="lineno"> 2968 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2969 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVNot w (RegWithVal _ (bvMatchConst -&gt; Just bv))) =</span>
<span class="lineno"> 2970 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvBV $ BV.complement w bv</span>
<span class="lineno"> 2971 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVAnd w (RegWithVal _ (bvMatchConst -&gt;</span>
<span class="lineno"> 2972 </span><span class="spaces">                               </span><span class="nottickedoff">Just bv1)) (RegWithVal _</span>
<span class="lineno"> 2973 </span><span class="spaces">                                           </span><span class="nottickedoff">(bvMatchConst -&gt; Just bv2))) =</span>
<span class="lineno"> 2974 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvBV $ BV.and bv1 bv2</span>
<span class="lineno"> 2975 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVOr w (RegWithVal _ (bvMatchConst -&gt;</span>
<span class="lineno"> 2976 </span><span class="spaces">                               </span><span class="nottickedoff">Just bv1)) (RegWithVal _</span>
<span class="lineno"> 2977 </span><span class="spaces">                                           </span><span class="nottickedoff">(bvMatchConst -&gt; Just bv2))) =</span>
<span class="lineno"> 2978 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvBV $ BV.or bv1 bv2</span>
<span class="lineno"> 2979 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVXor w (RegWithVal _ (bvMatchConst -&gt;</span>
<span class="lineno"> 2980 </span><span class="spaces">                               </span><span class="nottickedoff">Just bv1)) (RegWithVal _</span>
<span class="lineno"> 2981 </span><span class="spaces">                                           </span><span class="nottickedoff">(bvMatchConst -&gt; Just bv2))) =</span>
<span class="lineno"> 2982 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvBV $ BV.xor bv1 bv2</span>
<span class="lineno"> 2983 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2984 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVAdd w (RegWithVal _ e1) (RegWithVal _ e2)) =</span>
<span class="lineno"> 2985 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvAdd e1 e2</span>
<span class="lineno"> 2986 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2987 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVMul w (RegWithVal _ (bvMatchConstInt -&gt; Just i)) (RegWithVal _ e)) =</span>
<span class="lineno"> 2988 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvMult i e</span>
<span class="lineno"> 2989 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVMul w (RegWithVal _ e) (RegWithVal _ (bvMatchConstInt -&gt; Just i))) =</span>
<span class="lineno"> 2990 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvMult i e</span>
<span class="lineno"> 2991 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2992 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolToBV w (RegWithVal _ (PExpr_Bool True))) =</span>
<span class="lineno"> 2993 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvInt 1</span>
<span class="lineno"> 2994 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BoolToBV w (RegWithVal _ (PExpr_Bool False))) =</span>
<span class="lineno"> 2995 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $ pure $ Just $ bvInt 0</span>
<span class="lineno"> 2996 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 2997 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVUlt _ (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 2998 </span><span class="spaces">  </span><span class="nottickedoff">| bvLt e1 e2 = pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 2999 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVUlt _ (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3000 </span><span class="spaces">  </span><span class="nottickedoff">| not (bvCouldBeLt e1 e2) = pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 3001 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVUle _ (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3002 </span><span class="spaces">  </span><span class="nottickedoff">| bvLt e2 e1 = pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 3003 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVUle _ (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3004 </span><span class="spaces">  </span><span class="nottickedoff">| not (bvCouldBeLt e2 e1) = pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 3005 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3006 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVSlt w (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3007 </span><span class="spaces">  </span><span class="nottickedoff">| withKnownNat w $ bvSLt e1 e2</span>
<span class="lineno"> 3008 </span><span class="spaces">  </span><span class="nottickedoff">= pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 3009 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVSlt w (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3010 </span><span class="spaces">  </span><span class="nottickedoff">| withKnownNat w $ not (bvCouldBeSLt e1 e2)</span>
<span class="lineno"> 3011 </span><span class="spaces">  </span><span class="nottickedoff">= pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 3012 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVSle w (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3013 </span><span class="spaces">  </span><span class="nottickedoff">| withKnownNat w $ bvSLt e2 e1</span>
<span class="lineno"> 3014 </span><span class="spaces">  </span><span class="nottickedoff">= pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 3015 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVSle w (RegWithVal _ e1) (RegWithVal _ e2))</span>
<span class="lineno"> 3016 </span><span class="spaces">  </span><span class="nottickedoff">| withKnownNat w $ not (bvCouldBeSLt e2 e1)</span>
<span class="lineno"> 3017 </span><span class="spaces">  </span><span class="nottickedoff">= pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 3018 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3019 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVNonzero w (RegWithVal _ bv))</span>
<span class="lineno"> 3020 </span><span class="spaces">  </span><span class="nottickedoff">| bvEq bv (withKnownNat w $ bvInt 0) = pure $ Just $ PExpr_Bool False</span>
<span class="lineno"> 3021 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (BVNonzero _ (RegWithVal _ bv))</span>
<span class="lineno"> 3022 </span><span class="spaces">  </span><span class="nottickedoff">| not (bvZeroable bv) = pure $ Just $ PExpr_Bool True</span>
<span class="lineno"> 3023 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3024 </span><span class="spaces"></span><span class="nottickedoff">-- String expressions --</span>
<span class="lineno"> 3025 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3026 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (StringLit (UnicodeLiteral text)) =</span>
<span class="lineno"> 3027 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_String $ Text.unpack text</span>
<span class="lineno"> 3028 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3029 </span><span class="spaces"></span><span class="nottickedoff">-- Struct expressions --</span>
<span class="lineno"> 3030 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3031 </span><span class="spaces"></span><span class="nottickedoff">-- For a struct built from registers r1, ..., rn, return struct(r1,...,rn)</span>
<span class="lineno"> 3032 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (MkStruct _ vars) =</span>
<span class="lineno"> 3033 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Struct $ namesToExprs $</span>
<span class="lineno"> 3034 </span><span class="spaces">  </span><span class="nottickedoff">RL.map (typedRegVar . regWithValReg) $ assignToRList vars</span>
<span class="lineno"> 3035 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3036 </span><span class="spaces"></span><span class="nottickedoff">-- For GetStruct x ix, if x has a value it will have been eta-expanded to a</span>
<span class="lineno"> 3037 </span><span class="spaces"></span><span class="nottickedoff">-- struct expression, so simply get out the required field of that struct</span>
<span class="lineno"> 3038 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (GetStruct (RegWithVal r (PExpr_Struct es)) ix _) =</span>
<span class="lineno"> 3039 </span><span class="spaces">  </span><span class="nottickedoff">getVarType (typedRegVar r) &gt;&gt;= \(StructRepr tps) -&gt;</span>
<span class="lineno"> 3040 </span><span class="spaces">  </span><span class="nottickedoff">let memb = indexToMember (Ctx.size tps) ix in</span>
<span class="lineno"> 3041 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ RL.get memb (exprsToRAssign es)</span>
<span class="lineno"> 3042 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3043 </span><span class="spaces"></span><span class="nottickedoff">-- For SetStruct x ix y, if x has a value it will have been eta-expanded to a</span>
<span class="lineno"> 3044 </span><span class="spaces"></span><span class="nottickedoff">-- struct expression, so simply replace required field of that struct with y</span>
<span class="lineno"> 3045 </span><span class="spaces"></span><span class="nottickedoff">tcExpr (SetStruct tps (RegWithVal _ (PExpr_Struct es)) ix r') =</span>
<span class="lineno"> 3046 </span><span class="spaces">  </span><span class="nottickedoff">let memb = indexToMember (Ctx.size tps) ix in</span>
<span class="lineno"> 3047 </span><span class="spaces">  </span><span class="nottickedoff">pure $ Just $ PExpr_Struct $ rassignToExprs $</span>
<span class="lineno"> 3048 </span><span class="spaces">  </span><span class="nottickedoff">RL.set memb (PExpr_Var $ typedRegVar $ regWithValReg r') $</span>
<span class="lineno"> 3049 </span><span class="spaces">  </span><span class="nottickedoff">exprsToRAssign es</span>
<span class="lineno"> 3050 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3051 </span><span class="spaces"></span><span class="nottickedoff">-- Misc expressions --</span>
<span class="lineno"> 3052 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3053 </span><span class="spaces"></span><span class="nottickedoff">tcExpr _ = pure Nothing</span></span>
<span class="lineno"> 3054 </span>
<span class="lineno"> 3055 </span>
<span class="lineno"> 3056 </span>-- | Test if a sequence of arguments could potentially satisfy some function
<span class="lineno"> 3057 </span>-- input permissions. This is an overapproximation, meaning that we might return
<span class="lineno"> 3058 </span>-- 'True' even if the arguments do not satisfy the permissions.
<span class="lineno"> 3059 </span>couldSatisfyPermsM :: PermCheckExtC ext exprExt =&gt; CruCtx args -&gt; TypedRegs args -&gt;
<span class="lineno"> 3060 </span>                      Mb ghosts (ValuePerms args) -&gt;
<span class="lineno"> 3061 </span>                      StmtPermCheckM ext cblocks blocks tops rets ps ps Bool
<span class="lineno"> 3062 </span><span class="decl"><span class="nottickedoff">couldSatisfyPermsM CruCtxNil _ _ = pure True</span>
<span class="lineno"> 3063 </span><span class="spaces"></span><span class="nottickedoff">couldSatisfyPermsM (CruCtxCons tps (BVRepr _)) (TypedRegsCons args arg)</span>
<span class="lineno"> 3064 </span><span class="spaces">                   </span><span class="nottickedoff">(mbMatch -&gt; [nuMP| ValPerms_Cons ps (ValPerm_Eq mb_e) |]) =</span>
<span class="lineno"> 3065 </span><span class="spaces">  </span><span class="nottickedoff">do b &lt;- couldSatisfyPermsM tps args ps</span>
<span class="lineno"> 3066 </span><span class="spaces">     </span><span class="nottickedoff">arg_val &lt;- getRegEqualsExpr arg</span>
<span class="lineno"> 3067 </span><span class="spaces">     </span><span class="nottickedoff">pure (b &amp;&amp; mbLift (fmap (bvCouldEqual arg_val) mb_e))</span>
<span class="lineno"> 3068 </span><span class="spaces"></span><span class="nottickedoff">couldSatisfyPermsM (CruCtxCons tps _) (TypedRegsCons args arg)</span>
<span class="lineno"> 3069 </span><span class="spaces">                   </span><span class="nottickedoff">(mbMatch -&gt; [nuMP| ValPerms_Cons ps</span>
<span class="lineno"> 3070 </span><span class="spaces">                                       </span><span class="nottickedoff">(ValPerm_Eq (PExpr_LLVMWord mb_e)) |]) =</span>
<span class="lineno"> 3071 </span><span class="spaces">  </span><span class="nottickedoff">do b &lt;- couldSatisfyPermsM tps args ps</span>
<span class="lineno"> 3072 </span><span class="spaces">     </span><span class="nottickedoff">getRegEqualsExpr arg &gt;&gt;= \case</span>
<span class="lineno"> 3073 </span><span class="spaces">       </span><span class="nottickedoff">PExpr_LLVMWord e -&gt;</span>
<span class="lineno"> 3074 </span><span class="spaces">         </span><span class="nottickedoff">pure (b &amp;&amp; mbLift (fmap (bvCouldEqual e) mb_e))</span>
<span class="lineno"> 3075 </span><span class="spaces">       </span><span class="nottickedoff">_ -&gt; pure False</span>
<span class="lineno"> 3076 </span><span class="spaces"></span><span class="nottickedoff">couldSatisfyPermsM (CruCtxCons tps _) (TypedRegsCons args _)</span>
<span class="lineno"> 3077 </span><span class="spaces">                   </span><span class="nottickedoff">(mbMatch -&gt; [nuMP| ValPerms_Cons ps _ |]) =</span>
<span class="lineno"> 3078 </span><span class="spaces">  </span><span class="nottickedoff">couldSatisfyPermsM tps args ps</span></span>
<span class="lineno"> 3079 </span>
<span class="lineno"> 3080 </span>
<span class="lineno"> 3081 </span>-- | Typecheck a statement and emit it in the current statement sequence,
<span class="lineno"> 3082 </span>-- starting and ending with an empty stack of distinguished permissions
<span class="lineno"> 3083 </span>tcEmitStmt ::
<span class="lineno"> 3084 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 3085 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 3086 </span>  ProgramLoc -&gt;
<span class="lineno"> 3087 </span>  Stmt ext ctx ctx' -&gt;
<span class="lineno"> 3088 </span>  StmtPermCheckM ext cblocks blocks tops rets RNil RNil (CtxTrans ctx')
<span class="lineno"> 3089 </span><span class="decl"><span class="nottickedoff">tcEmitStmt ctx loc stmt =</span>
<span class="lineno"> 3090 </span><span class="spaces">  </span><span class="nottickedoff">do _     &lt;- stmtTraceM (const (pretty &quot;Type-checking statement:&quot; &lt;+&gt;</span>
<span class="lineno"> 3091 </span><span class="spaces">                                 </span><span class="nottickedoff">ppStmt (size ctx) stmt))</span>
<span class="lineno"> 3092 </span><span class="spaces">     </span><span class="nottickedoff">!_    &lt;- permGetPPInfo</span>
<span class="lineno"> 3093 </span><span class="spaces">     </span><span class="nottickedoff">!pps  &lt;- mapM (\(Some r) -&gt; ppCruRegAndPerms ctx r) (stmtInputRegs stmt)</span>
<span class="lineno"> 3094 </span><span class="spaces">     </span><span class="nottickedoff">!_    &lt;- stmtTraceM (\_-&gt; pretty &quot;Input perms:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 3095 </span><span class="spaces">                               </span><span class="nottickedoff">ppCommaSep pps)</span>
<span class="lineno"> 3096 </span><span class="spaces">     </span><span class="nottickedoff">!ctx' &lt;- tcEmitStmt' ctx loc stmt</span>
<span class="lineno"> 3097 </span><span class="spaces">     </span><span class="nottickedoff">!pps' &lt;- mapM (\(Some r) -&gt; ppCruRegAndPerms ctx' r)</span>
<span class="lineno"> 3098 </span><span class="spaces">                   </span><span class="nottickedoff">(stmtOutputRegs (Ctx.size ctx') stmt)</span>
<span class="lineno"> 3099 </span><span class="spaces">     </span><span class="nottickedoff">_     &lt;- stmtTraceM (const (pretty &quot;Output perms:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 3100 </span><span class="spaces">                                 </span><span class="nottickedoff">ppCommaSep pps'))</span>
<span class="lineno"> 3101 </span><span class="spaces">     </span><span class="nottickedoff">pure ctx'</span></span>
<span class="lineno"> 3102 </span>
<span class="lineno"> 3103 </span>
<span class="lineno"> 3104 </span>tcEmitStmt' ::
<span class="lineno"> 3105 </span>  forall ext ctx ctx' cblocks blocks tops rets exprExt.
<span class="lineno"> 3106 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 3107 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 3108 </span>  ProgramLoc -&gt;
<span class="lineno"> 3109 </span>  Stmt ext ctx ctx' -&gt;
<span class="lineno"> 3110 </span>  StmtPermCheckM ext cblocks blocks tops rets RNil RNil
<span class="lineno"> 3111 </span>    (CtxTrans ctx')
<span class="lineno"> 3112 </span>
<span class="lineno"> 3113 </span><span class="decl"><span class="nottickedoff">tcEmitStmt' ctx loc (SetReg _ (App (ExtensionApp e_ext</span>
<span class="lineno"> 3114 </span><span class="spaces">                                    </span><span class="nottickedoff">:: App ext (Reg ctx) tp)))</span>
<span class="lineno"> 3115 </span><span class="spaces">  </span><span class="nottickedoff">| ExtRepr_LLVM &lt;- knownRepr :: ExtRepr ext</span>
<span class="lineno"> 3116 </span><span class="spaces">  </span><span class="nottickedoff">= tcEmitLLVMSetExpr ctx loc e_ext</span>
<span class="lineno"> 3117 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3118 </span><span class="spaces"></span><span class="nottickedoff">tcEmitStmt' ctx loc (SetReg tp (App e)) =</span>
<span class="lineno"> 3119 </span><span class="spaces">  </span><span class="nottickedoff">traverseFC (tcRegWithVal ctx) e &gt;&gt;= \e_with_vals -&gt;</span>
<span class="lineno"> 3120 </span><span class="spaces">  </span><span class="nottickedoff">tcExpr e_with_vals &gt;&gt;= \maybe_val -&gt;</span>
<span class="lineno"> 3121 </span><span class="spaces">  </span><span class="nottickedoff">let typed_e = TypedExpr e_with_vals maybe_val in</span>
<span class="lineno"> 3122 </span><span class="spaces">  </span><span class="nottickedoff">let stmt_rets = (singletonCruCtx tp) in</span>
<span class="lineno"> 3123 </span><span class="spaces">  </span><span class="nottickedoff">dbgNames' stmt_rets &gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3124 </span><span class="spaces">  </span><span class="nottickedoff">emitStmt stmt_rets names loc (TypedSetReg tp typed_e) &gt;&gt;&gt;= \(_ :&gt;: x) -&gt;</span>
<span class="lineno"> 3125 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3126 </span><span class="spaces">  </span><span class="nottickedoff">pure (addCtxName ctx x)</span>
<span class="lineno"> 3127 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3128 </span><span class="spaces"></span><span class="nottickedoff">tcEmitStmt' ctx loc (ExtendAssign stmt_ext :: Stmt ext ctx ctx')</span>
<span class="lineno"> 3129 </span><span class="spaces">  </span><span class="nottickedoff">| ExtRepr_LLVM &lt;- knownRepr :: ExtRepr ext</span>
<span class="lineno"> 3130 </span><span class="spaces">  </span><span class="nottickedoff">= tcEmitLLVMStmt Proxy ctx loc stmt_ext</span>
<span class="lineno"> 3131 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3132 </span><span class="spaces"></span><span class="nottickedoff">tcEmitStmt' ctx loc (CallHandle _ret freg_untyped _args_ctx args_untyped) =</span>
<span class="lineno"> 3133 </span><span class="spaces">  </span><span class="nottickedoff">let freg = tcReg ctx freg_untyped</span>
<span class="lineno"> 3134 </span><span class="spaces">      </span><span class="nottickedoff">args = tcRegs ctx args_untyped</span>
<span class="lineno"> 3135 </span><span class="spaces">      </span><span class="nottickedoff">{- args_subst = typedRegsToVarSubst args -} in</span>
<span class="lineno"> 3136 </span><span class="spaces">  </span><span class="nottickedoff">{- getVarTypes (typedRegsToVars args) &gt;&gt;&gt;= \argTypes -&gt; -}</span>
<span class="lineno"> 3137 </span><span class="spaces">  </span><span class="nottickedoff">getSimpleRegPerm freg &gt;&gt;&gt;= \p_freg -&gt;</span>
<span class="lineno"> 3138 </span><span class="spaces">  </span><span class="nottickedoff">(case p_freg of</span>
<span class="lineno"> 3139 </span><span class="spaces">      </span><span class="nottickedoff">ValPerm_Conj ps -&gt;</span>
<span class="lineno"> 3140 </span><span class="spaces">        </span><span class="nottickedoff">forM ps $ \p -&gt; case p of</span>
<span class="lineno"> 3141 </span><span class="spaces">        </span><span class="nottickedoff">Perm_Fun fun_perm -&gt;</span>
<span class="lineno"> 3142 </span><span class="spaces">          </span><span class="nottickedoff">-- FIXME: rewrite couldSatisfyPermsM to fit ghosts having permissions</span>
<span class="lineno"> 3143 </span><span class="spaces">          </span><span class="nottickedoff">{- couldSatisfyPermsM argTypes args (fmap (varSubst args_subst) $</span>
<span class="lineno"> 3144 </span><span class="spaces">                                            </span><span class="nottickedoff">funPermIns fun_perm) &gt;&gt;&gt;= \could -&gt; -}</span>
<span class="lineno"> 3145 </span><span class="spaces">          </span><span class="nottickedoff">let could = True in</span>
<span class="lineno"> 3146 </span><span class="spaces">          </span><span class="nottickedoff">pure (if could then Just (SomeFunPerm fun_perm) else Nothing)</span>
<span class="lineno"> 3147 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; pure Nothing</span>
<span class="lineno"> 3148 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; pure []) &gt;&gt;&gt;= \maybe_fun_perms -&gt;</span>
<span class="lineno"> 3149 </span><span class="spaces">  </span><span class="nottickedoff">(stmtEmbedImplM $ foldr1WithDefault (implCatchM &quot;tcEmitStmt (fun perm)&quot; $</span>
<span class="lineno"> 3150 </span><span class="spaces">                                       </span><span class="nottickedoff">typedRegVar freg)</span>
<span class="lineno"> 3151 </span><span class="spaces">   </span><span class="nottickedoff">(implFailM FunctionPermissionError)</span>
<span class="lineno"> 3152 </span><span class="spaces">   </span><span class="nottickedoff">(mapMaybe (fmap pure) maybe_fun_perms)) &gt;&gt;&gt;= \some_fun_perm -&gt;</span>
<span class="lineno"> 3153 </span><span class="spaces">  </span><span class="nottickedoff">case some_fun_perm of</span>
<span class="lineno"> 3154 </span><span class="spaces">    </span><span class="nottickedoff">SomeFunPerm fun_perm -&gt;</span>
<span class="lineno"> 3155 </span><span class="spaces">      </span><span class="nottickedoff">let ghosts = funPermGhosts fun_perm</span>
<span class="lineno"> 3156 </span><span class="spaces">          </span><span class="nottickedoff">args_ns = typedRegsToVars args</span>
<span class="lineno"> 3157 </span><span class="spaces">          </span><span class="nottickedoff">rets = funPermRets fun_perm in</span>
<span class="lineno"> 3158 </span><span class="spaces">      </span><span class="nottickedoff">(stmtProvePermsFreshLs ghosts (funPermExDistIns</span>
<span class="lineno"> 3159 </span><span class="spaces">                                     </span><span class="nottickedoff">fun_perm args_ns)) &gt;&gt;&gt;= \gsubst -&gt;</span>
<span class="lineno"> 3160 </span><span class="spaces">      </span><span class="nottickedoff">let gexprs = exprsOfSubst gsubst in</span>
<span class="lineno"> 3161 </span><span class="spaces">      </span><span class="nottickedoff">gets (RL.split ghosts args_ns . distPermsVars . view distPerms . stCurPerms)</span>
<span class="lineno"> 3162 </span><span class="spaces">        </span><span class="nottickedoff">&gt;&gt;&gt;= \(ghosts_ns,_) -&gt;</span>
<span class="lineno"> 3163 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePermsAppend CruCtxNil (emptyMb $</span>
<span class="lineno"> 3164 </span><span class="spaces">                                      </span><span class="nottickedoff">eqDistPerms ghosts_ns gexprs) &gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 3165 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm freg (emptyMb $ ValPerm_Conj1 $ Perm_Fun fun_perm) &gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 3166 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames' rets &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3167 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt rets names loc (TypedCall freg fun_perm</span>
<span class="lineno"> 3168 </span><span class="spaces">                               </span><span class="nottickedoff">(varsToTypedRegs ghosts_ns) gexprs args)</span>
<span class="lineno"> 3169 </span><span class="spaces">      </span><span class="nottickedoff">&gt;&gt;&gt;= \(_ :&gt;: ret') -&gt;</span>
<span class="lineno"> 3170 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3171 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret')</span>
<span class="lineno"> 3172 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3173 </span><span class="spaces"></span><span class="nottickedoff">tcEmitStmt' ctx loc (Assert reg msg) =</span>
<span class="lineno"> 3174 </span><span class="spaces">  </span><span class="nottickedoff">let treg = tcReg ctx reg in</span>
<span class="lineno"> 3175 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr treg &gt;&gt;= \case</span>
<span class="lineno"> 3176 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Bool True -&gt; pure ctx</span>
<span class="lineno"> 3177 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Bool False -&gt; stmtFailM FailedAssertionError</span>
<span class="lineno"> 3178 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; ctx &lt;$ emitStmt CruCtxNil MNil loc (TypedAssert (tcReg ctx reg) (tcReg ctx msg))</span>
<span class="lineno"> 3179 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3180 </span><span class="spaces"></span><span class="nottickedoff">tcEmitStmt' _ _ _ = error &quot;tcEmitStmt: unsupported statement&quot;</span></span>
<span class="lineno"> 3181 </span>
<span class="lineno"> 3182 </span>
<span class="lineno"> 3183 </span>-- | Translate a Crucible assignment of an LLVM expression
<span class="lineno"> 3184 </span>tcEmitLLVMSetExpr ::
<span class="lineno"> 3185 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 3186 </span>  ProgramLoc -&gt;
<span class="lineno"> 3187 </span>  LLVMExtensionExpr (Reg ctx) tp -&gt;
<span class="lineno"> 3188 </span>  StmtPermCheckM LLVM cblocks blocks tops rets RNil RNil
<span class="lineno"> 3189 </span>    (CtxTrans (ctx ::&gt; tp))
<span class="lineno"> 3190 </span>
<span class="lineno"> 3191 </span>-- Type-check a pointer-building expression, which is only valid when the block
<span class="lineno"> 3192 </span>-- = 0, i.e., when building a word
<span class="lineno"> 3193 </span><span class="decl"><span class="nottickedoff">tcEmitLLVMSetExpr ctx loc (LLVM_PointerExpr w blk_reg off_reg) =</span>
<span class="lineno"> 3194 </span><span class="spaces">  </span><span class="nottickedoff">let toff_reg = tcReg ctx off_reg</span>
<span class="lineno"> 3195 </span><span class="spaces">      </span><span class="nottickedoff">tblk_reg = tcReg ctx blk_reg in</span>
<span class="lineno"> 3196 </span><span class="spaces">  </span><span class="nottickedoff">resolveConstant tblk_reg &gt;&gt;= \case</span>
<span class="lineno"> 3197 </span><span class="spaces">    </span><span class="nottickedoff">Just 0 -&gt;</span>
<span class="lineno"> 3198 </span><span class="spaces">      </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3199 </span><span class="spaces">      </span><span class="nottickedoff">withKnownNat w $</span>
<span class="lineno"> 3200 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (ConstructLLVMWord toff_reg) &gt;&gt;&gt;= \x -&gt;</span>
<span class="lineno"> 3201 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3202 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx x)</span>
<span class="lineno"> 3203 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 3204 </span><span class="spaces">      </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 3205 </span><span class="spaces">        </span><span class="nottickedoff">stmtFailM $ NonZeroPointerBlockError (permPretty ppinfo tblk_reg)</span>
<span class="lineno"> 3206 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3207 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check the LLVM value destructor that gets the block value, by either</span>
<span class="lineno"> 3208 </span><span class="spaces"></span><span class="nottickedoff">-- proving a permission eq(llvmword e) and returning block 0 or proving</span>
<span class="lineno"> 3209 </span><span class="spaces"></span><span class="nottickedoff">-- permission is_llvmptr and returning the constant value 1.</span>
<span class="lineno"> 3210 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 3211 </span><span class="spaces"></span><span class="nottickedoff">-- NOTE: our SAW translation does not include any computational content for</span>
<span class="lineno"> 3212 </span><span class="spaces"></span><span class="nottickedoff">-- pointer blocks and offsets, so we cannot represent the actual runtime value</span>
<span class="lineno"> 3213 </span><span class="spaces"></span><span class="nottickedoff">-- of the pointer block of a pointer. We can only know if it is zero or not by</span>
<span class="lineno"> 3214 </span><span class="spaces"></span><span class="nottickedoff">-- using permissions, and we map all non-zero values to 1. This implicitly</span>
<span class="lineno"> 3215 </span><span class="spaces"></span><span class="nottickedoff">-- assumes that the behavior of the program we are verifying is not altered in a</span>
<span class="lineno"> 3216 </span><span class="spaces"></span><span class="nottickedoff">-- meaningful way by mapping the return value of 'LLVM_PointerBlock' to 1 when</span>
<span class="lineno"> 3217 </span><span class="spaces"></span><span class="nottickedoff">-- it is applied to pointers, which is the case for all programs currently</span>
<span class="lineno"> 3218 </span><span class="spaces"></span><span class="nottickedoff">-- generated by Crucible from LLVM.</span>
<span class="lineno"> 3219 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMSetExpr ctx loc (LLVM_PointerBlock w ptr_reg) =</span>
<span class="lineno"> 3220 </span><span class="spaces">  </span><span class="nottickedoff">let tptr_reg = tcReg ctx ptr_reg in</span>
<span class="lineno"> 3221 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $</span>
<span class="lineno"> 3222 </span><span class="spaces">  </span><span class="nottickedoff">getAtomicOrWordLLVMPerms tptr_reg &gt;&gt;&gt;= \case</span>
<span class="lineno"> 3223 </span><span class="spaces">    </span><span class="nottickedoff">Left e -&gt;</span>
<span class="lineno"> 3224 </span><span class="spaces">      </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3225 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (AssertLLVMWord tptr_reg e) &gt;&gt;&gt;= \ret -&gt;</span>
<span class="lineno"> 3226 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3227 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3228 </span><span class="spaces">    </span><span class="nottickedoff">Right _ -&gt;</span>
<span class="lineno"> 3229 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3230 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm tptr_reg (emptyMb $ ValPerm_Conj1 Perm_IsLLVMPtr) &gt;&gt;&gt;</span>
<span class="lineno"> 3231 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (AssertLLVMPtr tptr_reg) &gt;&gt;&gt;</span>
<span class="lineno"> 3232 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3233 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt</span>
<span class="lineno"> 3234 </span><span class="spaces">        </span><span class="nottickedoff">knownRepr names loc</span>
<span class="lineno"> 3235 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3236 </span><span class="spaces">                              </span><span class="nottickedoff">TypedExpr (NatLit 1)</span>
<span class="lineno"> 3237 </span><span class="spaces">                              </span><span class="nottickedoff">(Just $ PExpr_Nat 1)) &gt;&gt;&gt;= \(_ :&gt;: ret) -&gt;</span>
<span class="lineno"> 3238 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3239 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3240 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3241 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check the LLVM value destructor that gets the offset value, by either</span>
<span class="lineno"> 3242 </span><span class="spaces"></span><span class="nottickedoff">-- proving a permission eq(llvmword e) and returning e or proving</span>
<span class="lineno"> 3243 </span><span class="spaces"></span><span class="nottickedoff">-- permission is_llvmptr and returning the constant bitvector value 0.</span>
<span class="lineno"> 3244 </span><span class="spaces"></span><span class="nottickedoff">--</span>
<span class="lineno"> 3245 </span><span class="spaces"></span><span class="nottickedoff">-- NOTE: Just as with 'LLVM_PointerBlock', because our SAW translation does not</span>
<span class="lineno"> 3246 </span><span class="spaces"></span><span class="nottickedoff">-- include any computational content for pointer blocks and offsets, we cannot</span>
<span class="lineno"> 3247 </span><span class="spaces"></span><span class="nottickedoff">-- represent the actual runtime value of the offset of a pointer. We thus return</span>
<span class="lineno"> 3248 </span><span class="spaces"></span><span class="nottickedoff">-- 0 as a dummy value. This implicitly assumes that the behavior of the program</span>
<span class="lineno"> 3249 </span><span class="spaces"></span><span class="nottickedoff">-- we are verifying is not altered in a meaningful way by mapping the return</span>
<span class="lineno"> 3250 </span><span class="spaces"></span><span class="nottickedoff">-- value of 'LLVM_PointerOffset' to 0 when it is applied to pointers, which is</span>
<span class="lineno"> 3251 </span><span class="spaces"></span><span class="nottickedoff">-- the case for all programs currently generated by Crucible from LLVM.</span>
<span class="lineno"> 3252 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMSetExpr ctx loc (LLVM_PointerOffset w ptr_reg) =</span>
<span class="lineno"> 3253 </span><span class="spaces">  </span><span class="nottickedoff">let tptr_reg = tcReg ctx ptr_reg in</span>
<span class="lineno"> 3254 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $</span>
<span class="lineno"> 3255 </span><span class="spaces">  </span><span class="nottickedoff">getAtomicOrWordLLVMPerms tptr_reg &gt;&gt;&gt;= \eith -&gt;</span>
<span class="lineno"> 3256 </span><span class="spaces">  </span><span class="nottickedoff">case eith of</span>
<span class="lineno"> 3257 </span><span class="spaces">    </span><span class="nottickedoff">Left e -&gt;</span>
<span class="lineno"> 3258 </span><span class="spaces">      </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3259 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (DestructLLVMWord</span>
<span class="lineno"> 3260 </span><span class="spaces">                                  </span><span class="nottickedoff">tptr_reg e) &gt;&gt;&gt;= \ret -&gt;</span>
<span class="lineno"> 3261 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3262 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3263 </span><span class="spaces">    </span><span class="nottickedoff">Right _ -&gt;</span>
<span class="lineno"> 3264 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3265 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm tptr_reg (emptyMb $ ValPerm_Conj1 Perm_IsLLVMPtr) &gt;&gt;&gt;</span>
<span class="lineno"> 3266 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (AssertLLVMPtr tptr_reg) &gt;&gt;&gt;</span>
<span class="lineno"> 3267 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3268 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3269 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3270 </span><span class="spaces">         </span><span class="nottickedoff">TypedExpr (BVLit w $ BV.mkBV w 0)</span>
<span class="lineno"> 3271 </span><span class="spaces">         </span><span class="nottickedoff">(Just $ bvInt 0)) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3272 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3273 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3274 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3275 </span><span class="spaces"></span><span class="nottickedoff">-- An if-then-else at pointer type is just preserved, though we propogate</span>
<span class="lineno"> 3276 </span><span class="spaces"></span><span class="nottickedoff">-- equality information when possible</span>
<span class="lineno"> 3277 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMSetExpr ctx loc (LLVM_PointerIte w cond_reg then_reg else_reg) =</span>
<span class="lineno"> 3278 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $</span>
<span class="lineno"> 3279 </span><span class="spaces">  </span><span class="nottickedoff">let tcond_reg = tcReg ctx cond_reg</span>
<span class="lineno"> 3280 </span><span class="spaces">      </span><span class="nottickedoff">tthen_reg = tcReg ctx then_reg</span>
<span class="lineno"> 3281 </span><span class="spaces">      </span><span class="nottickedoff">telse_reg = tcReg ctx else_reg in</span>
<span class="lineno"> 3282 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr tcond_reg &gt;&gt;= \case</span>
<span class="lineno"> 3283 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Bool True -&gt;</span>
<span class="lineno"> 3284 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3285 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3286 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetRegPermExpr knownRepr $</span>
<span class="lineno"> 3287 </span><span class="spaces">          </span><span class="nottickedoff">PExpr_Var $ typedRegVar tthen_reg) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3288 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3289 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3290 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Bool False -&gt;</span>
<span class="lineno"> 3291 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3292 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3293 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetRegPermExpr knownRepr $</span>
<span class="lineno"> 3294 </span><span class="spaces">          </span><span class="nottickedoff">PExpr_Var $ typedRegVar telse_reg) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3295 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3296 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3297 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 3298 </span><span class="spaces">      </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3299 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (TypedLLVMIte w</span>
<span class="lineno"> 3300 </span><span class="spaces">                                  </span><span class="nottickedoff">tcond_reg tthen_reg telse_reg) &gt;&gt;&gt;= \ret -&gt;</span>
<span class="lineno"> 3301 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3302 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3303 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3304 </span><span class="spaces"></span><span class="nottickedoff">-- For LLVM side conditions, treat each side condition as an assert</span>
<span class="lineno"> 3305 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMSetExpr ctx loc (LLVM_SideConditions _ tp conds reg) =</span>
<span class="lineno"> 3306 </span><span class="spaces">  </span><span class="nottickedoff">let treg = tcReg ctx reg in</span>
<span class="lineno"> 3307 </span><span class="spaces">  </span><span class="nottickedoff">foldr</span>
<span class="lineno"> 3308 </span><span class="spaces">  </span><span class="nottickedoff">(\(LLVMSideCondition cond_reg ub) rest_m -&gt;</span>
<span class="lineno"> 3309 </span><span class="spaces">    </span><span class="nottickedoff">let tcond_reg = tcReg ctx cond_reg</span>
<span class="lineno"> 3310 </span><span class="spaces">        </span><span class="nottickedoff">err_msg = pretty &quot;Undefined behavior&quot; &lt;&gt; softline &lt;&gt; UB.explain ub in</span>
<span class="lineno"> 3311 </span><span class="spaces">        </span><span class="nottickedoff">-- err_str = renderDoc (pretty &quot;Undefined behavior: &quot; &lt;&gt; softline &lt;&gt; UB.explain ub) in</span>
<span class="lineno"> 3312 </span><span class="spaces">    </span><span class="nottickedoff">getRegEqualsExpr tcond_reg &gt;&gt;= \case</span>
<span class="lineno"> 3313 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_Bool True -&gt;</span>
<span class="lineno"> 3314 </span><span class="spaces">        </span><span class="nottickedoff">rest_m</span>
<span class="lineno"> 3315 </span><span class="spaces">      </span><span class="nottickedoff">PExpr_Bool False -&gt; stmtFailM $ UndefinedBehaviorError err_msg</span>
<span class="lineno"> 3316 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 3317 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr noNames loc</span>
<span class="lineno"> 3318 </span><span class="spaces">          </span><span class="nottickedoff">(TypedSetRegPermExpr knownRepr $</span>
<span class="lineno"> 3319 </span><span class="spaces">            </span><span class="nottickedoff">PExpr_String (renderDoc err_msg)) &gt;&gt;&gt;= \(_ :&gt;: str_var) -&gt;</span>
<span class="lineno"> 3320 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3321 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt CruCtxNil MNil loc</span>
<span class="lineno"> 3322 </span><span class="spaces">          </span><span class="nottickedoff">(TypedAssert tcond_reg $</span>
<span class="lineno"> 3323 </span><span class="spaces">            </span><span class="nottickedoff">TypedReg str_var) &gt;&gt;&gt;= \MNil -&gt;</span>
<span class="lineno"> 3324 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3325 </span><span class="spaces">        </span><span class="nottickedoff">rest_m)</span>
<span class="lineno"> 3326 </span><span class="spaces">  </span><span class="nottickedoff">(let rets = singletonCruCtx tp in</span>
<span class="lineno"> 3327 </span><span class="spaces">   </span><span class="nottickedoff">dbgNames' rets &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3328 </span><span class="spaces">   </span><span class="nottickedoff">emitStmt rets names loc</span>
<span class="lineno"> 3329 </span><span class="spaces">     </span><span class="nottickedoff">(TypedSetRegPermExpr tp $ PExpr_Var $</span>
<span class="lineno"> 3330 </span><span class="spaces">       </span><span class="nottickedoff">typedRegVar treg) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3331 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3332 </span><span class="spaces">    </span><span class="nottickedoff">pure (addCtxName ctx ret))</span>
<span class="lineno"> 3333 </span><span class="spaces">  </span><span class="nottickedoff">conds</span>
<span class="lineno"> 3334 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMSetExpr _ctx _loc X86Expr{} =</span>
<span class="lineno"> 3335 </span><span class="spaces">  </span><span class="nottickedoff">stmtFailM X86ExprError</span></span>
<span class="lineno"> 3336 </span>
<span class="lineno"> 3337 </span>
<span class="lineno"> 3338 </span>
<span class="lineno"> 3339 </span>-- FIXME HERE: move withLifetimeCurrentPerms somewhere better...
<span class="lineno"> 3340 </span>
<span class="lineno"> 3341 </span>-- | Perform a statement type-checking conversation inside a context where the
<span class="lineno"> 3342 </span>-- supplied lifetime has been proved to be current using the supplied
<span class="lineno"> 3343 </span>-- 'LifetimeCurrentPerms'
<span class="lineno"> 3344 </span>withLifetimeCurrentPerms ::
<span class="lineno"> 3345 </span>  PermCheckExtC ext exprExt =&gt; PermExpr LifetimeType -&gt;
<span class="lineno"> 3346 </span>  (forall ps_l. LifetimeCurrentPerms ps_l -&gt;
<span class="lineno"> 3347 </span>   StmtPermCheckM ext cblocks blocks tops rets (ps_out :++: ps_l)
<span class="lineno"> 3348 </span>   (ps_in :++: ps_l) a) -&gt;
<span class="lineno"> 3349 </span>  StmtPermCheckM ext cblocks blocks tops rets ps_out ps_in a
<span class="lineno"> 3350 </span><span class="decl"><span class="nottickedoff">withLifetimeCurrentPerms l m =</span>
<span class="lineno"> 3351 </span><span class="spaces">  </span><span class="nottickedoff">-- Get the proof steps needed to prove that the lifetime l is current</span>
<span class="lineno"> 3352 </span><span class="spaces">  </span><span class="nottickedoff">stmtEmbedImplM (getLifetimeCurrentPerms l) &gt;&gt;&gt;= \(Some cur_perms) -&gt;</span>
<span class="lineno"> 3353 </span><span class="spaces">  </span><span class="nottickedoff">-- Prove that the required permissions</span>
<span class="lineno"> 3354 </span><span class="spaces">  </span><span class="nottickedoff">stmtEmbedImplM (proveLifetimeCurrent cur_perms) &gt;&gt;&gt;</span>
<span class="lineno"> 3355 </span><span class="spaces">  </span><span class="nottickedoff">-- Perform the computation</span>
<span class="lineno"> 3356 </span><span class="spaces">  </span><span class="nottickedoff">m cur_perms &gt;&gt;&gt;= \a -&gt;</span>
<span class="lineno"> 3357 </span><span class="spaces">  </span><span class="nottickedoff">-- Recombine the proof that the lifetime is current</span>
<span class="lineno"> 3358 </span><span class="spaces">  </span><span class="nottickedoff">stmtEmbedImplM (recombineLifetimeCurrentPerms cur_perms) &gt;&gt;&gt;</span>
<span class="lineno"> 3359 </span><span class="spaces">  </span><span class="nottickedoff">-- Finally, return the result</span>
<span class="lineno"> 3360 </span><span class="spaces">  </span><span class="nottickedoff">pure a</span></span>
<span class="lineno"> 3361 </span>
<span class="lineno"> 3362 </span>
<span class="lineno"> 3363 </span>-- | Emit a 'TypedLLVMLoad' instruction, assuming the given LLVM field
<span class="lineno"> 3364 </span>-- permission is on the top of the stack. Prove the required lifetime
<span class="lineno"> 3365 </span>-- permissions as part of this process, and pop the resulting lifetime
<span class="lineno"> 3366 </span>-- permission off the stack before returning. Return the resulting return
<span class="lineno"> 3367 </span>-- register.
<span class="lineno"> 3368 </span>emitTypedLLVMLoad ::
<span class="lineno"> 3369 </span>  forall w sz arch cblocks blocks tops rets ps.
<span class="lineno"> 3370 </span>  (HasPtrWidth w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 3371 </span>  Proxy arch -&gt; ProgramLoc -&gt;
<span class="lineno"> 3372 </span>  TypedReg (LLVMPointerType w) -&gt; LLVMFieldPerm w sz -&gt; DistPerms ps -&gt;
<span class="lineno"> 3373 </span>  StmtPermCheckM LLVM cblocks blocks tops rets
<span class="lineno"> 3374 </span>  (ps :&gt; LLVMPointerType w :&gt; LLVMPointerType sz)
<span class="lineno"> 3375 </span>  (ps :&gt; LLVMPointerType w)
<span class="lineno"> 3376 </span>  (Name (LLVMPointerType sz))
<span class="lineno"> 3377 </span><span class="decl"><span class="nottickedoff">emitTypedLLVMLoad _ loc treg fp ps =</span>
<span class="lineno"> 3378 </span><span class="spaces">  </span><span class="nottickedoff">withLifetimeCurrentPerms (llvmFieldLifetime fp) $ \cur_perms -&gt;</span>
<span class="lineno"> 3379 </span><span class="spaces">  </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (TypedLLVMLoad treg fp ps cur_perms)</span></span>
<span class="lineno"> 3380 </span>
<span class="lineno"> 3381 </span>
<span class="lineno"> 3382 </span>-- | Emit a 'TypedLLVMStore' instruction, assuming the given LLVM field
<span class="lineno"> 3383 </span>-- permission is on the top of the stack. Prove the required lifetime
<span class="lineno"> 3384 </span>-- permissions as part of this process, and pop the resulting lifetime
<span class="lineno"> 3385 </span>-- permission off the stack before returning. Return the resulting return
<span class="lineno"> 3386 </span>-- register of unit type.
<span class="lineno"> 3387 </span>emitTypedLLVMStore ::
<span class="lineno"> 3388 </span>  (HasPtrWidth w, 1 &lt;= sz, KnownNat sz) =&gt;
<span class="lineno"> 3389 </span>  Proxy arch -&gt;
<span class="lineno"> 3390 </span>  Maybe String -&gt;
<span class="lineno"> 3391 </span>  ProgramLoc -&gt;
<span class="lineno"> 3392 </span>  TypedReg (LLVMPointerType w) -&gt;
<span class="lineno"> 3393 </span>  LLVMFieldPerm w sz -&gt;
<span class="lineno"> 3394 </span>  PermExpr (LLVMPointerType sz) -&gt;
<span class="lineno"> 3395 </span>  DistPerms ps -&gt;
<span class="lineno"> 3396 </span>  StmtPermCheckM LLVM cblocks blocks tops rets
<span class="lineno"> 3397 </span>    (ps :&gt; LLVMPointerType w)
<span class="lineno"> 3398 </span>    (ps :&gt; LLVMPointerType w)
<span class="lineno"> 3399 </span>    (Name UnitType)
<span class="lineno"> 3400 </span><span class="decl"><span class="nottickedoff">emitTypedLLVMStore _ name loc treg_ptr fp e ps =</span>
<span class="lineno"> 3401 </span><span class="spaces">  </span><span class="nottickedoff">withLifetimeCurrentPerms (llvmFieldLifetime fp) $ \cur_perms -&gt;</span>
<span class="lineno"> 3402 </span><span class="spaces">  </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (TypedLLVMStore treg_ptr fp e ps cur_perms)</span></span>
<span class="lineno"> 3403 </span>
<span class="lineno"> 3404 </span>open :: HasPtrWidth wptr =&gt; f (LLVMPointerType wptr) -&gt; NatRepr wptr
<span class="lineno"> 3405 </span><span class="decl"><span class="nottickedoff">open _ = ?ptrWidth</span></span>
<span class="lineno"> 3406 </span>
<span class="lineno"> 3407 </span>-- | Typecheck a statement and emit it in the current statement sequence,
<span class="lineno"> 3408 </span>-- starting and ending with an empty stack of distinguished permissions
<span class="lineno"> 3409 </span>tcEmitLLVMStmt ::
<span class="lineno"> 3410 </span>  forall arch ctx tp cblocks blocks tops rets.
<span class="lineno"> 3411 </span>  Proxy arch -&gt;
<span class="lineno"> 3412 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 3413 </span>  ProgramLoc -&gt;
<span class="lineno"> 3414 </span>  LLVMStmt (Reg ctx) tp -&gt;
<span class="lineno"> 3415 </span>  StmtPermCheckM LLVM cblocks blocks tops rets RNil RNil
<span class="lineno"> 3416 </span>    (CtxTrans (ctx ::&gt; tp))
<span class="lineno"> 3417 </span>
<span class="lineno"> 3418 </span>-- Type-check a load of an LLVM pointer by requiring a ptr permission and using
<span class="lineno"> 3419 </span>-- TypedLLVMLoad, rounding up the size of the load to a whole number of bytes
<span class="lineno"> 3420 </span><span class="decl"><span class="nottickedoff">tcEmitLLVMStmt arch ctx loc (LLVM_Load _ ptr tp storage _)</span>
<span class="lineno"> 3421 </span><span class="spaces">  </span><span class="nottickedoff">| sz_bits &lt;- bytesToBits $ storageTypeSize storage</span>
<span class="lineno"> 3422 </span><span class="spaces">  </span><span class="nottickedoff">, sz_rnd_bits &lt;- 8 * ceil_div sz_bits 8</span>
<span class="lineno"> 3423 </span><span class="spaces">  </span><span class="nottickedoff">, Just (Some (sz_rnd :: NatRepr sz_rnd)) &lt;- someNat sz_rnd_bits</span>
<span class="lineno"> 3424 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof &lt;- decideLeq (knownNat @1) sz_rnd</span>
<span class="lineno"> 3425 </span><span class="spaces">  </span><span class="nottickedoff">= withKnownNat ?ptrWidth $ withKnownNat sz_rnd $</span>
<span class="lineno"> 3426 </span><span class="spaces">    </span><span class="nottickedoff">let tptr = tcReg ctx ptr in</span>
<span class="lineno"> 3427 </span><span class="spaces">    </span><span class="nottickedoff">-- Prove [l]ptr((sz_rnd,0,rw) |-&gt; eq(y)) for some l, rw, and y</span>
<span class="lineno"> 3428 </span><span class="spaces">    </span><span class="nottickedoff">stmtProvePerm tptr (llvmPtr0EqExPerm sz_rnd) &gt;&gt;&gt;= \impl_res -&gt;</span>
<span class="lineno"> 3429 </span><span class="spaces">    </span><span class="nottickedoff">let fp = subst impl_res (llvmPtr0EqEx sz_rnd) in</span>
<span class="lineno"> 3430 </span><span class="spaces">    </span><span class="nottickedoff">-- Emit a TypedLLVMLoad instruction</span>
<span class="lineno"> 3431 </span><span class="spaces">    </span><span class="nottickedoff">emitTypedLLVMLoad arch loc tptr fp DistPermsNil &gt;&gt;&gt;= \z -&gt;</span>
<span class="lineno"> 3432 </span><span class="spaces">    </span><span class="nottickedoff">-- Recombine the resulting permissions onto the stack</span>
<span class="lineno"> 3433 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3434 </span><span class="spaces">    </span><span class="nottickedoff">-- Convert the return value to the requested type and return it</span>
<span class="lineno"> 3435 </span><span class="spaces">    </span><span class="nottickedoff">(convertRegType knownRepr loc (TypedReg z) knownRepr tp &gt;&gt;&gt;= \ret -&gt;</span>
<span class="lineno"> 3436 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx $ typedRegVar ret))</span>
<span class="lineno"> 3437 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3438 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: add a case for stores of smaller-than-byte-sized values</span>
<span class="lineno"> 3439 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3440 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a store of an LLVM pointer</span>
<span class="lineno"> 3441 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt arch ctx loc (LLVM_Store _ ptr tp storage _ val)</span>
<span class="lineno"> 3442 </span><span class="spaces">  </span><span class="nottickedoff">| Just (Some sz) &lt;- someNat $ bytesToBits $ storageTypeSize storage</span>
<span class="lineno"> 3443 </span><span class="spaces">  </span><span class="nottickedoff">, Left LeqProof  &lt;- decideLeq (knownNat @1) sz =</span>
<span class="lineno"> 3444 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 3445 </span><span class="spaces">    </span><span class="nottickedoff">withKnownNat sz $</span>
<span class="lineno"> 3446 </span><span class="spaces">    </span><span class="nottickedoff">let tptr = tcReg ctx ptr</span>
<span class="lineno"> 3447 </span><span class="spaces">        </span><span class="nottickedoff">tval = tcReg ctx val in</span>
<span class="lineno"> 3448 </span><span class="spaces">    </span><span class="nottickedoff">convertRegType knownRepr loc tval tp (LLVMPointerRepr sz) &gt;&gt;&gt;= \tval' -&gt;</span>
<span class="lineno"> 3449 </span><span class="spaces">    </span><span class="nottickedoff">stmtProvePerm tptr (llvmWriteTrueExLPerm sz $ bvInt 0) &gt;&gt;&gt;= \sbst -&gt;</span>
<span class="lineno"> 3450 </span><span class="spaces">    </span><span class="nottickedoff">let l = substLookup sbst Member_Base in</span>
<span class="lineno"> 3451 </span><span class="spaces">    </span><span class="nottickedoff">let fp = llvmFieldWriteTrueL sz (bvInt 0) l in</span>
<span class="lineno"> 3452 </span><span class="spaces">    </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3453 </span><span class="spaces">    </span><span class="nottickedoff">emitTypedLLVMStore arch name loc tptr fp</span>
<span class="lineno"> 3454 </span><span class="spaces">    </span><span class="nottickedoff">(PExpr_Var $ typedRegVar tval') DistPermsNil &gt;&gt;&gt;= \z -&gt;</span>
<span class="lineno"> 3455 </span><span class="spaces">    </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3456 </span><span class="spaces">    </span><span class="nottickedoff">pure (addCtxName ctx z)</span>
<span class="lineno"> 3457 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3458 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a clear instruction by getting the list of field permissions</span>
<span class="lineno"> 3459 </span><span class="spaces"></span><span class="nottickedoff">-- returned by 'llvmFieldsOfSize' and storing word 0 to each of them</span>
<span class="lineno"> 3460 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt arch ctx loc (LLVM_MemClear _ (ptr :: Reg ctx (LLVMPointerType wptr)) bytes) =</span>
<span class="lineno"> 3461 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 3462 </span><span class="spaces">  </span><span class="nottickedoff">let tptr = tcReg ctx ptr</span>
<span class="lineno"> 3463 </span><span class="spaces">      </span><span class="nottickedoff">flds = llvmFieldsOfSize @wptr knownNat (bytesToInteger bytes) in</span>
<span class="lineno"> 3464 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3465 </span><span class="spaces">  </span><span class="nottickedoff">-- For each field perm, prove it and write 0 to it</span>
<span class="lineno"> 3466 </span><span class="spaces">  </span><span class="nottickedoff">(forM_ @_ @_ @_ @() flds $ \case</span>
<span class="lineno"> 3467 </span><span class="spaces">      </span><span class="nottickedoff">Perm_LLVMField fp -&gt;</span>
<span class="lineno"> 3468 </span><span class="spaces">        </span><span class="nottickedoff">stmtProvePerm tptr (emptyMb $ ValPerm_Conj1 $ Perm_LLVMField fp) &gt;&gt;&gt;</span>
<span class="lineno"> 3469 </span><span class="spaces">        </span><span class="nottickedoff">emitTypedLLVMStore arch Nothing loc tptr fp (PExpr_LLVMWord (bvInt 0)) DistPermsNil &gt;&gt;&gt;</span>
<span class="lineno"> 3470 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3471 </span><span class="spaces">        </span><span class="nottickedoff">pure ()</span>
<span class="lineno"> 3472 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; error &quot;Unexpected return value from llvmFieldsOfSize&quot;) &gt;&gt;&gt;</span>
<span class="lineno"> 3473 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3474 </span><span class="spaces">  </span><span class="nottickedoff">-- Return a fresh unit variable</span>
<span class="lineno"> 3475 </span><span class="spaces">  </span><span class="nottickedoff">dbgNames &gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3476 </span><span class="spaces">  </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3477 </span><span class="spaces">    </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3478 </span><span class="spaces">      </span><span class="nottickedoff">TypedExpr EmptyApp</span>
<span class="lineno"> 3479 </span><span class="spaces">      </span><span class="nottickedoff">(Just PExpr_Unit)) &gt;&gt;&gt;= \(MNil :&gt;: z) -&gt;</span>
<span class="lineno"> 3480 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3481 </span><span class="spaces">  </span><span class="nottickedoff">pure (addCtxName ctx z)</span>
<span class="lineno"> 3482 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3483 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3484 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 3485 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a non-empty mem-clear instruction by writing a 0 to the last word</span>
<span class="lineno"> 3486 </span><span class="spaces"></span><span class="nottickedoff">-- and then recursively clearing all but the last word</span>
<span class="lineno"> 3487 </span><span class="spaces"></span><span class="nottickedoff">-- FIXME: add support for using non-word-size ptr perms with MemClear</span>
<span class="lineno"> 3488 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt arch ctx loc (LLVM_MemClear mem ptr bytes) =</span>
<span class="lineno"> 3489 </span><span class="spaces">  </span><span class="nottickedoff">let tptr = tcReg ctx ptr</span>
<span class="lineno"> 3490 </span><span class="spaces">      </span><span class="nottickedoff">bytes' = bytes - bitsToBytes (intValue (archWidth arch))</span>
<span class="lineno"> 3491 </span><span class="spaces">      </span><span class="nottickedoff">off = bytesToInteger bytes' in</span>
<span class="lineno"> 3492 </span><span class="spaces">  </span><span class="nottickedoff">stmtProvePerm tptr (llvmWriteTrueExLPerm</span>
<span class="lineno"> 3493 </span><span class="spaces">                      </span><span class="nottickedoff">(archWidth arch) (bvInt off)) &gt;&gt;&gt;= \sbst -&gt;</span>
<span class="lineno"> 3494 </span><span class="spaces">  </span><span class="nottickedoff">let l = substLookup sbst Member_Base in</span>
<span class="lineno"> 3495 </span><span class="spaces">  </span><span class="nottickedoff">let fp = llvmFieldWriteTrueL (archWidth arch) (bvInt off) l in</span>
<span class="lineno"> 3496 </span><span class="spaces">  </span><span class="nottickedoff">emitTypedLLVMStore arch loc tptr fp (PExpr_LLVMWord $</span>
<span class="lineno"> 3497 </span><span class="spaces">                                       </span><span class="nottickedoff">bvInt 0) DistPermsNil &gt;&gt;&gt;</span>
<span class="lineno"> 3498 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3499 </span><span class="spaces">  </span><span class="nottickedoff">tcEmitLLVMStmt arch ctx loc (LLVM_MemClear mem ptr bytes')</span>
<span class="lineno"> 3500 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 3501 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3502 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check an alloca instruction</span>
<span class="lineno"> 3503 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_Alloca w _ sz_reg _ _) =</span>
<span class="lineno"> 3504 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat w $</span>
<span class="lineno"> 3505 </span><span class="spaces">  </span><span class="nottickedoff">let sz_treg = tcReg ctx sz_reg in</span>
<span class="lineno"> 3506 </span><span class="spaces">  </span><span class="nottickedoff">getFramePtr w &gt;&gt;&gt;= \maybe_fp -&gt;</span>
<span class="lineno"> 3507 </span><span class="spaces">  </span><span class="nottickedoff">maybe (pure ValPerm_True) getRegPerm maybe_fp &gt;&gt;&gt;= \fp_perm -&gt;</span>
<span class="lineno"> 3508 </span><span class="spaces">  </span><span class="nottickedoff">resolveConstant sz_treg &gt;&gt;&gt;= \maybe_sz -&gt;</span>
<span class="lineno"> 3509 </span><span class="spaces">  </span><span class="nottickedoff">case (maybe_fp, fp_perm, maybe_sz) of</span>
<span class="lineno"> 3510 </span><span class="spaces">    </span><span class="nottickedoff">(Just fp, ValPerm_Conj [Perm_LLVMFrame fperms], Just sz) -&gt;</span>
<span class="lineno"> 3511 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm fp (emptyMb fp_perm) &gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 3512 </span><span class="spaces">      </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3513 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc</span>
<span class="lineno"> 3514 </span><span class="spaces">        </span><span class="nottickedoff">(TypedLLVMAlloca fp fperms sz) &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 3515 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3516 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx y)</span>
<span class="lineno"> 3517 </span><span class="spaces">    </span><span class="nottickedoff">(_, _, Nothing) -&gt;</span>
<span class="lineno"> 3518 </span><span class="spaces">      </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 3519 </span><span class="spaces">        </span><span class="nottickedoff">stmtFailM $ AllocaError (AllocaNonConstantError $ permPretty ppinfo sz_treg)</span>
<span class="lineno"> 3520 </span><span class="spaces">    </span><span class="nottickedoff">(Just fp, p, _) -&gt;</span>
<span class="lineno"> 3521 </span><span class="spaces">      </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 3522 </span><span class="spaces">        </span><span class="nottickedoff">stmtFailM $ AllocaError $ AllocaFramePermError</span>
<span class="lineno"> 3523 </span><span class="spaces">                                    </span><span class="nottickedoff">(permPretty ppinfo fp)</span>
<span class="lineno"> 3524 </span><span class="spaces">                                    </span><span class="nottickedoff">(permPretty ppinfo p)</span>
<span class="lineno"> 3525 </span><span class="spaces">    </span><span class="nottickedoff">(Nothing, _, _) -&gt;</span>
<span class="lineno"> 3526 </span><span class="spaces">      </span><span class="nottickedoff">stmtFailM $ AllocaError AllocaFramePtrError</span>
<span class="lineno"> 3527 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3528 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a push frame instruction</span>
<span class="lineno"> 3529 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_PushFrame _ _) =</span>
<span class="lineno"> 3530 </span><span class="spaces">  </span><span class="nottickedoff">fmap stArchWidth top_get &gt;&gt;&gt;= \SomePtrWidth -&gt;</span>
<span class="lineno"> 3531 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 3532 </span><span class="spaces">  </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc TypedLLVMCreateFrame &gt;&gt;&gt;= \fp -&gt;</span>
<span class="lineno"> 3533 </span><span class="spaces">  </span><span class="nottickedoff">setFramePtr ?ptrWidth (TypedReg fp) &gt;&gt;&gt;</span>
<span class="lineno"> 3534 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3535 </span><span class="spaces">  </span><span class="nottickedoff">dbgNames &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3536 </span><span class="spaces">  </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3537 </span><span class="spaces">    </span><span class="nottickedoff">(TypedSetReg knownRepr</span>
<span class="lineno"> 3538 </span><span class="spaces">      </span><span class="nottickedoff">(TypedExpr EmptyApp Nothing)) &gt;&gt;&gt;= \(MNil :&gt;: y) -&gt;</span>
<span class="lineno"> 3539 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3540 </span><span class="spaces">  </span><span class="nottickedoff">pure (addCtxName ctx y)</span>
<span class="lineno"> 3541 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3542 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a pop frame instruction</span>
<span class="lineno"> 3543 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_PopFrame _) =</span>
<span class="lineno"> 3544 </span><span class="spaces">  </span><span class="nottickedoff">fmap stArchWidth top_get &gt;&gt;&gt;= \SomePtrWidth -&gt;</span>
<span class="lineno"> 3545 </span><span class="spaces">  </span><span class="nottickedoff">getFramePtr ?ptrWidth &gt;&gt;&gt;= \maybe_fp -&gt;</span>
<span class="lineno"> 3546 </span><span class="spaces">  </span><span class="nottickedoff">maybe (pure ValPerm_True) getRegPerm maybe_fp &gt;&gt;&gt;= \fp_perm -&gt;</span>
<span class="lineno"> 3547 </span><span class="spaces">  </span><span class="nottickedoff">case (maybe_fp, fp_perm) of</span>
<span class="lineno"> 3548 </span><span class="spaces">    </span><span class="nottickedoff">(Just fp, ValPerm_Conj [Perm_LLVMFrame fperms])</span>
<span class="lineno"> 3549 </span><span class="spaces">      </span><span class="nottickedoff">| Some del_perms &lt;- llvmFrameDeletionPerms fperms -&gt;</span>
<span class="lineno"> 3550 </span><span class="spaces">        </span><span class="nottickedoff">stmtProvePerms knownRepr (distPermsToExDistPerms del_perms) &gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 3551 </span><span class="spaces">        </span><span class="nottickedoff">stmtProvePerm fp (emptyMb fp_perm) &gt;&gt;&gt;= \_ -&gt;</span>
<span class="lineno"> 3552 </span><span class="spaces">        </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3553 </span><span class="spaces">        </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc</span>
<span class="lineno"> 3554 </span><span class="spaces">          </span><span class="nottickedoff">(TypedLLVMDeleteFrame fp fperms del_perms) &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 3555 </span><span class="spaces">        </span><span class="nottickedoff">modify (\st -&gt; st { stExtState = PermCheckExtState_LLVM Nothing }) &gt;&gt;&gt;</span>
<span class="lineno"> 3556 </span><span class="spaces">        </span><span class="nottickedoff">pure (addCtxName ctx y)</span>
<span class="lineno"> 3557 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; stmtFailM $ PopFrameError</span>
<span class="lineno"> 3558 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3559 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a pointer offset instruction by emitting OffsetLLVMValue</span>
<span class="lineno"> 3560 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_PtrAddOffset _w _ ptr off) =</span>
<span class="lineno"> 3561 </span><span class="spaces">  </span><span class="nottickedoff">let tptr = tcReg ctx ptr</span>
<span class="lineno"> 3562 </span><span class="spaces">      </span><span class="nottickedoff">toff = tcReg ctx off in</span>
<span class="lineno"> 3563 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr toff &gt;&gt;&gt;= \off_expr -&gt;</span>
<span class="lineno"> 3564 </span><span class="spaces">  </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3565 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 3566 </span><span class="spaces">  </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (OffsetLLVMValue tptr off_expr) &gt;&gt;&gt;= \ret -&gt;</span>
<span class="lineno"> 3567 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3568 </span><span class="spaces">  </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3569 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3570 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a LoadHandle instruction by looking for a function pointer perm</span>
<span class="lineno"> 3571 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_LoadHandle _ _ ptr args ret) =</span>
<span class="lineno"> 3572 </span><span class="spaces">  </span><span class="nottickedoff">let tptr = tcReg ctx ptr</span>
<span class="lineno"> 3573 </span><span class="spaces">      </span><span class="nottickedoff">x = typedRegVar tptr in</span>
<span class="lineno"> 3574 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 3575 </span><span class="spaces">  </span><span class="nottickedoff">getAtomicLLVMPerms tptr &gt;&gt;&gt;= \ps -&gt;</span>
<span class="lineno"> 3576 </span><span class="spaces">  </span><span class="nottickedoff">case findIndex (\p -&gt; case p of</span>
<span class="lineno"> 3577 </span><span class="spaces">                     </span><span class="nottickedoff">Perm_LLVMFunPtr _ _ -&gt; True</span>
<span class="lineno"> 3578 </span><span class="spaces">                     </span><span class="nottickedoff">_ -&gt; False) ps of</span>
<span class="lineno"> 3579 </span><span class="spaces">    </span><span class="nottickedoff">Just i</span>
<span class="lineno"> 3580 </span><span class="spaces">      </span><span class="nottickedoff">| Perm_LLVMFunPtr tp p &lt;- ps!!i</span>
<span class="lineno"> 3581 </span><span class="spaces">      </span><span class="nottickedoff">, Just Refl &lt;- testEquality tp (FunctionHandleRepr args ret) -&gt;</span>
<span class="lineno"> 3582 </span><span class="spaces">        </span><span class="nottickedoff">stmtEmbedImplM (implCopyConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 3583 </span><span class="spaces">                        </span><span class="nottickedoff">recombinePerm x (ValPerm_Conj ps)) &gt;&gt;&gt;</span>
<span class="lineno"> 3584 </span><span class="spaces">        </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3585 </span><span class="spaces">        </span><span class="nottickedoff">emitLLVMStmt (FunctionHandleRepr args ret) name loc</span>
<span class="lineno"> 3586 </span><span class="spaces">        </span><span class="nottickedoff">(TypedLLVMLoadHandle tptr tp p) &gt;&gt;&gt;= \ret' -&gt;</span>
<span class="lineno"> 3587 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3588 </span><span class="spaces">        </span><span class="nottickedoff">pure (addCtxName ctx ret')</span>
<span class="lineno"> 3589 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; stmtFailM LoadHandleError</span>
<span class="lineno"> 3590 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3591 </span><span class="spaces"></span><span class="nottickedoff">-- Type-check a ResolveGlobal instruction by looking up the global symbol</span>
<span class="lineno"> 3592 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_ResolveGlobal w _ gsym) =</span>
<span class="lineno"> 3593 </span><span class="spaces">  </span><span class="nottickedoff">(stPermEnv &lt;$&gt; top_get) &gt;&gt;&gt;= \env -&gt;</span>
<span class="lineno"> 3594 </span><span class="spaces">  </span><span class="nottickedoff">case lookupGlobalSymbol env gsym w of</span>
<span class="lineno"> 3595 </span><span class="spaces">    </span><span class="nottickedoff">Just (p, _) -&gt;</span>
<span class="lineno"> 3596 </span><span class="spaces">      </span><span class="nottickedoff">nextDebugName &gt;&gt;&gt;= \name -&gt;</span>
<span class="lineno"> 3597 </span><span class="spaces">      </span><span class="nottickedoff">withKnownNat ?ptrWidth $</span>
<span class="lineno"> 3598 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr name loc (TypedLLVMResolveGlobal gsym p) &gt;&gt;&gt;= \ret -&gt;</span>
<span class="lineno"> 3599 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3600 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3601 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 3602 </span><span class="spaces">      </span><span class="nottickedoff">stmtFailM $ ResolveGlobalError gsym</span>
<span class="lineno"> 3603 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3604 </span><span class="spaces"></span><span class="nottickedoff">{-</span>
<span class="lineno"> 3605 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_PtrLe _ r1 r2) =</span>
<span class="lineno"> 3606 </span><span class="spaces">  </span><span class="nottickedoff">let x1 = tcReg ctx r1</span>
<span class="lineno"> 3607 </span><span class="spaces">      </span><span class="nottickedoff">x2 = tcReg ctx r2 in</span>
<span class="lineno"> 3608 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr x1 &gt;&gt;&gt;= \e1 -&gt;</span>
<span class="lineno"> 3609 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr x2 &gt;&gt;&gt;= \e2 -&gt;</span>
<span class="lineno"> 3610 </span><span class="spaces">  </span><span class="nottickedoff">case (e1, e2) of</span>
<span class="lineno"> 3611 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3612 </span><span class="spaces">    </span><span class="nottickedoff">-- If both variables equal words, then compare the words</span>
<span class="lineno"> 3613 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 3614 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: if we have bvEq e1' e2' or not (bvCouldEqual e1' e2') then we</span>
<span class="lineno"> 3615 </span><span class="spaces">    </span><span class="nottickedoff">-- should return a known Boolean value in place of the Nothing</span>
<span class="lineno"> 3616 </span><span class="spaces">    </span><span class="nottickedoff">(PExpr_LLVMWord e1', PExpr_LLVMWord e2') -&gt;</span>
<span class="lineno"> 3617 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3618 </span><span class="spaces">                              </span><span class="nottickedoff">knownRepr e1') &gt;&gt;&gt;= \(_ :&gt;: n1) -&gt;</span>
<span class="lineno"> 3619 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3620 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3621 </span><span class="spaces">                              </span><span class="nottickedoff">knownRepr e2') &gt;&gt;&gt;= \(_ :&gt;: n2) -&gt;</span>
<span class="lineno"> 3622 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3623 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetReg knownRepr $</span>
<span class="lineno"> 3624 </span><span class="spaces">                              </span><span class="nottickedoff">TypedExpr (BVUle knownRepr</span>
<span class="lineno"> 3625 </span><span class="spaces">                                         </span><span class="nottickedoff">(RegWithVal (TypedReg n1) e1')</span>
<span class="lineno"> 3626 </span><span class="spaces">                                         </span><span class="nottickedoff">(RegWithVal (TypedReg n1) e2'))</span>
<span class="lineno"> 3627 </span><span class="spaces">                              </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(_ :&gt;: ret) -&gt;</span>
<span class="lineno"> 3628 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3629 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3630 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3631 </span><span class="spaces">    </span><span class="nottickedoff">-- If both variables equal x+off for the same x, compare the offsets</span>
<span class="lineno"> 3632 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 3633 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: test off1 == off2 like above</span>
<span class="lineno"> 3634 </span><span class="spaces">    </span><span class="nottickedoff">(asLLVMOffset -&gt; Just (x1', off1), asLLVMOffset -&gt; Just (x2', off2))</span>
<span class="lineno"> 3635 </span><span class="spaces">      </span><span class="nottickedoff">| x1' == x2' -&gt;</span>
<span class="lineno"> 3636 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3637 </span><span class="spaces">                                </span><span class="nottickedoff">knownRepr off1) &gt;&gt;&gt;= \(_ :&gt;: n1) -&gt;</span>
<span class="lineno"> 3638 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3639 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3640 </span><span class="spaces">                                </span><span class="nottickedoff">knownRepr off2) &gt;&gt;&gt;= \(_ :&gt;: n2) -&gt;</span>
<span class="lineno"> 3641 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3642 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetReg knownRepr $</span>
<span class="lineno"> 3643 </span><span class="spaces">                                </span><span class="nottickedoff">TypedExpr (BVUle knownRepr</span>
<span class="lineno"> 3644 </span><span class="spaces">                                         </span><span class="nottickedoff">(RegWithVal (TypedReg n1) off1)</span>
<span class="lineno"> 3645 </span><span class="spaces">                                         </span><span class="nottickedoff">(RegWithVal (TypedReg n1) off2))</span>
<span class="lineno"> 3646 </span><span class="spaces">                                </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(_ :&gt;: ret) -&gt;</span>
<span class="lineno"> 3647 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3648 </span><span class="spaces">        </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3649 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3650 </span><span class="spaces">    </span><span class="nottickedoff">-- If one variable is a word and the other is not known to be a word, then</span>
<span class="lineno"> 3651 </span><span class="spaces">    </span><span class="nottickedoff">-- that other has to be a pointer, in which case the comparison will</span>
<span class="lineno"> 3652 </span><span class="spaces">    </span><span class="nottickedoff">-- definitely fail. Otherwise we cannot compare them and we fail.</span>
<span class="lineno"> 3653 </span><span class="spaces">    </span><span class="nottickedoff">(PExpr_LLVMWord e, asLLVMOffset -&gt; Just (x', _)) -&gt;</span>
<span class="lineno"> 3654 </span><span class="spaces">      </span><span class="nottickedoff">let r' = TypedReg x' in</span>
<span class="lineno"> 3655 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm r' (emptyMb $ ValPerm_Conj1 Perm_IsLLVMPtr) &gt;&gt;&gt;</span>
<span class="lineno"> 3656 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr loc (AssertLLVMPtr r') &gt;&gt;&gt;</span>
<span class="lineno"> 3657 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetReg knownRepr $</span>
<span class="lineno"> 3658 </span><span class="spaces">                              </span><span class="nottickedoff">TypedExpr (BoolLit False)</span>
<span class="lineno"> 3659 </span><span class="spaces">                              </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(_ :&gt;: ret) -&gt;</span>
<span class="lineno"> 3660 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3661 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3662 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3663 </span><span class="spaces">    </span><span class="nottickedoff">-- Symmetrical version of the above case</span>
<span class="lineno"> 3664 </span><span class="spaces">    </span><span class="nottickedoff">(asLLVMOffset -&gt; Just (x', _), PExpr_LLVMWord e) -&gt;</span>
<span class="lineno"> 3665 </span><span class="spaces">      </span><span class="nottickedoff">let r' = TypedReg x' in</span>
<span class="lineno"> 3666 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm r' (emptyMb $ ValPerm_Conj1 Perm_IsLLVMPtr) &gt;&gt;&gt;</span>
<span class="lineno"> 3667 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr loc (AssertLLVMPtr r') &gt;&gt;&gt;</span>
<span class="lineno"> 3668 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr loc (TypedSetReg knownRepr $</span>
<span class="lineno"> 3669 </span><span class="spaces">                              </span><span class="nottickedoff">TypedExpr (BoolLit False)</span>
<span class="lineno"> 3670 </span><span class="spaces">                              </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(_ :&gt;: ret) -&gt;</span>
<span class="lineno"> 3671 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3672 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3673 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3674 </span><span class="spaces">    </span><span class="nottickedoff">-- If we don't know any relationship between the two registers, then we</span>
<span class="lineno"> 3675 </span><span class="spaces">    </span><span class="nottickedoff">-- fail, because there is no way to compare pointers in the translation</span>
<span class="lineno"> 3676 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 3677 </span><span class="spaces">      </span><span class="nottickedoff">stmtFailM (\i -&gt;</span>
<span class="lineno"> 3678 </span><span class="spaces">                  </span><span class="nottickedoff">sep [pretty &quot;Could not compare LLVM pointer values&quot;,</span>
<span class="lineno"> 3679 </span><span class="spaces">                       </span><span class="nottickedoff">permPretty i x1, pretty &quot;and&quot;, permPretty i x2])</span>
<span class="lineno"> 3680 </span><span class="spaces"></span><span class="nottickedoff">-}</span>
<span class="lineno"> 3681 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3682 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc (LLVM_PtrEq _ (r1 :: Reg ctx (LLVMPointerType wptr)) r2) =</span>
<span class="lineno"> 3683 </span><span class="spaces">  </span><span class="nottickedoff">let x1 = tcReg ctx r1</span>
<span class="lineno"> 3684 </span><span class="spaces">      </span><span class="nottickedoff">x2 = tcReg ctx r2 in</span>
<span class="lineno"> 3685 </span><span class="spaces">  </span><span class="nottickedoff">withKnownNat (?ptrWidth :: NatRepr wptr) $</span>
<span class="lineno"> 3686 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr x1 &gt;&gt;&gt;= \e1 -&gt;</span>
<span class="lineno"> 3687 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr x2 &gt;&gt;&gt;= \e2 -&gt;</span>
<span class="lineno"> 3688 </span><span class="spaces">  </span><span class="nottickedoff">case (e1, e2) of</span>
<span class="lineno"> 3689 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3690 </span><span class="spaces">    </span><span class="nottickedoff">-- If both variables equal words, then compare the words</span>
<span class="lineno"> 3691 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 3692 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: if we have bvEq e1' e2' or not (bvCouldEqual e1' e2') then we</span>
<span class="lineno"> 3693 </span><span class="spaces">    </span><span class="nottickedoff">-- should return a known Boolean value in place of the Nothing</span>
<span class="lineno"> 3694 </span><span class="spaces">    </span><span class="nottickedoff">(PExpr_LLVMWord e1', PExpr_LLVMWord e2') -&gt;</span>
<span class="lineno"> 3695 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr noNames loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3696 </span><span class="spaces">                              </span><span class="nottickedoff">knownRepr e1') &gt;&gt;&gt;= \(MNil :&gt;: n1) -&gt;</span>
<span class="lineno"> 3697 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3698 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr noNames loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3699 </span><span class="spaces">                              </span><span class="nottickedoff">knownRepr e2') &gt;&gt;&gt;= \(MNil :&gt;: n2) -&gt;</span>
<span class="lineno"> 3700 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3701 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3702 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3703 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3704 </span><span class="spaces">          </span><span class="nottickedoff">TypedExpr (BaseIsEq knownRepr</span>
<span class="lineno"> 3705 </span><span class="spaces">                      </span><span class="nottickedoff">(RegWithVal (TypedReg n1) e1')</span>
<span class="lineno"> 3706 </span><span class="spaces">                      </span><span class="nottickedoff">(RegWithVal (TypedReg n2) e2'))</span>
<span class="lineno"> 3707 </span><span class="spaces">          </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3708 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3709 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3710 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3711 </span><span class="spaces">    </span><span class="nottickedoff">-- If both variables equal x+off for the same x, compare the offsets</span>
<span class="lineno"> 3712 </span><span class="spaces">    </span><span class="nottickedoff">--</span>
<span class="lineno"> 3713 </span><span class="spaces">    </span><span class="nottickedoff">-- FIXME: test off1 == off2 like above</span>
<span class="lineno"> 3714 </span><span class="spaces">    </span><span class="nottickedoff">(asLLVMOffset -&gt; Just (x1', off1), asLLVMOffset -&gt; Just (x2', off2))</span>
<span class="lineno"> 3715 </span><span class="spaces">      </span><span class="nottickedoff">| x1' == x2' -&gt;</span>
<span class="lineno"> 3716 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr noNames loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3717 </span><span class="spaces">                                </span><span class="nottickedoff">knownRepr off1) &gt;&gt;&gt;= \(MNil :&gt;: n1) -&gt;</span>
<span class="lineno"> 3718 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3719 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr noNames loc (TypedSetRegPermExpr</span>
<span class="lineno"> 3720 </span><span class="spaces">                                </span><span class="nottickedoff">knownRepr off2) &gt;&gt;&gt;= \(MNil :&gt;: n2) -&gt;</span>
<span class="lineno"> 3721 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3722 </span><span class="spaces">        </span><span class="nottickedoff">dbgNames &gt;&gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3723 </span><span class="spaces">        </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3724 </span><span class="spaces">          </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3725 </span><span class="spaces">            </span><span class="nottickedoff">TypedExpr (BaseIsEq knownRepr</span>
<span class="lineno"> 3726 </span><span class="spaces">                        </span><span class="nottickedoff">(RegWithVal (TypedReg n1) off1)</span>
<span class="lineno"> 3727 </span><span class="spaces">                        </span><span class="nottickedoff">(RegWithVal (TypedReg n2) off2))</span>
<span class="lineno"> 3728 </span><span class="spaces">            </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3729 </span><span class="spaces">        </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3730 </span><span class="spaces">        </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3731 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3732 </span><span class="spaces">    </span><span class="nottickedoff">-- If one variable is a word and the other is not known to be a word, then</span>
<span class="lineno"> 3733 </span><span class="spaces">    </span><span class="nottickedoff">-- that other has to be a pointer, in which case the comparison will</span>
<span class="lineno"> 3734 </span><span class="spaces">    </span><span class="nottickedoff">-- definitely fail. Otherwise we cannot compare them and we fail.</span>
<span class="lineno"> 3735 </span><span class="spaces">    </span><span class="nottickedoff">(PExpr_LLVMWord _e, asLLVMOffset -&gt; Just (x', _)) -&gt;</span>
<span class="lineno"> 3736 </span><span class="spaces">      </span><span class="nottickedoff">let r' = TypedReg x' in</span>
<span class="lineno"> 3737 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm r' (emptyMb $ ValPerm_Conj1 Perm_IsLLVMPtr) &gt;&gt;&gt;</span>
<span class="lineno"> 3738 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (AssertLLVMPtr r') &gt;&gt;&gt;</span>
<span class="lineno"> 3739 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3740 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3741 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3742 </span><span class="spaces">          </span><span class="nottickedoff">TypedExpr (BoolLit False)</span>
<span class="lineno"> 3743 </span><span class="spaces">          </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3744 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3745 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3746 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3747 </span><span class="spaces">    </span><span class="nottickedoff">-- Symmetrical version of the above case</span>
<span class="lineno"> 3748 </span><span class="spaces">    </span><span class="nottickedoff">(asLLVMOffset -&gt; Just (x', _), PExpr_LLVMWord _e) -&gt;</span>
<span class="lineno"> 3749 </span><span class="spaces">      </span><span class="nottickedoff">let r' = TypedReg x' in</span>
<span class="lineno"> 3750 </span><span class="spaces">      </span><span class="nottickedoff">stmtProvePerm r' (emptyMb $ ValPerm_Conj1 Perm_IsLLVMPtr) &gt;&gt;&gt;</span>
<span class="lineno"> 3751 </span><span class="spaces">      </span><span class="nottickedoff">emitLLVMStmt knownRepr Nothing loc (AssertLLVMPtr r') &gt;&gt;&gt;</span>
<span class="lineno"> 3752 </span><span class="spaces">      </span><span class="nottickedoff">dbgNames &gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3753 </span><span class="spaces">      </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3754 </span><span class="spaces">        </span><span class="nottickedoff">(TypedSetReg knownRepr $</span>
<span class="lineno"> 3755 </span><span class="spaces">          </span><span class="nottickedoff">TypedExpr (BoolLit False)</span>
<span class="lineno"> 3756 </span><span class="spaces">          </span><span class="nottickedoff">Nothing) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3757 </span><span class="spaces">      </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3758 </span><span class="spaces">      </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3759 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3760 </span><span class="spaces">    </span><span class="nottickedoff">-- If we don't know any relationship between the two registers, then we</span>
<span class="lineno"> 3761 </span><span class="spaces">    </span><span class="nottickedoff">-- fail, because there is no way to compare pointers in the translation</span>
<span class="lineno"> 3762 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 3763 </span><span class="spaces">      </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppinfo -&gt;</span>
<span class="lineno"> 3764 </span><span class="spaces">        </span><span class="nottickedoff">stmtFailM $ PointerComparisonError</span>
<span class="lineno"> 3765 </span><span class="spaces">                      </span><span class="nottickedoff">(permPretty ppinfo x1)</span>
<span class="lineno"> 3766 </span><span class="spaces">                      </span><span class="nottickedoff">(permPretty ppinfo x2)</span>
<span class="lineno"> 3767 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3768 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch ctx loc LLVM_Debug{} =</span>
<span class="lineno"> 3769 </span><span class="spaces"></span><span class="nottickedoff">--  let tptr = tcReg ctx ptr in</span>
<span class="lineno"> 3770 </span><span class="spaces">  </span><span class="nottickedoff">dbgNames &gt;&gt;= \names -&gt;</span>
<span class="lineno"> 3771 </span><span class="spaces">  </span><span class="nottickedoff">emitStmt knownRepr names loc</span>
<span class="lineno"> 3772 </span><span class="spaces">    </span><span class="nottickedoff">(TypedSetReg knownRepr (TypedExpr EmptyApp Nothing)) &gt;&gt;&gt;= \(MNil :&gt;: ret) -&gt;</span>
<span class="lineno"> 3773 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 3774 </span><span class="spaces">  </span><span class="nottickedoff">pure (addCtxName ctx ret)</span>
<span class="lineno"> 3775 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3776 </span><span class="spaces"></span><span class="nottickedoff">tcEmitLLVMStmt _arch _ctx _loc stmt =</span>
<span class="lineno"> 3777 </span><span class="spaces">  </span><span class="nottickedoff">error (&quot;tcEmitLLVMStmt: unimplemented statement - &quot; ++ show (ppApp (\_ -&gt; mempty) stmt))</span></span>
<span class="lineno"> 3778 </span>
<span class="lineno"> 3779 </span>-- FIXME HERE: need to handle PtrEq, PtrLe, and PtrSubtract
<span class="lineno"> 3780 </span>
<span class="lineno"> 3781 </span>
<span class="lineno"> 3782 </span>----------------------------------------------------------------------
<span class="lineno"> 3783 </span>-- * Permission Checking for Jump Targets and Termination Statements
<span class="lineno"> 3784 </span>----------------------------------------------------------------------
<span class="lineno"> 3785 </span>
<span class="lineno"> 3786 </span>-- | Cast the primary permission for @x@ using any equality permissions on
<span class="lineno"> 3787 </span>-- variables *not* in the supplied list of determined variables. The idea here
<span class="lineno"> 3788 </span>-- is that we are trying to simplify out and remove un-determined variables.
<span class="lineno"> 3789 </span>castUnDetVarsForVar :: NuMatchingAny1 r =&gt; NameSet CrucibleType -&gt; ExprVar a -&gt;
<span class="lineno"> 3790 </span>                       ImplM vars s r RNil RNil ()
<span class="lineno"> 3791 </span><span class="decl"><span class="nottickedoff">castUnDetVarsForVar det_vars x =</span>
<span class="lineno"> 3792 </span><span class="spaces">  </span><span class="nottickedoff">(view varPermMap &lt;$&gt; getPerms) &gt;&gt;&gt;= \var_perm_map -&gt;</span>
<span class="lineno"> 3793 </span><span class="spaces">  </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= \p -&gt;</span>
<span class="lineno"> 3794 </span><span class="spaces">  </span><span class="nottickedoff">let nondet_perms =</span>
<span class="lineno"> 3795 </span><span class="spaces">        </span><span class="nottickedoff">NameMap.fromList $</span>
<span class="lineno"> 3796 </span><span class="spaces">        </span><span class="nottickedoff">filter (\(NameMap.NameAndElem y _) -&gt; not $ NameSet.member y det_vars) $</span>
<span class="lineno"> 3797 </span><span class="spaces">        </span><span class="nottickedoff">NameMap.assocs var_perm_map in</span>
<span class="lineno"> 3798 </span><span class="spaces">  </span><span class="nottickedoff">let eqp = someEqProofFromSubst nondet_perms p in</span>
<span class="lineno"> 3799 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt;</span>
<span class="lineno"> 3800 </span><span class="spaces">  </span><span class="nottickedoff">implCastPermM Proxy x eqp &gt;&gt;&gt;</span>
<span class="lineno"> 3801 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x (someEqProofRHS eqp)</span></span>
<span class="lineno"> 3802 </span>
<span class="lineno"> 3803 </span>
<span class="lineno"> 3804 </span>-- | Simplify @lowned@ permissions @p@ on variable @x@ so they only depend on
<span class="lineno"> 3805 </span>-- the determined variables given in the supplied list. This function only ends
<span class="lineno"> 3806 </span>-- lifetimes, so that all lifetime ending happens before other unneeded
<span class="lineno"> 3807 </span>-- permissions are dropped.
<span class="lineno"> 3808 </span>simplify1LOwnedPermForDetVars :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3809 </span>                                 NameSet CrucibleType -&gt; Name a -&gt; ValuePerm a -&gt;
<span class="lineno"> 3810 </span>                                 ImplM vars s r RNil RNil ()
<span class="lineno"> 3811 </span>
<span class="lineno"> 3812 </span>-- For permission l:lowned[ls](ps_in -o ps_out) where l or some free variable in
<span class="lineno"> 3813 </span>-- ps_in or ps_out is not determined, end l
<span class="lineno"> 3814 </span><span class="decl"><span class="nottickedoff">simplify1LOwnedPermForDetVars det_vars l (ValPerm_LOwned _ _ _ ps_in ps_out)</span>
<span class="lineno"> 3815 </span><span class="spaces">  </span><span class="nottickedoff">| vars &lt;- NameSet.insert l $ freeVars (ps_in,ps_out)</span>
<span class="lineno"> 3816 </span><span class="spaces">  </span><span class="nottickedoff">, not $ NameSet.nameSetIsSubsetOf vars det_vars</span>
<span class="lineno"> 3817 </span><span class="spaces">  </span><span class="nottickedoff">= implEndLifetimeRecM l</span>
<span class="lineno"> 3818 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3819 </span><span class="spaces"></span><span class="nottickedoff">-- For lowned permission l:lowned[ls](ps_in -o ps_out), end any lifetimes in ls</span>
<span class="lineno"> 3820 </span><span class="spaces"></span><span class="nottickedoff">-- that are not determined and remove them from the lowned permission for ls</span>
<span class="lineno"> 3821 </span><span class="spaces"></span><span class="nottickedoff">simplify1LOwnedPermForDetVars det_vars l (ValPerm_LOwned ls _ _ _ _)</span>
<span class="lineno"> 3822 </span><span class="spaces">  </span><span class="nottickedoff">| l':_ &lt;- flip mapMaybe ls (asVar &gt;=&gt; \l' -&gt;</span>
<span class="lineno"> 3823 </span><span class="spaces">                               </span><span class="nottickedoff">if NameSet.member l' det_vars then Nothing</span>
<span class="lineno"> 3824 </span><span class="spaces">                               </span><span class="nottickedoff">else return l') =</span>
<span class="lineno"> 3825 </span><span class="spaces">    </span><span class="nottickedoff">implEndLifetimeRecM l' &gt;&gt;&gt;</span>
<span class="lineno"> 3826 </span><span class="spaces">    </span><span class="nottickedoff">getPerm l &gt;&gt;&gt;= \p' -&gt; simplify1PermForDetVars det_vars l p'</span>
<span class="lineno"> 3827 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3828 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise do nothing</span>
<span class="lineno"> 3829 </span><span class="spaces"></span><span class="nottickedoff">simplify1LOwnedPermForDetVars _ _ _ = return ()</span></span>
<span class="lineno"> 3830 </span>
<span class="lineno"> 3831 </span>
<span class="lineno"> 3832 </span>-- | Simplify and drop permissions @p@ on variable @x@ so they only depend on
<span class="lineno"> 3833 </span>-- the determined variables given in the supplied list
<span class="lineno"> 3834 </span>simplify1PermForDetVars :: NuMatchingAny1 r =&gt;
<span class="lineno"> 3835 </span>                           NameSet CrucibleType -&gt; Name a -&gt; ValuePerm a -&gt;
<span class="lineno"> 3836 </span>                           ImplM vars s r RNil RNil ()
<span class="lineno"> 3837 </span>
<span class="lineno"> 3838 </span>-- If the permissions contain an array permission with undetermined borrows,
<span class="lineno"> 3839 </span>-- return those undetermined borrows if possible
<span class="lineno"> 3840 </span>--
<span class="lineno"> 3841 </span>-- FIXME: we should only return borrows if we can; currently, if there are
<span class="lineno"> 3842 </span>-- borrows we can't return, we fail here, and should instead just drop the array
<span class="lineno"> 3843 </span>-- permission and keep going. To do this, we have to make a way to try to prove
<span class="lineno"> 3844 </span>-- a permission, either by changing the ImplM monad or by adding a notion of
<span class="lineno"> 3845 </span>-- local implication proofs where failure is scoped inside a proof
<span class="lineno"> 3846 </span><span class="decl"><span class="nottickedoff">simplify1PermForDetVars det_vars x (ValPerm_Conj ps)</span>
<span class="lineno"> 3847 </span><span class="spaces">  </span><span class="nottickedoff">| Just i &lt;-</span>
<span class="lineno"> 3848 </span><span class="spaces">      </span><span class="nottickedoff">findIndex</span>
<span class="lineno"> 3849 </span><span class="spaces">      </span><span class="nottickedoff">(\case</span>
<span class="lineno"> 3850 </span><span class="spaces">          </span><span class="nottickedoff">Perm_LLVMArray ap -&gt;</span>
<span class="lineno"> 3851 </span><span class="spaces">            </span><span class="nottickedoff">any (\b -&gt; not (nameSetIsSubsetOf</span>
<span class="lineno"> 3852 </span><span class="spaces">                            </span><span class="nottickedoff">(freeVars b) det_vars)) (llvmArrayBorrows ap)</span>
<span class="lineno"> 3853 </span><span class="spaces">          </span><span class="nottickedoff">_ -&gt; False) ps</span>
<span class="lineno"> 3854 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMArray ap &lt;- ps!!i</span>
<span class="lineno"> 3855 </span><span class="spaces">  </span><span class="nottickedoff">, det_borrows &lt;- filter (\b -&gt; nameSetIsSubsetOf</span>
<span class="lineno"> 3856 </span><span class="spaces">                                 </span><span class="nottickedoff">(freeVars b) det_vars) (llvmArrayBorrows ap)</span>
<span class="lineno"> 3857 </span><span class="spaces">  </span><span class="nottickedoff">, ret_p &lt;- ValPerm_Conj1 $ Perm_LLVMArray $ ap { llvmArrayBorrows =</span>
<span class="lineno"> 3858 </span><span class="spaces">                                                     </span><span class="nottickedoff">det_borrows } =</span>
<span class="lineno"> 3859 </span><span class="spaces">    </span><span class="nottickedoff">mbVarsM ret_p &gt;&gt;&gt;= \mb_ret_p -&gt;</span>
<span class="lineno"> 3860 </span><span class="spaces">    </span><span class="nottickedoff">proveVarImpl x mb_ret_p &gt;&gt;&gt;</span>
<span class="lineno"> 3861 </span><span class="spaces">    </span><span class="nottickedoff">(getTopDistPerm x &gt;&gt;&gt;= recombinePerm x) &gt;&gt;&gt;</span>
<span class="lineno"> 3862 </span><span class="spaces">    </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= \new_p -&gt;</span>
<span class="lineno"> 3863 </span><span class="spaces">    </span><span class="nottickedoff">simplify1PermForDetVars det_vars x new_p</span>
<span class="lineno"> 3864 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3865 </span><span class="spaces"></span><span class="nottickedoff">-- If none of the above cases match but p has only determined free variables,</span>
<span class="lineno"> 3866 </span><span class="spaces"></span><span class="nottickedoff">-- just leave p as is</span>
<span class="lineno"> 3867 </span><span class="spaces"></span><span class="nottickedoff">simplify1PermForDetVars det_vars _ p</span>
<span class="lineno"> 3868 </span><span class="spaces">  </span><span class="nottickedoff">| nameSetIsSubsetOf (freeVars p) det_vars = pure ()</span>
<span class="lineno"> 3869 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3870 </span><span class="spaces"></span><span class="nottickedoff">-- If p is an equality permission to a word with undetermined variables,</span>
<span class="lineno"> 3871 </span><span class="spaces"></span><span class="nottickedoff">-- existentially quantify over the word</span>
<span class="lineno"> 3872 </span><span class="spaces"></span><span class="nottickedoff">simplify1PermForDetVars _ x p@(ValPerm_Eq (PExpr_LLVMWord e)) =</span>
<span class="lineno"> 3873 </span><span class="spaces">  </span><span class="nottickedoff">let mb_p = nu $ \z -&gt; ValPerm_Eq $ PExpr_LLVMWord $ PExpr_Var z in</span>
<span class="lineno"> 3874 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; introExistsM x e mb_p &gt;&gt;&gt;</span>
<span class="lineno"> 3875 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x (ValPerm_Exists mb_p)</span>
<span class="lineno"> 3876 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3877 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise, drop p, because it is not determined</span>
<span class="lineno"> 3878 </span><span class="spaces"></span><span class="nottickedoff">simplify1PermForDetVars _det_vars x p =</span>
<span class="lineno"> 3879 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implDropM x p</span></span>
<span class="lineno"> 3880 </span>
<span class="lineno"> 3881 </span>
<span class="lineno"> 3882 </span>-- | Simplify and drop permissions so they only depend on the determined
<span class="lineno"> 3883 </span>-- variables given in the supplied list
<span class="lineno"> 3884 </span>simplifyPermsForDetVars :: NuMatchingAny1 r =&gt; [SomeName CrucibleType] -&gt;
<span class="lineno"> 3885 </span>                           ImplM vars s r RNil RNil ()
<span class="lineno"> 3886 </span><span class="decl"><span class="nottickedoff">simplifyPermsForDetVars det_vars_list =</span>
<span class="lineno"> 3887 </span><span class="spaces">  </span><span class="nottickedoff">let det_vars = NameSet.fromList det_vars_list in</span>
<span class="lineno"> 3888 </span><span class="spaces">  </span><span class="nottickedoff">(permSetVars &lt;$&gt; getPerms) &gt;&gt;&gt;= \vars -&gt;</span>
<span class="lineno"> 3889 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 1: cast all the primary permissions using non-determined variables, to</span>
<span class="lineno"> 3890 </span><span class="spaces">  </span><span class="nottickedoff">-- try to simplify them out</span>
<span class="lineno"> 3891 </span><span class="spaces">  </span><span class="nottickedoff">mapM_ (\(SomeName x) -&gt; castUnDetVarsForVar det_vars x) vars &gt;&gt;&gt;</span>
<span class="lineno"> 3892 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 2: end any unneeded lifetimes, but do this before any other unneeded</span>
<span class="lineno"> 3893 </span><span class="spaces">  </span><span class="nottickedoff">-- permissions have been dropped, in case they are needed to end lifetimes</span>
<span class="lineno"> 3894 </span><span class="spaces">  </span><span class="nottickedoff">mapM_ (\(SomeName x) -&gt;</span>
<span class="lineno"> 3895 </span><span class="spaces">          </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= simplify1LOwnedPermForDetVars det_vars x) vars &gt;&gt;&gt;</span>
<span class="lineno"> 3896 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 3: simplify any other remaining permissions</span>
<span class="lineno"> 3897 </span><span class="spaces">  </span><span class="nottickedoff">mapM_ (\(SomeName x) -&gt;</span>
<span class="lineno"> 3898 </span><span class="spaces">          </span><span class="nottickedoff">getPerm x &gt;&gt;&gt;= simplify1PermForDetVars det_vars x) vars</span></span>
<span class="lineno"> 3899 </span>
<span class="lineno"> 3900 </span>
<span class="lineno"> 3901 </span>-- | If @x@ has permission @eq(llvmword e)@ where @e@ is not a needed variable
<span class="lineno"> 3902 </span>-- (in the supplied set), replace that perm with an existential permission
<span class="lineno"> 3903 </span>-- @x:exists z.eq(llvmword z)@. Similarly, if @x@ has permission @eq(e)@ where
<span class="lineno"> 3904 </span>-- @e@ is a literal, replace that permission with just @true@.  Also do this
<span class="lineno"> 3905 </span>-- inside pointer permissions, by recursively destructing any pointer
<span class="lineno"> 3906 </span>-- permissions @ptr((rw,off) |-&gt; p)@ to the permission @ptr((rw,off) |-&gt; eq(y))@
<span class="lineno"> 3907 </span>-- for fresh variable @y@ and generalizing unneeded word equalities for @y@.
<span class="lineno"> 3908 </span>generalizeUnneededEqPerms1 ::
<span class="lineno"> 3909 </span>  NuMatchingAny1 r =&gt; NameSet CrucibleType -&gt; Name a -&gt; ValuePerm a -&gt;
<span class="lineno"> 3910 </span>  ImplM vars s r ps ps ()
<span class="lineno"> 3911 </span>
<span class="lineno"> 3912 </span>-- For x:eq(y) for needed variable y, do nothing
<span class="lineno"> 3913 </span><span class="decl"><span class="nottickedoff">generalizeUnneededEqPerms1 needed_vars _ (ValPerm_Eq (PExpr_Var y))</span>
<span class="lineno"> 3914 </span><span class="spaces">  </span><span class="nottickedoff">| NameSet.member y needed_vars = pure ()</span>
<span class="lineno"> 3915 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 needed_vars _ (ValPerm_Eq e@(PExpr_BV _ _))</span>
<span class="lineno"> 3916 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_Var y &lt;- normalizeBVExpr e</span>
<span class="lineno"> 3917 </span><span class="spaces">  </span><span class="nottickedoff">, NameSet.member y needed_vars = pure ()</span>
<span class="lineno"> 3918 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3919 </span><span class="spaces"></span><span class="nottickedoff">-- Similarly, for x:eq(llvmword y) for needed variable y, do nothing</span>
<span class="lineno"> 3920 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 needed_vars _ (ValPerm_Eq (PExpr_LLVMWord e))</span>
<span class="lineno"> 3921 </span><span class="spaces">  </span><span class="nottickedoff">| PExpr_Var y &lt;- normalizeBVExpr e</span>
<span class="lineno"> 3922 </span><span class="spaces">  </span><span class="nottickedoff">, NameSet.member y needed_vars = pure ()</span>
<span class="lineno"> 3923 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 _needed_vars x p@(ValPerm_Eq (PExpr_LLVMWord e)) =</span>
<span class="lineno"> 3924 </span><span class="spaces">  </span><span class="nottickedoff">let mb_eq = nu $ \z -&gt; ValPerm_Eq $ PExpr_LLVMWord $ PExpr_Var z in</span>
<span class="lineno"> 3925 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt;</span>
<span class="lineno"> 3926 </span><span class="spaces">  </span><span class="nottickedoff">introExistsM x e mb_eq &gt;&gt;&gt;</span>
<span class="lineno"> 3927 </span><span class="spaces">  </span><span class="nottickedoff">implPopM x (ValPerm_Exists mb_eq)</span>
<span class="lineno"> 3928 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3929 </span><span class="spaces"></span><span class="nottickedoff">-- Similarly, for x:eq(y &amp;+ off) for needed variable y, do nothing</span>
<span class="lineno"> 3930 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 needed_vars _ (ValPerm_Eq (PExpr_LLVMOffset y _))</span>
<span class="lineno"> 3931 </span><span class="spaces">  </span><span class="nottickedoff">| NameSet.member y needed_vars = pure ()</span>
<span class="lineno"> 3932 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3933 </span><span class="spaces"></span><span class="nottickedoff">-- For x:eq(e) where e is a literal, just drop the eq(e) permission</span>
<span class="lineno"> 3934 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 _needed_vars x p@(ValPerm_Eq PExpr_Unit) =</span>
<span class="lineno"> 3935 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implDropM x p</span>
<span class="lineno"> 3936 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 _needed_vars x p@(ValPerm_Eq (PExpr_Nat _)) =</span>
<span class="lineno"> 3937 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implDropM x p</span>
<span class="lineno"> 3938 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 _needed_vars x p@(ValPerm_Eq (PExpr_Bool _)) =</span>
<span class="lineno"> 3939 </span><span class="spaces">  </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implDropM x p</span>
<span class="lineno"> 3940 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3941 </span><span class="spaces"></span><span class="nottickedoff">-- If x:p1 * ... * pn, generalize the contents of field permissions in the pis</span>
<span class="lineno"> 3942 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 needed_vars x p@(ValPerm_Conj ps)</span>
<span class="lineno"> 3943 </span><span class="spaces">  </span><span class="nottickedoff">| Just i &lt;- findIndex isLLVMFieldPerm ps</span>
<span class="lineno"> 3944 </span><span class="spaces">  </span><span class="nottickedoff">, Perm_LLVMField fp &lt;- ps!!i</span>
<span class="lineno"> 3945 </span><span class="spaces">  </span><span class="nottickedoff">, y_p &lt;- llvmFieldContents fp</span>
<span class="lineno"> 3946 </span><span class="spaces">  </span><span class="nottickedoff">, ps' &lt;- deleteNth i ps</span>
<span class="lineno"> 3947 </span><span class="spaces">  </span><span class="nottickedoff">, (case y_p of</span>
<span class="lineno"> 3948 </span><span class="spaces">        </span><span class="nottickedoff">ValPerm_Eq (PExpr_Var _) -&gt; False</span>
<span class="lineno"> 3949 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; True) =</span>
<span class="lineno"> 3950 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x p &gt;&gt;&gt; implExtractConjM x ps i &gt;&gt;&gt;</span>
<span class="lineno"> 3951 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 3952 </span><span class="spaces">    </span><span class="nottickedoff">implElimLLVMFieldContentsM x fp &gt;&gt;&gt;= \y -&gt;</span>
<span class="lineno"> 3953 </span><span class="spaces">    </span><span class="nottickedoff">let fp' = fp { llvmFieldContents = ValPerm_Eq (PExpr_Var y) } in</span>
<span class="lineno"> 3954 </span><span class="spaces">    </span><span class="nottickedoff">implPushM x (ValPerm_Conj ps') &gt;&gt;&gt;</span>
<span class="lineno"> 3955 </span><span class="spaces">    </span><span class="nottickedoff">implInsertConjM x (Perm_LLVMField fp') ps' i &gt;&gt;&gt;</span>
<span class="lineno"> 3956 </span><span class="spaces">    </span><span class="nottickedoff">implPopM x (ValPerm_Conj (take i ps' ++ Perm_LLVMField fp' : drop i ps')) &gt;&gt;&gt;</span>
<span class="lineno"> 3957 </span><span class="spaces">    </span><span class="nottickedoff">generalizeUnneededEqPerms1 needed_vars y y_p</span>
<span class="lineno"> 3958 </span><span class="spaces"></span><span class="nottickedoff">generalizeUnneededEqPerms1 _ _ _ = pure ()</span></span>
<span class="lineno"> 3959 </span>
<span class="lineno"> 3960 </span>-- | Find all permissions of the form @x:eq(llvmword e)@ other than those where
<span class="lineno"> 3961 </span>-- @e@ is a needed variable, and replace them with @x:exists z.eq(llvmword z)@
<span class="lineno"> 3962 </span>generalizeUnneededEqPerms :: NuMatchingAny1 r =&gt; ImplM vars s r ps ps ()
<span class="lineno"> 3963 </span><span class="decl"><span class="nottickedoff">generalizeUnneededEqPerms =</span>
<span class="lineno"> 3964 </span><span class="spaces">  </span><span class="nottickedoff">do Some var_perms &lt;- permSetAllVarPerms &lt;$&gt; getPerms</span>
<span class="lineno"> 3965 </span><span class="spaces">     </span><span class="nottickedoff">let needed_vars = neededVars var_perms</span>
<span class="lineno"> 3966 </span><span class="spaces">     </span><span class="nottickedoff">foldDistPerms</span>
<span class="lineno"> 3967 </span><span class="spaces">       </span><span class="nottickedoff">(\m x p -&gt; m &gt;&gt; generalizeUnneededEqPerms1 needed_vars x p)</span>
<span class="lineno"> 3968 </span><span class="spaces">       </span><span class="nottickedoff">(pure ())</span>
<span class="lineno"> 3969 </span><span class="spaces">       </span><span class="nottickedoff">var_perms</span></span>
<span class="lineno"> 3970 </span>
<span class="lineno"> 3971 </span>
<span class="lineno"> 3972 </span>-- | Type-check a Crucible jump target
<span class="lineno"> 3973 </span>tcJumpTarget :: PermCheckExtC ext exprExt =&gt; CtxTrans ctx -&gt; JumpTarget cblocks ctx -&gt;
<span class="lineno"> 3974 </span>                StmtPermCheckM ext cblocks blocks tops rets RNil RNil
<span class="lineno"> 3975 </span>                (AnnotPermImpl (TypedJumpTarget blocks tops) RNil)
<span class="lineno"> 3976 </span><span class="decl"><span class="nottickedoff">tcJumpTarget ctx (JumpTarget blkID args_tps args) =</span>
<span class="lineno"> 3977 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: we need to get the &quot;raw&quot; top-level state, without deltas being</span>
<span class="lineno"> 3978 </span><span class="spaces">  </span><span class="nottickedoff">-- applied to it, to run the InnerPermCheckM inside the ImplM monad below.</span>
<span class="lineno"> 3979 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: there should be a nicer way to do this... maybe if we got rid of</span>
<span class="lineno"> 3980 </span><span class="spaces">  </span><span class="nottickedoff">-- InnerPermCheckM and just had TopPermCheckM be a state monad on a Closed</span>
<span class="lineno"> 3981 </span><span class="spaces">  </span><span class="nottickedoff">-- TopPermCheckState?</span>
<span class="lineno"> 3982 </span><span class="spaces">  </span><span class="nottickedoff">(gcaptureCC $ \k -&gt; ask &gt;&gt;= k) &gt;&gt;&gt;= \top_st_raw -&gt;</span>
<span class="lineno"> 3983 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;= \st -&gt;</span>
<span class="lineno"> 3984 </span><span class="spaces">  </span><span class="nottickedoff">gets (permCheckExtStateNames . stExtState) &gt;&gt;= \(Some ext_ns) -&gt;</span>
<span class="lineno"> 3985 </span><span class="spaces">  </span><span class="nottickedoff">tcBlockID blkID &gt;&gt;&gt;= \tpBlkID -&gt;</span>
<span class="lineno"> 3986 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3987 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 0: run all of the following steps inside a local ImplM computation,</span>
<span class="lineno"> 3988 </span><span class="spaces">  </span><span class="nottickedoff">-- which we run in order to get out an AnnotPermImpl. This ensures that any</span>
<span class="lineno"> 3989 </span><span class="spaces">  </span><span class="nottickedoff">-- simplifications or other changes to permissions that are performed by this</span>
<span class="lineno"> 3990 </span><span class="spaces">  </span><span class="nottickedoff">-- computation are kept inside this local scope, which in turn is necessary so</span>
<span class="lineno"> 3991 </span><span class="spaces">  </span><span class="nottickedoff">-- that when we type-check a condition branch instruction (Br), the</span>
<span class="lineno"> 3992 </span><span class="spaces">  </span><span class="nottickedoff">-- simplifications of each branch do not affect each other.</span>
<span class="lineno"> 3993 </span><span class="spaces">  </span><span class="nottickedoff">pcmRunImplImplM CruCtxNil mempty $</span>
<span class="lineno"> 3994 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 3995 </span><span class="spaces">  </span><span class="nottickedoff">-- NOTE: the args all must be distinct variables (this is required by</span>
<span class="lineno"> 3996 </span><span class="spaces">  </span><span class="nottickedoff">-- implPushOrReflMultiM below and also the translation of jump targets)</span>
<span class="lineno"> 3997 </span><span class="spaces">  </span><span class="nottickedoff">implFreshenNames (typedRegsToVars $ tcRegs ctx args) &gt;&gt;&gt;= \args_ns -&gt;</span>
<span class="lineno"> 3998 </span><span class="spaces">  </span><span class="nottickedoff">let tops_ns = stTopVars st</span>
<span class="lineno"> 3999 </span><span class="spaces">      </span><span class="nottickedoff">tops_args_ns = RL.append tops_ns args_ns</span>
<span class="lineno"> 4000 </span><span class="spaces">      </span><span class="nottickedoff">tops_args_ext_ns = RL.append tops_args_ns ext_ns in</span>
<span class="lineno"> 4001 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4002 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 1: Compute the variables whose values are determined by the</span>
<span class="lineno"> 4003 </span><span class="spaces">  </span><span class="nottickedoff">-- permissions on the top and normal arguments as the starting point for</span>
<span class="lineno"> 4004 </span><span class="spaces">  </span><span class="nottickedoff">-- figuring out our ghost variables. The determined variables are the only</span>
<span class="lineno"> 4005 </span><span class="spaces">  </span><span class="nottickedoff">-- variables that could possibly be inferred by a caller, and they are the</span>
<span class="lineno"> 4006 </span><span class="spaces">  </span><span class="nottickedoff">-- only variables that could actually be accessed by the block we are calling,</span>
<span class="lineno"> 4007 </span><span class="spaces">  </span><span class="nottickedoff">-- so we should not be really giving up any permissions we need.</span>
<span class="lineno"> 4008 </span><span class="spaces">  </span><span class="nottickedoff">let orig_cur_perms = stCurPerms st</span>
<span class="lineno"> 4009 </span><span class="spaces">      </span><span class="nottickedoff">det_vars =</span>
<span class="lineno"> 4010 </span><span class="spaces">        </span><span class="nottickedoff">namesToNamesList tops_args_ext_ns ++</span>
<span class="lineno"> 4011 </span><span class="spaces">        </span><span class="nottickedoff">determinedVars orig_cur_perms tops_args_ext_ns in</span>
<span class="lineno"> 4012 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4013 </span><span class="spaces">  </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 4014 </span><span class="spaces">               </span><span class="nottickedoff">pretty (&quot;tcJumpTarget &quot; ++ show blkID) &lt;&gt;</span>
<span class="lineno"> 4015 </span><span class="spaces">               </span><span class="nottickedoff">{- (if gen_perms_hint then pretty &quot;(gen)&quot; else emptyDoc) &lt;&gt; -}</span>
<span class="lineno"> 4016 </span><span class="spaces">               </span><span class="nottickedoff">line &lt;&gt;</span>
<span class="lineno"> 4017 </span><span class="spaces">               </span><span class="nottickedoff">(case permSetAllVarPerms orig_cur_perms of</span>
<span class="lineno"> 4018 </span><span class="spaces">                   </span><span class="nottickedoff">Some all_perms -&gt;</span>
<span class="lineno"> 4019 </span><span class="spaces">                     </span><span class="nottickedoff">pretty &quot;Current perms:&quot; &lt;+&gt;</span>
<span class="lineno"> 4020 </span><span class="spaces">                     </span><span class="nottickedoff">align (permPretty i all_perms))</span>
<span class="lineno"> 4021 </span><span class="spaces">               </span><span class="nottickedoff">&lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4022 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Determined vars:&quot;&lt;+&gt;</span>
<span class="lineno"> 4023 </span><span class="spaces">               </span><span class="nottickedoff">align (list (map (permPretty i) det_vars))) &gt;&gt;&gt;</span>
<span class="lineno"> 4024 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4025 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 2: Simplify and drop permissions so they do not depend on undetermined</span>
<span class="lineno"> 4026 </span><span class="spaces">  </span><span class="nottickedoff">-- variables</span>
<span class="lineno"> 4027 </span><span class="spaces">  </span><span class="nottickedoff">simplifyPermsForDetVars det_vars &gt;&gt;&gt;</span>
<span class="lineno"> 4028 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4029 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 3: if gen_perms_hint is set, generalize any permissions of the form</span>
<span class="lineno"> 4030 </span><span class="spaces">  </span><span class="nottickedoff">-- eq(llvmword e) to exists z.eq(llvmword z) as long as they do not determine</span>
<span class="lineno"> 4031 </span><span class="spaces">  </span><span class="nottickedoff">-- a variable that we need, i.e., as long as they are not of the form</span>
<span class="lineno"> 4032 </span><span class="spaces">  </span><span class="nottickedoff">-- eq(llvmword x) for a variable x that we need</span>
<span class="lineno"> 4033 </span><span class="spaces">  </span><span class="nottickedoff">-- (if gen_perms_hint then generalizeUnneededEqPerms else pure ()) &gt;&gt;&gt;</span>
<span class="lineno"> 4034 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4035 </span><span class="spaces">  </span><span class="nottickedoff">-- Step 4: Compute the ghost variables for the target block as those variables</span>
<span class="lineno"> 4036 </span><span class="spaces">  </span><span class="nottickedoff">-- whose values are determined by the permissions on the top and normal</span>
<span class="lineno"> 4037 </span><span class="spaces">  </span><span class="nottickedoff">-- arguments after our above simplifications, adding in the extension-specific</span>
<span class="lineno"> 4038 </span><span class="spaces">  </span><span class="nottickedoff">-- variables as well</span>
<span class="lineno"> 4039 </span><span class="spaces">  </span><span class="nottickedoff">getPerms &gt;&gt;&gt;= \cur_perms -&gt;</span>
<span class="lineno"> 4040 </span><span class="spaces">  </span><span class="nottickedoff">case namesListToNames $ determinedVars cur_perms tops_args_ext_ns of</span>
<span class="lineno"> 4041 </span><span class="spaces">    </span><span class="nottickedoff">SomeRAssign ghosts_ns' -&gt;</span>
<span class="lineno"> 4042 </span><span class="spaces">      </span><span class="nottickedoff">localImplM $</span>
<span class="lineno"> 4043 </span><span class="spaces">      </span><span class="nottickedoff">let ghosts_ns = RL.append ext_ns ghosts_ns'</span>
<span class="lineno"> 4044 </span><span class="spaces">          </span><span class="nottickedoff">tops_perms = varPermsMulti tops_ns cur_perms</span>
<span class="lineno"> 4045 </span><span class="spaces">          </span><span class="nottickedoff">tops_set = NameSet.fromList $ namesToNamesList tops_ns</span>
<span class="lineno"> 4046 </span><span class="spaces">          </span><span class="nottickedoff">ghosts_perms = varPermsMulti ghosts_ns cur_perms</span>
<span class="lineno"> 4047 </span><span class="spaces">          </span><span class="nottickedoff">args_perms =</span>
<span class="lineno"> 4048 </span><span class="spaces">            </span><span class="nottickedoff">buildDistPerms (\n -&gt; if NameSet.member n tops_set</span>
<span class="lineno"> 4049 </span><span class="spaces">                                  </span><span class="nottickedoff">then ValPerm_Eq (PExpr_Var n)</span>
<span class="lineno"> 4050 </span><span class="spaces">                                  </span><span class="nottickedoff">else cur_perms ^. varPerm n) args_ns</span>
<span class="lineno"> 4051 </span><span class="spaces">          </span><span class="nottickedoff">perms_in = appendDistPerms (appendDistPerms</span>
<span class="lineno"> 4052 </span><span class="spaces">                                      </span><span class="nottickedoff">tops_perms args_perms) ghosts_perms in</span>
<span class="lineno"> 4053 </span><span class="spaces">      </span><span class="nottickedoff">implTraceM (\i -&gt;</span>
<span class="lineno"> 4054 </span><span class="spaces">                   </span><span class="nottickedoff">pretty (&quot;tcJumpTarget &quot; ++ show blkID) &lt;&gt;</span>
<span class="lineno"> 4055 </span><span class="spaces">                   </span><span class="nottickedoff">line &lt;&gt;</span>
<span class="lineno"> 4056 </span><span class="spaces">                   </span><span class="nottickedoff">pretty &quot;Input perms:&quot; &lt;+&gt;</span>
<span class="lineno"> 4057 </span><span class="spaces">                   </span><span class="nottickedoff">hang 2 (permPretty i perms_in)) &gt;&gt;&gt;</span>
<span class="lineno"> 4058 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4059 </span><span class="spaces">      </span><span class="nottickedoff">-- Step 5: abstract all the variables out of the input permissions.  Note</span>
<span class="lineno"> 4060 </span><span class="spaces">      </span><span class="nottickedoff">-- that abstractVars uses the left-most occurrence of any variable that</span>
<span class="lineno"> 4061 </span><span class="spaces">      </span><span class="nottickedoff">-- occurs multiple times in the variable list and we want our eq perms for</span>
<span class="lineno"> 4062 </span><span class="spaces">      </span><span class="nottickedoff">-- our args to map to our tops, not our args, so this order works for what</span>
<span class="lineno"> 4063 </span><span class="spaces">      </span><span class="nottickedoff">-- we want</span>
<span class="lineno"> 4064 </span><span class="spaces">      </span><span class="nottickedoff">(case abstractVars</span>
<span class="lineno"> 4065 </span><span class="spaces">            </span><span class="nottickedoff">(RL.append (RL.append tops_ns args_ns) ghosts_ns)</span>
<span class="lineno"> 4066 </span><span class="spaces">            </span><span class="nottickedoff">(distPermsToValuePerms perms_in) of</span>
<span class="lineno"> 4067 </span><span class="spaces">          </span><span class="nottickedoff">Just ps -&gt; pure ps</span>
<span class="lineno"> 4068 </span><span class="spaces">          </span><span class="nottickedoff">Nothing</span>
<span class="lineno"> 4069 </span><span class="spaces">            </span><span class="nottickedoff">| SomeRAssign orig_det_vars &lt;- namesListToNames det_vars</span>
<span class="lineno"> 4070 </span><span class="spaces">            </span><span class="nottickedoff">, orig_perms &lt;- varPermsMulti orig_det_vars orig_cur_perms -&gt;</span>
<span class="lineno"> 4071 </span><span class="spaces">              </span><span class="nottickedoff">implTraceM</span>
<span class="lineno"> 4072 </span><span class="spaces">              </span><span class="nottickedoff">(\i -&gt;</span>
<span class="lineno"> 4073 </span><span class="spaces">                </span><span class="nottickedoff">pretty (&quot;tcJumpTarget: unexpected free variable in perms_in:\n&quot;</span>
<span class="lineno"> 4074 </span><span class="spaces">                        </span><span class="nottickedoff">++ renderDoc (permPretty i perms_in)</span>
<span class="lineno"> 4075 </span><span class="spaces">                        </span><span class="nottickedoff">++ &quot;\norig_perms:\n&quot;</span>
<span class="lineno"> 4076 </span><span class="spaces">                        </span><span class="nottickedoff">++ renderDoc (permPretty i orig_perms))) &gt;&gt;&gt;= \str -&gt;</span>
<span class="lineno"> 4077 </span><span class="spaces">              </span><span class="nottickedoff">error str) &gt;&gt;&gt;= \cl_mb_perms_in -&gt;</span>
<span class="lineno"> 4078 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4079 </span><span class="spaces">      </span><span class="nottickedoff">-- Step 6: insert a new block entrypoint that has all the permissions</span>
<span class="lineno"> 4080 </span><span class="spaces">      </span><span class="nottickedoff">-- we constructed above as input permissions</span>
<span class="lineno"> 4081 </span><span class="spaces">      </span><span class="nottickedoff">implGetVarTypes ghosts_ns &gt;&gt;&gt;= \ghosts_tps -&gt;</span>
<span class="lineno"> 4082 </span><span class="spaces">      </span><span class="nottickedoff">(case stCurEntry st of</span>
<span class="lineno"> 4083 </span><span class="spaces">          </span><span class="nottickedoff">Some curEntryID -&gt;</span>
<span class="lineno"> 4084 </span><span class="spaces">            </span><span class="nottickedoff">lift $ flip runReaderT top_st_raw $</span>
<span class="lineno"> 4085 </span><span class="spaces">            </span><span class="nottickedoff">callBlockWithPerms curEntryID tpBlkID</span>
<span class="lineno"> 4086 </span><span class="spaces">            </span><span class="nottickedoff">ghosts_tps cl_mb_perms_in) &gt;&gt;&gt;= \siteID -&gt;</span>
<span class="lineno"> 4087 </span><span class="spaces">      </span><span class="nottickedoff">implTraceM (\_ -&gt;</span>
<span class="lineno"> 4088 </span><span class="spaces">                   </span><span class="nottickedoff">pretty (&quot;tcJumpTarget &quot; ++ show blkID ++ &quot; siteID =&quot; ++</span>
<span class="lineno"> 4089 </span><span class="spaces">                           </span><span class="nottickedoff">show siteID)) &gt;&gt;&gt;</span>
<span class="lineno"> 4090 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4091 </span><span class="spaces">      </span><span class="nottickedoff">-- Step 7: return a TypedJumpTarget inside a PermImpl that proves all the</span>
<span class="lineno"> 4092 </span><span class="spaces">      </span><span class="nottickedoff">-- required input permissions from the current permission set by copying</span>
<span class="lineno"> 4093 </span><span class="spaces">      </span><span class="nottickedoff">-- the existing permissions into the current distinguished perms, except</span>
<span class="lineno"> 4094 </span><span class="spaces">      </span><span class="nottickedoff">-- for the eq permissions for real arguments, which are proved by</span>
<span class="lineno"> 4095 </span><span class="spaces">      </span><span class="nottickedoff">-- reflexivity.</span>
<span class="lineno"> 4096 </span><span class="spaces">      </span><span class="nottickedoff">implWithoutTracingM (implPushOrReflMultiM perms_in) &gt;&gt;&gt;</span>
<span class="lineno"> 4097 </span><span class="spaces">      </span><span class="nottickedoff">pure (PermImpl_Done $</span>
<span class="lineno"> 4098 </span><span class="spaces">            </span><span class="nottickedoff">TypedJumpTarget siteID Proxy (mkCruCtx args_tps) perms_in)</span></span>
<span class="lineno"> 4099 </span>
<span class="lineno"> 4100 </span>
<span class="lineno"> 4101 </span>-- | Type-check a termination statement
<span class="lineno"> 4102 </span>tcTermStmt :: PermCheckExtC ext exprExt =&gt; CtxTrans ctx -&gt;
<span class="lineno"> 4103 </span>              TermStmt cblocks ret ctx -&gt;
<span class="lineno"> 4104 </span>              StmtPermCheckM ext cblocks blocks tops (gouts :&gt; ret) RNil RNil
<span class="lineno"> 4105 </span>              (TypedTermStmt blocks tops (gouts :&gt; ret) RNil)
<span class="lineno"> 4106 </span><span class="decl"><span class="nottickedoff">tcTermStmt ctx (Jump tgt) =</span>
<span class="lineno"> 4107 </span><span class="spaces">  </span><span class="nottickedoff">TypedJump &lt;$&gt; tcJumpTarget ctx tgt</span>
<span class="lineno"> 4108 </span><span class="spaces"></span><span class="nottickedoff">tcTermStmt ctx (Br reg tgt1 tgt2) =</span>
<span class="lineno"> 4109 </span><span class="spaces">  </span><span class="nottickedoff">-- FIXME: Instead of mapping Br to TypedJump when the jump target is known,</span>
<span class="lineno"> 4110 </span><span class="spaces">  </span><span class="nottickedoff">-- make a version of TypedBr that still stores the JumpTargets of never-taken</span>
<span class="lineno"> 4111 </span><span class="spaces">  </span><span class="nottickedoff">-- branches in order to allow translating back to untyped Crucible</span>
<span class="lineno"> 4112 </span><span class="spaces">  </span><span class="nottickedoff">let treg = tcReg ctx reg in</span>
<span class="lineno"> 4113 </span><span class="spaces">  </span><span class="nottickedoff">getRegEqualsExpr treg &gt;&gt;&gt;= \treg_expr -&gt;</span>
<span class="lineno"> 4114 </span><span class="spaces">  </span><span class="nottickedoff">case treg_expr of</span>
<span class="lineno"> 4115 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Bool True -&gt;</span>
<span class="lineno"> 4116 </span><span class="spaces">      </span><span class="nottickedoff">stmtTraceM (const $ pretty &quot;tcTermStmt: br reg known to be true!&quot;) &gt;&gt;</span>
<span class="lineno"> 4117 </span><span class="spaces">      </span><span class="nottickedoff">(TypedJump &lt;$&gt; tcJumpTarget ctx tgt1)</span>
<span class="lineno"> 4118 </span><span class="spaces">    </span><span class="nottickedoff">PExpr_Bool False -&gt;</span>
<span class="lineno"> 4119 </span><span class="spaces">      </span><span class="nottickedoff">stmtTraceM (const $ pretty &quot;tcTermStmt: br reg known to be false!&quot;) &gt;&gt;</span>
<span class="lineno"> 4120 </span><span class="spaces">      </span><span class="nottickedoff">(TypedJump &lt;$&gt; tcJumpTarget ctx tgt2)</span>
<span class="lineno"> 4121 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt;</span>
<span class="lineno"> 4122 </span><span class="spaces">      </span><span class="nottickedoff">stmtTraceM (const $ pretty</span>
<span class="lineno"> 4123 </span><span class="spaces">                  </span><span class="nottickedoff">&quot;tcTermStmt: br reg unknown, checking both branches...&quot;) &gt;&gt;</span>
<span class="lineno"> 4124 </span><span class="spaces">      </span><span class="nottickedoff">(TypedBr treg &lt;$&gt; tcJumpTarget ctx tgt1 &lt;*&gt; tcJumpTarget ctx tgt2)</span>
<span class="lineno"> 4125 </span><span class="spaces"></span><span class="nottickedoff">tcTermStmt ctx (Return reg) =</span>
<span class="lineno"> 4126 </span><span class="spaces">  </span><span class="nottickedoff">let ret_n = typedRegVar $ tcReg ctx reg in</span>
<span class="lineno"> 4127 </span><span class="spaces">  </span><span class="nottickedoff">get &gt;&gt;&gt;= \st -&gt;</span>
<span class="lineno"> 4128 </span><span class="spaces">  </span><span class="nottickedoff">top_get &gt;&gt;&gt;= \top_st -&gt;</span>
<span class="lineno"> 4129 </span><span class="spaces">  </span><span class="nottickedoff">let tops = stTopVars st</span>
<span class="lineno"> 4130 </span><span class="spaces">      </span><span class="nottickedoff">rets = stRetTypes top_st</span>
<span class="lineno"> 4131 </span><span class="spaces">      </span><span class="nottickedoff">CruCtxCons gouts _ = rets</span>
<span class="lineno"> 4132 </span><span class="spaces">      </span><span class="nottickedoff">mb_ret_perms =</span>
<span class="lineno"> 4133 </span><span class="spaces">        </span><span class="nottickedoff">give (cruCtxProxies rets) $</span>
<span class="lineno"> 4134 </span><span class="spaces">        </span><span class="nottickedoff">varSubst (permVarSubstOfNames tops) $</span>
<span class="lineno"> 4135 </span><span class="spaces">        </span><span class="nottickedoff">mbSeparate (cruCtxProxies rets) $</span>
<span class="lineno"> 4136 </span><span class="spaces">        </span><span class="nottickedoff">mbValuePermsToDistPerms (stRetPerms top_st)</span>
<span class="lineno"> 4137 </span><span class="spaces">      </span><span class="nottickedoff">mb_req_perms =</span>
<span class="lineno"> 4138 </span><span class="spaces">        </span><span class="nottickedoff">fmap (varSubst (singletonVarSubst ret_n)) $</span>
<span class="lineno"> 4139 </span><span class="spaces">        </span><span class="nottickedoff">mbSeparate (MNil :&gt;: Proxy) mb_ret_perms</span>
<span class="lineno"> 4140 </span><span class="spaces">      </span><span class="nottickedoff">err = ppProofError (stPPInfo st) &quot;Type-checking return statement&quot; mb_req_perms in</span>
<span class="lineno"> 4141 </span><span class="spaces">  </span><span class="nottickedoff">mapM (\(SomeName x) -&gt; ppRelevantPerms $ TypedReg x) (NameSet.toList $</span>
<span class="lineno"> 4142 </span><span class="spaces">                                                        </span><span class="nottickedoff">freeVars mb_req_perms)</span>
<span class="lineno"> 4143 </span><span class="spaces">  </span><span class="nottickedoff">&gt;&gt;&gt;= \pps_before -&gt;</span>
<span class="lineno"> 4144 </span><span class="spaces">  </span><span class="nottickedoff">stmtTraceM (\i -&gt;</span>
<span class="lineno"> 4145 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Type-checking return statement&quot; &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4146 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Current perms:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 4147 </span><span class="spaces">               </span><span class="nottickedoff">ppCommaSep pps_before &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4148 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Required perms:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 4149 </span><span class="spaces">               </span><span class="nottickedoff">permPretty i mb_req_perms) &gt;&gt;&gt;</span>
<span class="lineno"> 4150 </span><span class="spaces">  </span><span class="nottickedoff">TypedReturn &lt;$&gt;</span>
<span class="lineno"> 4151 </span><span class="spaces">  </span><span class="nottickedoff">pcmRunImplM gouts err</span>
<span class="lineno"> 4152 </span><span class="spaces">  </span><span class="nottickedoff">(\gouts_ns -&gt; TypedRet Refl rets (gouts_ns :&gt;: ret_n) mb_ret_perms)</span>
<span class="lineno"> 4153 </span><span class="spaces">  </span><span class="nottickedoff">(proveVarsImplVarEVars mb_req_perms)</span>
<span class="lineno"> 4154 </span><span class="spaces"></span><span class="nottickedoff">tcTermStmt ctx (ErrorStmt reg) =</span>
<span class="lineno"> 4155 </span><span class="spaces">  </span><span class="nottickedoff">let treg = tcReg ctx reg in</span>
<span class="lineno"> 4156 </span><span class="spaces">  </span><span class="nottickedoff">getRegPerm treg &gt;&gt;&gt;= \treg_p -&gt;</span>
<span class="lineno"> 4157 </span><span class="spaces">  </span><span class="nottickedoff">let maybe_str = case treg_p of</span>
<span class="lineno"> 4158 </span><span class="spaces">        </span><span class="nottickedoff">ValPerm_Eq (PExpr_String str) -&gt; Just str</span>
<span class="lineno"> 4159 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; Nothing in</span>
<span class="lineno"> 4160 </span><span class="spaces">  </span><span class="nottickedoff">pure $ TypedErrorStmt maybe_str treg</span>
<span class="lineno"> 4161 </span><span class="spaces"></span><span class="nottickedoff">tcTermStmt _ tstmt =</span>
<span class="lineno"> 4162 </span><span class="spaces">  </span><span class="nottickedoff">error (&quot;tcTermStmt: unhandled termination statement: &quot;</span>
<span class="lineno"> 4163 </span><span class="spaces">         </span><span class="nottickedoff">++ show (pretty tstmt))</span></span>
<span class="lineno"> 4164 </span>
<span class="lineno"> 4165 </span>
<span class="lineno"> 4166 </span>----------------------------------------------------------------------
<span class="lineno"> 4167 </span>-- * Permission Checking for Blocks and Sequences of Statements
<span class="lineno"> 4168 </span>----------------------------------------------------------------------
<span class="lineno"> 4169 </span>
<span class="lineno"> 4170 </span>-- | Translate and emit a Crucible statement sequence, starting and ending with
<span class="lineno"> 4171 </span>-- an empty stack of distinguished permissions
<span class="lineno"> 4172 </span>tcEmitStmtSeq ::
<span class="lineno"> 4173 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 4174 </span>  [Maybe String] -&gt;
<span class="lineno"> 4175 </span>  CtxTrans ctx -&gt;
<span class="lineno"> 4176 </span>  StmtSeq ext cblocks ret ctx -&gt;
<span class="lineno"> 4177 </span>  PermCheckM ext cblocks blocks tops (gouts :&gt; ret)
<span class="lineno"> 4178 </span>    () RNil
<span class="lineno"> 4179 </span>    (TypedStmtSeq ext blocks tops (gouts :&gt; ret) RNil) RNil
<span class="lineno"> 4180 </span>    ()
<span class="lineno"> 4181 </span><span class="decl"><span class="nottickedoff">tcEmitStmtSeq names ctx (ConsStmt loc stmt stmts) =</span>
<span class="lineno"> 4182 </span><span class="spaces">  </span><span class="nottickedoff">setErrorPrefix names loc (ppStmt (Ctx.size ctx) stmt) ctx (stmtInputRegs stmt) &gt;&gt;&gt;</span>
<span class="lineno"> 4183 </span><span class="spaces">  </span><span class="nottickedoff">tcEmitStmt ctx loc stmt &gt;&gt;&gt;= \ctx' -&gt; tcEmitStmtSeq names ctx' stmts</span>
<span class="lineno"> 4184 </span><span class="spaces"></span><span class="nottickedoff">tcEmitStmtSeq names ctx (TermStmt loc tstmt) =</span>
<span class="lineno"> 4185 </span><span class="spaces">  </span><span class="nottickedoff">setErrorPrefix names loc (pretty tstmt) ctx (termStmtRegs tstmt) &gt;&gt;&gt;</span>
<span class="lineno"> 4186 </span><span class="spaces">  </span><span class="nottickedoff">tcTermStmt ctx tstmt &gt;&gt;&gt;= \typed_tstmt -&gt;</span>
<span class="lineno"> 4187 </span><span class="spaces">  </span><span class="nottickedoff">gmapRet (&gt;&gt; return (TypedTermStmt loc typed_tstmt))</span></span>
<span class="lineno"> 4188 </span>
<span class="lineno"> 4189 </span>-- | Type-check the body of a Crucible block as the body of an entrypoint
<span class="lineno"> 4190 </span>tcBlockEntryBody ::
<span class="lineno"> 4191 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 4192 </span>  [Maybe String] -&gt;
<span class="lineno"> 4193 </span>  Block ext cblocks ret args -&gt;
<span class="lineno"> 4194 </span>  TypedEntry TCPhase ext blocks tops (gouts :&gt; ret) (CtxToRList args) ghosts -&gt;
<span class="lineno"> 4195 </span>  TopPermCheckM ext cblocks blocks tops (gouts :&gt; ret)
<span class="lineno"> 4196 </span>    (NamedMb ((tops :++: CtxToRList args) :++: ghosts)
<span class="lineno"> 4197 </span>      (TypedStmtSeq ext blocks tops (gouts :&gt; ret)
<span class="lineno"> 4198 </span>       ((tops :++: CtxToRList args) :++: ghosts)))
<span class="lineno"> 4199 </span><span class="decl"><span class="nottickedoff">tcBlockEntryBody names blk entry@(TypedEntry {..}) =</span>
<span class="lineno"> 4200 </span><span class="spaces">  </span><span class="nottickedoff">runPermCheckM names typedEntryID typedEntryArgs typedEntryGhosts typedEntryPermsIn $</span>
<span class="lineno"> 4201 </span><span class="spaces">  </span><span class="nottickedoff">\tops_ns args_ns ghosts_ns perms -&gt;</span>
<span class="lineno"> 4202 </span><span class="spaces">  </span><span class="nottickedoff">let ctx = mkCtxTrans (blockInputs blk) args_ns</span>
<span class="lineno"> 4203 </span><span class="spaces">      </span><span class="nottickedoff">ns = RL.append (RL.append tops_ns args_ns) ghosts_ns in</span>
<span class="lineno"> 4204 </span><span class="spaces">  </span><span class="nottickedoff">stmtTraceM (\i -&gt;</span>
<span class="lineno"> 4205 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Type-checking block&quot; &lt;+&gt; pretty (blockID blk) &lt;&gt;</span>
<span class="lineno"> 4206 </span><span class="spaces">               </span><span class="nottickedoff">comma &lt;+&gt; pretty &quot;entrypoint&quot; &lt;+&gt; pretty (entryIndex typedEntryID)</span>
<span class="lineno"> 4207 </span><span class="spaces">               </span><span class="nottickedoff">&lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4208 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Input types:&quot;</span>
<span class="lineno"> 4209 </span><span class="spaces">               </span><span class="nottickedoff">&lt;&gt; align (permPretty i $</span>
<span class="lineno"> 4210 </span><span class="spaces">                         </span><span class="nottickedoff">RL.map2 VarAndType ns $ cruCtxToTypes $</span>
<span class="lineno"> 4211 </span><span class="spaces">                         </span><span class="nottickedoff">typedEntryAllArgs entry)</span>
<span class="lineno"> 4212 </span><span class="spaces">               </span><span class="nottickedoff">&lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4213 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;Input perms:&quot;</span>
<span class="lineno"> 4214 </span><span class="spaces">               </span><span class="nottickedoff">&lt;&gt; align (permPretty i perms)) &gt;&gt;&gt;</span>
<span class="lineno"> 4215 </span><span class="spaces">  </span><span class="nottickedoff">-- handle unit variables</span>
<span class="lineno"> 4216 </span><span class="spaces">  </span><span class="nottickedoff">stmtHandleUnitVars ns &gt;&gt;&gt;</span>
<span class="lineno"> 4217 </span><span class="spaces">  </span><span class="nottickedoff">stmtRecombinePerms &gt;&gt;&gt;</span>
<span class="lineno"> 4218 </span><span class="spaces">  </span><span class="nottickedoff">tcEmitStmtSeq names ctx (blk ^. blockStmts)</span></span>
<span class="lineno"> 4219 </span>
<span class="lineno"> 4220 </span>rappend :: RAssign f x -&gt; RAssign f y -&gt; RAssign f (x :++: y)
<span class="lineno"> 4221 </span><span class="decl"><span class="nottickedoff">rappend xs (ys :&gt;: y) = rappend xs ys :&gt;: y</span>
<span class="lineno"> 4222 </span><span class="spaces"></span><span class="nottickedoff">rappend xs MNil = xs</span></span>
<span class="lineno"> 4223 </span>
<span class="lineno"> 4224 </span>-- | Prove that the permissions held at a call site from the given source
<span class="lineno"> 4225 </span>-- entrypoint imply the supplied input permissions of the current entrypoint
<span class="lineno"> 4226 </span>proveCallSiteImpl ::
<span class="lineno"> 4227 </span>  KnownRepr ExtRepr ext =&gt; TypedEntryID blocks some_args -&gt;
<span class="lineno"> 4228 </span>  TypedEntryID blocks args -&gt; CruCtx args -&gt; CruCtx ghosts -&gt; CruCtx vars -&gt;
<span class="lineno"> 4229 </span>  MbValuePerms ((tops :++: args) :++: vars) -&gt;
<span class="lineno"> 4230 </span>  MbValuePerms ((tops :++: args) :++: ghosts) -&gt;
<span class="lineno"> 4231 </span>  TopPermCheckM ext cblocks blocks tops rets (CallSiteImpl
<span class="lineno"> 4232 </span>                                              blocks
<span class="lineno"> 4233 </span>                                              ((tops :++: args) :++: vars)
<span class="lineno"> 4234 </span>                                              tops args ghosts)
<span class="lineno"> 4235 </span><span class="decl"><span class="nottickedoff">proveCallSiteImpl srcID destID args ghosts vars mb_perms_in mb_perms_out =</span>
<span class="lineno"> 4236 </span><span class="spaces">  </span><span class="nottickedoff">fmap (CallSiteImpl . _mbBinding) $ runPermCheckM [] srcID args vars mb_perms_in $</span>
<span class="lineno"> 4237 </span><span class="spaces">  </span><span class="nottickedoff">\tops_ns args_ns _ perms_in -&gt;</span>
<span class="lineno"> 4238 </span><span class="spaces">  </span><span class="nottickedoff">let ns = RL.append tops_ns args_ns</span>
<span class="lineno"> 4239 </span><span class="spaces">      </span><span class="nottickedoff">perms_out =</span>
<span class="lineno"> 4240 </span><span class="spaces">        </span><span class="nottickedoff">give (cruCtxProxies ghosts) $</span>
<span class="lineno"> 4241 </span><span class="spaces">        </span><span class="nottickedoff">varSubst (permVarSubstOfNames $ ns) $</span>
<span class="lineno"> 4242 </span><span class="spaces">        </span><span class="nottickedoff">mbSeparate (cruCtxProxies ghosts) $</span>
<span class="lineno"> 4243 </span><span class="spaces">        </span><span class="nottickedoff">mbValuePermsToDistPerms mb_perms_out in</span>
<span class="lineno"> 4244 </span><span class="spaces">  </span><span class="nottickedoff">stmtTraceM (\i -&gt;</span>
<span class="lineno"> 4245 </span><span class="spaces">               </span><span class="nottickedoff">pretty (&quot;proveCallSiteImpl, src = &quot; ++ show srcID ++</span>
<span class="lineno"> 4246 </span><span class="spaces">                       </span><span class="nottickedoff">&quot;, dest = &quot; ++ show destID) &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4247 </span><span class="spaces">               </span><span class="nottickedoff">indent 2 (permPretty i perms_in) &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4248 </span><span class="spaces">               </span><span class="nottickedoff">pretty &quot;-o&quot; &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4249 </span><span class="spaces">               </span><span class="nottickedoff">indent 2 (permPretty i perms_out)) &gt;&gt;&gt;</span>
<span class="lineno"> 4250 </span><span class="spaces">  </span><span class="nottickedoff">permGetPPInfo &gt;&gt;&gt;= \ppInfo -&gt;</span>
<span class="lineno"> 4251 </span><span class="spaces">  </span><span class="nottickedoff">let err = ppImplProofError ppInfo &quot;proveCallSiteImpl&quot; perms_in perms_out in</span>
<span class="lineno"> 4252 </span><span class="spaces">  </span><span class="nottickedoff">pcmRunImplM ghosts err</span>
<span class="lineno"> 4253 </span><span class="spaces">    </span><span class="nottickedoff">(CallSiteImplRet destID ghosts Refl tops_ns args_ns)</span>
<span class="lineno"> 4254 </span><span class="spaces">    </span><span class="nottickedoff">(handleUnitVars ns &gt;&gt;&gt;</span>
<span class="lineno"> 4255 </span><span class="spaces">     </span><span class="nottickedoff">recombinePerms perms_in &gt;&gt;&gt;</span>
<span class="lineno"> 4256 </span><span class="spaces">     </span><span class="nottickedoff">proveVarsImplVarEVars perms_out</span>
<span class="lineno"> 4257 </span><span class="spaces">     </span><span class="nottickedoff">) &gt;&gt;&gt;= \impl -&gt;</span>
<span class="lineno"> 4258 </span><span class="spaces">  </span><span class="nottickedoff">gmapRet (&gt;&gt; return impl)</span></span>
<span class="lineno"> 4259 </span>
<span class="lineno"> 4260 </span>
<span class="lineno"> 4261 </span>-- | Set the entrypoint ghost variables of a call site, erasing its implication
<span class="lineno"> 4262 </span>callSiteSetGhosts :: CruCtx ghosts' -&gt;
<span class="lineno"> 4263 </span>                     TypedCallSite TCPhase blocks tops args ghosts vars -&gt;
<span class="lineno"> 4264 </span>                     TypedCallSite TCPhase blocks tops args ghosts' vars
<span class="lineno"> 4265 </span><span class="decl"><span class="nottickedoff">callSiteSetGhosts _ (TypedCallSite {..}) =</span>
<span class="lineno"> 4266 </span><span class="spaces">  </span><span class="nottickedoff">TypedCallSite typedCallSiteID typedCallSitePerms Nothing</span></span>
<span class="lineno"> 4267 </span>
<span class="lineno"> 4268 </span>-- | Visit a call site, proving its implication of the entrypoint input
<span class="lineno"> 4269 </span>-- permissions if that implication does not already exist
<span class="lineno"> 4270 </span>visitCallSite ::
<span class="lineno"> 4271 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 4272 </span>  TypedEntry TCPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 4273 </span>  TypedCallSite TCPhase blocks tops args ghosts vars -&gt;
<span class="lineno"> 4274 </span>  TopPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 4275 </span>  (TypedCallSite TCPhase blocks tops args ghosts vars)
<span class="lineno"> 4276 </span><span class="decl"><span class="nottickedoff">visitCallSite _ site@(TypedCallSite { typedCallSiteImpl = Just _ }) =</span>
<span class="lineno"> 4277 </span><span class="spaces">  </span><span class="nottickedoff">return site</span>
<span class="lineno"> 4278 </span><span class="spaces"></span><span class="nottickedoff">visitCallSite (TypedEntry {..}) site@(TypedCallSite {..})</span>
<span class="lineno"> 4279 </span><span class="spaces">  </span><span class="nottickedoff">| TypedCallSiteID { callSiteSrc = srcID,</span>
<span class="lineno"> 4280 </span><span class="spaces">                      </span><span class="nottickedoff">callSiteVars = vars } &lt;- typedCallSiteID =</span>
<span class="lineno"> 4281 </span><span class="spaces">    </span><span class="nottickedoff">fmap (\impl -&gt; site { typedCallSiteImpl = Just impl }) $</span>
<span class="lineno"> 4282 </span><span class="spaces">    </span><span class="nottickedoff">proveCallSiteImpl srcID typedEntryID</span>
<span class="lineno"> 4283 </span><span class="spaces">    </span><span class="nottickedoff">typedEntryArgs typedEntryGhosts vars</span>
<span class="lineno"> 4284 </span><span class="spaces">    </span><span class="nottickedoff">typedCallSitePerms typedEntryPermsIn</span></span>
<span class="lineno"> 4285 </span>
<span class="lineno"> 4286 </span>-- | Widen the permissions held by all callers of an entrypoint to compute new,
<span class="lineno"> 4287 </span>-- weaker input permissions that can hopefully be satisfied by them
<span class="lineno"> 4288 </span>widenEntry :: PermCheckExtC ext exprExt =&gt; DebugLevel -&gt; PermEnv -&gt;
<span class="lineno"> 4289 </span>              TypedEntry TCPhase ext blocks tops rets args ghosts -&gt;
<span class="lineno"> 4290 </span>              Some (TypedEntry TCPhase ext blocks tops rets args)
<span class="lineno"> 4291 </span><span class="decl"><span class="nottickedoff">widenEntry dlevel env (TypedEntry {..}) =</span>
<span class="lineno"> 4292 </span><span class="spaces">  </span><span class="nottickedoff">debugTraceTraceLvl dlevel (&quot;Widening entrypoint: &quot; ++ show typedEntryID) $</span>
<span class="lineno"> 4293 </span><span class="spaces">  </span><span class="nottickedoff">case foldl1' (widen dlevel env typedEntryTops typedEntryArgs) $</span>
<span class="lineno"> 4294 </span><span class="spaces">       </span><span class="nottickedoff">map (fmapF typedCallSiteArgVarPerms) typedEntryCallers of</span>
<span class="lineno"> 4295 </span><span class="spaces">    </span><span class="nottickedoff">Some (ArgVarPerms (ghosts :: CruCtx x) perms_in) -&gt;</span>
<span class="lineno"> 4296 </span><span class="spaces">      </span><span class="nottickedoff">let callers =</span>
<span class="lineno"> 4297 </span><span class="spaces">            </span><span class="nottickedoff">map (fmapF (callSiteSetGhosts ghosts)) typedEntryCallers</span>
<span class="lineno"> 4298 </span><span class="spaces">      </span><span class="nottickedoff">in</span>
<span class="lineno"> 4299 </span><span class="spaces">      </span><span class="nottickedoff">Some $</span>
<span class="lineno"> 4300 </span><span class="spaces">      </span><span class="nottickedoff">TypedEntry { typedEntryCallers = callers, typedEntryGhosts = ghosts,</span>
<span class="lineno"> 4301 </span><span class="spaces">                   </span><span class="nottickedoff">typedEntryPermsIn = perms_in, typedEntryBody = Nothing,</span>
<span class="lineno"> 4302 </span><span class="spaces">                   </span><span class="nottickedoff">.. }</span></span>
<span class="lineno"> 4303 </span>
<span class="lineno"> 4304 </span>-- | Visit an entrypoint, by first proving the required implications at each
<span class="lineno"> 4305 </span>-- call site, meaning that the permissions held at the call site imply the input
<span class="lineno"> 4306 </span>-- permissions of the entrypoint, and then type-checking the body of the block
<span class="lineno"> 4307 </span>-- with those input permissions, if it has not been type-checked already.
<span class="lineno"> 4308 </span>--
<span class="lineno"> 4309 </span>-- If any of the call site implications fail, and the input \&quot;can widen\&quot; flag
<span class="lineno"> 4310 </span>-- is 'True', recompute the entrypoint input permissions using widening.
<span class="lineno"> 4311 </span>visitEntry ::
<span class="lineno"> 4312 </span>  (PermCheckExtC ext exprExt, CtxToRList cargs ~ args, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 4313 </span>  [Maybe String] -&gt;
<span class="lineno"> 4314 </span>  Bool -&gt; Block ext cblocks ret cargs -&gt;
<span class="lineno"> 4315 </span>  TypedEntry TCPhase ext blocks tops (gouts :&gt; ret) args ghosts -&gt;
<span class="lineno"> 4316 </span>  TopPermCheckM ext cblocks blocks tops (gouts :&gt; ret)
<span class="lineno"> 4317 </span>  (Some (TypedEntry TCPhase ext blocks tops (gouts :&gt; ret) args))
<span class="lineno"> 4318 </span>
<span class="lineno"> 4319 </span>-- If the entry is already complete, do nothing
<span class="lineno"> 4320 </span><span class="decl"><span class="nottickedoff">visitEntry _ _ _ entry</span>
<span class="lineno"> 4321 </span><span class="spaces">  </span><span class="nottickedoff">| isJust $ completeTypedEntry entry =</span>
<span class="lineno"> 4322 </span><span class="spaces">    </span><span class="nottickedoff">(stDebugLevel &lt;$&gt; get) &gt;&gt;= \dlevel -&gt;</span>
<span class="lineno"> 4323 </span><span class="spaces">    </span><span class="nottickedoff">debugTraceTraceLvl dlevel (&quot;visitEntry &quot; ++ show (typedEntryID entry)</span>
<span class="lineno"> 4324 </span><span class="spaces">                               </span><span class="nottickedoff">++ &quot;: no change&quot;) $</span>
<span class="lineno"> 4325 </span><span class="spaces">    </span><span class="nottickedoff">return $ Some entry</span>
<span class="lineno"> 4326 </span><span class="spaces"></span><span class="nottickedoff">-- Otherwise, visit the call sites, widen if needed, and type-check the body</span>
<span class="lineno"> 4327 </span><span class="spaces"></span><span class="nottickedoff">visitEntry names can_widen blk entry =</span>
<span class="lineno"> 4328 </span><span class="spaces">  </span><span class="nottickedoff">(stDebugLevel &lt;$&gt; get) &gt;&gt;= \dlevel -&gt;</span>
<span class="lineno"> 4329 </span><span class="spaces">  </span><span class="nottickedoff">(stPermEnv &lt;$&gt; get) &gt;&gt;= \env -&gt;</span>
<span class="lineno"> 4330 </span><span class="spaces">  </span><span class="nottickedoff">debugTracePretty traceDebugLevel dlevel</span>
<span class="lineno"> 4331 </span><span class="spaces">  </span><span class="nottickedoff">(vsep [pretty (&quot;visitEntry &quot; ++ show (typedEntryID entry)</span>
<span class="lineno"> 4332 </span><span class="spaces">                 </span><span class="nottickedoff">++ &quot; with input perms:&quot;),</span>
<span class="lineno"> 4333 </span><span class="spaces">         </span><span class="nottickedoff">permPretty emptyPPInfo (typedEntryPermsIn entry)])</span>
<span class="lineno"> 4334 </span><span class="spaces">  </span><span class="nottickedoff">(return ()) &gt;&gt;= \() -&gt;</span>
<span class="lineno"> 4335 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno"> 4336 </span><span class="spaces">  </span><span class="nottickedoff">mapM (traverseF $</span>
<span class="lineno"> 4337 </span><span class="spaces">        </span><span class="nottickedoff">visitCallSite entry) (typedEntryCallers entry) &gt;&gt;= \callers -&gt;</span>
<span class="lineno"> 4338 </span><span class="spaces">  </span><span class="nottickedoff">debugTraceTraceLvl dlevel (&quot;can_widen: &quot; ++ show can_widen ++ &quot;, any_fails: &quot;</span>
<span class="lineno"> 4339 </span><span class="spaces">                             </span><span class="nottickedoff">++ show (any (anyF typedCallSiteImplFails) callers)) $</span>
<span class="lineno"> 4340 </span><span class="spaces">  </span><span class="nottickedoff">if can_widen &amp;&amp; any (anyF typedCallSiteImplFails) callers then</span>
<span class="lineno"> 4341 </span><span class="spaces">    </span><span class="nottickedoff">case widenEntry dlevel env entry of</span>
<span class="lineno"> 4342 </span><span class="spaces">      </span><span class="nottickedoff">Some entry' -&gt;</span>
<span class="lineno"> 4343 </span><span class="spaces">        </span><span class="nottickedoff">-- If we widen then we are throwing away the old body, so all of its</span>
<span class="lineno"> 4344 </span><span class="spaces">        </span><span class="nottickedoff">-- callees are no longer needed and can be deleted</span>
<span class="lineno"> 4345 </span><span class="spaces">        </span><span class="nottickedoff">modifying stBlockMap (deleteEntryCallees $ typedEntryID entry) &gt;&gt;</span>
<span class="lineno"> 4346 </span><span class="spaces">        </span><span class="nottickedoff">visitEntry names False blk entry'</span>
<span class="lineno"> 4347 </span><span class="spaces">  </span><span class="nottickedoff">else</span>
<span class="lineno"> 4348 </span><span class="spaces">    </span><span class="nottickedoff">if isJust (typedEntryBody entry) then</span>
<span class="lineno"> 4349 </span><span class="spaces">      </span><span class="nottickedoff">-- If the body was complete when we started and we are not widening, there</span>
<span class="lineno"> 4350 </span><span class="spaces">      </span><span class="nottickedoff">-- is no reason to re-type-check the body, so just update the callers</span>
<span class="lineno"> 4351 </span><span class="spaces">      </span><span class="nottickedoff">return $ Some $ entry { typedEntryCallers = callers }</span>
<span class="lineno"> 4352 </span><span class="spaces">    </span><span class="nottickedoff">else</span>
<span class="lineno"> 4353 </span><span class="spaces">      </span><span class="nottickedoff">do body &lt;- maybe (tcBlockEntryBody names blk entry) return (typedEntryBody entry)</span>
<span class="lineno"> 4354 </span><span class="spaces">         </span><span class="nottickedoff">return $ Some $ entry { typedEntryCallers = callers,</span>
<span class="lineno"> 4355 </span><span class="spaces">                                 </span><span class="nottickedoff">typedEntryBody = Just body</span>
<span class="lineno"> 4356 </span><span class="spaces">                                </span><span class="nottickedoff">}</span></span>
<span class="lineno"> 4357 </span>
<span class="lineno"> 4358 </span>
<span class="lineno"> 4359 </span>-- | Visit a block by visiting all its entrypoints
<span class="lineno"> 4360 </span>visitBlock ::
<span class="lineno"> 4361 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext) =&gt;
<span class="lineno"> 4362 </span>  Bool {- ^ Whether widening can be applied in type-checking this block -} -&gt;
<span class="lineno"> 4363 </span>  TypedBlock TCPhase ext blocks tops rets args -&gt;
<span class="lineno"> 4364 </span>  TopPermCheckM ext cblocks blocks tops rets
<span class="lineno"> 4365 </span>  (TypedBlock TCPhase ext blocks tops rets args)
<span class="lineno"> 4366 </span><span class="decl"><span class="nottickedoff">visitBlock can_widen blk@(TypedBlock {..}) =</span>
<span class="lineno"> 4367 </span><span class="spaces">  </span><span class="nottickedoff">(stCBlocksEq &lt;$&gt; get) &gt;&gt;= \Refl -&gt;</span>
<span class="lineno"> 4368 </span><span class="spaces">  </span><span class="nottickedoff">flip (set typedBlockEntries) blk &lt;$&gt;</span>
<span class="lineno"> 4369 </span><span class="spaces">  </span><span class="nottickedoff">mapM (\(Some entry) -&gt;</span>
<span class="lineno"> 4370 </span><span class="spaces">         </span><span class="nottickedoff">visitEntry _typedBlockNames (can_widen &amp;&amp; typedBlockCanWiden)</span>
<span class="lineno"> 4371 </span><span class="spaces">         </span><span class="nottickedoff">typedBlockBlock entry)</span>
<span class="lineno"> 4372 </span><span class="spaces">  </span><span class="nottickedoff">_typedBlockEntries</span></span>
<span class="lineno"> 4373 </span>
<span class="lineno"> 4374 </span>-- | Flatten a list of topological ordering components to a list of nodes in
<span class="lineno"> 4375 </span>-- topological order paired with a flag denoting which nodes were loop heads
<span class="lineno"> 4376 </span>wtoCompsToListWithSCCs :: [WTOComponent n] -&gt; [(n, Bool)]
<span class="lineno"> 4377 </span><span class="decl"><span class="nottickedoff">wtoCompsToListWithSCCs =</span>
<span class="lineno"> 4378 </span><span class="spaces">  </span><span class="nottickedoff">concatMap (\case</span>
<span class="lineno"> 4379 </span><span class="spaces">                </span><span class="nottickedoff">Vertex n -&gt; [(n,False)]</span>
<span class="lineno"> 4380 </span><span class="spaces">                </span><span class="nottickedoff">SCC comps -&gt; [(wtoHead comps,True)] ++ wtoCompsToListWithSCCs (wtoComps comps))</span></span>
<span class="lineno"> 4381 </span>
<span class="lineno"> 4382 </span>-- | Build a topologically sorted list of 'BlockID's for a 'CFG', along with a
<span class="lineno"> 4383 </span>-- flag for each 'BlockID' indicating whether it is the head of a loop
<span class="lineno"> 4384 </span>cfgOrderWithSCCs :: CFG ext blocks init ret -&gt;
<span class="lineno"> 4385 </span>                    ([Some (BlockID blocks)], Assignment (Constant Bool) blocks)
<span class="lineno"> 4386 </span><span class="decl"><span class="nottickedoff">cfgOrderWithSCCs cfg =</span>
<span class="lineno"> 4387 </span><span class="spaces">  </span><span class="nottickedoff">let nodes_sccs = wtoCompsToListWithSCCs $ cfgWeakTopologicalOrdering cfg in</span>
<span class="lineno"> 4388 </span><span class="spaces">  </span><span class="nottickedoff">(map fst nodes_sccs,</span>
<span class="lineno"> 4389 </span><span class="spaces">   </span><span class="nottickedoff">foldr (\(Some blkID, is_scc) -&gt;</span>
<span class="lineno"> 4390 </span><span class="spaces">           </span><span class="nottickedoff">set (ixF $ blockIDIndex blkID) $ Constant is_scc)</span>
<span class="lineno"> 4391 </span><span class="spaces">   </span><span class="nottickedoff">(fmapFC (const $ Constant False) $ cfgBlockMap cfg)</span>
<span class="lineno"> 4392 </span><span class="spaces">   </span><span class="nottickedoff">nodes_sccs)</span></span>
<span class="lineno"> 4393 </span>
<span class="lineno"> 4394 </span>-- | The maximum number of iterations through the CFG while we allow widening
<span class="lineno"> 4395 </span>-- when type-checking before we give up and force everything to be done
<span class="lineno"> 4396 </span>maxWideningIters :: Int
<span class="lineno"> 4397 </span><span class="decl"><span class="nottickedoff">maxWideningIters = 5</span></span>
<span class="lineno"> 4398 </span>
<span class="lineno"> 4399 </span>-- | Type-check a Crucible CFG
<span class="lineno"> 4400 </span>tcCFG ::
<span class="lineno"> 4401 </span>  forall w ext cblocks ghosts inits gouts ret exprExt.
<span class="lineno"> 4402 </span>  (PermCheckExtC ext exprExt, KnownRepr ExtRepr ext, 1 &lt;= w, 16 &lt;= w) =&gt;
<span class="lineno"> 4403 </span>  NatRepr w -&gt;
<span class="lineno"> 4404 </span>  PermEnv -&gt; EndianForm -&gt; DebugLevel -&gt;
<span class="lineno"> 4405 </span>  FunPerm ghosts (CtxToRList inits) gouts ret -&gt;
<span class="lineno"> 4406 </span>  CFG ext cblocks inits ret -&gt;
<span class="lineno"> 4407 </span>  TypedCFG ext (CtxCtxToRList cblocks) ghosts (CtxToRList inits) gouts ret
<span class="lineno"> 4408 </span><span class="decl"><span class="nottickedoff">tcCFG w env endianness dlevel fun_perm cfg =</span>
<span class="lineno"> 4409 </span><span class="spaces">  </span><span class="nottickedoff">let h = cfgHandle cfg</span>
<span class="lineno"> 4410 </span><span class="spaces">      </span><span class="nottickedoff">ghosts = funPermGhosts fun_perm</span>
<span class="lineno"> 4411 </span><span class="spaces">      </span><span class="nottickedoff">gouts = funPermGouts fun_perm</span>
<span class="lineno"> 4412 </span><span class="spaces">      </span><span class="nottickedoff">(nodes, sccs) = cfgOrderWithSCCs cfg</span>
<span class="lineno"> 4413 </span><span class="spaces">      </span><span class="nottickedoff">init_st =</span>
<span class="lineno"> 4414 </span><span class="spaces">        </span><span class="nottickedoff">let ?ptrWidth = w in</span>
<span class="lineno"> 4415 </span><span class="spaces">        </span><span class="nottickedoff">emptyTopPermCheckState env fun_perm endianness dlevel cfg sccs</span>
<span class="lineno"> 4416 </span><span class="spaces">      </span><span class="nottickedoff">tp_nodes = map (\(Some blkID) -&gt;</span>
<span class="lineno"> 4417 </span><span class="spaces">                       </span><span class="nottickedoff">Some $ stLookupBlockID blkID init_st) nodes in</span>
<span class="lineno"> 4418 </span><span class="spaces">  </span><span class="nottickedoff">let tp_blk_map =</span>
<span class="lineno"> 4419 </span><span class="spaces">        </span><span class="nottickedoff">flip evalState init_st $ main_loop maxWideningIters tp_nodes in</span>
<span class="lineno"> 4420 </span><span class="spaces">  </span><span class="nottickedoff">TypedCFG { tpcfgHandle = TypedFnHandle ghosts gouts h</span>
<span class="lineno"> 4421 </span><span class="spaces">           </span><span class="nottickedoff">, tpcfgFunPerm = fun_perm</span>
<span class="lineno"> 4422 </span><span class="spaces">           </span><span class="nottickedoff">, tpcfgBlockMap = tp_blk_map</span>
<span class="lineno"> 4423 </span><span class="spaces">           </span><span class="nottickedoff">, tpcfgEntryID =</span>
<span class="lineno"> 4424 </span><span class="spaces">               </span><span class="nottickedoff">TypedEntryID (stLookupBlockID (cfgEntryBlockID cfg) init_st) 0 }</span>
<span class="lineno"> 4425 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno"> 4426 </span><span class="spaces">    </span><span class="nottickedoff">main_loop :: Int -&gt;</span>
<span class="lineno"> 4427 </span><span class="spaces">                 </span><span class="nottickedoff">[Some (TypedBlockID blocks :: RList CrucibleType -&gt; Type)] -&gt;</span>
<span class="lineno"> 4428 </span><span class="spaces">                 </span><span class="nottickedoff">TopPermCheckM ext cblocks blocks tops rets</span>
<span class="lineno"> 4429 </span><span class="spaces">                 </span><span class="nottickedoff">(TypedBlockMap TransPhase ext blocks tops rets)</span>
<span class="lineno"> 4430 </span><span class="spaces">    </span><span class="nottickedoff">main_loop rem_iters _</span>
<span class="lineno"> 4431 </span><span class="spaces">      </span><span class="nottickedoff">-- We may have to iterate through the CFG twice with widening turned off</span>
<span class="lineno"> 4432 </span><span class="spaces">      </span><span class="nottickedoff">-- to finally get everything to quiesce, once to ensure all block bodies</span>
<span class="lineno"> 4433 </span><span class="spaces">      </span><span class="nottickedoff">-- have type-checked and once again to ensure any back edged produced in</span>
<span class="lineno"> 4434 </span><span class="spaces">      </span><span class="nottickedoff">-- that last iteration have completed</span>
<span class="lineno"> 4435 </span><span class="spaces">      </span><span class="nottickedoff">| rem_iters &lt; -2 = error &quot;tcCFG: failed to complete on last iteration&quot;</span>
<span class="lineno"> 4436 </span><span class="spaces">    </span><span class="nottickedoff">main_loop rem_iters nodes =</span>
<span class="lineno"> 4437 </span><span class="spaces">      </span><span class="nottickedoff">get &gt;&gt;= \st -&gt;</span>
<span class="lineno"> 4438 </span><span class="spaces">      </span><span class="nottickedoff">case completeTypedBlockMap $ view stBlockMap st of</span>
<span class="lineno"> 4439 </span><span class="spaces">        </span><span class="nottickedoff">Just blkMapOut -&gt; return blkMapOut</span>
<span class="lineno"> 4440 </span><span class="spaces">        </span><span class="nottickedoff">Nothing -&gt;</span>
<span class="lineno"> 4441 </span><span class="spaces">          </span><span class="nottickedoff">forM_ nodes (\(Some tpBlkID) -&gt;</span>
<span class="lineno"> 4442 </span><span class="spaces">                        </span><span class="nottickedoff">let memb = typedBlockIDMember tpBlkID in</span>
<span class="lineno"> 4443 </span><span class="spaces">                        </span><span class="nottickedoff">use (stBlockMap . member memb) &gt;&gt;=</span>
<span class="lineno"> 4444 </span><span class="spaces">                        </span><span class="nottickedoff">(visitBlock (rem_iters &gt; 0) &gt;=&gt;</span>
<span class="lineno"> 4445 </span><span class="spaces">                         </span><span class="nottickedoff">assign (stBlockMap . member memb))) &gt;&gt;</span>
<span class="lineno"> 4446 </span><span class="spaces">          </span><span class="nottickedoff">main_loop (rem_iters - 1) nodes</span></span>
<span class="lineno"> 4447 </span>
<span class="lineno"> 4448 </span>--------------------------------------------------------------------------------
<span class="lineno"> 4449 </span>-- Error handling and logging
<span class="lineno"> 4450 </span>
<span class="lineno"> 4451 </span>data StmtError where
<span class="lineno"> 4452 </span>  AtomicPermError :: Doc ann -&gt; Doc ann -&gt; StmtError
<span class="lineno"> 4453 </span>  RegisterConversionError
<span class="lineno"> 4454 </span>    :: (Show tp1, Show tp2)
<span class="lineno"> 4455 </span>    =&gt; Doc ann -&gt; tp1 -&gt; tp2 -&gt; StmtError
<span class="lineno"> 4456 </span>  FailedAssertionError :: StmtError
<span class="lineno"> 4457 </span>  NonZeroPointerBlockError :: Doc ann -&gt; StmtError
<span class="lineno"> 4458 </span>  UndefinedBehaviorError :: Doc () -&gt; StmtError
<span class="lineno"> 4459 </span>  X86ExprError :: StmtError
<span class="lineno"> 4460 </span>  AllocaError :: AllocaErrorType -&gt; StmtError
<span class="lineno"> 4461 </span>  PopFrameError :: StmtError
<span class="lineno"> 4462 </span>  LoadHandleError :: StmtError
<span class="lineno"> 4463 </span>  ResolveGlobalError :: GlobalSymbol -&gt; StmtError
<span class="lineno"> 4464 </span>  PointerComparisonError :: Doc ann -&gt; Doc ann -&gt; StmtError
<span class="lineno"> 4465 </span>
<span class="lineno"> 4466 </span>data AllocaErrorType where
<span class="lineno"> 4467 </span>  AllocaNonConstantError :: Doc ann -&gt; AllocaErrorType
<span class="lineno"> 4468 </span>  AllocaFramePermError :: Doc ann -&gt; Doc ann -&gt; AllocaErrorType
<span class="lineno"> 4469 </span>  AllocaFramePtrError :: AllocaErrorType
<span class="lineno"> 4470 </span>
<span class="lineno"> 4471 </span>instance ErrorPretty StmtError where
<span class="lineno"> 4472 </span>  <span class="decl"><span class="nottickedoff">ppError (AtomicPermError r p) = renderDoc $</span>
<span class="lineno"> 4473 </span><span class="spaces">    </span><span class="nottickedoff">sep [pretty &quot;getAtomicOrWordLLVMPerms:&quot;,</span>
<span class="lineno"> 4474 </span><span class="spaces">         </span><span class="nottickedoff">pretty &quot;Needed atomic permissions for&quot; &lt;+&gt; r,</span>
<span class="lineno"> 4475 </span><span class="spaces">         </span><span class="nottickedoff">pretty &quot;but found&quot; &lt;+&gt; p]</span>
<span class="lineno"> 4476 </span><span class="spaces">  </span><span class="nottickedoff">ppError (RegisterConversionError docx tp1 tp2) = renderDoc $</span>
<span class="lineno"> 4477 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;Could not cast&quot; &lt;+&gt; docx &lt;+&gt;</span>
<span class="lineno"> 4478 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;from&quot; &lt;+&gt; pretty (show tp1) &lt;+&gt;</span>
<span class="lineno"> 4479 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;to&quot; &lt;+&gt; pretty (show tp2)</span>
<span class="lineno"> 4480 </span><span class="spaces">  </span><span class="nottickedoff">ppError FailedAssertionError =</span>
<span class="lineno"> 4481 </span><span class="spaces">    </span><span class="nottickedoff">&quot;Failed assertion&quot;</span>
<span class="lineno"> 4482 </span><span class="spaces">  </span><span class="nottickedoff">ppError (NonZeroPointerBlockError tblk_reg) = renderDoc $</span>
<span class="lineno"> 4483 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;LLVM_PointerExpr: Non-zero pointer block: &quot; &lt;&gt; tblk_reg</span>
<span class="lineno"> 4484 </span><span class="spaces">  </span><span class="nottickedoff">ppError (UndefinedBehaviorError doc) =</span>
<span class="lineno"> 4485 </span><span class="spaces">    </span><span class="nottickedoff">renderDoc doc</span>
<span class="lineno"> 4486 </span><span class="spaces">  </span><span class="nottickedoff">ppError X86ExprError =</span>
<span class="lineno"> 4487 </span><span class="spaces">    </span><span class="nottickedoff">&quot;X86Expr not supported&quot;</span>
<span class="lineno"> 4488 </span><span class="spaces">  </span><span class="nottickedoff">ppError (AllocaError (AllocaNonConstantError sz_treg)) = renderDoc $</span>
<span class="lineno"> 4489 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;LLVM_Alloca: non-constant size for&quot; &lt;+&gt;</span>
<span class="lineno"> 4490 </span><span class="spaces">    </span><span class="nottickedoff">sz_treg</span>
<span class="lineno"> 4491 </span><span class="spaces">  </span><span class="nottickedoff">ppError (AllocaError (AllocaFramePermError fp p)) = renderDoc $</span>
<span class="lineno"> 4492 </span><span class="spaces">    </span><span class="nottickedoff">pretty &quot;LLVM_Alloca: expected LLVM frame perm for &quot; &lt;+&gt;</span>
<span class="lineno"> 4493 </span><span class="spaces">    </span><span class="nottickedoff">fp &lt;&gt; pretty &quot;, found perm&quot; &lt;+&gt; p</span>
<span class="lineno"> 4494 </span><span class="spaces">  </span><span class="nottickedoff">ppError (AllocaError AllocaFramePtrError) =</span>
<span class="lineno"> 4495 </span><span class="spaces">    </span><span class="nottickedoff">&quot;LLVM_Alloca: no frame pointer set&quot;</span>
<span class="lineno"> 4496 </span><span class="spaces">  </span><span class="nottickedoff">ppError PopFrameError =</span>
<span class="lineno"> 4497 </span><span class="spaces">    </span><span class="nottickedoff">&quot;LLVM_PopFrame: no frame perms&quot;</span>
<span class="lineno"> 4498 </span><span class="spaces">  </span><span class="nottickedoff">ppError LoadHandleError =</span>
<span class="lineno"> 4499 </span><span class="spaces">    </span><span class="nottickedoff">&quot;LLVM_LoadHandle: no function pointer perms&quot;</span>
<span class="lineno"> 4500 </span><span class="spaces">  </span><span class="nottickedoff">ppError (ResolveGlobalError gsym) =</span>
<span class="lineno"> 4501 </span><span class="spaces">    </span><span class="nottickedoff">&quot;LLVM_ResolveGlobal: no perms for global &quot; ++</span>
<span class="lineno"> 4502 </span><span class="spaces">    </span><span class="nottickedoff">globalSymbolName gsym</span>
<span class="lineno"> 4503 </span><span class="spaces">  </span><span class="nottickedoff">ppError (PointerComparisonError x1 x2) = renderDoc $</span>
<span class="lineno"> 4504 </span><span class="spaces">    </span><span class="nottickedoff">sep [ pretty &quot;Could not compare LLVM pointer values&quot;</span>
<span class="lineno"> 4505 </span><span class="spaces">        </span><span class="nottickedoff">, x1, pretty &quot;and&quot;, x2 ]</span></span>
<span class="lineno"> 4506 </span>
<span class="lineno"> 4507 </span>
<span class="lineno"> 4508 </span>-- | Get the current 'PPInfo'
<span class="lineno"> 4509 </span>permGetPPInfo :: PermCheckM ext cblocks blocks tops ret r ps r ps PPInfo
<span class="lineno"> 4510 </span><span class="decl"><span class="nottickedoff">permGetPPInfo = gets stPPInfo</span></span>
<span class="lineno"> 4511 </span>
<span class="lineno"> 4512 </span>-- | Get the current prefix string to give context to error messages
<span class="lineno"> 4513 </span>getErrorPrefix :: PermCheckM ext cblocks blocks tops ret r ps r ps (Doc ())
<span class="lineno"> 4514 </span><span class="decl"><span class="nottickedoff">getErrorPrefix = gets (fromMaybe emptyDoc . stErrPrefix)</span></span>
<span class="lineno"> 4515 </span>
<span class="lineno"> 4516 </span>-- | Failure in the statement permission-checking monad
<span class="lineno"> 4517 </span>stmtFailM :: StmtError -&gt; PermCheckM ext cblocks blocks tops ret r1 ps1
<span class="lineno"> 4518 </span>             (TypedStmtSeq ext blocks tops ret ps2) ps2 a
<span class="lineno"> 4519 </span><span class="decl"><span class="nottickedoff">stmtFailM err =</span>
<span class="lineno"> 4520 </span><span class="spaces">  </span><span class="nottickedoff">getErrorPrefix &gt;&gt;&gt;= \err_prefix -&gt;</span>
<span class="lineno"> 4521 </span><span class="spaces">  </span><span class="nottickedoff">stmtTraceM (const $ err_prefix &lt;&gt; line &lt;&gt;</span>
<span class="lineno"> 4522 </span><span class="spaces">                </span><span class="nottickedoff">pretty &quot;Type-checking failure:&quot; &lt;&gt; softline &lt;&gt;</span>
<span class="lineno"> 4523 </span><span class="spaces">                </span><span class="nottickedoff">pretty (ppError err)) &gt;&gt;&gt;= \str -&gt;</span>
<span class="lineno"> 4524 </span><span class="spaces">  </span><span class="nottickedoff">gabortM (return $ TypedImplStmt $ AnnotPermImpl str $</span>
<span class="lineno"> 4525 </span><span class="spaces">           </span><span class="nottickedoff">PermImpl_Step (Impl1_Fail $ GeneralError (pretty &quot;&quot;)) MbPermImpls_Nil)</span></span>

</pre>
</body>
</html>
